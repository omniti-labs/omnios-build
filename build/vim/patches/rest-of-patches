To: vim_dev@googlegroups.com
Subject: Patch 8.0.0015
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0015
Problem:    Can't tell which part of a channel has "buffered" status.
Solution:   Add an optional argument to ch_status().  Let ch_info() also
            return "buffered" for out_status and err_status.
Files:      src/evalfunc.c, src/channel.c, src/proto/channel.pro,
            src/testdir/test_channel.vim, runtime/doc/eval.txt


*** ../vim-8.0.0014/src/evalfunc.c	2016-09-25 21:44:59.441600148 +0200
--- src/evalfunc.c	2016-09-26 22:03:14.961368676 +0200
***************
*** 514,520 ****
      {"ch_sendexpr",	2, 3, f_ch_sendexpr},
      {"ch_sendraw",	2, 3, f_ch_sendraw},
      {"ch_setoptions",	2, 2, f_ch_setoptions},
!     {"ch_status",	1, 1, f_ch_status},
  #endif
      {"changenr",	0, 0, f_changenr},
      {"char2nr",		1, 2, f_char2nr},
--- 514,520 ----
      {"ch_sendexpr",	2, 3, f_ch_sendexpr},
      {"ch_sendraw",	2, 3, f_ch_sendraw},
      {"ch_setoptions",	2, 2, f_ch_setoptions},
!     {"ch_status",	1, 2, f_ch_status},
  #endif
      {"changenr",	0, 0, f_changenr},
      {"char2nr",		1, 2, f_char2nr},
***************
*** 1985,1997 ****
  f_ch_status(typval_T *argvars, typval_T *rettv)
  {
      channel_T	*channel;
  
      /* return an empty string by default */
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = NULL;
  
      channel = get_channel_arg(&argvars[0], FALSE, FALSE, 0);
!     rettv->vval.v_string = vim_strsave((char_u *)channel_status(channel));
  }
  #endif
  
--- 1985,2008 ----
  f_ch_status(typval_T *argvars, typval_T *rettv)
  {
      channel_T	*channel;
+     jobopt_T	opt;
+     int		part = -1;
  
      /* return an empty string by default */
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = NULL;
  
      channel = get_channel_arg(&argvars[0], FALSE, FALSE, 0);
! 
!     if (argvars[1].v_type != VAR_UNKNOWN)
!     {
! 	clear_job_options(&opt);
! 	if (get_job_options(&argvars[1], &opt, JO_PART) == OK
! 						     && (opt.jo_set & JO_PART))
! 	    part = opt.jo_part;
!     }
! 
!     rettv->vval.v_string = vim_strsave((char_u *)channel_status(channel, part));
  }
  #endif
  
*** ../vim-8.0.0014/src/channel.c	2016-09-07 23:15:55.000000000 +0200
--- src/channel.c	2016-09-26 22:19:18.270706785 +0200
***************
*** 2590,2612 ****
  
  /*
   * Return a string indicating the status of the channel.
   */
      char *
! channel_status(channel_T *channel)
  {
      int part;
      int has_readahead = FALSE;
  
      if (channel == NULL)
  	 return "fail";
!     if (channel_is_open(channel))
! 	 return "open";
!     for (part = PART_SOCK; part <= PART_ERR; ++part)
! 	if (channel_has_readahead(channel, part))
! 	{
  	    has_readahead = TRUE;
! 	    break;
! 	}
  
      if (has_readahead)
  	return "buffered";
--- 2590,2630 ----
  
  /*
   * Return a string indicating the status of the channel.
+  * If "req_part" is not negative check that part.
   */
      char *
! channel_status(channel_T *channel, int req_part)
  {
      int part;
      int has_readahead = FALSE;
  
      if (channel == NULL)
  	 return "fail";
!     if (req_part == PART_OUT)
!     {
! 	if (channel->CH_OUT_FD != INVALID_FD)
! 	    return "open";
! 	if (channel_has_readahead(channel, PART_OUT))
  	    has_readahead = TRUE;
!     }
!     else if (req_part == PART_ERR)
!     {
! 	if (channel->CH_ERR_FD != INVALID_FD)
! 	    return "open";
! 	if (channel_has_readahead(channel, PART_ERR))
! 	    has_readahead = TRUE;
!     }
!     else
!     {
! 	if (channel_is_open(channel))
! 	    return "open";
! 	for (part = PART_SOCK; part <= PART_ERR; ++part)
! 	    if (channel_has_readahead(channel, part))
! 	    {
! 		has_readahead = TRUE;
! 		break;
! 	    }
!     }
  
      if (has_readahead)
  	return "buffered";
***************
*** 2619,2624 ****
--- 2637,2643 ----
      chanpart_T *chanpart = &channel->ch_part[part];
      char	namebuf[20];  /* longest is "sock_timeout" */
      size_t	tail;
+     char	*status;
      char	*s = "";
  
      vim_strncpy((char_u *)namebuf, (char_u *)name, 4);
***************
*** 2626,2633 ****
      tail = STRLEN(namebuf);
  
      STRCPY(namebuf + tail, "status");
!     dict_add_nr_str(dict, namebuf, 0,
! 		(char_u *)(chanpart->ch_fd == INVALID_FD ? "closed" : "open"));
  
      STRCPY(namebuf + tail, "mode");
      switch (chanpart->ch_mode)
--- 2645,2657 ----
      tail = STRLEN(namebuf);
  
      STRCPY(namebuf + tail, "status");
!     if (chanpart->ch_fd != INVALID_FD)
! 	status = "open";
!     else if (channel_has_readahead(channel, part))
! 	status = "buffered";
!     else
! 	status = "closed";
!     dict_add_nr_str(dict, namebuf, 0, (char_u *)status);
  
      STRCPY(namebuf + tail, "mode");
      switch (chanpart->ch_mode)
***************
*** 2660,2666 ****
  channel_info(channel_T *channel, dict_T *dict)
  {
      dict_add_nr_str(dict, "id", channel->ch_id, NULL);
!     dict_add_nr_str(dict, "status", 0, (char_u *)channel_status(channel));
  
      if (channel->ch_hostname != NULL)
      {
--- 2684,2690 ----
  channel_info(channel_T *channel, dict_T *dict)
  {
      dict_add_nr_str(dict, "id", channel->ch_id, NULL);
!     dict_add_nr_str(dict, "status", 0, (char_u *)channel_status(channel, -1));
  
      if (channel->ch_hostname != NULL)
      {
***************
*** 4244,4249 ****
--- 4268,4275 ----
  		val = get_tv_string(item);
  		if (STRCMP(val, "err") == 0)
  		    opt->jo_part = PART_ERR;
+ 		else if (STRCMP(val, "out") == 0)
+ 		    opt->jo_part = PART_OUT;
  		else
  		{
  		    EMSG2(_(e_invarg2), val);
*** ../vim-8.0.0014/src/proto/channel.pro	2016-09-12 13:04:24.000000000 +0200
--- src/proto/channel.pro	2016-09-26 22:14:54.376537165 +0200
***************
*** 24,30 ****
  int channel_collapse(channel_T *channel, int part, int want_nl);
  int channel_can_write_to(channel_T *channel);
  int channel_is_open(channel_T *channel);
! char *channel_status(channel_T *channel);
  void channel_info(channel_T *channel, dict_T *dict);
  void channel_close(channel_T *channel, int invoke_close_cb);
  void channel_close_in(channel_T *channel);
--- 24,30 ----
  int channel_collapse(channel_T *channel, int part, int want_nl);
  int channel_can_write_to(channel_T *channel);
  int channel_is_open(channel_T *channel);
! char *channel_status(channel_T *channel, int req_part);
  void channel_info(channel_T *channel, dict_T *dict);
  void channel_close(channel_T *channel, int invoke_close_cb);
  void channel_close_in(channel_T *channel);
*** ../vim-8.0.0014/src/testdir/test_channel.vim	2016-09-07 23:23:56.000000000 +0200
--- src/testdir/test_channel.vim	2016-09-26 22:34:36.352321622 +0200
***************
*** 434,439 ****
--- 434,456 ----
    let job = job_start(s:python . " test_channel_pipe.py", {'mode': 'raw'})
    call assert_equal(v:t_job, type(job))
    call assert_equal("run", job_status(job))
+ 
+   call assert_equal("open", ch_status(job))
+   call assert_equal("open", ch_status(job), {"part": "out"})
+   call assert_equal("open", ch_status(job), {"part": "err"})
+   call assert_fails('call ch_status(job, {"in_mode": "raw"})', 'E475:')
+   call assert_fails('call ch_status(job, {"part": "in"})', 'E475:')
+ 
+   let dict = ch_info(job)
+   call assert_true(dict.id != 0)
+   call assert_equal('open', dict.status)
+   call assert_equal('open', dict.out_status)
+   call assert_equal('RAW', dict.out_mode)
+   call assert_equal('pipe', dict.out_io)
+   call assert_equal('open', dict.err_status)
+   call assert_equal('RAW', dict.err_mode)
+   call assert_equal('pipe', dict.err_io)
+ 
    try
      " For a change use the job where a channel is expected.
      call ch_sendraw(job, "echo something\n")
*** ../vim-8.0.0014/runtime/doc/eval.txt	2016-09-12 12:45:25.000000000 +0200
--- runtime/doc/eval.txt	2016-09-26 22:24:12.284664360 +0200
***************
*** 2030,2036 ****
  				any	send {string} over raw {handle}
  ch_setoptions({handle}, {options})
  				none	set options for {handle}
! ch_status({handle})		String	status of channel {handle}
  changenr()			Number	current change number
  char2nr({expr}[, {utf8}])	Number	ASCII/UTF8 value of first char in {expr}
  cindent({lnum})			Number	C indent for line {lnum}
--- 2031,2038 ----
  				any	send {string} over raw {handle}
  ch_setoptions({handle}, {options})
  				none	set options for {handle}
! ch_status({handle} [, {options}])
! 				String	status of channel {handle}
  changenr()			Number	current change number
  char2nr({expr}[, {utf8}])	Number	ASCII/UTF8 value of first char in {expr}
  cindent({lnum})			Number	C indent for line {lnum}
***************
*** 3041,3047 ****
  		Returns a Dictionary with information about {handle}.  The
  		items are:
  		   "id"		  number of the channel
! 		   "status"	  "open" (any part is open) or "closed"
  		When opened with ch_open():
  		   "hostname"	  the hostname of the address
  		   "port"	  the port of the address
--- 3043,3050 ----
  		Returns a Dictionary with information about {handle}.  The
  		items are:
  		   "id"		  number of the channel
! 		   "status"	  "open", "buffered" or "closed", like
! 				  ch_status()
  		When opened with ch_open():
  		   "hostname"	  the hostname of the address
  		   "port"	  the port of the address
***************
*** 3050,3060 ****
  		   "sock_io"	  "socket"
  		   "sock_timeout" timeout in msec
  		When opened with job_start():
! 		   "out_status"	  "open" or "closed"
  		   "out_mode"	  "NL", "RAW", "JSON" or "JS"
  		   "out_io"	  "null", "pipe", "file" or "buffer"
  		   "out_timeout"  timeout in msec
! 		   "err_status"	  "open" or "closed"
  		   "err_mode"	  "NL", "RAW", "JSON" or "JS"
  		   "err_io"	  "out", "null", "pipe", "file" or "buffer"
  		   "err_timeout"  timeout in msec
--- 3053,3063 ----
  		   "sock_io"	  "socket"
  		   "sock_timeout" timeout in msec
  		When opened with job_start():
! 		   "out_status"	  "open", "buffered" or "closed"
  		   "out_mode"	  "NL", "RAW", "JSON" or "JS"
  		   "out_io"	  "null", "pipe", "file" or "buffer"
  		   "out_timeout"  timeout in msec
! 		   "err_status"	  "open", "buffered" or "closed"
  		   "err_mode"	  "NL", "RAW", "JSON" or "JS"
  		   "err_io"	  "out", "null", "pipe", "file" or "buffer"
  		   "err_timeout"  timeout in msec
***************
*** 3139,3145 ****
  		These options cannot be changed:
  			"waittime"	only applies to |ch_open()|
  
! ch_status({handle})						*ch_status()*
  		Return the status of {handle}:
  			"fail"		failed to open the channel
  			"open"		channel can be used
--- 3142,3148 ----
  		These options cannot be changed:
  			"waittime"	only applies to |ch_open()|
  
! ch_status({handle} [, {options}])				*ch_status()*
  		Return the status of {handle}:
  			"fail"		failed to open the channel
  			"open"		channel can be used
***************
*** 3149,3154 ****
--- 3152,3162 ----
  		"buffered" is used when the channel was closed but there is
  		still data that can be obtained with |ch_read()|.
  
+ 		If {options} is given it can contain a "part" entry to specify
+ 		the part of the channel to return the status for: "out" or
+ 		"err".  For example, to get the error status: >
+ 			ch_status(job, {"part": "err"})
+ <
  							*copy()*
  copy({expr})	Make a copy of {expr}.  For Numbers and Strings this isn't
  		different from using {expr} directly.
*** ../vim-8.0.0014/src/version.c	2016-09-26 20:14:49.925906743 +0200
--- src/version.c	2016-09-26 22:15:39.060227458 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     15,
  /**/

-- 
"A mouse can be just as dangerous as a bullet or a bomb."
             (US Representative Lamar Smith, R-Texas)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0016
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0016 (after 8.0.0015)
Problem:    Build fails.
Solution:   Include missing change.
Files:      src/eval.c


*** ../vim-8.0.0015/src/eval.c	2016-08-29 22:42:20.000000000 +0200
--- src/eval.c	2016-09-26 22:57:29.622842295 +0200
***************
*** 7305,7311 ****
  #ifdef FEAT_JOB_CHANNEL
  	    {
  		channel_T *channel = varp->vval.v_channel;
! 		char      *status = channel_status(channel);
  
  		if (channel == NULL)
  		    vim_snprintf((char *)buf, NUMBUFLEN, "channel %s", status);
--- 7305,7311 ----
  #ifdef FEAT_JOB_CHANNEL
  	    {
  		channel_T *channel = varp->vval.v_channel;
! 		char      *status = channel_status(channel, -1);
  
  		if (channel == NULL)
  		    vim_snprintf((char *)buf, NUMBUFLEN, "channel %s", status);
*** ../vim-8.0.0015/src/version.c	2016-09-26 22:36:50.619386344 +0200
--- src/version.c	2016-09-26 22:58:00.882626187 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     16,
  /**/

-- 
Nothing is impossible for the man who doesn't have to do it.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0017
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0017
Problem:    Cannot get the number of the current quickfix or location list.
Solution:   Use the current list if "nr" in "what" is zero. (Yegappan
            Lakshmanan)  Remove debug command from test.
Files:      src/quickfix.c, src/testdir/test_quickfix.vim,
            runtime/doc/eval.txt


*** ../vim-8.0.0016/src/quickfix.c	2016-09-25 21:44:59.445600117 +0200
--- src/quickfix.c	2016-09-27 21:27:48.729788268 +0200
***************
*** 4591,4599 ****
  	/* Use the specified quickfix/location list */
  	if (di->di_tv.v_type == VAR_NUMBER)
  	{
! 	    qf_idx = di->di_tv.vval.v_number - 1;
! 	    if (qf_idx < 0 || qf_idx >= qi->qf_listcount)
! 		return FAIL;
  	    flags |= QF_GETLIST_NR;
  	}
  	else
--- 4591,4603 ----
  	/* Use the specified quickfix/location list */
  	if (di->di_tv.v_type == VAR_NUMBER)
  	{
! 	    /* for zero use the current list */
! 	    if (di->di_tv.vval.v_number != 0)
! 	    {
! 		qf_idx = di->di_tv.vval.v_number - 1;
! 		if (qf_idx < 0 || qf_idx >= qi->qf_listcount)
! 		    return FAIL;
! 	    }
  	    flags |= QF_GETLIST_NR;
  	}
  	else
*** ../vim-8.0.0016/src/testdir/test_quickfix.vim	2016-09-01 15:39:30.000000000 +0200
--- src/testdir/test_quickfix.vim	2016-09-27 21:22:51.671854368 +0200
***************
*** 1429,1440 ****
    laddexpr 'one.txt:3:one one one'
  
    let loc_one = getloclist(one_id)
- echo string(loc_one)
    call assert_equal('Xone/a/one.txt', bufname(loc_one[1].bufnr))
    call assert_equal(3, loc_one[1].lnum)
  
    let loc_two = getloclist(two_id)
- echo string(loc_two)
    call assert_equal('Xtwo/a/two.txt', bufname(loc_two[1].bufnr))
    call assert_equal(5, loc_two[1].lnum)
  
--- 1429,1438 ----
***************
*** 1534,1539 ****
--- 1532,1542 ----
      call assert_equal('N1', g:Xgetlist({'all':1}).title)
      call g:Xsetlist([], ' ', {'title' : 'N2'})
      call assert_equal(qfnr + 1, g:Xgetlist({'all':1}).nr)
+ 
+     let res = g:Xgetlist({'nr': 0})
+     call assert_equal(qfnr + 1, res.nr)
+     call assert_equal(['nr'], keys(res))
+ 
      call g:Xsetlist([], ' ', {'title' : 'N3'})
      call assert_equal('N2', g:Xgetlist({'nr':2, 'title':1}).title)
  
***************
*** 1546,1552 ****
      call assert_equal({}, g:Xgetlist({'abc':1}))
  
      if a:cchar == 'l'
! 	call assert_equal({}, getloclist(99, ['title']))
      endif
  endfunction
  
--- 1549,1555 ----
      call assert_equal({}, g:Xgetlist({'abc':1}))
  
      if a:cchar == 'l'
! 	call assert_equal({}, getloclist(99, {'title': 1}))
      endif
  endfunction
  
*** ../vim-8.0.0016/runtime/doc/eval.txt	2016-09-26 22:36:50.619386344 +0200
--- runtime/doc/eval.txt	2016-09-27 21:14:57.863151829 +0200
***************
*** 4510,4516 ****
  		If the optional {what} dictionary argument is supplied, then
  		returns only the items listed in {what} as a dictionary. The
  		following string items are supported in {what}:
! 			nr	get information for this quickfix list
  			title	get the list title
  			winid	get the |window-ID| (if opened)
  			all	all of the above quickfix properties
--- 4516,4523 ----
  		If the optional {what} dictionary argument is supplied, then
  		returns only the items listed in {what} as a dictionary. The
  		following string items are supported in {what}:
! 			nr	get information for this quickfix list; zero
! 				means the current quickfix list
  			title	get the list title
  			winid	get the |window-ID| (if opened)
  			all	all of the above quickfix properties
*** ../vim-8.0.0016/src/version.c	2016-09-26 22:58:54.498255420 +0200
--- src/version.c	2016-09-27 21:17:23.714136503 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     17,
  /**/

-- 
This is the polymorph virus!  Follow these instructions carefully:
1. Send this message to everybody you know.
2. Format your harddisk.
Thank you for your cooperation in spreading the most powerful virus ever!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0018
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0018
Problem:    When using ":sleep" channel input is not handled.
Solution:   When there is a channel check for input also when not in raw mode.
            Check every 100 msec.
Files:      src/channel.c, src/proto/channel.pro, src/ui.c, src/proto/ui.pro,
            src/ex_docmd.c, src/os_amiga.c, src/proto/os_amiga.pro,
            src/os_unix.c, src/proto/os_unix.pro, src/os_win32.c,
            src/proto/os_win32.pro


*** ../vim-8.0.0017/src/channel.c	2016-09-26 22:36:50.615386371 +0200
--- src/channel.c	2016-09-29 15:12:13.482556346 +0200
***************
*** 341,346 ****
--- 341,352 ----
      return channel;
  }
  
+     int
+ has_any_channel(void)
+ {
+     return first_channel != NULL;
+ }
+ 
  /*
   * Called when the refcount of a channel is zero.
   * Return TRUE if "channel" has a callback and the associated job wasn't
*** ../vim-8.0.0017/src/proto/channel.pro	2016-09-26 22:36:50.615386371 +0200
--- src/proto/channel.pro	2016-09-29 14:59:14.620048830 +0200
***************
*** 4,9 ****
--- 4,10 ----
  void ch_log(channel_T *ch, char *msg);
  void ch_logs(channel_T *ch, char *msg, char *name);
  channel_T *add_channel(void);
+ int has_any_channel(void);
  int channel_unref(channel_T *channel);
  int free_unused_channels_contents(int copyID, int mask);
  void free_unused_channels(int copyID, int mask);
*** ../vim-8.0.0017/src/ui.c	2016-08-29 22:42:20.000000000 +0200
--- src/ui.c	2016-09-29 15:06:26.753000044 +0200
***************
*** 353,364 ****
      void
  ui_breakcheck(void)
  {
  #ifdef FEAT_GUI
      if (gui.in_use)
  	gui_mch_update();
      else
  #endif
! 	mch_breakcheck();
  }
  
  /*****************************************************************************
--- 353,374 ----
      void
  ui_breakcheck(void)
  {
+     ui_breakcheck_force(FALSE);
+ }
+ 
+ /*
+  * When "force" is true also check when the terminal is not in raw mode.
+  * This is useful to read input on channels.
+  */
+     void
+ ui_breakcheck_force(int force)
+ {
  #ifdef FEAT_GUI
      if (gui.in_use)
  	gui_mch_update();
      else
  #endif
! 	mch_breakcheck(force);
  }
  
  /*****************************************************************************
*** ../vim-8.0.0017/src/proto/ui.pro	2016-09-12 13:04:21.000000000 +0200
--- src/proto/ui.pro	2016-09-29 15:06:34.028948742 +0200
***************
*** 10,15 ****
--- 10,16 ----
  void ui_set_shellsize(int mustset);
  void ui_new_shellsize(void);
  void ui_breakcheck(void);
+ void ui_breakcheck_force(int force);
  void clip_init(int can_use);
  void clip_update_selection(VimClipboard *clip);
  void clip_own_selection(VimClipboard *cbd);
*** ../vim-8.0.0017/src/ex_docmd.c	2016-09-11 14:36:00.000000000 +0200
--- src/ex_docmd.c	2016-09-29 15:06:48.532846478 +0200
***************
*** 9065,9072 ****
  		wait_now = due_time;
  	}
  #endif
  	ui_delay(wait_now, TRUE);
! 	ui_breakcheck();
  #ifdef MESSAGE_QUEUE
  	/* Process the netbeans and clientserver messages that may have been
  	 * received in the call to ui_breakcheck() when the GUI is in use. This
--- 9065,9081 ----
  		wait_now = due_time;
  	}
  #endif
+ #ifdef FEAT_JOB_CHANNEL
+ 	if (has_any_channel() && wait_now > 100L)
+ 	    wait_now = 100L;
+ #endif
  	ui_delay(wait_now, TRUE);
! #ifdef FEAT_JOB_CHANNEL
! 	if (has_any_channel())
! 	    ui_breakcheck_force(TRUE);
! 	else
! #endif
! 	    ui_breakcheck();
  #ifdef MESSAGE_QUEUE
  	/* Process the netbeans and clientserver messages that may have been
  	 * received in the call to ui_breakcheck() when the GUI is in use. This
*** ../vim-8.0.0017/src/os_amiga.c	2016-08-29 22:42:20.000000000 +0200
--- src/os_amiga.c	2016-09-29 15:07:57.060363361 +0200
***************
*** 1381,1387 ****
   * trouble with lattice-c programs.
   */
      void
! mch_breakcheck(void)
  {
     if (SetSignal(0L, (long)(SIGBREAKF_CTRL_C|SIGBREAKF_CTRL_D|SIGBREAKF_CTRL_E|SIGBREAKF_CTRL_F)) & SIGBREAKF_CTRL_C)
  	got_int = TRUE;
--- 1381,1387 ----
   * trouble with lattice-c programs.
   */
      void
! mch_breakcheck(int force)
  {
     if (SetSignal(0L, (long)(SIGBREAKF_CTRL_C|SIGBREAKF_CTRL_D|SIGBREAKF_CTRL_E|SIGBREAKF_CTRL_F)) & SIGBREAKF_CTRL_C)
  	got_int = TRUE;
*** ../vim-8.0.0017/src/proto/os_amiga.pro	2016-09-12 13:04:29.000000000 +0200
--- src/proto/os_amiga.pro	2016-09-29 15:08:16.240228159 +0200
***************
*** 36,42 ****
  void mch_set_shellsize(void);
  void mch_new_shellsize(void);
  int mch_call_shell(char_u *cmd, int options);
! void mch_breakcheck(void);
  long Chk_Abort(void);
  int mch_expandpath(garray_T *gap, char_u *pat, int flags);
  int mch_has_exp_wildcard(char_u *p);
--- 36,42 ----
  void mch_set_shellsize(void);
  void mch_new_shellsize(void);
  int mch_call_shell(char_u *cmd, int options);
! void mch_breakcheck(int force);
  long Chk_Abort(void);
  int mch_expandpath(garray_T *gap, char_u *pat, int flags);
  int mch_has_exp_wildcard(char_u *p);
*** ../vim-8.0.0017/src/os_unix.c	2016-08-29 22:42:20.000000000 +0200
--- src/os_unix.c	2016-09-29 15:12:37.530386938 +0200
***************
*** 5364,5372 ****
   * In cooked mode we should get SIGINT, no need to check.
   */
      void
! mch_breakcheck(void)
  {
!     if (curr_tmode == TMODE_RAW && RealWaitForChar(read_cmd_fd, 0L, NULL, NULL))
  	fill_input_buf(FALSE);
  }
  
--- 5364,5373 ----
   * In cooked mode we should get SIGINT, no need to check.
   */
      void
! mch_breakcheck(int force)
  {
!     if ((curr_tmode == TMODE_RAW || force)
! 			       && RealWaitForChar(read_cmd_fd, 0L, NULL, NULL))
  	fill_input_buf(FALSE);
  }
  
*** ../vim-8.0.0017/src/proto/os_unix.pro	2016-09-12 13:04:15.000000000 +0200
--- src/proto/os_unix.pro	2016-09-29 15:09:02.235903956 +0200
***************
*** 61,67 ****
  char *mch_job_status(job_T *job);
  int mch_stop_job(job_T *job, char_u *how);
  void mch_clear_job(job_T *job);
! void mch_breakcheck(void);
  int mch_expandpath(garray_T *gap, char_u *path, int flags);
  int mch_expand_wildcards(int num_pat, char_u **pat, int *num_file, char_u ***file, int flags);
  int mch_has_exp_wildcard(char_u *p);
--- 61,67 ----
  char *mch_job_status(job_T *job);
  int mch_stop_job(job_T *job, char_u *how);
  void mch_clear_job(job_T *job);
! void mch_breakcheck(int force);
  int mch_expandpath(garray_T *gap, char_u *path, int flags);
  int mch_expand_wildcards(int num_pat, char_u **pat, int *num_file, char_u ***file, int flags);
  int mch_has_exp_wildcard(char_u *p);
*** ../vim-8.0.0017/src/os_win32.c	2016-09-01 18:31:42.000000000 +0200
--- src/os_win32.c	2016-09-29 15:09:50.431564286 +0200
***************
*** 6187,6196 ****
  
  
  /*
!  * check for an "interrupt signal": CTRL-break or CTRL-C
   */
      void
! mch_breakcheck(void)
  {
  #ifndef FEAT_GUI_W32	    /* never used */
      if (g_fCtrlCPressed || g_fCBrkPressed)
--- 6187,6196 ----
  
  
  /*
!  * Check for an "interrupt signal": CTRL-break or CTRL-C.
   */
      void
! mch_breakcheck(int force)
  {
  #ifndef FEAT_GUI_W32	    /* never used */
      if (g_fCtrlCPressed || g_fCBrkPressed)
*** ../vim-8.0.0017/src/proto/os_win32.pro	2016-09-12 13:04:29.000000000 +0200
--- src/proto/os_win32.pro	2016-09-29 15:10:04.219467120 +0200
***************
*** 48,54 ****
  void mch_write(char_u *s, int len);
  void mch_delay(long msec, int ignoreinput);
  int mch_remove(char_u *name);
! void mch_breakcheck(void);
  long_u mch_total_mem(int special);
  int mch_wrename(WCHAR *wold, WCHAR *wnew);
  int mch_rename(const char *pszOldFile, const char *pszNewFile);
--- 48,54 ----
  void mch_write(char_u *s, int len);
  void mch_delay(long msec, int ignoreinput);
  int mch_remove(char_u *name);
! void mch_breakcheck(int force);
  long_u mch_total_mem(int special);
  int mch_wrename(WCHAR *wold, WCHAR *wnew);
  int mch_rename(const char *pszOldFile, const char *pszNewFile);
*** ../vim-8.0.0017/src/version.c	2016-09-27 21:28:52.905342034 +0200
--- src/version.c	2016-09-29 15:17:41.140258776 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     18,
  /**/

-- 
ARTHUR:  Well, I can't just call you `Man'.
DENNIS:  Well, you could say `Dennis'.
ARTHUR:  Well, I didn't know you were called `Dennis.'
DENNIS:  Well, you didn't bother to find out, did you?
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0019
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0019
Problem:    Test_command_count is old style.
Solution:   Turn it into a new style test. (Naruhiko Nishino)
            Use more assert functions.
Files:      src/Makefile, src/testdir/Make_all.mak, src/testdir/test_alot.vim,
            src/testdir/test_autocmd.vim, src/testdir/test_command_count.in,
            src/testdir/test_command_count.ok,
            src/testdir/test_command_count.vim


*** ../vim-8.0.0018/src/Makefile	2016-09-26 20:14:49.921906772 +0200
--- src/Makefile	2016-09-29 19:23:13.153274891 +0200
***************
*** 2028,2034 ****
  	test_breakindent \
  	test_changelist \
  	test_close_count \
- 	test_command_count \
  	test_comparators \
  	test_erasebackword \
  	test_eval \
--- 2028,2033 ----
***************
*** 2066,2071 ****
--- 2065,2071 ----
  	test_channel \
  	test_charsearch \
  	test_cmdline \
+ 	test_command_count \
  	test_crypt \
  	test_cscope \
  	test_cursor_func \
*** ../vim-8.0.0018/src/testdir/Make_all.mak	2016-09-26 20:14:49.921906772 +0200
--- src/testdir/Make_all.mak	2016-09-29 19:11:33.650159645 +0200
***************
*** 79,85 ****
  	test_breakindent.out \
  	test_changelist.out \
  	test_close_count.out \
- 	test_command_count.out \
  	test_comparators.out \
  	test_erasebackword.out \
  	test_eval.out \
--- 79,84 ----
*** ../vim-8.0.0018/src/testdir/test_alot.vim	2016-09-11 14:34:48.000000000 +0200
--- src/testdir/test_alot.vim	2016-09-29 19:11:33.650159645 +0200
***************
*** 3,8 ****
--- 3,9 ----
  
  source test_assign.vim
  source test_autocmd.vim
+ source test_command_count.vim
  source test_cursor_func.vim
  source test_delete.vim
  source test_execute_func.vim
*** ../vim-8.0.0018/src/testdir/test_autocmd.vim	2016-09-08 22:06:01.000000000 +0200
--- src/testdir/test_autocmd.vim	2016-09-29 19:11:33.650159645 +0200
***************
*** 1,5 ****
--- 1,13 ----
  " Tests for autocommands
  
+ function! s:cleanup_buffers() abort
+   for bnr in range(1, bufnr('$'))
+     if bufloaded(bnr) && bufnr('%') != bnr
+       execute 'bd! ' . bnr
+     endif
+   endfor
+ endfunction
+ 
  func Test_vim_did_enter()
    call assert_false(v:vim_did_enter)
  
***************
*** 254,259 ****
--- 262,270 ----
  " Tests for autocommands on :close command.
  " This used to be in test13.
  func Test_three_windows()
+   " Clean up buffers, because in some cases this function fails.
+   call s:cleanup_buffers()
+ 
    " Write three files and open them, each in a window.
    " Then go to next window, with autocommand that deletes the previous one.
    " Do this twice, writing the file.
*** ../vim-8.0.0018/src/testdir/test_command_count.in	2015-02-27 20:03:15.000000000 +0100
--- src/testdir/test_command_count.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,158 ****
- Test for user command counts	    vim: set ft=vim :
- 
- STARTTEST
- :so small.vim
- :lang C
- :let g:lines = []
- :com -range=% RangeLines :call add(g:lines, 'RangeLines '.<line1>.' '.<line2>)
- :com -range -addr=arguments RangeArguments :call add(g:lines, 'RangeArguments '.<line1>.' '.<line2>)
- :com -range=% -addr=arguments RangeArgumentsAll :call add(g:lines, 'RangeArgumentsAll '.<line1>.' '.<line2>)
- :com -range -addr=loaded_buffers RangeLoadedBuffers :call add(g:lines, 'RangeLoadedBuffers '.<line1>.' '.<line2>)
- :com -range=% -addr=loaded_buffers RangeLoadedBuffersAll :call add(g:lines, 'RangeLoadedBuffersAll '.<line1>.' '.<line2>)
- :com -range -addr=buffers RangeBuffers :call add(g:lines, 'RangeBuffers '.<line1>.' '.<line2>)
- :com -range=% -addr=buffers RangeBuffersAll :call add(g:lines, 'RangeBuffersAll '.<line1>.' '.<line2>)
- :com -range -addr=windows RangeWindows :call add(g:lines, 'RangeWindows '.<line1>.' '.<line2>)
- :com -range=% -addr=windows RangeWindowsAll :call add(g:lines, 'RangeWindowsAll '.<line1>.' '.<line2>)
- :com -range -addr=tabs RangeTabs :call add(g:lines, 'RangeTabs '.<line1>.' '.<line2>)
- :com -range=% -addr=tabs RangeTabsAll :call add(g:lines, 'RangeTabsAll '.<line1>.' '.<line2>)
- :set hidden
- :arga a b c d
- :argdo echo "loading buffers"
- :argu 3
- :.-,$-RangeArguments
- :%RangeArguments
- :RangeArgumentsAll
- :N
- :.RangeArguments
- :split|split|split|split
- :3wincmd w
- :.,$RangeWindows
- :%RangeWindows
- :RangeWindowsAll
- :only
- :blast|bd
- :.,$RangeLoadedBuffers
- :%RangeLoadedBuffers
- :RangeLoadedBuffersAll
- :.,$RangeBuffers
- :%RangeBuffers
- :RangeBuffersAll
- :tabe|tabe|tabe|tabe
- :normal 2gt
- :.,$RangeTabs
- :%RangeTabs
- :RangeTabsAll
- :1tabonly
- :s/\n/\r\r\r\r\r/
- :2ma<
- :$-ma>
- :'<,'>RangeLines
- :com -range=% -buffer LocalRangeLines :call add(g:lines, 'LocalRangeLines '.<line1>.' '.<line2>)
- :'<,'>LocalRangeLines
- :b1
- ENDTEST
- 
- STARTTEST
- :call add(g:lines, '')
- :%argd
- :arga a b c d
- :let v:errmsg = ''
- :5argu
- :call add(g:lines, '5argu ' . v:errmsg)
- :$argu
- :call add(g:lines, '4argu ' . expand('%:t'))
- :let v:errmsg = ''
- :1argu
- :call add(g:lines, '1argu ' . expand('%:t'))
- :let v:errmsg = ''
- :100b
- :call add(g:lines, '100b ' . v:errmsg)
- :split|split|split|split
- :let v:errmsg = ''
- :0close
- :call add(g:lines, '0close ' . v:errmsg)
- :$wincmd w
- :$close
- :call add(g:lines, '$close ' . winnr())
- :let v:errmsg = ''
- :$+close
- :call add(g:lines, '$+close ' . v:errmsg)
- :$tabe
- :call add(g:lines, '$tabe ' . tabpagenr())
- :let v:errmsg = ''
- :$+tabe
- :call add(g:lines, '$+tabe ' . v:errmsg)
- :only!
- :e x
- :0tabm
- :normal 1gt
- :call add(g:lines, '0tabm ' . expand('%:t'))
- :tabonly!
- :only!
- :e! test.out
- :call append(0, g:lines)
- :unlet g:lines
- :w|bd
- :b1
- ENDTEST
- 
- STARTTEST
- :let g:lines = []
- :func BufStatus()
- :  call add(g:lines, 'aaa: ' . buflisted(g:buf_aaa) . ' bbb: ' . buflisted(g:buf_bbb) . ' ccc: ' . buflisted(g:buf_ccc))
- :endfunc
- :se nohidden
- :e aaa
- :let buf_aaa = bufnr('%')
- :e bbb
- :let buf_bbb = bufnr('%')
- :e ccc
- :let buf_ccc = bufnr('%')
- :b1
- :call BufStatus()
- :exe buf_bbb . "," . buf_ccc . "bdelete"
- :call BufStatus()
- :exe buf_aaa . "bdelete"
- :call BufStatus()
- :e! test.out
- :call append('$', g:lines)
- :unlet g:lines
- :delfunc BufStatus
- :w|bd
- :b1
- ENDTEST
- 
- STARTTEST
- :se hidden
- :only!
- :let g:lines = []
- :%argd
- :arga a b c d e f
- :3argu
- :let args = ''
- :.,$-argdo let args .= ' '.expand('%')
- :call add(g:lines, 'argdo:' . args)
- :split|split|split|split
- :2wincmd w
- :let windows = ''
- :.,$-windo let windows .= ' '.winnr()
- :call add(g:lines, 'windo:'. windows)
- :b2
- :let buffers = ''
- :.,$-bufdo let buffers .= ' '.bufnr('%')
- :call add(g:lines, 'bufdo:' . buffers)
- :3bd
- :let buffers = ''
- :3,7bufdo let buffers .= ' '.bufnr('%')
- :call add(g:lines, 'bufdo:' . buffers)
- :tabe|tabe|tabe|tabe
- :normal! 2gt
- :let tabpages = ''
- :.,$-tabdo let tabpages .= ' '.tabpagenr()
- :call add(g:lines, 'tabdo:' . tabpages)
- :e! test.out
- :call append('$', g:lines)
- :w|qa!
- ENDTEST
- 
- 
--- 0 ----
*** ../vim-8.0.0018/src/testdir/test_command_count.ok	2015-02-27 20:03:15.000000000 +0100
--- src/testdir/test_command_count.ok	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,38 ****
- RangeArguments 2 4
- RangeArguments 1 5
- RangeArgumentsAll 1 5
- RangeArguments 2 2
- RangeWindows 3 5
- RangeWindows 1 5
- RangeWindowsAll 1 5
- RangeLoadedBuffers 2 4
- RangeLoadedBuffers 1 4
- RangeLoadedBuffersAll 1 4
- RangeBuffers 2 5
- RangeBuffers 1 5
- RangeBuffersAll 1 5
- RangeTabs 2 5
- RangeTabs 1 5
- RangeTabsAll 1 5
- RangeLines 2 5
- LocalRangeLines 2 5
- 
- 5argu E16: Invalid range
- 4argu d
- 1argu a
- 100b E16: Invalid range
- 0close 
- $close 3
- $+close E16: Invalid range
- $tabe 2
- $+tabe E16: Invalid range
- 0tabm x
- 
- aaa: 1 bbb: 1 ccc: 1
- aaa: 1 bbb: 0 ccc: 0
- aaa: 0 bbb: 0 ccc: 0
- argdo: c d e
- windo: 2 3 4
- bufdo: 2 3 4 5 6 7 8 9 10 15
- bufdo: 4 5 6 7
- tabdo: 2 3 4
--- 0 ----
*** ../vim-8.0.0018/src/testdir/test_command_count.vim	2016-09-29 20:53:54.971440078 +0200
--- src/testdir/test_command_count.vim	2016-09-29 20:49:32.317263612 +0200
***************
*** 0 ****
--- 1,191 ----
+ " Test for user command counts.
+ 
+ func Test_command_count_0()
+   set hidden
+   set noswapfile
+ 
+   split DoesNotExistEver
+   let lastbuf = bufnr('$')
+   call setline(1, 'asdf')
+   quit!
+ 
+   command! -range -addr=loaded_buffers RangeLoadedBuffers :let lines = [<line1>, <line2>]
+   command! -range=% -addr=loaded_buffers RangeLoadedBuffersAll :let lines = [<line1>, <line2>]
+   command! -range -addr=buffers RangeBuffers :let lines = [<line1>, <line2>]
+   command! -range=% -addr=buffers RangeBuffersAll :let lines = [<line1>, <line2>]
+ 
+   .,$RangeLoadedBuffers
+   call assert_equal([1, 1], lines)
+   %RangeLoadedBuffers
+   call assert_equal([1, 1], lines)
+   RangeLoadedBuffersAll
+   call assert_equal([1, 1], lines)
+   .,$RangeBuffers
+   call assert_equal([1, lastbuf], lines)
+   %RangeBuffers
+   call assert_equal([1, lastbuf], lines)
+   RangeBuffersAll
+   call assert_equal([1, lastbuf], lines)
+ 
+   delcommand RangeLoadedBuffers
+   delcommand RangeLoadedBuffersAll
+   delcommand RangeBuffers
+   delcommand RangeBuffersAll
+ 
+   set hidden&
+   set swapfile&
+ endfunc
+ 
+ func Test_command_count_1()
+   silent! %argd
+   arga a b c d e
+   argdo echo "loading buffers"
+   argu 3
+   command! -range -addr=arguments RangeArguments :let lines = [<line1>, <line2>]
+   command! -range=% -addr=arguments RangeArgumentsAll :let lines = [<line1>, <line2>]
+   .-,$-RangeArguments
+   call assert_equal([2, 4], lines)
+   %RangeArguments
+   call assert_equal([1, 5], lines)
+   RangeArgumentsAll
+   call assert_equal([1, 5], lines)
+   N
+   .RangeArguments
+   call assert_equal([2, 2], lines)
+   delcommand RangeArguments
+   delcommand RangeArgumentsAll
+ 
+   split|split|split|split
+   3wincmd w
+   command! -range -addr=windows RangeWindows :let lines = [<line1>, <line2>]
+   .,$RangeWindows
+   call assert_equal([3, 5], lines)
+   %RangeWindows
+   call assert_equal([1, 5], lines)
+   delcommand RangeWindows
+ 
+   command! -range=% -addr=windows RangeWindowsAll :let lines = [<line1>, <line2>]
+   RangeWindowsAll
+   call assert_equal([1, 5], lines)
+   delcommand RangeWindowsAll
+   only
+   blast|bd
+ 
+   tabe|tabe|tabe|tabe
+   normal 2gt
+   command! -range -addr=tabs RangeTabs :let lines = [<line1>, <line2>]
+   .,$RangeTabs
+   call assert_equal([2, 5], lines)
+   %RangeTabs
+   call assert_equal([1, 5], lines)
+   delcommand RangeTabs
+ 
+   command! -range=% -addr=tabs RangeTabsAll :let lines = [<line1>, <line2>]
+   RangeTabsAll
+   call assert_equal([1, 5], lines)
+   delcommand RangeTabsAll
+   1tabonly
+ 
+   s/\n/\r\r\r\r\r/
+   2ma<
+   $-ma>
+   command! -range=% RangeLines :let lines = [<line1>, <line2>]
+   '<,'>RangeLines
+   call assert_equal([2, 5], lines)
+   delcommand RangeLines
+ 
+   command! -range=% -buffer LocalRangeLines :let lines = [<line1>, <line2>]
+   '<,'>LocalRangeLines
+   call assert_equal([2, 5], lines)
+   delcommand LocalRangeLines
+ endfunc
+ 
+ func Test_command_count_2()
+   silent! %argd
+   arga a b c d
+   call assert_fails('5argu', 'E16:')
+ 
+   $argu
+   call assert_equal('d', expand('%:t'))
+ 
+   1argu
+   call assert_equal('a', expand('%:t'))
+ 
+   call assert_fails('300b', 'E16:')
+ 
+   split|split|split|split
+   0close
+ 
+   $wincmd w
+   $close
+   call assert_equal(3, winnr())
+ 
+   call assert_fails('$+close', 'E16:')
+ 
+   $tabe
+   call assert_equal(2, tabpagenr())
+ 
+   call assert_fails('$+tabe', 'E16:')
+ 
+   only!
+   e x
+   0tabm
+   normal 1gt
+   call assert_equal('x', expand('%:t'))
+ 
+   tabonly!
+   only!
+ endfunc
+ 
+ func Test_command_count_3()
+   se nohidden
+   e aaa
+   let buf_aaa = bufnr('%')
+   e bbb
+   let buf_bbb = bufnr('%')
+   e ccc
+   let buf_ccc = bufnr('%')
+   buf 1
+   call assert_equal([1, 1, 1], [buflisted(buf_aaa), buflisted(buf_bbb), buflisted(buf_ccc)])
+   exe buf_bbb . "," . buf_ccc . "bdelete"
+   call assert_equal([1, 0, 0], [buflisted(buf_aaa), buflisted(buf_bbb), buflisted(buf_ccc)])
+   exe buf_aaa . "bdelete"
+   call assert_equal([0, 0, 0], [buflisted(buf_aaa), buflisted(buf_bbb), buflisted(buf_ccc)])
+ endfunc
+ 
+ func Test_command_count_4()
+   %argd
+   let bufnr = bufnr('$') + 1
+   arga aa bb cc dd ee ff
+   3argu
+   let args = []
+   .,$-argdo call add(args, expand('%'))
+   call assert_equal(['cc', 'dd', 'ee'], args)
+ 
+   " create windows to get 5
+   split|split|split|split
+   2wincmd w
+   let windows = []
+   .,$-windo call add(windows, winnr())
+   call assert_equal([2, 3, 4], windows)
+   only!
+ 
+   exe bufnr . 'buf'
+   let buffers = []
+   .,$-bufdo call add(buffers, bufnr('%'))
+   call assert_equal([bufnr, bufnr + 1, bufnr + 2, bufnr + 3, bufnr + 4], buffers)
+ 
+   exe (bufnr + 3) . 'bdel'
+   let buffers = []
+   exe (bufnr + 2) . ',' . (bufnr + 5) . "bufdo call add(buffers, bufnr('%'))"
+   call assert_equal([bufnr + 2, bufnr + 4, bufnr +  5], buffers)
+ 
+   " create tabpages to get 5
+   tabe|tabe|tabe|tabe
+   normal! 2gt
+   let tabpages = []
+   .,$-tabdo call add(tabpages, tabpagenr())
+   call assert_equal([2, 3, 4], tabpages)
+   tabonly!
+   bwipe!
+ endfunc
*** ../vim-8.0.0018/src/version.c	2016-09-29 15:18:51.359768012 +0200
--- src/version.c	2016-09-29 20:50:17.684948652 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     19,
  /**/

-- 
A computer programmer is a device for turning requirements into
undocumented features.  It runs on cola, pizza and Dilbert cartoons.
					Bram Moolenaar

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0020
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0020
Problem:    The regexp engines are not reentrant.
Solution:   Add regexec_T and save/restore the state when needed.
Files:      src/regexp.c, src/regexp_nfa.c, src/testdir/test_expr.vim,
            runtime/doc/eval.txt, runtime/doc/change.txt


*** ../vim-8.0.0019/src/regexp.c	2016-09-09 20:20:20.000000000 +0200
--- src/regexp.c	2016-10-02 16:21:22.709068952 +0200
***************
*** 3509,3535 ****
  #endif
  
  /*
-  * Internal copy of 'ignorecase'.  It is set at each call to vim_regexec().
-  * Normally it gets the value of "rm_ic" or "rmm_ic", but when the pattern
-  * contains '\c' or '\C' the value is overruled.
-  */
- static int	ireg_ic;
- 
- #ifdef FEAT_MBYTE
- /*
-  * Similar to ireg_ic, but only for 'combining' characters.  Set with \Z flag
-  * in the regexp.  Defaults to false, always.
-  */
- static int	ireg_icombine;
- #endif
- 
- /*
-  * Copy of "rmm_maxcol": maximum column to search for a match.  Zero when
-  * there is no maximum.
-  */
- static colnr_T	ireg_maxcol;
- 
- /*
   * Sometimes need to save a copy of a line.  Since alloc()/free() is very
   * slow, we keep one allocated piece of memory and only re-allocate it when
   * it's too small.  It's freed in bt_regexec_both() when finished.
--- 3509,3514 ----
***************
*** 3538,3544 ****
  static unsigned	reg_tofreelen;
  
  /*
!  * These variables are set when executing a regexp to speed up the execution.
   * Which ones are set depends on whether a single-line or multi-line match is
   * done:
   *			single-line		multi-line
--- 3517,3523 ----
  static unsigned	reg_tofreelen;
  
  /*
!  * Structure used to store the execution state of the regex engine.
   * Which ones are set depends on whether a single-line or multi-line match is
   * done:
   *			single-line		multi-line
***************
*** 3554,3570 ****
   * reg_maxline		0			last line nr
   * reg_line_lbr		FALSE or TRUE		FALSE
   */
! static regmatch_T	*reg_match;
! static regmmatch_T	*reg_mmatch;
! static char_u		**reg_startp = NULL;
! static char_u		**reg_endp = NULL;
! static lpos_T		*reg_startpos = NULL;
! static lpos_T		*reg_endpos = NULL;
! static win_T		*reg_win;
! static buf_T		*reg_buf;
! static linenr_T		reg_firstlnum;
! static linenr_T		reg_maxline;
! static int		reg_line_lbr;	    /* "\n" in string is line break */
  
  /* Values for rs_state in regitem_T. */
  typedef enum regstate_E
--- 3533,3570 ----
   * reg_maxline		0			last line nr
   * reg_line_lbr		FALSE or TRUE		FALSE
   */
! typedef struct {
!     regmatch_T		*reg_match;
!     regmmatch_T		*reg_mmatch;
!     char_u		**reg_startp;
!     char_u		**reg_endp;
!     lpos_T		*reg_startpos;
!     lpos_T		*reg_endpos;
!     win_T		*reg_win;
!     buf_T		*reg_buf;
!     linenr_T		reg_firstlnum;
!     linenr_T		reg_maxline;
!     int			reg_line_lbr;	/* "\n" in string is line break */
! 
!     /* Internal copy of 'ignorecase'.  It is set at each call to vim_regexec().
!      * Normally it gets the value of "rm_ic" or "rmm_ic", but when the pattern
!      * contains '\c' or '\C' the value is overruled. */
!     int			reg_ic;
! 
! #ifdef FEAT_MBYTE
!     /* Similar to rex.reg_ic, but only for 'combining' characters.  Set with \Z
!      * flag in the regexp.  Defaults to false, always. */
!     int			reg_icombine;
! #endif
! 
!     /* Copy of "rmm_maxcol": maximum column to search for a match.  Zero when
!      * there is no maximum. */
!     colnr_T		reg_maxcol;
! } regexec_T;
! 
! static regexec_T	rex;
! static int		rex_in_use = FALSE;
! 
  
  /* Values for rs_state in regitem_T. */
  typedef enum regstate_E
***************
*** 3669,3680 ****
  {
      /* when looking behind for a match/no-match lnum is negative.  But we
       * can't go before line 1 */
!     if (reg_firstlnum + lnum < 1)
  	return NULL;
!     if (lnum > reg_maxline)
  	/* Must have matched the "\n" in the last line. */
  	return (char_u *)"";
!     return ml_get_buf(reg_buf, reg_firstlnum + lnum, FALSE);
  }
  
  static regsave_T behind_pos;
--- 3669,3680 ----
  {
      /* when looking behind for a match/no-match lnum is negative.  But we
       * can't go before line 1 */
!     if (rex.reg_firstlnum + lnum < 1)
  	return NULL;
!     if (lnum > rex.reg_maxline)
  	/* Must have matched the "\n" in the last line. */
  	return (char_u *)"";
!     return ml_get_buf(rex.reg_buf, rex.reg_firstlnum + lnum, FALSE);
  }
  
  static regsave_T behind_pos;
***************
*** 3687,3696 ****
  #endif
  
  /* TRUE if using multi-line regexp. */
! #define REG_MULTI	(reg_match == NULL)
! 
! static int  bt_regexec_nl(regmatch_T *rmp, char_u *line, colnr_T col, int line_lbr);
! 
  
  /*
   * Match a regexp against a string.
--- 3687,3693 ----
  #endif
  
  /* TRUE if using multi-line regexp. */
! #define REG_MULTI	(rex.reg_match == NULL)
  
  /*
   * Match a regexp against a string.
***************
*** 3707,3729 ****
      colnr_T	col,	/* column to start looking for match */
      int		line_lbr)
  {
!     reg_match = rmp;
!     reg_mmatch = NULL;
!     reg_maxline = 0;
!     reg_line_lbr = line_lbr;
!     reg_buf = curbuf;
!     reg_win = NULL;
!     ireg_ic = rmp->rm_ic;
  #ifdef FEAT_MBYTE
!     ireg_icombine = FALSE;
  #endif
!     ireg_maxcol = 0;
  
      return bt_regexec_both(line, col, NULL);
  }
  
- static long bt_regexec_multi(regmmatch_T *rmp, win_T *win, buf_T *buf, linenr_T lnum, colnr_T col, proftime_T *tm);
- 
  /*
   * Match a regexp against multiple lines.
   * "rmp->regprog" is a compiled regexp as returned by vim_regcomp().
--- 3704,3724 ----
      colnr_T	col,	/* column to start looking for match */
      int		line_lbr)
  {
!     rex.reg_match = rmp;
!     rex.reg_mmatch = NULL;
!     rex.reg_maxline = 0;
!     rex.reg_line_lbr = line_lbr;
!     rex.reg_buf = curbuf;
!     rex.reg_win = NULL;
!     rex.reg_ic = rmp->rm_ic;
  #ifdef FEAT_MBYTE
!     rex.reg_icombine = FALSE;
  #endif
!     rex.reg_maxcol = 0;
  
      return bt_regexec_both(line, col, NULL);
  }
  
  /*
   * Match a regexp against multiple lines.
   * "rmp->regprog" is a compiled regexp as returned by vim_regcomp().
***************
*** 3741,3758 ****
      colnr_T	col,		/* column to start looking for match */
      proftime_T	*tm)		/* timeout limit or NULL */
  {
!     reg_match = NULL;
!     reg_mmatch = rmp;
!     reg_buf = buf;
!     reg_win = win;
!     reg_firstlnum = lnum;
!     reg_maxline = reg_buf->b_ml.ml_line_count - lnum;
!     reg_line_lbr = FALSE;
!     ireg_ic = rmp->rmm_ic;
  #ifdef FEAT_MBYTE
!     ireg_icombine = FALSE;
  #endif
!     ireg_maxcol = rmp->rmm_maxcol;
  
      return bt_regexec_both(NULL, col, tm);
  }
--- 3736,3753 ----
      colnr_T	col,		/* column to start looking for match */
      proftime_T	*tm)		/* timeout limit or NULL */
  {
!     rex.reg_match = NULL;
!     rex.reg_mmatch = rmp;
!     rex.reg_buf = buf;
!     rex.reg_win = win;
!     rex.reg_firstlnum = lnum;
!     rex.reg_maxline = rex.reg_buf->b_ml.ml_line_count - lnum;
!     rex.reg_line_lbr = FALSE;
!     rex.reg_ic = rmp->rmm_ic;
  #ifdef FEAT_MBYTE
!     rex.reg_icombine = FALSE;
  #endif
!     rex.reg_maxcol = rmp->rmm_maxcol;
  
      return bt_regexec_both(NULL, col, tm);
  }
***************
*** 3794,3809 ****
  
      if (REG_MULTI)
      {
! 	prog = (bt_regprog_T *)reg_mmatch->regprog;
  	line = reg_getline((linenr_T)0);
! 	reg_startpos = reg_mmatch->startpos;
! 	reg_endpos = reg_mmatch->endpos;
      }
      else
      {
! 	prog = (bt_regprog_T *)reg_match->regprog;
! 	reg_startp = reg_match->startp;
! 	reg_endp = reg_match->endp;
      }
  
      /* Be paranoid... */
--- 3789,3804 ----
  
      if (REG_MULTI)
      {
! 	prog = (bt_regprog_T *)rex.reg_mmatch->regprog;
  	line = reg_getline((linenr_T)0);
! 	rex.reg_startpos = rex.reg_mmatch->startpos;
! 	rex.reg_endpos = rex.reg_mmatch->endpos;
      }
      else
      {
! 	prog = (bt_regprog_T *)rex.reg_match->regprog;
! 	rex.reg_startp = rex.reg_match->startp;
! 	rex.reg_endp = rex.reg_match->endp;
      }
  
      /* Be paranoid... */
***************
*** 3818,3836 ****
  	goto theend;
  
      /* If the start column is past the maximum column: no need to try. */
!     if (ireg_maxcol > 0 && col >= ireg_maxcol)
  	goto theend;
  
!     /* If pattern contains "\c" or "\C": overrule value of ireg_ic */
      if (prog->regflags & RF_ICASE)
! 	ireg_ic = TRUE;
      else if (prog->regflags & RF_NOICASE)
! 	ireg_ic = FALSE;
  
  #ifdef FEAT_MBYTE
!     /* If pattern contains "\Z" overrule value of ireg_icombine */
      if (prog->regflags & RF_ICOMBINE)
! 	ireg_icombine = TRUE;
  #endif
  
      /* If there is a "must appear" string, look for it. */
--- 3813,3831 ----
  	goto theend;
  
      /* If the start column is past the maximum column: no need to try. */
!     if (rex.reg_maxcol > 0 && col >= rex.reg_maxcol)
  	goto theend;
  
!     /* If pattern contains "\c" or "\C": overrule value of rex.reg_ic */
      if (prog->regflags & RF_ICASE)
! 	rex.reg_ic = TRUE;
      else if (prog->regflags & RF_NOICASE)
! 	rex.reg_ic = FALSE;
  
  #ifdef FEAT_MBYTE
!     /* If pattern contains "\Z" overrule value of rex.reg_icombine */
      if (prog->regflags & RF_ICOMBINE)
! 	rex.reg_icombine = TRUE;
  #endif
  
      /* If there is a "must appear" string, look for it. */
***************
*** 3850,3856 ****
  	 * This is used very often, esp. for ":global".  Use three versions of
  	 * the loop to avoid overhead of conditions.
  	 */
! 	if (!ireg_ic
  #ifdef FEAT_MBYTE
  		&& !has_mbyte
  #endif
--- 3845,3851 ----
  	 * This is used very often, esp. for ":global".  Use three versions of
  	 * the loop to avoid overhead of conditions.
  	 */
! 	if (!rex.reg_ic
  #ifdef FEAT_MBYTE
  		&& !has_mbyte
  #endif
***************
*** 3862,3868 ****
  		++s;
  	    }
  #ifdef FEAT_MBYTE
! 	else if (!ireg_ic || (!enc_utf8 && mb_char2len(c) > 1))
  	    while ((s = vim_strchr(s, c)) != NULL)
  	    {
  		if (cstrncmp(s, prog->regmust, &prog->regmlen) == 0)
--- 3857,3863 ----
  		++s;
  	    }
  #ifdef FEAT_MBYTE
! 	else if (!rex.reg_ic || (!enc_utf8 && mb_char2len(c) > 1))
  	    while ((s = vim_strchr(s, c)) != NULL)
  	    {
  		if (cstrncmp(s, prog->regmust, &prog->regmlen) == 0)
***************
*** 3898,3904 ****
  	    c = regline[col];
  	if (prog->regstart == NUL
  		|| prog->regstart == c
! 		|| (ireg_ic && ((
  #ifdef FEAT_MBYTE
  			(enc_utf8 && utf_fold(prog->regstart) == utf_fold(c)))
  			|| (c < 255 && prog->regstart < 255 &&
--- 3893,3899 ----
  	    c = regline[col];
  	if (prog->regstart == NUL
  		|| prog->regstart == c
! 		|| (rex.reg_ic && ((
  #ifdef FEAT_MBYTE
  			(enc_utf8 && utf_fold(prog->regstart) == utf_fold(c)))
  			|| (c < 255 && prog->regstart < 255 &&
***************
*** 3920,3926 ****
  	    {
  		/* Skip until the char we know it must start with.
  		 * Used often, do some work to avoid call overhead. */
! 		if (!ireg_ic
  #ifdef FEAT_MBYTE
  			    && !has_mbyte
  #endif
--- 3915,3921 ----
  	    {
  		/* Skip until the char we know it must start with.
  		 * Used often, do some work to avoid call overhead. */
! 		if (!rex.reg_ic
  #ifdef FEAT_MBYTE
  			    && !has_mbyte
  #endif
***************
*** 3937,3943 ****
  	    }
  
  	    /* Check for maximum column to try. */
! 	    if (ireg_maxcol > 0 && col >= ireg_maxcol)
  	    {
  		retval = 0;
  		break;
--- 3932,3938 ----
  	    }
  
  	    /* Check for maximum column to try. */
! 	    if (rex.reg_maxcol > 0 && col >= rex.reg_maxcol)
  	    {
  		retval = 0;
  		break;
***************
*** 4056,4081 ****
      cleanup_subexpr();
      if (REG_MULTI)
      {
! 	if (reg_startpos[0].lnum < 0)
  	{
! 	    reg_startpos[0].lnum = 0;
! 	    reg_startpos[0].col = col;
  	}
! 	if (reg_endpos[0].lnum < 0)
  	{
! 	    reg_endpos[0].lnum = reglnum;
! 	    reg_endpos[0].col = (int)(reginput - regline);
  	}
  	else
  	    /* Use line number of "\ze". */
! 	    reglnum = reg_endpos[0].lnum;
      }
      else
      {
! 	if (reg_startp[0] == NULL)
! 	    reg_startp[0] = regline + col;
! 	if (reg_endp[0] == NULL)
! 	    reg_endp[0] = reginput;
      }
  #ifdef FEAT_SYN_HL
      /* Package any found \z(...\) matches for export. Default is none. */
--- 4051,4076 ----
      cleanup_subexpr();
      if (REG_MULTI)
      {
! 	if (rex.reg_startpos[0].lnum < 0)
  	{
! 	    rex.reg_startpos[0].lnum = 0;
! 	    rex.reg_startpos[0].col = col;
  	}
! 	if (rex.reg_endpos[0].lnum < 0)
  	{
! 	    rex.reg_endpos[0].lnum = reglnum;
! 	    rex.reg_endpos[0].col = (int)(reginput - regline);
  	}
  	else
  	    /* Use line number of "\ze". */
! 	    reglnum = rex.reg_endpos[0].lnum;
      }
      else
      {
! 	if (rex.reg_startp[0] == NULL)
! 	    rex.reg_startp[0] = regline + col;
! 	if (rex.reg_endp[0] == NULL)
! 	    rex.reg_endp[0] = reginput;
      }
  #ifdef FEAT_SYN_HL
      /* Package any found \z(...\) matches for export. Default is none. */
***************
*** 4125,4131 ****
  {
      if (reginput > regline)
  	return mb_get_class_buf(reginput - 1
! 			    - (*mb_head_off)(regline, reginput - 1), reg_buf);
      return -1;
  }
  #endif
--- 4120,4126 ----
  {
      if (reginput > regline)
  	return mb_get_class_buf(reginput - 1
! 			 - (*mb_head_off)(regline, reginput - 1), rex.reg_buf);
      return -1;
  }
  #endif
***************
*** 4141,4154 ****
      pos_T	top, bot;
      linenr_T    lnum;
      colnr_T	col;
!     win_T	*wp = reg_win == NULL ? curwin : reg_win;
      int		mode;
      colnr_T	start, end;
      colnr_T	start2, end2;
      colnr_T	cols;
  
      /* Check if the buffer is the current buffer. */
!     if (reg_buf != curbuf || VIsual.lnum == 0)
  	return FALSE;
  
      if (VIsual_active)
--- 4136,4149 ----
      pos_T	top, bot;
      linenr_T    lnum;
      colnr_T	col;
!     win_T	*wp = rex.reg_win == NULL ? curwin : rex.reg_win;
      int		mode;
      colnr_T	start, end;
      colnr_T	start2, end2;
      colnr_T	cols;
  
      /* Check if the buffer is the current buffer. */
!     if (rex.reg_buf != curbuf || VIsual.lnum == 0)
  	return FALSE;
  
      if (VIsual_active)
***************
*** 4179,4185 ****
  	}
  	mode = curbuf->b_visual.vi_mode;
      }
!     lnum = reglnum + reg_firstlnum;
      if (lnum < top.lnum || lnum > bot.lnum)
  	return FALSE;
  
--- 4174,4180 ----
  	}
  	mode = curbuf->b_visual.vi_mode;
      }
!     lnum = reglnum + rex.reg_firstlnum;
      if (lnum < top.lnum || lnum > bot.lnum)
  	return FALSE;
  
***************
*** 4309,4320 ****
  
  	op = OP(scan);
  	/* Check for character class with NL added. */
! 	if (!reg_line_lbr && WITH_NL(op) && REG_MULTI
! 				&& *reginput == NUL && reglnum <= reg_maxline)
  	{
  	    reg_nextline();
  	}
! 	else if (reg_line_lbr && WITH_NL(op) && *reginput == '\n')
  	{
  	    ADVANCE_REGINPUT();
  	}
--- 4304,4315 ----
  
  	op = OP(scan);
  	/* Check for character class with NL added. */
! 	if (!rex.reg_line_lbr && WITH_NL(op) && REG_MULTI
! 			     && *reginput == NUL && reglnum <= rex.reg_maxline)
  	{
  	    reg_nextline();
  	}
! 	else if (rex.reg_line_lbr && WITH_NL(op) && *reginput == '\n')
  	{
  	    ADVANCE_REGINPUT();
  	}
***************
*** 4345,4365 ****
  	     * line where we started, not at the start of the line or we
  	     * didn't start at the first line of the buffer. */
  	    if (reglnum != 0 || reginput != regline
! 					  || (REG_MULTI && reg_firstlnum > 1))
  		status = RA_NOMATCH;
  	    break;
  
  	  case RE_EOF:
! 	    if (reglnum != reg_maxline || c != NUL)
  		status = RA_NOMATCH;
  	    break;
  
  	  case CURSOR:
  	    /* Check if the buffer is in a window and compare the
! 	     * reg_win->w_cursor position to the match position. */
! 	    if (reg_win == NULL
! 		    || (reglnum + reg_firstlnum != reg_win->w_cursor.lnum)
! 		    || ((colnr_T)(reginput - regline) != reg_win->w_cursor.col))
  		status = RA_NOMATCH;
  	    break;
  
--- 4340,4362 ----
  	     * line where we started, not at the start of the line or we
  	     * didn't start at the first line of the buffer. */
  	    if (reglnum != 0 || reginput != regline
! 				       || (REG_MULTI && rex.reg_firstlnum > 1))
  		status = RA_NOMATCH;
  	    break;
  
  	  case RE_EOF:
! 	    if (reglnum != rex.reg_maxline || c != NUL)
  		status = RA_NOMATCH;
  	    break;
  
  	  case CURSOR:
  	    /* Check if the buffer is in a window and compare the
! 	     * rex.reg_win->w_cursor position to the match position. */
! 	    if (rex.reg_win == NULL
! 		    || (reglnum + rex.reg_firstlnum
! 						 != rex.reg_win->w_cursor.lnum)
! 		    || ((colnr_T)(reginput - regline)
! 						 != rex.reg_win->w_cursor.col))
  		status = RA_NOMATCH;
  	    break;
  
***************
*** 4370,4385 ****
  		int	cmp = OPERAND(scan)[1];
  		pos_T	*pos;
  
! 		pos = getmark_buf(reg_buf, mark, FALSE);
  		if (pos == NULL		     /* mark doesn't exist */
  			|| pos->lnum <= 0    /* mark isn't set in reg_buf */
! 			|| (pos->lnum == reglnum + reg_firstlnum
  				? (pos->col == (colnr_T)(reginput - regline)
  				    ? (cmp == '<' || cmp == '>')
  				    : (pos->col < (colnr_T)(reginput - regline)
  					? cmp != '>'
  					: cmp != '<'))
! 				: (pos->lnum < reglnum + reg_firstlnum
  				    ? cmp != '>'
  				    : cmp != '<')))
  		    status = RA_NOMATCH;
--- 4367,4382 ----
  		int	cmp = OPERAND(scan)[1];
  		pos_T	*pos;
  
! 		pos = getmark_buf(rex.reg_buf, mark, FALSE);
  		if (pos == NULL		     /* mark doesn't exist */
  			|| pos->lnum <= 0    /* mark isn't set in reg_buf */
! 			|| (pos->lnum == reglnum + rex.reg_firstlnum
  				? (pos->col == (colnr_T)(reginput - regline)
  				    ? (cmp == '<' || cmp == '>')
  				    : (pos->col < (colnr_T)(reginput - regline)
  					? cmp != '>'
  					: cmp != '<'))
! 				: (pos->lnum < reglnum + rex.reg_firstlnum
  				    ? cmp != '>'
  				    : cmp != '<')))
  		    status = RA_NOMATCH;
***************
*** 4392,4398 ****
  	    break;
  
  	  case RE_LNUM:
! 	    if (!REG_MULTI || !re_num_cmp((long_u)(reglnum + reg_firstlnum),
  									scan))
  		status = RA_NOMATCH;
  	    break;
--- 4389,4395 ----
  	    break;
  
  	  case RE_LNUM:
! 	    if (!REG_MULTI || !re_num_cmp((long_u)(reglnum + rex.reg_firstlnum),
  									scan))
  		status = RA_NOMATCH;
  	    break;
***************
*** 4404,4410 ****
  
  	  case RE_VCOL:
  	    if (!re_num_cmp((long_u)win_linetabsize(
! 			    reg_win == NULL ? curwin : reg_win,
  			    regline, (colnr_T)(reginput - regline)) + 1, scan))
  		status = RA_NOMATCH;
  	    break;
--- 4401,4407 ----
  
  	  case RE_VCOL:
  	    if (!re_num_cmp((long_u)win_linetabsize(
! 			    rex.reg_win == NULL ? curwin : rex.reg_win,
  			    regline, (colnr_T)(reginput - regline)) + 1, scan))
  		status = RA_NOMATCH;
  	    break;
***************
*** 4418,4424 ****
  		int this_class;
  
  		/* Get class of current and previous char (if it exists). */
! 		this_class = mb_get_class_buf(reginput, reg_buf);
  		if (this_class <= 1)
  		    status = RA_NOMATCH;  /* not on a word at all */
  		else if (reg_prev_class() == this_class)
--- 4415,4421 ----
  		int this_class;
  
  		/* Get class of current and previous char (if it exists). */
! 		this_class = mb_get_class_buf(reginput, rex.reg_buf);
  		if (this_class <= 1)
  		    status = RA_NOMATCH;  /* not on a word at all */
  		else if (reg_prev_class() == this_class)
***************
*** 4427,4434 ****
  #endif
  	    else
  	    {
! 		if (!vim_iswordc_buf(c, reg_buf) || (reginput > regline
! 				   && vim_iswordc_buf(reginput[-1], reg_buf)))
  		    status = RA_NOMATCH;
  	    }
  	    break;
--- 4424,4431 ----
  #endif
  	    else
  	    {
! 		if (!vim_iswordc_buf(c, rex.reg_buf) || (reginput > regline
! 				&& vim_iswordc_buf(reginput[-1], rex.reg_buf)))
  		    status = RA_NOMATCH;
  	    }
  	    break;
***************
*** 4442,4448 ****
  		int this_class, prev_class;
  
  		/* Get class of current and previous char (if it exists). */
! 		this_class = mb_get_class_buf(reginput, reg_buf);
  		prev_class = reg_prev_class();
  		if (this_class == prev_class
  			|| prev_class == 0 || prev_class == 1)
--- 4439,4445 ----
  		int this_class, prev_class;
  
  		/* Get class of current and previous char (if it exists). */
! 		this_class = mb_get_class_buf(reginput, rex.reg_buf);
  		prev_class = reg_prev_class();
  		if (this_class == prev_class
  			|| prev_class == 0 || prev_class == 1)
***************
*** 4451,4458 ****
  #endif
  	    else
  	    {
! 		if (!vim_iswordc_buf(reginput[-1], reg_buf)
! 			|| (reginput[0] != NUL && vim_iswordc_buf(c, reg_buf)))
  		    status = RA_NOMATCH;
  	    }
  	    break; /* Matched with EOW */
--- 4448,4456 ----
  #endif
  	    else
  	    {
! 		if (!vim_iswordc_buf(reginput[-1], rex.reg_buf)
! 			|| (reginput[0] != NUL
! 					   && vim_iswordc_buf(c, rex.reg_buf)))
  		    status = RA_NOMATCH;
  	    }
  	    break; /* Matched with EOW */
***************
*** 4480,4493 ****
  	    break;
  
  	  case KWORD:
! 	    if (!vim_iswordp_buf(reginput, reg_buf))
  		status = RA_NOMATCH;
  	    else
  		ADVANCE_REGINPUT();
  	    break;
  
  	  case SKWORD:
! 	    if (VIM_ISDIGIT(*reginput) || !vim_iswordp_buf(reginput, reg_buf))
  		status = RA_NOMATCH;
  	    else
  		ADVANCE_REGINPUT();
--- 4478,4492 ----
  	    break;
  
  	  case KWORD:
! 	    if (!vim_iswordp_buf(reginput, rex.reg_buf))
  		status = RA_NOMATCH;
  	    else
  		ADVANCE_REGINPUT();
  	    break;
  
  	  case SKWORD:
! 	    if (VIM_ISDIGIT(*reginput)
! 				    || !vim_iswordp_buf(reginput, rex.reg_buf))
  		status = RA_NOMATCH;
  	    else
  		ADVANCE_REGINPUT();
***************
*** 4655,4661 ****
  		opnd = OPERAND(scan);
  		/* Inline the first byte, for speed. */
  		if (*opnd != *reginput
! 			&& (!ireg_ic || (
  #ifdef FEAT_MBYTE
  			    !enc_utf8 &&
  #endif
--- 4654,4660 ----
  		opnd = OPERAND(scan);
  		/* Inline the first byte, for speed. */
  		if (*opnd != *reginput
! 			&& (!rex.reg_ic || (
  #ifdef FEAT_MBYTE
  			    !enc_utf8 &&
  #endif
***************
*** 4670,4676 ****
  		{
  		    if (opnd[1] == NUL
  #ifdef FEAT_MBYTE
! 			    && !(enc_utf8 && ireg_ic)
  #endif
  			)
  		    {
--- 4669,4675 ----
  		{
  		    if (opnd[1] == NUL
  #ifdef FEAT_MBYTE
! 			    && !(enc_utf8 && rex.reg_ic)
  #endif
  			)
  		    {
***************
*** 4689,4695 ****
  		    if (status != RA_NOMATCH
  			    && enc_utf8
  			    && UTF_COMPOSINGLIKE(reginput, reginput + len)
! 			    && !ireg_icombine
  			    && OP(next) != RE_COMPOSING)
  		    {
  			/* raaron: This code makes a composing character get
--- 4688,4694 ----
  		    if (status != RA_NOMATCH
  			    && enc_utf8
  			    && UTF_COMPOSINGLIKE(reginput, reginput + len)
! 			    && !rex.reg_icombine
  			    && OP(next) != RE_COMPOSING)
  		    {
  			/* raaron: This code makes a composing character get
***************
*** 4840,4847 ****
  		else
  		{
  		    rp->rs_no = no;
! 		    save_se(&rp->rs_un.sesave, &reg_startpos[no],
! 							     &reg_startp[no]);
  		    /* We simply continue and handle the result when done. */
  		}
  	    }
--- 4839,4846 ----
  		else
  		{
  		    rp->rs_no = no;
! 		    save_se(&rp->rs_un.sesave, &rex.reg_startpos[no],
! 							  &rex.reg_startp[no]);
  		    /* We simply continue and handle the result when done. */
  		}
  	    }
***************
*** 4900,4906 ****
  		else
  		{
  		    rp->rs_no = no;
! 		    save_se(&rp->rs_un.sesave, &reg_endpos[no], &reg_endp[no]);
  		    /* We simply continue and handle the result when done. */
  		}
  	    }
--- 4899,4906 ----
  		else
  		{
  		    rp->rs_no = no;
! 		    save_se(&rp->rs_un.sesave, &rex.reg_endpos[no],
! 							    &rex.reg_endp[no]);
  		    /* We simply continue and handle the result when done. */
  		}
  	    }
***************
*** 4949,4955 ****
  		cleanup_subexpr();
  		if (!REG_MULTI)		/* Single-line regexp */
  		{
! 		    if (reg_startp[no] == NULL || reg_endp[no] == NULL)
  		    {
  			/* Backref was not set: Match an empty string. */
  			len = 0;
--- 4949,4955 ----
  		cleanup_subexpr();
  		if (!REG_MULTI)		/* Single-line regexp */
  		{
! 		    if (rex.reg_startp[no] == NULL || rex.reg_endp[no] == NULL)
  		    {
  			/* Backref was not set: Match an empty string. */
  			len = 0;
***************
*** 4958,4983 ****
  		    {
  			/* Compare current input with back-ref in the same
  			 * line. */
! 			len = (int)(reg_endp[no] - reg_startp[no]);
! 			if (cstrncmp(reg_startp[no], reginput, &len) != 0)
  			    status = RA_NOMATCH;
  		    }
  		}
  		else				/* Multi-line regexp */
  		{
! 		    if (reg_startpos[no].lnum < 0 || reg_endpos[no].lnum < 0)
  		    {
  			/* Backref was not set: Match an empty string. */
  			len = 0;
  		    }
  		    else
  		    {
! 			if (reg_startpos[no].lnum == reglnum
! 				&& reg_endpos[no].lnum == reglnum)
  			{
  			    /* Compare back-ref within the current line. */
! 			    len = reg_endpos[no].col - reg_startpos[no].col;
! 			    if (cstrncmp(regline + reg_startpos[no].col,
  							  reginput, &len) != 0)
  				status = RA_NOMATCH;
  			}
--- 4958,4985 ----
  		    {
  			/* Compare current input with back-ref in the same
  			 * line. */
! 			len = (int)(rex.reg_endp[no] - rex.reg_startp[no]);
! 			if (cstrncmp(rex.reg_startp[no], reginput, &len) != 0)
  			    status = RA_NOMATCH;
  		    }
  		}
  		else				/* Multi-line regexp */
  		{
! 		    if (rex.reg_startpos[no].lnum < 0
! 						|| rex.reg_endpos[no].lnum < 0)
  		    {
  			/* Backref was not set: Match an empty string. */
  			len = 0;
  		    }
  		    else
  		    {
! 			if (rex.reg_startpos[no].lnum == reglnum
! 				&& rex.reg_endpos[no].lnum == reglnum)
  			{
  			    /* Compare back-ref within the current line. */
! 			    len = rex.reg_endpos[no].col
! 						    - rex.reg_startpos[no].col;
! 			    if (cstrncmp(regline + rex.reg_startpos[no].col,
  							  reginput, &len) != 0)
  				status = RA_NOMATCH;
  			}
***************
*** 4986,4995 ****
  			    /* Messy situation: Need to compare between two
  			     * lines. */
  			    int r = match_with_backref(
! 					    reg_startpos[no].lnum,
! 					    reg_startpos[no].col,
! 					    reg_endpos[no].lnum,
! 					    reg_endpos[no].col,
  					    &len);
  
  			    if (r != RA_MATCH)
--- 4988,4997 ----
  			    /* Messy situation: Need to compare between two
  			     * lines. */
  			    int r = match_with_backref(
! 					    rex.reg_startpos[no].lnum,
! 					    rex.reg_startpos[no].col,
! 					    rex.reg_endpos[no].lnum,
! 					    rex.reg_endpos[no].col,
  					    &len);
  
  			    if (r != RA_MATCH)
***************
*** 5154,5160 ****
  		if (OP(next) == EXACTLY)
  		{
  		    rst.nextb = *OPERAND(next);
! 		    if (ireg_ic)
  		    {
  			if (MB_ISUPPER(rst.nextb))
  			    rst.nextb_ic = MB_TOLOWER(rst.nextb);
--- 5156,5162 ----
  		if (OP(next) == EXACTLY)
  		{
  		    rst.nextb = *OPERAND(next);
! 		    if (rex.reg_ic)
  		    {
  			if (MB_ISUPPER(rst.nextb))
  			    rst.nextb_ic = MB_TOLOWER(rst.nextb);
***************
*** 5282,5291 ****
  	    break;
  
  	  case NEWL:
! 	    if ((c != NUL || !REG_MULTI || reglnum > reg_maxline
! 			     || reg_line_lbr) && (c != '\n' || !reg_line_lbr))
  		status = RA_NOMATCH;
! 	    else if (reg_line_lbr)
  		ADVANCE_REGINPUT();
  	    else
  		reg_nextline();
--- 5284,5294 ----
  	    break;
  
  	  case NEWL:
! 	    if ((c != NUL || !REG_MULTI || reglnum > rex.reg_maxline
! 			     || rex.reg_line_lbr)
! 					   && (c != '\n' || !rex.reg_line_lbr))
  		status = RA_NOMATCH;
! 	    else if (rex.reg_line_lbr)
  		ADVANCE_REGINPUT();
  	    else
  		reg_nextline();
***************
*** 5331,5338 ****
  	  case RS_MOPEN:
  	    /* Pop the state.  Restore pointers when there is no match. */
  	    if (status == RA_NOMATCH)
! 		restore_se(&rp->rs_un.sesave, &reg_startpos[rp->rs_no],
! 						  &reg_startp[rp->rs_no]);
  	    regstack_pop(&scan);
  	    break;
  
--- 5334,5341 ----
  	  case RS_MOPEN:
  	    /* Pop the state.  Restore pointers when there is no match. */
  	    if (status == RA_NOMATCH)
! 		restore_se(&rp->rs_un.sesave, &rex.reg_startpos[rp->rs_no],
! 						  &rex.reg_startp[rp->rs_no]);
  	    regstack_pop(&scan);
  	    break;
  
***************
*** 5349,5356 ****
  	  case RS_MCLOSE:
  	    /* Pop the state.  Restore pointers when there is no match. */
  	    if (status == RA_NOMATCH)
! 		restore_se(&rp->rs_un.sesave, &reg_endpos[rp->rs_no],
! 						    &reg_endp[rp->rs_no]);
  	    regstack_pop(&scan);
  	    break;
  
--- 5352,5359 ----
  	  case RS_MCLOSE:
  	    /* Pop the state.  Restore pointers when there is no match. */
  	    if (status == RA_NOMATCH)
! 		restore_se(&rp->rs_un.sesave, &rex.reg_endpos[rp->rs_no],
! 						    &rex.reg_endp[rp->rs_no]);
  	    regstack_pop(&scan);
  	    break;
  
***************
*** 5785,5792 ****
  		++count;
  		mb_ptr_adv(scan);
  	    }
! 	    if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > reg_maxline
! 					 || reg_line_lbr || count == maxcount)
  		break;
  	    ++count;		/* count the line-break */
  	    reg_nextline();
--- 5788,5795 ----
  		++count;
  		mb_ptr_adv(scan);
  	    }
! 	    if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > rex.reg_maxline
! 				      || rex.reg_line_lbr || count == maxcount)
  		break;
  	    ++count;		/* count the line-break */
  	    reg_nextline();
***************
*** 5810,5824 ****
  	    }
  	    else if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > reg_maxline
! 							      || reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
  		if (got_int)
  		    break;
  	    }
! 	    else if (reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
--- 5813,5827 ----
  	    }
  	    else if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > rex.reg_maxline
! 							   || rex.reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
  		if (got_int)
  		    break;
  	    }
! 	    else if (rex.reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
***************
*** 5834,5855 ****
        case SKWORD + ADD_NL:
  	while (count < maxcount)
  	{
! 	    if (vim_iswordp_buf(scan, reg_buf)
  					  && (testval || !VIM_ISDIGIT(*scan)))
  	    {
  		mb_ptr_adv(scan);
  	    }
  	    else if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > reg_maxline
! 							      || reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
  		if (got_int)
  		    break;
  	    }
! 	    else if (reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
--- 5837,5858 ----
        case SKWORD + ADD_NL:
  	while (count < maxcount)
  	{
! 	    if (vim_iswordp_buf(scan, rex.reg_buf)
  					  && (testval || !VIM_ISDIGIT(*scan)))
  	    {
  		mb_ptr_adv(scan);
  	    }
  	    else if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > rex.reg_maxline
! 							   || rex.reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
  		if (got_int)
  		    break;
  	    }
! 	    else if (rex.reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
***************
*** 5871,5885 ****
  	    }
  	    else if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > reg_maxline
! 							      || reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
  		if (got_int)
  		    break;
  	    }
! 	    else if (reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
--- 5874,5888 ----
  	    }
  	    else if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > rex.reg_maxline
! 							   || rex.reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
  		if (got_int)
  		    break;
  	    }
! 	    else if (rex.reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
***************
*** 5897,5904 ****
  	{
  	    if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > reg_maxline
! 							      || reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
--- 5900,5907 ----
  	{
  	    if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > rex.reg_maxline
! 							   || rex.reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
***************
*** 5910,5916 ****
  	    {
  		mb_ptr_adv(scan);
  	    }
! 	    else if (reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
--- 5913,5919 ----
  	    {
  		mb_ptr_adv(scan);
  	    }
! 	    else if (rex.reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
***************
*** 5929,5936 ****
  #endif
  	    if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > reg_maxline
! 							      || reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
--- 5932,5939 ----
  #endif
  	    if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > rex.reg_maxline
! 							   || rex.reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
***************
*** 5947,5953 ****
  #endif
  	    else if ((class_tab[*scan] & mask) == testval)
  		++scan;
! 	    else if (reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
--- 5950,5956 ----
  #endif
  	    else if ((class_tab[*scan] & mask) == testval)
  		++scan;
! 	    else if (rex.reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
***************
*** 6031,6037 ****
  	    /* This doesn't do a multi-byte character, because a MULTIBYTECODE
  	     * would have been used for it.  It does handle single-byte
  	     * characters, such as latin1. */
! 	    if (ireg_ic)
  	    {
  		cu = MB_TOUPPER(*opnd);
  		cl = MB_TOLOWER(*opnd);
--- 6034,6040 ----
  	    /* This doesn't do a multi-byte character, because a MULTIBYTECODE
  	     * would have been used for it.  It does handle single-byte
  	     * characters, such as latin1. */
! 	    if (rex.reg_ic)
  	    {
  		cu = MB_TOUPPER(*opnd);
  		cl = MB_TOLOWER(*opnd);
***************
*** 6062,6075 ****
  	     * compiling the program). */
  	    if ((len = (*mb_ptr2len)(opnd)) > 1)
  	    {
! 		if (ireg_ic && enc_utf8)
  		    cf = utf_fold(utf_ptr2char(opnd));
  		while (count < maxcount && (*mb_ptr2len)(scan) >= len)
  		{
  		    for (i = 0; i < len; ++i)
  			if (opnd[i] != scan[i])
  			    break;
! 		    if (i < len && (!ireg_ic || !enc_utf8
  					|| utf_fold(utf_ptr2char(scan)) != cf))
  			break;
  		    scan += len;
--- 6065,6078 ----
  	     * compiling the program). */
  	    if ((len = (*mb_ptr2len)(opnd)) > 1)
  	    {
! 		if (rex.reg_ic && enc_utf8)
  		    cf = utf_fold(utf_ptr2char(opnd));
  		while (count < maxcount && (*mb_ptr2len)(scan) >= len)
  		{
  		    for (i = 0; i < len; ++i)
  			if (opnd[i] != scan[i])
  			    break;
! 		    if (i < len && (!rex.reg_ic || !enc_utf8
  					|| utf_fold(utf_ptr2char(scan)) != cf))
  			break;
  		    scan += len;
***************
*** 6094,6108 ****
  #endif
  	    if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > reg_maxline
! 							      || reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
  		if (got_int)
  		    break;
  	    }
! 	    else if (reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  #ifdef FEAT_MBYTE
  	    else if (has_mbyte && (len = (*mb_ptr2len)(scan)) > 1)
--- 6097,6111 ----
  #endif
  	    if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > rex.reg_maxline
! 							   || rex.reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
  		if (got_int)
  		    break;
  	    }
! 	    else if (rex.reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  #ifdef FEAT_MBYTE
  	    else if (has_mbyte && (len = (*mb_ptr2len)(scan)) > 1)
***************
*** 6124,6134 ****
  
        case NEWL:
  	while (count < maxcount
! 		&& ((*scan == NUL && reglnum <= reg_maxline && !reg_line_lbr
! 			    && REG_MULTI) || (*scan == '\n' && reg_line_lbr)))
  	{
  	    count++;
! 	    if (reg_line_lbr)
  		ADVANCE_REGINPUT();
  	    else
  		reg_nextline();
--- 6127,6138 ----
  
        case NEWL:
  	while (count < maxcount
! 		&& ((*scan == NUL && reglnum <= rex.reg_maxline
! 				       && !rex.reg_line_lbr && REG_MULTI)
! 		    || (*scan == '\n' && rex.reg_line_lbr)))
  	{
  	    count++;
! 	    if (rex.reg_line_lbr)
  		ADVANCE_REGINPUT();
  	    else
  		reg_nextline();
***************
*** 6183,6189 ****
  {
      regprog_T	*prog;
  
!     prog = REG_MULTI ? reg_mmatch->regprog : reg_match->regprog;
      if (prog->engine == &nfa_regengine)
  	/* For NFA matcher we don't check the magic */
  	return FALSE;
--- 6187,6193 ----
  {
      regprog_T	*prog;
  
!     prog = REG_MULTI ? rex.reg_mmatch->regprog : rex.reg_match->regprog;
      if (prog->engine == &nfa_regengine)
  	/* For NFA matcher we don't check the magic */
  	return FALSE;
***************
*** 6209,6221 ****
  	if (REG_MULTI)
  	{
  	    /* Use 0xff to set lnum to -1 */
! 	    vim_memset(reg_startpos, 0xff, sizeof(lpos_T) * NSUBEXP);
! 	    vim_memset(reg_endpos, 0xff, sizeof(lpos_T) * NSUBEXP);
  	}
  	else
  	{
! 	    vim_memset(reg_startp, 0, sizeof(char_u *) * NSUBEXP);
! 	    vim_memset(reg_endp, 0, sizeof(char_u *) * NSUBEXP);
  	}
  	need_clear_subexpr = FALSE;
      }
--- 6213,6225 ----
  	if (REG_MULTI)
  	{
  	    /* Use 0xff to set lnum to -1 */
! 	    vim_memset(rex.reg_startpos, 0xff, sizeof(lpos_T) * NSUBEXP);
! 	    vim_memset(rex.reg_endpos, 0xff, sizeof(lpos_T) * NSUBEXP);
  	}
  	else
  	{
! 	    vim_memset(rex.reg_startp, 0, sizeof(char_u *) * NSUBEXP);
! 	    vim_memset(rex.reg_endp, 0, sizeof(char_u *) * NSUBEXP);
  	}
  	need_clear_subexpr = FALSE;
      }
***************
*** 6261,6273 ****
  	{
  	    if (REG_MULTI)
  	    {
! 		bp->save_start[i].se_u.pos = reg_startpos[i];
! 		bp->save_end[i].se_u.pos = reg_endpos[i];
  	    }
  	    else
  	    {
! 		bp->save_start[i].se_u.ptr = reg_startp[i];
! 		bp->save_end[i].se_u.ptr = reg_endp[i];
  	    }
  	}
      }
--- 6265,6277 ----
  	{
  	    if (REG_MULTI)
  	    {
! 		bp->save_start[i].se_u.pos = rex.reg_startpos[i];
! 		bp->save_end[i].se_u.pos = rex.reg_endpos[i];
  	    }
  	    else
  	    {
! 		bp->save_start[i].se_u.ptr = rex.reg_startp[i];
! 		bp->save_end[i].se_u.ptr = rex.reg_endp[i];
  	    }
  	}
      }
***************
*** 6289,6301 ****
  	{
  	    if (REG_MULTI)
  	    {
! 		reg_startpos[i] = bp->save_start[i].se_u.pos;
! 		reg_endpos[i] = bp->save_end[i].se_u.pos;
  	    }
  	    else
  	    {
! 		reg_startp[i] = bp->save_start[i].se_u.ptr;
! 		reg_endp[i] = bp->save_end[i].se_u.ptr;
  	    }
  	}
      }
--- 6293,6305 ----
  	{
  	    if (REG_MULTI)
  	    {
! 		rex.reg_startpos[i] = bp->save_start[i].se_u.pos;
! 		rex.reg_endpos[i] = bp->save_end[i].se_u.pos;
  	    }
  	    else
  	    {
! 		rex.reg_startp[i] = bp->save_start[i].se_u.ptr;
! 		rex.reg_endp[i] = bp->save_end[i].se_u.ptr;
  	    }
  	}
      }
***************
*** 6454,6460 ****
  	    *bytelen += len;
  	if (clnum == end_lnum)
  	    break;		/* match and at end! */
! 	if (reglnum >= reg_maxline)
  	    return RA_NOMATCH;  /* text too short */
  
  	/* Advance to next line. */
--- 6458,6464 ----
  	    *bytelen += len;
  	if (clnum == end_lnum)
  	    break;		/* match and at end! */
! 	if (reglnum >= rex.reg_maxline)
  	    return RA_NOMATCH;  /* text too short */
  
  	/* Advance to next line. */
***************
*** 7039,7045 ****
  #endif
  
  /*
!  * Compare two strings, ignore case if ireg_ic set.
   * Return 0 if strings match, non-zero otherwise.
   * Correct the length "*n" when composing characters are ignored.
   */
--- 7043,7049 ----
  #endif
  
  /*
!  * Compare two strings, ignore case if rex.reg_ic set.
   * Return 0 if strings match, non-zero otherwise.
   * Correct the length "*n" when composing characters are ignored.
   */
***************
*** 7048,7061 ****
  {
      int		result;
  
!     if (!ireg_ic)
  	result = STRNCMP(s1, s2, *n);
      else
  	result = MB_STRNICMP(s1, s2, *n);
  
  #ifdef FEAT_MBYTE
      /* if it failed and it's utf8 and we want to combineignore: */
!     if (result != 0 && enc_utf8 && ireg_icombine)
      {
  	char_u	*str1, *str2;
  	int	c1, c2, c11, c12;
--- 7052,7065 ----
  {
      int		result;
  
!     if (!rex.reg_ic)
  	result = STRNCMP(s1, s2, *n);
      else
  	result = MB_STRNICMP(s1, s2, *n);
  
  #ifdef FEAT_MBYTE
      /* if it failed and it's utf8 and we want to combineignore: */
!     if (result != 0 && enc_utf8 && rex.reg_icombine)
      {
  	char_u	*str1, *str2;
  	int	c1, c2, c11, c12;
***************
*** 7074,7087 ****
  	    /* decompose the character if necessary, into 'base' characters
  	     * because I don't care about Arabic, I will hard-code the Hebrew
  	     * which I *do* care about!  So sue me... */
! 	    if (c1 != c2 && (!ireg_ic || utf_fold(c1) != utf_fold(c2)))
  	    {
  		/* decomposition necessary? */
  		mb_decompose(c1, &c11, &junk, &junk);
  		mb_decompose(c2, &c12, &junk, &junk);
  		c1 = c11;
  		c2 = c12;
! 		if (c11 != c12 && (!ireg_ic || utf_fold(c11) != utf_fold(c12)))
  		    break;
  	    }
  	}
--- 7078,7092 ----
  	    /* decompose the character if necessary, into 'base' characters
  	     * because I don't care about Arabic, I will hard-code the Hebrew
  	     * which I *do* care about!  So sue me... */
! 	    if (c1 != c2 && (!rex.reg_ic || utf_fold(c1) != utf_fold(c2)))
  	    {
  		/* decomposition necessary? */
  		mb_decompose(c1, &c11, &junk, &junk);
  		mb_decompose(c2, &c12, &junk, &junk);
  		c1 = c11;
  		c2 = c12;
! 		if (c11 != c12
! 			    && (!rex.reg_ic || utf_fold(c11) != utf_fold(c12)))
  		    break;
  	    }
  	}
***************
*** 7103,7109 ****
      char_u	*p;
      int		cc;
  
!     if (!ireg_ic
  #ifdef FEAT_MBYTE
  	    || (!enc_utf8 && mb_char2len(c) > 1)
  #endif
--- 7108,7114 ----
      char_u	*p;
      int		cc;
  
!     if (!rex.reg_ic
  #ifdef FEAT_MBYTE
  	    || (!enc_utf8 && mb_char2len(c) > 1)
  #endif
***************
*** 7276,7289 ****
  #ifdef FEAT_EVAL
  static int can_f_submatch = FALSE;	/* TRUE when submatch() can be used */
  
! /* These pointers are used instead of reg_match and reg_mmatch for
!  * reg_submatch().  Needed for when the substitution string is an expression
!  * that contains a call to substitute() and submatch(). */
! static regmatch_T	*submatch_match;
! static regmmatch_T	*submatch_mmatch;
! static linenr_T		submatch_firstlnum;
! static linenr_T		submatch_maxline;
! static int		submatch_line_lbr;
  #endif
  
  #if defined(FEAT_MODIFY_FNAME) || defined(FEAT_EVAL) || defined(PROTO)
--- 7281,7298 ----
  #ifdef FEAT_EVAL
  static int can_f_submatch = FALSE;	/* TRUE when submatch() can be used */
  
! /* These pointers are used for reg_submatch().  Needed for when the
!  * substitution string is an expression that contains a call to substitute()
!  * and submatch(). */
! typedef struct {
!     regmatch_T	*sm_match;
!     regmmatch_T	*sm_mmatch;
!     linenr_T	sm_firstlnum;
!     linenr_T	sm_maxline;
!     int		sm_line_lbr;
! } regsubmatch_T;
! 
! static regsubmatch_T rsm;  /* can only be used when can_f_submatch is TRUE */
  #endif
  
  #if defined(FEAT_MODIFY_FNAME) || defined(FEAT_EVAL) || defined(PROTO)
***************
*** 7310,7320 ****
      li = argv->vval.v_list->lv_first;
      for (i = 0; i < 10; ++i)
      {
! 	s = submatch_match->startp[i];
! 	if (s == NULL || submatch_match->endp[i] == NULL)
  	    s = NULL;
  	else
! 	    s = vim_strnsave(s, (int)(submatch_match->endp[i] - s));
  	li->li_tv.v_type = VAR_STRING;
  	li->li_tv.vval.v_string = s;
  	li = li->li_next;
--- 7319,7329 ----
      li = argv->vval.v_list->lv_first;
      for (i = 0; i < 10; ++i)
      {
! 	s = rsm.sm_match->startp[i];
! 	if (s == NULL || rsm.sm_match->endp[i] == NULL)
  	    s = NULL;
  	else
! 	    s = vim_strnsave(s, (int)(rsm.sm_match->endp[i] - s));
  	li->li_tv.v_type = VAR_STRING;
  	li->li_tv.vval.v_string = s;
  	li = li->li_next;
***************
*** 7359,7370 ****
      int		magic,
      int		backslash)
  {
!     reg_match = rmp;
!     reg_mmatch = NULL;
!     reg_maxline = 0;
!     reg_buf = curbuf;
!     reg_line_lbr = TRUE;
!     return vim_regsub_both(source, expr, dest, copy, magic, backslash);
  }
  #endif
  
--- 7368,7394 ----
      int		magic,
      int		backslash)
  {
!     int		result;
!     regexec_T	rex_save;
!     int		rex_in_use_save = rex_in_use;
! 
!     if (rex_in_use)
! 	/* Being called recursively, save the state. */
! 	rex_save = rex;
!     rex_in_use = TRUE;
! 
!     rex.reg_match = rmp;
!     rex.reg_mmatch = NULL;
!     rex.reg_maxline = 0;
!     rex.reg_buf = curbuf;
!     rex.reg_line_lbr = TRUE;
!     result = vim_regsub_both(source, expr, dest, copy, magic, backslash);
! 
!     rex_in_use = rex_in_use_save;
!     if (rex_in_use)
! 	rex = rex_save;
! 
!     return result;
  }
  #endif
  
***************
*** 7378,7390 ****
      int		magic,
      int		backslash)
  {
!     reg_match = NULL;
!     reg_mmatch = rmp;
!     reg_buf = curbuf;		/* always works on the current buffer! */
!     reg_firstlnum = lnum;
!     reg_maxline = curbuf->b_ml.ml_line_count - lnum;
!     reg_line_lbr = FALSE;
!     return vim_regsub_both(source, NULL, dest, copy, magic, backslash);
  }
  
      static int
--- 7402,7429 ----
      int		magic,
      int		backslash)
  {
!     int		result;
!     regexec_T	rex_save;
!     int		rex_in_use_save = rex_in_use;
! 
!     if (rex_in_use)
! 	/* Being called recursively, save the state. */
! 	rex_save = rex;
!     rex_in_use = TRUE;
! 
!     rex.reg_match = NULL;
!     rex.reg_mmatch = rmp;
!     rex.reg_buf = curbuf;	/* always works on the current buffer! */
!     rex.reg_firstlnum = lnum;
!     rex.reg_maxline = curbuf->b_ml.ml_line_count - lnum;
!     rex.reg_line_lbr = FALSE;
!     result = vim_regsub_both(source, NULL, dest, copy, magic, backslash);
! 
!     rex_in_use = rex_in_use_save;
!     if (rex_in_use)
! 	rex = rex_save;
! 
!     return result;
  }
  
      static int
***************
*** 7424,7434 ****
      /*
       * When the substitute part starts with "\=" evaluate it as an expression.
       */
!     if (expr != NULL || (source[0] == '\\' && source[1] == '='
! #ifdef FEAT_EVAL
! 	    && !can_f_submatch	    /* can't do this recursively */
! #endif
! 	    ))
      {
  #ifdef FEAT_EVAL
  	/* To make sure that the length doesn't change between checking the
--- 7463,7469 ----
      /*
       * When the substitute part starts with "\=" evaluate it as an expression.
       */
!     if (expr != NULL || (source[0] == '\\' && source[1] == '='))
      {
  #ifdef FEAT_EVAL
  	/* To make sure that the length doesn't change between checking the
***************
*** 7447,7470 ****
  	}
  	else
  	{
! 	    win_T	*save_reg_win;
! 	    int		save_ireg_ic;
! 	    int		prev_can_f_submatch = can_f_submatch;
  
  	    vim_free(eval_result);
  
  	    /* The expression may contain substitute(), which calls us
  	     * recursively.  Make sure submatch() gets the text from the first
! 	     * level.  Don't need to save "reg_buf", because
! 	     * vim_regexec_multi() can't be called recursively. */
! 	    submatch_match = reg_match;
! 	    submatch_mmatch = reg_mmatch;
! 	    submatch_firstlnum = reg_firstlnum;
! 	    submatch_maxline = reg_maxline;
! 	    submatch_line_lbr = reg_line_lbr;
! 	    save_reg_win = reg_win;
! 	    save_ireg_ic = ireg_ic;
  	    can_f_submatch = TRUE;
  
  	    if (expr != NULL)
  	    {
--- 7482,7503 ----
  	}
  	else
  	{
! 	    int		    prev_can_f_submatch = can_f_submatch;
! 	    regsubmatch_T   rsm_save;
  
  	    vim_free(eval_result);
  
  	    /* The expression may contain substitute(), which calls us
  	     * recursively.  Make sure submatch() gets the text from the first
! 	     * level. */
! 	    if (can_f_submatch)
! 		rsm_save = rsm;
  	    can_f_submatch = TRUE;
+ 	    rsm.sm_match = rex.reg_match;
+ 	    rsm.sm_mmatch = rex.reg_mmatch;
+ 	    rsm.sm_firstlnum = rex.reg_firstlnum;
+ 	    rsm.sm_maxline = rex.reg_maxline;
+ 	    rsm.sm_line_lbr = rex.reg_line_lbr;
  
  	    if (expr != NULL)
  	    {
***************
*** 7476,7510 ****
  
  		rettv.v_type = VAR_STRING;
  		rettv.vval.v_string = NULL;
! 		if (prev_can_f_submatch)
! 		{
! 		    /* can't do this recursively */
! 		}
! 		else
! 		{
! 		    argv[0].v_type = VAR_LIST;
! 		    argv[0].vval.v_list = &matchList.sl_list;
! 		    matchList.sl_list.lv_len = 0;
! 		    if (expr->v_type == VAR_FUNC)
! 		    {
! 			s = expr->vval.v_string;
! 			call_func(s, (int)STRLEN(s), &rettv,
! 					1, argv, fill_submatch_list,
! 					     0L, 0L, &dummy, TRUE, NULL, NULL);
! 		    }
! 		    else if (expr->v_type == VAR_PARTIAL)
! 		    {
! 			partial_T   *partial = expr->vval.v_partial;
  
- 			s = partial_name(partial);
- 			call_func(s, (int)STRLEN(s), &rettv,
- 					1, argv, fill_submatch_list,
- 					  0L, 0L, &dummy, TRUE, partial, NULL);
- 		    }
- 		    if (matchList.sl_list.lv_len > 0)
- 			/* fill_submatch_list() was called */
- 			clear_submatch_list(&matchList);
- 		}
  		eval_result = get_tv_string_buf_chk(&rettv, buf);
  		if (eval_result != NULL)
  		    eval_result = vim_strsave(eval_result);
--- 7509,7537 ----
  
  		rettv.v_type = VAR_STRING;
  		rettv.vval.v_string = NULL;
! 		argv[0].v_type = VAR_LIST;
! 		argv[0].vval.v_list = &matchList.sl_list;
! 		matchList.sl_list.lv_len = 0;
! 		if (expr->v_type == VAR_FUNC)
! 		{
! 		    s = expr->vval.v_string;
! 		    call_func(s, (int)STRLEN(s), &rettv,
! 				    1, argv, fill_submatch_list,
! 					 0L, 0L, &dummy, TRUE, NULL, NULL);
! 		}
! 		else if (expr->v_type == VAR_PARTIAL)
! 		{
! 		    partial_T   *partial = expr->vval.v_partial;
! 
! 		    s = partial_name(partial);
! 		    call_func(s, (int)STRLEN(s), &rettv,
! 				    1, argv, fill_submatch_list,
! 				      0L, 0L, &dummy, TRUE, partial, NULL);
! 		}
! 		if (matchList.sl_list.lv_len > 0)
! 		    /* fill_submatch_list() was called */
! 		    clear_submatch_list(&matchList);
  
  		eval_result = get_tv_string_buf_chk(&rettv, buf);
  		if (eval_result != NULL)
  		    eval_result = vim_strsave(eval_result);
***************
*** 7522,7528 ****
  		    /* Change NL to CR, so that it becomes a line break,
  		     * unless called from vim_regexec_nl().
  		     * Skip over a backslashed character. */
! 		    if (*s == NL && !submatch_line_lbr)
  			*s = CAR;
  		    else if (*s == '\\' && s[1] != NUL)
  		    {
--- 7549,7555 ----
  		    /* Change NL to CR, so that it becomes a line break,
  		     * unless called from vim_regexec_nl().
  		     * Skip over a backslashed character. */
! 		    if (*s == NL && !rsm.sm_line_lbr)
  			*s = CAR;
  		    else if (*s == '\\' && s[1] != NUL)
  		    {
***************
*** 7533,7539 ****
  			 *   def
  			 * Not when called from vim_regexec_nl().
  			 */
! 			if (*s == NL && !submatch_line_lbr)
  			    *s = CAR;
  			had_backslash = TRUE;
  		    }
--- 7560,7566 ----
  			 *   def
  			 * Not when called from vim_regexec_nl().
  			 */
! 			if (*s == NL && !rsm.sm_line_lbr)
  			    *s = CAR;
  			had_backslash = TRUE;
  		    }
***************
*** 7552,7565 ****
  		dst += STRLEN(eval_result);
  	    }
  
! 	    reg_match = submatch_match;
! 	    reg_mmatch = submatch_mmatch;
! 	    reg_firstlnum = submatch_firstlnum;
! 	    reg_maxline = submatch_maxline;
! 	    reg_line_lbr = submatch_line_lbr;
! 	    reg_win = save_reg_win;
! 	    ireg_ic = save_ireg_ic;
! 	    can_f_submatch = FALSE;
  	}
  #endif
      }
--- 7579,7587 ----
  		dst += STRLEN(eval_result);
  	    }
  
! 	    can_f_submatch = prev_can_f_submatch;
! 	    if (can_f_submatch)
! 		rsm = rsm_save;
  	}
  #endif
      }
***************
*** 7688,7713 ****
  	{
  	    if (REG_MULTI)
  	    {
! 		clnum = reg_mmatch->startpos[no].lnum;
! 		if (clnum < 0 || reg_mmatch->endpos[no].lnum < 0)
  		    s = NULL;
  		else
  		{
! 		    s = reg_getline(clnum) + reg_mmatch->startpos[no].col;
! 		    if (reg_mmatch->endpos[no].lnum == clnum)
! 			len = reg_mmatch->endpos[no].col
! 					       - reg_mmatch->startpos[no].col;
  		    else
  			len = (int)STRLEN(s);
  		}
  	    }
  	    else
  	    {
! 		s = reg_match->startp[no];
! 		if (reg_match->endp[no] == NULL)
  		    s = NULL;
  		else
! 		    len = (int)(reg_match->endp[no] - s);
  	    }
  	    if (s != NULL)
  	    {
--- 7710,7735 ----
  	{
  	    if (REG_MULTI)
  	    {
! 		clnum = rex.reg_mmatch->startpos[no].lnum;
! 		if (clnum < 0 || rex.reg_mmatch->endpos[no].lnum < 0)
  		    s = NULL;
  		else
  		{
! 		    s = reg_getline(clnum) + rex.reg_mmatch->startpos[no].col;
! 		    if (rex.reg_mmatch->endpos[no].lnum == clnum)
! 			len = rex.reg_mmatch->endpos[no].col
! 					    - rex.reg_mmatch->startpos[no].col;
  		    else
  			len = (int)STRLEN(s);
  		}
  	    }
  	    else
  	    {
! 		s = rex.reg_match->startp[no];
! 		if (rex.reg_match->endp[no] == NULL)
  		    s = NULL;
  		else
! 		    len = (int)(rex.reg_match->endp[no] - s);
  	    }
  	    if (s != NULL)
  	    {
***************
*** 7717,7730 ****
  		    {
  			if (REG_MULTI)
  			{
! 			    if (reg_mmatch->endpos[no].lnum == clnum)
  				break;
  			    if (copy)
  				*dst = CAR;
  			    ++dst;
  			    s = reg_getline(++clnum);
! 			    if (reg_mmatch->endpos[no].lnum == clnum)
! 				len = reg_mmatch->endpos[no].col;
  			    else
  				len = (int)STRLEN(s);
  			}
--- 7739,7752 ----
  		    {
  			if (REG_MULTI)
  			{
! 			    if (rex.reg_mmatch->endpos[no].lnum == clnum)
  				break;
  			    if (copy)
  				*dst = CAR;
  			    ++dst;
  			    s = reg_getline(++clnum);
! 			    if (rex.reg_mmatch->endpos[no].lnum == clnum)
! 				len = rex.reg_mmatch->endpos[no].col;
  			    else
  				len = (int)STRLEN(s);
  			}
***************
*** 7824,7839 ****
  reg_getline_submatch(linenr_T lnum)
  {
      char_u *s;
!     linenr_T save_first = reg_firstlnum;
!     linenr_T save_max = reg_maxline;
  
!     reg_firstlnum = submatch_firstlnum;
!     reg_maxline = submatch_maxline;
  
      s = reg_getline(lnum);
  
!     reg_firstlnum = save_first;
!     reg_maxline = save_max;
      return s;
  }
  
--- 7846,7861 ----
  reg_getline_submatch(linenr_T lnum)
  {
      char_u *s;
!     linenr_T save_first = rex.reg_firstlnum;
!     linenr_T save_max = rex.reg_maxline;
  
!     rex.reg_firstlnum = rsm.sm_firstlnum;
!     rex.reg_maxline = rsm.sm_maxline;
  
      s = reg_getline(lnum);
  
!     rex.reg_firstlnum = save_first;
!     rex.reg_maxline = save_max;
      return s;
  }
  
***************
*** 7854,7860 ****
      if (!can_f_submatch || no < 0)
  	return NULL;
  
!     if (submatch_match == NULL)
      {
  	/*
  	 * First round: compute the length and allocate memory.
--- 7876,7882 ----
      if (!can_f_submatch || no < 0)
  	return NULL;
  
!     if (rsm.sm_match == NULL)
      {
  	/*
  	 * First round: compute the length and allocate memory.
***************
*** 7862,7879 ****
  	 */
  	for (round = 1; round <= 2; ++round)
  	{
! 	    lnum = submatch_mmatch->startpos[no].lnum;
! 	    if (lnum < 0 || submatch_mmatch->endpos[no].lnum < 0)
  		return NULL;
  
! 	    s = reg_getline_submatch(lnum) + submatch_mmatch->startpos[no].col;
  	    if (s == NULL)  /* anti-crash check, cannot happen? */
  		break;
! 	    if (submatch_mmatch->endpos[no].lnum == lnum)
  	    {
  		/* Within one line: take form start to end col. */
! 		len = submatch_mmatch->endpos[no].col
! 					  - submatch_mmatch->startpos[no].col;
  		if (round == 2)
  		    vim_strncpy(retval, s, len);
  		++len;
--- 7884,7901 ----
  	 */
  	for (round = 1; round <= 2; ++round)
  	{
! 	    lnum = rsm.sm_mmatch->startpos[no].lnum;
! 	    if (lnum < 0 || rsm.sm_mmatch->endpos[no].lnum < 0)
  		return NULL;
  
! 	    s = reg_getline_submatch(lnum) + rsm.sm_mmatch->startpos[no].col;
  	    if (s == NULL)  /* anti-crash check, cannot happen? */
  		break;
! 	    if (rsm.sm_mmatch->endpos[no].lnum == lnum)
  	    {
  		/* Within one line: take form start to end col. */
! 		len = rsm.sm_mmatch->endpos[no].col
! 					  - rsm.sm_mmatch->startpos[no].col;
  		if (round == 2)
  		    vim_strncpy(retval, s, len);
  		++len;
***************
*** 7890,7896 ****
  		}
  		++len;
  		++lnum;
! 		while (lnum < submatch_mmatch->endpos[no].lnum)
  		{
  		    s = reg_getline_submatch(lnum++);
  		    if (round == 2)
--- 7912,7918 ----
  		}
  		++len;
  		++lnum;
! 		while (lnum < rsm.sm_mmatch->endpos[no].lnum)
  		{
  		    s = reg_getline_submatch(lnum++);
  		    if (round == 2)
***************
*** 7902,7909 ****
  		}
  		if (round == 2)
  		    STRNCPY(retval + len, reg_getline_submatch(lnum),
! 					     submatch_mmatch->endpos[no].col);
! 		len += submatch_mmatch->endpos[no].col;
  		if (round == 2)
  		    retval[len] = NUL;
  		++len;
--- 7924,7931 ----
  		}
  		if (round == 2)
  		    STRNCPY(retval + len, reg_getline_submatch(lnum),
! 					     rsm.sm_mmatch->endpos[no].col);
! 		len += rsm.sm_mmatch->endpos[no].col;
  		if (round == 2)
  		    retval[len] = NUL;
  		++len;
***************
*** 7919,7929 ****
      }
      else
      {
! 	s = submatch_match->startp[no];
! 	if (s == NULL || submatch_match->endp[no] == NULL)
  	    retval = NULL;
  	else
! 	    retval = vim_strnsave(s, (int)(submatch_match->endp[no] - s));
      }
  
      return retval;
--- 7941,7951 ----
      }
      else
      {
! 	s = rsm.sm_match->startp[no];
! 	if (s == NULL || rsm.sm_match->endp[no] == NULL)
  	    retval = NULL;
  	else
! 	    retval = vim_strnsave(s, (int)(rsm.sm_match->endp[no] - s));
      }
  
      return retval;
***************
*** 7951,7965 ****
      if (!can_f_submatch || no < 0)
  	return NULL;
  
!     if (submatch_match == NULL)
      {
! 	slnum = submatch_mmatch->startpos[no].lnum;
! 	elnum = submatch_mmatch->endpos[no].lnum;
  	if (slnum < 0 || elnum < 0)
  	    return NULL;
  
! 	scol = submatch_mmatch->startpos[no].col;
! 	ecol = submatch_mmatch->endpos[no].col;
  
  	list = list_alloc();
  	if (list == NULL)
--- 7973,7987 ----
      if (!can_f_submatch || no < 0)
  	return NULL;
  
!     if (rsm.sm_match == NULL)
      {
! 	slnum = rsm.sm_mmatch->startpos[no].lnum;
! 	elnum = rsm.sm_mmatch->endpos[no].lnum;
  	if (slnum < 0 || elnum < 0)
  	    return NULL;
  
! 	scol = rsm.sm_mmatch->startpos[no].col;
! 	ecol = rsm.sm_mmatch->endpos[no].col;
  
  	list = list_alloc();
  	if (list == NULL)
***************
*** 7988,8001 ****
      }
      else
      {
! 	s = submatch_match->startp[no];
! 	if (s == NULL || submatch_match->endp[no] == NULL)
  	    return NULL;
  	list = list_alloc();
  	if (list == NULL)
  	    return NULL;
  	if (list_append_string(list, s,
! 				 (int)(submatch_match->endp[no] - s)) == FAIL)
  	    error = TRUE;
      }
  
--- 8010,8023 ----
      }
      else
      {
! 	s = rsm.sm_match->startp[no];
! 	if (s == NULL || rsm.sm_match->endp[no] == NULL)
  	    return NULL;
  	list = list_alloc();
  	if (list == NULL)
  	    return NULL;
  	if (list_append_string(list, s,
! 				 (int)(rsm.sm_match->endp[no] - s)) == FAIL)
  	    error = TRUE;
      }
  
***************
*** 8173,8179 ****
      colnr_T	col,    /* column to start looking for match */
      int		nl)
  {
!     int result = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);
  
      /* NFA engine aborted because it's very slow. */
      if (rmp->regprog->re_engine == AUTOMATIC_ENGINE
--- 8195,8214 ----
      colnr_T	col,    /* column to start looking for match */
      int		nl)
  {
!     int		result;
!     regexec_T	rex_save;
!     int		rex_in_use_save = rex_in_use;
! 
!     if (rex_in_use)
! 	/* Being called recursively, save the state. */
! 	rex_save = rex;
!     rex_in_use = TRUE;
!     rex.reg_startp = NULL;
!     rex.reg_endp = NULL;
!     rex.reg_startpos = NULL;
!     rex.reg_endpos = NULL;
! 
!     result = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);
  
      /* NFA engine aborted because it's very slow. */
      if (rmp->regprog->re_engine == AUTOMATIC_ENGINE
***************
*** 8198,8203 ****
--- 8233,8243 ----
  
  	p_re = save_p_re;
      }
+ 
+     rex_in_use = rex_in_use_save;
+     if (rex_in_use)
+ 	rex = rex_save;
+ 
      return result > 0;
  }
  
***************
*** 8264,8271 ****
      colnr_T     col,            /* column to start looking for match */
      proftime_T	*tm)		/* timeout limit or NULL */
  {
!     int result = rmp->regprog->engine->regexec_multi(
! 						rmp, win, buf, lnum, col, tm);
  
      /* NFA engine aborted because it's very slow. */
      if (rmp->regprog->re_engine == AUTOMATIC_ENGINE
--- 8304,8319 ----
      colnr_T     col,            /* column to start looking for match */
      proftime_T	*tm)		/* timeout limit or NULL */
  {
!     int		result;
!     regexec_T	rex_save;
!     int		rex_in_use_save = rex_in_use;
! 
!     if (rex_in_use)
! 	/* Being called recursively, save the state. */
! 	rex_save = rex;
!     rex_in_use = TRUE;
! 
!     result = rmp->regprog->engine->regexec_multi(rmp, win, buf, lnum, col, tm);
  
      /* NFA engine aborted because it's very slow. */
      if (rmp->regprog->re_engine == AUTOMATIC_ENGINE
***************
*** 8291,8295 ****
--- 8339,8347 ----
  	p_re = save_p_re;
      }
  
+     rex_in_use = rex_in_use_save;
+     if (rex_in_use)
+ 	rex = rex_save;
+ 
      return result <= 0 ? 0 : result;
  }
*** ../vim-8.0.0019/src/regexp_nfa.c	2016-09-09 20:26:46.000000000 +0200
--- src/regexp_nfa.c	2016-10-02 15:51:12.173504331 +0200
***************
*** 5432,5438 ****
      char_u *s;
  
      /* Used often, do some work to avoid call overhead. */
!     if (!ireg_ic
  #ifdef FEAT_MBYTE
  		&& !has_mbyte
  #endif
--- 5432,5438 ----
      char_u *s;
  
      /* Used often, do some work to avoid call overhead. */
!     if (!rex.reg_ic
  #ifdef FEAT_MBYTE
  		&& !has_mbyte
  #endif
***************
*** 5467,5473 ****
  	{
  	    c1 = PTR2CHAR(match_text + len1);
  	    c2 = PTR2CHAR(regline + col + len2);
! 	    if (c1 != c2 && (!ireg_ic || MB_TOLOWER(c1) != MB_TOLOWER(c2)))
  	    {
  		match = FALSE;
  		break;
--- 5467,5473 ----
  	{
  	    c1 = PTR2CHAR(match_text + len1);
  	    c2 = PTR2CHAR(regline + col + len2);
! 	    if (c1 != c2 && (!rex.reg_ic || MB_TOLOWER(c1) != MB_TOLOWER(c2)))
  	    {
  		match = FALSE;
  		break;
***************
*** 5485,5499 ****
  	    cleanup_subexpr();
  	    if (REG_MULTI)
  	    {
! 		reg_startpos[0].lnum = reglnum;
! 		reg_startpos[0].col = col;
! 		reg_endpos[0].lnum = reglnum;
! 		reg_endpos[0].col = col + len2;
  	    }
  	    else
  	    {
! 		reg_startp[0] = regline + col;
! 		reg_endp[0] = regline + col + len2;
  	    }
  	    return 1L;
  	}
--- 5485,5499 ----
  	    cleanup_subexpr();
  	    if (REG_MULTI)
  	    {
! 		rex.reg_startpos[0].lnum = reglnum;
! 		rex.reg_startpos[0].col = col;
! 		rex.reg_endpos[0].lnum = reglnum;
! 		rex.reg_endpos[0].col = col + len2;
  	    }
  	    else
  	    {
! 		rex.reg_startp[0] = regline + col;
! 		rex.reg_endp[0] = regline + col + len2;
  	    }
  	    return 1L;
  	}
***************
*** 5728,5735 ****
  	      {
  #ifdef FEAT_MBYTE
  		/* If the match ends before a composing characters and
! 		 * ireg_icombine is not set, that is not really a match. */
! 		if (enc_utf8 && !ireg_icombine && utf_iscomposing(curc))
  		    break;
  #endif
  		nfa_match = TRUE;
--- 5728,5735 ----
  	      {
  #ifdef FEAT_MBYTE
  		/* If the match ends before a composing characters and
! 		 * rex.reg_icombine is not set, that is not really a match. */
! 		if (enc_utf8 && !rex.reg_icombine && utf_iscomposing(curc))
  		    break;
  #endif
  		nfa_match = TRUE;
***************
*** 6048,6063 ****
  		    int this_class;
  
  		    /* Get class of current and previous char (if it exists). */
! 		    this_class = mb_get_class_buf(reginput, reg_buf);
  		    if (this_class <= 1)
  			result = FALSE;
  		    else if (reg_prev_class() == this_class)
  			result = FALSE;
  		}
  #endif
! 		else if (!vim_iswordc_buf(curc, reg_buf)
  			   || (reginput > regline
! 				   && vim_iswordc_buf(reginput[-1], reg_buf)))
  		    result = FALSE;
  		if (result)
  		{
--- 6048,6063 ----
  		    int this_class;
  
  		    /* Get class of current and previous char (if it exists). */
! 		    this_class = mb_get_class_buf(reginput, rex.reg_buf);
  		    if (this_class <= 1)
  			result = FALSE;
  		    else if (reg_prev_class() == this_class)
  			result = FALSE;
  		}
  #endif
! 		else if (!vim_iswordc_buf(curc, rex.reg_buf)
  			   || (reginput > regline
! 				&& vim_iswordc_buf(reginput[-1], rex.reg_buf)))
  		    result = FALSE;
  		if (result)
  		{
***************
*** 6076,6091 ****
  		    int this_class, prev_class;
  
  		    /* Get class of current and previous char (if it exists). */
! 		    this_class = mb_get_class_buf(reginput, reg_buf);
  		    prev_class = reg_prev_class();
  		    if (this_class == prev_class
  					|| prev_class == 0 || prev_class == 1)
  			result = FALSE;
  		}
  #endif
! 		else if (!vim_iswordc_buf(reginput[-1], reg_buf)
  			|| (reginput[0] != NUL
! 					   && vim_iswordc_buf(curc, reg_buf)))
  		    result = FALSE;
  		if (result)
  		{
--- 6076,6091 ----
  		    int this_class, prev_class;
  
  		    /* Get class of current and previous char (if it exists). */
! 		    this_class = mb_get_class_buf(reginput, rex.reg_buf);
  		    prev_class = reg_prev_class();
  		    if (this_class == prev_class
  					|| prev_class == 0 || prev_class == 1)
  			result = FALSE;
  		}
  #endif
! 		else if (!vim_iswordc_buf(reginput[-1], rex.reg_buf)
  			|| (reginput[0] != NUL
! 					&& vim_iswordc_buf(curc, rex.reg_buf)))
  		    result = FALSE;
  		if (result)
  		{
***************
*** 6096,6102 ****
  
  	    case NFA_BOF:
  		if (reglnum == 0 && reginput == regline
! 					&& (!REG_MULTI || reg_firstlnum == 1))
  		{
  		    add_here = TRUE;
  		    add_state = t->state->out;
--- 6096,6102 ----
  
  	    case NFA_BOF:
  		if (reglnum == 0 && reginput == regline
! 				     && (!REG_MULTI || rex.reg_firstlnum == 1))
  		{
  		    add_here = TRUE;
  		    add_state = t->state->out;
***************
*** 6104,6110 ****
  		break;
  
  	    case NFA_EOF:
! 		if (reglnum == reg_maxline && curc == NUL)
  		{
  		    add_here = TRUE;
  		    add_state = t->state->out;
--- 6104,6110 ----
  		break;
  
  	    case NFA_EOF:
! 		if (reglnum == rex.reg_maxline && curc == NUL)
  		{
  		    add_here = TRUE;
  		    add_state = t->state->out;
***************
*** 6131,6137 ****
  		     * (no preceding character). */
  		    len += mb_char2len(mc);
  		}
! 		if (ireg_icombine && len == 0)
  		{
  		    /* If \Z was present, then ignore composing characters.
  		     * When ignoring the base character this always matches. */
--- 6131,6137 ----
  		     * (no preceding character). */
  		    len += mb_char2len(mc);
  		}
! 		if (rex.reg_icombine && len == 0)
  		{
  		    /* If \Z was present, then ignore composing characters.
  		     * When ignoring the base character this always matches. */
***************
*** 6190,6197 ****
  #endif
  
  	    case NFA_NEWL:
! 		if (curc == NUL && !reg_line_lbr && REG_MULTI
! 						    && reglnum <= reg_maxline)
  		{
  		    go_to_nextline = TRUE;
  		    /* Pass -1 for the offset, which means taking the position
--- 6190,6197 ----
  #endif
  
  	    case NFA_NEWL:
! 		if (curc == NUL && !rex.reg_line_lbr && REG_MULTI
! 						 && reglnum <= rex.reg_maxline)
  		{
  		    go_to_nextline = TRUE;
  		    /* Pass -1 for the offset, which means taking the position
***************
*** 6199,6205 ****
  		    add_state = t->state->out;
  		    add_off = -1;
  		}
! 		else if (curc == '\n' && reg_line_lbr)
  		{
  		    /* match \n as if it is an ordinary character */
  		    add_state = t->state->out;
--- 6199,6205 ----
  		    add_state = t->state->out;
  		    add_off = -1;
  		}
! 		else if (curc == '\n' && rex.reg_line_lbr)
  		{
  		    /* match \n as if it is an ordinary character */
  		    add_state = t->state->out;
***************
*** 6244,6250 ****
  			    result = result_if_matched;
  			    break;
  			}
! 			if (ireg_ic)
  			{
  			    int curc_low = MB_TOLOWER(curc);
  			    int done = FALSE;
--- 6244,6250 ----
  			    result = result_if_matched;
  			    break;
  			}
! 			if (rex.reg_ic)
  			{
  			    int curc_low = MB_TOLOWER(curc);
  			    int done = FALSE;
***************
*** 6262,6268 ****
  		    }
  		    else if (state->c < 0 ? check_char_class(state->c, curc)
  			        : (curc == state->c
! 				   || (ireg_ic && MB_TOLOWER(curc)
  						    == MB_TOLOWER(state->c))))
  		    {
  			result = result_if_matched;
--- 6262,6268 ----
  		    }
  		    else if (state->c < 0 ? check_char_class(state->c, curc)
  			        : (curc == state->c
! 				   || (rex.reg_ic && MB_TOLOWER(curc)
  						    == MB_TOLOWER(state->c))))
  		    {
  			result = result_if_matched;
***************
*** 6320,6332 ****
  		break;
  
  	    case NFA_KWORD:	/*  \k	*/
! 		result = vim_iswordp_buf(reginput, reg_buf);
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
  	    case NFA_SKWORD:	/*  \K	*/
  		result = !VIM_ISDIGIT(curc)
! 					&& vim_iswordp_buf(reginput, reg_buf);
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
--- 6320,6332 ----
  		break;
  
  	    case NFA_KWORD:	/*  \k	*/
! 		result = vim_iswordp_buf(reginput, rex.reg_buf);
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
  	    case NFA_SKWORD:	/*  \K	*/
  		result = !VIM_ISDIGIT(curc)
! 				     && vim_iswordp_buf(reginput, rex.reg_buf);
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
***************
*** 6441,6464 ****
  		break;
  
  	    case NFA_LOWER_IC:	/* [a-z] */
! 		result = ri_lower(curc) || (ireg_ic && ri_upper(curc));
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
  	    case NFA_NLOWER_IC:	/* [^a-z] */
  		result = curc != NUL
! 			  && !(ri_lower(curc) || (ireg_ic && ri_upper(curc)));
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
  	    case NFA_UPPER_IC:	/* [A-Z] */
! 		result = ri_upper(curc) || (ireg_ic && ri_lower(curc));
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
  	    case NFA_NUPPER_IC:	/* ^[A-Z] */
  		result = curc != NUL
! 			  && !(ri_upper(curc) || (ireg_ic && ri_lower(curc)));
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
--- 6441,6464 ----
  		break;
  
  	    case NFA_LOWER_IC:	/* [a-z] */
! 		result = ri_lower(curc) || (rex.reg_ic && ri_upper(curc));
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
  	    case NFA_NLOWER_IC:	/* [^a-z] */
  		result = curc != NUL
! 			&& !(ri_lower(curc) || (rex.reg_ic && ri_upper(curc)));
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
  	    case NFA_UPPER_IC:	/* [A-Z] */
! 		result = ri_upper(curc) || (rex.reg_ic && ri_lower(curc));
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
  	    case NFA_NUPPER_IC:	/* ^[A-Z] */
  		result = curc != NUL
! 			&& !(ri_upper(curc) || (rex.reg_ic && ri_lower(curc)));
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
***************
*** 6549,6555 ****
  	    case NFA_LNUM_LT:
  		result = (REG_MULTI &&
  			nfa_re_num_cmp(t->state->val, t->state->c - NFA_LNUM,
! 			    (long_u)(reglnum + reg_firstlnum)));
  		if (result)
  		{
  		    add_here = TRUE;
--- 6549,6555 ----
  	    case NFA_LNUM_LT:
  		result = (REG_MULTI &&
  			nfa_re_num_cmp(t->state->val, t->state->c - NFA_LNUM,
! 			    (long_u)(reglnum + rex.reg_firstlnum)));
  		if (result)
  		{
  		    add_here = TRUE;
***************
*** 6575,6581 ****
  		{
  		    int     op = t->state->c - NFA_VCOL;
  		    colnr_T col = (colnr_T)(reginput - regline);
! 		    win_T   *wp = reg_win == NULL ? curwin : reg_win;
  
  		    /* Bail out quickly when there can't be a match, avoid the
  		     * overhead of win_linetabsize() on long lines. */
--- 6575,6581 ----
  		{
  		    int     op = t->state->c - NFA_VCOL;
  		    colnr_T col = (colnr_T)(reginput - regline);
! 		    win_T   *wp = rex.reg_win == NULL ? curwin : rex.reg_win;
  
  		    /* Bail out quickly when there can't be a match, avoid the
  		     * overhead of win_linetabsize() on long lines. */
***************
*** 6611,6628 ****
  	    case NFA_MARK_GT:
  	    case NFA_MARK_LT:
  	      {
! 		pos_T	*pos = getmark_buf(reg_buf, t->state->val, FALSE);
  
  		/* Compare the mark position to the match position. */
  		result = (pos != NULL		     /* mark doesn't exist */
  			&& pos->lnum > 0    /* mark isn't set in reg_buf */
! 			&& (pos->lnum == reglnum + reg_firstlnum
  				? (pos->col == (colnr_T)(reginput - regline)
  				    ? t->state->c == NFA_MARK
  				    : (pos->col < (colnr_T)(reginput - regline)
  					? t->state->c == NFA_MARK_GT
  					: t->state->c == NFA_MARK_LT))
! 				: (pos->lnum < reglnum + reg_firstlnum
  				    ? t->state->c == NFA_MARK_GT
  				    : t->state->c == NFA_MARK_LT)));
  		if (result)
--- 6611,6628 ----
  	    case NFA_MARK_GT:
  	    case NFA_MARK_LT:
  	      {
! 		pos_T	*pos = getmark_buf(rex.reg_buf, t->state->val, FALSE);
  
  		/* Compare the mark position to the match position. */
  		result = (pos != NULL		     /* mark doesn't exist */
  			&& pos->lnum > 0    /* mark isn't set in reg_buf */
! 			&& (pos->lnum == reglnum + rex.reg_firstlnum
  				? (pos->col == (colnr_T)(reginput - regline)
  				    ? t->state->c == NFA_MARK
  				    : (pos->col < (colnr_T)(reginput - regline)
  					? t->state->c == NFA_MARK_GT
  					: t->state->c == NFA_MARK_LT))
! 				: (pos->lnum < reglnum + rex.reg_firstlnum
  				    ? t->state->c == NFA_MARK_GT
  				    : t->state->c == NFA_MARK_LT)));
  		if (result)
***************
*** 6634,6643 ****
  	      }
  
  	    case NFA_CURSOR:
! 		result = (reg_win != NULL
! 			&& (reglnum + reg_firstlnum == reg_win->w_cursor.lnum)
  			&& ((colnr_T)(reginput - regline)
! 						   == reg_win->w_cursor.col));
  		if (result)
  		{
  		    add_here = TRUE;
--- 6634,6644 ----
  	      }
  
  	    case NFA_CURSOR:
! 		result = (rex.reg_win != NULL
! 			&& (reglnum + rex.reg_firstlnum
! 						 == rex.reg_win->w_cursor.lnum)
  			&& ((colnr_T)(reginput - regline)
! 						== rex.reg_win->w_cursor.col));
  		if (result)
  		{
  		    add_here = TRUE;
***************
*** 6691,6702 ****
  #endif
  		result = (c == curc);
  
! 		if (!result && ireg_ic)
  		    result = MB_TOLOWER(c) == MB_TOLOWER(curc);
  #ifdef FEAT_MBYTE
! 		/* If ireg_icombine is not set only skip over the character
  		 * itself.  When it is set skip over composing characters. */
! 		if (result && enc_utf8 && !ireg_icombine)
  		    clen = utf_ptr2len(reginput);
  #endif
  		ADD_STATE_IF_MATCH(t->state);
--- 6692,6703 ----
  #endif
  		result = (c == curc);
  
! 		if (!result && rex.reg_ic)
  		    result = MB_TOLOWER(c) == MB_TOLOWER(curc);
  #ifdef FEAT_MBYTE
! 		/* If rex.reg_icombine is not set only skip over the character
  		 * itself.  When it is set skip over composing characters. */
! 		if (result && enc_utf8 && !rex.reg_icombine)
  		    clen = utf_ptr2len(reginput);
  #endif
  		ADD_STATE_IF_MATCH(t->state);
***************
*** 6815,6822 ****
  		&& ((toplevel
  			&& reglnum == 0
  			&& clen != 0
! 			&& (ireg_maxcol == 0
! 			    || (colnr_T)(reginput - regline) < ireg_maxcol))
  		    || (nfa_endp != NULL
  			&& (REG_MULTI
  			    ? (reglnum < nfa_endp->se_u.pos.lnum
--- 6816,6823 ----
  		&& ((toplevel
  			&& reglnum == 0
  			&& clen != 0
! 			&& (rex.reg_maxcol == 0
! 			    || (colnr_T)(reginput - regline) < rex.reg_maxcol))
  		    || (nfa_endp != NULL
  			&& (REG_MULTI
  			    ? (reglnum < nfa_endp->se_u.pos.lnum
***************
*** 6856,6863 ****
  			/* Checking if the required start character matches is
  			 * cheaper than adding a state that won't match. */
  			c = PTR2CHAR(reginput + clen);
! 			if (c != prog->regstart && (!ireg_ic || MB_TOLOWER(c)
! 					       != MB_TOLOWER(prog->regstart)))
  			{
  #ifdef ENABLE_LOG
  			    fprintf(log_fd, "  Skipping start state, regstart does not match\n");
--- 6857,6864 ----
  			/* Checking if the required start character matches is
  			 * cheaper than adding a state that won't match. */
  			c = PTR2CHAR(reginput + clen);
! 			if (c != prog->regstart && (!rex.reg_ic
! 			       || MB_TOLOWER(c) != MB_TOLOWER(prog->regstart)))
  			{
  #ifdef ENABLE_LOG
  			    fprintf(log_fd, "  Skipping start state, regstart does not match\n");
***************
*** 6997,7036 ****
      {
  	for (i = 0; i < subs.norm.in_use; i++)
  	{
! 	    reg_startpos[i].lnum = subs.norm.list.multi[i].start_lnum;
! 	    reg_startpos[i].col = subs.norm.list.multi[i].start_col;
  
! 	    reg_endpos[i].lnum = subs.norm.list.multi[i].end_lnum;
! 	    reg_endpos[i].col = subs.norm.list.multi[i].end_col;
  	}
  
! 	if (reg_startpos[0].lnum < 0)
  	{
! 	    reg_startpos[0].lnum = 0;
! 	    reg_startpos[0].col = col;
  	}
! 	if (reg_endpos[0].lnum < 0)
  	{
  	    /* pattern has a \ze but it didn't match, use current end */
! 	    reg_endpos[0].lnum = reglnum;
! 	    reg_endpos[0].col = (int)(reginput - regline);
  	}
  	else
  	    /* Use line number of "\ze". */
! 	    reglnum = reg_endpos[0].lnum;
      }
      else
      {
  	for (i = 0; i < subs.norm.in_use; i++)
  	{
! 	    reg_startp[i] = subs.norm.list.line[i].start;
! 	    reg_endp[i] = subs.norm.list.line[i].end;
  	}
  
! 	if (reg_startp[0] == NULL)
! 	    reg_startp[0] = regline + col;
! 	if (reg_endp[0] == NULL)
! 	    reg_endp[0] = reginput;
      }
  
  #ifdef FEAT_SYN_HL
--- 6998,7037 ----
      {
  	for (i = 0; i < subs.norm.in_use; i++)
  	{
! 	    rex.reg_startpos[i].lnum = subs.norm.list.multi[i].start_lnum;
! 	    rex.reg_startpos[i].col = subs.norm.list.multi[i].start_col;
  
! 	    rex.reg_endpos[i].lnum = subs.norm.list.multi[i].end_lnum;
! 	    rex.reg_endpos[i].col = subs.norm.list.multi[i].end_col;
  	}
  
! 	if (rex.reg_startpos[0].lnum < 0)
  	{
! 	    rex.reg_startpos[0].lnum = 0;
! 	    rex.reg_startpos[0].col = col;
  	}
! 	if (rex.reg_endpos[0].lnum < 0)
  	{
  	    /* pattern has a \ze but it didn't match, use current end */
! 	    rex.reg_endpos[0].lnum = reglnum;
! 	    rex.reg_endpos[0].col = (int)(reginput - regline);
  	}
  	else
  	    /* Use line number of "\ze". */
! 	    reglnum = rex.reg_endpos[0].lnum;
      }
      else
      {
  	for (i = 0; i < subs.norm.in_use; i++)
  	{
! 	    rex.reg_startp[i] = subs.norm.list.line[i].start;
! 	    rex.reg_endp[i] = subs.norm.list.line[i].end;
  	}
  
! 	if (rex.reg_startp[0] == NULL)
! 	    rex.reg_startp[0] = regline + col;
! 	if (rex.reg_endp[0] == NULL)
! 	    rex.reg_endp[0] = reginput;
      }
  
  #ifdef FEAT_SYN_HL
***************
*** 7093,7108 ****
  
      if (REG_MULTI)
      {
! 	prog = (nfa_regprog_T *)reg_mmatch->regprog;
  	line = reg_getline((linenr_T)0);    /* relative to the cursor */
! 	reg_startpos = reg_mmatch->startpos;
! 	reg_endpos = reg_mmatch->endpos;
      }
      else
      {
! 	prog = (nfa_regprog_T *)reg_match->regprog;
! 	reg_startp = reg_match->startp;
! 	reg_endp = reg_match->endp;
      }
  
      /* Be paranoid... */
--- 7094,7109 ----
  
      if (REG_MULTI)
      {
! 	prog = (nfa_regprog_T *)rex.reg_mmatch->regprog;
  	line = reg_getline((linenr_T)0);    /* relative to the cursor */
! 	rex.reg_startpos = rex.reg_mmatch->startpos;
! 	rex.reg_endpos = rex.reg_mmatch->endpos;
      }
      else
      {
! 	prog = (nfa_regprog_T *)rex.reg_match->regprog;
! 	rex.reg_startp = rex.reg_match->startp;
! 	rex.reg_endp = rex.reg_match->endp;
      }
  
      /* Be paranoid... */
***************
*** 7112,7127 ****
  	goto theend;
      }
  
!     /* If pattern contains "\c" or "\C": overrule value of ireg_ic */
      if (prog->regflags & RF_ICASE)
! 	ireg_ic = TRUE;
      else if (prog->regflags & RF_NOICASE)
! 	ireg_ic = FALSE;
  
  #ifdef FEAT_MBYTE
!     /* If pattern contains "\Z" overrule value of ireg_icombine */
      if (prog->regflags & RF_ICOMBINE)
! 	ireg_icombine = TRUE;
  #endif
  
      regline = line;
--- 7113,7128 ----
  	goto theend;
      }
  
!     /* If pattern contains "\c" or "\C": overrule value of rex.reg_ic */
      if (prog->regflags & RF_ICASE)
! 	rex.reg_ic = TRUE;
      else if (prog->regflags & RF_NOICASE)
! 	rex.reg_ic = FALSE;
  
  #ifdef FEAT_MBYTE
!     /* If pattern contains "\Z" overrule value of rex.reg_icombine */
      if (prog->regflags & RF_ICOMBINE)
! 	rex.reg_icombine = TRUE;
  #endif
  
      regline = line;
***************
*** 7160,7173 ****
  	 * Nothing else to try. Doesn't handle combining chars well. */
  	if (prog->match_text != NULL
  #ifdef FEAT_MBYTE
! 		    && !ireg_icombine
  #endif
  		)
  	    return find_match_text(col, prog->regstart, prog->match_text);
      }
  
      /* If the start column is past the maximum column: no need to try. */
!     if (ireg_maxcol > 0 && col >= ireg_maxcol)
  	goto theend;
  
      nstate = prog->nstate;
--- 7161,7174 ----
  	 * Nothing else to try. Doesn't handle combining chars well. */
  	if (prog->match_text != NULL
  #ifdef FEAT_MBYTE
! 		    && !rex.reg_icombine
  #endif
  		)
  	    return find_match_text(col, prog->regstart, prog->match_text);
      }
  
      /* If the start column is past the maximum column: no need to try. */
!     if (rex.reg_maxcol > 0 && col >= rex.reg_maxcol)
  	goto theend;
  
      nstate = prog->nstate;
***************
*** 7326,7342 ****
      colnr_T	col,	/* column to start looking for match */
      int		line_lbr)
  {
!     reg_match = rmp;
!     reg_mmatch = NULL;
!     reg_maxline = 0;
!     reg_line_lbr = line_lbr;
!     reg_buf = curbuf;
!     reg_win = NULL;
!     ireg_ic = rmp->rm_ic;
  #ifdef FEAT_MBYTE
!     ireg_icombine = FALSE;
  #endif
!     ireg_maxcol = 0;
      return nfa_regexec_both(line, col, NULL);
  }
  
--- 7327,7343 ----
      colnr_T	col,	/* column to start looking for match */
      int		line_lbr)
  {
!     rex.reg_match = rmp;
!     rex.reg_mmatch = NULL;
!     rex.reg_maxline = 0;
!     rex.reg_line_lbr = line_lbr;
!     rex.reg_buf = curbuf;
!     rex.reg_win = NULL;
!     rex.reg_ic = rmp->rm_ic;
  #ifdef FEAT_MBYTE
!     rex.reg_icombine = FALSE;
  #endif
!     rex.reg_maxcol = 0;
      return nfa_regexec_both(line, col, NULL);
  }
  
***************
*** 7375,7392 ****
      colnr_T	col,		/* column to start looking for match */
      proftime_T	*tm)		/* timeout limit or NULL */
  {
!     reg_match = NULL;
!     reg_mmatch = rmp;
!     reg_buf = buf;
!     reg_win = win;
!     reg_firstlnum = lnum;
!     reg_maxline = reg_buf->b_ml.ml_line_count - lnum;
!     reg_line_lbr = FALSE;
!     ireg_ic = rmp->rmm_ic;
  #ifdef FEAT_MBYTE
!     ireg_icombine = FALSE;
  #endif
!     ireg_maxcol = rmp->rmm_maxcol;
  
      return nfa_regexec_both(NULL, col, tm);
  }
--- 7376,7393 ----
      colnr_T	col,		/* column to start looking for match */
      proftime_T	*tm)		/* timeout limit or NULL */
  {
!     rex.reg_match = NULL;
!     rex.reg_mmatch = rmp;
!     rex.reg_buf = buf;
!     rex.reg_win = win;
!     rex.reg_firstlnum = lnum;
!     rex.reg_maxline = rex.reg_buf->b_ml.ml_line_count - lnum;
!     rex.reg_line_lbr = FALSE;
!     rex.reg_ic = rmp->rmm_ic;
  #ifdef FEAT_MBYTE
!     rex.reg_icombine = FALSE;
  #endif
!     rex.reg_maxcol = rmp->rmm_maxcol;
  
      return nfa_regexec_both(NULL, col, tm);
  }
*** ../vim-8.0.0019/src/testdir/test_expr.vim	2016-09-14 22:16:09.863803610 +0200
--- src/testdir/test_expr.vim	2016-10-02 16:29:45.285611327 +0200
***************
*** 405,413 ****
  	\ {-> submatch(2) . submatch(3) . submatch(1)}, ''))
  
    func Recurse()
!     return substitute('yyy', 'y*', {-> g:val}, '')
    endfunc
!   call assert_equal('--', substitute('xxx', 'x*', {-> '-' . Recurse() . '-'}, ''))
  endfunc
  
  func Test_invalid_submatch()
--- 405,414 ----
  	\ {-> submatch(2) . submatch(3) . submatch(1)}, ''))
  
    func Recurse()
!     return substitute('yyy', 'y\(.\)y', {-> submatch(1)}, '')
    endfunc
!   " recursive call works
!   call assert_equal('-y-x-', substitute('xxx', 'x\(.\)x', {-> '-' . Recurse() . '-' . submatch(1) . '-'}, ''))
  endfunc
  
  func Test_invalid_submatch()
*** ../vim-8.0.0019/runtime/doc/eval.txt	2016-09-27 21:28:52.905342034 +0200
--- runtime/doc/eval.txt	2016-10-02 16:39:09.841721025 +0200
***************
*** 7379,7384 ****
--- 7390,7398 ----
  		|substitute()| this list will always contain one or zero
  		items, since there are no real line breaks.
  
+ 		When substitute() is used recursively only the submatches in
+ 		the current (deepest) call can be obtained.
+ 
  		Example: >
  			:s/\d\+/\=submatch(0) + 1/
  <		This finds the first number in the line and adds one to it.
*** ../vim-8.0.0019/runtime/doc/change.txt	2016-09-12 12:45:25.000000000 +0200
--- runtime/doc/change.txt	2016-10-02 16:37:35.170373987 +0200
***************
*** 1,4 ****
! *change.txt*    For Vim version 8.0.  Last change: 2016 Sep 11
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
--- 1,4 ----
! *change.txt*    For Vim version 8.0.  Last change: 2016 Oct 02
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
***************
*** 913,920 ****
  Substitute with an expression			*sub-replace-expression*
  						*sub-replace-\=* *s/\=*
  When the substitute string starts with "\=" the remainder is interpreted as an
! expression.  This does not work recursively: a |substitute()| function inside
! the expression cannot use "\=" for the substitute string.
  
  The special meaning for characters as mentioned at |sub-replace-special| does
  not apply except for "<CR>".  A <NL> character is used as a line break, you
--- 913,919 ----
  Substitute with an expression			*sub-replace-expression*
  						*sub-replace-\=* *s/\=*
  When the substitute string starts with "\=" the remainder is interpreted as an
! expression.
  
  The special meaning for characters as mentioned at |sub-replace-special| does
  not apply except for "<CR>".  A <NL> character is used as a line break, you
*** ../vim-8.0.0019/src/version.c	2016-09-29 20:54:42.407110721 +0200
--- src/version.c	2016-10-02 15:27:58.639175908 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     20,
  /**/

-- 
    With sufficient thrust, pigs fly just fine.
                   -- RFC 1925

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0021
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0021
Problem:    In the GUI when redrawing the cursor it may be on the second half
            of a double byte character.
Solution:   Correct the cursor column. (Yasuhiro Matsumoto)
Files:      src/screen.c


*** ../vim-8.0.0020/src/screen.c	2016-08-29 22:42:20.000000000 +0200
--- src/screen.c	2016-10-02 23:04:57.705033401 +0200
***************
*** 765,770 ****
--- 765,773 ----
  	     * uses that. */
  	    gui.col = gui_cursor_col;
  	    gui.row = gui_cursor_row;
+ # ifdef FEAT_MBYTE
+ 	    gui.col = mb_fix_col(gui.col, gui.row);
+ # endif
  	    gui_update_cursor(FALSE, FALSE);
  	    screen_cur_col = gui.col;
  	    screen_cur_row = gui.row;
*** ../vim-8.0.0020/src/version.c	2016-10-02 16:51:32.748592858 +0200
--- src/version.c	2016-10-02 23:06:01.632588200 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     21,
  /**/

-- 
BLACK KNIGHT:  I move for no man.
ARTHUR:        So be it!
    [hah] [parry thrust]
    [ARTHUR chops the BLACK KNIGHT's left arm off]
ARTHUR:        Now stand aside, worthy adversary.
BLACK KNIGHT:  'Tis but a scratch.
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0022
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0022
Problem:    If a channel in NL mode is missing the NL at the end the remaining
            characters are dropped.
Solution:   When the channel is closed use the remaining text. (Ozaki Kiichi)
Files:      src/channel.c, src/testdir/test_channel.vim


*** ../vim-8.0.0021/src/channel.c	2016-09-29 15:18:51.351768068 +0200
--- src/channel.c	2016-10-03 21:35:54.516547182 +0200
***************
*** 2355,2362 ****
      typval_T	*listtv = NULL;
      typval_T	argv[CH_JSON_MAX_ARGS];
      int		seq_nr = -1;
!     ch_mode_T	ch_mode = channel->ch_part[part].ch_mode;
!     cbq_T	*cbhead = &channel->ch_part[part].ch_cb_head;
      cbq_T	*cbitem;
      char_u	*callback = NULL;
      partial_T	*partial = NULL;
--- 2355,2363 ----
      typval_T	*listtv = NULL;
      typval_T	argv[CH_JSON_MAX_ARGS];
      int		seq_nr = -1;
!     chanpart_T	*ch_part = &channel->ch_part[part];
!     ch_mode_T	ch_mode = ch_part->ch_mode;
!     cbq_T	*cbhead = &ch_part->ch_cb_head;
      cbq_T	*cbitem;
      char_u	*callback = NULL;
      partial_T	*partial = NULL;
***************
*** 2376,2385 ****
  	callback = cbitem->cq_callback;
  	partial = cbitem->cq_partial;
      }
!     else if (channel->ch_part[part].ch_callback != NULL)
      {
! 	callback = channel->ch_part[part].ch_callback;
! 	partial = channel->ch_part[part].ch_partial;
      }
      else
      {
--- 2377,2386 ----
  	callback = cbitem->cq_callback;
  	partial = cbitem->cq_partial;
      }
!     else if (ch_part->ch_callback != NULL)
      {
! 	callback = ch_part->ch_callback;
! 	partial = ch_part->ch_partial;
      }
      else
      {
***************
*** 2387,2397 ****
  	partial = channel->ch_partial;
      }
  
!     buffer = channel->ch_part[part].ch_bufref.br_buf;
!     if (buffer != NULL && !bufref_valid(&channel->ch_part[part].ch_bufref))
      {
  	/* buffer was wiped out */
! 	channel->ch_part[part].ch_bufref.br_buf = NULL;
  	buffer = NULL;
      }
  
--- 2388,2398 ----
  	partial = channel->ch_partial;
      }
  
!     buffer = ch_part->ch_bufref.br_buf;
!     if (buffer != NULL && !bufref_valid(&ch_part->ch_bufref))
      {
  	/* buffer was wiped out */
! 	ch_part->ch_bufref.br_buf = NULL;
  	buffer = NULL;
      }
  
***************
*** 2452,2458 ****
  
  	if (ch_mode == MODE_NL)
  	{
! 	    char_u  *nl;
  	    char_u  *buf;
  	    readq_T *node;
  
--- 2453,2459 ----
  
  	if (ch_mode == MODE_NL)
  	{
! 	    char_u  *nl = NULL;
  	    char_u  *buf;
  	    readq_T *node;
  
***************
*** 2465,2474 ****
--- 2466,2490 ----
  		if (nl != NULL)
  		    break;
  		if (channel_collapse(channel, part, TRUE) == FAIL)
+ 		{
+ 		    if (ch_part->ch_fd == INVALID_FD && node->rq_buflen > 0)
+ 			break;
  		    return FALSE; /* incomplete message */
+ 		}
  	    }
  	    buf = node->rq_buffer;
  
+ 	    if (nl == NULL)
+ 	    {
+ 		/* Flush remaining message that is missing a NL. */
+ 		buf = vim_realloc(buf, node->rq_buflen + 1);
+ 		if (buf == NULL)
+ 		    return FALSE;
+ 		node->rq_buffer = buf;
+ 		nl = buf + node->rq_buflen++;
+ 		*nl = NUL;
+ 	    }
+ 
  	    /* Convert NUL to NL, the internal representation. */
  	    for (p = buf; p < nl && p < buf + node->rq_buflen; ++p)
  		if (*p == NUL)
*** ../vim-8.0.0021/src/testdir/test_channel.vim	2016-09-26 22:36:50.615386371 +0200
--- src/testdir/test_channel.vim	2016-10-03 21:31:14.246500828 +0200
***************
*** 1484,1489 ****
--- 1484,1510 ----
    bwipe!
  endfunc
  
+ func MyLineCountCb(ch, msg)
+   let g:linecount += 1
+ endfunc
+ 
+ func Test_read_nonl_line()
+   if !has('job')
+     return
+   endif
+ 
+   let g:linecount = 0
+   if has('win32')
+     " workaround: 'shellescape' does improper escaping double quotes
+     let arg = 'import sys;sys.stdout.write(\"1\n2\n3\")'
+   else
+     let arg = 'import sys;sys.stdout.write("1\n2\n3")'
+   endif
+   call job_start([s:python, '-c', arg], {'callback': 'MyLineCountCb'})
+   call WaitFor('3 <= g:linecount')
+   call assert_equal(3, g:linecount)
+ endfunc
+ 
  function Ch_test_close_lambda(port)
    let handle = ch_open('localhost:' . a:port, s:chopt)
    if ch_status(handle) == "fail"
*** ../vim-8.0.0021/src/version.c	2016-10-02 23:09:27.643153731 +0200
--- src/version.c	2016-10-03 21:33:11.837681063 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     22,
  /**/

-- 
"It's so simple to be wise.  Just think of something stupid to say
and then don't say it."        -- Sam Levenson

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0023
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0023
Problem:    "gd" and "gD" may find a match in a comment or string.
Solution:   Ignore matches in comments and strings. (Anton Lindqvist)
Files:      src/normal.c, src/testdir/test_goto.vim


*** ../vim-8.0.0022/src/normal.c	2016-09-11 16:52:37.000000000 +0200
--- src/normal.c	2016-10-08 19:05:10.213933460 +0200
***************
*** 4240,4245 ****
--- 4240,4291 ----
  }
  
  /*
+  * Return TRUE if line[offset] is not inside a C-style comment or string, FALSE
+  * otherwise.
+  */
+     static int
+ is_ident(char_u *line, int offset)
+ {
+     int	i;
+     int	incomment = FALSE;
+     int	instring = 0;
+     int	prev = 0;
+ 
+     for (i = 0; i < offset && line[i] != NUL; i++)
+     {
+ 	if (instring != 0)
+ 	{
+ 	    if (prev != '\\' && line[i] == instring)
+ 		instring = 0;
+ 	}
+ 	else if ((line[i] == '"' || line[i] == '\'') && !incomment)
+ 	{
+ 	    instring = line[i];
+ 	}
+ 	else
+ 	{
+ 	    if (incomment)
+ 	    {
+ 		if (prev == '*' && line[i] == '/')
+ 		    incomment = FALSE;
+ 	    }
+ 	    else if (prev == '/' && line[i] == '*')
+ 	    {
+ 		incomment = TRUE;
+ 	    }
+ 	    else if (prev == '/' && line[i] == '/')
+ 	    {
+ 		return FALSE;
+ 	    }
+ 	}
+ 
+ 	prev = line[i];
+     }
+ 
+     return incomment == FALSE && instring == 0;
+ }
+ 
+ /*
   * Search for variable declaration of "ptr[len]".
   * When "locally" is TRUE in the current function ("gd"), otherwise in the
   * current file ("gD").
***************
*** 4264,4269 ****
--- 4310,4316 ----
      int		retval = OK;
      int		incll;
      int		searchflags = flags_arg;
+     int		valid;
  
      if ((pat = alloc(len + 7)) == NULL)
  	return FAIL;
***************
*** 4301,4306 ****
--- 4348,4354 ----
      clearpos(&found_pos);
      for (;;)
      {
+ 	valid = FALSE;
  	t = searchit(curwin, curbuf, &curwin->w_cursor, FORWARD,
  			    pat, 1L, searchflags, RE_LAST, (linenr_T)0, NULL);
  	if (curwin->w_cursor.lnum >= old_pos.lnum)
***************
*** 4337,4345 ****
  	    continue;
  	}
  #endif
! 	if (!locally)	/* global search: use first match found */
  	    break;
! 	if (curwin->w_cursor.lnum >= par_pos.lnum)
  	{
  	    /* If we previously found a valid position, use it. */
  	    if (found_pos.lnum != 0)
--- 4385,4404 ----
  	    continue;
  	}
  #endif
! 	valid = is_ident(ml_get_curline(), curwin->w_cursor.col);
! 
! 	/* If the current position is not a valid identifier and a previous
! 	 * match is present, favor that one instead. */
! 	if (!valid && found_pos.lnum != 0)
! 	{
! 	    curwin->w_cursor = found_pos;
  	    break;
! 	}
! 
! 	/* Global search: use first valid match found */
! 	if (valid && !locally)
! 	    break;
! 	if (valid && curwin->w_cursor.lnum >= par_pos.lnum)
  	{
  	    /* If we previously found a valid position, use it. */
  	    if (found_pos.lnum != 0)
***************
*** 4347,4357 ****
  	    break;
  	}
  
! 	/* For finding a local variable and the match is before the "{" search
! 	 * to find a later match.  For K&R style function declarations this
! 	 * skips the function header without types.  Remove SEARCH_START from
! 	 * flags to avoid getting stuck at one position. */
! 	found_pos = curwin->w_cursor;
  	searchflags &= ~SEARCH_START;
      }
  
--- 4406,4425 ----
  	    break;
  	}
  
! 	/* For finding a local variable and the match is before the "{" or
! 	 * inside a comment, continue searching.  For K&R style function
! 	 * declarations this skips the function header without types. */
! 	if (!valid)
! 	{
! 	    /* Braces needed due to macro expansion of clearpos. */
! 	    clearpos(&found_pos);
! 	}
! 	else
! 	{
! 	    found_pos = curwin->w_cursor;
! 	}
! 	/* Remove SEARCH_START from flags to avoid getting stuck at one
! 	 * position. */
  	searchflags &= ~SEARCH_START;
      }
  
*** ../vim-8.0.0022/src/testdir/test_goto.vim	2016-06-15 21:58:47.000000000 +0200
--- src/testdir/test_goto.vim	2016-10-08 19:20:00.495818284 +0200
***************
*** 1,20 ****
  " Test commands that jump somewhere.
  
! func Test_geeDEE()
    new
!   call setline(1, ["Filename x;", "", "int Filename", "int func() {", "Filename y;"])
!   /y;/
!   normal gD
!   call assert_equal(1, line('.'))
    quit!
  endfunc
  
! func Test_gee_dee()
!   new
!   call setline(1, ["int x;", "", "int func(int x)", "{", "  return x;", "}"])
!   /return/
!   normal $hgd
!   call assert_equal(3, line('.'))
!   call assert_equal(14, col('.'))
!   quit!
  endfunc
--- 1,275 ----
  " Test commands that jump somewhere.
  
! " Create a new buffer using "lines" and place the cursor on the word after the
! " first occurrence of return and invoke "cmd". The cursor should now be
! " positioned at the given line and col.
! func XTest_goto_decl(cmd, lines, line, col)
    new
!   call setline(1, a:lines)
!   /return/
!   normal! W
!   execute 'norm! ' . a:cmd
!   call assert_equal(a:line, line('.'))
!   call assert_equal(a:col, col('.'))
    quit!
  endfunc
  
! func Test_gD()
!   let lines = [
!     \ 'int x;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gD', lines, 1, 5)
! endfunc
! 
! func Test_gD_too()
!   let lines = [
! 	\ 'Filename x;',
! 	\ '',
! 	\ 'int Filename',
! 	\ 'int func() {',
! 	\ '  Filename x;',
! 	\ '  return x;',
! 	\ ]
!   call XTest_goto_decl('gD', lines, 1, 10)
! endfunc
! 
! func Test_gD_comment()
!   let lines = [
!     \ '/* int x; */',
!     \ 'int x;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gD', lines, 2, 5)
! endfunc
! 
! func Test_gD_inline_comment()
!   let lines = [
!     \ 'int y /* , x */;',
!     \ 'int x;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gD', lines, 2, 5)
! endfunc
! 
! func Test_gD_string()
!   let lines = [
!     \ 'char *s[] = "x";',
!     \ 'int x = 1;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gD', lines, 2, 5)
! endfunc
! 
! func Test_gD_string_same_line()
!   let lines = [
!     \ 'char *s[] = "x", int x = 1;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gD', lines, 1, 22)
! endfunc
! 
! func Test_gD_char()
!   let lines = [
!     \ "char c = 'x';",
!     \ 'int x = 1;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gD', lines, 2, 5)
! endfunc
! 
! func Test_gd()
!   let lines = [
!     \ 'int x;',
!     \ '',
!     \ 'int func(int x)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gd', lines, 3, 14)
! endfunc
! 
! func Test_gd_not_local()
!   let lines = [
!     \ 'int func1(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ '',
!     \ 'int func2(int x)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gd', lines, 3, 10)
! endfunc
! 
! func Test_gd_kr_style()
!   let lines = [
!     \ 'int func(x)',
!     \ '  int x;',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gd', lines, 2, 7)
! endfunc
! 
! func Test_gd_missing_braces()
!   let lines = [
!     \ 'def func1(a)',
!     \ '  a + 1',
!     \ 'end',
!     \ '',
!     \ 'a = 1',
!     \ '',
!     \ 'def func2()',
!     \ '  return a',
!     \ 'end',
!     \ ]
!   call XTest_goto_decl('gd', lines, 1, 11)
! endfunc
! 
! func Test_gd_comment()
!   let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  /* int x; */',
!     \ '  int x;',
!     \ '  return x;',
!     \ '}',
!     \]
!   call XTest_goto_decl('gd', lines, 4, 7)
! endfunc
! 
! func Test_gd_comment_in_string()
!   let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  char *s ="//"; int x;',
!     \ '  int x;',
!     \ '  return x;',
!     \ '}',
!     \]
!   call XTest_goto_decl('gd', lines, 3, 22)
! endfunc
! 
! func Test_gd_string_in_comment()
!   set comments=
!   let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  /* " */ int x;',
!     \ '  int x;',
!     \ '  return x;',
!     \ '}',
!     \]
!   call XTest_goto_decl('gd', lines, 3, 15)
!   set comments&
! endfunc
! 
! func Test_gd_inline_comment()
!   let lines = [
!     \ 'int func(/* x is an int */ int x)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gd', lines, 1, 32)
! endfunc
! 
! func Test_gd_inline_comment_only()
!   let lines = [
!     \ 'int func(void) /* one lonely x */',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gd', lines, 3, 10)
! endfunc
! 
! func Test_gd_inline_comment_body()
!   let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  int y /* , x */;',
!     \ '',
!     \ '  for (/* int x = 0 */; y < 2; y++);',
!     \ '',
!     \ '  int x = 0;',
!     \ '',
!     \ '  return x;',
!     \ '}',
!   \ ]
!   call XTest_goto_decl('gd', lines, 7, 7)
! endfunc
! 
! func Test_gd_trailing_multiline_comment()
!   let lines = [
!     \ 'int func(int x) /* x is an int */',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gd', lines, 1, 14)
! endfunc
! 
! func Test_gd_trailing_comment()
!   let lines = [
!     \ 'int func(int x) // x is an int',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gd', lines, 1, 14)
! endfunc
! 
! func Test_gd_string()
!   let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  char *s = "x";',
!     \ '  int x = 1;',
!     \ '',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gd', lines, 4, 7)
! endfunc
! 
! func Test_gd_string_only()
!   let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  char *s = "x";',
!     \ '',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gd', lines, 5, 10)
  endfunc
*** ../vim-8.0.0022/src/version.c	2016-10-03 21:37:37.619829811 +0200
--- src/version.c	2016-10-08 19:20:57.867423971 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     23,
  /**/

-- 
Two cows are standing together in a field.  One asks the other:
"So what do you think about this Mad Cow Disease?"
The other replies: "That doesn't concern me. I'm a helicopter."

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0024
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0024
Problem:    When the netbeans channel closes, "DETACH" is put in the output
            part. (Ozaki Kiichi)
Solution:   Write "DETACH" in the socket part.
Files:      src/channel.c, src/testdir/test_netbeans.vim


*** ../vim-8.0.0023/src/channel.c	2016-10-03 21:37:37.619829811 +0200
--- src/channel.c	2016-10-09 15:42:14.971496844 +0200
***************
*** 3061,3067 ****
       * Only send "DETACH" for a netbeans channel.
       */
      if (channel->ch_nb_close_cb != NULL)
! 	channel_save(channel, PART_OUT, (char_u *)DETACH_MSG_RAW,
  			      (int)STRLEN(DETACH_MSG_RAW), FALSE, "PUT ");
  
      /* When reading from stdout is not possible, assume the other side has
--- 3061,3067 ----
       * Only send "DETACH" for a netbeans channel.
       */
      if (channel->ch_nb_close_cb != NULL)
! 	channel_save(channel, PART_SOCK, (char_u *)DETACH_MSG_RAW,
  			      (int)STRLEN(DETACH_MSG_RAW), FALSE, "PUT ");
  
      /* When reading from stdout is not possible, assume the other side has
*** ../vim-8.0.0023/src/testdir/test_netbeans.vim	2016-09-09 15:28:11.000000000 +0200
--- src/testdir/test_netbeans.vim	2016-10-09 15:39:35.824606229 +0200
***************
*** 35,40 ****
--- 35,41 ----
    nbclose
  
    call WaitFor('len(readfile("Xnetbeans")) > 6')
+   call assert_false(has("netbeans_enabled"))
    let lines = readfile("Xnetbeans")
    call assert_equal('AUTH bunny', lines[0])
    call assert_equal('0:version=0 "2.5"', lines[1])
*** ../vim-8.0.0023/src/version.c	2016-10-08 19:21:26.083230027 +0200
--- src/version.c	2016-10-09 15:25:08.486659955 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     24,
  /**/

-- 
TALL KNIGHT: We are now no longer the Knights Who Say Ni!
ONE KNIGHT:  Ni!
OTHERS:      Sh!
ONE KNIGHT:  (whispers) Sorry.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0025
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0025
Problem:    Inconsistent use of spaces vs tabs in gd test.
Solution:   Use tabs. (Anton Lindqvist)
Files:      src/testdir/test_goto.vim


*** ../vim-8.0.0024/src/testdir/test_goto.vim	2016-10-08 19:21:26.083230027 +0200
--- src/testdir/test_goto.vim	2016-10-09 15:47:40.725228290 +0200
***************
*** 16,28 ****
  
  func Test_gD()
    let lines = [
!     \ 'int x;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gD', lines, 1, 5)
  endfunc
  
--- 16,28 ----
  
  func Test_gD()
    let lines = [
! 	\ 'int x;',
! 	\ '',
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gD', lines, 1, 5)
  endfunc
  
***************
*** 40,275 ****
  
  func Test_gD_comment()
    let lines = [
!     \ '/* int x; */',
!     \ 'int x;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gD', lines, 2, 5)
  endfunc
  
  func Test_gD_inline_comment()
    let lines = [
!     \ 'int y /* , x */;',
!     \ 'int x;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gD', lines, 2, 5)
  endfunc
  
  func Test_gD_string()
    let lines = [
!     \ 'char *s[] = "x";',
!     \ 'int x = 1;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gD', lines, 2, 5)
  endfunc
  
  func Test_gD_string_same_line()
    let lines = [
!     \ 'char *s[] = "x", int x = 1;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gD', lines, 1, 22)
  endfunc
  
  func Test_gD_char()
    let lines = [
!     \ "char c = 'x';",
!     \ 'int x = 1;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gD', lines, 2, 5)
  endfunc
  
  func Test_gd()
    let lines = [
!     \ 'int x;',
!     \ '',
!     \ 'int func(int x)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gd', lines, 3, 14)
  endfunc
  
  func Test_gd_not_local()
    let lines = [
!     \ 'int func1(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ '',
!     \ 'int func2(int x)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gd', lines, 3, 10)
  endfunc
  
  func Test_gd_kr_style()
    let lines = [
!     \ 'int func(x)',
!     \ '  int x;',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gd', lines, 2, 7)
  endfunc
  
  func Test_gd_missing_braces()
    let lines = [
!     \ 'def func1(a)',
!     \ '  a + 1',
!     \ 'end',
!     \ '',
!     \ 'a = 1',
!     \ '',
!     \ 'def func2()',
!     \ '  return a',
!     \ 'end',
!     \ ]
    call XTest_goto_decl('gd', lines, 1, 11)
  endfunc
  
  func Test_gd_comment()
    let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  /* int x; */',
!     \ '  int x;',
!     \ '  return x;',
!     \ '}',
!     \]
    call XTest_goto_decl('gd', lines, 4, 7)
  endfunc
  
  func Test_gd_comment_in_string()
    let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  char *s ="//"; int x;',
!     \ '  int x;',
!     \ '  return x;',
!     \ '}',
!     \]
    call XTest_goto_decl('gd', lines, 3, 22)
  endfunc
  
  func Test_gd_string_in_comment()
    set comments=
    let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  /* " */ int x;',
!     \ '  int x;',
!     \ '  return x;',
!     \ '}',
!     \]
    call XTest_goto_decl('gd', lines, 3, 15)
    set comments&
  endfunc
  
  func Test_gd_inline_comment()
    let lines = [
!     \ 'int func(/* x is an int */ int x)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gd', lines, 1, 32)
  endfunc
  
  func Test_gd_inline_comment_only()
    let lines = [
!     \ 'int func(void) /* one lonely x */',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gd', lines, 3, 10)
  endfunc
  
  func Test_gd_inline_comment_body()
    let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  int y /* , x */;',
!     \ '',
!     \ '  for (/* int x = 0 */; y < 2; y++);',
!     \ '',
!     \ '  int x = 0;',
!     \ '',
!     \ '  return x;',
!     \ '}',
!   \ ]
    call XTest_goto_decl('gd', lines, 7, 7)
  endfunc
  
  func Test_gd_trailing_multiline_comment()
    let lines = [
!     \ 'int func(int x) /* x is an int */',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gd', lines, 1, 14)
  endfunc
  
  func Test_gd_trailing_comment()
    let lines = [
!     \ 'int func(int x) // x is an int',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gd', lines, 1, 14)
  endfunc
  
  func Test_gd_string()
    let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  char *s = "x";',
!     \ '  int x = 1;',
!     \ '',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gd', lines, 4, 7)
  endfunc
  
  func Test_gd_string_only()
    let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  char *s = "x";',
!     \ '',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gd', lines, 5, 10)
  endfunc
--- 40,275 ----
  
  func Test_gD_comment()
    let lines = [
! 	\ '/* int x; */',
! 	\ 'int x;',
! 	\ '',
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gD', lines, 2, 5)
  endfunc
  
  func Test_gD_inline_comment()
    let lines = [
! 	\ 'int y /* , x */;',
! 	\ 'int x;',
! 	\ '',
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gD', lines, 2, 5)
  endfunc
  
  func Test_gD_string()
    let lines = [
! 	\ 'char *s[] = "x";',
! 	\ 'int x = 1;',
! 	\ '',
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gD', lines, 2, 5)
  endfunc
  
  func Test_gD_string_same_line()
    let lines = [
! 	\ 'char *s[] = "x", int x = 1;',
! 	\ '',
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gD', lines, 1, 22)
  endfunc
  
  func Test_gD_char()
    let lines = [
! 	\ "char c = 'x';",
! 	\ 'int x = 1;',
! 	\ '',
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gD', lines, 2, 5)
  endfunc
  
  func Test_gd()
    let lines = [
! 	\ 'int x;',
! 	\ '',
! 	\ 'int func(int x)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 3, 14)
  endfunc
  
  func Test_gd_not_local()
    let lines = [
! 	\ 'int func1(void)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ '',
! 	\ 'int func2(int x)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 3, 10)
  endfunc
  
  func Test_gd_kr_style()
    let lines = [
! 	\ 'int func(x)',
! 	\ '  int x;',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 2, 7)
  endfunc
  
  func Test_gd_missing_braces()
    let lines = [
! 	\ 'def func1(a)',
! 	\ '  a + 1',
! 	\ 'end',
! 	\ '',
! 	\ 'a = 1',
! 	\ '',
! 	\ 'def func2()',
! 	\ '  return a',
! 	\ 'end',
! 	\ ]
    call XTest_goto_decl('gd', lines, 1, 11)
  endfunc
  
  func Test_gd_comment()
    let lines = [
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  /* int x; */',
! 	\ '  int x;',
! 	\ '  return x;',
! 	\ '}',
! 	\]
    call XTest_goto_decl('gd', lines, 4, 7)
  endfunc
  
  func Test_gd_comment_in_string()
    let lines = [
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  char *s ="//"; int x;',
! 	\ '  int x;',
! 	\ '  return x;',
! 	\ '}',
! 	\]
    call XTest_goto_decl('gd', lines, 3, 22)
  endfunc
  
  func Test_gd_string_in_comment()
    set comments=
    let lines = [
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  /* " */ int x;',
! 	\ '  int x;',
! 	\ '  return x;',
! 	\ '}',
! 	\]
    call XTest_goto_decl('gd', lines, 3, 15)
    set comments&
  endfunc
  
  func Test_gd_inline_comment()
    let lines = [
! 	\ 'int func(/* x is an int */ int x)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 1, 32)
  endfunc
  
  func Test_gd_inline_comment_only()
    let lines = [
! 	\ 'int func(void) /* one lonely x */',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 3, 10)
  endfunc
  
  func Test_gd_inline_comment_body()
    let lines = [
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  int y /* , x */;',
! 	\ '',
! 	\ '  for (/* int x = 0 */; y < 2; y++);',
! 	\ '',
! 	\ '  int x = 0;',
! 	\ '',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 7, 7)
  endfunc
  
  func Test_gd_trailing_multiline_comment()
    let lines = [
! 	\ 'int func(int x) /* x is an int */',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 1, 14)
  endfunc
  
  func Test_gd_trailing_comment()
    let lines = [
! 	\ 'int func(int x) // x is an int',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 1, 14)
  endfunc
  
  func Test_gd_string()
    let lines = [
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  char *s = "x";',
! 	\ '  int x = 1;',
! 	\ '',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 4, 7)
  endfunc
  
  func Test_gd_string_only()
    let lines = [
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  char *s = "x";',
! 	\ '',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 5, 10)
  endfunc
*** ../vim-8.0.0024/src/version.c	2016-10-09 15:43:22.459026620 +0200
--- src/version.c	2016-10-09 15:49:39.288398847 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     25,
  /**/

-- 
The war between Emacs and Vi is over.  Vi has won with 3 to 1.
http://m.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/030/3044/3044s1.html

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0026
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0026
Problem:    Error format with %W, %C and %Z does not work. (Gerd Wachsmuth)
Solution:   Skip code when qf_multiignore is set. (Lcd)
Files:      src/quickfix.c, src/testdir/test_quickfix.vim


*** ../vim-8.0.0025/src/quickfix.c	2016-09-27 21:28:52.901342062 +0200
--- src/quickfix.c	2016-10-09 16:02:48.394927690 +0200
***************
*** 1010,1048 ****
  	}
  	else if (vim_strchr((char_u *)"CZ", idx) != NULL)
  	{				/* continuation of multi-line msg */
! 	    qfline_T *qfprev = qi->qf_lists[qi->qf_curlist].qf_last;
! 
! 	    if (qfprev == NULL)
! 		return QF_FAIL;
! 	    if (*fields->errmsg && !qi->qf_multiignore)
  	    {
! 		len = (int)STRLEN(qfprev->qf_text);
! 		if ((ptr = alloc((unsigned)(len + STRLEN(fields->errmsg) + 2)))
! 			== NULL)
  		    return QF_FAIL;
! 		STRCPY(ptr, qfprev->qf_text);
! 		vim_free(qfprev->qf_text);
! 		qfprev->qf_text = ptr;
! 		*(ptr += len) = '\n';
! 		STRCPY(++ptr, fields->errmsg);
! 	    }
! 	    if (qfprev->qf_nr == -1)
! 		qfprev->qf_nr = fields->enr;
! 	    if (vim_isprintc(fields->type) && !qfprev->qf_type)
! 		/* only printable chars allowed */
! 		qfprev->qf_type = fields->type;
  
! 	    if (!qfprev->qf_lnum)
! 		qfprev->qf_lnum = fields->lnum;
! 	    if (!qfprev->qf_col)
! 		qfprev->qf_col = fields->col;
! 	    qfprev->qf_viscol = fields->use_viscol;
! 	    if (!qfprev->qf_fnum)
! 		qfprev->qf_fnum = qf_get_fnum(qi, qi->qf_directory,
! 			*fields->namebuf || qi->qf_directory != NULL
! 			? fields->namebuf
! 			: qi->qf_currfile != NULL && fields->valid
! 			? qi->qf_currfile : 0);
  	    if (idx == 'Z')
  		qi->qf_multiline = qi->qf_multiignore = FALSE;
  	    line_breakcheck();
--- 1010,1051 ----
  	}
  	else if (vim_strchr((char_u *)"CZ", idx) != NULL)
  	{				/* continuation of multi-line msg */
! 	    if (!qi->qf_multiignore)
  	    {
! 		qfline_T *qfprev = qi->qf_lists[qi->qf_curlist].qf_last;
! 
! 		if (qfprev == NULL)
  		    return QF_FAIL;
! 		if (*fields->errmsg && !qi->qf_multiignore)
! 		{
! 		    len = (int)STRLEN(qfprev->qf_text);
! 		    if ((ptr = alloc((unsigned)(len + STRLEN(fields->errmsg) + 2)))
! 			    == NULL)
! 			return QF_FAIL;
! 		    STRCPY(ptr, qfprev->qf_text);
! 		    vim_free(qfprev->qf_text);
! 		    qfprev->qf_text = ptr;
! 		    *(ptr += len) = '\n';
! 		    STRCPY(++ptr, fields->errmsg);
! 		}
! 		if (qfprev->qf_nr == -1)
! 		    qfprev->qf_nr = fields->enr;
! 		if (vim_isprintc(fields->type) && !qfprev->qf_type)
! 		    /* only printable chars allowed */
! 		    qfprev->qf_type = fields->type;
  
! 		if (!qfprev->qf_lnum)
! 		    qfprev->qf_lnum = fields->lnum;
! 		if (!qfprev->qf_col)
! 		    qfprev->qf_col = fields->col;
! 		qfprev->qf_viscol = fields->use_viscol;
! 		if (!qfprev->qf_fnum)
! 		    qfprev->qf_fnum = qf_get_fnum(qi, qi->qf_directory,
! 			    *fields->namebuf || qi->qf_directory != NULL
! 			    ? fields->namebuf
! 			    : qi->qf_currfile != NULL && fields->valid
! 			    ? qi->qf_currfile : 0);
! 	    }
  	    if (idx == 'Z')
  		qi->qf_multiline = qi->qf_multiignore = FALSE;
  	    line_breakcheck();
*** ../vim-8.0.0025/src/testdir/test_quickfix.vim	2016-09-27 21:28:52.901342062 +0200
--- src/testdir/test_quickfix.vim	2016-10-09 16:01:59.319265564 +0200
***************
*** 818,823 ****
--- 818,846 ----
    call delete('habits1.txt')
  endfunction
  
+ " Test for resync after continuing an ignored message
+ function! Xefm_ignore_continuations(cchar)
+   call s:setup_commands(a:cchar)
+ 
+   let save_efm = &efm
+ 
+   let &efm =
+ 	\ '%Eerror %m %l,' .
+ 	\ '%-Wignored %m %l,' .
+ 	\ '%+Cmore ignored %m %l,' .
+ 	\ '%Zignored end'
+   Xgetexpr ['ignored warning 1', 'more ignored continuation 2', 'ignored end', 'error resync 4']
+   let l = map(g:Xgetlist(), '[v:val.text, v:val.valid, v:val.lnum, v:val.type]')
+   call assert_equal([['resync', 1, 4, 'E']], l)
+ 
+   let &efm = save_efm
+ endfunction
+ 
+ function! Test_efm_ignore_continuations()
+   call Xefm_ignore_continuations('c')
+   call Xefm_ignore_continuations('l')
+ endfunction
+ 
  " Tests for invalid error format specifies
  function Xinvalid_efm_Tests(cchar)
    call s:setup_commands(a:cchar)
*** ../vim-8.0.0025/src/version.c	2016-10-09 15:50:45.927932466 +0200
--- src/version.c	2016-10-09 16:03:43.222550240 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     26,
  /**/

-- 
Q: How do you tell the difference between a female cat and a male cat?
A: You ask it a question and if HE answers, it's a male but, if SHE
   answers, it's a female.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0027
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0027
Problem:    A channel is closed when reading on stderr or stdout fails, but
            there may still be something to read on another part.
Solution:   Turn ch_to_be_closed into a bitfield. (Ozaki Kiichi)
Files:      src/channel.c, src/eval.c, src/structs.h, src/proto/channel.pro,
            src/testdir/test_channel.vim


*** ../vim-8.0.0026/src/channel.c	2016-10-09 15:43:22.455026647 +0200
--- src/channel.c	2016-10-09 17:08:57.303345580 +0200
***************
*** 54,60 ****
  # define fd_close(sd) close(sd)
  #endif
  
! static void channel_read(channel_T *channel, int part, char *func);
  
  /* Whether a redraw is needed for appending a line to a buffer. */
  static int channel_need_redraw = FALSE;
--- 54,60 ----
  # define fd_close(sd) close(sd)
  #endif
  
! static void channel_read(channel_T *channel, ch_part_T part, char *func);
  
  /* Whether a redraw is needed for appending a line to a buffer. */
  static int channel_need_redraw = FALSE;
***************
*** 309,315 ****
      channel_T *
  add_channel(void)
  {
!     int		part;
      channel_T	*channel = (channel_T *)alloc_clear((int)sizeof(channel_T));
  
      if (channel == NULL)
--- 309,315 ----
      channel_T *
  add_channel(void)
  {
!     ch_part_T	part;
      channel_T	*channel = (channel_T *)alloc_clear((int)sizeof(channel_T));
  
      if (channel == NULL)
***************
*** 318,324 ****
      channel->ch_id = next_ch_id++;
      ch_log(channel, "Created channel");
  
!     for (part = PART_SOCK; part <= PART_IN; ++part)
      {
  	channel->ch_part[part].ch_fd = INVALID_FD;
  #ifdef FEAT_GUI_X11
--- 318,324 ----
      channel->ch_id = next_ch_id++;
      ch_log(channel, "Created channel");
  
!     for (part = PART_SOCK; part < PART_COUNT; ++part)
      {
  	channel->ch_part[part].ch_fd = INVALID_FD;
  #ifdef FEAT_GUI_X11
***************
*** 421,429 ****
      if (!in_free_unref_items)
      {
  	if (safe_to_invoke_callback == 0)
- 	{
  	    channel->ch_to_be_freed = TRUE;
- 	}
  	else
  	{
  	    channel_free_contents(channel);
--- 421,427 ----
***************
*** 511,517 ****
  channel_read_fd(int fd)
  {
      channel_T	*channel;
!     int		part;
  
      channel = channel_fd2channel(fd, &part);
      if (channel == NULL)
--- 509,515 ----
  channel_read_fd(int fd)
  {
      channel_T	*channel;
!     ch_part_T	part;
  
      channel = channel_fd2channel(fd, &part);
      if (channel == NULL)
***************
*** 557,563 ****
  #endif
  
      static void
! channel_gui_register_one(channel_T *channel, int part)
  {
      if (!CH_HAS_GUI)
  	return;
--- 555,561 ----
  #endif
  
      static void
! channel_gui_register_one(channel_T *channel, ch_part_T part)
  {
      if (!CH_HAS_GUI)
  	return;
***************
*** 627,633 ****
  }
  
      static void
! channel_gui_unregister_one(channel_T *channel, int part)
  {
  # ifdef FEAT_GUI_X11
      if (channel->ch_part[part].ch_inputHandler != (XtInputId)NULL)
--- 625,631 ----
  }
  
      static void
! channel_gui_unregister_one(channel_T *channel, ch_part_T part)
  {
  # ifdef FEAT_GUI_X11
      if (channel->ch_part[part].ch_inputHandler != (XtInputId)NULL)
***************
*** 653,659 ****
      static void
  channel_gui_unregister(channel_T *channel)
  {
!     int	    part;
  
      for (part = PART_SOCK; part < PART_IN; ++part)
  	channel_gui_unregister_one(channel, part);
--- 651,657 ----
      static void
  channel_gui_unregister(channel_T *channel)
  {
!     ch_part_T	part;
  
      for (part = PART_SOCK; part < PART_IN; ++part)
  	channel_gui_unregister_one(channel, part);
***************
*** 928,933 ****
--- 926,932 ----
      channel->ch_nb_close_cb = nb_close_cb;
      channel->ch_hostname = (char *)vim_strsave((char_u *)hostname);
      channel->ch_port = port_in;
+     channel->ch_to_be_closed |= (1 << PART_SOCK);
  
  #ifdef FEAT_GUI
      channel_gui_register_one(channel, PART_SOCK);
***************
*** 998,1009 ****
  }
  
      static void
! may_close_part(sock_T *fd)
  {
      if (*fd != INVALID_FD)
      {
! 	fd_close(*fd);
  	*fd = INVALID_FD;
      }
  }
  
--- 997,1015 ----
  }
  
      static void
! ch_close_part(channel_T *channel, ch_part_T part)
  {
+     sock_T *fd = &channel->ch_part[part].ch_fd;
+ 
      if (*fd != INVALID_FD)
      {
! 	if (part == PART_SOCK)
! 	    sock_close(*fd);
! 	else
! 	    fd_close(*fd);
  	*fd = INVALID_FD;
+ 
+ 	channel->ch_to_be_closed &= ~(1 << part);
      }
  }
  
***************
*** 1012,1018 ****
  {
      if (in != INVALID_FD)
      {
! 	may_close_part(&channel->CH_IN_FD);
  	channel->CH_IN_FD = in;
      }
      if (out != INVALID_FD)
--- 1018,1024 ----
  {
      if (in != INVALID_FD)
      {
! 	ch_close_part(channel, PART_IN);
  	channel->CH_IN_FD = in;
      }
      if (out != INVALID_FD)
***************
*** 1020,1027 ****
  # if defined(FEAT_GUI)
  	channel_gui_unregister_one(channel, PART_OUT);
  # endif
! 	may_close_part(&channel->CH_OUT_FD);
  	channel->CH_OUT_FD = out;
  # if defined(FEAT_GUI)
  	channel_gui_register_one(channel, PART_OUT);
  # endif
--- 1026,1034 ----
  # if defined(FEAT_GUI)
  	channel_gui_unregister_one(channel, PART_OUT);
  # endif
! 	ch_close_part(channel, PART_OUT);
  	channel->CH_OUT_FD = out;
+ 	channel->ch_to_be_closed |= (1 << PART_OUT);
  # if defined(FEAT_GUI)
  	channel_gui_register_one(channel, PART_OUT);
  # endif
***************
*** 1031,1038 ****
  # if defined(FEAT_GUI)
  	channel_gui_unregister_one(channel, PART_ERR);
  # endif
! 	may_close_part(&channel->CH_ERR_FD);
  	channel->CH_ERR_FD = err;
  # if defined(FEAT_GUI)
  	channel_gui_register_one(channel, PART_ERR);
  # endif
--- 1038,1046 ----
  # if defined(FEAT_GUI)
  	channel_gui_unregister_one(channel, PART_ERR);
  # endif
! 	ch_close_part(channel, PART_ERR);
  	channel->CH_ERR_FD = err;
+ 	channel->ch_to_be_closed |= (1 << PART_ERR);
  # if defined(FEAT_GUI)
  	channel_gui_register_one(channel, PART_ERR);
  # endif
***************
*** 1151,1160 ****
      void
  channel_set_options(channel_T *channel, jobopt_T *opt)
  {
!     int		part;
  
      if (opt->jo_set & JO_MODE)
! 	for (part = PART_SOCK; part <= PART_IN; ++part)
  	    channel->ch_part[part].ch_mode = opt->jo_mode;
      if (opt->jo_set & JO_IN_MODE)
  	channel->ch_part[PART_IN].ch_mode = opt->jo_in_mode;
--- 1159,1168 ----
      void
  channel_set_options(channel_T *channel, jobopt_T *opt)
  {
!     ch_part_T	part;
  
      if (opt->jo_set & JO_MODE)
! 	for (part = PART_SOCK; part < PART_COUNT; ++part)
  	    channel->ch_part[part].ch_mode = opt->jo_mode;
      if (opt->jo_set & JO_IN_MODE)
  	channel->ch_part[PART_IN].ch_mode = opt->jo_in_mode;
***************
*** 1164,1170 ****
  	channel->ch_part[PART_ERR].ch_mode = opt->jo_err_mode;
  
      if (opt->jo_set & JO_TIMEOUT)
! 	for (part = PART_SOCK; part <= PART_IN; ++part)
  	    channel->ch_part[part].ch_timeout = opt->jo_timeout;
      if (opt->jo_set & JO_OUT_TIMEOUT)
  	channel->ch_part[PART_OUT].ch_timeout = opt->jo_out_timeout;
--- 1172,1178 ----
  	channel->ch_part[PART_ERR].ch_mode = opt->jo_err_mode;
  
      if (opt->jo_set & JO_TIMEOUT)
! 	for (part = PART_SOCK; part < PART_COUNT; ++part)
  	    channel->ch_part[part].ch_timeout = opt->jo_timeout;
      if (opt->jo_set & JO_OUT_TIMEOUT)
  	channel->ch_part[PART_OUT].ch_timeout = opt->jo_out_timeout;
***************
*** 1282,1288 ****
      void
  channel_set_req_callback(
  	channel_T   *channel,
! 	int	    part,
  	char_u	    *callback,
  	partial_T   *partial,
  	int	    id)
--- 1290,1296 ----
      void
  channel_set_req_callback(
  	channel_T   *channel,
! 	ch_part_T   part,
  	char_u	    *callback,
  	partial_T   *partial,
  	int	    id)
***************
*** 1448,1454 ****
  	ch_log(channel, "Finished writing all lines to channel");
  
  	/* Close the pipe/socket, so that the other side gets EOF. */
! 	may_close_part(&channel->CH_IN_FD);
      }
      else
  	ch_logn(channel, "Still %d more lines to write",
--- 1456,1462 ----
  	ch_log(channel, "Finished writing all lines to channel");
  
  	/* Close the pipe/socket, so that the other side gets EOF. */
! 	ch_close_part(channel, PART_IN);
      }
      else
  	ch_logn(channel, "Still %d more lines to write",
***************
*** 1462,1471 ****
  channel_buffer_free(buf_T *buf)
  {
      channel_T	*channel;
!     int		part;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
! 	for (part = PART_SOCK; part <= PART_IN; ++part)
  	{
  	    chanpart_T  *ch_part = &channel->ch_part[part];
  
--- 1470,1479 ----
  channel_buffer_free(buf_T *buf)
  {
      channel_T	*channel;
!     ch_part_T	part;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
! 	for (part = PART_SOCK; part < PART_COUNT; ++part)
  	{
  	    chanpart_T  *ch_part = &channel->ch_part[part];
  
***************
*** 1574,1580 ****
   * Returns NULL if there is nothing.
   */
      readq_T *
! channel_peek(channel_T *channel, int part)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
  
--- 1582,1588 ----
   * Returns NULL if there is nothing.
   */
      readq_T *
! channel_peek(channel_T *channel, ch_part_T part)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
  
***************
*** 1604,1610 ****
   * Returns NULL if there is nothing.
   */
      char_u *
! channel_get(channel_T *channel, int part)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
      readq_T *node = head->rq_next;
--- 1612,1618 ----
   * Returns NULL if there is nothing.
   */
      char_u *
! channel_get(channel_T *channel, ch_part_T part)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
      readq_T *node = head->rq_next;
***************
*** 1628,1634 ****
   * Replaces NUL bytes with NL.
   */
      static char_u *
! channel_get_all(channel_T *channel, int part)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
      readq_T *node = head->rq_next;
--- 1636,1642 ----
   * Replaces NUL bytes with NL.
   */
      static char_u *
! channel_get_all(channel_T *channel, ch_part_T part)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
      readq_T *node = head->rq_next;
***************
*** 1677,1683 ****
   * Caller must check these bytes are available.
   */
      void
! channel_consume(channel_T *channel, int part, int len)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
      readq_T *node = head->rq_next;
--- 1685,1691 ----
   * Caller must check these bytes are available.
   */
      void
! channel_consume(channel_T *channel, ch_part_T part, int len)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
      readq_T *node = head->rq_next;
***************
*** 1693,1699 ****
   * When "want_nl" is TRUE collapse more buffers until a NL is found.
   */
      int
! channel_collapse(channel_T *channel, int part, int want_nl)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
      readq_T *node = head->rq_next;
--- 1701,1707 ----
   * When "want_nl" is TRUE collapse more buffers until a NL is found.
   */
      int
! channel_collapse(channel_T *channel, ch_part_T part, int want_nl)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
      readq_T *node = head->rq_next;
***************
*** 1753,1759 ****
   * Returns OK or FAIL.
   */
      static int
! channel_save(channel_T *channel, int part, char_u *buf, int len,
  						      int prepend, char *lead)
  {
      readq_T *node;
--- 1761,1767 ----
   * Returns OK or FAIL.
   */
      static int
! channel_save(channel_T *channel, ch_part_T part, char_u *buf, int len,
  						      int prepend, char *lead)
  {
      readq_T *node;
***************
*** 1828,1834 ****
  channel_fill(js_read_T *reader)
  {
      channel_T	*channel = (channel_T *)reader->js_cookie;
!     int		part = reader->js_cookie_arg;
      char_u	*next = channel_get(channel, part);
      int		unused;
      int		len;
--- 1836,1842 ----
  channel_fill(js_read_T *reader)
  {
      channel_T	*channel = (channel_T *)reader->js_cookie;
!     ch_part_T	part = reader->js_cookie_arg;
      char_u	*next = channel_get(channel, part);
      int		unused;
      int		len;
***************
*** 1866,1872 ****
   * Return TRUE if there is more to read.
   */
      static int
! channel_parse_json(channel_T *channel, int part)
  {
      js_read_T	reader;
      typval_T	listtv;
--- 1874,1880 ----
   * Return TRUE if there is more to read.
   */
      static int
! channel_parse_json(channel_T *channel, ch_part_T part)
  {
      js_read_T	reader;
      typval_T	listtv;
***************
*** 2046,2052 ****
   * Return FAIL otherwise.
   */
      static int
! channel_get_json(channel_T *channel, int part, int id, typval_T **rettv)
  {
      jsonq_T   *head = &channel->ch_part[part].ch_json_head;
      jsonq_T   *item = head->jq_next;
--- 2054,2060 ----
   * Return FAIL otherwise.
   */
      static int
! channel_get_json(channel_T *channel, ch_part_T part, int id, typval_T **rettv)
  {
      jsonq_T   *head = &channel->ch_part[part].ch_json_head;
      jsonq_T   *item = head->jq_next;
***************
*** 2080,2086 ****
   * "argv[1]" etc. have further arguments, type is VAR_UNKNOWN if missing.
   */
      static void
! channel_exe_cmd(channel_T *channel, int part, typval_T *argv)
  {
      char_u  *cmd = argv[0].vval.v_string;
      char_u  *arg;
--- 2088,2094 ----
   * "argv[1]" etc. have further arguments, type is VAR_UNKNOWN if missing.
   */
      static void
! channel_exe_cmd(channel_T *channel, ch_part_T part, typval_T *argv)
  {
      char_u  *cmd = argv[0].vval.v_string;
      char_u  *arg;
***************
*** 2237,2243 ****
  }
  
      static void
! append_to_buffer(buf_T *buffer, char_u *msg, channel_T *channel, int part)
  {
      buf_T	*save_curbuf = curbuf;
      linenr_T    lnum = buffer->b_ml.ml_line_count;
--- 2245,2251 ----
  }
  
      static void
! append_to_buffer(buf_T *buffer, char_u *msg, channel_T *channel, ch_part_T part)
  {
      buf_T	*save_curbuf = curbuf;
      linenr_T    lnum = buffer->b_ml.ml_line_count;
***************
*** 2332,2338 ****
  }
  
      static void
! drop_messages(channel_T *channel, int part)
  {
      char_u *msg;
  
--- 2340,2346 ----
  }
  
      static void
! drop_messages(channel_T *channel, ch_part_T part)
  {
      char_u *msg;
  
***************
*** 2349,2355 ****
   * Return TRUE when a message was handled, there might be another one.
   */
      static int
! may_invoke_callback(channel_T *channel, int part)
  {
      char_u	*msg = NULL;
      typval_T	*listtv = NULL;
--- 2357,2363 ----
   * Return TRUE when a message was handled, there might be another one.
   */
      static int
! may_invoke_callback(channel_T *channel, ch_part_T part)
  {
      char_u	*msg = NULL;
      typval_T	*listtv = NULL;
***************
*** 2596,2602 ****
   * Return TRUE if "channel" has JSON or other typeahead.
   */
      static int
! channel_has_readahead(channel_T *channel, int part)
  {
      ch_mode_T	ch_mode = channel->ch_part[part].ch_mode;
  
--- 2604,2610 ----
   * Return TRUE if "channel" has JSON or other typeahead.
   */
      static int
! channel_has_readahead(channel_T *channel, ch_part_T part)
  {
      ch_mode_T	ch_mode = channel->ch_part[part].ch_mode;
  
***************
*** 2617,2623 ****
      char *
  channel_status(channel_T *channel, int req_part)
  {
!     int part;
      int has_readahead = FALSE;
  
      if (channel == NULL)
--- 2625,2631 ----
      char *
  channel_status(channel_T *channel, int req_part)
  {
!     ch_part_T part;
      int has_readahead = FALSE;
  
      if (channel == NULL)
***************
*** 2640,2646 ****
      {
  	if (channel_is_open(channel))
  	    return "open";
! 	for (part = PART_SOCK; part <= PART_ERR; ++part)
  	    if (channel_has_readahead(channel, part))
  	    {
  		has_readahead = TRUE;
--- 2648,2654 ----
      {
  	if (channel_is_open(channel))
  	    return "open";
! 	for (part = PART_SOCK; part < PART_IN; ++part)
  	    if (channel_has_readahead(channel, part))
  	    {
  		has_readahead = TRUE;
***************
*** 2654,2660 ****
  }
  
      static void
! channel_part_info(channel_T *channel, dict_T *dict, char *name, int part)
  {
      chanpart_T *chanpart = &channel->ch_part[part];
      char	namebuf[20];  /* longest is "sock_timeout" */
--- 2662,2668 ----
  }
  
      static void
! channel_part_info(channel_T *channel, dict_T *dict, char *name, ch_part_T part)
  {
      chanpart_T *chanpart = &channel->ch_part[part];
      char	namebuf[20];  /* longest is "sock_timeout" */
***************
*** 2736,2763 ****
      channel_gui_unregister(channel);
  #endif
  
!     if (channel->CH_SOCK_FD != INVALID_FD)
!     {
! 	sock_close(channel->CH_SOCK_FD);
! 	channel->CH_SOCK_FD = INVALID_FD;
!     }
!     may_close_part(&channel->CH_IN_FD);
!     may_close_part(&channel->CH_OUT_FD);
!     may_close_part(&channel->CH_ERR_FD);
  
      if (invoke_close_cb && channel->ch_close_cb != NULL)
      {
  	  typval_T	argv[1];
  	  typval_T	rettv;
  	  int		dummy;
! 	  int		part;
  
  	  /* Invoke callbacks before the close callback, since it's weird to
  	   * first invoke the close callback.  Increment the refcount to avoid
  	   * the channel being freed halfway. */
  	  ++channel->ch_refcount;
  	  ch_log(channel, "Invoking callbacks before closing");
! 	  for (part = PART_SOCK; part <= PART_ERR; ++part)
  	      while (may_invoke_callback(channel, part))
  		  ;
  
--- 2744,2767 ----
      channel_gui_unregister(channel);
  #endif
  
!     ch_close_part(channel, PART_SOCK);
!     ch_close_part(channel, PART_IN);
!     ch_close_part(channel, PART_OUT);
!     ch_close_part(channel, PART_ERR);
  
      if (invoke_close_cb && channel->ch_close_cb != NULL)
      {
  	  typval_T	argv[1];
  	  typval_T	rettv;
  	  int		dummy;
! 	  ch_part_T	part;
  
  	  /* Invoke callbacks before the close callback, since it's weird to
  	   * first invoke the close callback.  Increment the refcount to avoid
  	   * the channel being freed halfway. */
  	  ++channel->ch_refcount;
  	  ch_log(channel, "Invoking callbacks before closing");
! 	  for (part = PART_SOCK; part < PART_IN; ++part)
  	      while (may_invoke_callback(channel, part))
  		  ;
  
***************
*** 2789,2795 ****
  	  }
  
  	  /* any remaining messages are useless now */
! 	  for (part = PART_SOCK; part <= PART_ERR; ++part)
  	      drop_messages(channel, part);
      }
  
--- 2793,2799 ----
  	  }
  
  	  /* any remaining messages are useless now */
! 	  for (part = PART_SOCK; part < PART_IN; ++part)
  	      drop_messages(channel, part);
      }
  
***************
*** 2802,2815 ****
      void
  channel_close_in(channel_T *channel)
  {
!     may_close_part(&channel->CH_IN_FD);
  }
  
  /*
   * Clear the read buffer on "channel"/"part".
   */
      static void
! channel_clear_one(channel_T *channel, int part)
  {
      jsonq_T *json_head = &channel->ch_part[part].ch_json_head;
      cbq_T   *cb_head = &channel->ch_part[part].ch_cb_head;
--- 2806,2819 ----
      void
  channel_close_in(channel_T *channel)
  {
!     ch_close_part(channel, PART_IN);
  }
  
  /*
   * Clear the read buffer on "channel"/"part".
   */
      static void
! channel_clear_one(channel_T *channel, ch_part_T part)
  {
      jsonq_T *json_head = &channel->ch_part[part].ch_json_head;
      cbq_T   *cb_head = &channel->ch_part[part].ch_cb_head;
***************
*** 3043,3053 ****
  }
  
      static void
! channel_close_on_error(channel_T *channel, char *func)
  {
!     /* Do not call emsg(), most likely the other end just exited. */
!     ch_errors(channel, "%s(): Cannot read from channel, will close it soon",
! 									func);
  
      /* Queue a "DETACH" netbeans message in the command queue in order to
       * terminate the netbeans session later. Do not end the session here
--- 3047,3066 ----
  }
  
      static void
! ch_close_part_on_error(
! 	channel_T *channel, ch_part_T part, int is_err, char *func)
  {
!     char	msgbuf[80];
! 
!     vim_snprintf(msgbuf, sizeof(msgbuf),
! 	    "%%s(): Read %s from ch_part[%d], closing",
! 					    (is_err ? "error" : "EOF"), part);
! 
!     if (is_err)
! 	/* Do not call emsg(), most likely the other end just exited. */
! 	ch_errors(channel, msgbuf, func);
!     else
! 	ch_logs(channel, msgbuf, func);
  
      /* Queue a "DETACH" netbeans message in the command queue in order to
       * terminate the netbeans session later. Do not end the session here
***************
*** 3064,3084 ****
  	channel_save(channel, PART_SOCK, (char_u *)DETACH_MSG_RAW,
  			      (int)STRLEN(DETACH_MSG_RAW), FALSE, "PUT ");
  
!     /* When reading from stdout is not possible, assume the other side has
!      * died.  Don't close the channel right away, it may be the wrong moment
!      * to invoke callbacks. */
!     channel->ch_to_be_closed = TRUE;
  
  #ifdef FEAT_GUI
      /* Stop listening to GUI events right away. */
!     channel_gui_unregister(channel);
  #endif
  }
  
      static void
  channel_close_now(channel_T *channel)
  {
!     ch_log(channel, "Closing channel because of previous read error");
      channel_close(channel, TRUE);
      if (channel->ch_nb_close_cb != NULL)
  	(*channel->ch_nb_close_cb)();
--- 3077,3096 ----
  	channel_save(channel, PART_SOCK, (char_u *)DETACH_MSG_RAW,
  			      (int)STRLEN(DETACH_MSG_RAW), FALSE, "PUT ");
  
!     /* When reading is not possible close this part of the channel.  Don't
!      * close the channel yet, there may be something to read on another part. */
!     ch_close_part(channel, part);
  
  #ifdef FEAT_GUI
      /* Stop listening to GUI events right away. */
!     channel_gui_unregister_one(channel, part);
  #endif
  }
  
      static void
  channel_close_now(channel_T *channel)
  {
!     ch_log(channel, "Closing channel because all readable fds are closed");
      channel_close(channel, TRUE);
      if (channel->ch_nb_close_cb != NULL)
  	(*channel->ch_nb_close_cb)();
***************
*** 3090,3096 ****
   * The data is put in the read queue.  No callbacks are invoked here.
   */
      static void
! channel_read(channel_T *channel, int part, char *func)
  {
      static char_u	*buf = NULL;
      int			len = 0;
--- 3102,3108 ----
   * The data is put in the read queue.  No callbacks are invoked here.
   */
      static void
! channel_read(channel_T *channel, ch_part_T part, char *func)
  {
      static char_u	*buf = NULL;
      int			len = 0;
***************
*** 3098,3111 ****
      sock_T		fd;
      int			use_socket = FALSE;
  
-     /* If we detected a read error don't try reading again. */
-     if (channel->ch_to_be_closed)
- 	return;
- 
      fd = channel->ch_part[part].ch_fd;
      if (fd == INVALID_FD)
      {
! 	ch_error(channel, "channel_read() called while socket is closed");
  	return;
      }
      use_socket = fd == channel->CH_SOCK_FD;
--- 3110,3120 ----
      sock_T		fd;
      int			use_socket = FALSE;
  
      fd = channel->ch_part[part].ch_fd;
      if (fd == INVALID_FD)
      {
! 	ch_errors(channel, "channel_read() called while %s part is closed",
! 							    part_names[part]);
  	return;
      }
      use_socket = fd == channel->CH_SOCK_FD;
***************
*** 3141,3147 ****
  
      /* Reading a disconnection (readlen == 0), or an error. */
      if (readlen <= 0)
! 	channel_close_on_error(channel, func);
  
  #if defined(CH_HAS_GUI) && defined(FEAT_GUI_GTK)
      /* signal the main loop that there is something to read */
--- 3150,3156 ----
  
      /* Reading a disconnection (readlen == 0), or an error. */
      if (readlen <= 0)
! 	ch_close_part_on_error(channel, part, (len < 0), func);
  
  #if defined(CH_HAS_GUI) && defined(FEAT_GUI_GTK)
      /* signal the main loop that there is something to read */
***************
*** 3157,3163 ****
   * Returns NULL in case of error or timeout.
   */
      char_u *
! channel_read_block(channel_T *channel, int part, int timeout)
  {
      char_u	*buf;
      char_u	*msg;
--- 3166,3172 ----
   * Returns NULL in case of error or timeout.
   */
      char_u *
! channel_read_block(channel_T *channel, ch_part_T part, int timeout)
  {
      char_u	*buf;
      char_u	*msg;
***************
*** 3237,3243 ****
      int
  channel_read_json_block(
  	channel_T   *channel,
! 	int	    part,
  	int	    timeout_arg,
  	int	    id,
  	typval_T    **rettv)
--- 3246,3252 ----
      int
  channel_read_json_block(
  	channel_T   *channel,
! 	ch_part_T   part,
  	int	    timeout_arg,
  	int	    id,
  	typval_T    **rettv)
***************
*** 3323,3329 ****
  common_channel_read(typval_T *argvars, typval_T *rettv, int raw)
  {
      channel_T	*channel;
!     int		part = -1;
      jobopt_T	opt;
      int		mode;
      int		timeout;
--- 3332,3338 ----
  common_channel_read(typval_T *argvars, typval_T *rettv, int raw)
  {
      channel_T	*channel;
!     ch_part_T	part = PART_COUNT;
      jobopt_T	opt;
      int		mode;
      int		timeout;
***************
*** 3344,3350 ****
      channel = get_channel_arg(&argvars[0], TRUE, TRUE, part);
      if (channel != NULL)
      {
! 	if (part < 0)
  	    part = channel_part_read(channel);
  	mode = channel_get_mode(channel, part);
  	timeout = channel_get_timeout(channel, part);
--- 3353,3359 ----
      channel = get_channel_arg(&argvars[0], TRUE, TRUE, part);
      if (channel != NULL)
      {
! 	if (part == PART_COUNT)
  	    part = channel_part_read(channel);
  	mode = channel_get_mode(channel, part);
  	timeout = channel_get_timeout(channel, part);
***************
*** 3382,3391 ****
   * Returns NULL when the socket isn't found.
   */
      channel_T *
! channel_fd2channel(sock_T fd, int *partp)
  {
      channel_T	*channel;
!     int		part;
  
      if (fd != INVALID_FD)
  	for (channel = first_channel; channel != NULL;
--- 3391,3400 ----
   * Returns NULL when the socket isn't found.
   */
      channel_T *
! channel_fd2channel(sock_T fd, ch_part_T *partp)
  {
      channel_T	*channel;
!     ch_part_T	part;
  
      if (fd != INVALID_FD)
  	for (channel = first_channel; channel != NULL;
***************
*** 3411,3427 ****
  channel_handle_events(void)
  {
      channel_T	*channel;
!     int		part;
      sock_T	fd;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
      {
- 	/* If we detected a read error don't try reading again. */
- 	if (channel->ch_to_be_closed)
- 	    continue;
- 
  	/* check the socket and pipes */
! 	for (part = PART_SOCK; part <= PART_ERR; ++part)
  	{
  	    fd = channel->ch_part[part].ch_fd;
  	    if (fd != INVALID_FD)
--- 3420,3432 ----
  channel_handle_events(void)
  {
      channel_T	*channel;
!     ch_part_T	part;
      sock_T	fd;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
      {
  	/* check the socket and pipes */
! 	for (part = PART_SOCK; part < PART_IN; ++part)
  	{
  	    fd = channel->ch_part[part].ch_fd;
  	    if (fd != INVALID_FD)
***************
*** 3431,3437 ****
  		if (r == CW_READY)
  		    channel_read(channel, part, "channel_handle_events");
  		else if (r == CW_ERROR)
! 		    channel_close_on_error(channel, "channel_handle_events()");
  	    }
  	}
      }
--- 3436,3443 ----
  		if (r == CW_READY)
  		    channel_read(channel, part, "channel_handle_events");
  		else if (r == CW_ERROR)
! 		    ch_close_part_on_error(channel, part, TRUE,
! 						     "channel_handle_events");
  	    }
  	}
      }
***************
*** 3444,3450 ****
   * Return FAIL or OK.
   */
      int
! channel_send(channel_T *channel, int part, char_u *buf, int len, char *fun)
  {
      int		res;
      sock_T	fd;
--- 3450,3456 ----
   * Return FAIL or OK.
   */
      int
! channel_send(channel_T *channel, ch_part_T part, char_u *buf, int len, char *fun)
  {
      int		res;
      sock_T	fd;
***************
*** 3496,3502 ****
   * Sets "part_read" to the read fd.
   * Otherwise returns NULL.
   */
!     channel_T *
  send_common(
  	typval_T    *argvars,
  	char_u	    *text,
--- 3502,3508 ----
   * Sets "part_read" to the read fd.
   * Otherwise returns NULL.
   */
!     static channel_T *
  send_common(
  	typval_T    *argvars,
  	char_u	    *text,
***************
*** 3504,3513 ****
  	int	    eval,
  	jobopt_T    *opt,
  	char	    *fun,
! 	int	    *part_read)
  {
      channel_T	*channel;
!     int		part_send;
  
      clear_job_options(opt);
      channel = get_channel_arg(&argvars[0], TRUE, FALSE, 0);
--- 3510,3519 ----
  	int	    eval,
  	jobopt_T    *opt,
  	char	    *fun,
! 	ch_part_T   *part_read)
  {
      channel_T	*channel;
!     ch_part_T	part_send;
  
      clear_job_options(opt);
      channel = get_channel_arg(&argvars[0], TRUE, FALSE, 0);
***************
*** 3550,3557 ****
      channel_T	*channel;
      int		id;
      ch_mode_T	ch_mode;
!     int		part_send;
!     int		part_read;
      jobopt_T    opt;
      int		timeout;
  
--- 3556,3563 ----
      channel_T	*channel;
      int		id;
      ch_mode_T	ch_mode;
!     ch_part_T	part_send;
!     ch_part_T	part_read;
      jobopt_T    opt;
      int		timeout;
  
***************
*** 3610,3616 ****
      char_u	buf[NUMBUFLEN];
      char_u	*text;
      channel_T	*channel;
!     int		part_read;
      jobopt_T    opt;
      int		timeout;
  
--- 3616,3622 ----
      char_u	buf[NUMBUFLEN];
      char_u	*text;
      channel_T	*channel;
!     ch_part_T	part_read;
      jobopt_T    opt;
      int		timeout;
  
***************
*** 3644,3650 ****
      int		nfd = nfd_in;
      channel_T	*channel;
      struct	pollfd *fds = fds_in;
!     int		part;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
      {
--- 3650,3656 ----
      int		nfd = nfd_in;
      channel_T	*channel;
      struct	pollfd *fds = fds_in;
!     ch_part_T	part;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
      {
***************
*** 3678,3684 ****
      int		ret = ret_in;
      channel_T	*channel;
      struct	pollfd *fds = fds_in;
!     int		part;
      int		idx;
      chanpart_T	*in_part;
  
--- 3684,3690 ----
      int		ret = ret_in;
      channel_T	*channel;
      struct	pollfd *fds = fds_in;
!     ch_part_T	part;
      int		idx;
      chanpart_T	*in_part;
  
***************
*** 3725,3731 ****
      channel_T	*channel;
      fd_set	*rfds = rfds_in;
      fd_set	*wfds = wfds_in;
!     int		part;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
      {
--- 3731,3737 ----
      channel_T	*channel;
      fd_set	*rfds = rfds_in;
      fd_set	*wfds = wfds_in;
!     ch_part_T	part;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
      {
***************
*** 3757,3763 ****
      channel_T	*channel;
      fd_set	*rfds = rfds_in;
      fd_set	*wfds = wfds_in;
!     int		part;
      chanpart_T	*in_part;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
--- 3763,3769 ----
      channel_T	*channel;
      fd_set	*rfds = rfds_in;
      fd_set	*wfds = wfds_in;
!     ch_part_T	part;
      chanpart_T	*in_part;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
***************
*** 3803,3809 ****
      channel_T	*channel = first_channel;
      int		ret = FALSE;
      int		r;
!     int		part = PART_SOCK;
  
      ++safe_to_invoke_callback;
  
--- 3809,3815 ----
      channel_T	*channel = first_channel;
      int		ret = FALSE;
      int		r;
!     ch_part_T	part = PART_SOCK;
  
      ++safe_to_invoke_callback;
  
***************
*** 3816,3824 ****
      }
      while (channel != NULL)
      {
! 	if (channel->ch_to_be_closed)
  	{
! 	    channel->ch_to_be_closed = FALSE;
  	    channel_close_now(channel);
  	    /* channel may have been freed, start over */
  	    channel = first_channel;
--- 3822,3830 ----
      }
      while (channel != NULL)
      {
! 	if (channel->ch_to_be_closed == 0)
  	{
! 	    channel->ch_to_be_closed = (1 << PART_COUNT);
  	    channel_close_now(channel);
  	    /* channel may have been freed, start over */
  	    channel = first_channel;
***************
*** 3840,3846 ****
  	    continue;
  	}
  	if (channel->ch_part[part].ch_fd != INVALID_FD
! 		|| channel_has_readahead(channel, part))
  	{
  	    /* Increase the refcount, in case the handler causes the channel
  	     * to be unreferenced or closed. */
--- 3846,3852 ----
  	    continue;
  	}
  	if (channel->ch_part[part].ch_fd != INVALID_FD
! 				      || channel_has_readahead(channel, part))
  	{
  	    /* Increase the refcount, in case the handler causes the channel
  	     * to be unreferenced or closed. */
***************
*** 3899,3905 ****
  /*
   * Return the "part" to write to for "channel".
   */
!     int
  channel_part_send(channel_T *channel)
  {
      if (channel->CH_SOCK_FD == INVALID_FD)
--- 3905,3911 ----
  /*
   * Return the "part" to write to for "channel".
   */
!     ch_part_T
  channel_part_send(channel_T *channel)
  {
      if (channel->CH_SOCK_FD == INVALID_FD)
***************
*** 3910,3916 ****
  /*
   * Return the default "part" to read from for "channel".
   */
!     int
  channel_part_read(channel_T *channel)
  {
      if (channel->CH_SOCK_FD == INVALID_FD)
--- 3916,3922 ----
  /*
   * Return the default "part" to read from for "channel".
   */
!     ch_part_T
  channel_part_read(channel_T *channel)
  {
      if (channel->CH_SOCK_FD == INVALID_FD)
***************
*** 3923,3929 ****
   * If "channel" is invalid returns MODE_JSON.
   */
      ch_mode_T
! channel_get_mode(channel_T *channel, int part)
  {
      if (channel == NULL)
  	return MODE_JSON;
--- 3929,3935 ----
   * If "channel" is invalid returns MODE_JSON.
   */
      ch_mode_T
! channel_get_mode(channel_T *channel, ch_part_T part)
  {
      if (channel == NULL)
  	return MODE_JSON;
***************
*** 3934,3940 ****
   * Return the timeout of "channel"/"part"
   */
      int
! channel_get_timeout(channel_T *channel, int part)
  {
      return channel->ch_part[part].ch_timeout;
  }
--- 3940,3946 ----
   * Return the timeout of "channel"/"part"
   */
      int
! channel_get_timeout(channel_T *channel, ch_part_T part)
  {
      return channel->ch_part[part].ch_timeout;
  }
***************
*** 3962,3968 ****
  }
  
      static int
! handle_io(typval_T *item, int part, jobopt_T *opt)
  {
      char_u	*val = get_tv_string(item);
  
--- 3968,3974 ----
  }
  
      static int
! handle_io(typval_T *item, ch_part_T part, jobopt_T *opt)
  {
      char_u	*val = get_tv_string(item);
  
***************
*** 4045,4051 ****
      dict_T	*dict;
      int		todo;
      hashitem_T	*hi;
!     int		part;
  
      opt->jo_set = 0;
      if (tv->v_type == VAR_UNKNOWN)
--- 4051,4057 ----
      dict_T	*dict;
      int		todo;
      hashitem_T	*hi;
!     ch_part_T	part;
  
      opt->jo_set = 0;
      if (tv->v_type == VAR_UNKNOWN)
***************
*** 4343,4352 ****
   * Returns NULL if the handle is invalid.
   * When "check_open" is TRUE check that the channel can be used.
   * When "reading" is TRUE "check_open" considers typeahead useful.
!  * "part" is used to check typeahead, when -1 use the default part.
   */
      channel_T *
! get_channel_arg(typval_T *tv, int check_open, int reading, int part)
  {
      channel_T	*channel = NULL;
      int		has_readahead = FALSE;
--- 4349,4358 ----
   * Returns NULL if the handle is invalid.
   * When "check_open" is TRUE check that the channel can be used.
   * When "reading" is TRUE "check_open" considers typeahead useful.
!  * "part" is used to check typeahead, when PART_COUNT use the default part.
   */
      channel_T *
! get_channel_arg(typval_T *tv, int check_open, int reading, ch_part_T part)
  {
      channel_T	*channel = NULL;
      int		has_readahead = FALSE;
***************
*** 4367,4373 ****
      }
      if (channel != NULL && reading)
  	has_readahead = channel_has_readahead(channel,
! 			       part >= 0 ? part : channel_part_read(channel));
  
      if (check_open && (channel == NULL || (!channel_is_open(channel)
  					     && !(reading && has_readahead))))
--- 4373,4379 ----
      }
      if (channel != NULL && reading)
  	has_readahead = channel_has_readahead(channel,
! 		       part != PART_COUNT ? part : channel_part_read(channel));
  
      if (check_open && (channel == NULL || (!channel_is_open(channel)
  					     && !(reading && has_readahead))))
***************
*** 4659,4665 ****
      garray_T	ga;
  #endif
      jobopt_T	opt;
!     int		part;
  
      job = job_alloc();
      if (job == NULL)
--- 4665,4671 ----
      garray_T	ga;
  #endif
      jobopt_T	opt;
!     ch_part_T	part;
  
      job = job_alloc();
      if (job == NULL)
***************
*** 4679,4685 ****
  	goto theend;
  
      /* Check that when io is "file" that there is a file name. */
!     for (part = PART_OUT; part <= PART_IN; ++part)
  	if ((opt.jo_set & (JO_OUT_IO << (part - PART_OUT)))
  		&& opt.jo_io[part] == JIO_FILE
  		&& (!(opt.jo_set & (JO_OUT_NAME << (part - PART_OUT)))
--- 4685,4691 ----
  	goto theend;
  
      /* Check that when io is "file" that there is a file name. */
!     for (part = PART_OUT; part < PART_COUNT; ++part)
  	if ((opt.jo_set & (JO_OUT_IO << (part - PART_OUT)))
  		&& opt.jo_io[part] == JIO_FILE
  		&& (!(opt.jo_set & (JO_OUT_NAME << (part - PART_OUT)))
*** ../vim-8.0.0026/src/eval.c	2016-09-26 22:58:54.498255420 +0200
--- src/eval.c	2016-10-09 16:54:57.401187760 +0200
***************
*** 5622,5628 ****
      else if (tv->v_type == VAR_CHANNEL)
      {
  	channel_T   *ch =tv->vval.v_channel;
! 	int	    part;
  	typval_T    dtv;
  	jsonq_T	    *jq;
  	cbq_T	    *cq;
--- 5622,5628 ----
      else if (tv->v_type == VAR_CHANNEL)
      {
  	channel_T   *ch =tv->vval.v_channel;
! 	ch_part_T   part;
  	typval_T    dtv;
  	jsonq_T	    *jq;
  	cbq_T	    *cq;
***************
*** 5630,5636 ****
  	if (ch != NULL && ch->ch_copyID != copyID)
  	{
  	    ch->ch_copyID = copyID;
! 	    for (part = PART_SOCK; part <= PART_IN; ++part)
  	    {
  		for (jq = ch->ch_part[part].ch_json_head.jq_next; jq != NULL;
  							     jq = jq->jq_next)
--- 5630,5636 ----
  	if (ch != NULL && ch->ch_copyID != copyID)
  	{
  	    ch->ch_copyID = copyID;
! 	    for (part = PART_SOCK; part < PART_COUNT; ++part)
  	    {
  		for (jq = ch->ch_part[part].ch_json_head.jq_next; jq != NULL;
  							     jq = jq->jq_next)
*** ../vim-8.0.0026/src/structs.h	2016-09-07 22:48:11.000000000 +0200
--- src/structs.h	2016-10-09 16:39:57.571448152 +0200
***************
*** 1499,1517 ****
  
  /* Ordering matters, it is used in for loops: IN is last, only SOCK/OUT/ERR
   * are polled. */
! #define PART_SOCK   0
  #define CH_SOCK_FD	ch_part[PART_SOCK].ch_fd
- 
  #ifdef FEAT_JOB_CHANNEL
! # define INVALID_FD  (-1)
! 
! # define PART_OUT   1
! # define PART_ERR   2
! # define PART_IN    3
  # define CH_OUT_FD	ch_part[PART_OUT].ch_fd
  # define CH_ERR_FD	ch_part[PART_ERR].ch_fd
  # define CH_IN_FD	ch_part[PART_IN].ch_fd
  #endif
  
  /* The per-fd info for a channel. */
  typedef struct {
--- 1499,1519 ----
  
  /* Ordering matters, it is used in for loops: IN is last, only SOCK/OUT/ERR
   * are polled. */
! typedef enum {
!     PART_SOCK = 0,
  #define CH_SOCK_FD	ch_part[PART_SOCK].ch_fd
  #ifdef FEAT_JOB_CHANNEL
!     PART_OUT,
  # define CH_OUT_FD	ch_part[PART_OUT].ch_fd
+     PART_ERR,
  # define CH_ERR_FD	ch_part[PART_ERR].ch_fd
+     PART_IN,
  # define CH_IN_FD	ch_part[PART_IN].ch_fd
  #endif
+     PART_COUNT
+ } ch_part_T;
+ 
+ #define INVALID_FD	(-1)
  
  /* The per-fd info for a channel. */
  typedef struct {
***************
*** 1566,1579 ****
      int		ch_id;		/* ID of the channel */
      int		ch_last_msg_id;	/* ID of the last message */
  
!     chanpart_T	ch_part[4];	/* info for socket, out, err and in */
  
      char	*ch_hostname;	/* only for socket, allocated */
      int		ch_port;	/* only for socket */
  
!     int		ch_to_be_closed; /* When TRUE reading or writing failed and
! 				  * the channel must be closed when it's safe
! 				  * to invoke callbacks. */
      int		ch_to_be_freed; /* When TRUE channel must be freed when it's
  				 * safe to invoke callbacks. */
      int		ch_error;	/* When TRUE an error was reported.  Avoids
--- 1568,1581 ----
      int		ch_id;		/* ID of the channel */
      int		ch_last_msg_id;	/* ID of the last message */
  
!     chanpart_T	ch_part[PART_COUNT]; /* info for socket, out, err and in */
  
      char	*ch_hostname;	/* only for socket, allocated */
      int		ch_port;	/* only for socket */
  
!     int		ch_to_be_closed; /* bitset of readable fds to be closed.
! 				  * When all readable fds have been closed,
! 				  * set to (1 << PART_COUNT). */
      int		ch_to_be_freed; /* When TRUE channel must be freed when it's
  				 * safe to invoke callbacks. */
      int		ch_error;	/* When TRUE an error was reported.  Avoids
*** ../vim-8.0.0026/src/proto/channel.pro	2016-09-29 15:18:51.351768068 +0200
--- src/proto/channel.pro	2016-10-09 17:00:24.546924836 +0200
***************
*** 14,28 ****
  void channel_set_pipes(channel_T *channel, sock_T in, sock_T out, sock_T err);
  void channel_set_job(channel_T *channel, job_T *job, jobopt_T *options);
  void channel_set_options(channel_T *channel, jobopt_T *opt);
! void channel_set_req_callback(channel_T *channel, int part, char_u *callback, partial_T *partial, int id);
  void channel_buffer_free(buf_T *buf);
  void channel_write_any_lines(void);
  void channel_write_new_lines(buf_T *buf);
! readq_T *channel_peek(channel_T *channel, int part);
  char_u *channel_first_nl(readq_T *node);
! char_u *channel_get(channel_T *channel, int part);
! void channel_consume(channel_T *channel, int part, int len);
! int channel_collapse(channel_T *channel, int part, int want_nl);
  int channel_can_write_to(channel_T *channel);
  int channel_is_open(channel_T *channel);
  char *channel_status(channel_T *channel, int req_part);
--- 14,28 ----
  void channel_set_pipes(channel_T *channel, sock_T in, sock_T out, sock_T err);
  void channel_set_job(channel_T *channel, job_T *job, jobopt_T *options);
  void channel_set_options(channel_T *channel, jobopt_T *opt);
! void channel_set_req_callback(channel_T *channel, ch_part_T part, char_u *callback, partial_T *partial, int id);
  void channel_buffer_free(buf_T *buf);
  void channel_write_any_lines(void);
  void channel_write_new_lines(buf_T *buf);
! readq_T *channel_peek(channel_T *channel, ch_part_T part);
  char_u *channel_first_nl(readq_T *node);
! char_u *channel_get(channel_T *channel, ch_part_T part);
! void channel_consume(channel_T *channel, ch_part_T part, int len);
! int channel_collapse(channel_T *channel, ch_part_T part, int want_nl);
  int channel_can_write_to(channel_T *channel);
  int channel_is_open(channel_T *channel);
  char *channel_status(channel_T *channel, int req_part);
***************
*** 31,43 ****
  void channel_close_in(channel_T *channel);
  void channel_clear(channel_T *channel);
  void channel_free_all(void);
! char_u *channel_read_block(channel_T *channel, int part, int timeout);
! int channel_read_json_block(channel_T *channel, int part, int timeout_arg, int id, typval_T **rettv);
  void common_channel_read(typval_T *argvars, typval_T *rettv, int raw);
! channel_T *channel_fd2channel(sock_T fd, int *partp);
  void channel_handle_events(void);
! int channel_send(channel_T *channel, int part, char_u *buf, int len, char *fun);
! channel_T *send_common(typval_T *argvars, char_u *text, int id, int eval, jobopt_T *opt, char *fun, int *part_read);
  void ch_expr_common(typval_T *argvars, typval_T *rettv, int eval);
  void ch_raw_common(typval_T *argvars, typval_T *rettv, int eval);
  int channel_poll_setup(int nfd_in, void *fds_in);
--- 31,42 ----
  void channel_close_in(channel_T *channel);
  void channel_clear(channel_T *channel);
  void channel_free_all(void);
! char_u *channel_read_block(channel_T *channel, ch_part_T part, int timeout);
! int channel_read_json_block(channel_T *channel, ch_part_T part, int timeout_arg, int id, typval_T **rettv);
  void common_channel_read(typval_T *argvars, typval_T *rettv, int raw);
! channel_T *channel_fd2channel(sock_T fd, ch_part_T *partp);
  void channel_handle_events(void);
! int channel_send(channel_T *channel, ch_part_T part, char_u *buf, int len, char *fun);
  void ch_expr_common(typval_T *argvars, typval_T *rettv, int eval);
  void ch_raw_common(typval_T *argvars, typval_T *rettv, int eval);
  int channel_poll_setup(int nfd_in, void *fds_in);
***************
*** 46,59 ****
  int channel_select_check(int ret_in, void *rfds_in, void *wfds_in);
  int channel_parse_messages(void);
  int set_ref_in_channel(int copyID);
! int channel_part_send(channel_T *channel);
! int channel_part_read(channel_T *channel);
! ch_mode_T channel_get_mode(channel_T *channel, int part);
! int channel_get_timeout(channel_T *channel, int part);
  void clear_job_options(jobopt_T *opt);
  void free_job_options(jobopt_T *opt);
  int get_job_options(typval_T *tv, jobopt_T *opt, int supported);
! channel_T *get_channel_arg(typval_T *tv, int check_open, int reading, int part);
  void job_free_all(void);
  int set_ref_in_job(int copyID);
  void job_unref(job_T *job);
--- 45,58 ----
  int channel_select_check(int ret_in, void *rfds_in, void *wfds_in);
  int channel_parse_messages(void);
  int set_ref_in_channel(int copyID);
! ch_part_T channel_part_send(channel_T *channel);
! ch_part_T channel_part_read(channel_T *channel);
! ch_mode_T channel_get_mode(channel_T *channel, ch_part_T part);
! int channel_get_timeout(channel_T *channel, ch_part_T part);
  void clear_job_options(jobopt_T *opt);
  void free_job_options(jobopt_T *opt);
  int get_job_options(typval_T *tv, jobopt_T *opt, int supported);
! channel_T *get_channel_arg(typval_T *tv, int check_open, int reading, ch_part_T part);
  void job_free_all(void);
  int set_ref_in_job(int copyID);
  void job_unref(job_T *job);
*** ../vim-8.0.0026/src/testdir/test_channel.vim	2016-10-03 21:37:37.619829811 +0200
--- src/testdir/test_channel.vim	2016-10-09 16:28:59.732061278 +0200
***************
*** 1505,1510 ****
--- 1505,1527 ----
    call assert_equal(3, g:linecount)
  endfunc
  
+ func Test_read_from_terminated_job()
+   if !has('job')
+     return
+   endif
+ 
+   let g:linecount = 0
+   if has('win32')
+     " workaround: 'shellescape' does improper escaping double quotes 
+     let arg = 'import os,sys;os.close(1);sys.stderr.write(\"test\n\")'
+   else
+     let arg = 'import os,sys;os.close(1);sys.stderr.write("test\n")'
+   endif
+   call job_start([s:python, '-c', arg], {'callback': 'MyLineCountCb'})
+   call WaitFor('1 <= g:linecount')
+   call assert_equal(1, g:linecount)
+ endfunc
+ 
  function Ch_test_close_lambda(port)
    let handle = ch_open('localhost:' . a:port, s:chopt)
    if ch_status(handle) == "fail"
*** ../vim-8.0.0026/src/version.c	2016-10-09 16:10:02.135942266 +0200
--- src/version.c	2016-10-09 17:01:36.282423622 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     27,
  /**/

-- 
       [Autumn changed into Winter ... Winter changed into Spring ...  Spring
       changed back into Autumn and Autumn gave Winter and Spring a miss and
       went straight on into Summer ...  Until one day ...]
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0028
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0028
Problem:    Superfluous semicolons.
Solution:   Remove them. (Ozaki Kiichi)
Files:      src/ex_cmds2.c


*** ../vim-8.0.0027/src/ex_cmds2.c	2016-09-10 19:01:19.000000000 +0200
--- src/ex_cmds2.c	2016-10-12 12:11:16.417291809 +0200
***************
*** 1093,1103 ****
  # ifdef WIN3264
  #  define GET_TIMEDIFF(timer, now) \
  	(long)(((double)(timer->tr_due.QuadPart - now.QuadPart) \
! 					   / (double)fr.QuadPart) * 1000);
  # else
  #  define GET_TIMEDIFF(timer, now) \
  	(timer->tr_due.tv_sec - now.tv_sec) * 1000 \
! 			   + (timer->tr_due.tv_usec - now.tv_usec) / 1000;
  # endif
  
  /*
--- 1093,1103 ----
  # ifdef WIN3264
  #  define GET_TIMEDIFF(timer, now) \
  	(long)(((double)(timer->tr_due.QuadPart - now.QuadPart) \
! 					   / (double)fr.QuadPart) * 1000)
  # else
  #  define GET_TIMEDIFF(timer, now) \
  	(timer->tr_due.tv_sec - now.tv_sec) * 1000 \
! 			   + (timer->tr_due.tv_usec - now.tv_usec) / 1000
  # endif
  
  /*
*** ../vim-8.0.0027/src/version.c	2016-10-09 17:27:56.863388510 +0200
--- src/version.c	2016-10-12 12:12:25.804801625 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     28,
  /**/

-- 
An indication you must be a manager:
You feel sorry for Dilbert's boss.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0029
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0029
Problem:    Code for MS-Windows is complicated because of the exceptions for
            old systems.
Solution:   Drop support for MS-Windows older than Windows XP. (Ken Takata)
Files:      runtime/doc/gui_w32.txt, runtime/doc/os_win32.txt,
            runtime/doc/todo.txt, src/GvimExt/Makefile, src/Make_mvc.mak,
            src/evalfunc.c, src/ex_cmds.c, src/ex_docmd.c, src/gui_w32.c,
            src/if_cscope.c, src/misc1.c, src/misc2.c, src/option.c,
            src/os_mswin.c, src/os_win32.c, src/os_win32.h,
            src/proto/os_mswin.pro, src/proto/os_win32.pro, src/version.c


*** ../vim-8.0.0028/runtime/doc/gui_w32.txt	2016-09-12 12:45:25.000000000 +0200
--- runtime/doc/gui_w32.txt	2016-10-12 14:00:10.218811720 +0200
***************
*** 49,58 ****
  vimrc or gvimrc file: >
  	au GUIEnter * simalt ~x
  <
- 								*gui-w32s*
- There is a specific version of gvim.exe that runs under the Win32s subsystem
- of Windows 3.1 or 3.11.  See |win32s|.
- 
  
  Using Vim as a plugin					*gui-w32-windowid*
  
--- 49,54 ----
***************
*** 100,108 ****
  You can also install Vim in the "Send To" menu:
  1. Start a Windows Explorer
  2. Navigate to your sendto directory:
-    Windows 95: %windir%\sendto (e.g. "c:\windows\sendto")
     Windows NT: %windir%\profiles\%user%\sendto (e.g.
! 	       "c:\winnt\profiles\mattha\sendto").
  3. Right-click in the file pane and select New->Shortcut
  4. Follow the shortcut wizard, using the full path to VIM/GVIM.
  
--- 96,105 ----
  You can also install Vim in the "Send To" menu:
  1. Start a Windows Explorer
  2. Navigate to your sendto directory:
     Windows NT: %windir%\profiles\%user%\sendto (e.g.
! 	       "c:\winnt\profiles\mattha\sendto")
!    Windows XP: C:\Documents and Settings\%user%\SendTo
!    Windows Vista: C:\Users\%user%\AppData\Roaming\Microsoft\Windows\SendTo .
  3. Right-click in the file pane and select New->Shortcut
  4. Follow the shortcut wizard, using the full path to VIM/GVIM.
  
***************
*** 274,308 ****
  question if you really want to kill the application, Vim may be killed too!
  (This does not apply to commands run asynchronously with ":!start".)
  
! In Windows 95, the window in which the commands are executed is always 25x80
! characters, to be as DOS compatible as possible (this matters!).  The default
! system font is used.  On NT, the window will be the default you have set up for
! "Console" in Control Panel.  On Win32s, the properties of the DOS box are
! determined by _default.pif in the windows directory.
! 
! 							*msdos-mode*
! If you get a dialog that says "This program is set to run in MS-DOS mode..."
! when you run an external program, you can solve this by changing the
! properties of the associated shortcut:
! - Use a Windows Explorer to find the command.com that is used.  It can be
!   c:\command.com, c:\dos\command.com, c:\windows\command.com, etc.
! - With the right mouse button, select properties of this command.com.
! - In the Program tab select "Advanced".
! - Unselect "MS-DOS mode".
! - Click "OK" twice.
  
  							*win32-!start*
  Normally, Vim waits for a command to complete before continuing (this makes
  sense for most shell commands which produce output for Vim to use).  If you
  want Vim to start a program and return immediately, you can use the following
! syntax on W95 & NT: >
  	:!start [/min] {command}
  The optional "/min" causes the window to be minimized.
  
- On Win32s, you will have to go to another window instead.  Don't forget that
- you must tell Windows 3.1x to keep executing a DOS command in the background
- while you switch back to Vim.
- 
  ==============================================================================
  5. Special colors					*win32-colors*
  
--- 271,287 ----
  question if you really want to kill the application, Vim may be killed too!
  (This does not apply to commands run asynchronously with ":!start".)
  
! The window in which the commands are executed will be the default you have set
! up for "Console" in Control Panel.
  
  							*win32-!start*
  Normally, Vim waits for a command to complete before continuing (this makes
  sense for most shell commands which produce output for Vim to use).  If you
  want Vim to start a program and return immediately, you can use the following
! syntax: >
  	:!start [/min] {command}
  The optional "/min" causes the window to be minimized.
  
  ==============================================================================
  5. Special colors					*win32-colors*
  
***************
*** 311,317 ****
  Additionally the system configured colors can also be used.  These are known
  by the names Sys_XXX, where XXX is the appropriate system color name, from the
  following list (see the Win32 documentation for full descriptions).  Case is
! ignored.  Note: On Win32s not all of these colors are supported.
  
  Sys_3DDKShadow		Sys_3DFace			Sys_BTNFace
  Sys_3DHilight		Sys_3DHighlight			Sys_BTNHilight
--- 290,296 ----
  Additionally the system configured colors can also be used.  These are known
  by the names Sys_XXX, where XXX is the appropriate system color name, from the
  following list (see the Win32 documentation for full descriptions).  Case is
! ignored.
  
  Sys_3DDKShadow		Sys_3DFace			Sys_BTNFace
  Sys_3DHilight		Sys_3DHighlight			Sys_BTNHilight
*** ../vim-8.0.0028/runtime/doc/os_win32.txt	2016-09-12 12:45:26.000000000 +0200
--- runtime/doc/os_win32.txt	2016-10-12 14:04:26.836987376 +0200
***************
*** 1,4 ****
! *os_win32.txt*  For Vim version 8.0.  Last change: 2016 Aug 28
  
  
  		  VIM REFERENCE MANUAL    by George Reilly
--- 1,4 ----
! *os_win32.txt*  For Vim version 8.0.  Last change: 2016 Oct 12
  
  
  		  VIM REFERENCE MANUAL    by George Reilly
***************
*** 7,26 ****
  						*win32* *Win32* *MS-Windows*
  This file documents the idiosyncrasies of the Win32 version of Vim.
  
! The Win32 version of Vim works on Windows NT, 95, 98, ME, XP, Vista and
! Windows 7.  There are both console and GUI versions.
  
  The 32 bit version also runs on 64 bit MS-Windows systems.
  
- There is GUI version for use in the Win32s subsystem in Windows 3.1[1].  You
- can also use the 32-bit DOS version of Vim instead.  See |os_msdos.txt|.
- 
  1. Known problems		|win32-problems|
  2. Startup			|win32-startup|
  3. Restore screen contents	|win32-restore|
  4. Using the mouse		|win32-mouse|
! 5. Running under Windows 3.1	|win32-win3.1|
! 6. Win32 mini FAQ		|win32-faq|
  
  Additionally, there are a number of common Win32 and DOS items:
  File locations			|dos-locations|
--- 7,24 ----
  						*win32* *Win32* *MS-Windows*
  This file documents the idiosyncrasies of the Win32 version of Vim.
  
! The Win32 version of Vim works on Windows XP, Vista, 7, 8 and 10.  There are
! both console and GUI versions.
  
  The 32 bit version also runs on 64 bit MS-Windows systems.
  
  1. Known problems		|win32-problems|
  2. Startup			|win32-startup|
  3. Restore screen contents	|win32-restore|
  4. Using the mouse		|win32-mouse|
! 5. Running under Windows 95	|win32-win95|
! 6. Running under Windows 3.1	|win32-win3.1|
! 7. Win32 mini FAQ		|win32-faq|
  
  Additionally, there are a number of common Win32 and DOS items:
  File locations			|dos-locations|
***************
*** 43,62 ****
  For compiling see "src/INSTALLpc.txt".			*win32-compiling*
  
  ==============================================================================
! 1. Known problems				*windows95* *win32-problems*
! 
! There are a few known problems with running in a console on Windows 95.  As
! far as we know, this is the same in Windows 98 and Windows ME.
! 
! Comments from somebody working at Microsoft: "Win95 console support has always
! been and will always be flaky".
! 1.  Dead key support doesn't work.
! 2.  Resizing the window with ":set columns=nn lines=nn" works, but executing
!     external commands MAY CAUSE THE SYSTEM TO HANG OR CRASH.
! 3.  Screen updating is slow, unless you change 'columns' or 'lines' to a
!     non-DOS value.  But then the second problem applies!
! 
! If this bothers you, use the 32 bit MS-DOS version or the Win32 GUI version.
  
  When doing file name completion, Vim also finds matches for the short file
  name.  But Vim will still find and use the corresponding long file name.  For
--- 41,47 ----
  For compiling see "src/INSTALLpc.txt".			*win32-compiling*
  
  ==============================================================================
! 1. Known problems					*win32-problems*
  
  When doing file name completion, Vim also finds matches for the short file
  name.  But Vim will still find and use the corresponding long file name.  For
***************
*** 141,200 ****
  the console.
  
  ==============================================================================
! 5. Running under Windows 3.1				*win32-win3.1*
  
! 						*win32s* *windows-3.1*
  There was a special version of Gvim that runs under Windows 3.1 and 3.11.
  Support was removed in patch 7.4.1363.
  
  ==============================================================================
! 6. Win32 mini FAQ					*win32-faq*
! 
! Q. Why does the Win32 version of Vim update the screen so slowly on Windows 95?
! A. The support for Win32 console mode applications is very buggy in Win95.
!    For some unknown reason, the screen updates very slowly when Vim is run at
!    one of the standard resolutions (80x25, 80x43, or 80x50) and the 16-bit DOS
!    version updates the screen much more quickly than the Win32 version.
!    However, if the screen is set to some other resolution, such as by ":set
!    columns=100" or ":set lines=40", screen updating becomes about as fast as
!    it is with the 16-bit version.
! 
!    WARNING: Changing 'columns' may make Windows 95 crash while updating the
!    window (complaints --> Microsoft).  Since this mostly works, this has not
!    been disabled, but be careful with changing 'columns'.
! 
!    Changing the screen resolution makes updates faster, but it brings
!    additional problems.  External commands (e.g., ":!dir") can cause Vim to
!    freeze when the screen is set to a non-standard resolution, particularly
!    when 'columns' is not equal to 80.  It is not possible for Vim to reliably
!    set the screen resolution back to the value it had upon startup before
!    running external commands, so if you change the number of 'lines' or
!    'columns', be very, very careful.  In fact, Vim will not allow you to
!    execute external commands when 'columns' is not equal to 80, because it is
!    so likely to freeze up afterwards.
! 
!    None of the above applies on Windows NT.  Screen updates are fast, no
!    matter how many 'lines' or 'columns' the window has, and external commands
!    do not cause Vim to freeze.
! 
! Q. So if the Win32 version updates the screen so slowly on Windows 95 and the
!    16-bit DOS version updates the screen quickly, why would I want to run the
!    Win32 version?
! A. Firstly, the Win32 version isn't that slow, especially when the screen is
!    set to some non-standard number of 'lines' or 'columns'.  Secondly, the
!    16-bit DOS version has some severe limitations: It can't do big changes and
!    it doesn't know about long file names.  The Win32 version doesn't have these
!    limitations and it's faster overall (the same is true for the 32-bit DJGPP
!    DOS version of Vim).  The Win32 version is smarter about handling the
!    screen, the mouse, and the keyboard than the DJGPP version is.
! 
! Q. And what about the 16-bit DOS version versus the Win32 version on NT?
! A. There are no good reasons to run the 16-bit DOS version on NT.  The Win32
!    version updates the screen just as fast as the 16-bit version does when
!    running on NT.  All of the above disadvantages apply.  Finally, DOS
!    applications can take a long time to start up and will run more slowly.  On
!    non-Intel NT platforms, the DOS version is almost unusably slow, because it
!    runs on top of an 80x86 emulator.
  
  Q. How do I change the font?
  A. In the GUI version, you can use the 'guifont' option.  Example: >
--- 126,145 ----
  the console.
  
  ==============================================================================
! 5. Running under Windows 95				*win32-win95*
! 					*windows95* *windows98* *windowsme*
! Windows 95/98/ME support was removed in patch 8.0.0029  If you want to use it
! you will need to get a version older than that.
  
! ==============================================================================
! 6. Running under Windows 3.1				*win32-win3.1*
! 
! 					*win32s* *windows-3.1* *gui-w32s*
  There was a special version of Gvim that runs under Windows 3.1 and 3.11.
  Support was removed in patch 7.4.1363.
  
  ==============================================================================
! 7. Win32 mini FAQ					*win32-faq*
  
  Q. How do I change the font?
  A. In the GUI version, you can use the 'guifont' option.  Example: >
***************
*** 202,248 ****
  <  In the console version, you need to set the font of the console itself.
     You cannot do this from within Vim.
  
- Q. When I change the size of the console window with ':set lines=xx' or
-    similar, the font changes! (Win95)
- A. You have the console font set to 'Auto' in Vim's (or your MS-DOS prompt's)
-    properties.  This makes W95 guess (badly!) what font is best.  Set an explicit
-    font instead.
- 
- Q. Why can't I paste into Vim when running Windows 95?
- A. In the properties dialog box for the MS-DOS window, go to "MS-DOS
-    Prompt/Misc/Fast pasting" and make sure that it is NOT checked.  You should
-    also do ":set paste" in Vim to avoid unexpected effects.	|'paste'|
- 
- Q. How do I type dead keys on Windows 95, in the console version?
-    (A dead key is an accent key, such as acute, grave, or umlaut, that doesn't
-    produce a character by itself, but when followed by another key, produces
-    an accented character, such as a-acute, e-grave, u-umlaut, n-tilde, and so
-    on.  Very useful for most European languages.  English-language keyboard
-    layouts don't use dead keys, as far as we know.)
- A. You don't.  The console mode input routines simply do not work correctly in
-    Windows 95, and I have not been able to work around them.  In the words
-    of a senior developer at Microsoft:
- 	Win95 console support has always been and will always be flaky.
- 
- 	The flakiness is unavoidable because we are stuck between the world of
- 	MS-DOS keyboard TSRs like KEYB (which wants to cook the data;
- 	important for international) and the world of Win32.
- 
- 	So keys that don't "exist" in MS-DOS land (like dead keys) have a
- 	very tenuous existence in Win32 console land.  Keys that act
- 	differently between MS-DOS land and Win32 console land (like
- 	capslock) will act flaky.
- 
- 	Don't even _mention_ the problems with multiple language keyboard
- 	layouts...
- 
-    You may be able to fashion some sort of workaround with the digraphs
-    mechanism.							|digraphs|
- 
-    The best solution is to use the Win32 GUI version gvim.exe.  Alternatively,
-    you can try one of the DOS versions of Vim where dead keys reportedly do
-    work.
- 
  Q. How do I type dead keys on Windows NT?
  A. Dead keys work on NT 3.51.  Just type them as you would in any other
     application.
--- 147,152 ----
***************
*** 349,376 ****
  <  The first command runs notepad minimized and the second one runs it
     normally.
  
- Q. I'm using Win32s, and when I try to run an external command like "make",
-    Vim doesn't wait for it to finish!  Help!
- A. The problem is that a 32-bit application (Vim) can't get notification from
-    Windows that a 16-bit application (your DOS session) has finished.  Vim
-    includes a work-around for this, but you must set up your DOS commands to
-    run in a window, not full-screen.  Unfortunately the default when you
-    install Windows is full-screen.  To change this:
-    1) Start PIF editor (in the Main program group).
-    2) Open the file "_DEFAULT.PIF" in your Windows directory.
-    3) Changes the display option from "Full Screen" to "Windowed".
-    4) Save and exit.
- 
-    To test, start Vim and type >
- 	:!dir C:\<CR>".
- <  You should see a DOS box window appear briefly with the directory listing.
- 
- Q. I use Vim under Win32s and NT.  In NT, I can define the console to default to
-    50 lines, so that I get a 80x50 shell when I ':sh'.  Can I do the same in
-    W3.1x, or am I stuck with 80x25?
- A. Edit SYSTEM.INI and add 'ScreenLines=50' to the [NonWindowsApp] section.  DOS
-    prompts and external DOS commands will now run in a 50-line window.
- 
  						*windows-icon*
  Q. I don't like the Vim icon, can I change it?
  A. Yes, place your favorite icon in bitmaps/vim.ico in a directory of
--- 253,258 ----
*** ../vim-8.0.0028/src/GvimExt/Makefile	2016-02-02 18:48:30.000000000 +0100
--- src/GvimExt/Makefile	2016-10-12 14:00:10.222811692 +0200
***************
*** 3,9 ****
  #   DEBUG=yes		Build debug version (for VC7 and maybe later)
  #
  
! TARGETOS=BOTH
  !ifndef APPVER
  APPVER=5.0
  !endif
--- 3,9 ----
  #   DEBUG=yes		Build debug version (for VC7 and maybe later)
  #
  
! TARGETOS=WINNT
  !ifndef APPVER
  APPVER=5.0
  !endif
*** ../vim-8.0.0028/src/Make_mvc.mak	2016-09-08 20:25:34.000000000 +0200
--- src/Make_mvc.mak	2016-10-12 14:00:10.222811692 +0200
***************
*** 1,7 ****
! # Makefile for Vim on Win32 (Windows NT/2000/XP/2003 and Windows 95/98/Me)
! # and Win64, using the Microsoft Visual C++ compilers. Known to work with
! # VC5, VC6 (VS98), VC7.0 (VS2002), VC7.1 (VS2003), VC8 (VS2005),
! # VC9 (VS2008), VC10 (VS2010) and VC11 (VS2012)
  #
  # To build using other Windows compilers, see INSTALLpc.txt
  #
--- 1,7 ----
! # Makefile for Vim on Win32 (Windows XP/2003/Vista/7/8/10) and Win64,
! # using the Microsoft Visual C++ compilers. Known to work with VC5, VC6 (VS98),
! # VC7.0 (VS2002), VC7.1 (VS2003), VC8 (VS2005), VC9 (VS2008), VC10 (VS2010),
! # VC11 (VS2012), VC12 (VS2013) and VC14 (VS2015)
  #
  # To build using other Windows compilers, see INSTALLpc.txt
  #
***************
*** 119,125 ****
  #	  yes:   Write a normal mapfile.
  #	  lines: Write a mapfile with line numbers (only for VC6 and later)
  #
! #	Static Code Analysis: ANALYZE=yes (works with VS2012 only)
  #
  # You can combine any of these interfaces
  #
--- 119,125 ----
  #	  yes:   Write a normal mapfile.
  #	  lines: Write a mapfile with line numbers (only for VC6 and later)
  #
! #	Static Code Analysis: ANALYZE=yes (works with VS2012 or later)
  #
  # You can combine any of these interfaces
  #
***************
*** 162,170 ****
  # you can set DEFINES on the command line, e.g.,
  #	nmake -f Make_mvc.mvc "DEFINES=-DEMACS_TAGS"
  
! # Build on both Windows NT/XP and Windows 9x
  
! TARGETOS = BOTH
  
  # Select one of eight object code directories, depends on GUI, OLE, DEBUG and
  # interfaces.
--- 162,170 ----
  # you can set DEFINES on the command line, e.g.,
  #	nmake -f Make_mvc.mvc "DEFINES=-DEMACS_TAGS"
  
! # Build on Windows NT/XP
  
! TARGETOS = WINNT
  
  # Select one of eight object code directories, depends on GUI, OLE, DEBUG and
  # interfaces.
***************
*** 436,448 ****
  #>>>>> end of choices
  ###########################################################################
  
- !ifdef OS
- OS_TYPE	= winnt
  DEL_TREE = rmdir /s /q
- !else
- OS_TYPE	= win95
- DEL_TREE = deltree /y
- !endif
  
  INTDIR=$(OBJDIR)
  OUTDIR=$(OBJDIR)
--- 436,442 ----
*** ../vim-8.0.0028/src/evalfunc.c	2016-09-26 22:36:50.615386371 +0200
--- src/evalfunc.c	2016-10-12 14:00:10.226811664 +0200
***************
*** 6017,6023 ****
  #endif
  #if defined(WIN3264)
  	else if (STRICMP(name, "win95") == 0)
! 	    n = mch_windows95();
  #endif
  #ifdef FEAT_NETBEANS_INTG
  	else if (STRICMP(name, "netbeans_enabled") == 0)
--- 6017,6023 ----
  #endif
  #if defined(WIN3264)
  	else if (STRICMP(name, "win95") == 0)
! 	    n = FALSE;		/* Win9x is no more supported. */
  #endif
  #ifdef FEAT_NETBEANS_INTG
  	else if (STRICMP(name, "netbeans_enabled") == 0)
*** ../vim-8.0.0028/src/ex_cmds.c	2016-09-04 21:08:45.000000000 +0200
--- src/ex_cmds.c	2016-10-12 14:00:10.226811664 +0200
***************
*** 1175,1188 ****
      if (*cmd == NUL)	    /* no filter command */
  	return;
  
- #ifdef WIN3264
-     /*
-      * Check if external commands are allowed now.
-      */
-     if (can_end_termcap_mode(TRUE) == FALSE)
- 	return;
- #endif
- 
      cursor_save = curwin->w_cursor;
      linecount = line2 - line1 + 1;
      curwin->w_cursor.lnum = line1;
--- 1175,1180 ----
***************
*** 1460,1471 ****
  
  #ifdef MSWIN
      /*
-      * Check if external commands are allowed now.
-      */
-     if (can_end_termcap_mode(TRUE) == FALSE)
- 	return;
- 
-     /*
       * Check if ":!start" is used.
       */
      if (cmd != NULL)
--- 1452,1457 ----
*** ../vim-8.0.0028/src/ex_docmd.c	2016-09-29 15:18:51.355768041 +0200
--- src/ex_docmd.c	2016-10-12 14:00:10.230811635 +0200
***************
*** 7611,7624 ****
      /*
       * Disallow suspending for "rvim".
       */
!     if (!check_restricted()
! #ifdef WIN3264
! 	/*
! 	 * Check if external commands are allowed now.
! 	 */
! 	&& can_end_termcap_mode(TRUE)
! #endif
! 					)
      {
  	if (!eap->forceit)
  	    autowrite_all();
--- 7611,7617 ----
      /*
       * Disallow suspending for "rvim".
       */
!     if (!check_restricted())
      {
  	if (!eap->forceit)
  	    autowrite_all();
*** ../vim-8.0.0028/src/gui_w32.c	2016-08-29 22:42:20.000000000 +0200
--- src/gui_w32.c	2016-10-12 14:00:10.234811607 +0200
***************
*** 319,325 ****
  #ifdef MSWIN_FIND_REPLACE
  static UINT		s_findrep_msg = 0;	/* set in gui_w[16/32].c */
  static FINDREPLACE	s_findrep_struct;
! # if defined(FEAT_MBYTE) && defined(WIN3264)
  static FINDREPLACEW	s_findrep_struct_w;
  # endif
  static HWND		s_findrep_hwnd = NULL;
--- 319,325 ----
  #ifdef MSWIN_FIND_REPLACE
  static UINT		s_findrep_msg = 0;	/* set in gui_w[16/32].c */
  static FINDREPLACE	s_findrep_struct;
! # ifdef FEAT_MBYTE
  static FINDREPLACEW	s_findrep_struct_w;
  # endif
  static HWND		s_findrep_hwnd = NULL;
***************
*** 369,375 ****
  # define MyTranslateMessage(x) TranslateMessage(x)
  #endif
  
! #if (defined(WIN3264) && defined(FEAT_MBYTE)) || defined(GLOBAL_IME)
    /* use of WindowProc depends on wide_WindowProc */
  # define MyWindowProc vim_WindowProc
  #else
--- 369,375 ----
  # define MyTranslateMessage(x) TranslateMessage(x)
  #endif
  
! #if defined(FEAT_MBYTE) || defined(GLOBAL_IME)
    /* use of WindowProc depends on wide_WindowProc */
  # define MyWindowProc vim_WindowProc
  #else
***************
*** 473,482 ****
  static int	s_timed_out = FALSE;
  static int	dead_key = 0;	/* 0: no dead key, 1: dead key pressed */
  
- #ifdef WIN3264
- static OSVERSIONINFO os_version;    /* like it says.  Init in gui_mch_init() */
- #endif
- 
  #ifdef FEAT_BEVAL
  /* balloon-eval WM_NOTIFY_HANDLER */
  static void Handle_WM_Notify(HWND hwnd, LPNMHDR pnmh);
--- 473,478 ----
***************
*** 695,755 ****
      WCHAR	wstring[2];
      char_u	*ws = NULL;
  
!     if (os_version.dwPlatformId != VER_PLATFORM_WIN32_NT)
!     {
! 	/* On Windows 95/98 we apparently get the character in the active
! 	 * codepage, not in UCS-2.  If conversion is needed convert it to
! 	 * UCS-2 first. */
! 	if ((int)GetACP() == enc_codepage)
! 	    len = 0;	    /* no conversion required */
! 	else
  	{
! 	    string[0] = ch;
! 	    len = MultiByteToWideChar(GetACP(), 0, (LPCSTR)string,
! 		    1, wstring, 2);
  	}
      }
      else
      {
- 	wstring[0] = ch;
  	len = 1;
!     }
! 
!     if (len > 0)
!     {
! 	/* "ch" is a UTF-16 character.  Convert it to a string of bytes.  When
! 	 * "enc_codepage" is non-zero use the standard Win32 function,
! 	 * otherwise use our own conversion function (e.g., for UTF-8). */
! 	if (enc_codepage > 0)
! 	{
! 	    len = WideCharToMultiByte(enc_codepage, 0, wstring, len,
! 					       (LPSTR)string, slen, 0, NULL);
! 	    /* If we had included the ALT key into the character but now the
! 	     * upper bit is no longer set, that probably means the conversion
! 	     * failed.  Convert the original character and set the upper bit
! 	     * afterwards. */
! 	    if (had_alt && len == 1 && ch >= 0x80 && string[0] < 0x80)
! 	    {
! 		wstring[0] = ch & 0x7f;
! 		len = WideCharToMultiByte(enc_codepage, 0, wstring, len,
! 					       (LPSTR)string, slen, 0, NULL);
! 		if (len == 1) /* safety check */
! 		    string[0] |= 0x80;
! 	    }
! 	}
  	else
  	{
! 	    len = 1;
! 	    ws = utf16_to_enc(wstring, &len);
! 	    if (ws == NULL)
! 		len = 0;
! 	    else
! 	    {
! 		if (len > slen)	/* just in case */
! 		    len = slen;
! 		mch_memmove(string, ws, len);
! 		vim_free(ws);
! 	    }
  	}
      }
  
--- 691,731 ----
      WCHAR	wstring[2];
      char_u	*ws = NULL;
  
!     wstring[0] = ch;
!     len = 1;
! 
!     /* "ch" is a UTF-16 character.  Convert it to a string of bytes.  When
!      * "enc_codepage" is non-zero use the standard Win32 function,
!      * otherwise use our own conversion function (e.g., for UTF-8). */
!     if (enc_codepage > 0)
!     {
! 	len = WideCharToMultiByte(enc_codepage, 0, wstring, len,
! 		(LPSTR)string, slen, 0, NULL);
! 	/* If we had included the ALT key into the character but now the
! 	 * upper bit is no longer set, that probably means the conversion
! 	 * failed.  Convert the original character and set the upper bit
! 	 * afterwards. */
! 	if (had_alt && len == 1 && ch >= 0x80 && string[0] < 0x80)
  	{
! 	    wstring[0] = ch & 0x7f;
! 	    len = WideCharToMultiByte(enc_codepage, 0, wstring, len,
! 		    (LPSTR)string, slen, 0, NULL);
! 	    if (len == 1) /* safety check */
! 		string[0] |= 0x80;
  	}
      }
      else
      {
  	len = 1;
! 	ws = utf16_to_enc(wstring, &len);
! 	if (ws == NULL)
! 	    len = 0;
  	else
  	{
! 	    if (len > slen)	/* just in case */
! 		len = slen;
! 	    mch_memmove(string, ws, len);
! 	    vim_free(ws);
  	}
      }
  
***************
*** 1079,1085 ****
  #endif
  
  #ifdef MSWIN_FIND_REPLACE
! # if defined(FEAT_MBYTE) && defined(WIN3264)
  /*
   * copy useful data from structure LPFINDREPLACE to structure LPFINDREPLACEW
   */
--- 1055,1061 ----
  #endif
  
  #ifdef MSWIN_FIND_REPLACE
! # ifdef FEAT_MBYTE
  /*
   * copy useful data from structure LPFINDREPLACE to structure LPFINDREPLACEW
   */
***************
*** 1127,1137 ****
      int	    flags = 0;
      int	    down;
  
! # if defined(FEAT_MBYTE) && defined(WIN3264)
      /* If the OS is Windows NT, and 'encoding' differs from active codepage:
       * convert text from wide string. */
!     if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
! 			&& enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
  	findrep_wtoa(&s_findrep_struct, &s_findrep_struct_w);
      }
--- 1103,1112 ----
      int	    flags = 0;
      int	    down;
  
! # ifdef FEAT_MBYTE
      /* If the OS is Windows NT, and 'encoding' differs from active codepage:
       * convert text from wide string. */
!     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
  	findrep_wtoa(&s_findrep_struct, &s_findrep_struct_w);
      }
***************
*** 1279,1285 ****
      }
  }
  
! #if (defined(WIN3264) && defined(FEAT_MBYTE)) \
  	|| defined(GLOBAL_IME) \
  	|| defined(PROTO)
  # ifdef PROTO
--- 1254,1260 ----
      }
  }
  
! #if defined(FEAT_MBYTE) \
  	|| defined(GLOBAL_IME) \
  	|| defined(PROTO)
  # ifdef PROTO
***************
*** 1586,1595 ****
  
      static SysColorTable sys_table[] =
      {
- #ifdef WIN3264
  	{"SYS_3DDKSHADOW", COLOR_3DDKSHADOW},
  	{"SYS_3DHILIGHT", COLOR_3DHILIGHT},
! #ifndef __MINGW32__
  	{"SYS_3DHIGHLIGHT", COLOR_3DHIGHLIGHT},
  #endif
  	{"SYS_BTNHILIGHT", COLOR_BTNHILIGHT},
--- 1561,1569 ----
  
      static SysColorTable sys_table[] =
      {
  	{"SYS_3DDKSHADOW", COLOR_3DDKSHADOW},
  	{"SYS_3DHILIGHT", COLOR_3DHILIGHT},
! #ifdef COLOR_3DHIGHLIGHT
  	{"SYS_3DHIGHLIGHT", COLOR_3DHIGHLIGHT},
  #endif
  	{"SYS_BTNHILIGHT", COLOR_BTNHILIGHT},
***************
*** 1600,1606 ****
  	{"SYS_INFOBK", COLOR_INFOBK},
  	{"SYS_INFOTEXT", COLOR_INFOTEXT},
  	{"SYS_3DFACE", COLOR_3DFACE},
- #endif
  	{"SYS_BTNFACE", COLOR_BTNFACE},
  	{"SYS_BTNSHADOW", COLOR_BTNSHADOW},
  	{"SYS_ACTIVEBORDER", COLOR_ACTIVEBORDER},
--- 1574,1579 ----
***************
*** 2094,2104 ****
  
  	if (s_need_activate)
  	{
- #ifdef WIN32
  	    (void)SetForegroundWindow(s_hwnd);
- #else
- 	    (void)SetActiveWindow(s_hwnd);
- #endif
  	    s_need_activate = FALSE;
  	}
  
--- 2067,2073 ----
***************
*** 2421,2427 ****
  {
  #ifdef FEAT_MBYTE
      WCHAR	*wn = NULL;
-     int		n;
  
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
--- 2390,2395 ----
***************
*** 2438,2448 ****
  	    infow.fType = MFT_STRING;
  	    infow.dwTypeData = wn;
  	    infow.cch = (UINT)wcslen(wn);
! 	    n = InsertMenuItemW(pmenu, item_id, FALSE, &infow);
  	    vim_free(wn);
- 	    if (n == 0 && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
- 		/* Failed, try using non-wide function. */
- 		wn = NULL;
  	}
      }
  
--- 2406,2413 ----
  	    infow.fType = MFT_STRING;
  	    infow.dwTypeData = wn;
  	    infow.cch = (UINT)wcslen(wn);
! 	    InsertMenuItemW(pmenu, item_id, FALSE, &infow);
  	    vim_free(wn);
  	}
      }
  
***************
*** 2563,2569 ****
      if (s_tabhwnd == NULL)
  	return;
  
! #if defined(FEAT_MBYTE)
  # ifndef CCM_SETUNICODEFORMAT
      /* For older compilers.  We assume this never changes. */
  #  define CCM_SETUNICODEFORMAT 0x2005
--- 2528,2534 ----
      if (s_tabhwnd == NULL)
  	return;
  
! #ifdef FEAT_MBYTE
  # ifndef CCM_SETUNICODEFORMAT
      /* For older compilers.  We assume this never changes. */
  #  define CCM_SETUNICODEFORMAT 0x2005
***************
*** 2708,2725 ****
      if (title != NULL && enc_codepage >= 0 && enc_codepage != (int)GetACP())
      {
  	WCHAR	*wbuf;
- 	int	n;
  
  	/* Convert the title from 'encoding' to UTF-16. */
  	wbuf = (WCHAR *)enc_to_utf16((char_u *)title, NULL);
  	if (wbuf != NULL)
  	{
! 	    n = SetWindowTextW(hwnd, wbuf);
  	    vim_free(wbuf);
- 	    if (n != 0 || GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
- 		return;
- 	    /* Retry with non-wide function (for Windows 98). */
  	}
      }
  #endif
      (void)SetWindowText(hwnd, (LPCSTR)title);
--- 2673,2687 ----
      if (title != NULL && enc_codepage >= 0 && enc_codepage != (int)GetACP())
      {
  	WCHAR	*wbuf;
  
  	/* Convert the title from 'encoding' to UTF-16. */
  	wbuf = (WCHAR *)enc_to_utf16((char_u *)title, NULL);
  	if (wbuf != NULL)
  	{
! 	    SetWindowTextW(hwnd, wbuf);
  	    vim_free(wbuf);
  	}
+ 	return;
      }
  #endif
      (void)SetWindowText(hwnd, (LPCSTR)title);
***************
*** 2737,2747 ****
  	if (!IsWindow(s_findrep_hwnd))
  	{
  	    initialise_findrep(eap->arg);
! # if defined(FEAT_MBYTE) && defined(WIN3264)
  	    /* If the OS is Windows NT, and 'encoding' differs from active
  	     * codepage: convert text and use wide function. */
! 	    if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
! 		    && enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	    {
  		findrep_atow(&s_findrep_struct_w, &s_findrep_struct);
  		s_findrep_hwnd = FindTextW(
--- 2699,2708 ----
  	if (!IsWindow(s_findrep_hwnd))
  	{
  	    initialise_findrep(eap->arg);
! # ifdef FEAT_MBYTE
  	    /* If the OS is Windows NT, and 'encoding' differs from active
  	     * codepage: convert text and use wide function. */
! 	    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	    {
  		findrep_atow(&s_findrep_struct_w, &s_findrep_struct);
  		s_findrep_hwnd = FindTextW(
***************
*** 2774,2782 ****
  	if (!IsWindow(s_findrep_hwnd))
  	{
  	    initialise_findrep(eap->arg);
! # if defined(FEAT_MBYTE) && defined(WIN3264)
! 	    if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
! 		    && enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	    {
  		findrep_atow(&s_findrep_struct_w, &s_findrep_struct);
  		s_findrep_hwnd = ReplaceTextW(
--- 2735,2742 ----
  	if (!IsWindow(s_findrep_hwnd))
  	{
  	    initialise_findrep(eap->arg);
! # ifdef FEAT_MBYTE
! 	    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	    {
  		findrep_atow(&s_findrep_struct_w, &s_findrep_struct);
  		s_findrep_hwnd = ReplaceTextW(
***************
*** 3466,3476 ****
      IDC_SIZEWE,			/* leftright */
      IDC_SIZEWE,			/* lrsizing */
      IDC_WAIT,			/* busy */
- #ifdef WIN3264
      IDC_NO,			/* no */
- #else
-     IDC_ICON,			/* no */
- #endif
      IDC_ARROW,			/* crosshair */
      IDC_ARROW,			/* hand1 */
      IDC_ARROW,			/* hand2 */
--- 3426,3432 ----
***************
*** 3497,3507 ****
  #ifdef SetClassLongPtr
  	SetClassLongPtr(s_textArea, GCLP_HCURSOR, (__int3264)(LONG_PTR)LoadCursor(NULL, idc));
  #else
- # ifdef WIN32
  	SetClassLong(s_textArea, GCL_HCURSOR, (long_u)LoadCursor(NULL, idc));
- # else /* Win16 */
- 	SetClassWord(s_textArea, GCW_HCURSOR, (WORD)LoadCursor(NULL, idc));
- # endif
  #endif
  	if (!p_mh)
  	{
--- 3453,3459 ----
***************
*** 3523,3529 ****
   * Windows NT/2000/XP the "W" functions are used.
   */
  
! # if defined(FEAT_MBYTE) && defined(WIN3264)
  /*
   * Wide version of convert_filter().
   */
--- 3475,3481 ----
   * Windows NT/2000/XP the "W" functions are used.
   */
  
! # ifdef FEAT_MBYTE
  /*
   * Wide version of convert_filter().
   */
***************
*** 3728,3744 ****
  	char_u *initdir,
  	char_u *filter)
  {
      OPENFILENAME	fileStruct;
      char_u		fileBuf[MAXPATHL];
      char_u		*initdirp = NULL;
      char_u		*filterp;
      char_u		*p;
  
- # if defined(FEAT_MBYTE) && defined(WIN3264)
-     if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT)
- 	return gui_mch_browseW(saving, title, dflt, ext, initdir, filter);
- # endif
- 
      if (dflt == NULL)
  	fileBuf[0] = NUL;
      else
--- 3680,3694 ----
  	char_u *initdir,
  	char_u *filter)
  {
+ # ifdef FEAT_MBYTE
+     return gui_mch_browseW(saving, title, dflt, ext, initdir, filter);
+ # else
      OPENFILENAME	fileStruct;
      char_u		fileBuf[MAXPATHL];
      char_u		*initdirp = NULL;
      char_u		*filterp;
      char_u		*p;
  
      if (dflt == NULL)
  	fileBuf[0] = NUL;
      else
***************
*** 3748,3759 ****
      filterp = convert_filter(filter);
  
      vim_memset(&fileStruct, 0, sizeof(OPENFILENAME));
! #ifdef OPENFILENAME_SIZE_VERSION_400
      /* be compatible with Windows NT 4.0 */
      fileStruct.lStructSize = OPENFILENAME_SIZE_VERSION_400;
! #else
      fileStruct.lStructSize = sizeof(fileStruct);
! #endif
  
      fileStruct.lpstrTitle = (LPSTR)title;
      fileStruct.lpstrDefExt = (LPSTR)ext;
--- 3698,3709 ----
      filterp = convert_filter(filter);
  
      vim_memset(&fileStruct, 0, sizeof(OPENFILENAME));
! #  ifdef OPENFILENAME_SIZE_VERSION_400
      /* be compatible with Windows NT 4.0 */
      fileStruct.lStructSize = OPENFILENAME_SIZE_VERSION_400;
! #  else
      fileStruct.lStructSize = sizeof(fileStruct);
! #  endif
  
      fileStruct.lpstrTitle = (LPSTR)title;
      fileStruct.lpstrDefExt = (LPSTR)ext;
***************
*** 3783,3792 ****
       * Don't use OFN_OVERWRITEPROMPT, Vim has its own ":confirm" dialog.
       */
      fileStruct.Flags = (OFN_NOCHANGEDIR | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY);
! #ifdef FEAT_SHORTCUT
      if (curbuf->b_p_bin)
  	fileStruct.Flags |= OFN_NODEREFERENCELINKS;
! #endif
      if (saving)
      {
  	if (!GetSaveFileName(&fileStruct))
--- 3733,3742 ----
       * Don't use OFN_OVERWRITEPROMPT, Vim has its own ":confirm" dialog.
       */
      fileStruct.Flags = (OFN_NOCHANGEDIR | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY);
! #  ifdef FEAT_SHORTCUT
      if (curbuf->b_p_bin)
  	fileStruct.Flags |= OFN_NODEREFERENCELINKS;
! #  endif
      if (saving)
      {
  	if (!GetSaveFileName(&fileStruct))
***************
*** 3806,3811 ****
--- 3756,3762 ----
  
      /* Shorten the file name if possible */
      return vim_strsave(shorten_fname1((char_u *)fileBuf));
+ # endif
  }
  #endif /* FEAT_BROWSE */
  
***************
*** 3816,3831 ****
      HDROP hDrop)
  {
  #ifdef FEAT_WINDOWS
- #ifdef WIN3264
  # define BUFPATHLEN _MAX_PATH
  # define DRAGQVAL 0xFFFFFFFF
! #else
! # define BUFPATHLEN MAXPATHL
! # define DRAGQVAL 0xFFFF
! #endif
! #ifdef FEAT_MBYTE
      WCHAR   wszFile[BUFPATHLEN];
! #endif
      char    szFile[BUFPATHLEN];
      UINT    cFiles = DragQueryFile(hDrop, DRAGQVAL, NULL, 0);
      UINT    i;
--- 3767,3777 ----
      HDROP hDrop)
  {
  #ifdef FEAT_WINDOWS
  # define BUFPATHLEN _MAX_PATH
  # define DRAGQVAL 0xFFFFFFFF
! # ifdef FEAT_MBYTE
      WCHAR   wszFile[BUFPATHLEN];
! # endif
      char    szFile[BUFPATHLEN];
      UINT    cFiles = DragQueryFile(hDrop, DRAGQVAL, NULL, 0);
      UINT    i;
***************
*** 3846,3856 ****
      if (fnames != NULL)
  	for (i = 0; i < cFiles; ++i)
  	{
! #ifdef FEAT_MBYTE
  	    if (DragQueryFileW(hDrop, i, wszFile, BUFPATHLEN) > 0)
  		fnames[i] = utf16_to_enc(wszFile, NULL);
  	    else
! #endif
  	    {
  		DragQueryFile(hDrop, i, szFile, BUFPATHLEN);
  		fnames[i] = vim_strsave((char_u *)szFile);
--- 3792,3802 ----
      if (fnames != NULL)
  	for (i = 0; i < cFiles; ++i)
  	{
! # ifdef FEAT_MBYTE
  	    if (DragQueryFileW(hDrop, i, wszFile, BUFPATHLEN) > 0)
  		fnames[i] = utf16_to_enc(wszFile, NULL);
  	    else
! # endif
  	    {
  		DragQueryFile(hDrop, i, szFile, BUFPATHLEN);
  		fnames[i] = vim_strsave((char_u *)szFile);
***************
*** 3888,3901 ****
      long	val;
      int		dragging = FALSE;
      int		dont_scroll_save = dont_scroll;
- #ifndef WIN3264
-     int		nPos;
- #else
      SCROLLINFO	si;
  
      si.cbSize = sizeof(si);
      si.fMask = SIF_POS;
- #endif
  
      sb = gui_mswin_find_scrollbar(hwndCtl);
      if (sb == NULL)
--- 3834,3843 ----
***************
*** 3960,3972 ****
      }
      prev_code = code;
  
- #ifdef WIN3264
      si.nPos = (sb->scroll_shift > 0) ? val >> sb->scroll_shift : val;
      SetScrollInfo(hwndCtl, SB_CTL, &si, TRUE);
- #else
-     nPos = (sb->scroll_shift > 0) ? val >> sb->scroll_shift : val;
-     SetScrollPos(hwndCtl, SB_CTL, nPos, TRUE);
- #endif
  
      /*
       * When moving a vertical scrollbar, move the other vertical scrollbar too.
--- 3902,3909 ----
***************
*** 3976,3986 ****
  	scrollbar_T *sba = sb->wp->w_scrollbars;
  	HWND    id = sba[ (sb == sba + SBAR_LEFT) ? SBAR_RIGHT : SBAR_LEFT].id;
  
- #ifdef WIN3264
  	SetScrollInfo(id, SB_CTL, &si, TRUE);
- #else
- 	SetScrollPos(id, SB_CTL, nPos, TRUE);
- #endif
      }
  
      /* Don't let us be interrupted here by another message. */
--- 3913,3919 ----
***************
*** 4448,4454 ****
  
  /* Intellimouse support */
  static int mouse_scroll_lines = 0;
- static UINT msh_msgmousewheel = 0;
  
  static int	s_usenewlook;	    /* emulate W95/NT4 non-bold dialogs */
  #ifdef FEAT_TOOLBAR
--- 4381,4386 ----
***************
*** 4505,4538 ****
  # define pImmSetConversionStatus  ImmSetConversionStatus
  #endif
  
- /* multi monitor support */
- typedef struct _MONITORINFOstruct
- {
-     DWORD cbSize;
-     RECT rcMonitor;
-     RECT rcWork;
-     DWORD dwFlags;
- } _MONITORINFO;
- 
- typedef HANDLE _HMONITOR;
- typedef _HMONITOR (WINAPI *TMonitorFromWindow)(HWND, DWORD);
- typedef BOOL (WINAPI *TGetMonitorInfo)(_HMONITOR, _MONITORINFO *);
- 
- static TMonitorFromWindow   pMonitorFromWindow = NULL;
- static TGetMonitorInfo	    pGetMonitorInfo = NULL;
- static HANDLE		    user32_lib = NULL;
- /*
-  * Return TRUE when running under Windows NT 3.x or Win32s, both of which have
-  * less fancy GUI APIs.
-  */
-     static int
- is_winnt_3(void)
- {
-     return ((os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
- 		&& os_version.dwMajorVersion == 3)
- 	    || (os_version.dwPlatformId == VER_PLATFORM_WIN32s));
- }
- 
  #ifdef FEAT_MENU
  /*
   * Figure out how high the menu bar is at the moment.
--- 4437,4442 ----
***************
*** 4564,4608 ****
      }
      else
      {
! 	if (is_winnt_3())	/* for NT 3.xx */
  	{
! 	    if (gui.starting)
! 		menu_height = GetSystemMetrics(SM_CYMENU);
! 	    else
! 	    {
! 		RECT r1, r2;
! 		int frameht = GetSystemMetrics(SM_CYFRAME);
! 		int capht = GetSystemMetrics(SM_CYCAPTION);
! 
! 		/* get window rect of s_hwnd
! 		 * get client rect of s_hwnd
! 		 * get cap height
! 		 * subtract from window rect, the sum of client height,
! 		 * (if not maximized)frame thickness, and caption height.
! 		 */
! 		GetWindowRect(s_hwnd, &r1);
! 		GetClientRect(s_hwnd, &r2);
! 		menu_height = r1.bottom - r1.top - (r2.bottom - r2.top
! 				 + 2 * frameht * (!IsZoomed(s_hwnd)) + capht);
! 	    }
! 	}
! 	else			/* win95 and variants (NT 4.0, I guess) */
! 	{
! 	    /*
! 	     * In case 'lines' is set in _vimrc/_gvimrc window width doesn't
! 	     * seem to have been set yet, so menu wraps in default window
! 	     * width which is very narrow.  Instead just return height of a
! 	     * single menu item.  Will still be wrong when the menu really
! 	     * should wrap over more than one line.
! 	     */
! 	    GetMenuItemRect(s_hwnd, s_menuBar, 0, &rc1);
! 	    if (gui.starting)
! 		menu_height = rc1.bottom - rc1.top + 1;
! 	    else
! 	    {
! 		GetMenuItemRect(s_hwnd, s_menuBar, num - 1, &rc2);
! 		menu_height = rc2.bottom - rc1.top + 1;
! 	    }
  	}
      }
  
--- 4468,4487 ----
      }
      else
      {
! 	/*
! 	 * In case 'lines' is set in _vimrc/_gvimrc window width doesn't
! 	 * seem to have been set yet, so menu wraps in default window
! 	 * width which is very narrow.  Instead just return height of a
! 	 * single menu item.  Will still be wrong when the menu really
! 	 * should wrap over more than one line.
! 	 */
! 	GetMenuItemRect(s_hwnd, s_menuBar, 0, &rc1);
! 	if (gui.starting)
! 	    menu_height = rc1.bottom - rc1.top + 1;
! 	else
  	{
! 	    GetMenuItemRect(s_hwnd, s_menuBar, num - 1, &rc2);
! 	    menu_height = rc2.bottom - rc1.top + 1;
  	}
      }
  
***************
*** 4636,4677 ****
  #define VMSH_MOUSEWHEEL    "MSWHEEL_ROLLMSG"
  #define VMSH_SCROLL_LINES  "MSH_SCROLL_LINES_MSG"
  
-     HWND hdl_mswheel;
-     UINT msh_msgscrolllines;
- 
-     msh_msgmousewheel = 0;
      mouse_scroll_lines = 3;	/* reasonable default */
  
!     if ((os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
! 		&& os_version.dwMajorVersion >= 4)
! 	    || (os_version.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS
! 		&& ((os_version.dwMajorVersion == 4
! 			&& os_version.dwMinorVersion >= 10)
! 		    || os_version.dwMajorVersion >= 5)))
!     {
! 	/* if NT 4.0+ (or Win98) get scroll lines directly from system */
! 	SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0,
! 		&mouse_scroll_lines, 0);
!     }
!     else if (os_version.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS
! 	    || (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
! 		&& os_version.dwMajorVersion < 4))
!     {	/*
! 	 * If Win95 or NT 3.51,
! 	 * try to find the hidden point32 window.
! 	 */
! 	hdl_mswheel = FindWindow(VMOUSEZ_CLASSNAME, VMOUSEZ_TITLE);
! 	if (hdl_mswheel)
! 	{
! 	    msh_msgscrolllines = RegisterWindowMessage(VMSH_SCROLL_LINES);
! 	    if (msh_msgscrolllines)
! 	    {
! 		mouse_scroll_lines = (int)SendMessage(hdl_mswheel,
! 			msh_msgscrolllines, 0, 0);
! 		msh_msgmousewheel  = RegisterWindowMessage(VMSH_MOUSEWHEEL);
! 	    }
! 	}
!     }
  }
  
  
--- 4515,4525 ----
  #define VMSH_MOUSEWHEEL    "MSWHEEL_ROLLMSG"
  #define VMSH_SCROLL_LINES  "MSH_SCROLL_LINES_MSG"
  
      mouse_scroll_lines = 3;	/* reasonable default */
  
!     /* if NT 4.0+ (or Win98) get scroll lines directly from system */
!     SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0,
! 	    &mouse_scroll_lines, 0);
  }
  
  
***************
*** 5210,5222 ****
  #endif
  
      default:
- 	if (uMsg == msh_msgmousewheel && msh_msgmousewheel != 0)
- 	{   /* handle MSH_MOUSEWHEEL messages for Intellimouse */
- 	    _OnMouseWheel(hwnd, HIWORD(wParam));
- 	    return 0L;
- 	}
  #ifdef MSWIN_FIND_REPLACE
! 	else if (uMsg == s_findrep_msg && s_findrep_msg != 0)
  	{
  	    _OnFindRepl();
  	}
--- 5058,5065 ----
  #endif
  
      default:
  #ifdef MSWIN_FIND_REPLACE
! 	if (uMsg == s_findrep_msg && s_findrep_msg != 0)
  	{
  	    _OnFindRepl();
  	}
***************
*** 5376,5417 ****
  	    }
      }
  #endif
- 
-     /* get the OS version info */
-     os_version.dwOSVersionInfoSize = sizeof(os_version);
-     GetVersionEx(&os_version); /* this call works on Win32s, Win95 and WinNT */
- 
-     /* try and load the user32.dll library and get the entry points for
-      * multi-monitor-support. */
-     if ((user32_lib = vimLoadLib("User32.dll")) != NULL)
-     {
- 	pMonitorFromWindow = (TMonitorFromWindow)GetProcAddress(user32_lib,
- 							 "MonitorFromWindow");
- 
- 	/* there are ...A and ...W version of GetMonitorInfo - looking at
- 	 * winuser.h, they have exactly the same declaration. */
- 	pGetMonitorInfo = (TGetMonitorInfo)GetProcAddress(user32_lib,
- 							  "GetMonitorInfoA");
-     }
- 
- #ifdef FEAT_MBYTE
-     /* If the OS is Windows NT, use wide functions;
-      * this enables common dialogs input unicode from IME. */
-     if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT)
-     {
- 	pDispatchMessage = DispatchMessageW;
- 	pGetMessage = GetMessageW;
- 	pIsDialogMessage = IsDialogMessageW;
- 	pPeekMessage = PeekMessageW;
-     }
-     else
-     {
- 	pDispatchMessage = DispatchMessageA;
- 	pGetMessage = GetMessageA;
- 	pIsDialogMessage = IsDialogMessageA;
- 	pPeekMessage = PeekMessageA;
-     }
- #endif
  }
  
  /*
--- 5219,5224 ----
***************
*** 5475,5486 ****
  		    atom =
  #endif
  		    RegisterClassW(&wndclassw)) == 0)
! 	{
! 	    if (GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
! 		return FAIL;
! 
! 	    /* Must be Windows 98, fall back to non-wide function. */
! 	}
  	else
  	    wide_WindowProc = TRUE;
      }
--- 5282,5288 ----
  		    atom =
  #endif
  		    RegisterClassW(&wndclassw)) == 0)
! 	    return FAIL;
  	else
  	    wide_WindowProc = TRUE;
      }
***************
*** 5710,5716 ****
      s_findrep_struct.lpstrReplaceWith[0] = NUL;
      s_findrep_struct.wFindWhatLen = MSWIN_FR_BUFSIZE;
      s_findrep_struct.wReplaceWithLen = MSWIN_FR_BUFSIZE;
! # if defined(FEAT_MBYTE) && defined(WIN3264)
      s_findrep_struct_w.lStructSize = sizeof(s_findrep_struct_w);
      s_findrep_struct_w.lpstrFindWhat =
  			      (LPWSTR)alloc(MSWIN_FR_BUFSIZE * sizeof(WCHAR));
--- 5512,5518 ----
      s_findrep_struct.lpstrReplaceWith[0] = NUL;
      s_findrep_struct.wFindWhatLen = MSWIN_FR_BUFSIZE;
      s_findrep_struct.wReplaceWithLen = MSWIN_FR_BUFSIZE;
! # ifdef FEAT_MBYTE
      s_findrep_struct_w.lStructSize = sizeof(s_findrep_struct_w);
      s_findrep_struct_w.lpstrFindWhat =
  			      (LPWSTR)alloc(MSWIN_FR_BUFSIZE * sizeof(WCHAR));
***************
*** 5753,5774 ****
      static void
  get_work_area(RECT *spi_rect)
  {
!     _HMONITOR	    mon;
!     _MONITORINFO    moninfo;
  
!     /* use these functions only if available */
!     if (pMonitorFromWindow != NULL && pGetMonitorInfo != NULL)
      {
! 	/* work out which monitor the window is on, and get *it's* work area */
! 	mon = pMonitorFromWindow(s_hwnd, 1 /*MONITOR_DEFAULTTOPRIMARY*/);
! 	if (mon != NULL)
  	{
! 	    moninfo.cbSize = sizeof(_MONITORINFO);
! 	    if (pGetMonitorInfo(mon, &moninfo))
! 	    {
! 		*spi_rect = moninfo.rcWork;
! 		return;
! 	    }
  	}
      }
      /* this is the old method... */
--- 5555,5572 ----
      static void
  get_work_area(RECT *spi_rect)
  {
!     HMONITOR	    mon;
!     MONITORINFO	    moninfo;
  
!     /* work out which monitor the window is on, and get *it's* work area */
!     mon = MonitorFromWindow(s_hwnd, 1 /*MONITOR_DEFAULTTOPRIMARY*/);
!     if (mon != NULL)
      {
! 	moninfo.cbSize = sizeof(MONITORINFO);
! 	if (GetMonitorInfo(mon, &moninfo))
  	{
! 	    *spi_rect = moninfo.rcWork;
! 	    return;
  	}
      }
      /* this is the old method... */
***************
*** 6307,6335 ****
  	CONST INT *padding)
  {
      int		ix;
-     static int	special = -1;
- 
-     if (special == -1)
-     {
- 	/* Check windows version: special treatment is needed if it is NT 5 or
- 	 * Win98 or higher. */
- 	if  ((os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
- 		    && os_version.dwMajorVersion >= 5)
- 		|| (os_version.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS
- 		    && (os_version.dwMajorVersion > 4
- 			|| (os_version.dwMajorVersion == 4
- 			    && os_version.dwMinorVersion > 0))))
- 	    special = 1;
- 	else
- 	    special = 0;
-     }
  
!     if (special)
! 	for (ix = 0; ix < (int)len; ++ix)
! 	    ExtTextOut(s_hdc, col + TEXT_X(ix), row, foptions,
! 					    pcliprect, text + ix, 1, padding);
!     else
! 	ExtTextOut(s_hdc, col, row, foptions, pcliprect, text, len, padding);
  }
  #endif
  
--- 6105,6114 ----
  	CONST INT *padding)
  {
      int		ix;
  
!     for (ix = 0; ix < (int)len; ++ix)
! 	ExtTextOut(s_hdc, col + TEXT_X(ix), row, foptions,
! 					pcliprect, text + ix, 1, padding);
  }
  #endif
  
***************
*** 6718,6780 ****
  
      if (menu_is_menubar(menu->name))
      {
- 	if (is_winnt_3())
- 	{
- 	    InsertMenu((parent == NULL) ? s_menuBar : parent->submenu_id,
- 		    (UINT)pos, MF_POPUP | MF_STRING | MF_BYPOSITION,
- 		    (long_u)menu->submenu_id, (LPCTSTR) menu->name);
- 	}
- 	else
- 	{
  #ifdef FEAT_MBYTE
! 	    WCHAR	*wn = NULL;
! 	    int		n;
  
! 	    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	    {
! 		/* 'encoding' differs from active codepage: convert menu name
! 		 * and use wide function */
! 		wn = enc_to_utf16(menu->name, NULL);
! 		if (wn != NULL)
! 		{
! 		    MENUITEMINFOW	infow;
  
! 		    infow.cbSize = sizeof(infow);
! 		    infow.fMask = MIIM_DATA | MIIM_TYPE | MIIM_ID
! 							       | MIIM_SUBMENU;
! 		    infow.dwItemData = (long_u)menu;
! 		    infow.wID = menu->id;
! 		    infow.fType = MFT_STRING;
! 		    infow.dwTypeData = wn;
! 		    infow.cch = (UINT)wcslen(wn);
! 		    infow.hSubMenu = menu->submenu_id;
! 		    n = InsertMenuItemW((parent == NULL)
! 					    ? s_menuBar : parent->submenu_id,
! 					    (UINT)pos, TRUE, &infow);
! 		    vim_free(wn);
! 		    if (n == 0 && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
! 			/* Failed, try using non-wide function. */
! 			wn = NULL;
! 		}
  	    }
  
! 	    if (wn == NULL)
  #endif
! 	    {
! 		MENUITEMINFO	info;
  
! 		info.cbSize = sizeof(info);
! 		info.fMask = MIIM_DATA | MIIM_TYPE | MIIM_ID | MIIM_SUBMENU;
! 		info.dwItemData = (long_u)menu;
! 		info.wID = menu->id;
! 		info.fType = MFT_STRING;
! 		info.dwTypeData = (LPTSTR)menu->name;
! 		info.cch = (UINT)STRLEN(menu->name);
! 		info.hSubMenu = menu->submenu_id;
! 		InsertMenuItem((parent == NULL)
! 					? s_menuBar : parent->submenu_id,
! 					(UINT)pos, TRUE, &info);
! 	    }
  	}
      }
  
--- 6497,6546 ----
  
      if (menu_is_menubar(menu->name))
      {
  #ifdef FEAT_MBYTE
! 	WCHAR	*wn = NULL;
  
! 	if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
! 	{
! 	    /* 'encoding' differs from active codepage: convert menu name
! 	     * and use wide function */
! 	    wn = enc_to_utf16(menu->name, NULL);
! 	    if (wn != NULL)
  	    {
! 		MENUITEMINFOW	infow;
  
! 		infow.cbSize = sizeof(infow);
! 		infow.fMask = MIIM_DATA | MIIM_TYPE | MIIM_ID
! 		    | MIIM_SUBMENU;
! 		infow.dwItemData = (long_u)menu;
! 		infow.wID = menu->id;
! 		infow.fType = MFT_STRING;
! 		infow.dwTypeData = wn;
! 		infow.cch = (UINT)wcslen(wn);
! 		infow.hSubMenu = menu->submenu_id;
! 		InsertMenuItemW((parent == NULL)
! 			? s_menuBar : parent->submenu_id,
! 			(UINT)pos, TRUE, &infow);
! 		vim_free(wn);
  	    }
+ 	}
  
! 	if (wn == NULL)
  #endif
! 	{
! 	    MENUITEMINFO	info;
  
! 	    info.cbSize = sizeof(info);
! 	    info.fMask = MIIM_DATA | MIIM_TYPE | MIIM_ID | MIIM_SUBMENU;
! 	    info.dwItemData = (long_u)menu;
! 	    info.wID = menu->id;
! 	    info.fType = MFT_STRING;
! 	    info.dwTypeData = (LPTSTR)menu->name;
! 	    info.cch = (UINT)STRLEN(menu->name);
! 	    info.hSubMenu = menu->submenu_id;
! 	    InsertMenuItem((parent == NULL)
! 		    ? s_menuBar : parent->submenu_id,
! 		    (UINT)pos, TRUE, &info);
  	}
      }
  
***************
*** 6890,6896 ****
      {
  #ifdef FEAT_MBYTE
  	WCHAR	*wn = NULL;
- 	int	n;
  
  	if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	{
--- 6656,6661 ----
***************
*** 6899,6912 ****
  	    wn = enc_to_utf16(menu->name, NULL);
  	    if (wn != NULL)
  	    {
! 		n = InsertMenuW(parent->submenu_id, (UINT)idx,
  			(menu_is_separator(menu->name)
  				 ? MF_SEPARATOR : MF_STRING) | MF_BYPOSITION,
  			(UINT)menu->id, wn);
  		vim_free(wn);
- 		if (n == 0 && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
- 		    /* Failed, try using non-wide function. */
- 		    wn = NULL;
  	    }
  	}
  	if (wn == NULL)
--- 6664,6674 ----
  	    wn = enc_to_utf16(menu->name, NULL);
  	    if (wn != NULL)
  	    {
! 		InsertMenuW(parent->submenu_id, (UINT)idx,
  			(menu_is_separator(menu->name)
  				 ? MF_SEPARATOR : MF_STRING) | MF_BYPOSITION,
  			(UINT)menu->id, wn);
  		vim_free(wn);
  	    }
  	}
  	if (wn == NULL)
***************
*** 7105,7115 ****
  	/* If the edit box exists, copy the string. */
  	if (s_textfield != NULL)
  	{
! # if defined(FEAT_MBYTE) && defined(WIN3264)
  	    /* If the OS is Windows NT, and 'encoding' differs from active
  	     * codepage: use wide function and convert text. */
! 	    if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
! 		    && enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	    {
  	       WCHAR  *wp = (WCHAR *)alloc(IOSIZE * sizeof(WCHAR));
  	       char_u *p;
--- 6867,6876 ----
  	/* If the edit box exists, copy the string. */
  	if (s_textfield != NULL)
  	{
! # ifdef FEAT_MBYTE
  	    /* If the OS is Windows NT, and 'encoding' differs from active
  	     * codepage: use wide function and convert text. */
! 	    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	    {
  	       WCHAR  *wp = (WCHAR *)alloc(IOSIZE * sizeof(WCHAR));
  	       char_u *p;
***************
*** 7866,7903 ****
  
      s_usenewlook = FALSE;
  
-     /*
-      * For NT3.51 and Win32s, we stick with the old look
-      * because it matches everything else.
-      */
-     if (!is_winnt_3())
-     {
  #ifdef USE_SYSMENU_FONT
! 	if (gui_w32_get_menu_font(&lfSysmenu) == OK)
! 	    hfontTools = CreateFontIndirect(&lfSysmenu);
! 	else
  #endif
  	hfontTools = CreateFont(-DLG_FONT_POINT_SIZE, 0, 0, 0, 0, 0, 0, 0,
  				0, 0, 0, 0, VARIABLE_PITCH , DLG_FONT_NAME);
  
! 	if (hfontTools)
! 	{
! 	    hdc = GetDC(s_hwnd);
! 	    SelectObject(hdc, hfontTools);
! 	    /*
! 	     * GetTextMetrics() doesn't return the right value in
! 	     * tmAveCharWidth, so we have to figure out the dialog base units
! 	     * ourselves.
! 	     */
! 	    GetTextExtentPoint(hdc,
! 		    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
! 		    52, &size);
! 	    ReleaseDC(s_hwnd, hdc);
! 
! 	    s_dlgfntwidth = (WORD)((size.cx / 26 + 1) / 2);
! 	    s_dlgfntheight = (WORD)size.cy;
! 	    s_usenewlook = TRUE;
! 	}
      }
  
      if (!s_usenewlook)
--- 7627,7657 ----
  
      s_usenewlook = FALSE;
  
  #ifdef USE_SYSMENU_FONT
!     if (gui_w32_get_menu_font(&lfSysmenu) == OK)
! 	hfontTools = CreateFontIndirect(&lfSysmenu);
!     else
  #endif
  	hfontTools = CreateFont(-DLG_FONT_POINT_SIZE, 0, 0, 0, 0, 0, 0, 0,
  				0, 0, 0, 0, VARIABLE_PITCH , DLG_FONT_NAME);
  
!     if (hfontTools)
!     {
! 	hdc = GetDC(s_hwnd);
! 	SelectObject(hdc, hfontTools);
! 	/*
! 	 * GetTextMetrics() doesn't return the right value in
! 	 * tmAveCharWidth, so we have to figure out the dialog base units
! 	 * ourselves.
! 	 */
! 	GetTextExtentPoint(hdc,
! 		"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
! 		52, &size);
! 	ReleaseDC(s_hwnd, hdc);
! 
! 	s_dlgfntwidth = (WORD)((size.cx / 26 + 1) / 2);
! 	s_dlgfntheight = (WORD)size.cy;
! 	s_usenewlook = TRUE;
      }
  
      if (!s_usenewlook)
***************
*** 8044,8053 ****
  	dlgwidth = textWidth;
      dlgwidth += 2 * TEAROFF_PADDING_X + TEAROFF_BUTTON_PAD_X;
  
-     /* W95 can't do thin dialogs, they look v. weird! */
-     if (mch_windows95() && dlgwidth < TEAROFF_MIN_WIDTH)
- 	dlgwidth = TEAROFF_MIN_WIDTH;
- 
      /* start to fill in the dlgtemplate information.  addressing by WORDs */
      if (s_usenewlook)
  	lStyle = DS_MODALFRAME | WS_CAPTION| WS_SYSMENU |DS_SETFONT| WS_VISIBLE;
--- 7798,7803 ----
***************
*** 8299,8305 ****
      /*
       * Check user bitmaps first, unless builtin is specified.
       */
!     if (!is_winnt_3() && !menu->icon_builtin)
      {
  	char_u fname[MAXPATHL];
  	HANDLE hbitmap = NULL;
--- 8049,8055 ----
      /*
       * Check user bitmaps first, unless builtin is specified.
       */
!     if (!menu->icon_builtin)
      {
  	char_u fname[MAXPATHL];
  	HANDLE hbitmap = NULL;
***************
*** 8556,8567 ****
      signicon_t	sign, *psign;
      char_u	*ext;
  
-     if (is_winnt_3())
-     {
- 	EMSG(_(e_signdata));
- 	return NULL;
-     }
- 
      sign.hImage = NULL;
      ext = signfile + STRLEN(signfile) - 4; /* get extension */
      if (ext > signfile)
--- 8306,8311 ----
*** ../vim-8.0.0028/src/if_cscope.c	2016-08-29 22:42:20.000000000 +0200
--- src/if_cscope.c	2016-10-12 14:00:10.234811607 +0200
***************
*** 839,852 ****
      HANDLE	stdin_rd, stdout_rd;
      HANDLE	stdout_wr, stdin_wr;
      BOOL	created;
! # ifdef __BORLANDC__
! #  define OPEN_OH_ARGTYPE long
  # else
! #  if (_MSC_VER >= 1300) || defined(__MINGW32__)
! #   define OPEN_OH_ARGTYPE intptr_t
! #  else
! #   define OPEN_OH_ARGTYPE long
! #  endif
  # endif
  #endif
  
--- 839,848 ----
      HANDLE	stdin_rd, stdout_rd;
      HANDLE	stdout_wr, stdin_wr;
      BOOL	created;
! # if (defined(_MSC_VER) && (_MSC_VER >= 1300)) || defined(__MINGW32__)
! #  define OPEN_OH_ARGTYPE intptr_t
  # else
! #  define OPEN_OH_ARGTYPE long
  # endif
  #endif
  
***************
*** 1427,1437 ****
  #ifndef UNIX
      BY_HANDLE_FILE_INFORMATION bhfi;
  
!     /* On windows 9x GetFileInformationByHandle doesn't work, so skip it */
!     if (!mch_windows95())
      {
- 	switch (win32_fileinfo((char_u *)fname, &bhfi))
- 	{
  	case FILEINFO_ENC_FAIL:		/* enc_to_utf16() failed */
  	case FILEINFO_READ_FAIL:	/* CreateFile() failed */
  	    if (p_csverbose)
--- 1423,1430 ----
  #ifndef UNIX
      BY_HANDLE_FILE_INFORMATION bhfi;
  
!     switch (win32_fileinfo((char_u *)fname, &bhfi))
      {
  	case FILEINFO_ENC_FAIL:		/* enc_to_utf16() failed */
  	case FILEINFO_READ_FAIL:	/* CreateFile() failed */
  	    if (p_csverbose)
***************
*** 1454,1460 ****
  	    if (p_csverbose)
  		(void)EMSG(_("E626: cannot get cscope database information"));
  	    return -1;
- 	}
      }
  #endif
  
--- 1447,1452 ----
***************
*** 1468,1476 ****
  	    /* compare pathnames first */
  	    && ((fullpathcmp((char_u *)csinfo[j].fname,
  			(char_u *)fname, FALSE) & FPC_SAME)
! 		/* if not Windows 9x, test index file attributes too */
! 		|| (!mch_windows95()
! 		    && csinfo[j].nVolume == bhfi.dwVolumeSerialNumber
  		    && csinfo[j].nIndexHigh == bhfi.nFileIndexHigh
  		    && csinfo[j].nIndexLow == bhfi.nFileIndexLow))
  #endif
--- 1460,1467 ----
  	    /* compare pathnames first */
  	    && ((fullpathcmp((char_u *)csinfo[j].fname,
  			(char_u *)fname, FALSE) & FPC_SAME)
! 		/* test index file attributes too */
! 		|| (csinfo[j].nVolume == bhfi.dwVolumeSerialNumber
  		    && csinfo[j].nIndexHigh == bhfi.nFileIndexHigh
  		    && csinfo[j].nIndexLow == bhfi.nFileIndexLow))
  #endif
*** ../vim-8.0.0028/src/misc1.c	2016-09-10 15:43:04.000000000 +0200
--- src/misc1.c	2016-10-12 14:00:10.238811579 +0200
***************
*** 9450,9459 ****
  	 * screen (if there are two screens).
  	 */
  	settmode(TMODE_COOK);
! #ifdef WIN3264
! 	if (can_end_termcap_mode(FALSE) == TRUE)
! #endif
! 	    stoptermcap();
  	out_flush();
      }
  }
--- 9450,9456 ----
  	 * screen (if there are two screens).
  	 */
  	settmode(TMODE_COOK);
! 	stoptermcap();
  	out_flush();
      }
  }
*** ../vim-8.0.0028/src/misc2.c	2016-09-04 20:34:12.000000000 +0200
--- src/misc2.c	2016-10-12 14:00:10.238811579 +0200
***************
*** 1420,1426 ****
      length = (unsigned)STRLEN(string) + 3;  /* two quotes and a trailing NUL */
      for (p = string; *p != NUL; mb_ptr_adv(p))
      {
! # if defined(WIN32) || defined(DOS)
  	if (!p_ssl)
  	{
  	    if (*p == '"')
--- 1420,1426 ----
      length = (unsigned)STRLEN(string) + 3;  /* two quotes and a trailing NUL */
      for (p = string; *p != NUL; mb_ptr_adv(p))
      {
! # ifdef WIN32
  	if (!p_ssl)
  	{
  	    if (*p == '"')
***************
*** 1451,1457 ****
  	d = escaped_string;
  
  	/* add opening quote */
! # if defined(WIN32) || defined(DOS)
  	if (!p_ssl)
  	    *d++ = '"';
  	else
--- 1451,1457 ----
  	d = escaped_string;
  
  	/* add opening quote */
! # ifdef WIN32
  	if (!p_ssl)
  	    *d++ = '"';
  	else
***************
*** 1460,1466 ****
  
  	for (p = string; *p != NUL; )
  	{
! # if defined(WIN32) || defined(DOS)
  	    if (!p_ssl)
  	    {
  		if (*p == '"')
--- 1460,1466 ----
  
  	for (p = string; *p != NUL; )
  	{
! # ifdef WIN32
  	    if (!p_ssl)
  	    {
  		if (*p == '"')
***************
*** 1503,1509 ****
  	}
  
  	/* add terminating quote and finish with a NUL */
! # if defined(WIN32) || defined(DOS)
  	if (!p_ssl)
  	    *d++ = '"';
  	else
--- 1503,1509 ----
  	}
  
  	/* add terminating quote and finish with a NUL */
! # ifdef WIN32
  	if (!p_ssl)
  	    *d++ = '"';
  	else
*** ../vim-8.0.0028/src/option.c	2016-09-12 19:51:07.685659713 +0200
--- src/option.c	2016-10-12 14:00:10.238811579 +0200
***************
*** 22,28 ****
   * - If it's a list of flags, add some code in do_set(), search for WW_ALL.
   * - When adding an option with expansion (P_EXPAND), but with a different
   *   default for Vi and Vim (no P_VI_DEF), add some code at VIMEXP.
!  * - Add documentation!  One line in doc/help.txt, full description in
   *   options.txt, and any other related places.
   * - Add an entry in runtime/optwin.vim.
   * When making changes:
--- 22,28 ----
   * - If it's a list of flags, add some code in do_set(), search for WW_ALL.
   * - When adding an option with expansion (P_EXPAND), but with a different
   *   default for Vi and Vim (no P_VI_DEF), add some code at VIMEXP.
!  * - Add documentation!  One line in doc/quickref.txt, full description in
   *   options.txt, and any other related places.
   * - Add an entry in runtime/optwin.vim.
   * When making changes:
***************
*** 9944,9956 ****
      if (gui.starting)
  	clear_xterm_clip();
  #endif
! #ifdef WIN3264
!     /*
!      * Check if this is allowed now.
!      */
!     if (can_end_termcap_mode(FALSE) == TRUE)
! #endif
! 	stoptermcap();			/* stop termcap mode */
  
      free_termoptions();
  }
--- 9944,9950 ----
      if (gui.starting)
  	clear_xterm_clip();
  #endif
!     stoptermcap();			/* stop termcap mode */
  
      free_termoptions();
  }
*** ../vim-8.0.0028/src/os_mswin.c	2016-08-29 22:42:20.000000000 +0200
--- src/os_mswin.c	2016-10-12 14:00:10.238811579 +0200
***************
*** 38,48 ****
  
  # if defined(FEAT_PRINTER) && !defined(FEAT_POSTSCRIPT)
  #  include <dlgs.h>
! #  ifdef WIN3264
! #   include <winspool.h>
! #  else
! #   include <print.h>
! #  endif
  #  include <commdlg.h>
  #endif
  
--- 38,44 ----
  
  # if defined(FEAT_PRINTER) && !defined(FEAT_POSTSCRIPT)
  #  include <dlgs.h>
! #  include <winspool.h>
  #  include <commdlg.h>
  #endif
  
***************
*** 130,139 ****
  FILE* fdDump = NULL;
  #endif
  
- #ifdef WIN3264
- extern DWORD g_PlatformId;
- #endif
- 
  #ifndef FEAT_GUI_MSWIN
  extern char g_szOrigTitle[];
  #endif
--- 126,131 ----
***************
*** 248,267 ****
  {
      int		i;
  
- #ifdef WIN3264
      PlatformId();
- #endif
  
      /* Init the tables for toupper() and tolower() */
      for (i = 0; i < 256; ++i)
  	toupper_tab[i] = tolower_tab[i] = i;
- #ifdef WIN3264
      CharUpperBuff((LPSTR)toupper_tab, 256);
      CharLowerBuff((LPSTR)tolower_tab, 256);
- #else
-     AnsiUpperBuff((LPSTR)toupper_tab, 256);
-     AnsiLowerBuff((LPSTR)tolower_tab, 256);
- #endif
  }
  
  
--- 240,252 ----
***************
*** 299,312 ****
  	{
  	    /* Convert the title from 'encoding' to the active codepage. */
  	    WCHAR	*wp = enc_to_utf16(title, NULL);
- 	    int	n;
  
  	    if (wp != NULL)
  	    {
! 		n = SetConsoleTitleW(wp);
  		vim_free(wp);
! 		if (n != 0 || GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
! 		    return;
  	    }
  	}
  #  endif
--- 284,295 ----
  	{
  	    /* Convert the title from 'encoding' to the active codepage. */
  	    WCHAR	*wp = enc_to_utf16(title, NULL);
  
  	    if (wp != NULL)
  	    {
! 		SetConsoleTitleW(wp);
  		vim_free(wp);
! 		return;
  	    }
  	}
  #  endif
***************
*** 379,390 ****
  #endif
      {
  #ifdef FEAT_MBYTE
! 	if (enc_codepage >= 0 && (int)GetACP() != enc_codepage
! # ifdef __BORLANDC__
! 		/* Wide functions of Borland C 5.5 do not work on Windows 98. */
! 		&& g_PlatformId == VER_PLATFORM_WIN32_NT
! # endif
! 	   )
  	{
  	    WCHAR	*wname;
  	    WCHAR	wbuf[MAX_PATH];
--- 362,368 ----
  #endif
      {
  #ifdef FEAT_MBYTE
! 	if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	{
  	    WCHAR	*wname;
  	    WCHAR	wbuf[MAX_PATH];
***************
*** 641,652 ****
  	}
      }
  #ifdef FEAT_MBYTE
!     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage
! # ifdef __BORLANDC__
! 	    /* Wide functions of Borland C 5.5 do not work on Windows 98. */
! 	    && g_PlatformId == VER_PLATFORM_WIN32_NT
! # endif
!        )
      {
  	WCHAR	*wp = enc_to_utf16(buf, NULL);
  	int	n;
--- 619,625 ----
  	}
      }
  #ifdef FEAT_MBYTE
!     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
  	WCHAR	*wp = enc_to_utf16(buf, NULL);
  	int	n;
***************
*** 655,665 ****
  	{
  	    n = wstat_symlink_aware(wp, stp);
  	    vim_free(wp);
! 	    if (n >= 0 || g_PlatformId == VER_PLATFORM_WIN32_NT)
! 		return n;
! 	    /* Retry with non-wide function (for Windows 98). Can't use
! 	     * GetLastError() here and it's unclear what errno gets set to if
! 	     * the _wstat() fails for missing wide functions. */
  	}
      }
  #endif
--- 628,634 ----
  	{
  	    n = wstat_symlink_aware(wp, stp);
  	    vim_free(wp);
! 	    return n;
  	}
      }
  #endif
***************
*** 823,831 ****
  	{
  	    n = _wchdir(p);
  	    vim_free(p);
! 	    if (n == 0 || g_PlatformId == VER_PLATFORM_WIN32_NT)
! 		return n;
! 	    /* Retry with non-wide function (for Windows 98). */
  	}
      }
  #endif
--- 792,798 ----
  	{
  	    n = _wchdir(p);
  	    vim_free(p);
! 	    return n;
  	}
      }
  #endif
***************
*** 834,860 ****
  }
  
  
- /*
-  * Switching off termcap mode is only allowed when Columns is 80, otherwise a
-  * crash may result.  It's always allowed on NT or when running the GUI.
-  */
- /*ARGSUSED*/
-     int
- can_end_termcap_mode(
-     int give_msg)
- {
- #ifdef FEAT_GUI_MSWIN
-     return TRUE;	/* GUI starts a new console anyway */
- #else
-     if (g_PlatformId == VER_PLATFORM_WIN32_NT || Columns == 80)
- 	return TRUE;
-     if (give_msg)
- 	msg((char_u *)
- 		_("'columns' is not 80, cannot execute external commands"));
-     return FALSE;
- #endif
- }
- 
  #ifdef FEAT_GUI_MSWIN
  /*
   * return non-zero if a character is available
--- 801,806 ----
***************
*** 887,903 ****
   * and returns an allocated string.
   * Return OK if it worked, FAIL if not.
   */
- # ifdef WIN3264
  typedef LPTSTR (*MYSTRPROCSTR)(LPTSTR);
  typedef LPTSTR (*MYINTPROCSTR)(int);
  typedef int (*MYSTRPROCINT)(LPTSTR);
  typedef int (*MYINTPROCINT)(int);
- # else
- typedef LPSTR (*MYSTRPROCSTR)(LPSTR);
- typedef LPSTR (*MYINTPROCSTR)(int);
- typedef int (*MYSTRPROCINT)(LPSTR);
- typedef int (*MYINTPROCINT)(int);
- # endif
  
  /*
   * Check if a pointer points to a valid NUL terminated string.
--- 833,842 ----
***************
*** 1093,1099 ****
  #endif //_DEBUG
  
  #if !defined(FEAT_GUI) || defined(PROTO)
! # if defined(FEAT_TITLE) && defined(WIN3264)
  extern HWND g_hWnd;	/* This is in os_win32.c. */
  # endif
  
--- 1032,1038 ----
  #endif //_DEBUG
  
  #if !defined(FEAT_GUI) || defined(PROTO)
! # ifdef FEAT_TITLE
  extern HWND g_hWnd;	/* This is in os_win32.c. */
  # endif
  
***************
*** 1114,1120 ****
      if (s_hwnd != 0)
  	return;
  
! # if defined(FEAT_TITLE) && defined(WIN3264)
      /* Window handle may have been found by init code (Windows NT only) */
      if (g_hWnd != 0)
      {
--- 1053,1059 ----
      if (s_hwnd != 0)
  	return;
  
! # ifdef FEAT_TITLE
      /* Window handle may have been found by init code (Windows NT only) */
      if (g_hWnd != 0)
      {
***************
*** 1539,1545 ****
  	    )
      {
  	prt_dlg.Flags |= PD_RETURNDEFAULT;
- #ifdef WIN3264
  	/*
  	 * MSDN suggests setting the first parameter to WINSPOOL for
  	 * NT, but NULL appears to work just as well.
--- 1478,1483 ----
***************
*** 1547,1553 ****
  	if (*p_pdev != NUL)
  	    prt_dlg.hDC = CreateDC(NULL, (LPCSTR)p_pdev, NULL, NULL);
  	else
- #endif
  	{
  	    prt_dlg.Flags |= PD_RETURNDEFAULT;
  	    if (PrintDlg(&prt_dlg) == 0)
--- 1485,1490 ----
***************
*** 1593,1602 ****
      mem = (DEVMODE *)GlobalLock(prt_dlg.hDevMode);
      if (mem != NULL)
      {
- #ifdef WIN3264
  	if (mem->dmCopies != 1)
  	    stored_nCopies = mem->dmCopies;
- #endif
  	if ((mem->dmFields & DM_DUPLEX) && (mem->dmDuplex & ~DMDUP_SIMPLEX))
  	    psettings->duplex = TRUE;
  	if ((mem->dmFields & DM_COLOR) && (mem->dmColor & DMCOLOR_COLOR))
--- 1530,1537 ----
***************
*** 1953,1959 ****
  		goto shortcut_end;
  	    }
  	}
! 	/* Retry with non-wide function (for Windows 98). */
      }
  # endif
      // create a link manager object and request its interface
--- 1888,1894 ----
  		goto shortcut_end;
  	    }
  	}
! 	goto shortcut_end;
      }
  # endif
      // create a link manager object and request its interface
***************
*** 2681,2687 ****
      {"OEM",		OEM_CHARSET},
      {"SHIFTJIS",	SHIFTJIS_CHARSET},
      {"SYMBOL",		SYMBOL_CHARSET},
- #ifdef WIN3264
      {"ARABIC",		ARABIC_CHARSET},
      {"BALTIC",		BALTIC_CHARSET},
      {"EASTEUROPE",	EASTEUROPE_CHARSET},
--- 2616,2621 ----
***************
*** 2693,2702 ****
      {"RUSSIAN",		RUSSIAN_CHARSET},
      {"THAI",		THAI_CHARSET},
      {"TURKISH",		TURKISH_CHARSET},
! # if (!defined(_MSC_VER) || (_MSC_VER > 1010)) \
! 	&& (!defined(__BORLANDC__) || (__BORLANDC__ > 0x0500))
      {"VIETNAMESE",	VIETNAMESE_CHARSET},
- # endif
  #endif
      {NULL,		0}
  };
--- 2627,2634 ----
      {"RUSSIAN",		RUSSIAN_CHARSET},
      {"THAI",		THAI_CHARSET},
      {"TURKISH",		TURKISH_CHARSET},
! #ifdef VIETNAMESE_CHARSET
      {"VIETNAMESE",	VIETNAMESE_CHARSET},
  #endif
      {NULL,		0}
  };
*** ../vim-8.0.0028/src/os_win32.c	2016-09-29 15:18:51.359768012 +0200
--- src/os_win32.c	2016-10-12 14:00:10.242811549 +0200
***************
*** 141,183 ****
  # define __stdcall /* empty */
  #endif
  
- #ifndef FEAT_GUI_W32
- /* Undocumented API in kernel32.dll needed to work around dead key bug in
-  * console-mode applications in NT 4.0.  If you switch keyboard layouts
-  * in a console app to a layout that includes dead keys and then hit a
-  * dead key, a call to ToAscii will trash the stack.  My thanks to Ian James
-  * and Michael Dietrich for helping me figure out this workaround.
-  */
- 
- /* WINAPI BOOL WINAPI GetConsoleKeyboardLayoutNameA(LPSTR); */
- #ifndef WINAPI
- # define WINAPI __stdcall
- #endif
- #if defined(__BORLANDC__)
- typedef BOOL (__stdcall *PFNGCKLN)(LPSTR);
- #else
- typedef BOOL (WINAPI *PFNGCKLN)(LPSTR);
- #endif
- static PFNGCKLN    s_pfnGetConsoleKeyboardLayoutName = NULL;
- #endif
- 
  #if defined(__BORLANDC__)
  /* Strangely Borland uses a non-standard name. */
  # define wcsicmp(a, b) wcscmpi((a), (b))
  #endif
  
- #ifndef PROTO
- 
- /* Enable common dialogs input unicode from IME if possible. */
- #ifdef FEAT_MBYTE
- LRESULT (WINAPI *pDispatchMessage)(CONST MSG *) = DispatchMessage;
- BOOL (WINAPI *pGetMessage)(LPMSG, HWND, UINT, UINT) = GetMessage;
- BOOL (WINAPI *pIsDialogMessage)(HWND, LPMSG) = IsDialogMessage;
- BOOL (WINAPI *pPeekMessage)(LPMSG, HWND, UINT, UINT, UINT) = PeekMessage;
- #endif
- 
- #endif /* PROTO */
- 
  #ifndef FEAT_GUI_W32
  /* Win32 Console handles for input and output */
  static HANDLE g_hConIn  = INVALID_HANDLE_VALUE;
--- 141,151 ----
***************
*** 430,436 ****
  vimLoadLib(char *name)
  {
      HINSTANCE	dll = NULL;
-     char	old_dir[MAXPATHL];
  
      /* NOTE: Do not use mch_dirname() and mch_chdir() here, they may call
       * vimLoadLib() recursively, which causes a stack overflow. */
--- 398,403 ----
***************
*** 438,444 ****
  	get_exe_name();
      if (exe_path != NULL)
      {
- #ifdef FEAT_MBYTE
  	WCHAR old_dirw[MAXPATHL];
  
  	if (GetCurrentDirectoryW(MAXPATHL, old_dirw) != 0)
--- 405,410 ----
***************
*** 451,468 ****
  	    SetCurrentDirectoryW(old_dirw);
  	    return dll;
  	}
- 	/* Retry with non-wide function (for Windows 98). */
- 	if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
- #endif
- 	    if (GetCurrentDirectory(MAXPATHL, old_dir) != 0)
- 	    {
- 		/* Change directory to where the executable is, both to make
- 		 * sure we find a .dll there and to avoid looking for a .dll
- 		 * in the current directory. */
- 		SetCurrentDirectory((LPCSTR)exe_path);
- 		dll = LoadLibrary(name);
- 		SetCurrentDirectory(old_dir);
- 	    }
      }
      return dll;
  }
--- 417,422 ----
***************
*** 621,658 ****
  # ifndef PROTECTED_DACL_SECURITY_INFORMATION
  #  define PROTECTED_DACL_SECURITY_INFORMATION	0x80000000L
  # endif
- 
- /*
-  * These are needed to dynamically load the ADVAPI DLL, which is not
-  * implemented under Windows 95 (and causes VIM to crash)
-  */
- typedef DWORD (WINAPI *PSNSECINFO) (LPSTR, SE_OBJECT_TYPE,
- 	SECURITY_INFORMATION, PSID, PSID, PACL, PACL);
- typedef DWORD (WINAPI *PGNSECINFO) (LPSTR, SE_OBJECT_TYPE,
- 	SECURITY_INFORMATION, PSID *, PSID *, PACL *, PACL *,
- 	PSECURITY_DESCRIPTOR *);
- # ifdef FEAT_MBYTE
- typedef DWORD (WINAPI *PSNSECINFOW) (LPWSTR, SE_OBJECT_TYPE,
- 	SECURITY_INFORMATION, PSID, PSID, PACL, PACL);
- typedef DWORD (WINAPI *PGNSECINFOW) (LPWSTR, SE_OBJECT_TYPE,
- 	SECURITY_INFORMATION, PSID *, PSID *, PACL *, PACL *,
- 	PSECURITY_DESCRIPTOR *);
- # endif
- 
- static HANDLE advapi_lib = NULL;	/* Handle for ADVAPI library */
- static PSNSECINFO pSetNamedSecurityInfo;
- static PGNSECINFO pGetNamedSecurityInfo;
- # ifdef FEAT_MBYTE
- static PSNSECINFOW pSetNamedSecurityInfoW;
- static PGNSECINFOW pGetNamedSecurityInfoW;
- # endif
  #endif
  
- typedef BOOL (WINAPI *PSETHANDLEINFORMATION)(HANDLE, DWORD, DWORD);
- 
- static BOOL allowPiping = FALSE;
- static PSETHANDLEINFORMATION pSetHandleInformation;
- 
  #ifdef HAVE_ACL
  /*
   * Enables or disables the specified privilege.
--- 575,582 ----
***************
*** 712,804 ****
  	    win8_or_later = TRUE;
  
  #ifdef HAVE_ACL
! 	/*
! 	 * Load the ADVAPI runtime if we are on anything
! 	 * other than Windows 95
! 	 */
! 	if (g_PlatformId == VER_PLATFORM_WIN32_NT)
! 	{
! 	    /*
! 	     * do this load.  Problems: Doesn't unload at end of run (this is
! 	     * theoretically okay, since Windows should unload it when VIM
! 	     * terminates).  Should we be using the 'mch_libcall' routines?
! 	     * Seems like a lot of overhead to load/unload ADVAPI32.DLL each
! 	     * time we verify security...
! 	     */
! 	    advapi_lib = vimLoadLib("ADVAPI32.DLL");
! 	    if (advapi_lib != NULL)
! 	    {
! 		pSetNamedSecurityInfo = (PSNSECINFO)GetProcAddress(advapi_lib,
! 						      "SetNamedSecurityInfoA");
! 		pGetNamedSecurityInfo = (PGNSECINFO)GetProcAddress(advapi_lib,
! 						      "GetNamedSecurityInfoA");
! # ifdef FEAT_MBYTE
! 		pSetNamedSecurityInfoW = (PSNSECINFOW)GetProcAddress(advapi_lib,
! 						      "SetNamedSecurityInfoW");
! 		pGetNamedSecurityInfoW = (PGNSECINFOW)GetProcAddress(advapi_lib,
! 						      "GetNamedSecurityInfoW");
! # endif
! 		if (pSetNamedSecurityInfo == NULL
! 			|| pGetNamedSecurityInfo == NULL
! # ifdef FEAT_MBYTE
! 			|| pSetNamedSecurityInfoW == NULL
! 			|| pGetNamedSecurityInfoW == NULL
! # endif
! 			)
! 		{
! 		    /* If we can't get the function addresses, set advapi_lib
! 		     * to NULL so that we don't use them. */
! 		    FreeLibrary(advapi_lib);
! 		    advapi_lib = NULL;
! 		}
! 		/* Enable privilege for getting or setting SACLs. */
! 		win32_enable_privilege(SE_SECURITY_NAME, TRUE);
! 	    }
! 	}
  #endif
- 	/*
- 	 * If we are on windows NT, try to load the pipe functions, only
- 	 * available from Win2K.
- 	 */
- 	if (g_PlatformId == VER_PLATFORM_WIN32_NT)
- 	{
- 	    HANDLE kernel32 = GetModuleHandle("kernel32");
- 	    pSetHandleInformation = (PSETHANDLEINFORMATION)GetProcAddress(
- 					    kernel32, "SetHandleInformation");
- 
- 	    allowPiping = pSetHandleInformation != NULL;
- 	}
  	done = TRUE;
      }
  }
  
- /*
-  * Return TRUE when running on Windows 95 (or 98 or ME).
-  * Only to be used after mch_init().
-  */
-     int
- mch_windows95(void)
- {
-     return g_PlatformId == VER_PLATFORM_WIN32_WINDOWS;
- }
- 
- #ifdef FEAT_GUI_W32
- /*
-  * Used to work around the "can't do synchronous spawn"
-  * problem on Win32s, without resorting to Universal Thunk.
-  */
- static int old_num_windows;
- static int num_windows;
- 
- /*ARGSUSED*/
-     static BOOL CALLBACK
- win32ssynch_cb(HWND hwnd, LPARAM lparam)
- {
-     num_windows++;
-     return TRUE;
- }
- #endif
- 
  #ifndef FEAT_GUI_W32
  
  #define SHIFT  (SHIFT_PRESSED)
--- 636,648 ----
  	    win8_or_later = TRUE;
  
  #ifdef HAVE_ACL
! 	/* Enable privilege for getting or setting SACLs. */
! 	win32_enable_privilege(SE_SECURITY_NAME, TRUE);
  #endif
  	done = TRUE;
      }
  }
  
  #ifndef FEAT_GUI_W32
  
  #define SHIFT  (SHIFT_PRESSED)
***************
*** 926,940 ****
  
      vim_memset(abKeystate, 0, sizeof (abKeystate));
  
-     // Should only be non-NULL on NT 4.0
-     if (s_pfnGetConsoleKeyboardLayoutName != NULL)
-     {
- 	CHAR szKLID[KL_NAMELENGTH];
- 
- 	if ((*s_pfnGetConsoleKeyboardLayoutName)(szKLID))
- 	    (void)LoadKeyboardLayout(szKLID, KLF_ACTIVATE);
-     }
- 
      /* Clear any pending dead keys */
      ToUnicode(VK_SPACE, MapVirtualKey(VK_SPACE, 0), abKeystate, awAnsiCode, 2, 0);
  
--- 770,775 ----
***************
*** 1977,1993 ****
  	    n = (long)SearchPathW(wnewpath, p, NULL, _MAX_PATH, fnamew, &dumw);
  	    vim_free(wnewpath);
  	    vim_free(p);
! 	    if (n > 0 || GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
! 	    {
! 		if (n == 0)
! 		    return FALSE;
! 		if (GetFileAttributesW(fnamew) & FILE_ATTRIBUTE_DIRECTORY)
! 		    return FALSE;
! 		if (path != NULL)
! 		    *path = utf16_to_enc(fnamew, NULL);
! 		return TRUE;
! 	    }
! 	    /* Retry with non-wide function (for Windows 98). */
  	}
      }
  #endif
--- 1812,1824 ----
  	    n = (long)SearchPathW(wnewpath, p, NULL, _MAX_PATH, fnamew, &dumw);
  	    vim_free(wnewpath);
  	    vim_free(p);
! 	    if (n == 0)
! 		return FALSE;
! 	    if (GetFileAttributesW(fnamew) & FILE_ATTRIBUTE_DIRECTORY)
! 		return FALSE;
! 	    if (path != NULL)
! 		*path = utf16_to_enc(fnamew, NULL);
! 	    return TRUE;
  	}
      }
  #endif
***************
*** 2462,2469 ****
      static void
  SaveConsoleTitleAndIcon(void)
  {
-     GETCONSOLEWINDOWPROC GetConsoleWindowProc;
- 
      /* Save the original title. */
      if (!GetConsoleTitle(g_szOrigTitle, sizeof(g_szOrigTitle)))
  	return;
--- 2293,2298 ----
***************
*** 2475,2486 ****
       * 2000.  On older operating systems, we can't change the window icon
       * anyway.
       */
!     if ((GetConsoleWindowProc = (GETCONSOLEWINDOWPROC)
! 	    GetProcAddress(GetModuleHandle("KERNEL32.DLL"),
! 		    "GetConsoleWindow")) != NULL)
!     {
! 	g_hWnd = (*GetConsoleWindowProc)();
!     }
      if (g_hWnd == NULL)
  	return;
  
--- 2304,2310 ----
       * 2000.  On older operating systems, we can't change the window icon
       * anyway.
       */
!     g_hWnd = GetConsoleWindow();
      if (g_hWnd == NULL)
  	return;
  
***************
*** 2589,2599 ****
  #ifdef FEAT_CLIPBOARD
      win_clip_init();
  #endif
- 
-     /* This will be NULL on anything but NT 4.0 */
-     s_pfnGetConsoleKeyboardLayoutName =
- 	(PFNGCKLN) GetProcAddress(GetModuleHandle("kernel32.dll"),
- 				  "GetConsoleKeyboardLayoutNameA");
  }
  
  /*
--- 2413,2418 ----
***************
*** 2775,2783 ****
  	    *porig = c;
  	    ptrue = ptruePrev + wcslen(ptruePrev);
  	}
- 	else if (hFind == INVALID_HANDLE_VALUE
- 		&& GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
- 	    return FAIL;
      }
  
      wcscpy(name, szTrueName);
--- 2594,2599 ----
***************
*** 2836,2842 ****
  		}
  	    }
  	}
! 	/* Retry with non-wide function (for Windows 98). */
      }
  #endif
  
--- 2652,2658 ----
  		}
  	    }
  	}
! 	return;
      }
  #endif
  
***************
*** 2966,2974 ****
  		return OK;
  	    }
  	}
- 	else if (GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
- 	    return FAIL;
- 	/* Retry with non-wide function (for Windows 98). */
      }
  #endif
      if (GetUserName(szUserName, &cch))
--- 2782,2787 ----
***************
*** 3008,3016 ****
  		return;
  	    }
  	}
- 	else if (GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
- 	    return;
- 	/* Retry with non-wide function (for Windows 98). */
      }
  #endif
      if (!GetComputerName((LPSTR)s, &cch))
--- 2821,2826 ----
***************
*** 3059,3067 ****
  		return OK;
  	    }
  	}
! 	else if (GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
! 	    return FAIL;
! 	/* Retry with non-wide function (for Windows 98). */
      }
  #endif
      return (GetCurrentDirectory(len, (LPSTR)buf) != 0 ? OK : FAIL);
--- 2869,2875 ----
  		return OK;
  	    }
  	}
! 	return FAIL;
      }
  #endif
      return (GetCurrentDirectory(len, (LPSTR)buf) != 0 ? OK : FAIL);
***************
*** 3101,3109 ****
  	{
  	    n = _wchmod(p, perm);
  	    vim_free(p);
! 	    if (n == -1 && g_PlatformId == VER_PLATFORM_WIN32_NT)
  		return FAIL;
- 	    /* Retry with non-wide function (for Windows 98). */
  	}
      }
      if (n == -1)
--- 2909,2916 ----
  	{
  	    n = _wchmod(p, perm);
  	    vim_free(p);
! 	    if (n == -1)
  		return FAIL;
  	}
      }
      if (n == -1)
***************
*** 3251,3268 ****
      {
  	hFind = FindFirstFileW(wn, &findDataW);
  	vim_free(wn);
! 	if (hFind == INVALID_HANDLE_VALUE
! 		&& GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
! 	{
! 	    /* Retry with non-wide function (for Windows 98). */
! 	    hFind = FindFirstFile((LPCSTR)name, &findDataA);
! 	    if (hFind != INVALID_HANDLE_VALUE)
! 	    {
! 		fileFlags = findDataA.dwFileAttributes;
! 		reparseTag = findDataA.dwReserved0;
! 	    }
! 	}
! 	else
  	{
  	    fileFlags = findDataW.dwFileAttributes;
  	    reparseTag = findDataW.dwReserved0;
--- 3058,3064 ----
      {
  	hFind = FindFirstFileW(wn, &findDataW);
  	vim_free(wn);
! 	if (hFind != INVALID_HANDLE_VALUE)
  	{
  	    fileFlags = findDataW.dwFileAttributes;
  	    reparseTag = findDataW.dwReserved0;
***************
*** 3321,3327 ****
      {
  	wn = enc_to_utf16(fname, NULL);
  	if (wn == NULL)
! 	    res = FILEINFO_ENC_FAIL;
      }
      if (wn != NULL)
      {
--- 3117,3123 ----
      {
  	wn = enc_to_utf16(fname, NULL);
  	if (wn == NULL)
! 	    return FILEINFO_ENC_FAIL;
      }
      if (wn != NULL)
      {
***************
*** 3332,3346 ****
  		    OPEN_EXISTING,	/* creation disposition */
  		    FILE_FLAG_BACKUP_SEMANTICS,	/* file attributes */
  		    NULL);		/* handle to template file */
! 	if (hFile == INVALID_HANDLE_VALUE
! 			      && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
! 	{
! 	    /* Retry with non-wide function (for Windows 98). */
! 	    vim_free(wn);
! 	    wn = NULL;
! 	}
      }
!     if (wn == NULL)
  #endif
  	hFile = CreateFile((LPCSTR)fname,    /* file name */
  		    GENERIC_READ,	    /* access mode */
--- 3128,3136 ----
  		    OPEN_EXISTING,	/* creation disposition */
  		    FILE_FLAG_BACKUP_SEMANTICS,	/* file attributes */
  		    NULL);		/* handle to template file */
! 	vim_free(wn);
      }
!     else
  #endif
  	hFile = CreateFile((LPCSTR)fname,    /* file name */
  		    GENERIC_READ,	    /* access mode */
***************
*** 3359,3367 ****
  	CloseHandle(hFile);
      }
  
- #ifdef FEAT_MBYTE
-     vim_free(wn);
- #endif
      return res;
  }
  
--- 3149,3154 ----
***************
*** 3383,3401 ****
      if (p != NULL)
      {
  	attr = GetFileAttributesW(p);
! 	if (attr < 0 && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
! 	{
! 	    /* Retry with non-wide function (for Windows 98). */
! 	    vim_free(p);
! 	    p = NULL;
! 	}
      }
!     if (p == NULL)
  #endif
  	attr = GetFileAttributes((char *)name);
! #ifdef FEAT_MBYTE
!     vim_free(p);
! #endif
      return attr;
  }
  
--- 3170,3181 ----
      if (p != NULL)
      {
  	attr = GetFileAttributesW(p);
! 	vim_free(p);
      }
!     else
  #endif
  	attr = GetFileAttributes((char *)name);
! 
      return attr;
  }
  
***************
*** 3418,3437 ****
      if (p != NULL)
      {
  	res = SetFileAttributesW(p, attrs);
! 	if (res == FALSE
! 	    && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
! 	{
! 	    /* Retry with non-wide function (for Windows 98). */
! 	    vim_free(p);
! 	    p = NULL;
! 	}
      }
!     if (p == NULL)
  #endif
  	res = SetFileAttributes((char *)name, attrs);
! #ifdef FEAT_MBYTE
!     vim_free(p);
! #endif
      return res ? 0 : -1;
  }
  
--- 3198,3209 ----
      if (p != NULL)
      {
  	res = SetFileAttributesW(p, attrs);
! 	vim_free(p);
      }
!     else
  #endif
  	res = SetFileAttributes((char *)name, attrs);
! 
      return res ? 0 : -1;
  }
  
***************
*** 3539,3565 ****
  
  #ifdef FEAT_MBYTE
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
-     {
  	wn = enc_to_utf16(name, NULL);
! 	if (wn != NULL)
! 	{
! 	    hFile = CreateFileW(wn,	/* file name */
! 			GENERIC_WRITE,	/* access mode */
! 			0,		/* share mode */
! 			NULL,		/* security descriptor */
! 			OPEN_EXISTING,	/* creation disposition */
! 			0,		/* file attributes */
! 			NULL);		/* handle to template file */
! 	    if (hFile == INVALID_HANDLE_VALUE
! 			      && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
! 	    {
! 		/* Retry with non-wide function (for Windows 98). */
! 		vim_free(wn);
! 		wn = NULL;
! 	    }
! 	}
      }
!     if (wn == NULL)
  #endif
  	hFile = CreateFile((LPCSTR)name,    /* file name */
  		    GENERIC_WRITE,	    /* access mode */
--- 3311,3330 ----
  
  #ifdef FEAT_MBYTE
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	wn = enc_to_utf16(name, NULL);
! 
!     if (wn != NULL)
!     {
! 	hFile = CreateFileW(wn,		    /* file name */
! 		    GENERIC_WRITE,	    /* access mode */
! 		    0,			    /* share mode */
! 		    NULL,		    /* security descriptor */
! 		    OPEN_EXISTING,	    /* creation disposition */
! 		    0,			    /* file attributes */
! 		    NULL);		    /* handle to template file */
! 	vim_free(wn);
      }
!     else
  #endif
  	hFile = CreateFile((LPCSTR)name,    /* file name */
  		    GENERIC_WRITE,	    /* access mode */
***************
*** 3569,3577 ****
  		    0,			    /* file attributes */
  		    NULL);		    /* handle to template file */
  
- #ifdef FEAT_MBYTE
-     vim_free(wn);
- #endif
      if (hFile == INVALID_HANDLE_VALUE)
  	return NODE_NORMAL;
  
--- 3334,3339 ----
***************
*** 3608,3695 ****
      struct my_acl   *p = NULL;
      DWORD   err;
  
!     /* This only works on Windows NT and 2000. */
!     if (g_PlatformId == VER_PLATFORM_WIN32_NT && advapi_lib != NULL)
      {
- 	p = (struct my_acl *)alloc_clear((unsigned)sizeof(struct my_acl));
- 	if (p != NULL)
- 	{
  # ifdef FEAT_MBYTE
! 	    WCHAR	*wn = NULL;
  
! 	    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
! 		wn = enc_to_utf16(fname, NULL);
! 	    if (wn != NULL)
  	    {
! 		/* Try to retrieve the entire security descriptor. */
! 		err = pGetNamedSecurityInfoW(
! 			    wn,			// Abstract filename
! 			    SE_FILE_OBJECT,	// File Object
! 			    OWNER_SECURITY_INFORMATION |
! 			    GROUP_SECURITY_INFORMATION |
! 			    DACL_SECURITY_INFORMATION |
! 			    SACL_SECURITY_INFORMATION,
! 			    &p->pSidOwner,	// Ownership information.
! 			    &p->pSidGroup,	// Group membership.
! 			    &p->pDacl,		// Discretionary information.
! 			    &p->pSacl,		// For auditing purposes.
! 			    &p->pSecurityDescriptor);
! 		if (err == ERROR_ACCESS_DENIED ||
! 			err == ERROR_PRIVILEGE_NOT_HELD)
! 		{
! 		    /* Retrieve only DACL. */
! 		    (void)pGetNamedSecurityInfoW(
! 			    wn,
! 			    SE_FILE_OBJECT,
! 			    DACL_SECURITY_INFORMATION,
! 			    NULL,
! 			    NULL,
! 			    &p->pDacl,
! 			    NULL,
! 			    &p->pSecurityDescriptor);
! 		}
! 		if (p->pSecurityDescriptor == NULL)
! 		{
! 		    mch_free_acl((vim_acl_T)p);
! 		    p = NULL;
! 		}
! 		vim_free(wn);
  	    }
! 	    else
  # endif
  	    {
! 		/* Try to retrieve the entire security descriptor. */
! 		err = pGetNamedSecurityInfo(
! 			    (LPSTR)fname,	// Abstract filename
! 			    SE_FILE_OBJECT,	// File Object
! 			    OWNER_SECURITY_INFORMATION |
! 			    GROUP_SECURITY_INFORMATION |
! 			    DACL_SECURITY_INFORMATION |
! 			    SACL_SECURITY_INFORMATION,
! 			    &p->pSidOwner,	// Ownership information.
! 			    &p->pSidGroup,	// Group membership.
! 			    &p->pDacl,		// Discretionary information.
! 			    &p->pSacl,		// For auditing purposes.
! 			    &p->pSecurityDescriptor);
! 		if (err == ERROR_ACCESS_DENIED ||
! 			err == ERROR_PRIVILEGE_NOT_HELD)
! 		{
! 		    /* Retrieve only DACL. */
! 		    (void)pGetNamedSecurityInfo(
! 			    (LPSTR)fname,
! 			    SE_FILE_OBJECT,
! 			    DACL_SECURITY_INFORMATION,
! 			    NULL,
! 			    NULL,
! 			    &p->pDacl,
! 			    NULL,
! 			    &p->pSecurityDescriptor);
! 		}
! 		if (p->pSecurityDescriptor == NULL)
! 		{
! 		    mch_free_acl((vim_acl_T)p);
! 		    p = NULL;
! 		}
  	    }
  	}
      }
--- 3370,3453 ----
      struct my_acl   *p = NULL;
      DWORD   err;
  
!     p = (struct my_acl *)alloc_clear((unsigned)sizeof(struct my_acl));
!     if (p != NULL)
      {
  # ifdef FEAT_MBYTE
! 	WCHAR	*wn = NULL;
  
! 	if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
! 	    wn = enc_to_utf16(fname, NULL);
! 	if (wn != NULL)
! 	{
! 	    /* Try to retrieve the entire security descriptor. */
! 	    err = GetNamedSecurityInfoW(
! 		    wn,			// Abstract filename
! 		    SE_FILE_OBJECT,	// File Object
! 		    OWNER_SECURITY_INFORMATION |
! 		    GROUP_SECURITY_INFORMATION |
! 		    DACL_SECURITY_INFORMATION |
! 		    SACL_SECURITY_INFORMATION,
! 		    &p->pSidOwner,	// Ownership information.
! 		    &p->pSidGroup,	// Group membership.
! 		    &p->pDacl,		// Discretionary information.
! 		    &p->pSacl,		// For auditing purposes.
! 		    &p->pSecurityDescriptor);
! 	    if (err == ERROR_ACCESS_DENIED ||
! 		    err == ERROR_PRIVILEGE_NOT_HELD)
! 	    {
! 		/* Retrieve only DACL. */
! 		(void)GetNamedSecurityInfoW(
! 			wn,
! 			SE_FILE_OBJECT,
! 			DACL_SECURITY_INFORMATION,
! 			NULL,
! 			NULL,
! 			&p->pDacl,
! 			NULL,
! 			&p->pSecurityDescriptor);
! 	    }
! 	    if (p->pSecurityDescriptor == NULL)
  	    {
! 		mch_free_acl((vim_acl_T)p);
! 		p = NULL;
  	    }
! 	    vim_free(wn);
! 	}
! 	else
  # endif
+ 	{
+ 	    /* Try to retrieve the entire security descriptor. */
+ 	    err = GetNamedSecurityInfo(
+ 		    (LPSTR)fname,	// Abstract filename
+ 		    SE_FILE_OBJECT,	// File Object
+ 		    OWNER_SECURITY_INFORMATION |
+ 		    GROUP_SECURITY_INFORMATION |
+ 		    DACL_SECURITY_INFORMATION |
+ 		    SACL_SECURITY_INFORMATION,
+ 		    &p->pSidOwner,	// Ownership information.
+ 		    &p->pSidGroup,	// Group membership.
+ 		    &p->pDacl,		// Discretionary information.
+ 		    &p->pSacl,		// For auditing purposes.
+ 		    &p->pSecurityDescriptor);
+ 	    if (err == ERROR_ACCESS_DENIED ||
+ 		    err == ERROR_PRIVILEGE_NOT_HELD)
+ 	    {
+ 		/* Retrieve only DACL. */
+ 		(void)GetNamedSecurityInfo(
+ 			(LPSTR)fname,
+ 			SE_FILE_OBJECT,
+ 			DACL_SECURITY_INFORMATION,
+ 			NULL,
+ 			NULL,
+ 			&p->pDacl,
+ 			NULL,
+ 			&p->pSecurityDescriptor);
+ 	    }
+ 	    if (p->pSecurityDescriptor == NULL)
  	    {
! 		mch_free_acl((vim_acl_T)p);
! 		p = NULL;
  	    }
  	}
      }
***************
*** 3733,3739 ****
      struct my_acl   *p = (struct my_acl *)acl;
      SECURITY_INFORMATION    sec_info = 0;
  
!     if (p != NULL && advapi_lib != NULL)
      {
  # ifdef FEAT_MBYTE
  	WCHAR	*wn = NULL;
--- 3491,3497 ----
      struct my_acl   *p = (struct my_acl *)acl;
      SECURITY_INFORMATION    sec_info = 0;
  
!     if (p != NULL)
      {
  # ifdef FEAT_MBYTE
  	WCHAR	*wn = NULL;
***************
*** 3761,3767 ****
  	    wn = enc_to_utf16(fname, NULL);
  	if (wn != NULL)
  	{
! 	    (void)pSetNamedSecurityInfoW(
  			wn,			// Abstract filename
  			SE_FILE_OBJECT,		// File Object
  			sec_info,
--- 3519,3525 ----
  	    wn = enc_to_utf16(fname, NULL);
  	if (wn != NULL)
  	{
! 	    (void)SetNamedSecurityInfoW(
  			wn,			// Abstract filename
  			SE_FILE_OBJECT,		// File Object
  			sec_info,
***************
*** 3775,3781 ****
  	else
  # endif
  	{
! 	    (void)pSetNamedSecurityInfo(
  			(LPSTR)fname,		// Abstract filename
  			SE_FILE_OBJECT,		// File Object
  			sec_info,
--- 3533,3539 ----
  	else
  # endif
  	{
! 	    (void)SetNamedSecurityInfo(
  			(LPSTR)fname,		// Abstract filename
  			SE_FILE_OBJECT,		// File Object
  			sec_info,
***************
*** 4076,4082 ****
      STARTUPINFO		*si,
      PROCESS_INFORMATION *pi)
  {
! #  ifdef FEAT_MBYTE
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
  	WCHAR	*wcmd = enc_to_utf16((char_u *)cmd, NULL);
--- 3834,3840 ----
      STARTUPINFO		*si,
      PROCESS_INFORMATION *pi)
  {
! #ifdef FEAT_MBYTE
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
  	WCHAR	*wcmd = enc_to_utf16((char_u *)cmd, NULL);
***************
*** 4138,4168 ****
      si.lpTitle = NULL;
      si.dwFlags = STARTF_USESHOWWINDOW;
      /*
!      * It's nicer to run a filter command in a minimized window, but in
!      * Windows 95 this makes the command MUCH slower.  We can't do it under
!      * Win32s either as it stops the synchronous spawn workaround working.
       * Don't activate the window to keep focus on Vim.
       */
!     if ((options & SHELL_DOOUT) && !mch_windows95())
  	si.wShowWindow = SW_SHOWMINNOACTIVE;
      else
  	si.wShowWindow = SW_SHOWNORMAL;
      si.cbReserved2 = 0;
      si.lpReserved2 = NULL;
  
-     /* There is a strange error on Windows 95 when using "c:\command.com".
-      * When the "c:\\" is left out it works OK...? */
-     if (mch_windows95()
- 	    && (STRNICMP(cmd, "c:/command.com", 14) == 0
- 		|| STRNICMP(cmd, "c:\\command.com", 14) == 0))
- 	cmd += 3;
- 
      /* Now, run the command */
      vim_create_process(cmd, FALSE,
  	    CREATE_DEFAULT_ERROR_MODE |	CREATE_NEW_CONSOLE, &si, &pi);
  
      /* Wait for the command to terminate before continuing */
-     if (g_PlatformId != VER_PLATFORM_WIN32s)
      {
  #ifdef FEAT_GUI
  	int	    delay = 1;
--- 3896,3916 ----
      si.lpTitle = NULL;
      si.dwFlags = STARTF_USESHOWWINDOW;
      /*
!      * It's nicer to run a filter command in a minimized window.
       * Don't activate the window to keep focus on Vim.
       */
!     if (options & SHELL_DOOUT)
  	si.wShowWindow = SW_SHOWMINNOACTIVE;
      else
  	si.wShowWindow = SW_SHOWNORMAL;
      si.cbReserved2 = 0;
      si.lpReserved2 = NULL;
  
      /* Now, run the command */
      vim_create_process(cmd, FALSE,
  	    CREATE_DEFAULT_ERROR_MODE |	CREATE_NEW_CONSOLE, &si, &pi);
  
      /* Wait for the command to terminate before continuing */
      {
  #ifdef FEAT_GUI
  	int	    delay = 1;
***************
*** 4195,4217 ****
  	/* Get the command exit code */
  	GetExitCodeProcess(pi.hProcess, &ret);
      }
-     else
-     {
- 	/*
- 	 * This ugly code is the only quick way of performing
- 	 * a synchronous spawn under Win32s. Yuk.
- 	 */
- 	num_windows = 0;
- 	EnumWindows(win32ssynch_cb, 0);
- 	old_num_windows = num_windows;
- 	do
- 	{
- 	    Sleep(1000);
- 	    num_windows = 0;
- 	    EnumWindows(win32ssynch_cb, 0);
- 	} while (num_windows == old_num_windows);
- 	ret = 0;
-     }
  
      /* Close the handles to the subprocess, so that it goes away */
      CloseHandle(pi.hThread);
--- 3943,3948 ----
***************
*** 4453,4463 ****
  
      if ( ! CreatePipe(&g_hChildStd_OUT_Rd, &g_hChildStd_OUT_Wr, &saAttr, 0)
  	/* Ensure the read handle to the pipe for STDOUT is not inherited. */
!        || ! pSetHandleInformation(g_hChildStd_OUT_Rd, HANDLE_FLAG_INHERIT, 0)
  	/* Create a pipe for the child process's STDIN. */
         || ! CreatePipe(&g_hChildStd_IN_Rd, &g_hChildStd_IN_Wr, &saAttr, 0)
  	/* Ensure the write handle to the pipe for STDIN is not inherited. */
!        || ! pSetHandleInformation(g_hChildStd_IN_Wr, HANDLE_FLAG_INHERIT, 0) )
      {
  	CloseHandle(g_hChildStd_IN_Rd);
  	CloseHandle(g_hChildStd_IN_Wr);
--- 4184,4194 ----
  
      if ( ! CreatePipe(&g_hChildStd_OUT_Rd, &g_hChildStd_OUT_Wr, &saAttr, 0)
  	/* Ensure the read handle to the pipe for STDOUT is not inherited. */
!        || ! SetHandleInformation(g_hChildStd_OUT_Rd, HANDLE_FLAG_INHERIT, 0)
  	/* Create a pipe for the child process's STDIN. */
         || ! CreatePipe(&g_hChildStd_IN_Rd, &g_hChildStd_IN_Wr, &saAttr, 0)
  	/* Ensure the write handle to the pipe for STDIN is not inherited. */
!        || ! SetHandleInformation(g_hChildStd_IN_Wr, HANDLE_FLAG_INHERIT, 0) )
      {
  	CloseHandle(g_hChildStd_IN_Rd);
  	CloseHandle(g_hChildStd_IN_Wr);
***************
*** 4707,4713 ****
  mch_system(char *cmd, int options)
  {
      /* if we can pipe and the shelltemp option is off */
!     if (allowPiping && !p_stmp)
  	return mch_system_piped(cmd, options);
      else
  	return mch_system_classic(cmd, options);
--- 4438,4444 ----
  mch_system(char *cmd, int options)
  {
      /* if we can pipe and the shelltemp option is off */
!     if (!p_stmp)
  	return mch_system_piped(cmd, options);
      else
  	return mch_system_classic(cmd, options);
***************
*** 4960,4966 ****
  	{
  	    cmdlen = (
  #ifdef FEAT_GUI_W32
! 		(allowPiping && !p_stmp ? 0 : STRLEN(vimrun_path)) +
  #endif
  		STRLEN(p_sh) + STRLEN(p_shcf) + STRLEN(cmd) + 10);
  
--- 4691,4697 ----
  	{
  	    cmdlen = (
  #ifdef FEAT_GUI_W32
! 		(!p_stmp ? 0 : STRLEN(vimrun_path)) +
  #endif
  		STRLEN(p_sh) + STRLEN(p_shcf) + STRLEN(cmd) + 10);
  
***************
*** 4978,4984 ****
  			    MB_ICONWARNING);
  		    need_vimrun_warning = FALSE;
  		}
! 		if (!s_dont_use_vimrun && (!allowPiping || p_stmp))
  		    /* Use vimrun to execute the command.  It opens a console
  		     * window, which can be closed without killing Vim. */
  		    vim_snprintf((char *)newcmd, cmdlen, "%s%s%s %s %s",
--- 4709,4715 ----
  			    MB_ICONWARNING);
  		    need_vimrun_warning = FALSE;
  		}
! 		if (!s_dont_use_vimrun && p_stmp)
  		    /* Use vimrun to execute the command.  It opens a console
  		     * window, which can be closed without killing Vim. */
  		    vim_snprintf((char *)newcmd, cmdlen, "%s%s%s %s %s",
***************
*** 5002,5009 ****
      /* Print the return value, unless "vimrun" was used. */
      if (x != 0 && !(options & SHELL_SILENT) && !emsg_silent
  #if defined(FEAT_GUI_W32)
! 		&& ((options & SHELL_DOOUT) || s_dont_use_vimrun
! 						  || (allowPiping && !p_stmp))
  #endif
  	    )
      {
--- 4733,4739 ----
      /* Print the return value, unless "vimrun" was used. */
      if (x != 0 && !(options & SHELL_SILENT) && !emsg_silent
  #if defined(FEAT_GUI_W32)
! 		&& ((options & SHELL_DOOUT) || s_dont_use_vimrun || !p_stmp)
  #endif
  	    )
      {
***************
*** 5051,5064 ****
                       lpSecurityAttributes, dwCreationDisposition,
                       dwFlagsAndAttributes, NULL);
              vim_free(wn);
-             if (h == INVALID_HANDLE_VALUE
-                           && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
-                 wn = NULL;
          }
      }
      if (wn == NULL)
  # endif
- 
          h = CreateFile((LPCSTR)fname, dwDesiredAccess, dwShareMode,
                       lpSecurityAttributes, dwCreationDisposition,
                       dwFlagsAndAttributes, NULL);
--- 4781,4790 ----
***************
*** 5127,5133 ****
      }
      else if (!use_null_for_in &&
  	    (!CreatePipe(&ifd[0], &ifd[1], &saAttr, 0)
! 	    || !pSetHandleInformation(ifd[1], HANDLE_FLAG_INHERIT, 0)))
  	goto failed;
  
      if (use_file_for_out)
--- 4853,4859 ----
      }
      else if (!use_null_for_in &&
  	    (!CreatePipe(&ifd[0], &ifd[1], &saAttr, 0)
! 	    || !SetHandleInformation(ifd[1], HANDLE_FLAG_INHERIT, 0)))
  	goto failed;
  
      if (use_file_for_out)
***************
*** 5145,5151 ****
      }
      else if (!use_null_for_out &&
  	    (!CreatePipe(&ofd[0], &ofd[1], &saAttr, 0)
! 	    || !pSetHandleInformation(ofd[0], HANDLE_FLAG_INHERIT, 0)))
  	goto failed;
  
      if (use_file_for_err)
--- 4871,4877 ----
      }
      else if (!use_null_for_out &&
  	    (!CreatePipe(&ofd[0], &ofd[1], &saAttr, 0)
! 	    || !SetHandleInformation(ofd[0], HANDLE_FLAG_INHERIT, 0)))
  	goto failed;
  
      if (use_file_for_err)
***************
*** 5163,5169 ****
      }
      else if (!use_out_for_err && !use_null_for_err &&
  	    (!CreatePipe(&efd[0], &efd[1], &saAttr, 0)
! 	    || !pSetHandleInformation(efd[0], HANDLE_FLAG_INHERIT, 0)))
  	goto failed;
  
      si.dwFlags |= STARTF_USESTDHANDLES;
--- 4889,4895 ----
      }
      else if (!use_out_for_err && !use_null_for_err &&
  	    (!CreatePipe(&efd[0], &efd[1], &saAttr, 0)
! 	    || !SetHandleInformation(efd[0], HANDLE_FLAG_INHERIT, 0)))
  	goto failed;
  
      si.dwFlags |= STARTF_USESTDHANDLES;
***************
*** 6176,6184 ****
  	{
  	    n = DeleteFileW(wn) ? 0 : -1;
  	    vim_free(wn);
! 	    if (n == 0 || GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
! 		return n;
! 	    /* Retry with non-wide function (for Windows 98). */
  	}
      }
  #endif
--- 5902,5908 ----
  	{
  	    n = DeleteFileW(wn) ? 0 : -1;
  	    vim_free(wn);
! 	    return n;
  	}
      }
  #endif
***************
*** 6203,6209 ****
  
  /* physical RAM to leave for the OS */
  #define WINNT_RESERVE_BYTES     (256*1024*1024)
- #define WIN95_RESERVE_BYTES       (8*1024*1024)
  
  /*
   * How much main memory in KiB that can be used by VIM.
--- 5927,5932 ----
***************
*** 6212,6265 ****
      long_u
  mch_total_mem(int special)
  {
!     PlatformId();
! #if (defined(_MSC_VER) && (WINVER > 0x0400)) || defined(MEMORYSTATUSEX)
!     if (g_PlatformId == VER_PLATFORM_WIN32_NT)
!     {
! 	MEMORYSTATUSEX  ms;
  
! 	/* Need to use GlobalMemoryStatusEx() when there is more memory than
! 	 * what fits in 32 bits. But it's not always available. */
! 	ms.dwLength = sizeof(MEMORYSTATUSEX);
! 	GlobalMemoryStatusEx(&ms);
! 	if (ms.ullAvailVirtual < ms.ullTotalPhys)
! 	{
! 	    /* Process address space fits in physical RAM, use all of it. */
! 	    return (long_u)(ms.ullAvailVirtual / 1024);
! 	}
! 	if (ms.ullTotalPhys <= WINNT_RESERVE_BYTES)
! 	{
! 	    /* Catch old NT box or perverse hardware setup. */
! 	    return (long_u)((ms.ullTotalPhys / 2) / 1024);
! 	}
! 	/* Use physical RAM less reserve for OS + data. */
! 	return (long_u)((ms.ullTotalPhys - WINNT_RESERVE_BYTES) / 1024);
      }
!     else
! #endif
      {
! 	/* Pre-XP or 95 OS handling. */
! 	MEMORYSTATUS    ms;
! 	long_u		os_reserve_bytes;
! 
! 	ms.dwLength = sizeof(MEMORYSTATUS);
! 	GlobalMemoryStatus(&ms);
! 	if (ms.dwAvailVirtual < ms.dwTotalPhys)
! 	{
! 	    /* Process address space fits in physical RAM, use all of it. */
! 	    return (long_u)(ms.dwAvailVirtual / 1024);
! 	}
! 	os_reserve_bytes = (g_PlatformId == VER_PLATFORM_WIN32_NT)
! 	    ? WINNT_RESERVE_BYTES
! 	    : WIN95_RESERVE_BYTES;
! 	if (ms.dwTotalPhys <= os_reserve_bytes)
! 	{
! 	    /* Catch old boxes or perverse hardware setup. */
! 	    return (long_u)((ms.dwTotalPhys / 2) / 1024);
! 	}
! 	/* Use physical RAM less reserve for OS + data. */
! 	return (long_u)((ms.dwTotalPhys - os_reserve_bytes) / 1024);
      }
  }
  
  #ifdef FEAT_MBYTE
--- 5935,5959 ----
      long_u
  mch_total_mem(int special)
  {
!     MEMORYSTATUSEX  ms;
  
!     PlatformId();
!     /* Need to use GlobalMemoryStatusEx() when there is more memory than
!      * what fits in 32 bits. But it's not always available. */
!     ms.dwLength = sizeof(MEMORYSTATUSEX);
!     GlobalMemoryStatusEx(&ms);
!     if (ms.ullAvailVirtual < ms.ullTotalPhys)
!     {
! 	/* Process address space fits in physical RAM, use all of it. */
! 	return (long_u)(ms.ullAvailVirtual / 1024);
      }
!     if (ms.ullTotalPhys <= WINNT_RESERVE_BYTES)
      {
! 	/* Catch old NT box or perverse hardware setup. */
! 	return (long_u)((ms.ullTotalPhys / 2) / 1024);
      }
+     /* Use physical RAM less reserve for OS + data. */
+     return (long_u)((ms.ullTotalPhys - WINNT_RESERVE_BYTES) / 1024);
  }
  
  #ifdef FEAT_MBYTE
***************
*** 6276,6291 ****
      WCHAR	szNewPath[_MAX_PATH + 1];
      HANDLE	hf;
  
!     if (!mch_windows95())
!     {
! 	p = wold;
! 	for (i = 0; wold[i] != NUL; ++i)
! 	    if ((wold[i] == '/' || wold[i] == '\\' || wold[i] == ':')
! 		    && wold[i + 1] != 0)
! 		p = wold + i + 1;
! 	if ((int)(wold + i - p) < 8 || p[6] != '~')
! 	    return (MoveFileW(wold, wnew) == 0);
!     }
  
      if (GetFullPathNameW(wnew, _MAX_PATH, szNewPath, &p) == 0 || p == NULL)
  	return -1;
--- 5970,5982 ----
      WCHAR	szNewPath[_MAX_PATH + 1];
      HANDLE	hf;
  
!     p = wold;
!     for (i = 0; wold[i] != NUL; ++i)
! 	if ((wold[i] == '/' || wold[i] == '\\' || wold[i] == ':')
! 		&& wold[i + 1] != 0)
! 	    p = wold + i + 1;
!     if ((int)(wold + i - p) < 8 || p[6] != '~')
! 	return (MoveFileW(wold, wnew) == 0);
  
      if (GetFullPathNameW(wnew, _MAX_PATH, szNewPath, &p) == 0 || p == NULL)
  	return -1;
***************
*** 6363,6384 ****
  	    retval = mch_wrename(wold, wnew);
  	vim_free(wold);
  	vim_free(wnew);
! 	if (retval == 0 || GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
! 	    return retval;
! 	/* Retry with non-wide function (for Windows 98). */
      }
  #endif
  
      /*
!      * No need to play tricks if not running Windows 95, unless the file name
!      * contains a "~" as the seventh character.
       */
!     if (!mch_windows95())
!     {
! 	pszFilePart = (char *)gettail((char_u *)pszOldFile);
! 	if (STRLEN(pszFilePart) < 8 || pszFilePart[6] != '~')
! 	    return rename(pszOldFile, pszNewFile);
!     }
  
      /* Get base path of new file name.  Undocumented feature: If pszNewFile is
       * a directory, no error is returned and pszFilePart will be NULL. */
--- 6054,6070 ----
  	    retval = mch_wrename(wold, wnew);
  	vim_free(wold);
  	vim_free(wnew);
! 	return retval;
      }
  #endif
  
      /*
!      * No need to play tricks unless the file name contains a "~" as the
!      * seventh character.
       */
!     pszFilePart = (char *)gettail((char_u *)pszOldFile);
!     if (STRLEN(pszFilePart) < 8 || pszFilePart[6] != '~')
! 	return rename(pszOldFile, pszNewFile);
  
      /* Get base path of new file name.  Undocumented feature: If pszNewFile is
       * a directory, no error is returned and pszFilePart will be NULL. */
***************
*** 6441,6456 ****
      char *
  default_shell(void)
  {
-     char* psz = NULL;
- 
      PlatformId();
  
!     if (g_PlatformId == VER_PLATFORM_WIN32_NT)		/* Windows NT */
! 	psz = "cmd.exe";
!     else if (g_PlatformId == VER_PLATFORM_WIN32_WINDOWS) /* Windows 95 */
! 	psz = "command.com";
! 
!     return psz;
  }
  
  /*
--- 6127,6135 ----
      char *
  default_shell(void)
  {
      PlatformId();
  
!     return "cmd.exe";
  }
  
  /*
***************
*** 6496,6513 ****
  
  		hFile = FindFirstFileW(TempNameW, &d);
  		if (hFile == INVALID_HANDLE_VALUE)
! 		{
! 		    if (GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
! 			goto getout;
! 
! 		    /* Retry with non-wide function (for Windows 98). */
! 		    vim_free(wn);
! 		    wn = NULL;
! 		}
  		else
  		    (void)FindClose(hFile);
  	    }
! 	    if (wn == NULL)
  #endif
  	    {
  		char		    *pch;
--- 6175,6185 ----
  
  		hFile = FindFirstFileW(TempNameW, &d);
  		if (hFile == INVALID_HANDLE_VALUE)
! 		    goto getout;
  		else
  		    (void)FindClose(hFile);
  	    }
! 	    else
  #endif
  	    {
  		char		    *pch;
***************
*** 6537,6554 ****
  	    if (wn != NULL)
  	    {
  		if (!GetTempFileNameW(wn, L"VIM", 0, TempNameW))
! 		{
! 		    if (GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
! 			goto getout;
! 
! 		    /* Retry with non-wide function (for Windows 98). */
! 		    vim_free(wn);
! 		    wn = NULL;
! 		}
  		else
  		    DeleteFileW(TempNameW);
  	    }
! 	    if (wn == NULL)
  #endif
  	    {
  		if (!GetTempFileName(n, "VIM", 0, TempName))
--- 6209,6219 ----
  	    if (wn != NULL)
  	    {
  		if (!GetTempFileNameW(wn, L"VIM", 0, TempNameW))
! 		    goto getout;
  		else
  		    DeleteFileW(TempNameW);
  	    }
! 	    else
  #endif
  	    {
  		if (!GetTempFileName(n, "VIM", 0, TempName))
***************
*** 6565,6581 ****
  		| ((p & R_OK) ? GENERIC_READ : 0);
  #ifdef FEAT_MBYTE
  	if (wn != NULL)
- 	{
  	    hFile = CreateFileW(wn, am, 0, NULL, OPEN_EXISTING, 0, NULL);
! 	    if (hFile == INVALID_HANDLE_VALUE
! 			      && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
! 	    {
! 		/* Retry with non-wide function (for Windows 98). */
! 		vim_free(wn);
! 		wn = NULL;
! 	    }
! 	}
! 	if (wn == NULL)
  #endif
  	    hFile = CreateFile(n, am, 0, NULL, OPEN_EXISTING, 0, NULL);
  	if (hFile == INVALID_HANDLE_VALUE)
--- 6230,6237 ----
  		| ((p & R_OK) ? GENERIC_READ : 0);
  #ifdef FEAT_MBYTE
  	if (wn != NULL)
  	    hFile = CreateFileW(wn, am, 0, NULL, OPEN_EXISTING, 0, NULL);
! 	else
  #endif
  	    hFile = CreateFile(n, am, 0, NULL, OPEN_EXISTING, 0, NULL);
  	if (hFile == INVALID_HANDLE_VALUE)
***************
*** 6610,6620 ****
  	{
  	    f = _wopen(wn, flags, mode);
  	    vim_free(wn);
! 	    if (f >= 0 || g_PlatformId == VER_PLATFORM_WIN32_NT)
! 		return f;
! 	    /* Retry with non-wide function (for Windows 98). Can't use
! 	     * GetLastError() here and it's unclear what errno gets set to if
! 	     * the _wopen() fails for missing wide functions. */
  	}
      }
  # endif
--- 6266,6272 ----
  	{
  	    f = _wopen(wn, flags, mode);
  	    vim_free(wn);
! 	    return f;
  	}
      }
  # endif
***************
*** 6638,6649 ****
      WCHAR	*wn, *wm;
      FILE	*f = NULL;
  
!     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage
! # ifdef __BORLANDC__
! 	    /* Wide functions of Borland C 5.5 do not work on Windows 98. */
! 	    && g_PlatformId == VER_PLATFORM_WIN32_NT
! # endif
!        )
      {
  # if defined(DEBUG) && _MSC_VER >= 1400
  	/* Work around an annoying assertion in the Microsoft debug CRT
--- 6290,6296 ----
      WCHAR	*wn, *wm;
      FILE	*f = NULL;
  
!     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
  # if defined(DEBUG) && _MSC_VER >= 1400
  	/* Work around an annoying assertion in the Microsoft debug CRT
***************
*** 6667,6678 ****
  # if defined(DEBUG) && _MSC_VER >= 1400
  	_set_fmode(oldMode);
  # endif
! 
! 	if (f != NULL || g_PlatformId == VER_PLATFORM_WIN32_NT)
! 	    return f;
! 	/* Retry with non-wide function (for Windows 98). Can't use
! 	 * GetLastError() here and it's unclear what errno gets set to if
! 	 * the _wfopen() fails for missing wide functions. */
      }
  
      /* fopen() can open a file which name is longer than _MAX_PATH bytes
--- 6314,6320 ----
  # if defined(DEBUG) && _MSC_VER >= 1400
  	_set_fmode(oldMode);
  # endif
! 	return f;
      }
  
      /* fopen() can open a file which name is longer than _MAX_PATH bytes
***************
*** 6843,6850 ****
  #ifdef FEAT_MBYTE
      /* File streams only work on Windows NT and later. */
      PlatformId();
!     if (g_PlatformId == VER_PLATFORM_WIN32_NT)
! 	copy_infostreams(from, to);
  #endif
      return 0;
  }
--- 6485,6491 ----
  #ifdef FEAT_MBYTE
      /* File streams only work on Windows NT and later. */
      PlatformId();
!     copy_infostreams(from, to);
  #endif
      return 0;
  }
***************
*** 6856,6862 ****
   */
  
  /* These magic numbers are from the MS header files */
- #define MIN_STACK_WIN9X 17
  #define MIN_STACK_WINNT 2
  
  /*
--- 6497,6502 ----
***************
*** 6876,6885 ****
      DWORD	nPageSize;
      DWORD	dummy;
  
-     /* This code will not work on win32s. */
      PlatformId();
-     if (g_PlatformId == VER_PLATFORM_WIN32s)
- 	return 0;
  
      /* We need to know the system page size. */
      GetSystemInfo(&si);
--- 6516,6522 ----
***************
*** 6895,6923 ****
  
      /* ...and the page thats min_stack_req pages away from stack base; this is
       * the lowest page we could use. */
!     pLowestPossiblePage = pStackBase + ((g_PlatformId == VER_PLATFORM_WIN32_NT)
! 			     ? MIN_STACK_WINNT : MIN_STACK_WIN9X) * nPageSize;
  
-     /* On Win95, we want the next page down from the end of the stack. */
-     if (g_PlatformId == VER_PLATFORM_WIN32_WINDOWS)
      {
! 	/* Find the page that's only 1 page down from the page that the stack
! 	 * ptr is in. */
! 	pGuardPage = (BYTE*)((DWORD)nPageSize * (((DWORD)pStackPtr
! 						    / (DWORD)nPageSize) - 1));
! 	if (pGuardPage < pLowestPossiblePage)
! 	    return 0;
! 
! 	/* Apply the noaccess attribute to the page -- there's no guard
! 	 * attribute in win95-type OSes. */
! 	if (!VirtualProtect(pGuardPage, nPageSize, PAGE_NOACCESS, &dummy))
! 	    return 0;
!     }
!     else
!     {
! 	/* On NT, however, we want the first committed page in the stack Start
! 	 * at the stack base and move forward through memory until we find a
! 	 * committed block. */
  	BYTE *pBlock = pStackBase;
  
  	for (;;)
--- 6532,6543 ----
  
      /* ...and the page thats min_stack_req pages away from stack base; this is
       * the lowest page we could use. */
!     pLowestPossiblePage = pStackBase + MIN_STACK_WINNT * nPageSize;
  
      {
! 	/* We want the first committed page in the stack Start at the stack
! 	 * base and move forward through memory until we find a committed block.
! 	 */
  	BYTE *pBlock = pStackBase;
  
  	for (;;)
*** ../vim-8.0.0028/src/os_win32.h	2016-08-29 22:42:20.000000000 +0200
--- src/os_win32.h	2016-10-12 14:00:10.242811549 +0200
***************
*** 210,229 ****
  # define vim_mkdir(x, y) mch_mkdir(x)
  #endif
  
- #ifndef PROTO
- 
  /* Enable common dialogs input unicode from IME if possible. */
  #ifdef FEAT_MBYTE
!     /* The variables are defined in os_win32.c. */
! extern LRESULT (WINAPI *pDispatchMessage)(CONST MSG *);
! extern BOOL (WINAPI *pGetMessage)(LPMSG, HWND, UINT, UINT);
! extern BOOL (WINAPI *pIsDialogMessage)(HWND, LPMSG);
! extern BOOL (WINAPI *pPeekMessage)(LPMSG, HWND, UINT, UINT, UINT);
  #else
  # define pDispatchMessage DispatchMessage
  # define pGetMessage GetMessage
  # define pIsDialogMessage IsDialogMessage
  # define pPeekMessage PeekMessage
  #endif
- 
- #endif /* PROTO */
--- 210,224 ----
  # define vim_mkdir(x, y) mch_mkdir(x)
  #endif
  
  /* Enable common dialogs input unicode from IME if possible. */
  #ifdef FEAT_MBYTE
! # define pDispatchMessage DispatchMessageW
! # define pGetMessage GetMessageW
! # define pIsDialogMessage IsDialogMessageW
! # define pPeekMessage PeekMessageW
  #else
  # define pDispatchMessage DispatchMessage
  # define pGetMessage GetMessage
  # define pIsDialogMessage IsDialogMessage
  # define pPeekMessage PeekMessage
  #endif
*** ../vim-8.0.0028/src/proto/os_mswin.pro	2016-09-12 13:04:30.000000000 +0200
--- src/proto/os_mswin.pro	2016-10-12 14:00:10.242811549 +0200
***************
*** 19,25 ****
  int mch_has_exp_wildcard(char_u *p);
  int mch_has_wildcard(char_u *p);
  int mch_chdir(char *path);
- int can_end_termcap_mode(int give_msg);
  int mch_screenmode(char_u *arg);
  int mch_icon_load(HANDLE *iconp);
  int mch_libcall(char_u *libname, char_u *funcname, char_u *argstring, int argint, char_u **string_result, int *number_result);
--- 19,24 ----
*** ../vim-8.0.0028/src/proto/os_win32.pro	2016-09-29 15:18:51.359768012 +0200
--- src/proto/os_win32.pro	2016-10-12 14:00:10.242811549 +0200
***************
*** 3,9 ****
  int dyn_libintl_init(void);
  void dyn_libintl_end(void);
  void PlatformId(void);
- int mch_windows95(void);
  void mch_setmouse(int on);
  void mch_update_cursor(void);
  int mch_char_avail(void);
--- 3,8 ----
*** ../vim-8.0.0028/src/version.c	2016-10-12 12:13:30.488344697 +0200
--- src/version.c	2016-10-12 14:02:29.605820741 +0200
***************
*** 962,976 ****
      MSG(longVersion);
  #ifdef WIN3264
  # ifdef FEAT_GUI_W32
! #  if defined(_MSC_VER) && (_MSC_VER <= 1010)
!     /* Only MS VC 4.1 and earlier can do Win32s */
!     MSG_PUTS(_("\nMS-Windows 16/32-bit GUI version"));
! #  else
! #   ifdef _WIN64
      MSG_PUTS(_("\nMS-Windows 64-bit GUI version"));
! #   else
      MSG_PUTS(_("\nMS-Windows 32-bit GUI version"));
- #   endif
  #  endif
  # ifdef FEAT_OLE
      MSG_PUTS(_(" with OLE support"));
--- 964,973 ----
      MSG(longVersion);
  #ifdef WIN3264
  # ifdef FEAT_GUI_W32
! #  ifdef _WIN64
      MSG_PUTS(_("\nMS-Windows 64-bit GUI version"));
! #  else
      MSG_PUTS(_("\nMS-Windows 32-bit GUI version"));
  #  endif
  # ifdef FEAT_OLE
      MSG_PUTS(_(" with OLE support"));
***************
*** 1332,1341 ****
      blanklines = (int)Rows - ((sizeof(lines) / sizeof(char *)) - 1);
      if (!p_cp)
  	blanklines += 4;  /* add 4 for not showing "Vi compatible" message */
- #if defined(WIN3264) && !defined(FEAT_GUI_W32)
-     if (mch_windows95())
- 	blanklines -= 3;  /* subtract 3 for showing "Windows 95" message */
- #endif
  
  #ifdef FEAT_WINDOWS
      /* Don't overwrite a statusline.  Depends on 'cmdheight'. */
--- 1329,1334 ----
***************
*** 1384,1400 ****
  		do_intro_line(row, (char_u *)_(p), i == 2, 0);
  	    ++row;
  	}
- #if defined(WIN3264) && !defined(FEAT_GUI_W32)
- 	if (mch_windows95())
- 	{
- 	    do_intro_line(++row,
- 		    (char_u *)_("WARNING: Windows 95/98/ME detected"),
- 							FALSE, hl_attr(HLF_E));
- 	    do_intro_line(++row,
- 		(char_u *)_("type  :help windows95<Enter>  for info on this"),
- 								    FALSE, 0);
- 	}
- #endif
      }
  
      /* Make the wait-return message appear just below the text. */
--- 1377,1382 ----
*** ../vim-8.0.0028/src/version.c	2016-10-12 12:13:30.488344697 +0200
--- src/version.c	2016-10-12 14:02:29.605820741 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     29,
  /**/

-- 
Lose weight, NEVER Diet again with
                  The "Invisible Weight Loss Patch"
						(spam e-mail)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0030
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0030
Problem:    Mouse mode is not automatically detected for tmux.
Solution:   Check for 'term' to be "tmux". (Michael Henry)
Files:      src/os_unix.c


*** ../vim-8.0.0029/src/os_unix.c	2016-09-29 15:18:51.359768012 +0200
--- src/os_unix.c	2016-10-12 14:36:03.887453490 +0200
***************
*** 2261,2266 ****
--- 2261,2267 ----
      return (name != NULL
  	    && (term_is_xterm
  		|| STRNICMP(name, "screen", 6) == 0
+ 		|| STRNICMP(name, "tmux", 4) == 0
  		|| STRICMP(name, "st") == 0
  		|| STRNICMP(name, "st-", 3) == 0
  		|| STRNICMP(name, "stterm", 6) == 0));
***************
*** 2324,2329 ****
--- 2325,2331 ----
      return (   STRNICMP(name, "hpterm", 6) == 0
  	    || STRNICMP(name, "sun-cmd", 7) == 0
  	    || STRNICMP(name, "screen", 6) == 0
+ 	    || STRNICMP(name, "tmux", 4) == 0
  	    || STRNICMP(name, "dtterm", 6) == 0);
  }
  
*** ../vim-8.0.0029/src/version.c	2016-10-12 14:19:55.754357695 +0200
--- src/version.c	2016-10-12 14:50:38.049202893 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     30,
  /**/

-- 
Compilation process failed successfully.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0031
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0031
Problem:    After ":bwipeout" 'fileformat' is not set to the right default.
Solution:   Get the default from 'fileformats'. (Mike Williams)
Files:      src/option.c, src/Makefile, src/testdir/test_fileformat.vim,
            src/testdir/test_alot.vim


*** ../vim-8.0.0030/src/option.c	2016-10-12 14:19:55.750357722 +0200
--- src/option.c	2016-10-12 17:36:42.482477038 +0200
***************
*** 10729,10735 ****
  #ifdef FEAT_MBYTE
  		buf->b_p_fenc = vim_strsave(p_fenc);
  #endif
! 		buf->b_p_ff = vim_strsave(p_ff);
  #if defined(FEAT_QUICKFIX)
  		buf->b_p_bh = empty_option;
  		buf->b_p_bt = empty_option;
--- 10729,10747 ----
  #ifdef FEAT_MBYTE
  		buf->b_p_fenc = vim_strsave(p_fenc);
  #endif
! 		switch (*p_ffs)
! 		{
! 		    case 'm':
! 			buf->b_p_ff = vim_strsave((char_u *)FF_MAC); break;
! 		    case 'd':
! 			buf->b_p_ff = vim_strsave((char_u *)FF_DOS); break;
! 		    case 'u':
! 			buf->b_p_ff = vim_strsave((char_u *)FF_UNIX); break;
! 		    default:
! 			buf->b_p_ff = vim_strsave(p_ff);
! 		}
! 		if (buf->b_p_ff != NULL)
! 		    buf->b_start_ffc = *buf->b_p_ff;
  #if defined(FEAT_QUICKFIX)
  		buf->b_p_bh = empty_option;
  		buf->b_p_bt = empty_option;
*** ../vim-8.0.0030/src/Makefile	2016-09-29 20:54:42.399110777 +0200
--- src/Makefile	2016-10-12 16:24:51.984989904 +0200
***************
*** 2081,2086 ****
--- 2081,2087 ----
  	test_farsi \
  	test_feedkeys \
  	test_file_perm \
+ 	test_fileformat \
  	test_filter_cmd \
  	test_filter_map \
  	test_fnameescape \
*** ../vim-8.0.0030/src/testdir/test_fileformat.vim	2016-10-12 17:43:54.755416077 +0200
--- src/testdir/test_fileformat.vim	2016-10-12 16:29:46.522911119 +0200
***************
*** 0 ****
--- 1,17 ----
+ " Test behavior of fileformat after bwipeout of last buffer
+ 
+ func Test_fileformat_after_bw()
+   bwipeout
+   set fileformat&
+   if &fileformat == 'dos'
+     let test_fileformats = 'unix'
+   elseif &fileformat == 'unix'
+     let test_fileformats = 'mac'
+   else  " must be mac
+     let test_fileformats = 'dos'
+   endif
+   exec 'set fileformats='.test_fileformats
+   bwipeout!
+   call assert_equal(test_fileformats, &fileformat)
+   set fileformats&
+ endfunc
*** ../vim-8.0.0030/src/testdir/test_alot.vim	2016-09-29 20:54:42.403110749 +0200
--- src/testdir/test_alot.vim	2016-10-12 16:24:26.933166652 +0200
***************
*** 12,21 ****
  source test_expr.vim
  source test_expand_dllpath.vim
  source test_feedkeys.vim
- source test_fnamemodify.vim
  source test_file_perm.vim
  source test_filter_cmd.vim
  source test_filter_map.vim
  source test_glob2regpat.vim
  source test_goto.vim
  source test_help_tagjump.vim
--- 12,22 ----
  source test_expr.vim
  source test_expand_dllpath.vim
  source test_feedkeys.vim
  source test_file_perm.vim
+ source test_fileformat.vim
  source test_filter_cmd.vim
  source test_filter_map.vim
+ source test_fnamemodify.vim
  source test_glob2regpat.vim
  source test_goto.vim
  source test_help_tagjump.vim
*** ../vim-8.0.0030/src/version.c	2016-10-12 14:50:50.233115689 +0200
--- src/version.c	2016-10-12 16:27:46.415758987 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     31,
  /**/

-- 
   Arthur pulls Pin out.  The MONK blesses the grenade as ...
ARTHUR:  (quietly) One, two, five ...
GALAHAD: Three, sir!
ARTHUR:  Three.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0032
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0032
Problem:    Tests may change the input file when something goes wrong.
Solution:   Avoid writing the input file.
Files:      src/testdir/test51.in, src/testdir/test67.in,
            src/testdir/test97.in, src/testdir/test_tabpage.vim


*** ../vim-8.0.0031/src/testdir/test51.in	2012-11-15 22:30:32.000000000 +0100
--- src/testdir/test51.in	2016-10-12 16:53:02.513047817 +0200
***************
*** 24,30 ****
  :hi Crash term='asdf
  :redir END
  :" filter ctermfg and ctermbg, the numbers depend on the terminal
! :e test.out
  :%s/ctermfg=\d*/ctermfg=2/
  :%s/ctermbg=\d*/ctermbg=3/
  :" filter out possibly translated error message
--- 24,30 ----
  :hi Crash term='asdf
  :redir END
  :" filter ctermfg and ctermbg, the numbers depend on the terminal
! :e! test.out
  :%s/ctermfg=\d*/ctermfg=2/
  :%s/ctermbg=\d*/ctermbg=3/
  :" filter out possibly translated error message
*** ../vim-8.0.0031/src/testdir/test67.in	2012-11-15 22:30:49.000000000 +0100
--- src/testdir/test67.in	2016-10-12 16:54:27.692445533 +0200
***************
*** 24,30 ****
  :call add(results, "#BufEnter#<buffer>: " . exists("#BufEnter#<buffer>"))
  :edit testfile2.test
  :call add(results, "#BufEnter#<buffer>: " . exists("#BufEnter#<buffer>"))
! :e test.out
  :call append(0, results)
  :$d
  :w
--- 24,30 ----
  :call add(results, "#BufEnter#<buffer>: " . exists("#BufEnter#<buffer>"))
  :edit testfile2.test
  :call add(results, "#BufEnter#<buffer>: " . exists("#BufEnter#<buffer>"))
! :e! test.out
  :call append(0, results)
  :$d
  :w
*** ../vim-8.0.0031/src/testdir/test97.in	2014-05-08 11:42:37.000000000 +0200
--- src/testdir/test97.in	2016-10-12 16:55:32.683985962 +0200
***************
*** 7,13 ****
  :set shell=doesnotexist
  :" consistent sorting of file names
  :set nofileignorecase
! :e test.out
  :$put =glob('Xxx\{')
  :$put =glob('Xxx\$')
  :w! Xxx{
--- 7,13 ----
  :set shell=doesnotexist
  :" consistent sorting of file names
  :set nofileignorecase
! :e! test.out
  :$put =glob('Xxx\{')
  :$put =glob('Xxx\$')
  :w! Xxx{
*** ../vim-8.0.0031/src/testdir/test_tabpage.vim	2016-09-06 21:31:11.000000000 +0200
--- src/testdir/test_tabpage.vim	2016-09-29 20:07:58.098576056 +0200
***************
*** 11,16 ****
--- 11,17 ----
    0tabnew
    1tabnew
    $tabnew
+   %del
    tabdo call append(line('$'), tabpagenr())
    tabclose! 2
    tabrewind
*** ../vim-8.0.0031/src/version.c	2016-10-12 17:45:13.642857417 +0200
--- src/version.c	2016-10-12 17:51:56.632003323 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     32,
  /**/

-- 
ARTHUR:          What does it say?
BROTHER MAYNARD: It reads ... "Here may be found the last words of Joseph of
                 Aramathea." "He who is valorous and pure of heart may find
                 the Holy Grail in the aaaaarrrrrrggghhh..."
ARTHUR:          What?
BROTHER MAYNARD: "The Aaaaarrrrrrggghhh..."
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0033
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0033
Problem:    Cannot use overlapping positions with matchaddpos().
Solution:   Check end of match. (Ozaki Kiichi) Add a test (Hirohito Higashi)
Files:      src/screen.c, src/testdir/test_match.vim


*** ../vim-8.0.0032/src/screen.c	2016-10-02 23:09:27.643153731 +0200
--- src/screen.c	2016-10-15 14:52:51.297854046 +0200
***************
*** 7786,7806 ****
      shl->lnum = 0;
      for (i = posmatch->cur; i < MAXPOSMATCH; i++)
      {
! 	if (posmatch->pos[i].lnum == 0)
  	    break;
! 	if (posmatch->pos[i].col < mincol)
  	    continue;
! 	if (posmatch->pos[i].lnum == lnum)
  	{
  	    if (shl->lnum == lnum)
  	    {
  		/* partially sort positions by column numbers
  		 * on the same line */
! 		if (posmatch->pos[i].col < posmatch->pos[bot].col)
  		{
! 		    llpos_T	tmp = posmatch->pos[i];
  
! 		    posmatch->pos[i] = posmatch->pos[bot];
  		    posmatch->pos[bot] = tmp;
  		}
  	    }
--- 7786,7808 ----
      shl->lnum = 0;
      for (i = posmatch->cur; i < MAXPOSMATCH; i++)
      {
! 	llpos_T	*pos = &posmatch->pos[i];
! 
! 	if (pos->lnum == 0)
  	    break;
! 	if (pos->col + pos->len - 1 <= mincol)
  	    continue;
! 	if (pos->lnum == lnum)
  	{
  	    if (shl->lnum == lnum)
  	    {
  		/* partially sort positions by column numbers
  		 * on the same line */
! 		if (pos->col < posmatch->pos[bot].col)
  		{
! 		    llpos_T	tmp = *pos;
  
! 		    *pos = posmatch->pos[bot];
  		    posmatch->pos[bot] = tmp;
  		}
  	    }
*** ../vim-8.0.0032/src/testdir/test_match.vim	2016-08-27 18:28:13.000000000 +0200
--- src/testdir/test_match.vim	2016-10-15 14:50:58.442694482 +0200
***************
*** 181,186 ****
--- 181,196 ----
    redraw!
    call assert_equal(screenattr(2,2), screenattr(1,6))
  
+   " Check overlapping pos
+   call clearmatches()
+   call setline(1, ['1234567890', 'NH'])
+   call matchaddpos('Error', [[1,1,5], [1,3,5], [2,2]])
+   redraw!
+   call assert_notequal(screenattr(2,2), 0)
+   call assert_equal(screenattr(2,2), screenattr(1,5))
+   call assert_equal(screenattr(2,2), screenattr(1,7))
+   call assert_notequal(screenattr(2,2), screenattr(1,8))
+ 
    nohl
    syntax off
    set hlsearch&
*** ../vim-8.0.0032/src/version.c	2016-10-12 17:52:39.199701825 +0200
--- src/version.c	2016-10-15 14:54:57.816912413 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     33,
  /**/

-- 
Q: Why does /dev/null accept only integers?
A: You can't sink a float.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0034
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0034
Problem:    No completion for ":messages".
Solution:   Complete "clear" argument. (Hirohito Higashi)
Files:      src/ex_docmd.c, src/ex_getln.c, src/proto/ex_docmd.pro,
            src/testdir/test_cmdline.vim, src/vim.h,
            runtime/doc/eval.txt, runtime/doc/map.txt


*** ../vim-8.0.0033/src/ex_docmd.c	2016-10-12 14:19:55.742357780 +0200
--- src/ex_docmd.c	2016-10-15 15:22:09.672808290 +0200
***************
*** 4281,4286 ****
--- 4281,4291 ----
  	    xp->xp_pattern = arg;
  	    break;
  
+ 	case CMD_messages:
+ 	    xp->xp_context = EXPAND_MESSAGES;
+ 	    xp->xp_pattern = arg;
+ 	    break;
+ 
  #if defined(FEAT_CMDHIST)
  	case CMD_history:
  	    xp->xp_context = EXPAND_HISTORY;
***************
*** 5893,5898 ****
--- 5898,5904 ----
  #endif
      {EXPAND_MAPPINGS, "mapping"},
      {EXPAND_MENUS, "menu"},
+     {EXPAND_MESSAGES, "messages"},
      {EXPAND_OWNSYNTAX, "syntax"},
  #if defined(FEAT_PROFILE)
      {EXPAND_SYNTIME, "syntime"},
***************
*** 11901,11906 ****
--- 11907,11924 ----
  	return (char_u *)"xterm";
      return NULL;
  }
+ 
+ /*
+  * Function given to ExpandGeneric() to obtain the possible arguments of the
+  * ":messages {clear}" command.
+  */
+     char_u *
+ get_messages_arg(expand_T *xp UNUSED, int idx)
+ {
+     if (idx == 0)
+ 	return (char_u *)"clear";
+     return NULL;
+ }
  #endif
  
  #ifdef FEAT_AUTOCMD
*** ../vim-8.0.0033/src/ex_getln.c	2016-09-09 21:35:27.000000000 +0200
--- src/ex_getln.c	2016-10-15 15:22:09.672808290 +0200
***************
*** 4832,4837 ****
--- 4832,4838 ----
  	{
  	    {EXPAND_COMMANDS, get_command_name, FALSE, TRUE},
  	    {EXPAND_BEHAVE, get_behave_arg, TRUE, TRUE},
+ 	    {EXPAND_MESSAGES, get_messages_arg, TRUE, TRUE},
  #ifdef FEAT_CMDHIST
  	    {EXPAND_HISTORY, get_history_arg, TRUE, TRUE},
  #endif
*** ../vim-8.0.0033/src/proto/ex_docmd.pro	2016-09-12 13:04:02.000000000 +0200
--- src/proto/ex_docmd.pro	2016-10-15 15:22:09.672808290 +0200
***************
*** 61,64 ****
--- 61,65 ----
  int put_line(FILE *fd, char *s);
  void dialog_msg(char_u *buff, char *format, char_u *fname);
  char_u *get_behave_arg(expand_T *xp, int idx);
+ char_u *get_messages_arg(expand_T *xp, int idx);
  /* vim: set ft=c : */
*** ../vim-8.0.0033/src/testdir/test_cmdline.vim	2016-08-28 13:34:01.000000000 +0200
--- src/testdir/test_cmdline.vim	2016-10-15 15:22:09.672808290 +0200
***************
*** 129,134 ****
--- 129,139 ----
    let l = getcompletion('dark', 'highlight')
    call assert_equal([], l)
  
+   let l = getcompletion('', 'messages')
+   call assert_true(index(l, 'clear') >= 0)
+   let l = getcompletion('not', 'messages')
+   call assert_equal([], l)
+ 
    if has('cscope')
      let l = getcompletion('', 'cscope')
      let cmds = ['add', 'find', 'help', 'kill', 'reset', 'show']
*** ../vim-8.0.0033/src/vim.h	2016-09-04 21:27:13.000000000 +0200
--- src/vim.h	2016-10-15 15:22:09.672808290 +0200
***************
*** 793,798 ****
--- 793,799 ----
  #define EXPAND_SYNTIME		43
  #define EXPAND_USER_ADDR_TYPE	44
  #define EXPAND_PACKADD		45
+ #define EXPAND_MESSAGES		46
  
  /* Values for exmode_active (0 is no exmode) */
  #define EXMODE_NORMAL		1
*** ../vim-8.0.0033/runtime/doc/eval.txt	2016-10-02 16:51:32.748592858 +0200
--- runtime/doc/eval.txt	2016-10-15 15:24:39.175697407 +0200
***************
*** 4281,4287 ****
--- 4287,4295 ----
  		locale		locale names (as output of locale -a)
  		mapping		mapping name
  		menu		menus
+ 		messages	|:messages| suboptions
  		option		options
+ 		packadd		optional package |pack-add| names
  		shellcmd	Shell command
  		sign		|:sign| suboptions
  		syntax		syntax file names |'syntax'|
*** ../vim-8.0.0033/runtime/doc/map.txt	2016-09-12 12:45:26.000000000 +0200
--- runtime/doc/map.txt	2016-10-15 15:24:55.571575607 +0200
***************
*** 1280,1285 ****
--- 1280,1286 ----
  	-complete=locale	locale names (as output of locale -a)
  	-complete=mapping	mapping name
  	-complete=menu		menus
+ 	-complete=messages	|:messages| suboptions
  	-complete=option	options
  	-complete=packadd	optional package |pack-add| names
  	-complete=shellcmd	Shell command
*** ../vim-8.0.0033/src/version.c	2016-10-15 14:56:25.868257421 +0200
--- src/version.c	2016-10-15 15:23:36.340164248 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     34,
  /**/

-- 
SIGFUN -- signature too funny (core dumped)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0035
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0035 (after 7.4.2013)
Problem:    Order of matches for 'omnifunc' is messed up. (Danny Su)
Solution:   Do not set compl_curr_match when called from complete_check().
            (closes #1168)
Files:      src/edit.c, src/evalfunc.c, src/proto/edit.pro, src/search.c,
            src/spell.c, src/tag.c, src/testdir/test76.in, 
            src/testdir/test76.ok, src/testdir/test_popup.vim, src/Makefile,
            src/testdir/Make_all.mak


*** ../vim-8.0.0034/src/edit.c	2016-09-05 20:53:05.000000000 +0200
--- src/edit.c	2016-10-15 17:01:00.865374961 +0200
***************
*** 179,186 ****
  #endif
  static int  ins_compl_get_exp(pos_T *ini);
  static void ins_compl_delete(void);
! static void ins_compl_insert(void);
! static int  ins_compl_next(int allow_get_expansion, int count, int insert_match);
  static int  ins_compl_key2dir(int c);
  static int  ins_compl_pum_key(int c);
  static int  ins_compl_key2count(int c);
--- 179,186 ----
  #endif
  static int  ins_compl_get_exp(pos_T *ini);
  static void ins_compl_delete(void);
! static void ins_compl_insert(int in_compl_func);
! static int  ins_compl_next(int allow_get_expansion, int count, int insert_match, int in_compl_func);
  static int  ins_compl_key2dir(int c);
  static int  ins_compl_pum_key(int c);
  static int  ins_compl_key2count(int c);
***************
*** 861,867 ****
  				   && (c == CAR || c == K_KENTER || c == NL)))
  		{
  		    ins_compl_delete();
! 		    ins_compl_insert();
  		}
  	    }
  	}
--- 861,867 ----
  				   && (c == CAR || c == K_KENTER || c == NL)))
  		{
  		    ins_compl_delete();
! 		    ins_compl_insert(FALSE);
  		}
  	    }
  	}
***************
*** 3297,3303 ****
  			break;
  		}
  		line_breakcheck();
! 		ins_compl_check_keys(50);
  	    }
  	    fclose(fp);
  	}
--- 3297,3303 ----
  			break;
  		}
  		line_breakcheck();
! 		ins_compl_check_keys(50, FALSE);
  	    }
  	    fclose(fp);
  	}
***************
*** 4036,4043 ****
  }
  
  #ifdef FEAT_COMPL_FUNC
- static void expand_by_function(int type, char_u *base);
- 
  /*
   * Execute user defined complete function 'completefunc' or 'omnifunc', and
   * get matches in "matches".
--- 4036,4041 ----
***************
*** 4596,4602 ****
  		break;
  	    /* Fill the popup menu as soon as possible. */
  	    if (type != -1)
! 		ins_compl_check_keys(0);
  
  	    if ((ctrl_x_mode != 0 && !CTRL_X_MODE_LINE_OR_EVAL(ctrl_x_mode))
  							 || compl_interrupted)
--- 4594,4600 ----
  		break;
  	    /* Fill the popup menu as soon as possible. */
  	    if (type != -1)
! 		ins_compl_check_keys(0, FALSE);
  
  	    if ((ctrl_x_mode != 0 && !CTRL_X_MODE_LINE_OR_EVAL(ctrl_x_mode))
  							 || compl_interrupted)
***************
*** 4653,4661 ****
      set_vim_var_dict(VV_COMPLETED_ITEM, dict_alloc());
  }
  
! /* Insert the new text being completed. */
      static void
! ins_compl_insert(void)
  {
      dict_T	*dict;
  
--- 4651,4662 ----
      set_vim_var_dict(VV_COMPLETED_ITEM, dict_alloc());
  }
  
! /*
!  * Insert the new text being completed.
!  * "in_compl_func" is TRUE when called from complete_check().
!  */
      static void
! ins_compl_insert(int in_compl_func)
  {
      dict_T	*dict;
  
***************
*** 4682,4688 ****
  		    EMPTY_IF_NULL(compl_shown_match->cp_text[CPT_INFO]));
      }
      set_vim_var_dict(VV_COMPLETED_ITEM, dict);
!     compl_curr_match = compl_shown_match;
  }
  
  /*
--- 4683,4690 ----
  		    EMPTY_IF_NULL(compl_shown_match->cp_text[CPT_INFO]));
      }
      set_vim_var_dict(VV_COMPLETED_ITEM, dict);
!     if (!in_compl_func)
! 	compl_curr_match = compl_shown_match;
  }
  
  /*
***************
*** 4706,4712 ****
      int	    allow_get_expansion,
      int	    count,		/* repeat completion this many times; should
  				   be at least 1 */
!     int	    insert_match)	/* Insert the newly selected match */
  {
      int	    num_matches = -1;
      int	    i;
--- 4708,4715 ----
      int	    allow_get_expansion,
      int	    count,		/* repeat completion this many times; should
  				   be at least 1 */
!     int	    insert_match,	/* Insert the newly selected match */
!     int	    in_compl_func)	/* called from complete_check() */
  {
      int	    num_matches = -1;
      int	    i;
***************
*** 4856,4862 ****
      else if (insert_match)
      {
  	if (!compl_get_longest || compl_used_match)
! 	    ins_compl_insert();
  	else
  	    ins_bytes(compl_leader + ins_compl_len());
      }
--- 4859,4865 ----
      else if (insert_match)
      {
  	if (!compl_get_longest || compl_used_match)
! 	    ins_compl_insert(in_compl_func);
  	else
  	    ins_bytes(compl_leader + ins_compl_len());
      }
***************
*** 4921,4929 ****
   * mode.  Also, when compl_pending is not zero, show a completion as soon as
   * possible. -- webb
   * "frequency" specifies out of how many calls we actually check.
   */
      void
! ins_compl_check_keys(int frequency)
  {
      static int	count = 0;
  
--- 4924,4934 ----
   * mode.  Also, when compl_pending is not zero, show a completion as soon as
   * possible. -- webb
   * "frequency" specifies out of how many calls we actually check.
+  * "in_compl_func" is TRUE when called from complete_check(), don't set
+  * compl_curr_match.
   */
      void
! ins_compl_check_keys(int frequency, int in_compl_func)
  {
      static int	count = 0;
  
***************
*** 4949,4955 ****
  	    c = safe_vgetc();	/* Eat the character */
  	    compl_shows_dir = ins_compl_key2dir(c);
  	    (void)ins_compl_next(FALSE, ins_compl_key2count(c),
! 						    c != K_UP && c != K_DOWN);
  	}
  	else
  	{
--- 4954,4960 ----
  	    c = safe_vgetc();	/* Eat the character */
  	    compl_shows_dir = ins_compl_key2dir(c);
  	    (void)ins_compl_next(FALSE, ins_compl_key2count(c),
! 				      c != K_UP && c != K_DOWN, in_compl_func);
  	}
  	else
  	{
***************
*** 4972,4978 ****
  	int todo = compl_pending > 0 ? compl_pending : -compl_pending;
  
  	compl_pending = 0;
! 	(void)ins_compl_next(FALSE, todo, TRUE);
      }
  }
  
--- 4977,4983 ----
  	int todo = compl_pending > 0 ? compl_pending : -compl_pending;
  
  	compl_pending = 0;
! 	(void)ins_compl_next(FALSE, todo, TRUE, in_compl_func);
      }
  }
  
***************
*** 5490,5496 ****
       * Find next match (and following matches).
       */
      save_w_wrow = curwin->w_wrow;
!     n = ins_compl_next(TRUE, ins_compl_key2count(c), ins_compl_use_match(c));
  
      /* may undisplay the popup menu */
      ins_compl_upd_pum();
--- 5495,5502 ----
       * Find next match (and following matches).
       */
      save_w_wrow = curwin->w_wrow;
!     n = ins_compl_next(TRUE, ins_compl_key2count(c),
! 						ins_compl_use_match(c), FALSE);
  
      /* may undisplay the popup menu */
      ins_compl_upd_pum();
*** ../vim-8.0.0034/src/evalfunc.c	2016-10-12 14:19:55.738357808 +0200
--- src/evalfunc.c	2016-10-15 16:22:08.458346817 +0200
***************
*** 2175,2181 ****
      int		saved = RedrawingDisabled;
  
      RedrawingDisabled = 0;
!     ins_compl_check_keys(0);
      rettv->vval.v_number = compl_interrupted;
      RedrawingDisabled = saved;
  }
--- 2175,2181 ----
      int		saved = RedrawingDisabled;
  
      RedrawingDisabled = 0;
!     ins_compl_check_keys(0, TRUE);
      rettv->vval.v_number = compl_interrupted;
      RedrawingDisabled = saved;
  }
*** ../vim-8.0.0034/src/proto/edit.pro	2016-09-12 13:04:00.000000000 +0200
--- src/proto/edit.pro	2016-10-15 16:23:24.833787216 +0200
***************
*** 15,21 ****
  char_u *find_word_end(char_u *ptr);
  int ins_compl_active(void);
  int ins_compl_add_tv(typval_T *tv, int dir);
! void ins_compl_check_keys(int frequency);
  int get_literal(void);
  void insertchar(int c, int flags, int second_indent);
  void auto_format(int trailblank, int prev_line);
--- 15,21 ----
  char_u *find_word_end(char_u *ptr);
  int ins_compl_active(void);
  int ins_compl_add_tv(typval_T *tv, int dir);
! void ins_compl_check_keys(int frequency, int in_compl_func);
  int get_literal(void);
  void insertchar(int c, int flags, int second_indent);
  void auto_format(int trailblank, int prev_line);
*** ../vim-8.0.0034/src/search.c	2016-09-09 21:20:55.000000000 +0200
--- src/search.c	2016-10-15 16:26:52.640264523 +0200
***************
*** 5429,5435 ****
  	line_breakcheck();
  #ifdef FEAT_INS_EXPAND
  	if (action == ACTION_EXPAND)
! 	    ins_compl_check_keys(30);
  	if (got_int || compl_interrupted)
  #else
  	if (got_int)
--- 5429,5435 ----
  	line_breakcheck();
  #ifdef FEAT_INS_EXPAND
  	if (action == ACTION_EXPAND)
! 	    ins_compl_check_keys(30, FALSE);
  	if (got_int || compl_interrupted)
  #else
  	if (got_int)
*** ../vim-8.0.0034/src/spell.c	2016-08-29 22:42:20.000000000 +0200
--- src/spell.c	2016-10-15 16:27:13.788109555 +0200
***************
*** 8694,8700 ****
  		    /* Done all bytes at this node, go up one level. */
  		    --depth;
  		    line_breakcheck();
! 		    ins_compl_check_keys(50);
  		}
  		else
  		{
--- 8694,8700 ----
  		    /* Done all bytes at this node, go up one level. */
  		    --depth;
  		    line_breakcheck();
! 		    ins_compl_check_keys(50, FALSE);
  		}
  		else
  		{
*** ../vim-8.0.0034/src/tag.c	2016-09-06 21:20:44.000000000 +0200
--- src/tag.c	2016-10-15 16:27:34.955954439 +0200
***************
*** 1587,1593 ****
  		fast_breakcheck();
  #ifdef FEAT_INS_EXPAND
  	    if ((flags & TAG_INS_COMP))	/* Double brackets for gcc */
! 		ins_compl_check_keys(30);
  	    if (got_int || compl_interrupted)
  #else
  	    if (got_int)
--- 1587,1593 ----
  		fast_breakcheck();
  #ifdef FEAT_INS_EXPAND
  	    if ((flags & TAG_INS_COMP))	/* Double brackets for gcc */
! 		ins_compl_check_keys(30, FALSE);
  	    if (got_int || compl_interrupted)
  #else
  	    if (got_int)
*** ../vim-8.0.0034/src/testdir/test76.in	2010-11-10 16:38:45.000000000 +0100
--- src/testdir/test76.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,46 ****
- Tests for completefunc/omnifunc. vim: set ft=vim :
- 
- STARTTEST
- :"Test that nothing happens if the 'completefunc' opens
- :"a new window (no completion, no crash)
- :so small.vim
- :function! DummyCompleteOne(findstart, base)
- :  if a:findstart
- :    return 0
- :  else
- :    wincmd n
- :    return ['onedef', 'oneDEF']
- :  endif
- :endfunction
- :setlocal completefunc=DummyCompleteOne
- /^one
- A:q!
- :function! DummyCompleteTwo(findstart, base)
- :  if a:findstart
- :    wincmd n
- :    return 0
- :  else
- :    return ['twodef', 'twoDEF']
- :  endif
- :endfunction
- :setlocal completefunc=DummyCompleteTwo
- /^two
- A:q!
- :"Test that 'completefunc' works when it's OK.
- :function! DummyCompleteThree(findstart, base)
- :  if a:findstart
- :    return 0
- :  else
- :    return ['threedef', 'threeDEF']
- :  endif
- :endfunction
- :setlocal completefunc=DummyCompleteThree
- /^three
- A:/^+++/,/^three/w! test.out
- :qa!
- ENDTEST
- 
- +++
- one
- two
- three
--- 0 ----
*** ../vim-8.0.0034/src/testdir/test76.ok	2010-11-10 16:38:58.000000000 +0100
--- src/testdir/test76.ok	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,4 ****
- +++
- 
- two
- threeDEF
--- 0 ----
*** ../vim-8.0.0034/src/testdir/test_popup.vim	2016-09-22 21:27:08.360782126 +0200
--- src/testdir/test_popup.vim	2016-10-15 17:00:08.237755020 +0200
***************
*** 289,292 ****
--- 289,403 ----
    bwipe!
  endfunc
  
+ func DummyCompleteOne(findstart, base)
+   if a:findstart
+     return 0
+   else
+     wincmd n
+     return ['onedef', 'oneDEF']
+   endif
+ endfunc
+ 
+ " Test that nothing happens if the 'completefunc' opens
+ " a new window (no completion, no crash)
+ func Test_completefunc_opens_new_window_one()
+   new
+   let winid = win_getid()
+   setlocal completefunc=DummyCompleteOne
+   call setline(1, 'one')
+   /^one
+   call assert_fails('call feedkeys("A\<C-X>\<C-U>\<C-N>\<Esc>", "x")', 'E839:')
+   call assert_notequal(winid, win_getid())
+   q!
+   call assert_equal(winid, win_getid())
+   call assert_equal('', getline(1))
+   q!
+ endfunc
+ 
+ " Test that nothing happens if the 'completefunc' opens
+ " a new window (no completion, no crash)
+ func DummyCompleteTwo(findstart, base)
+   if a:findstart
+     wincmd n
+     return 0
+   else
+     return ['twodef', 'twoDEF']
+   endif
+ endfunction
+ 
+ " Test that nothing happens if the 'completefunc' opens
+ " a new window (no completion, no crash)
+ func Test_completefunc_opens_new_window_two()
+   new
+   let winid = win_getid()
+   setlocal completefunc=DummyCompleteTwo
+   call setline(1, 'two')
+   /^two
+   call assert_fails('call feedkeys("A\<C-X>\<C-U>\<C-N>\<Esc>", "x")', 'E764:')
+   call assert_notequal(winid, win_getid())
+   q!
+   call assert_equal(winid, win_getid())
+   call assert_equal('two', getline(1))
+   q!
+ endfunc
+ 
+ func DummyCompleteThree(findstart, base)
+   if a:findstart
+     return 0
+   else
+     return ['threedef', 'threeDEF']
+   endif
+ endfunc
+ 
+ :"Test that 'completefunc' works when it's OK.
+ func Test_completefunc_works()
+   new
+   let winid = win_getid()
+   setlocal completefunc=DummyCompleteThree
+   call setline(1, 'three')
+   /^three
+   call feedkeys("A\<C-X>\<C-U>\<C-N>\<Esc>", "x")
+   call assert_equal(winid, win_getid())
+   call assert_equal('threeDEF', getline(1))
+   q!
+ endfunc
+ 
+ func DummyCompleteFour(findstart, base)
+   if a:findstart
+     return 0
+   else
+     call complete_add('four1')
+     call complete_add('four2')
+     call complete_check()
+     call complete_add('four3')
+     call complete_add('four4')
+     call complete_check()
+     call complete_add('four5')
+     call complete_add('four6')
+     return []
+   endif
+ endfunc
+ 
+ :"Test that 'completefunc' works when it's OK.
+ func Test_omnifunc_with_check()
+   new
+   setlocal omnifunc=DummyCompleteFour
+   call setline(1, 'four')
+   /^four
+   call feedkeys("A\<C-X>\<C-O>\<C-N>\<Esc>", "x")
+   call assert_equal('four2', getline(1))
+ 
+   call setline(1, 'four')
+   /^four
+   call feedkeys("A\<C-X>\<C-O>\<C-N>\<C-N>\<Esc>", "x")
+   call assert_equal('four3', getline(1))
+ 
+   call setline(1, 'four')
+   /^four
+   call feedkeys("A\<C-X>\<C-O>\<C-N>\<C-N>\<C-N>\<C-N>\<Esc>", "x")
+   call assert_equal('four5', getline(1))
+ 
+   q!
+ endfunc
+ 
  " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.0.0034/src/Makefile	2016-10-12 17:45:13.642857417 +0200
--- src/Makefile	2016-10-15 16:53:46.808507474 +0200
***************
*** 2047,2053 ****
  	test40 test41 test42 test43 test44 test45 test48 test49 \
  	test50 test51 test52 test53 test54 test55 test56 test57 test58 test59 \
  	test60 test64 test65 test66 test67 test68 test69 \
! 	test70 test72 test73 test74 test75 test76 test77 test78 test79 \
  	test80 test82 test83 test84 test85 test86 test87 test88 test89 \
  	test90 test91 test92 test93 test94 test95 test97 test98 test99 \
  	test100 test101 test103 test104 test107 test108:
--- 2047,2053 ----
  	test40 test41 test42 test43 test44 test45 test48 test49 \
  	test50 test51 test52 test53 test54 test55 test56 test57 test58 test59 \
  	test60 test64 test65 test66 test67 test68 test69 \
! 	test70 test72 test73 test74 test75 test77 test78 test79 \
  	test80 test82 test83 test84 test85 test86 test87 test88 test89 \
  	test90 test91 test92 test93 test94 test95 test97 test98 test99 \
  	test100 test101 test103 test104 test107 test108:
*** ../vim-8.0.0034/src/testdir/Make_all.mak	2016-09-29 20:54:42.403110749 +0200
--- src/testdir/Make_all.mak	2016-10-15 16:53:57.008433920 +0200
***************
*** 55,61 ****
  	test70.out \
  	test73.out \
  	test75.out \
- 	test76.out \
  	test77.out \
  	test79.out \
  	test80.out \
--- 55,60 ----
*** ../vim-8.0.0034/src/version.c	2016-10-15 15:39:34.693059595 +0200
--- src/version.c	2016-10-15 17:05:26.303457035 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     35,
  /**/

-- 
Every exit is an entrance into something else.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0036
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0036
Problem:    Detecting that a job has finished may take a while.
Solution:   Check for a finished job more often (Ozaki Kiichi)
Files:      src/channel.c, src/os_unix.c, src/os_win32.c,
            src/proto/os_unix.pro, src/proto/os_win32.pro,
            src/testdir/test_channel.vim


*** ../vim-8.0.0035/src/channel.c	2016-10-09 17:27:56.859388538 +0200
--- src/channel.c	2016-10-15 18:34:49.054767438 +0200
***************
*** 4428,4433 ****
--- 4428,4466 ----
      }
  }
  
+     static void
+ job_cleanup(job_T *job)
+ {
+     if (job->jv_status != JOB_ENDED)
+ 	return;
+ 
+     if (job->jv_exit_cb != NULL)
+     {
+ 	typval_T	argv[3];
+ 	typval_T	rettv;
+ 	int		dummy;
+ 
+ 	/* invoke the exit callback; make sure the refcount is > 0 */
+ 	++job->jv_refcount;
+ 	argv[0].v_type = VAR_JOB;
+ 	argv[0].vval.v_job = job;
+ 	argv[1].v_type = VAR_NUMBER;
+ 	argv[1].vval.v_number = job->jv_exitval;
+ 	call_func(job->jv_exit_cb, (int)STRLEN(job->jv_exit_cb),
+ 	    &rettv, 2, argv, NULL, 0L, 0L, &dummy, TRUE,
+ 	    job->jv_exit_partial, NULL);
+ 	clear_tv(&rettv);
+ 	--job->jv_refcount;
+ 	channel_need_redraw = TRUE;
+     }
+     if (job->jv_refcount == 0)
+     {
+ 	/* The job was already unreferenced, now that it ended it can be
+ 	 * freed. Careful: caller must not use "job" after this! */
+ 	job_free(job);
+     }
+ }
+ 
  #if defined(EXITFREE) || defined(PROTO)
      void
  job_free_all(void)
***************
*** 4445,4454 ****
      static int
  job_still_useful(job_T *job)
  {
!     return job->jv_status == JOB_STARTED
! 	       && (job->jv_stoponexit != NULL || job->jv_exit_cb != NULL
! 		   || (job->jv_channel != NULL
! 		       && channel_still_useful(job->jv_channel)));
  }
  
  /*
--- 4478,4492 ----
      static int
  job_still_useful(job_T *job)
  {
!     return (job->jv_stoponexit != NULL || job->jv_exit_cb != NULL
! 	    || (job->jv_channel != NULL
! 		&& channel_still_useful(job->jv_channel)));
! }
! 
!     static int
! job_still_alive(job_T *job)
! {
!     return (job->jv_status == JOB_STARTED) && job_still_useful(job);
  }
  
  /*
***************
*** 4462,4468 ****
      typval_T	tv;
  
      for (job = first_job; job != NULL; job = job->jv_next)
! 	if (job_still_useful(job))
  	{
  	    tv.v_type = VAR_JOB;
  	    tv.vval.v_job = job;
--- 4500,4506 ----
      typval_T	tv;
  
      for (job = first_job; job != NULL; job = job->jv_next)
! 	if (job_still_alive(job))
  	{
  	    tv.v_type = VAR_JOB;
  	    tv.vval.v_job = job;
***************
*** 4478,4484 ****
      {
  	/* Do not free the job when it has not ended yet and there is a
  	 * "stoponexit" flag or an exit callback. */
! 	if (!job_still_useful(job))
  	{
  	    job_free(job);
  	}
--- 4516,4522 ----
      {
  	/* Do not free the job when it has not ended yet and there is a
  	 * "stoponexit" flag or an exit callback. */
! 	if (!job_still_alive(job))
  	{
  	    job_free(job);
  	}
***************
*** 4503,4509 ****
  
      for (job = first_job; job != NULL; job = job->jv_next)
  	if ((job->jv_copyID & mask) != (copyID & mask)
! 						    && !job_still_useful(job))
  	{
  	    /* Free the channel and ordinary items it contains, but don't
  	     * recurse into Lists, Dictionaries etc. */
--- 4541,4547 ----
  
      for (job = first_job; job != NULL; job = job->jv_next)
  	if ((job->jv_copyID & mask) != (copyID & mask)
! 						     && !job_still_alive(job))
  	{
  	    /* Free the channel and ordinary items it contains, but don't
  	     * recurse into Lists, Dictionaries etc. */
***************
*** 4523,4529 ****
      {
  	job_next = job->jv_next;
  	if ((job->jv_copyID & mask) != (copyID & mask)
! 						    && !job_still_useful(job))
  	{
  	    /* Free the job struct itself. */
  	    job_free_job(job);
--- 4561,4567 ----
      {
  	job_next = job->jv_next;
  	if ((job->jv_copyID & mask) != (copyID & mask)
! 						     && !job_still_alive(job))
  	{
  	    /* Free the job struct itself. */
  	    job_free_job(job);
***************
*** 4614,4647 ****
      job_T	    *job;
  
      for (job = first_job; job != NULL; job = job->jv_next)
! 	if (job->jv_status == JOB_STARTED && job_still_useful(job))
  	    return TRUE;
      return FALSE;
  }
  
  /*
   * Called once in a while: check if any jobs that seem useful have ended.
   */
      void
  job_check_ended(void)
  {
!     static time_t   last_check = 0;
!     time_t	    now;
!     job_T	    *job;
!     job_T	    *next;
  
!     /* Only do this once in 10 seconds. */
!     now = time(NULL);
!     if (last_check + 10 < now)
!     {
! 	last_check = now;
! 	for (job = first_job; job != NULL; job = next)
! 	{
! 	    next = job->jv_next;
! 	    if (job->jv_status == JOB_STARTED && job_still_useful(job))
! 		job_status(job); /* may free "job" */
! 	}
      }
      if (channel_need_redraw)
      {
  	channel_need_redraw = FALSE;
--- 4652,4682 ----
      job_T	    *job;
  
      for (job = first_job; job != NULL; job = job->jv_next)
! 	if (job_still_alive(job))
  	    return TRUE;
      return FALSE;
  }
  
+ #define MAX_CHECK_ENDED 8
+ 
  /*
   * Called once in a while: check if any jobs that seem useful have ended.
   */
      void
  job_check_ended(void)
  {
!     int		i;
  
!     for (i = 0; i < MAX_CHECK_ENDED; ++i)
!     {
! 	job_T	*job = mch_detect_ended_job(first_job);
! 
! 	if (job == NULL)
! 	    break;
! 	if (job_still_useful(job))
! 	    job_cleanup(job); /* may free "job" */
      }
+ 
      if (channel_need_redraw)
      {
  	channel_need_redraw = FALSE;
***************
*** 4862,4893 ****
      {
  	result = mch_job_status(job);
  	if (job->jv_status == JOB_ENDED)
! 	    ch_log(job->jv_channel, "Job ended");
! 	if (job->jv_status == JOB_ENDED && job->jv_exit_cb != NULL)
! 	{
! 	    typval_T	argv[3];
! 	    typval_T	rettv;
! 	    int		dummy;
! 
! 	    /* invoke the exit callback; make sure the refcount is > 0 */
! 	    ++job->jv_refcount;
! 	    argv[0].v_type = VAR_JOB;
! 	    argv[0].vval.v_job = job;
! 	    argv[1].v_type = VAR_NUMBER;
! 	    argv[1].vval.v_number = job->jv_exitval;
! 	    call_func(job->jv_exit_cb, (int)STRLEN(job->jv_exit_cb),
! 			   &rettv, 2, argv, NULL, 0L, 0L, &dummy, TRUE,
! 			   job->jv_exit_partial, NULL);
! 	    clear_tv(&rettv);
! 	    --job->jv_refcount;
! 	    channel_need_redraw = TRUE;
! 	}
! 	if (job->jv_status == JOB_ENDED && job->jv_refcount == 0)
! 	{
! 	    /* The job was already unreferenced, now that it ended it can be
! 	     * freed. Careful: caller must not use "job" after this! */
! 	    job_free(job);
! 	}
      }
      return result;
  }
--- 4897,4903 ----
      {
  	result = mch_job_status(job);
  	if (job->jv_status == JOB_ENDED)
! 	    job_cleanup(job);
      }
      return result;
  }
*** ../vim-8.0.0035/src/os_unix.c	2016-10-12 14:50:50.233115689 +0200
--- src/os_unix.c	2016-10-15 18:33:46.303229935 +0200
***************
*** 5294,5301 ****
      if (wait_pid == -1)
      {
  	/* process must have exited */
! 	job->jv_status = JOB_ENDED;
! 	return "dead";
      }
      if (wait_pid == 0)
  	return "run";
--- 5294,5300 ----
      if (wait_pid == -1)
      {
  	/* process must have exited */
! 	goto return_dead;
      }
      if (wait_pid == 0)
  	return "run";
***************
*** 5303,5318 ****
      {
  	/* LINTED avoid "bitwise operation on signed value" */
  	job->jv_exitval = WEXITSTATUS(status);
! 	job->jv_status = JOB_ENDED;
! 	return "dead";
      }
      if (WIFSIGNALED(status))
      {
  	job->jv_exitval = -1;
! 	job->jv_status = JOB_ENDED;
! 	return "dead";
      }
      return "run";
  }
  
      int
--- 5302,5363 ----
      {
  	/* LINTED avoid "bitwise operation on signed value" */
  	job->jv_exitval = WEXITSTATUS(status);
! 	goto return_dead;
      }
      if (WIFSIGNALED(status))
      {
  	job->jv_exitval = -1;
! 	goto return_dead;
      }
      return "run";
+ 
+ return_dead:
+     if (job->jv_status != JOB_ENDED)
+     {
+ 	ch_log(job->jv_channel, "Job ended");
+ 	job->jv_status = JOB_ENDED;
+     }
+     return "dead";
+ }
+ 
+     job_T *
+ mch_detect_ended_job(job_T *job_list)
+ {
+ # ifdef HAVE_UNION_WAIT
+     union wait	status;
+ # else
+     int		status = -1;
+ # endif
+     pid_t	wait_pid = 0;
+     job_T	*job;
+ 
+ # ifdef __NeXT__
+     wait_pid = wait4(-1, &status, WNOHANG, (struct rusage *)0);
+ # else
+     wait_pid = waitpid(-1, &status, WNOHANG);
+ # endif
+     if (wait_pid <= 0)
+ 	/* no process ended */
+ 	return NULL;
+     for (job = job_list; job != NULL; job = job->jv_next)
+     {
+ 	if (job->jv_pid == wait_pid)
+ 	{
+ 	    if (WIFEXITED(status))
+ 		/* LINTED avoid "bitwise operation on signed value" */
+ 		job->jv_exitval = WEXITSTATUS(status);
+ 	    else if (WIFSIGNALED(status))
+ 		job->jv_exitval = -1;
+ 	    if (job->jv_status != JOB_ENDED)
+ 	    {
+ 		ch_log(job->jv_channel, "Job ended");
+ 		job->jv_status = JOB_ENDED;
+ 	    }
+ 	    return job;
+ 	}
+     }
+     return NULL;
+ 
  }
  
      int
*** ../vim-8.0.0035/src/os_win32.c	2016-10-12 14:19:55.754357695 +0200
--- src/os_win32.c	2016-10-15 18:34:13.379030378 +0200
***************
*** 4973,4985 ****
      if (!GetExitCodeProcess(job->jv_proc_info.hProcess, &dwExitCode)
  	    || dwExitCode != STILL_ACTIVE)
      {
- 	job->jv_status = JOB_ENDED;
  	job->jv_exitval = (int)dwExitCode;
  	return "dead";
      }
      return "run";
  }
  
      int
  mch_stop_job(job_T *job, char_u *how)
  {
--- 4973,5025 ----
      if (!GetExitCodeProcess(job->jv_proc_info.hProcess, &dwExitCode)
  	    || dwExitCode != STILL_ACTIVE)
      {
  	job->jv_exitval = (int)dwExitCode;
+ 	if (job->jv_status != JOB_ENDED)
+ 	{
+ 	    ch_log(job->jv_channel, "Job ended");
+ 	    job->jv_status = JOB_ENDED;
+ 	}
  	return "dead";
      }
      return "run";
  }
  
+     job_T *
+ mch_detect_ended_job(job_T *job_list)
+ {
+     HANDLE jobHandles[MAXIMUM_WAIT_OBJECTS];
+     job_T *jobArray[MAXIMUM_WAIT_OBJECTS];
+     job_T *job = job_list;
+ 
+     while (job != NULL)
+     {
+ 	DWORD n;
+ 	DWORD result;
+ 
+ 	for (n = 0; n < MAXIMUM_WAIT_OBJECTS
+ 				       && job != NULL; job = job->jv_next)
+ 	{
+ 	    if (job->jv_status == JOB_STARTED)
+ 	    {
+ 		jobHandles[n] = job->jv_proc_info.hProcess;
+ 		jobArray[n] = job;
+ 		++n;
+ 	    }
+ 	}
+ 	if (n == 0)
+ 	    continue;
+ 	result = WaitForMultipleObjects(n, jobHandles, FALSE, 0);
+ 	if (result >= WAIT_OBJECT_0 && result < WAIT_OBJECT_0 + n)
+ 	{
+ 	    job_T *wait_job = jobArray[result - WAIT_OBJECT_0];
+ 
+ 	    if (STRCMP(mch_job_status(wait_job), "dead") == 0)
+ 		return wait_job;
+ 	}
+     }
+     return NULL;
+ }
+ 
      int
  mch_stop_job(job_T *job, char_u *how)
  {
*** ../vim-8.0.0035/src/proto/os_unix.pro	2016-09-29 15:18:51.359768012 +0200
--- src/proto/os_unix.pro	2016-10-15 18:26:49.770299911 +0200
***************
*** 59,64 ****
--- 59,65 ----
  int mch_call_shell(char_u *cmd, int options);
  void mch_start_job(char **argv, job_T *job, jobopt_T *options);
  char *mch_job_status(job_T *job);
+ job_T *mch_detect_ended_job(job_T *job_list);
  int mch_stop_job(job_T *job, char_u *how);
  void mch_clear_job(job_T *job);
  void mch_breakcheck(int force);
*** ../vim-8.0.0035/src/proto/os_win32.pro	2016-10-12 14:19:55.754357695 +0200
--- src/proto/os_win32.pro	2016-10-15 18:26:49.770299911 +0200
***************
*** 41,46 ****
--- 41,47 ----
  int mch_call_shell(char_u *cmd, int options);
  void mch_start_job(char *cmd, job_T *job, jobopt_T *options);
  char *mch_job_status(job_T *job);
+ job_T *mch_detect_ended_job(job_T *job_list);
  int mch_stop_job(job_T *job, char_u *how);
  void mch_clear_job(job_T *job);
  void mch_set_normal_colors(void);
*** ../vim-8.0.0035/src/testdir/test_channel.vim	2016-10-09 17:27:56.863388510 +0200
--- src/testdir/test_channel.vim	2016-10-15 18:26:49.770299911 +0200
***************
*** 1362,1367 ****
--- 1362,1385 ----
    endif
  endfunc
  
+ let g:exit_cb_time = {'start': 0, 'end': 0}
+ function MyExitTimeCb(job, status)
+   let g:exit_cb_time.end = reltime(g:exit_cb_time.start)
+ endfunction
+ 
+ func Test_exit_callback_interval()
+   if !has('job')
+     return
+   endif
+ 
+   let g:exit_cb_time.start = reltime()
+   let job = job_start([s:python, '-c', 'import time;time.sleep(0.5)'], {'exit_cb': 'MyExitTimeCb'})
+   call WaitFor('g:exit_cb_time.end != 0')
+   let elapsed = reltimefloat(g:exit_cb_time.end)
+   call assert_true(elapsed > 0.3)
+   call assert_true(elapsed < 1.0)
+ endfunc
+ 
  """""""""
  
  let g:Ch_close_ret = 'alive'
*** ../vim-8.0.0035/src/version.c	2016-10-15 17:06:42.094912699 +0200
--- src/version.c	2016-10-15 18:28:19.269640273 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     36,
  /**/

-- 
It is illegal for a driver to be blindfolded while operating a vehicle.
		[real standing law in Alabama, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0037
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0037
Problem:    Get E924 when switching tabs.
Solution:   Use win_valid_any_tab() instead of win_valid(). (Martin Vuille,
            closes #1167, closes #1171)
Files:      src/quickfix.c, src/testdir/test_quickfix.vim


*** ../vim-8.0.0036/src/quickfix.c	2016-10-09 16:10:02.135942266 +0200
--- src/quickfix.c	2016-10-15 19:20:23.402614457 +0200
***************
*** 2266,2272 ****
  
  	    ok = buflist_getfile(qf_ptr->qf_fnum,
  			    (linenr_T)1, GETF_SETMARK | GETF_SWITCH, forceit);
! 	    if (qi != &ql_info && !win_valid(oldwin))
  	    {
  		EMSG(_("E924: Current window was closed"));
  		is_abort = TRUE;
--- 2266,2272 ----
  
  	    ok = buflist_getfile(qf_ptr->qf_fnum,
  			    (linenr_T)1, GETF_SETMARK | GETF_SWITCH, forceit);
! 	    if (qi != &ql_info && !win_valid_any_tab(oldwin))
  	    {
  		EMSG(_("E924: Current window was closed"));
  		is_abort = TRUE;
*** ../vim-8.0.0036/src/testdir/test_quickfix.vim	2016-10-09 16:10:02.135942266 +0200
--- src/testdir/test_quickfix.vim	2016-10-15 19:19:46.170888867 +0200
***************
*** 617,622 ****
--- 617,638 ----
      augroup! testgroup
  endfunction
  
+ function Test_locationlist_cross_tab_jump()
+   call writefile(['loclistfoo'], 'loclistfoo')
+   call writefile(['loclistbar'], 'loclistbar')
+   set switchbuf=usetab
+ 
+   edit loclistfoo
+   tabedit loclistbar
+   silent lgrep loclistfoo loclist*
+   call assert_equal(1, tabpagenr())
+ 
+   enew | only | tabonly
+   set switchbuf&vim
+   call delete('loclistfoo')
+   call delete('loclistbar')
+ endfunction
+ 
  " More tests for 'errorformat'
  function! Test_efm1()
      if !has('unix')
*** ../vim-8.0.0036/src/version.c	2016-10-15 18:36:45.353910276 +0200
--- src/version.c	2016-10-15 19:22:55.749491613 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     37,
  /**/

-- 
You can be stopped by the police for biking over 65 miles per hour.
You are not allowed to walk across a street on your hands.
		[real standing laws in Connecticut, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0038
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0038
Problem:    OPEN_CHR_FILES not defined for FreeBSD using Debian userland
            files.
Solution:   Check for __FreeBSD_kernel__. (James McCoy, closes #1166)
Files:      src/vim.h


*** ../vim-8.0.0037/src/vim.h	2016-10-15 15:39:34.689059624 +0200
--- src/vim.h	2016-10-15 19:32:06.017435971 +0200
***************
*** 2495,2501 ****
  #define FNE_INCL_BR	1	/* include [] in name */
  #define FNE_CHECK_START	2	/* check name starts with valid character */
  
! #if (defined(sun) || defined(__FreeBSD__)) && defined(S_ISCHR)
  # define OPEN_CHR_FILES
  #endif
  
--- 2495,2502 ----
  #define FNE_INCL_BR	1	/* include [] in name */
  #define FNE_CHECK_START	2	/* check name starts with valid character */
  
! #if (defined(sun) || defined(__FreeBSD__) || defined(__FreeBSD_kernel__)) \
! 	&& defined(S_ISCHR)
  # define OPEN_CHR_FILES
  #endif
  
*** ../vim-8.0.0037/src/version.c	2016-10-15 19:28:09.243181069 +0200
--- src/version.c	2016-10-15 19:33:06.036993609 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     38,
  /**/

-- 
A special law prohibits unmarried women from parachuting on Sunday or she
shall risk arrest, fine, and/or jailing.
		[real standing law in Florida, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0039
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0039
Problem:    When Vim 8 reads an old viminfo and exits, the next time marks are
            not read from viminfo. (Ned Batchelder)
Solution:   Set a mark when it wasn't set before, even when the timestamp is
            zero. (closes #1170)
Files:      src/mark.c, src/testdir/test_viminfo.vim


*** ../vim-8.0.0038/src/mark.c	2016-08-29 22:42:20.000000000 +0200
--- src/mark.c	2016-10-15 20:42:31.522292708 +0200
***************
*** 1597,1603 ****
  
      if (fm != NULL)
      {
! 	if (vi_namedfm != NULL || fm->time_set < timestamp || force)
  	{
  	    fm->fmark.mark.lnum = lnum;
  	    fm->fmark.mark.col = col;
--- 1597,1604 ----
  
      if (fm != NULL)
      {
! 	if (vi_namedfm != NULL || fm->fmark.mark.lnum == 0
! 					  || fm->time_set < timestamp || force)
  	{
  	    fm->fmark.mark.lnum = lnum;
  	    fm->fmark.mark.col = col;
*** ../vim-8.0.0038/src/testdir/test_viminfo.vim	2016-08-26 20:35:50.000000000 +0200
--- src/testdir/test_viminfo.vim	2016-10-15 20:38:48.599935714 +0200
***************
*** 1,6 ****
  " Test for reading and writing .viminfo
  
! function Test_read_and_write()
    call histdel(':')
    let lines = [
  	\ '# comment line',
--- 1,6 ----
  " Test for reading and writing .viminfo
  
! function Test_viminfo_read_and_write()
    call histdel(':')
    let lines = [
  	\ '# comment line',
***************
*** 17,23 ****
    let lines = readfile('Xviminfo')
    let done = 0
    for line in lines
!     if line[0] == '|' && line !~ '^|[234],'
        if done == 0
  	call assert_equal('|1,4', line)
        elseif done == 1
--- 17,23 ----
    let lines = readfile('Xviminfo')
    let done = 0
    for line in lines
!     if line[0] == '|' && line !~ '^|[234],' && line !~ '^|<'
        if done == 0
  	call assert_equal('|1,4', line)
        elseif done == 1
***************
*** 469,475 ****
    silent! bwipe Xtestfileintab
  endfunc
  
! func Test_oldfiles()
    let v:oldfiles = []
    let lines = [
  	\ '# comment line',
--- 469,495 ----
    silent! bwipe Xtestfileintab
  endfunc
  
! func Test_viminfo_file_mark_zero_time()
!   let lines = [
! 	\ '# Viminfo version',
! 	\ '|1,4',
! 	\ '',
! 	\ '*encoding=utf-8',
! 	\ '',
! 	\ '# File marks:',
! 	\ "'B  1  0  /tmp/nothing",
! 	\ '|4,66,1,0,0,"/tmp/nothing"',
! 	\ "",
! 	\ ]
!   call writefile(lines, 'Xviminfo')
!   delmark B
!   rviminfo Xviminfo
!   call delete('Xviminfo')
!   call assert_equal(1, line("'B"))
!   delmark B
! endfunc
! 
! func Test_viminfo_oldfiles()
    let v:oldfiles = []
    let lines = [
  	\ '# comment line',
*** ../vim-8.0.0038/src/version.c	2016-10-15 19:33:47.264689748 +0200
--- src/version.c	2016-10-15 20:41:39.246677996 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     39,
  /**/

-- 
If an elephant is left tied to a parking meter, the parking fee has to be paid
just as it would for a vehicle.
		[real standing law in Florida, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0040
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0040 (after 8.0.0033)
Problem:    Whole line highlighting with matchaddpos() does not work.
Solution:   Check for zero length. (Hirohito Higashi)
Files:      src/screen.c, src/testdir/test_match.vim


*** ../vim-8.0.0039/src/screen.c	2016-10-15 14:56:25.868257421 +0200
--- src/screen.c	2016-10-16 14:28:48.026766302 +0200
***************
*** 7773,7778 ****
--- 7773,7782 ----
      }
  }
  
+ /*
+  * If there is a match fill "shl" and return one.
+  * Return zero otherwise.
+  */
      static int
  next_search_hl_pos(
      match_T	    *shl,	/* points to a match */
***************
*** 7781,7835 ****
      colnr_T	    mincol)	/* minimal column for a match */
  {
      int	    i;
!     int	    bot = -1;
  
-     shl->lnum = 0;
      for (i = posmatch->cur; i < MAXPOSMATCH; i++)
      {
  	llpos_T	*pos = &posmatch->pos[i];
  
  	if (pos->lnum == 0)
  	    break;
! 	if (pos->col + pos->len - 1 <= mincol)
  	    continue;
  	if (pos->lnum == lnum)
  	{
! 	    if (shl->lnum == lnum)
  	    {
! 		/* partially sort positions by column numbers
! 		 * on the same line */
! 		if (pos->col < posmatch->pos[bot].col)
  		{
  		    llpos_T	tmp = *pos;
  
! 		    *pos = posmatch->pos[bot];
! 		    posmatch->pos[bot] = tmp;
  		}
  	    }
  	    else
! 	    {
! 		bot = i;
! 		shl->lnum = lnum;
! 	    }
  	}
      }
      posmatch->cur = 0;
!     if (shl->lnum == lnum && bot >= 0)
      {
! 	colnr_T	start = posmatch->pos[bot].col == 0
! 					     ? 0 : posmatch->pos[bot].col - 1;
! 	colnr_T	end = posmatch->pos[bot].col == 0
! 				    ? MAXCOL : start + posmatch->pos[bot].len;
  
  	shl->rm.startpos[0].lnum = 0;
  	shl->rm.startpos[0].col = start;
  	shl->rm.endpos[0].lnum = 0;
  	shl->rm.endpos[0].col = end;
  	shl->is_addpos = TRUE;
! 	posmatch->cur = bot + 1;
! 	return TRUE;
      }
!     return FALSE;
  }
  #endif
  
--- 7785,7836 ----
      colnr_T	    mincol)	/* minimal column for a match */
  {
      int	    i;
!     int	    found = -1;
  
      for (i = posmatch->cur; i < MAXPOSMATCH; i++)
      {
  	llpos_T	*pos = &posmatch->pos[i];
  
  	if (pos->lnum == 0)
  	    break;
! 	if (pos->len == 0 && pos->col < mincol)
  	    continue;
  	if (pos->lnum == lnum)
  	{
! 	    if (found >= 0)
  	    {
! 		/* if this match comes before the one at "found" then swap
! 		 * them */
! 		if (pos->col < posmatch->pos[found].col)
  		{
  		    llpos_T	tmp = *pos;
  
! 		    *pos = posmatch->pos[found];
! 		    posmatch->pos[found] = tmp;
  		}
  	    }
  	    else
! 		found = i;
  	}
      }
      posmatch->cur = 0;
!     if (found >= 0)
      {
! 	colnr_T	start = posmatch->pos[found].col == 0
! 					    ? 0 : posmatch->pos[found].col - 1;
! 	colnr_T	end = posmatch->pos[found].col == 0
! 				   ? MAXCOL : start + posmatch->pos[found].len;
  
+ 	shl->lnum = lnum;
  	shl->rm.startpos[0].lnum = 0;
  	shl->rm.startpos[0].col = start;
  	shl->rm.endpos[0].lnum = 0;
  	shl->rm.endpos[0].col = end;
  	shl->is_addpos = TRUE;
! 	posmatch->cur = found + 1;
! 	return 1;
      }
!     return 0;
  }
  #endif
  
*** ../vim-8.0.0039/src/testdir/test_match.vim	2016-10-15 14:56:25.868257421 +0200
--- src/testdir/test_match.vim	2016-10-16 14:16:10.376350417 +0200
***************
*** 191,197 ****
--- 191,205 ----
    call assert_equal(screenattr(2,2), screenattr(1,7))
    call assert_notequal(screenattr(2,2), screenattr(1,8))
  
+   call clearmatches()
+   call matchaddpos('Error', [[1], [2,2]])
+   redraw!
+   call assert_equal(screenattr(2,2), screenattr(1,1))
+   call assert_equal(screenattr(2,2), screenattr(1,10))
+   call assert_notequal(screenattr(2,2), screenattr(1,11))
+ 
    nohl
+   call clearmatches()
    syntax off
    set hlsearch&
  endfunc
*** ../vim-8.0.0039/src/version.c	2016-10-15 20:46:13.580656069 +0200
--- src/version.c	2016-10-16 14:30:29.174020816 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     40,
  /**/

-- 
It is illegal for anyone to give lighted cigars to dogs, cats, and other
domesticated animal kept as pets.
		[real standing law in Illinois, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0041
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0041
Problem:    When using Insert mode completion but not actually inserting
            anything an undo item is still created. (Tommy Allen)
Solution:   Do not call stop_arrow() when not inserting anything.
Files:      src/edit.c, src/testdir/test_popup.vim


*** ../vim-8.0.0040/src/edit.c	2016-10-15 17:06:42.086912756 +0200
--- src/edit.c	2016-10-16 15:34:26.985734970 +0200
***************
*** 2799,2807 ****
  	ins_compl_prep(' ');
      ins_compl_clear();
  
-     if (stop_arrow() == FAIL)
- 	return;
- 
      compl_direction = FORWARD;
      if (startcol > curwin->w_cursor.col)
  	startcol = curwin->w_cursor.col;
--- 2799,2804 ----
***************
*** 3876,3882 ****
  		/* put the cursor on the last char, for 'tw' formatting */
  		if (prev_col > 0)
  		    dec_cursor();
! 		if (stop_arrow() == OK)
  		    insertchar(NUL, 0, -1);
  		if (prev_col > 0
  			     && ml_get_curline()[curwin->w_cursor.col] != NUL)
--- 3873,3880 ----
  		/* put the cursor on the last char, for 'tw' formatting */
  		if (prev_col > 0)
  		    dec_cursor();
! 		/* only format when something was inserted */
! 		if (!arrow_used && !ins_need_undo)
  		    insertchar(NUL, 0, -1);
  		if (prev_col > 0
  			     && ml_get_curline()[curwin->w_cursor.col] != NUL)
*** ../vim-8.0.0040/src/testdir/test_popup.vim	2016-10-15 17:06:42.094912699 +0200
--- src/testdir/test_popup.vim	2016-10-16 15:33:41.586069579 +0200
***************
*** 378,384 ****
    endif
  endfunc
  
! :"Test that 'completefunc' works when it's OK.
  func Test_omnifunc_with_check()
    new
    setlocal omnifunc=DummyCompleteFour
--- 378,384 ----
    endif
  endfunc
  
! " Test that 'completefunc' works when it's OK.
  func Test_omnifunc_with_check()
    new
    setlocal omnifunc=DummyCompleteFour
***************
*** 400,403 ****
--- 400,429 ----
    q!
  endfunc
  
+ function UndoComplete()
+   call complete(1, ['January', 'February', 'March',
+         \ 'April', 'May', 'June', 'July', 'August', 'September',
+         \ 'October', 'November', 'December'])
+   return ''
+ endfunc
+ 
+ " Test that no undo item is created when no completion is inserted
+ func Test_complete_no_undo()
+   set completeopt=menu,preview,noinsert,noselect
+   inoremap <Right> <C-R>=UndoComplete()<CR>
+   new
+   call feedkeys("ixxx\<CR>\<CR>yyy\<Esc>k", 'xt')
+   call feedkeys("iaaa\<Esc>0", 'xt')
+   call assert_equal('aaa', getline(2))
+   call feedkeys("i\<Right>\<Esc>", 'xt')
+   call assert_equal('aaa', getline(2))
+   call feedkeys("u", 'xt')
+   call assert_equal('', getline(2))
+ 
+   iunmap <Right>
+   set completeopt&
+   q!
+ endfunc
+ 
+ 
  " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.0.0040/src/version.c	2016-10-16 14:35:44.547696415 +0200
--- src/version.c	2016-10-16 15:35:09.805419375 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     41,
  /**/

-- 
Sometimes I think the surest sign that intelligent life exists elsewhere
in the universe is that none of it has tried to contact us.     (Calvin)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0042
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0042 (after 8.0.0041)
Problem:    When using Insert mode completion with 'completeopt' containing
            "noinsert" change is not saved for undo.  (Tommy Allen)
Solution:   Call stop_arrow() before inserting for pressing Enter.
Files:      src/edit.c, src/testdir/test_popup.vim


*** ../vim-8.0.0041/src/edit.c	2016-10-16 15:35:43.113173887 +0200
--- src/edit.c	2016-10-17 20:40:11.205738031 +0200
***************
*** 857,864 ****
  
  		/* Pressing CTRL-Y selects the current match.  When
  		 * compl_enter_selects is set the Enter key does the same. */
! 		if (c == Ctrl_Y || (compl_enter_selects
! 				   && (c == CAR || c == K_KENTER || c == NL)))
  		{
  		    ins_compl_delete();
  		    ins_compl_insert(FALSE);
--- 857,865 ----
  
  		/* Pressing CTRL-Y selects the current match.  When
  		 * compl_enter_selects is set the Enter key does the same. */
! 		if ((c == Ctrl_Y || (compl_enter_selects
! 				    && (c == CAR || c == K_KENTER || c == NL)))
! 			&& stop_arrow() == OK)
  		{
  		    ins_compl_delete();
  		    ins_compl_insert(FALSE);
*** ../vim-8.0.0041/src/testdir/test_popup.vim	2016-10-16 15:35:43.113173887 +0200
--- src/testdir/test_popup.vim	2016-10-17 20:33:32.300678084 +0200
***************
*** 420,425 ****
--- 420,432 ----
    call feedkeys("u", 'xt')
    call assert_equal('', getline(2))
  
+   call feedkeys("ibbb\<Esc>0", 'xt')
+   call assert_equal('bbb', getline(2))
+   call feedkeys("A\<Right>\<Down>\<CR>\<Esc>", 'xt')
+   call assert_equal('January', getline(2))
+   call feedkeys("u", 'xt')
+   call assert_equal('bbb', getline(2))
+ 
    iunmap <Right>
    set completeopt&
    q!
*** ../vim-8.0.0041/src/version.c	2016-10-16 15:35:43.113173887 +0200
--- src/version.c	2016-10-17 20:43:35.744230520 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     42,
  /**/

-- 
bashian roulette:
$ ((RANDOM%6)) || rm -rf ~

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0043
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0043 (after 8.0.0041)
Problem:    When using Insert mode completion with 'completeopt' containing
            "noinsert" with CTRL-N the change is not saved for undo.  (Tommy
            Allen)
Solution:   Call stop_arrow() before inserting for any key.
Files:      src/edit.c, src/testdir/test_popup.vim


*** ../vim-8.0.0042/src/edit.c	2016-10-17 20:46:59.342729937 +0200
--- src/edit.c	2016-10-18 12:51:59.119990870 +0200
***************
*** 4634,4647 ****
      static void
  ins_compl_delete(void)
  {
!     int	    i;
  
      /*
       * In insert mode: Delete the typed part.
       * In replace mode: Put the old characters back, if any.
       */
!     i = compl_col + (compl_cont_status & CONT_ADDING ? compl_length : 0);
!     backspace_until_column(i);
  
      /* TODO: is this sufficient for redrawing?  Redrawing everything causes
       * flicker, thus we can't do that. */
--- 4634,4652 ----
      static void
  ins_compl_delete(void)
  {
!     int	    col;
  
      /*
       * In insert mode: Delete the typed part.
       * In replace mode: Put the old characters back, if any.
       */
!     col = compl_col + (compl_cont_status & CONT_ADDING ? compl_length : 0);
!     if ((int)curwin->w_cursor.col > col)
!     {
! 	if (stop_arrow() == FAIL)
! 	    return;
! 	backspace_until_column(col);
!     }
  
      /* TODO: is this sufficient for redrawing?  Redrawing everything causes
       * flicker, thus we can't do that. */
***************
*** 5059,5066 ****
--- 5064,5074 ----
      colnr_T	curs_col;	    /* cursor column */
      int		n;
      int		save_w_wrow;
+     int		insert_match;
  
      compl_direction = ins_compl_key2dir(c);
+     insert_match = ins_compl_use_match(c);
+ 
      if (!compl_started)
      {
  	/* First time we hit ^N or ^P (in a row, I mean) */
***************
*** 5486,5491 ****
--- 5494,5501 ----
  	edit_submode_extra = NULL;
  	out_flush();
      }
+     else if (insert_match && stop_arrow() == FAIL)
+ 	return FAIL;
  
      compl_shown_match = compl_curr_match;
      compl_shows_dir = compl_direction;
***************
*** 5494,5501 ****
       * Find next match (and following matches).
       */
      save_w_wrow = curwin->w_wrow;
!     n = ins_compl_next(TRUE, ins_compl_key2count(c),
! 						ins_compl_use_match(c), FALSE);
  
      /* may undisplay the popup menu */
      ins_compl_upd_pum();
--- 5504,5510 ----
       * Find next match (and following matches).
       */
      save_w_wrow = curwin->w_wrow;
!     n = ins_compl_next(TRUE, ins_compl_key2count(c), insert_match, FALSE);
  
      /* may undisplay the popup menu */
      ins_compl_upd_pum();
*** ../vim-8.0.0042/src/testdir/test_popup.vim	2016-10-17 20:46:59.342729937 +0200
--- src/testdir/test_popup.vim	2016-10-18 12:31:27.581067689 +0200
***************
*** 427,432 ****
--- 427,437 ----
    call feedkeys("u", 'xt')
    call assert_equal('bbb', getline(2))
  
+   call feedkeys("A\<Right>\<C-N>\<Esc>", 'xt')
+   call assert_equal('January', getline(2))
+   call feedkeys("u", 'xt')
+   call assert_equal('bbb', getline(2))
+ 
    iunmap <Right>
    set completeopt&
    q!
*** ../vim-8.0.0042/src/version.c	2016-10-17 20:46:59.342729937 +0200
--- src/version.c	2016-10-18 13:01:18.947864767 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     43,
  /**/

-- 
A parent can be arrested if his child cannot hold back a burp during a church
service.
		[real standing law in Nebraska, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0044
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0044
Problem:    In diff mode the cursor may end up below the last line, resulting
            in an ml_get error.
Solution:   Check the line to be valid.
Files:      src/move.c, src/diff.c, src/proto/diff.pro,
            src/testdir/test_diffmode.vim


*** ../vim-8.0.0043/src/move.c	2016-09-04 14:29:37.000000000 +0200
--- src/move.c	2016-10-18 14:28:15.793415019 +0200
***************
*** 2824,2834 ****
  	{
  # ifdef FEAT_DIFF
  	    if (curwin->w_p_diff)
! 		curwin->w_cursor.lnum
! 			= diff_get_corresponding_line(old_curbuf,
! 						      line,
! 						      curbuf,
! 						      curwin->w_cursor.lnum);
  	    else
  # endif
  		curwin->w_cursor.lnum = line;
--- 2824,2831 ----
  	{
  # ifdef FEAT_DIFF
  	    if (curwin->w_p_diff)
! 		curwin->w_cursor.lnum =
! 				 diff_get_corresponding_line(old_curbuf, line);
  	    else
  # endif
  		curwin->w_cursor.lnum = line;
*** ../vim-8.0.0043/src/diff.c	2016-08-29 22:42:20.000000000 +0200
--- src/diff.c	2016-10-18 14:48:59.700247046 +0200
***************
*** 1100,1109 ****
  		if (bufref_valid(&old_curbuf))
  		    /* Move the cursor position to that of the old window. */
  		    curwin->w_cursor.lnum = diff_get_corresponding_line(
! 			    old_curbuf.br_buf,
! 			    old_curwin->w_cursor.lnum,
! 			    curbuf,
! 			    curwin->w_cursor.lnum);
  	    }
  	    /* Now that lines are folded scroll to show the cursor at the same
  	     * relative position. */
--- 1100,1106 ----
  		if (bufref_valid(&old_curbuf))
  		    /* Move the cursor position to that of the old window. */
  		    curwin->w_cursor.lnum = diff_get_corresponding_line(
! 			    old_curbuf.br_buf, old_curwin->w_cursor.lnum);
  	    }
  	    /* Now that lines are folded scroll to show the cursor at the same
  	     * relative position. */
***************
*** 2524,2544 ****
      return OK;
  }
  
!     linenr_T
! diff_get_corresponding_line(
      buf_T	*buf1,
!     linenr_T	lnum1,
!     buf_T	*buf2,
!     linenr_T	lnum3)
  {
      int		idx1;
      int		idx2;
      diff_T	*dp;
      int		baseline = 0;
-     linenr_T	lnum2;
  
      idx1 = diff_buf_idx(buf1);
!     idx2 = diff_buf_idx(buf2);
      if (idx1 == DB_COUNT || idx2 == DB_COUNT || curtab->tp_first_diff == NULL)
  	return lnum1;
  
--- 2521,2542 ----
      return OK;
  }
  
! /*
!  * Return the line number in the current window that is closest to "lnum1" in
!  * "buf1" in diff mode.
!  */
!     static linenr_T
! diff_get_corresponding_line_int(
      buf_T	*buf1,
!     linenr_T	lnum1)
  {
      int		idx1;
      int		idx2;
      diff_T	*dp;
      int		baseline = 0;
  
      idx1 = diff_buf_idx(buf1);
!     idx2 = diff_buf_idx(curbuf);
      if (idx1 == DB_COUNT || idx2 == DB_COUNT || curtab->tp_first_diff == NULL)
  	return lnum1;
  
***************
*** 2551,2565 ****
      for (dp = curtab->tp_first_diff; dp != NULL; dp = dp->df_next)
      {
  	if (dp->df_lnum[idx1] > lnum1)
! 	{
! 	    lnum2 = lnum1 - baseline;
! 	    /* don't end up past the end of the file */
! 	    if (lnum2 > buf2->b_ml.ml_line_count)
! 		lnum2 = buf2->b_ml.ml_line_count;
! 
! 	    return lnum2;
! 	}
! 	else if ((dp->df_lnum[idx1] + dp->df_count[idx1]) > lnum1)
  	{
  	    /* Inside the diffblock */
  	    baseline = lnum1 - dp->df_lnum[idx1];
--- 2549,2556 ----
      for (dp = curtab->tp_first_diff; dp != NULL; dp = dp->df_next)
      {
  	if (dp->df_lnum[idx1] > lnum1)
! 	    return lnum1 - baseline;
! 	if ((dp->df_lnum[idx1] + dp->df_count[idx1]) > lnum1)
  	{
  	    /* Inside the diffblock */
  	    baseline = lnum1 - dp->df_lnum[idx1];
***************
*** 2568,2577 ****
  
  	    return dp->df_lnum[idx2] + baseline;
  	}
! 	else if (   (dp->df_lnum[idx1] == lnum1)
! 		 && (dp->df_count[idx1] == 0)
! 		 && (dp->df_lnum[idx2] <= lnum3)
! 		 && ((dp->df_lnum[idx2] + dp->df_count[idx2]) > lnum3))
  	    /*
  	     * Special case: if the cursor is just after a zero-count
  	     * block (i.e. all filler) and the target cursor is already
--- 2559,2569 ----
  
  	    return dp->df_lnum[idx2] + baseline;
  	}
! 	if (    (dp->df_lnum[idx1] == lnum1)
! 	     && (dp->df_count[idx1] == 0)
! 	     && (dp->df_lnum[idx2] <= curwin->w_cursor.lnum)
! 	     && ((dp->df_lnum[idx2] + dp->df_count[idx2])
! 						      > curwin->w_cursor.lnum))
  	    /*
  	     * Special case: if the cursor is just after a zero-count
  	     * block (i.e. all filler) and the target cursor is already
***************
*** 2579,2596 ****
  	     * unmoved. This makes repeated CTRL-W W operations work
  	     * as expected.
  	     */
! 	    return lnum3;
  	baseline = (dp->df_lnum[idx1] + dp->df_count[idx1])
  				   - (dp->df_lnum[idx2] + dp->df_count[idx2]);
      }
  
      /* If we get here then the cursor is after the last diff */
!     lnum2 = lnum1 - baseline;
!     /* don't end up past the end of the file */
!     if (lnum2 > buf2->b_ml.ml_line_count)
! 	lnum2 = buf2->b_ml.ml_line_count;
  
!     return lnum2;
  }
  
  #if defined(FEAT_FOLDING) || defined(PROTO)
--- 2571,2598 ----
  	     * unmoved. This makes repeated CTRL-W W operations work
  	     * as expected.
  	     */
! 	    return curwin->w_cursor.lnum;
  	baseline = (dp->df_lnum[idx1] + dp->df_count[idx1])
  				   - (dp->df_lnum[idx2] + dp->df_count[idx2]);
      }
  
      /* If we get here then the cursor is after the last diff */
!     return lnum1 - baseline;
! }
  
! /*
!  * Return the line number in the current window that is closest to "lnum1" in
!  * "buf1" in diff mode.  Checks the line number to be valid.
!  */
!     linenr_T
! diff_get_corresponding_line(buf_T *buf1, linenr_T lnum1)
! {
!     linenr_T lnum = diff_get_corresponding_line_int(buf1, lnum1);
! 
!     /* don't end up past the end of the file */
!     if (lnum > curbuf->b_ml.ml_line_count)
! 	return curbuf->b_ml.ml_line_count;
!     return lnum;
  }
  
  #if defined(FEAT_FOLDING) || defined(PROTO)
*** ../vim-8.0.0043/src/proto/diff.pro	2016-09-12 13:03:59.000000000 +0200
--- src/proto/diff.pro	2016-10-18 14:30:25.208461191 +0200
***************
*** 22,27 ****
  void ex_diffgetput(exarg_T *eap);
  int diff_mode_buf(buf_T *buf);
  int diff_move_to(int dir, long count);
! linenr_T diff_get_corresponding_line(buf_T *buf1, linenr_T lnum1, buf_T *buf2, linenr_T lnum3);
  linenr_T diff_lnum_win(linenr_T lnum, win_T *wp);
  /* vim: set ft=c : */
--- 22,27 ----
  void ex_diffgetput(exarg_T *eap);
  int diff_mode_buf(buf_T *buf);
  int diff_move_to(int dir, long count);
! linenr_T diff_get_corresponding_line(buf_T *buf1, linenr_T lnum1);
  linenr_T diff_lnum_win(linenr_T lnum, win_T *wp);
  /* vim: set ft=c : */
*** ../vim-8.0.0043/src/testdir/test_diffmode.vim	2016-08-27 22:20:56.000000000 +0200
--- src/testdir/test_diffmode.vim	2016-10-18 14:48:01.108678884 +0200
***************
*** 218,220 ****
--- 218,237 ----
    bwipe!
    bwipe!
  endfunc
+ 
+ func Test_setting_cursor()
+   new Xtest1
+   put =range(1,90)
+   wq
+   new Xtest2
+   put =range(1,100)
+   wq
+   
+   tabe Xtest2
+   $
+   diffsp Xtest1
+   tabclose
+ 
+   call delete('Xtest1')
+   call delete('Xtest2')
+ endfunc
*** ../vim-8.0.0043/src/version.c	2016-10-18 13:06:33.377547323 +0200
--- src/version.c	2016-10-18 14:28:23.337359418 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     44,
  /**/

-- 
Zen Microsystems: we're the om in .commmmmmmmm

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0045
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0045
Problem:    Calling job_stop() right after job_start() does not work.
Solution:   Block signals while fork is still busy. (Ozaki Kiichi, closes
            #1155)
Files:      src/auto/configure, src/config.h.in, src/configure.in,
            src/os_unix.c, src/testdir/test_channel.vim


*** ../vim-8.0.0044/src/auto/configure	2016-08-14 17:30:13.000000000 +0200
--- src/auto/configure	2016-10-18 15:38:10.274500411 +0200
***************
*** 12004,12010 ****
  	getpwent getpwnam getpwuid getrlimit gettimeofday getwd lstat memcmp \
  	memset mkdtemp nanosleep opendir putenv qsort readlink select setenv \
  	setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction \
! 	sigvec strcasecmp strerror strftime stricmp strncasecmp \
  	strnicmp strpbrk strtol tgetent towlower towupper iswupper \
  	usleep utime utimes
  do :
--- 12004,12010 ----
  	getpwent getpwnam getpwuid getrlimit gettimeofday getwd lstat memcmp \
  	memset mkdtemp nanosleep opendir putenv qsort readlink select setenv \
  	setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction \
! 	sigprocmask sigvec strcasecmp strerror strftime stricmp strncasecmp \
  	strnicmp strpbrk strtol tgetent towlower towupper iswupper \
  	usleep utime utimes
  do :
*** ../vim-8.0.0044/src/config.h.in	2016-04-24 14:48:57.000000000 +0200
--- src/config.h.in	2016-10-18 15:38:10.274500411 +0200
***************
*** 190,195 ****
--- 190,196 ----
  #undef HAVE_SIGSET
  #undef HAVE_SIGSETJMP
  #undef HAVE_SIGSTACK
+ #undef HAVE_SIGPROCMASK
  #undef HAVE_SIGVEC
  #undef HAVE_SMACK
  #undef HAVE_STRCASECMP
*** ../vim-8.0.0044/src/configure.in	2016-08-14 17:30:09.000000000 +0200
--- src/configure.in	2016-10-18 15:38:10.274500411 +0200
***************
*** 3598,3604 ****
  	getpwent getpwnam getpwuid getrlimit gettimeofday getwd lstat memcmp \
  	memset mkdtemp nanosleep opendir putenv qsort readlink select setenv \
  	setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction \
! 	sigvec strcasecmp strerror strftime stricmp strncasecmp \
  	strnicmp strpbrk strtol tgetent towlower towupper iswupper \
  	usleep utime utimes)
  AC_FUNC_FSEEKO
--- 3598,3604 ----
  	getpwent getpwnam getpwuid getrlimit gettimeofday getwd lstat memcmp \
  	memset mkdtemp nanosleep opendir putenv qsort readlink select setenv \
  	setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction \
! 	sigprocmask sigvec strcasecmp strerror strftime stricmp strncasecmp \
  	strnicmp strpbrk strtol tgetent towlower towupper iswupper \
  	usleep utime utimes)
  AC_FUNC_FSEEKO
*** ../vim-8.0.0044/src/os_unix.c	2016-10-15 18:36:45.349910306 +0200
--- src/os_unix.c	2016-10-18 16:27:09.580836824 +0200
***************
*** 211,216 ****
--- 211,225 ----
  static void catch_int_signal(void);
  static void set_signals(void);
  static void catch_signals(RETSIGTYPE (*func_deadly)(), RETSIGTYPE (*func_other)());
+ #ifdef HAVE_SIGPROCMASK
+ # define SIGSET_DECL(set)	sigset_t set;
+ # define BLOCK_SIGNALS(set)	block_signals(set)
+ # define UNBLOCK_SIGNALS(set)	unblock_signals(set)
+ #else
+ # define SIGSET_DECL(set)
+ # define BLOCK_SIGNALS(set)	do { /**/ } while (0)
+ # define UNBLOCK_SIGNALS(set)	do { /**/ } while (0)
+ #endif
  static int  have_wildcard(int, char_u **);
  static int  have_dollars(int, char_u **);
  
***************
*** 1468,1473 ****
--- 1477,1509 ----
  	    signal(signal_info[i].sig, func_other);
  }
  
+ #ifdef HAVE_SIGPROCMASK
+     static void
+ block_signals(sigset_t *set)
+ {
+     sigset_t	newset;
+     int		i;
+ 
+     sigemptyset(&newset);
+ 
+     for (i = 0; signal_info[i].sig != -1; i++)
+ 	sigaddset(&newset, signal_info[i].sig);
+ 
+ # if defined(_REENTRANT) && defined(SIGCONT)
+     /* SIGCONT isn't in the list, because its default action is ignore */
+     sigaddset(&newset, SIGCONT);
+ # endif
+ 
+     sigprocmask(SIG_BLOCK, &newset, set);
+ }
+ 
+     static void
+ unblock_signals(sigset_t *set)
+ {
+     sigprocmask(SIG_SETMASK, set, NULL);
+ }
+ #endif
+ 
  /*
   * Handling of SIGHUP, SIGQUIT and SIGTERM:
   * "when" == a signal:       when busy, postpone and return FALSE, otherwise
***************
*** 4283,4294 ****
  
      if (!pipe_error)			/* pty or pipe opened or not used */
      {
  # ifdef __BEOS__
  	beos_cleanup_read_thread();
  # endif
  
! 	if ((pid = fork()) == -1)	/* maybe we should use vfork() */
  	{
  	    MSG_PUTS(_("\nCannot fork\n"));
  	    if ((options & (SHELL_READ|SHELL_WRITE))
  # ifdef FEAT_GUI
--- 4319,4336 ----
  
      if (!pipe_error)			/* pty or pipe opened or not used */
      {
+ 	SIGSET_DECL(curset)
+ 
  # ifdef __BEOS__
  	beos_cleanup_read_thread();
  # endif
  
! 	BLOCK_SIGNALS(&curset);
! 	pid = fork();	/* maybe we should use vfork() */
! 	if (pid == -1)
  	{
+ 	    UNBLOCK_SIGNALS(&curset);
+ 
  	    MSG_PUTS(_("\nCannot fork\n"));
  	    if ((options & (SHELL_READ|SHELL_WRITE))
  # ifdef FEAT_GUI
***************
*** 4315,4320 ****
--- 4357,4363 ----
  	else if (pid == 0)	/* child */
  	{
  	    reset_signals();		/* handle signals normally */
+ 	    UNBLOCK_SIGNALS(&curset);
  
  	    if (!show_shell_mess || (options & SHELL_EXPAND))
  	    {
***************
*** 4458,4463 ****
--- 4501,4507 ----
  	     */
  	    catch_signals(SIG_IGN, SIG_ERR);
  	    catch_int_signal();
+ 	    UNBLOCK_SIGNALS(&curset);
  
  	    /*
  	     * For the GUI we redirect stdin, stdout and stderr to our window.
***************
*** 5069,5074 ****
--- 5113,5119 ----
      int		use_file_for_out = options->jo_io[PART_OUT] == JIO_FILE;
      int		use_file_for_err = options->jo_io[PART_ERR] == JIO_FILE;
      int		use_out_for_err = options->jo_io[PART_ERR] == JIO_OUT;
+     SIGSET_DECL(curset)
  
      if (use_out_for_err && use_null_for_out)
  	use_null_for_err = TRUE;
***************
*** 5140,5152 ****
  	    goto failed;
      }
  
      pid = fork();	/* maybe we should use vfork() */
!     if (pid  == -1)
      {
  	/* failed to fork */
  	goto failed;
      }
- 
      if (pid == 0)
      {
  	int	null_fd = -1;
--- 5185,5198 ----
  	    goto failed;
      }
  
+     BLOCK_SIGNALS(&curset);
      pid = fork();	/* maybe we should use vfork() */
!     if (pid == -1)
      {
  	/* failed to fork */
+ 	UNBLOCK_SIGNALS(&curset);
  	goto failed;
      }
      if (pid == 0)
      {
  	int	null_fd = -1;
***************
*** 5154,5159 ****
--- 5200,5206 ----
  
  	/* child */
  	reset_signals();		/* handle signals normally */
+ 	UNBLOCK_SIGNALS(&curset);
  
  # ifdef HAVE_SETSID
  	/* Create our own process group, so that the child and all its
***************
*** 5234,5239 ****
--- 5281,5288 ----
      }
  
      /* parent */
+     UNBLOCK_SIGNALS(&curset);
+ 
      job->jv_pid = pid;
      job->jv_status = JOB_STARTED;
      job->jv_channel = channel;  /* ch_refcount was set above */
***************
*** 5357,5363 ****
  	}
      }
      return NULL;
- 
  }
  
      int
--- 5406,5411 ----
*** ../vim-8.0.0044/src/testdir/test_channel.vim	2016-10-15 18:36:45.353910276 +0200
--- src/testdir/test_channel.vim	2016-10-18 15:38:10.274500411 +0200
***************
*** 1433,1438 ****
--- 1433,1453 ----
    call assert_fails('call job_start("")', 'E474:')
  endfunc
  
+ func Test_job_stop_immediately()
+   if !has('job')
+     return
+   endif
+ 
+   let job = job_start([s:python, '-c', 'import time;time.sleep(10)'])
+   try
+     call job_stop(job)
+     call WaitFor('"dead" == job_status(job)')
+     call assert_equal('dead', job_status(job))
+   finally
+     call job_stop(job, 'kill')
+   endtry
+ endfunc
+ 
  " This was leaking memory.
  func Test_partial_in_channel_cycle()
    let d = {}
*** ../vim-8.0.0044/src/version.c	2016-10-18 14:50:14.731694041 +0200
--- src/version.c	2016-10-18 16:25:17.693661467 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     45,
  /**/

-- 
Females are strictly forbidden to appear unshaven in public.
		[real standing law in New Mexico, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0046
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0046
Problem:    Using NUL instead of NULL.
Solution:   Change to NULL. (Dominique Pelle)
Files:      src/ex_cmds.c, src/json.c


*** ../vim-8.0.0045/src/ex_cmds.c	2016-10-12 14:19:55.742357780 +0200
--- src/ex_cmds.c	2016-10-21 20:33:45.713617892 +0200
***************
*** 6908,6914 ****
  				    continue;
  				e1 = vim_strrchr(t1, '.');
  				e2 = vim_strrchr(gettail(f2), '.');
! 				if (e1 == NUL || e2 == NUL)
  				    continue;
  				if (fnamecmp(e1, ".txt") != 0
  				    && fnamecmp(e1, fname + 4) != 0)
--- 6908,6914 ----
  				    continue;
  				e1 = vim_strrchr(t1, '.');
  				e2 = vim_strrchr(gettail(f2), '.');
! 				if (e1 == NULL || e2 == NULL)
  				    continue;
  				if (fnamecmp(e1, ".txt") != 0
  				    && fnamecmp(e1, fname + 4) != 0)
***************
*** 8205,8211 ****
      /* :sign define {name} {args}... {last}=
       *				     |	   |
       *				  last	   p */
!     if (p == NUL)
      {
  	/* Expand last argument name (before equal sign). */
  	xp->xp_pattern = last;
--- 8205,8211 ----
      /* :sign define {name} {args}... {last}=
       *				     |	   |
       *				  last	   p */
!     if (p == NULL)
      {
  	/* Expand last argument name (before equal sign). */
  	xp->xp_pattern = last;
*** ../vim-8.0.0045/src/json.c	2016-08-29 22:42:20.000000000 +0200
--- src/json.c	2016-10-21 20:33:45.717617866 +0200
***************
*** 861,867 ****
  	    break;
      }
  
!     if (res != NUL)
      {
  	res->v_type = VAR_SPECIAL;
  	res->vval.v_number = VVAL_NONE;
--- 861,867 ----
  	    break;
      }
  
!     if (res != NULL)
      {
  	res->v_type = VAR_SPECIAL;
  	res->vval.v_number = VVAL_NONE;
*** ../vim-8.0.0045/src/version.c	2016-10-18 16:27:20.544756017 +0200
--- src/version.c	2016-10-21 20:34:37.841288951 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     46,
  /**/

-- 
"I love deadlines.  I especially like the whooshing sound they
make as they go flying by."
                         -- Douglas Adams

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0047
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0047
Problem:    Crash when using the preview window from an unnamed buffer.
            (lifepillar)
Solution:   Do not clear the wrong buffer. (closes #1200)
Files:      src/popupmnu.c


*** ../vim-8.0.0046/src/popupmnu.c	2016-08-29 22:42:20.000000000 +0200
--- src/popupmnu.c	2016-10-27 14:29:30.530187340 +0200
***************
*** 582,588 ****
  
  	    if (curwin->w_p_pvw)
  	    {
! 		if (curbuf->b_fname == NULL
  			&& curbuf->b_p_bt[0] == 'n' && curbuf->b_p_bt[2] == 'f'
  			&& curbuf->b_p_bh[0] == 'w')
  		{
--- 582,590 ----
  
  	    if (curwin->w_p_pvw)
  	    {
! 		if (!resized
! 			&& curbuf->b_nwindows == 1
! 			&& curbuf->b_fname == NULL
  			&& curbuf->b_p_bt[0] == 'n' && curbuf->b_p_bt[2] == 'f'
  			&& curbuf->b_p_bh[0] == 'w')
  		{
*** ../vim-8.0.0046/src/version.c	2016-10-21 20:35:32.632943225 +0200
--- src/version.c	2016-10-27 14:48:11.623357275 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     47,
  /**/

-- 
"I've been teaching myself to play the piano for about 5 years and now write
most of my songs on it, mainly because I can never find any paper."
		Jeff Lynne, ELO's greatest hits

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0048
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0048
Problem:    On Windows job_stop() stops cmd.exe, not the processes it runs.
            (Linwei)
Solution:   Iterate over all processes and terminate the one where the parent
            is the job process. (Yasuhiro Matsumoto, closes #1184)
Files:      src/os_win32.c, src/structs.h


*** ../vim-8.0.0047/src/os_win32.c	2016-10-15 18:36:45.353910276 +0200
--- src/os_win32.c	2016-10-27 16:42:55.597417857 +0200
***************
*** 50,55 ****
--- 50,59 ----
  # endif
  #endif
  
+ #ifdef FEAT_JOB_CHANNEL
+ # include <tlhelp32.h>
+ #endif
+ 
  #ifdef __MINGW32__
  # ifndef FROM_LEFT_1ST_BUTTON_PRESSED
  #  define FROM_LEFT_1ST_BUTTON_PRESSED    0x0001
***************
*** 4796,4802 ****
  {
      STARTUPINFO		si;
      PROCESS_INFORMATION	pi;
-     HANDLE		jo;
      SECURITY_ATTRIBUTES saAttr;
      channel_T		*channel = NULL;
      HANDLE		ifd[2];
--- 4800,4805 ----
***************
*** 4821,4833 ****
      efd[0] = INVALID_HANDLE_VALUE;
      efd[1] = INVALID_HANDLE_VALUE;
  
-     jo = CreateJobObject(NULL, NULL);
-     if (jo == NULL)
-     {
- 	job->jv_status = JOB_FAILED;
- 	goto failed;
-     }
- 
      ZeroMemory(&pi, sizeof(pi));
      ZeroMemory(&si, sizeof(si));
      si.cb = sizeof(si);
--- 4824,4829 ----
***************
*** 4912,4939 ****
      }
  
      if (!vim_create_process(cmd, TRUE,
- 	    CREATE_SUSPENDED |
  	    CREATE_DEFAULT_ERROR_MODE |
  	    CREATE_NEW_PROCESS_GROUP |
  	    CREATE_NEW_CONSOLE,
  	    &si, &pi))
      {
- 	CloseHandle(jo);
  	job->jv_status = JOB_FAILED;
  	goto failed;
      }
  
-     if (!AssignProcessToJobObject(jo, pi.hProcess))
-     {
- 	/* if failing, switch the way to terminate
- 	 * process with TerminateProcess. */
- 	CloseHandle(jo);
- 	jo = NULL;
-     }
-     ResumeThread(pi.hThread);
      CloseHandle(pi.hThread);
      job->jv_proc_info = pi;
-     job->jv_job_object = jo;
      job->jv_status = JOB_STARTED;
  
      CloseHandle(ifd[0]);
--- 4908,4924 ----
***************
*** 5020,5025 ****
--- 5005,5048 ----
      return NULL;
  }
  
+     static BOOL
+ terminate_all(HANDLE process, int code)
+ {
+     PROCESSENTRY32  pe;
+     HANDLE	    h = INVALID_HANDLE_VALUE;
+     DWORD	    pid = GetProcessId(process);
+ 
+     if (pid != 0)
+     {
+ 	h = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
+ 	if (h == INVALID_HANDLE_VALUE)
+ 	    goto theend;
+ 
+ 	pe.dwSize = sizeof(PROCESSENTRY32);
+ 	if (Process32First(h, &pe))
+ 	{
+ 	    do
+ 	    {
+ 		if (pe.th32ParentProcessID == pid)
+ 		{
+ 		    HANDLE ph = OpenProcess(
+ 				  PROCESS_ALL_ACCESS, FALSE, pe.th32ProcessID);
+ 		    if (ph != NULL)
+ 		    {
+ 			terminate_all(ph, code);
+ 			CloseHandle(ph);
+ 		    }
+ 		}
+ 	    } while (Process32Next(h, &pe));
+ 	}
+ 
+ 	CloseHandle(h);
+     }
+ 
+ theend:
+     return TerminateProcess(process, code);
+ }
+ 
      int
  mch_stop_job(job_T *job, char_u *how)
  {
***************
*** 5027,5036 ****
  
      if (STRCMP(how, "term") == 0 || STRCMP(how, "kill") == 0 || *how == NUL)
      {
! 	if (job->jv_job_object != NULL)
! 	    return TerminateJobObject(job->jv_job_object, 0) ? OK : FAIL;
! 	else
! 	    return TerminateProcess(job->jv_proc_info.hProcess, 0) ? OK : FAIL;
      }
  
      if (!AttachConsole(job->jv_proc_info.dwProcessId))
--- 5050,5056 ----
  
      if (STRCMP(how, "term") == 0 || STRCMP(how, "kill") == 0 || *how == NUL)
      {
! 	return terminate_all(job->jv_proc_info.hProcess, 0) ? OK : FAIL;
      }
  
      if (!AttachConsole(job->jv_proc_info.dwProcessId))
***************
*** 5051,5058 ****
  {
      if (job->jv_status != JOB_FAILED)
      {
- 	if (job->jv_job_object != NULL)
- 	    CloseHandle(job->jv_job_object);
  	CloseHandle(job->jv_proc_info.hProcess);
      }
  }
--- 5071,5076 ----
*** ../vim-8.0.0047/src/structs.h	2016-10-09 17:27:56.863388510 +0200
--- src/structs.h	2016-10-27 16:36:49.151650364 +0200
***************
*** 1437,1443 ****
  #endif
  #ifdef WIN32
      PROCESS_INFORMATION	jv_proc_info;
-     HANDLE		jv_job_object;
  #endif
      jobstatus_T	jv_status;
      char_u	*jv_stoponexit; /* allocated */
--- 1437,1442 ----
*** ../vim-8.0.0047/src/version.c	2016-10-27 14:49:11.022995393 +0200
--- src/version.c	2016-10-27 16:38:42.722958450 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     48,
  /**/

-- 
FIRST SOLDIER:  So they wouldn't be able to bring a coconut back anyway.
SECOND SOLDIER: Wait a minute! Suppose two swallows carried it together?
FIRST SOLDIER:  No, they'd have to have it on a line.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0049
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0049
Problem:    When a match ends in part of concealed text highlighting, it might
            mess up concealing by resetting prev_syntax_id.
Solution:   Do not reset prev_syntax_id and add a test to verify. (Christian
            Brabandt, closes #1092)
Files:      src/screen.c, src/testdir/test_matchadd_conceal.vim


*** ../vim-8.0.0048/src/screen.c	2016-10-16 14:35:44.543696445 +0200
--- src/screen.c	2016-10-27 17:26:54.065343448 +0200
***************
*** 3981,3989 ****
  			else if (v == (long)shl->endcol)
  			{
  			    shl->attr_cur = 0;
- #ifdef FEAT_CONCEAL
- 			    prev_syntax_id = 0;
- #endif
  			    next_search_hl(wp, shl, lnum, (colnr_T)v,
  					       shl == &search_hl ? NULL : cur);
  			    pos_inprogress = cur == NULL || cur->pos.cur == 0
--- 3981,3986 ----
*** ../vim-8.0.0048/src/testdir/test_matchadd_conceal.vim	2016-04-14 17:59:07.000000000 +0200
--- src/testdir/test_matchadd_conceal.vim	2016-10-27 17:20:24.939714129 +0200
***************
*** 264,266 ****
--- 264,288 ----
  
    quit!
  endfunction
+ 
+ function! Test_matchadd_and_syn_conceal()
+   new
+   let cnt='Inductive bool : Type := | true : bool | false : bool.'
+   let expect = 'Inductive - : Type := | true : - | false : -.'
+   0put =cnt
+   " set filetype and :syntax on to change screenattr()
+   set cole=1 cocu=nv
+   hi link CheckedByCoq WarningMsg
+   syntax on
+   syntax keyword coqKwd bool conceal cchar=-
+   redraw!
+   call assert_equal(expect, s:screenline(1))
+   call assert_notequal(screenattr(1, 10) , screenattr(1, 11))
+   call assert_notequal(screenattr(1, 11) , screenattr(1, 12))
+   call assert_equal(screenattr(1, 11) , screenattr(1, 32))
+   call matchadd('CheckedByCoq', '\%<2l\%>9c\%<16c')
+   call assert_equal(expect, s:screenline(1))
+   call assert_notequal(screenattr(1, 10) , screenattr(1, 11))
+   call assert_notequal(screenattr(1, 11) , screenattr(1, 12))
+   call assert_equal(screenattr(1, 11) , screenattr(1, 32))
+ endfunction
*** ../vim-8.0.0048/src/version.c	2016-10-27 16:46:49.423993309 +0200
--- src/version.c	2016-10-27 17:20:49.627563722 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     49,
  /**/

-- 
If you don't get everything you want, think of
everything you didn't get and don't want.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0050
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0050
Problem:    An exiting job is detected with a large latency.
Solution:   Check for pending job more often. (Ozaki Kiichi)  Change the
            double loop in mch_inchar() into one.
Files:      src/channel.c, src/os_unix.c, src/testdir/shared.vim,
            src/testdir/test_channel.vim


*** ../vim-8.0.0049/src/channel.c	2016-10-15 18:36:45.341910365 +0200
--- src/channel.c	2016-10-27 19:49:15.597305647 +0200
***************
*** 4643,4650 ****
  }
  
  /*
!  * Return TRUE when there is any job that might exit, which means
!  * job_check_ended() should be called once in a while.
   */
      int
  has_pending_job(void)
--- 4643,4650 ----
  }
  
  /*
!  * Return TRUE when there is any job that has an exit callback and might exit,
!  * which means job_check_ended() should be called more often.
   */
      int
  has_pending_job(void)
***************
*** 4652,4658 ****
      job_T	    *job;
  
      for (job = first_job; job != NULL; job = job->jv_next)
! 	if (job_still_alive(job))
  	    return TRUE;
      return FALSE;
  }
--- 4652,4662 ----
      job_T	    *job;
  
      for (job = first_job; job != NULL; job = job->jv_next)
! 	/* Only should check if the channel has been closed, if the channel is
! 	 * open the job won't exit. */
! 	if (job->jv_status == JOB_STARTED && job->jv_exit_cb != NULL
! 		&& (job->jv_channel == NULL
! 		    || !channel_still_useful(job->jv_channel)))
  	    return TRUE;
      return FALSE;
  }
*** ../vim-8.0.0049/src/os_unix.c	2016-10-18 16:27:20.544756017 +0200
--- src/os_unix.c	2016-10-27 19:43:31.019404929 +0200
***************
*** 404,542 ****
  {
      int		len;
      int		interrupted = FALSE;
      long	wait_time;
  #if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
      struct timeval  start_tv;
  
      gettimeofday(&start_tv, NULL);
  #endif
  
! #ifdef MESSAGE_QUEUE
!     parse_queued_messages();
! #endif
! 
!     /* Check if window changed size while we were busy, perhaps the ":set
!      * columns=99" command was used. */
!     while (do_resize)
! 	handle_resize();
! 
      for (;;)
      {
! 	if (wtime >= 0)
! 	    wait_time = wtime;
! 	else
! 	    wait_time = p_ut;
! #if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
! 	wait_time -= elapsed(&start_tv);
! 	if (wait_time >= 0)
! 	{
! #endif
! 	    if (WaitForChar(wait_time, &interrupted))
! 		break;
  
- 	    /* no character available */
- 	    if (do_resize)
- 	    {
- 		handle_resize();
- 		continue;
- 	    }
- #ifdef FEAT_CLIENTSERVER
- 	    if (server_waiting())
- 	    {
- 		parse_queued_messages();
- 		continue;
- 	    }
- #endif
  #ifdef MESSAGE_QUEUE
! 	    if (interrupted)
! 	    {
! 		parse_queued_messages();
! 		continue;
! 	    }
  #endif
  #if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
! 	}
  #endif
! 	if (wtime >= 0)
! 	    /* no character available within "wtime" */
! 	    return 0;
! 
! 	/* wtime == -1: no character available within 'updatetime' */
  #ifdef FEAT_AUTOCMD
! 	if (trigger_cursorhold() && maxlen >= 3
! 					   && !typebuf_changed(tb_change_cnt))
! 	{
! 	    buf[0] = K_SPECIAL;
! 	    buf[1] = KS_EXTRA;
! 	    buf[2] = (int)KE_CURSORHOLD;
! 	    return 3;
  	}
- #endif
- 	/*
- 	 * If there is no character available within 'updatetime' seconds
- 	 * flush all the swap files to disk.
- 	 * Also done when interrupted by SIGWINCH.
- 	 */
- 	before_blocking();
- 	break;
-     }
- 
-     /* repeat until we got a character */
-     for (;;)
-     {
- 	long	wtime_now = -1L;
- 
- 	while (do_resize)    /* window changed size */
- 	    handle_resize();
- 
- #ifdef MESSAGE_QUEUE
- 	parse_queued_messages();
  
! # ifdef FEAT_JOB_CHANNEL
! 	if (has_pending_job())
! 	{
! 	    /* Don't wait longer than a few seconds, checking for a finished
! 	     * job requires polling. */
! 	    if (p_ut > 9000L)
! 		wtime_now = 1000L;
! 	    else
! 		wtime_now = 10000L - p_ut;
! 	}
! # endif
  #endif
  	/*
  	 * We want to be interrupted by the winch signal
  	 * or by an event on the monitored file descriptors.
  	 */
! 	if (!WaitForChar(wtime_now, &interrupted))
  	{
! 	    if (do_resize)	    /* interrupted by SIGWINCH signal */
! 		continue;
! #ifdef MESSAGE_QUEUE
! 	    if (interrupted || wtime_now > 0)
! 	    {
! 		parse_queued_messages();
! 		continue;
! 	    }
! #endif
! 	    return 0;
  	}
  
! 	/* If input was put directly in typeahead buffer bail out here. */
! 	if (typebuf_changed(tb_change_cnt))
! 	    return 0;
  
! 	/*
! 	 * For some terminals we only get one character at a time.
! 	 * We want the get all available characters, so we could keep on
! 	 * trying until none is available
! 	 * For some other terminals this is quite slow, that's why we don't do
! 	 * it.
! 	 */
! 	len = read_from_input_buf(buf, (long)maxlen);
! 	if (len > 0)
! 	    return len;
      }
  }
  
      static void
--- 404,524 ----
  {
      int		len;
      int		interrupted = FALSE;
+     int		did_start_blocking = FALSE;
      long	wait_time;
+     long	elapsed_time = 0;
  #if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
      struct timeval  start_tv;
  
      gettimeofday(&start_tv, NULL);
  #endif
  
!     /* repeat until we got a character or waited long enough */
      for (;;)
      {
! 	/* Check if window changed size while we were busy, perhaps the ":set
! 	 * columns=99" command was used. */
! 	while (do_resize)
! 	    handle_resize();
  
  #ifdef MESSAGE_QUEUE
! 	parse_queued_messages();
  #endif
+ 	if (wtime < 0 && did_start_blocking)
+ 	    /* blocking and already waited for p_ut */
+ 	    wait_time = -1;
+ 	else
+ 	{
+ 	    if (wtime >= 0)
+ 		wait_time = wtime;
+ 	    else
+ 		/* going to block after p_ut */
+ 		wait_time = p_ut;
  #if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
! 	    elapsed_time = elapsed(&start_tv);
  #endif
! 	    wait_time -= elapsed_time;
! 	    if (wait_time < 0)
! 	    {
! 		if (wtime >= 0)
! 		    /* no character available within "wtime" */
! 		    return 0;
! 
! 		if (wtime < 0)
! 		{
! 		    /* no character available within 'updatetime' */
! 		    did_start_blocking = TRUE;
  #ifdef FEAT_AUTOCMD
! 		    if (trigger_cursorhold() && maxlen >= 3
! 					    && !typebuf_changed(tb_change_cnt))
! 		    {
! 			buf[0] = K_SPECIAL;
! 			buf[1] = KS_EXTRA;
! 			buf[2] = (int)KE_CURSORHOLD;
! 			return 3;
! 		    }
! #endif
! 		    /*
! 		     * If there is no character available within 'updatetime'
! 		     * seconds flush all the swap files to disk.
! 		     * Also done when interrupted by SIGWINCH.
! 		     */
! 		    before_blocking();
! 		    continue;
! 		}
! 	    }
  	}
  
! #ifdef FEAT_JOB_CHANNEL
! 	/* Checking if a job ended requires polling.  Do this every 100 msec. */
! 	if (has_pending_job() && (wait_time < 0 || wait_time > 100L))
! 	    wait_time = 100L;
  #endif
+ 
  	/*
  	 * We want to be interrupted by the winch signal
  	 * or by an event on the monitored file descriptors.
  	 */
! 	if (WaitForChar(wait_time, &interrupted))
  	{
! 	    /* If input was put directly in typeahead buffer bail out here. */
! 	    if (typebuf_changed(tb_change_cnt))
! 		return 0;
! 
! 	    /*
! 	     * For some terminals we only get one character at a time.
! 	     * We want the get all available characters, so we could keep on
! 	     * trying until none is available
! 	     * For some other terminals this is quite slow, that's why we don't
! 	     * do it.
! 	     */
! 	    len = read_from_input_buf(buf, (long)maxlen);
! 	    if (len > 0)
! 		return len;
! 	    continue;
  	}
  
! 	/* no character available */
! #if !(defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H))
! 	/* estimate the elapsed time */
! 	elapsed += wait_time;
! #endif
  
! 	if (do_resize	    /* interrupted by SIGWINCH signal */
! #ifdef FEAT_CLIENTSERVER
! 		|| server_waiting()
! #endif
! #ifdef MESSAGE_QUEUE
! 		|| interrupted
! #endif
! 		|| wait_time > 0
! 		|| !did_start_blocking)
! 	    continue;
! 
! 	/* no character available or interrupted */
! 	break;
      }
+     return 0;
  }
  
      static void
*** ../vim-8.0.0049/src/testdir/shared.vim	2016-08-22 21:30:05.000000000 +0200
--- src/testdir/shared.vim	2016-10-27 19:51:53.040346452 +0200
***************
*** 136,141 ****
--- 136,169 ----
    return 1000
  endfunc
  
+ " Wait for up to a given milliseconds.
+ " With the +timers feature this waits for key-input by getchar(), Resume()
+ " feeds key-input and resumes process. Return time waited in milliseconds.
+ " Without +timers it uses simply :sleep.
+ func Standby(msec)
+   if has('timers')
+     let start = reltime()
+     let g:_standby_timer = timer_start(a:msec, function('s:feedkeys'))
+     call getchar()
+     return float2nr(reltimefloat(reltime(start)) * 1000)
+   else
+     execute 'sleep ' a:msec . 'm'
+     return a:msec
+   endif
+ endfunc
+ 
+ func Resume()
+   if exists('g:_standby_timer')
+     call timer_stop(g:_standby_timer)
+     call s:feedkeys(0)
+     unlet g:_standby_timer
+   endif
+ endfunc
+ 
+ func s:feedkeys(timer)
+   call feedkeys('x', 'nt')
+ endfunc
+ 
  " Run Vim, using the "vimcmd" file and "-u NORC".
  " "before" is a list of Vim commands to be executed before loading plugins.
  " "after" is a list of Vim commands to be executed after loading plugins.
*** ../vim-8.0.0049/src/testdir/test_channel.vim	2016-10-18 16:27:20.544756017 +0200
--- src/testdir/test_channel.vim	2016-10-27 18:09:46.713670034 +0200
***************
*** 1362,1370 ****
    endif
  endfunc
  
- let g:exit_cb_time = {'start': 0, 'end': 0}
  function MyExitTimeCb(job, status)
!   let g:exit_cb_time.end = reltime(g:exit_cb_time.start)
  endfunction
  
  func Test_exit_callback_interval()
--- 1362,1372 ----
    endif
  endfunc
  
  function MyExitTimeCb(job, status)
!   if job_info(a:job).process == g:exit_cb_val.process
!     let g:exit_cb_val.end = reltime(g:exit_cb_val.start)
!   endif
!   call Resume()
  endfunction
  
  func Test_exit_callback_interval()
***************
*** 1372,1382 ****
      return
    endif
  
!   let g:exit_cb_time.start = reltime()
    let job = job_start([s:python, '-c', 'import time;time.sleep(0.5)'], {'exit_cb': 'MyExitTimeCb'})
!   call WaitFor('g:exit_cb_time.end != 0')
!   let elapsed = reltimefloat(g:exit_cb_time.end)
!   call assert_true(elapsed > 0.3)
    call assert_true(elapsed < 1.0)
  endfunc
  
--- 1374,1403 ----
      return
    endif
  
!   let g:exit_cb_val = {'start': reltime(), 'end': 0, 'process': 0}
    let job = job_start([s:python, '-c', 'import time;time.sleep(0.5)'], {'exit_cb': 'MyExitTimeCb'})
!   let g:exit_cb_val.process = job_info(job).process
!   call WaitFor('type(g:exit_cb_val.end) != v:t_number || g:exit_cb_val.end != 0')
!   let elapsed = reltimefloat(g:exit_cb_val.end)
!   call assert_true(elapsed > 0.5)
!   call assert_true(elapsed < 1.0)
! 
!   " case: unreferenced job, using timer
!   if !has('timers')
!     return
!   endif
! 
!   let g:exit_cb_val = {'start': reltime(), 'end': 0, 'process': 0}
!   let g:job = job_start([s:python, '-c', 'import time;time.sleep(0.5)'], {'exit_cb': 'MyExitTimeCb'})
!   let g:exit_cb_val.process = job_info(g:job).process
!   unlet g:job
!   call Standby(1000)
!   if type(g:exit_cb_val.end) != v:t_number || g:exit_cb_val.end != 0
!     let elapsed = reltimefloat(g:exit_cb_val.end)
!   else
!     let elapsed = 1.0
!   endif
!   call assert_true(elapsed > 0.5)
    call assert_true(elapsed < 1.0)
  endfunc
  
*** ../vim-8.0.0049/src/version.c	2016-10-27 17:27:38.269074145 +0200
--- src/version.c	2016-10-27 19:54:19.827452177 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     50,
  /**/

-- 
CART DRIVER: Bring out your dead!
   We follow the cart through a wretched, impoverished plague-ridden village.
   A few starved mongrels run about in the mud scavenging.  In the open
   doorway of one house perhaps we jug glimpse a pair of legs dangling from
   the ceiling.  In another doorway an OLD WOMAN is beating a cat against a
   wall rather like one does with a mat.  The cart passes round a dead donkey
   or cow in the mud.  And a MAN tied to a cart is being hammered to death by
   four NUNS with huge mallets.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0051
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0051 (after 8.0.0048)
Problem:    New code for job_stop() breaks channel test on AppVeyor.
Solution:   Revert the change.
Files:      src/os_win32.c, src/structs.h


*** ../vim-8.0.0050/src/os_win32.c	2016-10-27 16:46:49.419993332 +0200
--- src/os_win32.c	2016-10-27 21:11:18.235315329 +0200
***************
*** 50,59 ****
  # endif
  #endif
  
- #ifdef FEAT_JOB_CHANNEL
- # include <tlhelp32.h>
- #endif
- 
  #ifdef __MINGW32__
  # ifndef FROM_LEFT_1ST_BUTTON_PRESSED
  #  define FROM_LEFT_1ST_BUTTON_PRESSED    0x0001
--- 50,55 ----
***************
*** 4800,4805 ****
--- 4796,4802 ----
  {
      STARTUPINFO		si;
      PROCESS_INFORMATION	pi;
+     HANDLE		jo;
      SECURITY_ATTRIBUTES saAttr;
      channel_T		*channel = NULL;
      HANDLE		ifd[2];
***************
*** 4824,4829 ****
--- 4821,4833 ----
      efd[0] = INVALID_HANDLE_VALUE;
      efd[1] = INVALID_HANDLE_VALUE;
  
+     jo = CreateJobObject(NULL, NULL);
+     if (jo == NULL)
+     {
+ 	job->jv_status = JOB_FAILED;
+ 	goto failed;
+     }
+ 
      ZeroMemory(&pi, sizeof(pi));
      ZeroMemory(&si, sizeof(si));
      si.cb = sizeof(si);
***************
*** 4908,4924 ****
--- 4912,4939 ----
      }
  
      if (!vim_create_process(cmd, TRUE,
+ 	    CREATE_SUSPENDED |
  	    CREATE_DEFAULT_ERROR_MODE |
  	    CREATE_NEW_PROCESS_GROUP |
  	    CREATE_NEW_CONSOLE,
  	    &si, &pi))
      {
+ 	CloseHandle(jo);
  	job->jv_status = JOB_FAILED;
  	goto failed;
      }
  
+     if (!AssignProcessToJobObject(jo, pi.hProcess))
+     {
+ 	/* if failing, switch the way to terminate
+ 	 * process with TerminateProcess. */
+ 	CloseHandle(jo);
+ 	jo = NULL;
+     }
+     ResumeThread(pi.hThread);
      CloseHandle(pi.hThread);
      job->jv_proc_info = pi;
+     job->jv_job_object = jo;
      job->jv_status = JOB_STARTED;
  
      CloseHandle(ifd[0]);
***************
*** 5005,5048 ****
      return NULL;
  }
  
-     static BOOL
- terminate_all(HANDLE process, int code)
- {
-     PROCESSENTRY32  pe;
-     HANDLE	    h = INVALID_HANDLE_VALUE;
-     DWORD	    pid = GetProcessId(process);
- 
-     if (pid != 0)
-     {
- 	h = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
- 	if (h == INVALID_HANDLE_VALUE)
- 	    goto theend;
- 
- 	pe.dwSize = sizeof(PROCESSENTRY32);
- 	if (Process32First(h, &pe))
- 	{
- 	    do
- 	    {
- 		if (pe.th32ParentProcessID == pid)
- 		{
- 		    HANDLE ph = OpenProcess(
- 				  PROCESS_ALL_ACCESS, FALSE, pe.th32ProcessID);
- 		    if (ph != NULL)
- 		    {
- 			terminate_all(ph, code);
- 			CloseHandle(ph);
- 		    }
- 		}
- 	    } while (Process32Next(h, &pe));
- 	}
- 
- 	CloseHandle(h);
-     }
- 
- theend:
-     return TerminateProcess(process, code);
- }
- 
      int
  mch_stop_job(job_T *job, char_u *how)
  {
--- 5020,5025 ----
***************
*** 5050,5056 ****
  
      if (STRCMP(how, "term") == 0 || STRCMP(how, "kill") == 0 || *how == NUL)
      {
! 	return terminate_all(job->jv_proc_info.hProcess, 0) ? OK : FAIL;
      }
  
      if (!AttachConsole(job->jv_proc_info.dwProcessId))
--- 5027,5036 ----
  
      if (STRCMP(how, "term") == 0 || STRCMP(how, "kill") == 0 || *how == NUL)
      {
! 	if (job->jv_job_object != NULL)
! 	    return TerminateJobObject(job->jv_job_object, 0) ? OK : FAIL;
! 	else
! 	    return TerminateProcess(job->jv_proc_info.hProcess, 0) ? OK : FAIL;
      }
  
      if (!AttachConsole(job->jv_proc_info.dwProcessId))
***************
*** 5071,5076 ****
--- 5051,5058 ----
  {
      if (job->jv_status != JOB_FAILED)
      {
+ 	if (job->jv_job_object != NULL)
+ 	    CloseHandle(job->jv_job_object);
  	CloseHandle(job->jv_proc_info.hProcess);
      }
  }
*** ../vim-8.0.0050/src/structs.h	2016-10-27 16:46:49.423993309 +0200
--- src/structs.h	2016-10-27 21:11:27.439259254 +0200
***************
*** 1437,1442 ****
--- 1437,1443 ----
  #endif
  #ifdef WIN32
      PROCESS_INFORMATION	jv_proc_info;
+     HANDLE		jv_job_object;
  #endif
      jobstatus_T	jv_status;
      char_u	*jv_stoponexit; /* allocated */
*** ../vim-8.0.0050/src/version.c	2016-10-27 20:00:03.665357405 +0200
--- src/version.c	2016-10-27 21:12:22.526923642 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     51,
  /**/

-- 
BODY:        I'm not dead!
CART DRIVER: 'Ere.  He says he's not dead.
LARGE MAN:   Yes he is.
BODY:        I'm not!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0052
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0052 (after 8.0.0049)
Problem:    Conceal test passes even without the bug fix.
Solution:   Add a redraw command. (Christian Brabandt)
Files:      src/testdir/test_matchadd_conceal.vim


*** ../vim-8.0.0051/src/testdir/test_matchadd_conceal.vim	2016-10-27 17:27:38.265074170 +0200
--- src/testdir/test_matchadd_conceal.vim	2016-10-28 22:06:28.144773262 +0200
***************
*** 281,286 ****
--- 281,287 ----
    call assert_notequal(screenattr(1, 11) , screenattr(1, 12))
    call assert_equal(screenattr(1, 11) , screenattr(1, 32))
    call matchadd('CheckedByCoq', '\%<2l\%>9c\%<16c')
+   redraw!
    call assert_equal(expect, s:screenline(1))
    call assert_notequal(screenattr(1, 10) , screenattr(1, 11))
    call assert_notequal(screenattr(1, 11) , screenattr(1, 12))
*** ../vim-8.0.0051/src/version.c	2016-10-27 21:13:04.886665573 +0200
--- src/version.c	2016-10-28 22:09:12.539771714 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     52,
  /**/

-- 
"Lisp has all the visual appeal of oatmeal with nail clippings thrown in."
                                                         -- Larry Wall

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0053
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0053 (after 8.0.0047)
Problem:    No test for what 8.0.0047 fixes.
Solution:   Add a test. (Hirohito Higashi)
Files:      src/testdir/test_popup.vim


*** ../vim-8.0.0052/src/testdir/test_popup.vim	2016-10-18 13:06:33.377547323 +0200
--- src/testdir/test_popup.vim	2016-10-29 14:36:20.406936205 +0200
***************
*** 378,384 ****
    endif
  endfunc
  
! " Test that 'completefunc' works when it's OK.
  func Test_omnifunc_with_check()
    new
    setlocal omnifunc=DummyCompleteFour
--- 378,384 ----
    endif
  endfunc
  
! " Test that 'omnifunc' works when it's OK.
  func Test_omnifunc_with_check()
    new
    setlocal omnifunc=DummyCompleteFour
***************
*** 437,441 ****
--- 437,467 ----
    q!
  endfunc
  
+ function! DummyCompleteFive(findstart, base)
+   if a:findstart
+     return 0
+   else
+     return [
+           \   { 'word': 'January', 'info': "info1-1\n1-2\n1-3" },
+           \   { 'word': 'February', 'info': "info2-1\n2-2\n2-3" },
+           \   { 'word': 'March', 'info': "info3-1\n3-2\n3-3" },
+           \   { 'word': 'April', 'info': "info4-1\n4-2\n4-3" },
+           \   { 'word': 'May', 'info': "info5-1\n5-2\n5-3" },
+           \ ]
+   endif
+ endfunc
+ 
+ " Test that 'completefunc' on Scratch buffer with preview window works when
+ " it's OK.
+ func Test_completefunc_with_scratch_buffer()
+   new +setlocal\ buftype=nofile\ bufhidden=wipe\ noswapfile
+   set completeopt+=preview
+   setlocal completefunc=DummyCompleteFive
+   call feedkeys("A\<C-X>\<C-U>\<C-N>\<C-N>\<C-N>\<Esc>", "x")
+   call assert_equal(['April'], getline(1, '$'))
+   pclose
+   q!
+   set completeopt&
+ endfunc
  
  " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.0.0052/src/version.c	2016-10-28 22:10:22.775343816 +0200
--- src/version.c	2016-10-29 14:37:30.574508722 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     53,
  /**/

-- 
ARTHUR:    ... and I am your king ....
OLD WOMAN: Ooooh!  I didn't know we had a king.  I thought we were an
           autonomous collective ...
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0054
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0054 (after 8.0.0051)
Problem:    On Windows job_stop() stops cmd.exe, not the processes it runs.
            (Linwei)
Solution:   Iterate over all processes and terminate the one where the parent
            is the job process. Now only when there is no job object.
            (Yasuhiro Matsumoto, closes #1203)
Files:      src/os_win32.c


*** ../vim-8.0.0053/src/os_win32.c	2016-10-27 21:13:04.882665596 +0200
--- src/os_win32.c	2016-10-29 14:52:48.832914391 +0200
***************
*** 50,55 ****
--- 50,59 ----
  # endif
  #endif
  
+ #ifdef FEAT_JOB_CHANNEL
+ # include <tlhelp32.h>
+ #endif
+ 
  #ifdef __MINGW32__
  # ifndef FROM_LEFT_1ST_BUTTON_PRESSED
  #  define FROM_LEFT_1ST_BUTTON_PRESSED    0x0001
***************
*** 5020,5025 ****
--- 5024,5071 ----
      return NULL;
  }
  
+     static BOOL
+ terminate_all(HANDLE process, int code)
+ {
+     PROCESSENTRY32  pe;
+     HANDLE	    h = INVALID_HANDLE_VALUE;
+     DWORD	    pid = GetProcessId(process);
+ 
+     if (pid != 0)
+     {
+ 	h = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
+ 	if (h != INVALID_HANDLE_VALUE)
+ 	{
+ 	    pe.dwSize = sizeof(PROCESSENTRY32);
+ 	    if (!Process32First(h, &pe))
+ 		goto theend;
+ 
+ 	    do
+ 	    {
+ 		if (pe.th32ParentProcessID == pid)
+ 		{
+ 		    HANDLE ph = OpenProcess(
+ 				  PROCESS_ALL_ACCESS, FALSE, pe.th32ProcessID);
+ 		    if (ph != NULL)
+ 		    {
+ 			terminate_all(ph, code);
+ 			CloseHandle(ph);
+ 		    }
+ 		}
+ 	    } while (Process32Next(h, &pe));
+ 
+ 	    CloseHandle(h);
+ 	}
+     }
+ 
+ theend:
+     return TerminateProcess(process, code);
+ }
+ 
+ /*
+  * Send a (deadly) signal to "job".
+  * Return FAIL if it didn't work.
+  */
      int
  mch_stop_job(job_T *job, char_u *how)
  {
***************
*** 5027,5036 ****
  
      if (STRCMP(how, "term") == 0 || STRCMP(how, "kill") == 0 || *how == NUL)
      {
  	if (job->jv_job_object != NULL)
  	    return TerminateJobObject(job->jv_job_object, 0) ? OK : FAIL;
! 	else
! 	    return TerminateProcess(job->jv_proc_info.hProcess, 0) ? OK : FAIL;
      }
  
      if (!AttachConsole(job->jv_proc_info.dwProcessId))
--- 5073,5082 ----
  
      if (STRCMP(how, "term") == 0 || STRCMP(how, "kill") == 0 || *how == NUL)
      {
+ 	/* deadly signal */
  	if (job->jv_job_object != NULL)
  	    return TerminateJobObject(job->jv_job_object, 0) ? OK : FAIL;
! 	return terminate_all(job->jv_proc_info.hProcess, 0) ? OK : FAIL;
      }
  
      if (!AttachConsole(job->jv_proc_info.dwProcessId))
*** ../vim-8.0.0053/src/version.c	2016-10-29 14:37:51.970378370 +0200
--- src/version.c	2016-10-29 14:54:23.980334722 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     54,
  /**/

-- 
OLD WOMAN: Well, how did you become king, then?
ARTHUR: The Lady of the Lake, her arm clad in the purest shimmering samite,
        held Excalibur aloft from the bosom of the water to signify by Divine
        Providence ...  that I, Arthur, was to carry Excalibur ...  That is
        why I am your king!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0055
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0055
Problem:    Minor comment and style deficiencies.
Solution:   Update comments and fix style.
Files:      src/buffer.c, src/misc2.c, src/os_unix.c


*** ../vim-8.0.0054/src/buffer.c	2016-09-11 14:36:14.000000000 +0200
--- src/buffer.c	2016-10-08 16:28:50.059483141 +0200
***************
*** 451,457 ****
      int		nwindows;
      bufref_T	bufref;
  # ifdef FEAT_WINDOWS
!     int		is_curwin = (curwin!= NULL && curwin->w_buffer == buf);
      win_T	*the_curwin = curwin;
      tabpage_T	*the_curtab = curtab;
  # endif
--- 451,457 ----
      int		nwindows;
      bufref_T	bufref;
  # ifdef FEAT_WINDOWS
!     int		is_curwin = (curwin != NULL && curwin->w_buffer == buf);
      win_T	*the_curwin = curwin;
      tabpage_T	*the_curtab = curtab;
  # endif
***************
*** 1649,1658 ****
  #ifdef FEAT_AUTOCMD
      if (!apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf)
  # ifdef FEAT_EVAL
! 	    || (bufref_valid(&bufref) && !aborting()))
  # else
! 	    || bufref_valid(&bufref))
  # endif
  #endif
      {
  #ifdef FEAT_SYN_HL
--- 1649,1659 ----
  #ifdef FEAT_AUTOCMD
      if (!apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf)
  # ifdef FEAT_EVAL
! 	    || (bufref_valid(&bufref) && !aborting())
  # else
! 	    || bufref_valid(&bufref)
  # endif
+        )
  #endif
      {
  #ifdef FEAT_SYN_HL
*** ../vim-8.0.0054/src/misc2.c	2016-10-12 14:19:55.746357751 +0200
--- src/misc2.c	2016-10-27 18:27:13.667291651 +0200
***************
*** 6256,6261 ****
--- 6256,6262 ----
  #if defined(MESSAGE_QUEUE) || defined(PROTO)
  /*
   * Process messages that have been queued for netbeans or clientserver.
+  * Also check if any jobs have ended.
   * These functions can call arbitrary vimscript and should only be called when
   * it is safe to do so.
   */
*** ../vim-8.0.0054/src/os_unix.c	2016-10-27 20:00:03.661357429 +0200
--- src/os_unix.c	2016-10-29 14:50:00.921937360 +0200
***************
*** 5390,5395 ****
--- 5390,5399 ----
      return NULL;
  }
  
+ /*
+  * Send a (deadly) signal to "job".
+  * Return FAIL if "how" is not a valid name.
+  */
      int
  mch_stop_job(job_T *job, char_u *how)
  {
*** ../vim-8.0.0054/src/version.c	2016-10-29 14:54:56.628135821 +0200
--- src/version.c	2016-10-30 21:57:08.786668736 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     55,
  /**/

-- 
Any resemblance between the above views and those of my employer, my terminal,
or the view out my window are purely coincidental.  Any resemblance between
the above and my own views is non-deterministic.  The question of the
existence of views in the absence of anyone to hold them is left as an
exercise for the reader.  The question of the existence of the reader is left
as an exercise for the second god coefficient.  (A discussion of
non-orthogonal, non-integral polytheism is beyond the scope of this article.)
						(Ralph Jennings)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0056
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0056
Problem:    When setting 'filetype' there is no check for a valid name.
Solution:   Only allow valid characters in 'filetype', 'syntax' and 'keymap'.
Files:      src/option.c, src/testdir/test_options.vim


*** ../vim-8.0.0055/src/option.c	2016-10-12 17:45:13.638857445 +0200
--- src/option.c	2016-11-04 15:15:21.485747398 +0100
***************
*** 5823,5828 ****
--- 5823,5843 ----
  }
  
  /*
+  * Return TRUE if "val" is a valid 'filetype' name.
+  * Also used for 'syntax' and 'keymap'.
+  */
+     static int
+ valid_filetype(char_u *val)
+ {
+     char_u *s;
+ 
+     for (s = val; *s != NUL; ++s)
+ 	if (!ASCII_ISALNUM(*s) && vim_strchr((char_u *)".-_", *s) == NULL)
+ 	    return FALSE;
+     return TRUE;
+ }
+ 
+ /*
   * Handle string options that need some action to perform when changed.
   * Returns NULL for success, or an error message for an error.
   */
***************
*** 6235,6242 ****
  #ifdef FEAT_KEYMAP
      else if (varp == &curbuf->b_p_keymap)
      {
! 	/* load or unload key mapping tables */
! 	errmsg = keymap_init();
  
  	if (errmsg == NULL)
  	{
--- 6250,6260 ----
  #ifdef FEAT_KEYMAP
      else if (varp == &curbuf->b_p_keymap)
      {
! 	if (!valid_filetype(*varp))
! 	    errmsg = e_invarg;
! 	else
! 	    /* load or unload key mapping tables */
! 	    errmsg = keymap_init();
  
  	if (errmsg == NULL)
  	{
***************
*** 7221,7226 ****
--- 7239,7260 ----
  	    errmsg = e_invarg;
      }
  #endif
+ 
+ #ifdef FEAT_AUTOCMD
+     else if (gvarp == &p_ft)
+     {
+ 	if (!valid_filetype(*varp))
+ 	    errmsg = e_invarg;
+     }
+ #endif
+ 
+ #ifdef FEAT_SYN_HL
+     else if (gvarp == &p_syn)
+     {
+ 	if (!valid_filetype(*varp))
+ 	    errmsg = e_invarg;
+     }
+ #endif
  
      /* Options that are a list of flags. */
      else
*** ../vim-8.0.0055/src/testdir/test_options.vim	2016-08-12 19:14:36.000000000 +0200
--- src/testdir/test_options.vim	2016-11-04 15:16:04.909425894 +0100
***************
*** 48,50 ****
--- 48,99 ----
    endif
  endfunc
  
+ func Test_filetype_valid()
+   set ft=valid_name
+   call assert_equal("valid_name", &filetype)
+   set ft=valid-name
+   call assert_equal("valid-name", &filetype)
+ 
+   call assert_fails(":set ft=wrong;name", "E474:")
+   call assert_fails(":set ft=wrong\\\\name", "E474:")
+   call assert_fails(":set ft=wrong\\|name", "E474:")
+   call assert_fails(":set ft=wrong/name", "E474:")
+   call assert_fails(":set ft=wrong\\\nname", "E474:")
+   call assert_equal("valid-name", &filetype)
+ 
+   exe "set ft=trunc\x00name"
+   call assert_equal("trunc", &filetype)
+ endfunc
+ 
+ func Test_syntax_valid()
+   set syn=valid_name
+   call assert_equal("valid_name", &syntax)
+   set syn=valid-name
+   call assert_equal("valid-name", &syntax)
+ 
+   call assert_fails(":set syn=wrong;name", "E474:")
+   call assert_fails(":set syn=wrong\\\\name", "E474:")
+   call assert_fails(":set syn=wrong\\|name", "E474:")
+   call assert_fails(":set syn=wrong/name", "E474:")
+   call assert_fails(":set syn=wrong\\\nname", "E474:")
+   call assert_equal("valid-name", &syntax)
+ 
+   exe "set syn=trunc\x00name"
+   call assert_equal("trunc", &syntax)
+ endfunc
+ 
+ func Test_keymap_valid()
+   call assert_fails(":set kmp=valid_name", "E544:")
+   call assert_fails(":set kmp=valid_name", "valid_name")
+   call assert_fails(":set kmp=valid-name", "E544:")
+   call assert_fails(":set kmp=valid-name", "valid-name")
+ 
+   call assert_fails(":set kmp=wrong;name", "E474:")
+   call assert_fails(":set kmp=wrong\\\\name", "E474:")
+   call assert_fails(":set kmp=wrong\\|name", "E474:")
+   call assert_fails(":set kmp=wrong/name", "E474:")
+   call assert_fails(":set kmp=wrong\\\nname", "E474:")
+ 
+   call assert_fails(":set kmp=trunc\x00name", "E544:")
+   call assert_fails(":set kmp=trunc\x00name", "trunc")
+ endfunc
*** ../vim-8.0.0055/src/version.c	2016-10-30 21:57:48.074395566 +0100
--- src/version.c	2016-11-04 14:34:35.299868887 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     56,
  /**/

-- 
Team-building exercises come in many forms but they all trace their roots back
to the prison system.  In your typical team-building exercise the employees
are subjected to a variety of unpleasant situations until they become either a
cohesive team or a ring of car jackers.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0057
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0057 (after 8.0.0056)
Problem:    Tests fail without the 'keymap' features.
Solution:   Check for feature in test.
Files:      src/testdir/test_options.vim


*** ../vim-8.0.0056/src/testdir/test_options.vim	2016-11-04 15:23:41.609967769 +0100
--- src/testdir/test_options.vim	2016-11-04 16:39:27.595960265 +0100
***************
*** 49,54 ****
--- 49,57 ----
  endfunc
  
  func Test_filetype_valid()
+   if !has('autocmd')
+     return
+   endif
    set ft=valid_name
    call assert_equal("valid_name", &filetype)
    set ft=valid-name
***************
*** 66,71 ****
--- 69,77 ----
  endfunc
  
  func Test_syntax_valid()
+   if !has('syntax')
+     return
+   endif
    set syn=valid_name
    call assert_equal("valid_name", &syntax)
    set syn=valid-name
***************
*** 83,88 ****
--- 89,97 ----
  endfunc
  
  func Test_keymap_valid()
+   if !has('keymap')
+     return
+   endif
    call assert_fails(":set kmp=valid_name", "E544:")
    call assert_fails(":set kmp=valid_name", "valid_name")
    call assert_fails(":set kmp=valid-name", "E544:")
*** ../vim-8.0.0056/src/version.c	2016-11-04 15:23:41.609967769 +0100
--- src/version.c	2016-11-04 16:40:11.219637484 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     57,
  /**/

-- 
The acknowledged parents of reengineering are Michael Hammer and James Champy.
When I say they're the "parents" I don't mean they had sex - and I apologize
for making you think about it.  I mean they wrote the best-selling business
book _Reengineering the Corporation_, which was published in 1993.
   Businesses flocked to reengineering like frat boys to a drunken
cheerleader.  (This analogy wasn't necessary, but I'm trying to get my mind
off that Hammer and Champy thing.)
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0058
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0058
Problem:    Positioning of the popup menu is not good.
Solution:   Position it better. (Hirohito Higashi)
Files:      src/popupmnu.c


*** ../vim-8.0.0057/src/popupmnu.c	2016-10-27 14:49:11.022995393 +0200
--- src/popupmnu.c	2016-11-04 20:03:00.299805506 +0100
***************
*** 54,71 ****
      int		kind_width;
      int		extra_width;
      int		i;
-     int		top_clear;
      int		row;
      int		context_lines;
      int		col;
!     int		above_row = cmdline_row;
      int		redo_count = 0;
  
  redo:
      def_width = PUM_DEF_WIDTH;
      max_width = 0;
      kind_width = 0;
      extra_width = 0;
  
      /* Pretend the pum is already there to avoid that must_redraw is set when
       * 'cuc' is on. */
--- 54,74 ----
      int		kind_width;
      int		extra_width;
      int		i;
      int		row;
      int		context_lines;
      int		col;
!     int		above_row;
!     int		below_row;
      int		redo_count = 0;
+     win_T	*pvwin;
  
  redo:
      def_width = PUM_DEF_WIDTH;
      max_width = 0;
      kind_width = 0;
      extra_width = 0;
+     above_row = 0;
+     below_row = cmdline_row;
  
      /* Pretend the pum is already there to avoid that must_redraw is set when
       * 'cuc' is on. */
***************
*** 76,93 ****
      row = curwin->w_wrow + W_WINROW(curwin);
  
  #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
!     if (firstwin->w_p_pvw)
! 	top_clear = firstwin->w_height;
!     else
! #endif
! 	top_clear = 0;
! 
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
!     /* When the preview window is at the bottom stop just above it.  Also
!      * avoid drawing over the status line so that it's clear there is a window
!      * boundary. */
!     if (lastwin->w_p_pvw)
! 	above_row -= lastwin->w_height + lastwin->w_status_height + 1;
  #endif
  
      /*
--- 79,94 ----
      row = curwin->w_wrow + W_WINROW(curwin);
  
  #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
!     FOR_ALL_WINDOWS(pvwin)
! 	if (pvwin->w_p_pvw)
! 	    break;
!     if (pvwin != NULL)
!     {
! 	if (W_WINROW(pvwin) < W_WINROW(curwin))
! 	    above_row = W_WINROW(pvwin) + pvwin->w_height;
! 	else if (W_WINROW(pvwin) > W_WINROW(curwin) + curwin->w_height)
! 	    below_row = W_WINROW(pvwin);
!     }
  #endif
  
      /*
***************
*** 102,109 ****
  
      /* Put the pum below "row" if possible.  If there are few lines decide on
       * where there is more room. */
!     if (row  + 2 >= above_row - pum_height
! 					 && row > (above_row - top_clear) / 2)
      {
  	/* pum above "row" */
  
--- 103,109 ----
  
      /* Put the pum below "row" if possible.  If there are few lines decide on
       * where there is more room. */
!     if (row - above_row >= below_row - row)
      {
  	/* pum above "row" */
  
***************
*** 141,148 ****
  				+ curwin->w_cline_height - curwin->w_wrow;
  
  	pum_row = row + context_lines;
! 	if (size > above_row - pum_row)
! 	    pum_height = above_row - pum_row;
  	else
  	    pum_height = size;
  	if (p_ph > 0 && pum_height > p_ph)
--- 141,148 ----
  				+ curwin->w_cline_height - curwin->w_wrow;
  
  	pum_row = row + context_lines;
! 	if (size > below_row - pum_row)
! 	    pum_height = below_row - pum_row;
  	else
  	    pum_height = size;
  	if (p_ph > 0 && pum_height > p_ph)
***************
*** 154,166 ****
  	return;
  
  #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
!     /* If there is a preview window at the top avoid drawing over it. */
!     if (firstwin->w_p_pvw
! 	    && pum_row < firstwin->w_height
! 	    && pum_height > firstwin->w_height + 4)
      {
! 	pum_row += firstwin->w_height;
! 	pum_height -= firstwin->w_height;
      }
  #endif
  
--- 154,164 ----
  	return;
  
  #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
!     /* If there is a preview window at the above avoid drawing over it. */
!     if (pvwin != NULL && pum_row < above_row && pum_height > above_row)
      {
! 	pum_row += above_row;
! 	pum_height -= above_row;
      }
  #endif
  
*** ../vim-8.0.0057/src/version.c	2016-11-04 16:41:16.559153991 +0100
--- src/version.c	2016-11-04 20:03:57.851368163 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     58,
  /**/

-- 
Your company is doomed if your primary product is overhead transparencies.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0059
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0059
Problem:    Vim does not build on VMS systems.
Solution:   Various changes for VMS. (Zoltan Arpadffy)
Files:      src/json.c, src/macros.h, src/Make_vms.mms, src/os_unix.c,
            src/os_unix.h, src/os_vms.c, src/os_vms_conf.h,
            src/proto/os_vms.pro, src/testdir/Make_vms.mms


*** ../vim-8.0.0058/src/json.c	2016-10-21 20:35:32.632943225 +0200
--- src/json.c	2016-11-04 20:12:47.107346775 +0100
***************
*** 16,21 ****
--- 16,25 ----
  
  #include "vim.h"
  
+ #ifdef VAX
+ # undef FEAT_FLOAT // VAX does not handle well the Infinities
+ #endif
+ 
  #if defined(FEAT_EVAL) || defined(PROTO)
  
  static int json_encode_item(garray_T *gap, typval_T *val, int copyID, int options);
*** ../vim-8.0.0058/src/macros.h	2016-08-29 22:42:20.000000000 +0200
--- src/macros.h	2016-11-04 20:13:34.310988154 +0100
***************
*** 177,182 ****
--- 177,183 ----
  # define mch_fstat(n, p)	fstat(vms_fixfilename(n), (p))
  	/* VMS does not have lstat() */
  # define mch_stat(n, p)		stat(vms_fixfilename(n), (p))
+ # define mch_rmdir(n)		rmdir(vms_fixfilename(n))
  #else
  # ifndef WIN32
  #   define mch_access(n, p)	access((n), (p))
*** ../vim-8.0.0058/src/Make_vms.mms	2016-07-02 19:59:17.000000000 +0200
--- src/Make_vms.mms	2016-11-04 20:18:44.880628815 +0100
***************
*** 2,8 ****
  # Makefile for Vim on OpenVMS
  #
  # Maintainer:   Zoltan Arpadffy <arpadffy@polarhome.com>
! # Last change:  2016 Jul 02
  #
  # This has script been tested on VMS 6.2 to 8.2 on DEC Alpha, VAX and IA64
  # with MMS and MMK
--- 2,8 ----
  # Makefile for Vim on OpenVMS
  #
  # Maintainer:   Zoltan Arpadffy <arpadffy@polarhome.com>
! # Last change:  2016 Nov 04
  #
  # This has script been tested on VMS 6.2 to 8.2 on DEC Alpha, VAX and IA64
  # with MMS and MMK
***************
*** 38,44 ****
  # GUI or terminal mode executable.
  # Comment out if you want just the character terminal mode only.
  # GUI with Motif
! # GUI = YES
  
  # GUI with GTK
  # If you have GTK installed you might want to enable this option.
--- 38,44 ----
  # GUI or terminal mode executable.
  # Comment out if you want just the character terminal mode only.
  # GUI with Motif
! GUI = YES
  
  # GUI with GTK
  # If you have GTK installed you might want to enable this option.
***************
*** 299,320 ****
  ALL_LIBS = $(LIBS) $(GUI_LIB_DIR) $(GUI_LIB) \
  	   $(PERL_LIB) $(PYTHON_LIB) $(TCL_LIB) $(RUBY_LIB)
  
! SRC =	arabic.c blowfish.c buffer.c charset.c crypt.c, crypt_zip.c diff.c digraph.c edit.c eval.c ex_cmds.c ex_cmds2.c \
! 	ex_docmd.c ex_eval.c ex_getln.c if_xcmdsrv.c farsi.c fileio.c fold.c getchar.c \
! 	hardcopy.c hashtab.c json.c main.c mark.c menu.c mbyte.c memfile.c memline.c message.c misc1.c \
  	misc2.c move.c normal.c ops.c option.c popupmnu.c quickfix.c regexp.c search.c sha256.c\
! 	spell.c syntax.c tag.c term.c termlib.c ui.c undo.c version.c screen.c \
  	window.c os_unix.c os_vms.c pathdef.c \
  	$(GUI_SRC) $(PERL_SRC) $(PYTHON_SRC) $(TCL_SRC) \
  	$(RUBY_SRC) $(HANGULIN_SRC) $(MZSCH_SRC)
  
! OBJ =	arabic.obj blowfish.obj buffer.obj charset.obj crypt.obj, crypt_zip.obj diff.obj digraph.obj edit.obj eval.obj \
! 	ex_cmds.obj ex_cmds2.obj ex_docmd.obj ex_eval.obj ex_getln.obj \
! 	if_xcmdsrv.obj farsi.obj fileio.obj fold.obj getchar.obj hardcopy.obj hashtab.obj json.obj main.obj mark.obj \
  	menu.obj memfile.obj memline.obj message.obj misc1.obj misc2.obj \
  	move.obj mbyte.obj normal.obj ops.obj option.obj popupmnu.obj quickfix.obj \
! 	regexp.obj search.obj sha256.obj spell.obj syntax.obj tag.obj term.obj termlib.obj \
! 	ui.obj undo.obj screen.obj version.obj window.obj os_unix.obj \
  	os_vms.obj pathdef.obj if_mzsch.obj\
  	$(GUI_OBJ) $(PERL_OBJ) $(PYTHON_OBJ) $(TCL_OBJ) \
  	$(RUBY_OBJ) $(HANGULIN_OBJ) $(MZSCH_OBJ)
--- 299,320 ----
  ALL_LIBS = $(LIBS) $(GUI_LIB_DIR) $(GUI_LIB) \
  	   $(PERL_LIB) $(PYTHON_LIB) $(TCL_LIB) $(RUBY_LIB)
  
! SRC =	arabic.c blowfish.c buffer.c charset.c crypt.c crypt_zip.c dict.c diff.c digraph.c edit.c eval.c evalfunc.c \
! 	ex_cmds.c ex_cmds2.c ex_docmd.c ex_eval.c ex_getln.c if_cscope.c if_xcmdsrv.c farsi.c fileio.c fold.c getchar.c \
! 	hardcopy.c hashtab.c json.c list.c main.c mark.c menu.c mbyte.c memfile.c memline.c message.c misc1.c \
  	misc2.c move.c normal.c ops.c option.c popupmnu.c quickfix.c regexp.c search.c sha256.c\
! 	spell.c spellfile.c syntax.c tag.c term.c termlib.c ui.c undo.c userfunc.c version.c screen.c \
  	window.c os_unix.c os_vms.c pathdef.c \
  	$(GUI_SRC) $(PERL_SRC) $(PYTHON_SRC) $(TCL_SRC) \
  	$(RUBY_SRC) $(HANGULIN_SRC) $(MZSCH_SRC)
  
! OBJ = 	arabic.obj blowfish.obj buffer.obj charset.obj crypt.obj crypt_zip.obj dict.obj diff.obj digraph.obj edit.obj eval.obj \
! 	evalfunc.obj ex_cmds.obj ex_cmds2.obj ex_docmd.obj ex_eval.obj ex_getln.obj if_cscope.obj \
! 	if_xcmdsrv.obj farsi.obj fileio.obj fold.obj getchar.obj hardcopy.obj hashtab.obj json.obj list.obj main.obj mark.obj \
  	menu.obj memfile.obj memline.obj message.obj misc1.obj misc2.obj \
  	move.obj mbyte.obj normal.obj ops.obj option.obj popupmnu.obj quickfix.obj \
! 	regexp.obj search.obj sha256.obj spell.obj spellfile.obj syntax.obj tag.obj term.obj termlib.obj \
! 	ui.obj undo.obj userfunc.obj screen.obj version.obj window.obj os_unix.obj \
  	os_vms.obj pathdef.obj if_mzsch.obj\
  	$(GUI_OBJ) $(PERL_OBJ) $(PYTHON_OBJ) $(TCL_OBJ) \
  	$(RUBY_OBJ) $(HANGULIN_OBJ) $(MZSCH_OBJ)
***************
*** 496,501 ****
--- 496,513 ----
   ascii.h keymap.h term.h macros.h structs.h regexp.h \
   gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
   globals.h farsi.h arabic.h
+ crypt.obj : crypt.c vim.h [.auto]config.h feature.h os_unix.h \
+  ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \
+  gui_beval.h [.proto]gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \
+  globals.h farsi.h arabic.h
+ crypt_zip.obj : crypt_zip.c vim.h [.auto]config.h feature.h os_unix.h \
+  ascii.h keymap.h term.h macros.h option.h structs.h \
+  regexp.h gui.h gui_beval.h [.proto]gui_beval.pro alloc.h ex_cmds.h spell.h \
+  proto.h globals.h farsi.h arabic.h
+ dict.obj : dict.c vim.h [.auto]config.h feature.h os_unix.h \
+  ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \
+  gui_beval.h [.proto]gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \
+  globals.h farsi.h arabic.h
  diff.obj : diff.c vim.h [.auto]config.h feature.h os_unix.h   \
   ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
   [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
***************
*** 512,517 ****
--- 524,533 ----
   ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
   [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
   arabic.h version.h
+ evalfunc.obj : evalfunc.c vim.h [.auto]config.h feature.h os_unix.h \
+  ascii.h keymap.h term.h macros.h option.h structs.h \
+  regexp.h gui.h gui_beval.h [.proto]gui_beval.pro alloc.h ex_cmds.h spell.h \
+  proto.h globals.h farsi.h arabic.h version.h
  ex_cmds.obj : ex_cmds.c vim.h [.auto]config.h feature.h os_unix.h \
   ascii.h keymap.h term.h macros.h structs.h regexp.h \
   gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
***************
*** 569,574 ****
--- 585,594 ----
   ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
   [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
   arabic.h version.h
+ list.obj : list.c vim.h [.auto]config.h feature.h os_unix.h \
+  ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \
+  gui_beval.h [.proto]gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \
+  globals.h farsi.h arabic.h
  main.obj : main.c vim.h [.auto]config.h feature.h os_unix.h   \
   ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
   [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
***************
*** 653,662 ****
--- 673,690 ----
   ascii.h keymap.h term.h macros.h structs.h regexp.h \
   gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
   globals.h farsi.h arabic.h
+ sha256.obj : sha256.c vim.h [.auto]config.h feature.h os_unix.h \
+  ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \
+  gui_beval.h [.proto]gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \
+  globals.h farsi.h arabic.h
  spell.obj : spell.c vim.h [.auto]config.h feature.h os_unix.h \
   ascii.h keymap.h term.h macros.h structs.h regexp.h \
   gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
   globals.h farsi.h arabic.h
+ spellfile.obj : spellfile.c vim.h [.auto]config.h feature.h os_unix.h \
+  ascii.h keymap.h term.h macros.h option.h structs.h \
+  regexp.h gui.h gui_beval.h [.proto]gui_beval.pro alloc.h ex_cmds.h spell.h \
+  proto.h globals.h farsi.h arabic.h
  syntax.obj : syntax.c vim.h [.auto]config.h feature.h os_unix.h \
   ascii.h keymap.h term.h macros.h structs.h regexp.h \
   gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
***************
*** 681,686 ****
--- 709,718 ----
   ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
   [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
   arabic.h
+ userfunc.obj : userfunc.c vim.h [.auto]config.h feature.h os_unix.h \
+  ascii.h keymap.h term.h macros.h option.h structs.h \
+  regexp.h gui.h gui_beval.h [.proto]gui_beval.pro alloc.h ex_cmds.h spell.h \
+  proto.h globals.h farsi.h arabic.h
  version.obj : version.c vim.h [.auto]config.h feature.h os_unix.h \
   ascii.h keymap.h term.h macros.h structs.h regexp.h \
   gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
*** ../vim-8.0.0058/src/os_unix.c	2016-10-30 21:57:48.074395566 +0100
--- src/os_unix.c	2016-11-04 20:21:15.359474394 +0100
***************
*** 501,507 ****
  	/* no character available */
  #if !(defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H))
  	/* estimate the elapsed time */
! 	elapsed += wait_time;
  #endif
  
  	if (do_resize	    /* interrupted by SIGWINCH signal */
--- 501,507 ----
  	/* no character available */
  #if !(defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H))
  	/* estimate the elapsed time */
! 	elapsed_time += wait_time;
  #endif
  
  	if (do_resize	    /* interrupted by SIGWINCH signal */
***************
*** 2644,2650 ****
      DIR		*dirp;
      struct dirent *dp;
  
!     if (lstat((char *)name, &st) >= 0)
      {
  	/* Open the directory where the file is located. */
  	slash = vim_strrchr(name, '/');
--- 2644,2650 ----
      DIR		*dirp;
      struct dirent *dp;
  
!     if (mch_lstat((char *)name, &st) >= 0)
      {
  	/* Open the directory where the file is located. */
  	slash = vim_strrchr(name, '/');
***************
*** 2677,2683 ****
  		    vim_strncpy(newname, name, MAXPATHL);
  		    vim_strncpy(newname + (tail - name), (char_u *)dp->d_name,
  						    MAXPATHL - (tail - name));
! 		    if (lstat((char *)newname, &st2) >= 0
  			    && st.st_ino == st2.st_ino
  			    && st.st_dev == st2.st_dev)
  		    {
--- 2677,2683 ----
  		    vim_strncpy(newname, name, MAXPATHL);
  		    vim_strncpy(newname + (tail - name), (char_u *)dp->d_name,
  						    MAXPATHL - (tail - name));
! 		    if (mch_lstat((char *)newname, &st2) >= 0
  			    && st.st_ino == st2.st_ino
  			    && st.st_dev == st2.st_dev)
  		    {
***************
*** 3040,3046 ****
  
      if (*name == NUL)	    /* Some stat()s don't flag "" as an error. */
  	return FALSE;
!     if (lstat((char *)name, &statb))
  	return FALSE;
  #ifdef _POSIX_SOURCE
      return (S_ISDIR(statb.st_mode) ? TRUE : FALSE);
--- 3040,3046 ----
  
      if (*name == NUL)	    /* Some stat()s don't flag "" as an error. */
  	return FALSE;
!     if (mch_lstat((char *)name, &statb))
  	return FALSE;
  #ifdef _POSIX_SOURCE
      return (S_ISDIR(statb.st_mode) ? TRUE : FALSE);
***************
*** 4098,4103 ****
--- 4098,4104 ----
      int		tmode = cur_tmode;
  #ifdef USE_SYSTEM	/* use system() to start the shell: simple but slow */
      char_u	*newcmd;	/* only needed for unix */
+     int		x;
  
      out_flush();
  
*** ../vim-8.0.0058/src/os_unix.h	2016-08-29 22:42:20.000000000 +0200
--- src/os_unix.h	2016-11-04 20:11:03.284135575 +0100
***************
*** 75,84 ****
  # ifdef VMS
  #  define mch_remove(x) delete((char *)(x))
  #  define vim_mkdir(x, y) mkdir((char *)(x), y)
- #  ifdef VAX
- #  else
- #   define mch_rmdir(x) rmdir((char *)(x))
- #  endif
  # else
  #  define vim_mkdir(x, y) mkdir((char *)(x), y)
  #  define mch_rmdir(x) rmdir((char *)(x))
--- 75,80 ----
*** ../vim-8.0.0058/src/os_vms.c	2016-08-29 22:42:20.000000000 +0200
--- src/os_vms.c	2016-11-04 20:22:07.923071226 +0100
***************
*** 726,732 ****
  RealWaitForChar(
      int		fd UNUSED, /* always read from iochan */
      long	msec,
!     int		*check_for_gpm UNUSED)
  {
      int status;
      struct _generic_64 time_curr;
--- 726,733 ----
  RealWaitForChar(
      int		fd UNUSED, /* always read from iochan */
      long	msec,
!     int		*check_for_gpm UNUSED,
!     int		*interrupted)
  {
      int status;
      struct _generic_64 time_curr;
*** ../vim-8.0.0058/src/os_vms_conf.h	2016-01-30 21:37:24.000000000 +0100
--- src/os_vms_conf.h	2016-11-04 20:23:23.210493858 +0100
***************
*** 141,146 ****
--- 141,147 ----
  #undef	HAVE_SYS_POLL_H
  #undef	HAVE_PWD_H
  #undef  HAVE_FCHDIR
+ #undef  HAVE_LSTAT
  
  /* Hardware specific */
  #ifdef  VAX
***************
*** 148,160 ****
  #undef  HAVE_USLEEP
  #undef  HAVE_STRCASECMP
  #undef  HAVE_STRINGS_H
! #undef	HAVE_SIGSETJMP
  #else
  #define HAVE_GETTIMEOFDAY
  #define HAVE_USLEEP
  #define HAVE_STRCASECMP
  #define HAVE_STRINGS_H
! #define	HAVE_SIGSETJMP
  #endif
  
  /* Compiler specific */
--- 149,163 ----
  #undef  HAVE_USLEEP
  #undef  HAVE_STRCASECMP
  #undef  HAVE_STRINGS_H
! #undef  HAVE_SIGSETJMP
! #undef  HAVE_ISNAN
  #else
  #define HAVE_GETTIMEOFDAY
  #define HAVE_USLEEP
  #define HAVE_STRCASECMP
  #define HAVE_STRINGS_H
! #define HAVE_SIGSETJMP
! #define HAVE_ISNAN
  #endif
  
  /* Compiler specific */
*** ../vim-8.0.0058/src/proto/os_vms.pro	2016-09-12 13:04:31.000000000 +0200
--- src/proto/os_vms.pro	2016-11-04 20:11:03.284135575 +0100
***************
*** 12,16 ****
  int mch_expandpath(garray_T *gap, char_u *path, int flags);
  void *vms_fixfilename(void *instring);
  void vms_remove_version(void *fname);
! int RealWaitForChar(int fd, long msec, int *check_for_gpm);
  /* vim: set ft=c : */
--- 12,16 ----
  int mch_expandpath(garray_T *gap, char_u *path, int flags);
  void *vms_fixfilename(void *instring);
  void vms_remove_version(void *fname);
! int RealWaitForChar(int fd, long msec, int *check_for_gpm, int *interrupted);
  /* vim: set ft=c : */
*** ../vim-8.0.0058/src/testdir/Make_vms.mms	2016-08-04 20:03:47.000000000 +0200
--- src/testdir/Make_vms.mms	2016-11-04 20:26:17.725155965 +0100
***************
*** 4,10 ****
  # Authors:	Zoltan Arpadffy, <arpadffy@polarhome.com>
  #		Sandor Kopanyi,  <sandor.kopanyi@mailbox.hu>
  #
! # Last change:  2016 Aug 04
  #
  # This has been tested on VMS 6.2 to 8.3 on DEC Alpha, VAX and IA64.
  # Edit the lines in the Configuration section below to select.
--- 4,10 ----
  # Authors:	Zoltan Arpadffy, <arpadffy@polarhome.com>
  #		Sandor Kopanyi,  <sandor.kopanyi@mailbox.hu>
  #
! # Last change:  2016 Nov 04
  #
  # This has been tested on VMS 6.2 to 8.3 on DEC Alpha, VAX and IA64.
  # Edit the lines in the Configuration section below to select.
***************
*** 74,87 ****
  
  VIMPROG = <->vim.exe
  
- default : all
- 
- # This probably doesn't work, please fix.
- .INCLUDE Make_all.mak
- 
  .SUFFIXES : .out .in
  
! SCRIPT = $(SCRIPTS_ALL) $(SCRIPTS_MORE3)
  
  # Known problems:
  # test17: ?
--- 74,118 ----
  
  VIMPROG = <->vim.exe
  
  .SUFFIXES : .out .in
  
! SCRIPT = test1.out  test3.out  test4.out  test5.out  \
!        test7.out  test8.out  test9.out  \
!        test14.out test15.out \
!        test19.out test20.out test22.out \
!        test23.out test24.out test26.out \
!        test28.out test29.out test30.out test31.out test32.out \
!        test33.out test34.out test36.out test37.out \
!        test38.out test39.out test40.out test41.out test42.out \
!        test43.out test44.out test45.out \
!        test48.out test49.out test51.out test53.out test54.out \
!        test55.out test56.out test57.out test60.out \
!        test64.out test65.out \
!        test66.out test67.out test68.out test69.out \
!        test72.out test75.out \
!        test77a.out test78.out test79.out test80.out \
!        test82.out test84.out test88.out test89.out \
!        test90.out test91.out test92.out test93.out test94.out \
!        test95.out test98.out test99.out \
!        test103.out test104.out \
!        test107.out test108.out\
!        test_autocmd_option.out \
!        test_autoformat_join.out \
!        test_breakindent.out \
!        test_changelist.out \
!        test_close_count.out \
!        test_comparators.out \
!        test_erasebackword.out \
!        test_eval.out \
!        test_fixeol.out \
!        test_getcwd.out \
!        test_insertcount.out \
!        test_listchars.out \
!        test_listlbr.out \
!        test_listlbr_utf8.out \
!        test_search_mbyte.out \
!        test_utf8.out \
!        test_wordcount.out
  
  # Known problems:
  # test17: ?
***************
*** 104,115 ****
  # On ODS-2 tests fail. 
  
  .IFDEF WANT_GUI
! SCRIPT_GUI = 
  GUI_OPTION = -g
  .ENDIF
  
  .IFDEF WANT_UNIX
! SCRIPT_UNIX = test12.out test17.out test25.out test27.out test49.out test73.out
  .ENDIF
  
  .IFDEF WANT_WIN
--- 135,146 ----
  # On ODS-2 tests fail. 
  
  .IFDEF WANT_GUI
! SCRIPT_GUI = test16.out
  GUI_OPTION = -g
  .ENDIF
  
  .IFDEF WANT_UNIX
! SCRIPT_UNIX = test10.out test12.out test17.out test25.out test27.out test49.out test73.out
  .ENDIF
  
  .IFDEF WANT_WIN
***************
*** 163,169 ****
  	-@ write sys$output "                "$*" "
  	-@ write sys$output "-----------------------------------------------"
  	-@ !run the test
! 	-@ create/term/wait/nodetach mcr $(VIMPROG) $(GUI_OPTION) -u vms.vim $(NO_PLUGIN) -s dotest.in $*.in
  	-@ !analyse the result
  	-@ directory /size/date test.out
  	-@ if "''F$SEARCH("test.out.*")'" .NES. "" then rename/nolog test.out $*.out 
--- 194,200 ----
  	-@ write sys$output "                "$*" "
  	-@ write sys$output "-----------------------------------------------"
  	-@ !run the test
! 	-@ create/term/wait/nodetach mcr $(VIMPROG) $(GUI_OPTION) -u vms.vim --noplugin -s dotest.in $*.in
  	-@ !analyse the result
  	-@ directory /size/date test.out
  	-@ if "''F$SEARCH("test.out.*")'" .NES. "" then rename/nolog test.out $*.out 
***************
*** 172,178 ****
  	-@ if "''F$SEARCH("Xdotest.*")'"  .NES. "" then delete/noconfirm/nolog Xdotest.*.*
  	-@ if "''F$SEARCH("Xtest.*")'"    .NES. "" then delete/noconfirm/nolog Xtest.*.*
  
! all : clean nolog $(SCRIPTS_FIRST) $(SCRIPT) $(SCRIPT_GUI) $(SCRIPT_UNIX) $(SCRIPT_WIN) $(SCRIPT_SPELL) $(SCRIPT_ODS5) $(SCRIPT_GZIP) \
      $(SCRIPT_GDIFF) $(SCRIPT_MZSCH) $(SCRIPT_CKSUM) $(SCRIPT_ICONV) $(SCRIPT_LUA) $(SCRIPT_PYTHON) nolog 
  	-@ write sys$output " "
  	-@ write sys$output "-----------------------------------------------"
--- 203,209 ----
  	-@ if "''F$SEARCH("Xdotest.*")'"  .NES. "" then delete/noconfirm/nolog Xdotest.*.*
  	-@ if "''F$SEARCH("Xtest.*")'"    .NES. "" then delete/noconfirm/nolog Xtest.*.*
  
! all : clean nolog $(START_WITH) $(SCRIPT) $(SCRIPT_GUI) $(SCRIPT_UNIX) $(SCRIPT_WIN) $(SCRIPT_SPELL) $(SCRIPT_ODS5) $(SCRIPT_GZIP) \
      $(SCRIPT_GDIFF) $(SCRIPT_MZSCH) $(SCRIPT_CKSUM) $(SCRIPT_ICONV) $(SCRIPT_LUA) $(SCRIPT_PYTHON) nolog 
  	-@ write sys$output " "
  	-@ write sys$output "-----------------------------------------------"
*** ../vim-8.0.0058/src/version.c	2016-11-04 20:08:48.281161315 +0100
--- src/version.c	2016-11-04 20:26:57.472851325 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     59,
  /**/

-- 
"You're fired." (1980)
"You're laid off." (1985)
"You're downsized." (1990)
"You're rightsized." (1992)
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0060
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0060
Problem:    When using an Ex command for 'keywordprg' it is escaped as with a
            shell command. (Romain Lafourcade)
Solution:   Escape for an Ex command. (closes #1175)
Files:      src/normal.c, src/testdir/test_normal.vim


*** ../vim-8.0.0059/src/normal.c	2016-10-08 19:21:26.079230055 +0200
--- src/normal.c	2016-11-04 21:10:40.832732253 +0100
***************
*** 5713,5721 ****
       */
      if (cmdchar == 'K' && !kp_help)
      {
- 	/* Escape the argument properly for a shell command */
  	ptr = vim_strnsave(ptr, n);
! 	p = vim_strsave_shellescape(ptr, TRUE, TRUE);
  	vim_free(ptr);
  	if (p == NULL)
  	{
--- 5713,5725 ----
       */
      if (cmdchar == 'K' && !kp_help)
      {
  	ptr = vim_strnsave(ptr, n);
! 	if (kp_ex)
! 	    /* Escape the argument properly for an Ex command */
! 	    p = vim_strsave_fnameescape(ptr, FALSE);
! 	else
! 	    /* Escape the argument properly for a shell command */
! 	    p = vim_strsave_shellescape(ptr, TRUE, TRUE);
  	vim_free(ptr);
  	if (p == NULL)
  	{
*** ../vim-8.0.0059/src/testdir/test_normal.vim	2016-09-09 16:54:46.000000000 +0200
--- src/testdir/test_normal.vim	2016-11-04 21:13:39.267361314 +0100
***************
*** 1222,1228 ****
  func! Test_normal23_K()
    " Test for K command
    new
!   call append(0, ['version8.txt', 'man'])
    let k = &keywordprg
    set keywordprg=:help
    1
--- 1222,1228 ----
  func! Test_normal23_K()
    " Test for K command
    new
!   call append(0, ['version8.txt', 'man', 'aa%bb', 'cc|dd'])
    let k = &keywordprg
    set keywordprg=:help
    1
***************
*** 1237,1242 ****
--- 1237,1260 ----
    call assert_match('\*version8\.0\*', getline('.'))
    helpclose
  
+   set keywordprg=:new
+   set iskeyword+=%
+   set iskeyword+=\|
+   2
+   norm! K
+   call assert_equal('man', fnamemodify(bufname('%'), ':t'))
+   bwipe!
+   3
+   norm! K
+   call assert_equal('aa%bb', fnamemodify(bufname('%'), ':t'))
+   bwipe!
+   4
+   norm! K
+   call assert_equal('cc|dd', fnamemodify(bufname('%'), ':t'))
+   bwipe!
+   set iskeyword-=%
+   set iskeyword-=\|
+ 
    " Only expect "man" to work on Unix
    if !has("unix")
      let &keywordprg = k
*** ../vim-8.0.0059/src/version.c	2016-11-04 20:35:27.352945991 +0100
--- src/version.c	2016-11-04 21:16:20.930121967 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     60,
  /**/

-- 
If your company is not involved in something called "ISO 9000" you probably
have no idea what it is.  If your company _is_ involved in ISO 9000 then you
definitely have no idea what it is.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0061
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0061 (after 8.0.0058)
Problem:    Compiler warning for unused variable.
Solution:   Add #ifdef. (John Marriott)
Files:      src/popupmnu.c


*** ../vim-8.0.0060/src/popupmnu.c	2016-11-04 20:08:48.277161346 +0100
--- src/popupmnu.c	2016-11-04 22:06:22.479024095 +0100
***************
*** 60,66 ****
--- 60,68 ----
      int		above_row;
      int		below_row;
      int		redo_count = 0;
+ #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
      win_T	*pvwin;
+ #endif
  
  redo:
      def_width = PUM_DEF_WIDTH;
*** ../vim-8.0.0060/src/version.c	2016-11-04 21:22:33.323268841 +0100
--- src/version.c	2016-11-04 22:07:26.686534879 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     61,
  /**/

-- 
The only way the average employee can speak to an executive is by taking a
second job as a golf caddie.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0062
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0062
Problem:    No digraph for HORIZONTAL ELLIPSIS.
Solution:   Use ",.". (Hans Ginzel, closes #1226)
Files:      src/digraph.c, runtime/doc/digraph.txt


*** ../vim-8.0.0061/src/digraph.c	2016-08-29 22:42:20.000000000 +0200
--- src/digraph.c	2016-11-04 22:15:15.382964392 +0100
***************
*** 1312,1317 ****
--- 1312,1318 ----
  	{'/', '-', 0x2020},
  	{'/', '=', 0x2021},
  	{'.', '.', 0x2025},
+ 	{',', '.', 0x2026},
  	{'%', '0', 0x2030},
  	{'1', '\'', 0x2032},
  	{'2', '\'', 0x2033},
*** ../vim-8.0.0061/runtime/doc/digraph.txt	2016-09-12 12:45:25.000000000 +0200
--- runtime/doc/digraph.txt	2016-11-04 22:14:55.827113346 +0100
***************
*** 147,153 ****
  	Two			2	Hook
  	Nine			9	Horn
  
! 	Equals			=	Cyrillic (= used as second char) 
  	Asterisk		*	Greek
  	Percent sign		%	Greek/Cyrillic special
  	Plus			+	smalls: Arabic, capitals: Hebrew
--- 147,153 ----
  	Two			2	Hook
  	Nine			9	Horn
  
! 	Equals			=	Cyrillic (= used as second char)
  	Asterisk		*	Greek
  	Percent sign		%	Greek/Cyrillic special
  	Plus			+	smalls: Arabic, capitals: Hebrew
***************
*** 926,931 ****
--- 926,932 ----
  	/-	2020	8224	DAGGER
  	/=	2021	8225	DOUBLE DAGGER
  	..	2025	8229	TWO DOT LEADER
+ 	,.	2026	8230	HORIZONTAL ELLIPSIS
  	%0	2030	8240	PER MILLE SIGN
  	1'	2032	8242	PRIME
  	2'	2033	8243	DOUBLE PRIME
*** ../vim-8.0.0061/src/version.c	2016-11-04 22:08:26.014082864 +0100
--- src/version.c	2016-11-04 22:16:28.018411161 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     62,
  /**/

-- 
A salesperson says:            Translation:
"backward compatible"          Old technology
"Premium"                      Overpriced
"Can't keep it on the shelf"   Unavailable
"Stands alone"                 Piece of shit
"Proprietary"                  Incompatible
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0063
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0063
Problem:    Compiler warning for comparing with unsigned. (Zoltan Arpadffy)
Solution:   Change <= to ==.
Files:      src/undo.c


*** ../vim-8.0.0062/src/undo.c	2016-08-29 22:42:20.000000000 +0200
--- src/undo.c	2016-11-05 14:56:19.176297387 +0100
***************
*** 1076,1082 ****
  	    if (bi->bi_used >= bi->bi_avail)
  	    {
  		n = fread(bi->bi_buffer, 1, (size_t)CRYPT_BUF_SIZE, bi->bi_fp);
! 		if (n <= 0)
  		{
  		    /* Error may be checked for only later.  Fill with zeros,
  		     * so that the reader won't use garbage. */
--- 1076,1082 ----
  	    if (bi->bi_used >= bi->bi_avail)
  	    {
  		n = fread(bi->bi_buffer, 1, (size_t)CRYPT_BUF_SIZE, bi->bi_fp);
! 		if (n == 0)
  		{
  		    /* Error may be checked for only later.  Fill with zeros,
  		     * so that the reader won't use garbage. */
*** ../vim-8.0.0062/src/version.c	2016-11-04 22:17:10.654086435 +0100
--- src/version.c	2016-11-05 14:58:22.639291038 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     63,
  /**/

-- 
If the Universe is constantly expanding, why can't I ever find a parking space?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0064
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0064 (after 8.0.0060)
Problem:    Normal test fails on MS-Windows.
Solution:   Don't try using an illegal file name.
Files:      src/testdir/test_normal.vim


*** ../vim-8.0.0063/src/testdir/test_normal.vim	2016-11-04 21:22:33.323268841 +0100
--- src/testdir/test_normal.vim	2016-11-05 19:51:32.362651582 +0100
***************
*** 1248,1257 ****
    norm! K
    call assert_equal('aa%bb', fnamemodify(bufname('%'), ':t'))
    bwipe!
!   4
!   norm! K
!   call assert_equal('cc|dd', fnamemodify(bufname('%'), ':t'))
!   bwipe!
    set iskeyword-=%
    set iskeyword-=\|
  
--- 1248,1259 ----
    norm! K
    call assert_equal('aa%bb', fnamemodify(bufname('%'), ':t'))
    bwipe!
!   if !has('win32')
!     4
!     norm! K
!     call assert_equal('cc|dd', fnamemodify(bufname('%'), ':t'))
!     bwipe!
!   endif
    set iskeyword-=%
    set iskeyword-=\|
  
*** ../vim-8.0.0063/src/version.c	2016-11-05 14:58:30.767225798 +0100
--- src/version.c	2016-11-05 19:53:43.165839035 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     64,
  /**/

-- 
The budget process was invented by an alien race of sadistic beings who
resemble large cats.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0065
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0065 (after 8.0.0056)
Problem:    Compiler warning for unused function in tiny build. (Tony
            Mechelynck)
Solution:   Add #ifdef.
Files:      src/option.c


*** ../vim-8.0.0064/src/option.c	2016-11-04 15:23:41.609967769 +0100
--- src/option.c	2016-11-05 20:11:28.643203745 +0100
***************
*** 5822,5827 ****
--- 5822,5828 ----
      return r;
  }
  
+ #if defined(FEAT_KEYMAP) || defined(FEAT_AUTOCMD) || defined(FEAT_SYN_HL)
  /*
   * Return TRUE if "val" is a valid 'filetype' name.
   * Also used for 'syntax' and 'keymap'.
***************
*** 5836,5841 ****
--- 5837,5843 ----
  	    return FALSE;
      return TRUE;
  }
+ #endif
  
  /*
   * Handle string options that need some action to perform when changed.
*** ../vim-8.0.0064/src/version.c	2016-11-05 19:53:57.049752758 +0100
--- src/version.c	2016-11-05 20:12:19.538886188 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     65,
  /**/

-- 
The fastest way to get an engineer to solve a problem is to declare that the
problem is unsolvable.  No engineer can walk away from an unsolvable problem
until it's solved.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0066
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0066
Problem:    when calling an operator function when 'linebreak' is set, it is
            internally reset before calling the operator function.
Solution:   Restore 'linebreak' before calling op_function(). (Christian
            Brabandt)
Files:      src/normal.c, src/testdir/test_normal.vim


*** ../vim-8.0.0065/src/normal.c	2016-11-04 21:22:33.323268841 +0100
--- src/normal.c	2016-11-05 21:54:33.644438077 +0100
***************
*** 1995,2000 ****
--- 1995,2005 ----
  	    break;
  
  	case OP_FUNCTION:
+ #ifdef FEAT_LINEBREAK
+ 	    /* Restore linebreak, so that when the user edits it looks as
+ 	     * before. */
+ 	    curwin->w_p_lbr = lbr_saved;
+ #endif
  	    op_function(oap);		/* call 'operatorfunc' */
  	    break;
  
*** ../vim-8.0.0065/src/testdir/test_normal.vim	2016-11-05 19:53:57.049752758 +0100
--- src/testdir/test_normal.vim	2016-11-05 21:50:29.141989667 +0100
***************
*** 35,42 ****
    let @@ = reg_save
  endfunc
  
! func! IsWindows()
!   return has("win32") || has("win64") || has("win95")
  endfunc
  
  fun! Test_normal00_optrans()
--- 35,54 ----
    let @@ = reg_save
  endfunc
  
! func! OpfuncDummy(type, ...)
!   " for testing operatorfunc
!   let g:opt=&linebreak
! 
!   if a:0  " Invoked from Visual mode, use gv command.
!     silent exe "normal! gvy"
!   elseif a:type == 'line'
!     silent exe "normal! '[V']y"
!   else
!     silent exe "normal! `[v`]y"
!   endif
!   " Create a new dummy window
!   new
!   let g:bufnr=bufnr('%')
  endfunc
  
  fun! Test_normal00_optrans()
***************
*** 147,153 ****
  func! Test_normal04_filter()
    " basic filter test
    " only test on non windows platform
!   if IsWindows()
      return
    endif
    call Setup_NewWindow()
--- 159,165 ----
  func! Test_normal04_filter()
    " basic filter test
    " only test on non windows platform
!   if has('win32')
      return
    endif
    call Setup_NewWindow()
***************
*** 210,216 ****
  func! Test_normal06_formatprg()
    " basic test for formatprg
    " only test on non windows platform
!   if IsWindows()
      return
    else
      " uses sed to number non-empty lines
--- 222,228 ----
  func! Test_normal06_formatprg()
    " basic test for formatprg
    " only test on non windows platform
!   if has('win32')
      return
    else
      " uses sed to number non-empty lines
***************
*** 328,334 ****
--- 340,373 ----
    " clean up
    unmap <buffer> ,,
    set opfunc=
+   unlet! g:a
+   bw!
+ endfunc
+ 
+ func! Test_normal09a_operatorfunc()
+   " Test operatorfunc
+   call Setup_NewWindow()
+   " Add some spaces for counting
+   50,60s/$/  /
+   unlet! g:opt
+   set linebreak
+   nmap <buffer><silent> ,, :set opfunc=OpfuncDummy<CR>g@
+   50
+   norm ,,j
+   exe "bd!" g:bufnr
+   call assert_true(&linebreak)
+   call assert_equal(g:opt, &linebreak)
+   set nolinebreak
+   norm ,,j
+   exe "bd!" g:bufnr
+   call assert_false(&linebreak)
+   call assert_equal(g:opt, &linebreak)
+ 
+   " clean up
+   unmap <buffer> ,,
+   set opfunc=
    bw!
+   unlet! g:opt
  endfunc
  
  func! Test_normal10_expand()
*** ../vim-8.0.0065/src/version.c	2016-11-05 20:13:29.146451807 +0100
--- src/version.c	2016-11-05 21:53:05.184999344 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     66,
  /**/

-- 
While it's true that many normal people whould prefer not to _date_ an
engineer, most normal people harbor an intense desire to _mate_ with them,
thus producing engineerlike children who will have high-paying jobs long
before losing their virginity.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0067
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0067
Problem:    VMS has a problem with infinity.
Solution:   Avoid an overflow. (Zoltan Arpadffy)
Files:      src/json.c, src/macros.h


*** ../vim-8.0.0066/src/json.c	2016-11-04 20:35:27.348946021 +0100
--- src/json.c	2016-11-06 14:14:03.760136140 +0100
***************
*** 16,25 ****
  
  #include "vim.h"
  
- #ifdef VAX
- # undef FEAT_FLOAT // VAX does not handle well the Infinities
- #endif
- 
  #if defined(FEAT_EVAL) || defined(PROTO)
  
  static int json_encode_item(garray_T *gap, typval_T *val, int copyID, int options);
--- 16,21 ----
*** ../vim-8.0.0066/src/macros.h	2016-11-04 20:35:27.348946021 +0100
--- src/macros.h	2016-11-06 14:15:05.207758686 +0100
***************
*** 345,351 ****
  #  endif
  #  if !defined(INFINITY)
  #   if defined(DBL_MAX)
! #    define INFINITY (DBL_MAX+DBL_MAX)
  #   else
  #    define INFINITY (1.0 / 0.0)
  #   endif
--- 345,355 ----
  #  endif
  #  if !defined(INFINITY)
  #   if defined(DBL_MAX)
! #    ifdef VMS
! #     define INFINITY DBL_MAX
! #    else
! #     define INFINITY (DBL_MAX+DBL_MAX)
! #    endif
  #   else
  #    define INFINITY (1.0 / 0.0)
  #   endif
*** ../vim-8.0.0066/src/version.c	2016-11-05 21:55:09.844208420 +0100
--- src/version.c	2016-11-06 14:13:30.924337877 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     67,
  /**/

-- 
An alien life briefly visits earth.  Just before departing it leaves a
message in the dust on the back of a white van.  The world is shocked
and wants to know what it means.  After months of studies the worlds
best linguistic scientists are able to decipher the message: "Wash me!".

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0068
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0068
Problem:    Checking did_throw after executing autocommands is wrong. (Daniel
            Hahler)
Solution:   Call aborting() instead, and only when autocommands were executed.
Files:      src/quickfix.c, src/if_cscope.c, src/testdir/test_quickfix.vim


*** ../vim-8.0.0067/src/quickfix.c	2016-10-15 19:28:09.239181100 +0200
--- src/quickfix.c	2016-11-05 20:29:05.956598800 +0100
***************
*** 3446,3457 ****
  	case CMD_lgrepadd:  au_name = (char_u *)"lgrepadd"; break;
  	default: break;
      }
!     if (au_name != NULL)
      {
- 	apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,
- 					       curbuf->b_fname, TRUE, curbuf);
  # ifdef FEAT_EVAL
! 	if (did_throw || force_abort)
  	    return;
  # endif
      }
--- 3446,3456 ----
  	case CMD_lgrepadd:  au_name = (char_u *)"lgrepadd"; break;
  	default: break;
      }
!     if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,
! 					       curbuf->b_fname, TRUE, curbuf))
      {
  # ifdef FEAT_EVAL
! 	if (aborting())
  	    return;
  # endif
      }
***************
*** 3970,3981 ****
  	case CMD_lgrepadd:    au_name = (char_u *)"lgrepadd"; break;
  	default: break;
      }
!     if (au_name != NULL)
      {
! 	apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,
! 					       curbuf->b_fname, TRUE, curbuf);
! 	if (did_throw || force_abort)
  	    return;
      }
  #endif
  
--- 3969,3981 ----
  	case CMD_lgrepadd:    au_name = (char_u *)"lgrepadd"; break;
  	default: break;
      }
!     if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,
! 					       curbuf->b_fname, TRUE, curbuf))
      {
! # ifdef FEAT_EVAL
! 	if (aborting())
  	    return;
+ # endif
      }
  #endif
  
***************
*** 4875,4886 ****
  	case CMD_laddbuffer:	au_name = (char_u *)"laddbuffer"; break;
  	default: break;
      }
!     if (au_name != NULL)
      {
- 	apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,
- 					       curbuf->b_fname, TRUE, curbuf);
  # ifdef FEAT_EVAL
! 	if (did_throw || force_abort)
  	    return;
  # endif
      }
--- 4875,4885 ----
  	case CMD_laddbuffer:	au_name = (char_u *)"laddbuffer"; break;
  	default: break;
      }
!     if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,
! 					       curbuf->b_fname, TRUE, curbuf))
      {
  # ifdef FEAT_EVAL
! 	if (aborting())
  	    return;
  # endif
      }
***************
*** 4966,4977 ****
  	case CMD_laddexpr:  au_name = (char_u *)"laddexpr"; break;
  	default: break;
      }
!     if (au_name != NULL)
      {
- 	apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,
- 					       curbuf->b_fname, TRUE, curbuf);
  # ifdef FEAT_EVAL
! 	if (did_throw || force_abort)
  	    return;
  # endif
      }
--- 4965,4975 ----
  	case CMD_laddexpr:  au_name = (char_u *)"laddexpr"; break;
  	default: break;
      }
!     if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,
! 					       curbuf->b_fname, TRUE, curbuf))
      {
  # ifdef FEAT_EVAL
! 	if (aborting())
  	    return;
  # endif
      }
***************
*** 5042,5053 ****
  	case CMD_lhelpgrep: au_name = (char_u *)"lhelpgrep"; break;
  	default: break;
      }
!     if (au_name != NULL)
      {
! 	apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,
! 					       curbuf->b_fname, TRUE, curbuf);
! 	if (did_throw || force_abort)
  	    return;
      }
  #endif
  
--- 5040,5052 ----
  	case CMD_lhelpgrep: au_name = (char_u *)"lhelpgrep"; break;
  	default: break;
      }
!     if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,
! 					       curbuf->b_fname, TRUE, curbuf))
      {
! # ifdef FEAT_EVAL
! 	if (aborting())
  	    return;
+ # endif
      }
  #endif
  
*** ../vim-8.0.0067/src/if_cscope.c	2016-10-12 14:19:55.746357751 +0200
--- src/if_cscope.c	2016-11-06 14:37:33.399497314 +0100
***************
*** 1178,1189 ****
  	}
  
  # ifdef FEAT_AUTOCMD
! 	if (*qfpos != '0')
  	{
- 	    apply_autocmds(EVENT_QUICKFIXCMDPRE, (char_u *)"cscope",
- 					       curbuf->b_fname, TRUE, curbuf);
  #  ifdef FEAT_EVAL
! 	    if (did_throw || force_abort)
  		return FALSE;
  #  endif
  	}
--- 1178,1189 ----
  	}
  
  # ifdef FEAT_AUTOCMD
! 	if (*qfpos != '0'
! 		&& apply_autocmds(EVENT_QUICKFIXCMDPRE, (char_u *)"cscope",
! 					       curbuf->b_fname, TRUE, curbuf))
  	{
  #  ifdef FEAT_EVAL
! 	    if (aborting())
  		return FALSE;
  #  endif
  	}
*** ../vim-8.0.0067/src/testdir/test_quickfix.vim	2016-10-15 19:28:09.243181069 +0200
--- src/testdir/test_quickfix.vim	2016-11-06 14:40:38.522365572 +0100
***************
*** 1631,1633 ****
--- 1631,1650 ----
  	      \ 'postcaddbuffer']
    call assert_equal(l, g:acmds)
  endfunction
+ 
+ function! Test_Autocmd_Exception()
+   set efm=%m
+   lgetexpr '?'
+ 
+   try
+     call DoesNotExit()
+   catch
+     lgetexpr '1'
+   finally
+     lgetexpr '1'
+   endtry
+ 
+   call assert_equal('1', getloclist(0)[0].text)
+ 
+   set efm&vim
+ endfunction
*** ../vim-8.0.0067/src/version.c	2016-11-06 14:17:13.182972857 +0100
--- src/version.c	2016-11-06 14:44:51.388820574 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     68,
  /**/

-- 
Engineers understand that their appearance only bothers other people and
therefore it is not worth optimizing.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0069
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0069
Problem:    Compiler warning for self-comparison.
Solution:   Define ONE_WINDOW and add #ifdef.
Files:      src/globals.h, src/buffer.c, src/ex_docmd.c, src/move.c,
            src/screen.c, src/quickfix.c, src/window.c


*** ../vim-8.0.0068/src/globals.h	2016-08-29 22:42:20.000000000 +0200
--- src/globals.h	2016-11-06 15:18:10.068418172 +0100
***************
*** 546,551 ****
--- 546,552 ----
  EXTERN win_T	*firstwin;		/* first window */
  EXTERN win_T	*lastwin;		/* last window */
  EXTERN win_T	*prevwin INIT(= NULL);	/* previous window */
+ # define ONE_WINDOW (firstwin == lastwin)
  # define W_NEXT(wp) ((wp)->w_next)
  # define FOR_ALL_WINDOWS(wp) for (wp = firstwin; wp != NULL; wp = wp->w_next)
  # define FOR_ALL_TABPAGES(tp) for (tp = first_tabpage; tp != NULL; tp = tp->tp_next)
***************
*** 563,568 ****
--- 564,570 ----
  #else
  # define firstwin curwin
  # define lastwin curwin
+ # define ONE_WINDOW 1
  # define W_NEXT(wp) NULL
  # define FOR_ALL_WINDOWS(wp) wp = curwin;
  # define FOR_ALL_TABPAGES(tp) for (;FALSE;)
*** ../vim-8.0.0068/src/buffer.c	2016-10-30 21:57:48.070395594 +0100
--- src/buffer.c	2016-11-06 15:20:32.491532716 +0100
***************
*** 4935,4941 ****
  		    }
  #ifdef FEAT_WINDOWS
  		    /* don't close last window */
! 		    if (firstwin == lastwin
  			    && (first_tabpage->tp_next == NULL || !had_tab))
  #endif
  			use_firstwin = TRUE;
--- 4935,4941 ----
  		    }
  #ifdef FEAT_WINDOWS
  		    /* don't close last window */
! 		    if (ONE_WINDOW
  			    && (first_tabpage->tp_next == NULL || !had_tab))
  #endif
  			use_firstwin = TRUE;
*** ../vim-8.0.0068/src/ex_docmd.c	2016-10-15 15:39:34.685059653 +0200
--- src/ex_docmd.c	2016-11-06 15:21:01.243353096 +0100
***************
*** 7239,7245 ****
  	 * :h|wincmd w|1q     - don't quit
  	 * :h|wincmd w|q      - quit
  	 */
! 	if (only_one_window() && (firstwin == lastwin || eap->addr_count == 0))
  #endif
  	    getout(0);
  #ifdef FEAT_WINDOWS
--- 7239,7245 ----
  	 * :h|wincmd w|1q     - don't quit
  	 * :h|wincmd w|q      - quit
  	 */
! 	if (only_one_window() && (ONE_WINDOW || eap->addr_count == 0))
  #endif
  	    getout(0);
  #ifdef FEAT_WINDOWS
*** ../vim-8.0.0068/src/move.c	2016-10-18 14:50:14.731694041 +0200
--- src/move.c	2016-11-06 15:18:38.896239173 +0100
***************
*** 2311,2317 ****
  #endif
  	if (dir == FORWARD)
  	{
! 	    if (firstwin == lastwin && p_window > 0 && p_window < Rows - 1)
  	    {
  		/* Vi compatible scrolling */
  		if (p_window <= 2)
--- 2311,2317 ----
  #endif
  	if (dir == FORWARD)
  	{
! 	    if (ONE_WINDOW && p_window > 0 && p_window < Rows - 1)
  	    {
  		/* Vi compatible scrolling */
  		if (p_window <= 2)
***************
*** 2361,2367 ****
  		continue;
  	    }
  #endif
! 	    if (firstwin == lastwin && p_window > 0 && p_window < Rows - 1)
  	    {
  		/* Vi compatible scrolling (sort of) */
  		if (p_window <= 2)
--- 2361,2367 ----
  		continue;
  	    }
  #endif
! 	    if (ONE_WINDOW && p_window > 0 && p_window < Rows - 1)
  	    {
  		/* Vi compatible scrolling (sort of) */
  		if (p_window <= 2)
*** ../vim-8.0.0068/src/screen.c	2016-10-27 17:27:38.265074170 +0200
--- src/screen.c	2016-11-06 15:21:34.503145348 +0100
***************
*** 1510,1516 ****
  	if (mid_start == 0)
  	{
  	    mid_end = wp->w_height;
! 	    if (lastwin == firstwin)
  	    {
  		/* Clear the screen when it was not done by win_del_lines() or
  		 * win_ins_lines() above, "screen_cleared" is FALSE or MAYBE
--- 1510,1516 ----
  	if (mid_start == 0)
  	{
  	    mid_end = wp->w_height;
! 	    if (ONE_WINDOW)
  	    {
  		/* Clear the screen when it was not done by win_del_lines() or
  		 * win_ins_lines() above, "screen_cleared" is FALSE or MAYBE
***************
*** 5670,5676 ****
  #ifdef FEAT_DIFF
  		     && filler_todo <= 0
  #endif
! 		     && W_WIDTH(wp) == Columns)
  	    {
  		/* Remember that the line wraps, used for modeless copy. */
  		LineWraps[screen_row - 1] = TRUE;
--- 5670,5679 ----
  #ifdef FEAT_DIFF
  		     && filler_todo <= 0
  #endif
! #ifdef FEAT_WINDOWS
! 		     && W_WIDTH(wp) == Columns
! #endif
! 		     )
  	    {
  		/* Remember that the line wraps, used for modeless copy. */
  		LineWraps[screen_row - 1] = TRUE;
***************
*** 10524,10530 ****
       * window differs, or the fillchars differ, or this is not the
       * current window */
      if (*attr != 0 && ((hl_attr(HLF_S) != hl_attr(HLF_SNC)
! 			|| !is_curwin || firstwin == lastwin)
  		    || (fill_stl != fill_stlnc)))
  	return fill;
      if (is_curwin)
--- 10527,10533 ----
       * window differs, or the fillchars differ, or this is not the
       * current window */
      if (*attr != 0 && ((hl_attr(HLF_S) != hl_attr(HLF_SNC)
! 			|| !is_curwin || ONE_WINDOW)
  		    || (fill_stl != fill_stlnc)))
  	return fill;
      if (is_curwin)
*** ../vim-8.0.0068/src/quickfix.c	2016-11-06 14:46:40.644143343 +0100
--- src/quickfix.c	2016-11-06 15:21:15.663263021 +0100
***************
*** 2137,2143 ****
  	 * If there is only one window and it is the quickfix window, create a
  	 * new one above the quickfix window.
  	 */
! 	if (((firstwin == lastwin) && bt_quickfix(curbuf)) || !usable_win)
  	{
  	    flags = WSP_ABOVE;
  	    if (ll_ref != NULL)
--- 2137,2143 ----
  	 * If there is only one window and it is the quickfix window, create a
  	 * new one above the quickfix window.
  	 */
! 	if ((ONE_WINDOW && bt_quickfix(curbuf)) || !usable_win)
  	{
  	    flags = WSP_ABOVE;
  	    if (ll_ref != NULL)
*** ../vim-8.0.0068/src/window.c	2016-09-04 17:24:16.000000000 +0200
--- src/window.c	2016-11-06 15:22:39.882737085 +0100
***************
*** 234,240 ****
  /* cursor to previous window with wrap around */
      case 'W':
  		CHECK_CMDWIN
! 		if (firstwin == lastwin && Prenum != 1)	/* just one window */
  		    beep_flush();
  		else
  		{
--- 234,240 ----
  /* cursor to previous window with wrap around */
      case 'W':
  		CHECK_CMDWIN
! 		if (ONE_WINDOW && Prenum != 1)	/* just one window */
  		    beep_flush();
  		else
  		{
***************
*** 1593,1599 ****
      frame_T	*frp;
      int		n;
  
!     if (firstwin == lastwin)		/* nothing to do */
      {
  	beep_flush();
  	return;
--- 1593,1599 ----
      frame_T	*frp;
      int		n;
  
!     if (ONE_WINDOW)		/* nothing to do */
      {
  	beep_flush();
  	return;
***************
*** 2206,2212 ****
      }
      return TRUE;
  #else
!     return firstwin == lastwin;
  #endif
  }
  
--- 2206,2212 ----
      }
      return TRUE;
  #else
!     return ONE_WINDOW;
  #endif
  }
  
***************
*** 2220,2226 ****
      int		free_buf,
      tabpage_T   *prev_curtab)
  {
!     if (firstwin == lastwin)
      {
  #ifdef FEAT_AUTOCMD
  	buf_T	*old_curbuf = curbuf;
--- 2220,2226 ----
      int		free_buf,
      tabpage_T   *prev_curtab)
  {
!     if (ONE_WINDOW)
      {
  #ifdef FEAT_AUTOCMD
  	buf_T	*old_curbuf = curbuf;
***************
*** 2625,2631 ****
      /*
       * If there is only one window there is nothing to remove.
       */
!     if (tp == NULL ? firstwin == lastwin : tp->tp_firstwin == tp->tp_lastwin)
  	return NULL;
  
      /*
--- 2625,2631 ----
      /*
       * If there is only one window there is nothing to remove.
       */
!     if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)
  	return NULL;
  
      /*
***************
*** 2780,2786 ****
      frame_T	*frp;
      int		b;
  
!     if (tp == NULL ? firstwin == lastwin : tp->tp_firstwin == tp->tp_lastwin)
  	/* Last window in this tab page, will go to next tab page. */
  	return alt_tabpage()->tp_curwin->w_frame;
  
--- 2780,2786 ----
      frame_T	*frp;
      int		b;
  
!     if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)
  	/* Last window in this tab page, will go to next tab page. */
  	return alt_tabpage()->tp_curwin->w_frame;
  
*** ../vim-8.0.0068/src/version.c	2016-11-06 14:46:40.644143343 +0100
--- src/version.c	2016-11-06 15:24:12.094161516 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     69,
  /**/

-- 
Imagine a world without hypothetical situations.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0070
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0070
Problem:    Tests referred in Makefile that no longer exist.
Solution:   Remove test71 and test74 entries. (Michael Soyka)
Files:      src/testdir/Make_ming.mak


*** ../vim-8.0.0069/src/testdir/Make_ming.mak	2016-08-06 20:34:08.000000000 +0200
--- src/testdir/Make_ming.mak	2016-11-07 22:11:19.136749981 +0100
***************
*** 68,74 ****
  fixff:
  	-$(VIMPROG) -u dos.vim $(NO_PLUGIN) "+argdo set ff=dos|upd" +q *.in *.ok
  	-$(VIMPROG) -u dos.vim $(NO_PLUGIN) "+argdo set ff=unix|upd" +q \
! 		dotest.in test60.ok test71.ok test74.ok test_listchars.ok \
  		test_getcwd.ok test_wordcount.ok
  
  clean:
--- 68,74 ----
  fixff:
  	-$(VIMPROG) -u dos.vim $(NO_PLUGIN) "+argdo set ff=dos|upd" +q *.in *.ok
  	-$(VIMPROG) -u dos.vim $(NO_PLUGIN) "+argdo set ff=unix|upd" +q \
! 		dotest.in test60.ok test_listchars.ok \
  		test_getcwd.ok test_wordcount.ok
  
  clean:
*** ../vim-8.0.0069/src/version.c	2016-11-06 15:25:37.701627423 +0100
--- src/version.c	2016-11-07 22:12:07.920428900 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     70,
  /**/

-- 
The average life of an organization chart is six months.  You can safely
ignore any order from your boss that would take six months to complete.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0071
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0071
Problem:    Exit value from a shell command is wrong. (Hexchain Tong)
Solution:   Do not check for ended jobs while waiting for a shell command.
            (ichizok, closes #1196)
Files:      src/os_unix.c


*** ../vim-8.0.0070/src/os_unix.c	2016-11-04 20:35:27.352945991 +0100
--- src/os_unix.c	2016-11-07 22:35:15.711318293 +0100
***************
*** 238,243 ****
--- 238,247 ----
  /* volatile because it is used in signal handler deathtrap(). */
  static volatile int in_mch_delay = FALSE;    /* sleeping in mch_delay() */
  
+ #if defined(FEAT_JOB_CHANNEL) && !defined(USE_SYSTEM)
+ static int dont_check_job_ended = 0;
+ #endif
+ 
  static int curr_tmode = TMODE_COOK;	/* contains current terminal mode */
  
  #ifdef USE_XSMP
***************
*** 4485,4491 ****
  	    catch_signals(SIG_IGN, SIG_ERR);
  	    catch_int_signal();
  	    UNBLOCK_SIGNALS(&curset);
! 
  	    /*
  	     * For the GUI we redirect stdin, stdout and stderr to our window.
  	     * This is also used to pipe stdin/stdout to/from the external
--- 4489,4497 ----
  	    catch_signals(SIG_IGN, SIG_ERR);
  	    catch_int_signal();
  	    UNBLOCK_SIGNALS(&curset);
! # ifdef FEAT_JOB_CHANNEL
! 	    ++dont_check_job_ended;
! # endif
  	    /*
  	     * For the GUI we redirect stdin, stdout and stderr to our window.
  	     * This is also used to pipe stdin/stdout to/from the external
***************
*** 5030,5035 ****
--- 5036,5045 ----
  		wait4pid(wpid, NULL);
  	    }
  
+ # ifdef FEAT_JOB_CHANNEL
+ 	    --dont_check_job_ended;
+ # endif
+ 
  	    /*
  	     * Set to raw mode right now, otherwise a CTRL-C after
  	     * catch_signals() will kill Vim.
***************
*** 5363,5368 ****
--- 5373,5386 ----
      pid_t	wait_pid = 0;
      job_T	*job;
  
+ # ifndef USE_SYSTEM
+     /* Do not do this when waiting for a shell command to finish, we would get
+      * the exit value here (and discard it), the exit value obtained there
+      * would then be wrong.  */
+     if (dont_check_job_ended > 0)
+ 	return NULL;
+ # endif
+ 
  # ifdef __NeXT__
      wait_pid = wait4(-1, &status, WNOHANG, (struct rusage *)0);
  # else
*** ../vim-8.0.0070/src/version.c	2016-11-07 22:13:29.171894387 +0100
--- src/version.c	2016-11-07 22:36:59.566637376 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     71,
  /**/

-- 
An operatingsystem is just a name you give to the rest of bloating
idiosyncratic machine-based-features you left out of your editor.
			(author unknown)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0072
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0072
Problem:    MS-Windows: Crash with long font name. (Henry Hu)
Solution:   Fix comparing with LF_FACESIZE. (Ken Takata, closes #1243)
Files:      src/os_mswin.c


*** ../vim-8.0.0071/src/os_mswin.c	2016-10-12 14:19:55.750357722 +0200
--- src/os_mswin.c	2016-11-10 17:09:00.686845213 +0100
***************
*** 2893,2899 ****
       */
      for (p = name; *p && *p != ':'; p++)
      {
! 	if (p - name + 1 > LF_FACESIZE)
  	    goto theend;			/* Name too long */
  	lf->lfFaceName[p - name] = *p;
      }
--- 2893,2899 ----
       */
      for (p = name; *p && *p != ':'; p++)
      {
! 	if (p - name + 1 >= LF_FACESIZE)
  	    goto theend;			/* Name too long */
  	lf->lfFaceName[p - name] = *p;
      }
*** ../vim-8.0.0071/src/version.c	2016-11-07 22:42:48.828350757 +0100
--- src/version.c	2016-11-10 17:10:11.414402898 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     72,
  /**/

-- 
The Feynman problem solving Algorithm:
	1) Write down the problem
	2) Think real hard
	3) Write down the answer

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0073
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0073 (after 8.0.0069)
Problem:    More comparisons between firstwin and lastwin.
Solution:   Use ONE_WINDOW for consistency. (Hirohito Higashi)
Files:      src/buffer.c, src/ex_cmds.c, src/ex_docmd.c, src/option.c,
            src/window.c


*** ../vim-8.0.0072/src/buffer.c	2016-11-06 15:25:37.689627497 +0100
--- src/buffer.c	2016-11-10 17:42:03.550441517 +0100
***************
*** 1412,1418 ****
  # ifdef FEAT_AUTOCMD
  		   && !(curwin->w_closing || curwin->w_buffer->b_locked > 0)
  # endif
! 		   && (firstwin != lastwin || first_tabpage->tp_next != NULL))
  	{
  	    if (win_close(curwin, FALSE) == FAIL)
  		break;
--- 1412,1418 ----
  # ifdef FEAT_AUTOCMD
  		   && !(curwin->w_closing || curwin->w_buffer->b_locked > 0)
  # endif
! 		   && (!ONE_WINDOW || first_tabpage->tp_next != NULL))
  	{
  	    if (win_close(curwin, FALSE) == FAIL)
  		break;
***************
*** 5140,5146 ****
  			: wp->w_width != Columns)
  		    || (had_tab > 0 && wp != firstwin)
  #endif
! 		    ) && firstwin != lastwin
  #ifdef FEAT_AUTOCMD
  		    && !(wp->w_closing || wp->w_buffer->b_locked > 0)
  #endif
--- 5140,5146 ----
  			: wp->w_width != Columns)
  		    || (had_tab > 0 && wp != firstwin)
  #endif
! 		    ) && !ONE_WINDOW
  #ifdef FEAT_AUTOCMD
  		    && !(wp->w_closing || wp->w_buffer->b_locked > 0)
  #endif
*** ../vim-8.0.0072/src/ex_cmds.c	2016-10-21 20:35:32.632943225 +0200
--- src/ex_cmds.c	2016-11-10 17:42:17.082356600 +0100
***************
*** 4577,4583 ****
      if (eap->forceit)
  	bigness = curwin->w_height;
  #ifdef FEAT_WINDOWS
!     else if (firstwin != lastwin)
  	bigness = curwin->w_height - 3;
  #endif
      else
--- 4577,4583 ----
      if (eap->forceit)
  	bigness = curwin->w_height;
  #ifdef FEAT_WINDOWS
!     else if (!ONE_WINDOW)
  	bigness = curwin->w_height - 3;
  #endif
      else
*** ../vim-8.0.0072/src/ex_docmd.c	2016-11-06 15:25:37.693627473 +0100
--- src/ex_docmd.c	2016-11-10 17:39:17.259485131 +0100
***************
*** 7488,7496 ****
  {
      /* First close all the windows but the current one.  If that worked then
       * close the last window in this tab, that will close it. */
!     if (lastwin != firstwin)
  	close_others(TRUE, forceit);
!     if (lastwin == firstwin)
  	ex_win_close(forceit, curwin, NULL);
  # ifdef FEAT_GUI
      need_mouse_correct = TRUE;
--- 7488,7496 ----
  {
      /* First close all the windows but the current one.  If that worked then
       * close the last window in this tab, that will close it. */
!     if (!ONE_WINDOW)
  	close_others(TRUE, forceit);
!     if (ONE_WINDOW)
  	ex_win_close(forceit, curwin, NULL);
  # ifdef FEAT_GUI
      need_mouse_correct = TRUE;
*** ../vim-8.0.0072/src/option.c	2016-11-05 20:13:29.142451833 +0100
--- src/option.c	2016-11-10 17:42:51.762138974 +0100
***************
*** 8551,8557 ****
  	}
  
  	/* Change window height NOW */
! 	if (lastwin != firstwin)
  	{
  	    if (pp == &p_wh && curwin->w_height < p_wh)
  		win_setheight((int)p_wh);
--- 8551,8557 ----
  	}
  
  	/* Change window height NOW */
! 	if (!ONE_WINDOW)
  	{
  	    if (pp == &p_wh && curwin->w_height < p_wh)
  		win_setheight((int)p_wh);
***************
*** 8591,8597 ****
  	}
  
  	/* Change window width NOW */
! 	if (lastwin != firstwin && curwin->w_width < p_wiw)
  	    win_setwidth((int)p_wiw);
      }
  
--- 8591,8597 ----
  	}
  
  	/* Change window width NOW */
! 	if (!ONE_WINDOW && curwin->w_width < p_wiw)
  	    win_setwidth((int)p_wiw);
      }
  
***************
*** 10075,10081 ****
  comp_col(void)
  {
  #if defined(FEAT_CMDL_INFO) && defined(FEAT_WINDOWS)
!     int last_has_status = (p_ls == 2 || (p_ls == 1 && firstwin != lastwin));
  
      sc_col = 0;
      ru_col = 0;
--- 10075,10081 ----
  comp_col(void)
  {
  #if defined(FEAT_CMDL_INFO) && defined(FEAT_WINDOWS)
!     int last_has_status = (p_ls == 2 || (p_ls == 1 && !ONE_WINDOW));
  
      sc_col = 0;
      ru_col = 0;
*** ../vim-8.0.0072/src/window.c	2016-11-06 15:25:37.697627447 +0100
--- src/window.c	2016-11-10 17:39:17.263485105 +0100
***************
*** 791,797 ****
  	oldwin = curwin;
  
      /* add a status line when p_ls == 1 and splitting the first window */
!     if (lastwin == firstwin && p_ls == 1 && oldwin->w_status_height == 0)
      {
  	if (oldwin->w_height <= p_wmh && new_wp == NULL)
  	{
--- 791,797 ----
  	oldwin = curwin;
  
      /* add a status line when p_ls == 1 and splitting the first window */
!     if (ONE_WINDOW && p_ls == 1 && oldwin->w_status_height == 0)
      {
  	if (oldwin->w_height <= p_wmh && new_wp == NULL)
  	{
***************
*** 1492,1498 ****
      win_T	*wp2;
      int		temp;
  
!     if (lastwin == firstwin)	    /* just one window */
      {
  	beep_flush();
  	return;
--- 1492,1498 ----
      win_T	*wp2;
      int		temp;
  
!     if (ONE_WINDOW)	    /* just one window */
      {
  	beep_flush();
  	return;
***************
*** 1674,1680 ****
      int		dir;
      int		height = curwin->w_height;
  
!     if (lastwin == firstwin)
      {
  	beep_flush();
  	return;
--- 1674,1680 ----
      int		dir;
      int		height = curwin->w_height;
  
!     if (ONE_WINDOW)
      {
  	beep_flush();
  	return;
***************
*** 2123,2129 ****
  
      ++RedrawingDisabled;
  
!     for (wp = firstwin; wp != NULL && lastwin != firstwin; )
      {
  	if (wp->w_buffer == buf && (!keep_curwin || wp != curwin)
  #ifdef FEAT_AUTOCMD
--- 2123,2129 ----
  
      ++RedrawingDisabled;
  
!     for (wp = firstwin; wp != NULL && !ONE_WINDOW; )
      {
  	if (wp->w_buffer == buf && (!keep_curwin || wp != curwin)
  #ifdef FEAT_AUTOCMD
***************
*** 3373,3379 ****
  	}
      }
  
!     if (message && lastwin != firstwin)
  	EMSG(_("E445: Other window contains changes"));
  }
  
--- 3373,3379 ----
  	}
      }
  
!     if (message && !ONE_WINDOW)
  	EMSG(_("E445: Other window contains changes"));
  }
  
***************
*** 5971,5977 ****
  {
      /* Don't make a difference between horizontal or vertical split. */
      last_status_rec(topframe, (p_ls == 2
! 			  || (p_ls == 1 && (morewin || lastwin != firstwin))));
  }
  
      static void
--- 5971,5977 ----
  {
      /* Don't make a difference between horizontal or vertical split. */
      last_status_rec(topframe, (p_ls == 2
! 			  || (p_ls == 1 && (morewin || !ONE_WINDOW))));
  }
  
      static void
*** ../vim-8.0.0072/src/version.c	2016-11-10 17:10:47.494177267 +0100
--- src/version.c	2016-11-10 17:39:46.535301392 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     73,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
11. You find yourself typing "com" after every period when using a word
    processor.com

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0074
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0074
Problem:    Cannot make Vim fail on an internal error.
Solution:   Add IEMSG() and IEMSG2(). (Domenique Pelle)  Avoid reporting an
            internal error without mentioning where.
Files:      src/globals.h, src/blowfish.c, src/dict.c, src/edit.c, src/eval.c,
            src/evalfunc.c, src/ex_eval.c, src/getchar.c, src/gui_beval.c,
            src/gui_w32.c, src/hangulin.c, src/hashtab.c, src/if_cscope.c,
            src/json.c, src/memfile.c, src/memline.c, src/message.c,
            src/misc2.c, src/option.c, src/quickfix.c, src/regexp.c,
            src/spell.c, src/undo.c, src/userfunc.c, src/vim.h, src/window.c,
            src/proto/misc2.pro, src/proto/message.pro, src/Makefile


*** ../vim-8.0.0073/src/globals.h	2016-11-06 15:25:37.689627497 +0100
--- src/globals.h	2016-11-10 18:19:43.448260941 +0100
***************
*** 1440,1445 ****
--- 1440,1446 ----
  EXTERN char_u e_fontwidth[]	INIT(= N_("E236: Font \"%s\" is not fixed-width"));
  #endif
  EXTERN char_u e_internal[]	INIT(= N_("E473: Internal error"));
+ EXTERN char_u e_intern2[]	INIT(= N_("E685: Internal error: %s"));
  EXTERN char_u e_interr[]	INIT(= N_("Interrupted"));
  EXTERN char_u e_invaddr[]	INIT(= N_("E14: Invalid address"));
  EXTERN char_u e_invarg[]	INIT(= N_("E474: Invalid argument"));
***************
*** 1589,1595 ****
  EXTERN char_u e_guarded[]	INIT(= N_("E463: Region is guarded, cannot modify"));
  EXTERN char_u e_nbreadonly[]	INIT(= N_("E744: NetBeans does not allow changes in read-only files"));
  #endif
- EXTERN char_u e_intern2[]	INIT(= N_("E685: Internal error: %s"));
  EXTERN char_u e_maxmempat[]	INIT(= N_("E363: pattern uses more memory than 'maxmempattern'"));
  EXTERN char_u e_emptybuf[]	INIT(= N_("E749: empty buffer"));
  EXTERN char_u e_nobufnr[]	INIT(= N_("E86: Buffer %ld does not exist"));
--- 1590,1595 ----
*** ../vim-8.0.0073/src/blowfish.c	2016-08-29 22:42:20.000000000 +0200
--- src/blowfish.c	2016-11-10 18:24:37.542411483 +0100
***************
*** 426,432 ****
      keylen = (int)STRLEN(key) / 2;
      if (keylen == 0)
      {
! 	EMSG(_("E831: bf_key_init() called with empty password"));
  	return;
      }
      for (i = 0; i < keylen; i++)
--- 426,432 ----
      keylen = (int)STRLEN(key) / 2;
      if (keylen == 0)
      {
! 	IEMSG(_("E831: bf_key_init() called with empty password"));
  	return;
      }
      for (i = 0; i < keylen; i++)
*** ../vim-8.0.0073/src/dict.c	2016-08-29 22:42:20.000000000 +0200
--- src/dict.c	2016-11-10 18:30:42.356117872 +0100
***************
*** 214,220 ****
  
      hi = hash_find(&dict->dv_hashtab, item->di_key);
      if (HASHITEM_EMPTY(hi))
! 	EMSG2(_(e_intern2), "dictitem_remove()");
      else
  	hash_remove(&dict->dv_hashtab, hi);
      dictitem_free(item);
--- 214,220 ----
  
      hi = hash_find(&dict->dv_hashtab, item->di_key);
      if (HASHITEM_EMPTY(hi))
! 	internal_error("dictitem_remove()");
      else
  	hash_remove(&dict->dv_hashtab, hi);
      dictitem_free(item);
*** ../vim-8.0.0073/src/edit.c	2016-10-18 13:06:33.377547323 +0200
--- src/edit.c	2016-11-10 19:21:36.688859519 +0100
***************
*** 2299,2305 ****
  	case CTRL_X_EVAL:
  	    return (c == Ctrl_P || c == Ctrl_N);
      }
!     EMSG(_(e_internal));
      return FALSE;
  }
  
--- 2299,2305 ----
  	case CTRL_X_EVAL:
  	    return (c == Ctrl_P || c == Ctrl_N);
      }
!     internal_error("vim_is_ctrl_x_key()");
      return FALSE;
  }
  
***************
*** 5431,5437 ****
  	}
  	else
  	{
! 	    EMSG2(_(e_intern2), "ins_complete()");
  	    return FAIL;
  	}
  
--- 5431,5437 ----
  	}
  	else
  	{
! 	    internal_error("ins_complete()");
  	    return FAIL;
  	}
  
*** ../vim-8.0.0073/src/eval.c	2016-10-09 17:27:56.863388510 +0200
--- src/eval.c	2016-11-10 18:31:29.847819176 +0100
***************
*** 839,845 ****
      {
  	hi = hash_find(&vimvarht, vimvars[idx].vv_di.di_key);
  	if (HASHITEM_EMPTY(hi))
! 	    EMSG2(_(e_intern2), "restore_vimvar()");
  	else
  	    hash_remove(&vimvarht, hi);
      }
--- 839,845 ----
      {
  	hi = hash_find(&vimvarht, vimvars[idx].vv_di.di_key);
  	if (HASHITEM_EMPTY(hi))
! 	    internal_error("restore_vimvar()");
  	else
  	    hash_remove(&vimvarht, hi);
      }
***************
*** 1308,1314 ****
  	}
  	else if (*arg != ',' && *arg != ']')
  	{
! 	    EMSG2(_(e_intern2), "ex_let_vars()");
  	    return FAIL;
  	}
      }
--- 1308,1314 ----
  	}
  	else if (*arg != ',' && *arg != ']')
  	{
! 	    internal_error("ex_let_vars()");
  	    return FAIL;
  	}
      }
***************
*** 2830,2836 ****
  	    }
  	    if (d == NULL)
  	    {
! 		EMSG2(_(e_intern2), "do_unlet()");
  		return FAIL;
  	    }
  	}
--- 2830,2836 ----
  	    }
  	    if (d == NULL)
  	    {
! 		internal_error("do_unlet()");
  		return FAIL;
  	    }
  	}
***************
*** 5678,5684 ****
  	case VVAL_NONE:  return "v:none";
  	case VVAL_NULL:  return "v:null";
      }
!     EMSG2(_(e_intern2), "get_var_special_name()");
      return "42";
  }
  
--- 5678,5684 ----
  	case VVAL_NONE:  return "v:none";
  	case VVAL_NULL:  return "v:null";
      }
!     internal_error("get_var_special_name()");
      return "42";
  }
  
***************
*** 7152,7158 ****
  	    break;
  #endif
  	case VAR_UNKNOWN:
! 	    EMSG2(_(e_intern2), "get_tv_number(UNKNOWN)");
  	    break;
      }
      if (denote == NULL)		/* useful for values that must be unsigned */
--- 7152,7158 ----
  	    break;
  #endif
  	case VAR_UNKNOWN:
! 	    internal_error("get_tv_number(UNKNOWN)");
  	    break;
      }
      if (denote == NULL)		/* useful for values that must be unsigned */
***************
*** 7199,7205 ****
  	    break;
  # endif
  	case VAR_UNKNOWN:
! 	    EMSG2(_(e_intern2), "get_tv_float(UNKNOWN)");
  	    break;
      }
      return 0;
--- 7199,7205 ----
  	    break;
  # endif
  	case VAR_UNKNOWN:
! 	    internal_error("get_tv_float(UNKNOWN)");
  	    break;
      }
      return 0;
***************
*** 7733,7739 ****
  		return;
  	    }
  	    else if (v->di_tv.v_type != tv->v_type)
! 		EMSG2(_(e_intern2), "set_var()");
  	}
  
  	clear_tv(&v->di_tv);
--- 7733,7739 ----
  		return;
  	    }
  	    else if (v->di_tv.v_type != tv->v_type)
! 		internal_error("set_var()");
  	}
  
  	clear_tv(&v->di_tv);
***************
*** 7962,7968 ****
  	    }
  	    break;
  	case VAR_UNKNOWN:
! 	    EMSG2(_(e_intern2), "copy_tv(UNKNOWN)");
  	    break;
      }
  }
--- 7962,7968 ----
  	    }
  	    break;
  	case VAR_UNKNOWN:
! 	    internal_error("copy_tv(UNKNOWN)");
  	    break;
      }
  }
***************
*** 8036,8042 ****
  		ret = FAIL;
  	    break;
  	case VAR_UNKNOWN:
! 	    EMSG2(_(e_intern2), "item_copy(UNKNOWN)");
  	    ret = FAIL;
      }
      --recurse;
--- 8036,8042 ----
  		ret = FAIL;
  	    break;
  	case VAR_UNKNOWN:
! 	    internal_error("item_copy(UNKNOWN)");
  	    ret = FAIL;
      }
      --recurse;
*** ../vim-8.0.0073/src/evalfunc.c	2016-10-15 17:06:42.090912729 +0200
--- src/evalfunc.c	2016-11-10 18:31:36.215779091 +0100
***************
*** 2644,2650 ****
  	    break;
  #endif
  	case VAR_UNKNOWN:
! 	    EMSG2(_(e_intern2), "f_empty(UNKNOWN)");
  	    n = TRUE;
  	    break;
      }
--- 2644,2650 ----
  	    break;
  #endif
  	case VAR_UNKNOWN:
! 	    internal_error("f_empty(UNKNOWN)");
  	    n = TRUE;
  	    break;
      }
***************
*** 12695,12701 ****
  	case VAR_JOB:     n = VAR_TYPE_JOB; break;
  	case VAR_CHANNEL: n = VAR_TYPE_CHANNEL; break;
  	case VAR_UNKNOWN:
! 	     EMSG2(_(e_intern2), "f_type(UNKNOWN)");
  	     n = -1;
  	     break;
      }
--- 12695,12701 ----
  	case VAR_JOB:     n = VAR_TYPE_JOB; break;
  	case VAR_CHANNEL: n = VAR_TYPE_CHANNEL; break;
  	case VAR_UNKNOWN:
! 	     internal_error("f_type(UNKNOWN)");
  	     n = -1;
  	     break;
      }
*** ../vim-8.0.0073/src/ex_eval.c	2016-08-29 22:42:20.000000000 +0200
--- src/ex_eval.c	2016-11-10 19:26:49.226873434 +0100
***************
*** 595,601 ****
  
      if (excp == NULL)
      {
! 	EMSG(_(e_internal));
  	return;
      }
  
--- 595,601 ----
  
      if (excp == NULL)
      {
! 	internal_error("discard_exception()");
  	return;
      }
  
***************
*** 700,706 ****
  finish_exception(except_T *excp)
  {
      if (excp != caught_stack)
! 	EMSG(_(e_internal));
      caught_stack = caught_stack->caught;
      if (caught_stack != NULL)
      {
--- 700,706 ----
  finish_exception(except_T *excp)
  {
      if (excp != caught_stack)
! 	internal_error("finish_exception()");
      caught_stack = caught_stack->caught;
      if (caught_stack != NULL)
      {
***************
*** 1603,1609 ****
  	     * ":break", ":return", ":finish", error, interrupt, or another
  	     * exception. */
  	    if (cstack->cs_exception[cstack->cs_idx] != current_exception)
! 		EMSG(_(e_internal));
  	}
  	else
  	{
--- 1603,1609 ----
  	     * ":break", ":return", ":finish", error, interrupt, or another
  	     * exception. */
  	    if (cstack->cs_exception[cstack->cs_idx] != current_exception)
! 		internal_error("ex_catch()");
  	}
  	else
  	{
***************
*** 1737,1743 ****
  		 * exception will be discarded. */
  		if (did_throw && cstack->cs_exception[cstack->cs_idx]
  							 != current_exception)
! 		    EMSG(_(e_internal));
  	    }
  
  	    /*
--- 1737,1743 ----
  		 * exception will be discarded. */
  		if (did_throw && cstack->cs_exception[cstack->cs_idx]
  							 != current_exception)
! 		    internal_error("ex_finally()");
  	    }
  
  	    /*
*** ../vim-8.0.0073/src/getchar.c	2016-08-29 22:42:20.000000000 +0200
--- src/getchar.c	2016-11-10 18:31:44.727725510 +0100
***************
*** 250,256 ****
      }
      else if (buf->bh_curr == NULL)	/* buffer has already been read */
      {
! 	EMSG(_("E222: Add to read buffer"));
  	return;
      }
      else if (buf->bh_index != 0)
--- 250,256 ----
      }
      else if (buf->bh_curr == NULL)	/* buffer has already been read */
      {
! 	IEMSG(_("E222: Add to read buffer"));
  	return;
      }
      else if (buf->bh_index != 0)
***************
*** 1321,1331 ****
  free_typebuf(void)
  {
      if (typebuf.tb_buf == typebuf_init)
! 	EMSG2(_(e_intern2), "Free typebuf 1");
      else
  	vim_free(typebuf.tb_buf);
      if (typebuf.tb_noremap == noremapbuf_init)
! 	EMSG2(_(e_intern2), "Free typebuf 2");
      else
  	vim_free(typebuf.tb_noremap);
  }
--- 1321,1331 ----
  free_typebuf(void)
  {
      if (typebuf.tb_buf == typebuf_init)
! 	internal_error("Free typebuf 1");
      else
  	vim_free(typebuf.tb_buf);
      if (typebuf.tb_noremap == noremapbuf_init)
! 	internal_error("Free typebuf 2");
      else
  	vim_free(typebuf.tb_noremap);
  }
***************
*** 4868,4874 ****
  			c1 = 'l';
  			break;
  		    default:
! 			EMSG(_("E228: makemap: Illegal mode"));
  			return FAIL;
  		}
  		do	/* do this twice if c2 is set, 3 times with c3 */
--- 4868,4874 ----
  			c1 = 'l';
  			break;
  		    default:
! 			IEMSG(_("E228: makemap: Illegal mode"));
  			return FAIL;
  		}
  		do	/* do this twice if c2 is set, 3 times with c3 */
*** ../vim-8.0.0073/src/gui_beval.c	2016-09-09 22:00:25.000000000 +0200
--- src/gui_beval.c	2016-11-10 18:24:37.550411433 +0100
***************
*** 218,224 ****
  
      if (mesg != NULL && mesgCB != NULL)
      {
! 	EMSG(_("E232: Cannot create BalloonEval with both message and callback"));
  	return NULL;
      }
  
--- 218,224 ----
  
      if (mesg != NULL && mesgCB != NULL)
      {
! 	IEMSG(_("E232: Cannot create BalloonEval with both message and callback"));
  	return NULL;
      }
  
*** ../vim-8.0.0073/src/gui_w32.c	2016-10-12 14:19:55.746357751 +0200
--- src/gui_w32.c	2016-11-10 18:24:37.550411433 +0100
***************
*** 8620,8626 ****
  
      if (mesg != NULL && mesgCB != NULL)
      {
! 	EMSG(_("E232: Cannot create BalloonEval with both message and callback"));
  	return NULL;
      }
  
--- 8620,8626 ----
  
      if (mesg != NULL && mesgCB != NULL)
      {
! 	IEMSG(_("E232: Cannot create BalloonEval with both message and callback"));
  	return NULL;
      }
  
*** ../vim-8.0.0073/src/hangulin.c	2016-08-29 22:42:20.000000000 +0200
--- src/hangulin.c	2016-11-10 18:24:37.550411433 +0100
***************
*** 590,596 ****
  	    return AUTOMATA_CORRECT_NEW;
  
  	default:
! 	    EMSG(_("E256: Hangul automata ERROR"));
  	    break;
      }
      return AUTOMATA_ERROR; /* RrEeAaLlLlYy EeRrRrOoRr */
--- 590,596 ----
  	    return AUTOMATA_CORRECT_NEW;
  
  	default:
! 	    IEMSG(_("E256: Hangul automata ERROR"));
  	    break;
      }
      return AUTOMATA_ERROR; /* RrEeAaLlLlYy EeRrRrOoRr */
*** ../vim-8.0.0073/src/hashtab.c	2016-08-29 22:42:20.000000000 +0200
--- src/hashtab.c	2016-11-10 18:31:48.775700031 +0100
***************
*** 210,216 ****
      hi = hash_lookup(ht, key, hash);
      if (!HASHITEM_EMPTY(hi))
      {
! 	EMSG2(_(e_intern2), "hash_add()");
  	return FAIL;
      }
      return hash_add_item(ht, hi, key, hash);
--- 210,216 ----
      hi = hash_lookup(ht, key, hash);
      if (!HASHITEM_EMPTY(hi))
      {
! 	internal_error("hash_add()");
  	return FAIL;
      }
      return hash_add_item(ht, hi, key, hash);
*** ../vim-8.0.0073/src/if_cscope.c	2016-11-06 14:46:40.644143343 +0100
--- src/if_cscope.c	2016-11-10 19:59:00.346602378 +0100
***************
*** 1792,1798 ****
  	cs_print_tags_priv(mp, cp, cnt);
  	break;
      default:	/* should not reach here */
! 	(void)EMSG(_("E570: fatal error in cs_manage_matches"));
  	return NULL;
      }
  
--- 1792,1798 ----
  	cs_print_tags_priv(mp, cp, cnt);
  	break;
      default:	/* should not reach here */
! 	IEMSG(_("E570: fatal error in cs_manage_matches"));
  	return NULL;
      }
  
*** ../vim-8.0.0073/src/json.c	2016-11-06 14:17:13.182972857 +0100
--- src/json.c	2016-11-10 18:31:52.663675557 +0100
***************
*** 328,334 ****
  	    break;
  #endif
  	case VAR_UNKNOWN:
! 	    EMSG2(_(e_intern2), "json_encode_item()");
  	    return FAIL;
      }
      return OK;
--- 328,334 ----
  	    break;
  #endif
  	case VAR_UNKNOWN:
! 	    internal_error("json_encode_item()");
  	    return FAIL;
      }
      return OK;
*** ../vim-8.0.0073/src/memfile.c	2016-08-29 22:42:20.000000000 +0200
--- src/memfile.c	2016-11-10 18:24:37.550411433 +0100
***************
*** 482,488 ****
      flags = hp->bh_flags;
  
      if ((flags & BH_LOCKED) == 0)
! 	EMSG(_("E293: block was not locked"));
      flags &= ~BH_LOCKED;
      if (dirty)
      {
--- 482,488 ----
      flags = hp->bh_flags;
  
      if ((flags & BH_LOCKED) == 0)
! 	IEMSG(_("E293: block was not locked"));
      flags &= ~BH_LOCKED;
      if (dirty)
      {
*** ../vim-8.0.0073/src/memline.c	2016-08-29 22:42:20.000000000 +0200
--- src/memline.c	2016-11-10 19:28:51.582093727 +0100
***************
*** 333,339 ****
  	goto error;
      if (hp->bh_bnum != 0)
      {
! 	EMSG(_("E298: Didn't get block nr 0?"));
  	goto error;
      }
      b0p = (ZERO_BL *)(hp->bh_data);
--- 333,339 ----
  	goto error;
      if (hp->bh_bnum != 0)
      {
! 	IEMSG(_("E298: Didn't get block nr 0?"));
  	goto error;
      }
      b0p = (ZERO_BL *)(hp->bh_data);
***************
*** 383,389 ****
  	goto error;
      if (hp->bh_bnum != 1)
      {
! 	EMSG(_("E298: Didn't get block nr 1?"));
  	goto error;
      }
      pp = (PTR_BL *)(hp->bh_data);
--- 383,389 ----
  	goto error;
      if (hp->bh_bnum != 1)
      {
! 	IEMSG(_("E298: Didn't get block nr 1?"));
  	goto error;
      }
      pp = (PTR_BL *)(hp->bh_data);
***************
*** 401,407 ****
  	goto error;
      if (hp->bh_bnum != 2)
      {
! 	EMSG(_("E298: Didn't get block nr 2?"));
  	goto error;
      }
  
--- 401,407 ----
  	goto error;
      if (hp->bh_bnum != 2)
      {
! 	IEMSG(_("E298: Didn't get block nr 2?"));
  	goto error;
      }
  
***************
*** 950,956 ****
  
      b0p = (ZERO_BL *)(hp->bh_data);
      if (ml_check_b0_id(b0p) == FAIL)
! 	EMSG(_("E304: ml_upd_block0(): Didn't get block 0??"));
      else
      {
  	if (what == UB_FNAME)
--- 950,956 ----
  
      b0p = (ZERO_BL *)(hp->bh_data);
      if (ml_check_b0_id(b0p) == FAIL)
! 	IEMSG(_("E304: ml_upd_block0(): Didn't get block 0??"));
      else
      {
  	if (what == UB_FNAME)
***************
*** 2450,2456 ****
  	    /* Avoid giving this message for a recursive call, may happen when
  	     * the GUI redraws part of the text. */
  	    ++recursive;
! 	    EMSGN(_("E315: ml_get: invalid lnum: %ld"), lnum);
  	    --recursive;
  	}
  errorret:
--- 2450,2456 ----
  	    /* Avoid giving this message for a recursive call, may happen when
  	     * the GUI redraws part of the text. */
  	    ++recursive;
! 	    IEMSGN(_("E315: ml_get: invalid lnum: %ld"), lnum);
  	    --recursive;
  	}
  errorret:
***************
*** 2485,2491 ****
  		/* Avoid giving this message for a recursive call, may happen
  		 * when the GUI redraws part of the text. */
  		++recursive;
! 		EMSGN(_("E316: ml_get: cannot find line %ld"), lnum);
  		--recursive;
  	    }
  	    goto errorret;
--- 2485,2491 ----
  		/* Avoid giving this message for a recursive call, may happen
  		 * when the GUI redraws part of the text. */
  		++recursive;
! 		IEMSGN(_("E316: ml_get: cannot find line %ld"), lnum);
  		--recursive;
  	    }
  	    goto errorret;
***************
*** 2900,2906 ****
  	    pp = (PTR_BL *)(hp->bh_data);   /* must be pointer block */
  	    if (pp->pb_id != PTR_ID)
  	    {
! 		EMSG(_("E317: pointer block id wrong 3"));
  		mf_put(mfp, hp, FALSE, FALSE);
  		return FAIL;
  	    }
--- 2900,2906 ----
  	    pp = (PTR_BL *)(hp->bh_data);   /* must be pointer block */
  	    if (pp->pb_id != PTR_ID)
  	    {
! 		IEMSG(_("E317: pointer block id wrong 3"));
  		mf_put(mfp, hp, FALSE, FALSE);
  		return FAIL;
  	    }
***************
*** 3042,3048 ****
  	 */
  	if (stack_idx < 0)
  	{
! 	    EMSG(_("E318: Updated too many blocks?"));
  	    buf->b_ml.ml_stack_top = 0;	/* invalidate stack */
  	}
      }
--- 3042,3048 ----
  	 */
  	if (stack_idx < 0)
  	{
! 	    IEMSG(_("E318: Updated too many blocks?"));
  	    buf->b_ml.ml_stack_top = 0;	/* invalidate stack */
  	}
      }
***************
*** 3220,3226 ****
  	    pp = (PTR_BL *)(hp->bh_data);   /* must be pointer block */
  	    if (pp->pb_id != PTR_ID)
  	    {
! 		EMSG(_("E317: pointer block id wrong 4"));
  		mf_put(mfp, hp, FALSE, FALSE);
  		return FAIL;
  	    }
--- 3220,3226 ----
  	    pp = (PTR_BL *)(hp->bh_data);   /* must be pointer block */
  	    if (pp->pb_id != PTR_ID)
  	    {
! 		IEMSG(_("E317: pointer block id wrong 4"));
  		mf_put(mfp, hp, FALSE, FALSE);
  		return FAIL;
  	    }
***************
*** 3432,3438 ****
  
  	hp = ml_find_line(buf, lnum, ML_FIND);
  	if (hp == NULL)
! 	    EMSGN(_("E320: Cannot find line %ld"), lnum);
  	else
  	{
  	    dp = (DATA_BL *)(hp->bh_data);
--- 3432,3438 ----
  
  	hp = ml_find_line(buf, lnum, ML_FIND);
  	if (hp == NULL)
! 	    IEMSGN(_("E320: Cannot find line %ld"), lnum);
  	else
  	{
  	    dp = (DATA_BL *)(hp->bh_data);
***************
*** 3674,3680 ****
  	pp = (PTR_BL *)(dp);		/* must be pointer block */
  	if (pp->pb_id != PTR_ID)
  	{
! 	    EMSG(_("E317: pointer block id wrong"));
  	    goto error_block;
  	}
  
--- 3674,3680 ----
  	pp = (PTR_BL *)(dp);		/* must be pointer block */
  	if (pp->pb_id != PTR_ID)
  	{
! 	    IEMSG(_("E317: pointer block id wrong"));
  	    goto error_block;
  	}
  
***************
*** 3719,3729 ****
  	if (idx >= (int)pp->pb_count)	    /* past the end: something wrong! */
  	{
  	    if (lnum > buf->b_ml.ml_line_count)
! 		EMSGN(_("E322: line number out of range: %ld past the end"),
  					      lnum - buf->b_ml.ml_line_count);
  
  	    else
! 		EMSGN(_("E323: line count wrong in block %ld"), bnum);
  	    goto error_block;
  	}
  	if (action == ML_DELETE)
--- 3719,3729 ----
  	if (idx >= (int)pp->pb_count)	    /* past the end: something wrong! */
  	{
  	    if (lnum > buf->b_ml.ml_line_count)
! 		IEMSGN(_("E322: line number out of range: %ld past the end"),
  					      lnum - buf->b_ml.ml_line_count);
  
  	    else
! 		IEMSGN(_("E323: line count wrong in block %ld"), bnum);
  	    goto error_block;
  	}
  	if (action == ML_DELETE)
***************
*** 3817,3823 ****
  	if (pp->pb_id != PTR_ID)
  	{
  	    mf_put(mfp, hp, FALSE, FALSE);
! 	    EMSG(_("E317: pointer block id wrong 2"));
  	    break;
  	}
  	pp->pb_pointer[ip->ip_index].pe_line_count += count;
--- 3817,3823 ----
  	if (pp->pb_id != PTR_ID)
  	{
  	    mf_put(mfp, hp, FALSE, FALSE);
! 	    IEMSG(_("E317: pointer block id wrong 2"));
  	    break;
  	}
  	pp->pb_pointer[ip->ip_index].pe_line_count += count;
*** ../vim-8.0.0073/src/message.c	2016-09-09 14:10:47.000000000 +0200
--- src/message.c	2016-11-10 19:31:12.797194172 +0100
***************
*** 662,667 ****
--- 662,668 ----
      return msg_attr(s, attr);
  }
  
+ 
  /*
   * Print an error message with one "%s" and one string argument.
   */
***************
*** 671,676 ****
--- 672,755 ----
      return emsg3(s, a1, NULL);
  }
  
+ /*
+  * Print an error message with one or two "%s" and one or two string arguments.
+  * This is not in message.c to avoid a warning for prototypes.
+  */
+     int
+ emsg3(char_u *s, char_u *a1, char_u *a2)
+ {
+     if (emsg_not_now())
+ 	return TRUE;		/* no error messages at the moment */
+     vim_snprintf((char *)IObuff, IOSIZE, (char *)s, a1, a2);
+     return emsg(IObuff);
+ }
+ 
+ /*
+  * Print an error message with one "%ld" and one long int argument.
+  * This is not in message.c to avoid a warning for prototypes.
+  */
+     int
+ emsgn(char_u *s, long n)
+ {
+     if (emsg_not_now())
+ 	return TRUE;		/* no error messages at the moment */
+     vim_snprintf((char *)IObuff, IOSIZE, (char *)s, n);
+     return emsg(IObuff);
+ }
+ 
+ /*
+  * Same as emsg(...), but abort on error when ABORT_ON_INTERNAL_ERROR is
+  * defined. It is used for internal errors only, so that they can be
+  * detected when fuzzing vim.
+  */
+     void
+ iemsg(char_u *s)
+ {
+     msg(s);
+ #ifdef ABORT_ON_INTERNAL_ERROR
+     abort();
+ #endif
+ }
+ 
+ 
+ /*
+  * Same as emsg2(...) but abort on error when ABORT_ON_INTERNAL_ERROR is
+  * defined. It is used for internal errors only, so that they can be
+  * detected when fuzzing vim.
+  */
+     void
+ iemsg2(char_u *s, char_u *a1)
+ {
+     emsg2(s, a1);
+ #ifdef ABORT_ON_INTERNAL_ERROR
+     abort();
+ #endif
+ }
+ 
+ /*
+  * Same as emsgn(...) but abort on error when ABORT_ON_INTERNAL_ERROR is
+  * defined. It is used for internal errors only, so that they can be
+  * detected when fuzzing vim.
+  */
+     void
+ iemsgn(char_u *s, long n)
+ {
+     emsgn(s, n);
+ #ifdef ABORT_ON_INTERNAL_ERROR
+     abort();
+ #endif
+ }
+ 
+ /*
+  * Give an "Internal error" message.
+  */
+     void
+ internal_error(char *where)
+ {
+     IEMSG2(_(e_intern2), where);
+ }
+ 
  /* emsg3() and emsgn() are in misc2.c to avoid warnings for the prototypes. */
  
      void
*** ../vim-8.0.0073/src/misc2.c	2016-10-30 21:57:48.074395566 +0100
--- src/misc2.c	2016-11-10 18:25:56.829912944 +0100
***************
*** 918,924 ****
      {
  	/* Don't hide this message */
  	emsg_silent = 0;
! 	EMSGN(_("E341: Internal error: lalloc(%ld, )"), size);
  	return NULL;
      }
  
--- 918,924 ----
      {
  	/* Don't hide this message */
  	emsg_silent = 0;
! 	IEMSGN(_("E341: Internal error: lalloc(%ld, )"), size);
  	return NULL;
      }
  
***************
*** 1075,1081 ****
      p_ea = FALSE;
      if (first_tabpage->tp_next != NULL)
  	do_cmdline_cmd((char_u *)"tabonly!");
!     if (firstwin != lastwin)
  	do_cmdline_cmd((char_u *)"only!");
  # endif
  
--- 1075,1081 ----
      p_ea = FALSE;
      if (first_tabpage->tp_next != NULL)
  	do_cmdline_cmd((char_u *)"tabonly!");
!     if (!ONE_WINDOW)
  	do_cmdline_cmd((char_u *)"only!");
  # endif
  
***************
*** 6040,6071 ****
  }
  #endif
  
- /*
-  * Print an error message with one or two "%s" and one or two string arguments.
-  * This is not in message.c to avoid a warning for prototypes.
-  */
-     int
- emsg3(char_u *s, char_u *a1, char_u *a2)
- {
-     if (emsg_not_now())
- 	return TRUE;		/* no error messages at the moment */
-     vim_snprintf((char *)IObuff, IOSIZE, (char *)s, a1, a2);
-     return emsg(IObuff);
- }
- 
- /*
-  * Print an error message with one "%ld" and one long int argument.
-  * This is not in message.c to avoid a warning for prototypes.
-  */
-     int
- emsgn(char_u *s, long n)
- {
-     if (emsg_not_now())
- 	return TRUE;		/* no error messages at the moment */
-     vim_snprintf((char *)IObuff, IOSIZE, (char *)s, n);
-     return emsg(IObuff);
- }
- 
  #if defined(FEAT_SPELL) || defined(FEAT_PERSISTENT_UNDO) || defined(PROTO)
  /*
   * Read 2 bytes from "fd" and turn them into an int, MSB first.
--- 6040,6045 ----
*** ../vim-8.0.0073/src/option.c	2016-11-10 18:16:30.081477202 +0100
--- src/option.c	2016-11-10 18:32:36.615398904 +0100
***************
*** 5615,5621 ****
  	flagp = insecure_flag(idx, opt_flags);
  	return (*flagp & P_INSECURE) != 0;
      }
!     EMSG2(_(e_intern2), "was_set_insecurely()");
      return -1;
  }
  
--- 5615,5621 ----
  	flagp = insecure_flag(idx, opt_flags);
  	return (*flagp & P_INSECURE) != 0;
      }
!     internal_error("was_set_insecurely()");
      return -1;
  }
  
***************
*** 5696,5702 ****
  	if (idx < 0)	/* not found (should not happen) */
  	{
  	    EMSG2(_(e_intern2), "set_string_option_direct()");
! 	    EMSG2(_("For option %s"), name);
  	    return;
  	}
      }
--- 5696,5702 ----
  	if (idx < 0)	/* not found (should not happen) */
  	{
  	    EMSG2(_(e_intern2), "set_string_option_direct()");
! 	    IEMSG2(_("For option %s"), name);
  	    return;
  	}
      }
***************
*** 9375,9381 ****
  		    ret = NULL;
  		break;
  	    default:
! 		EMSG2(_(e_intern2), "option_iter_next()");
  		return NULL;
  	}
      }
--- 9375,9381 ----
  		    ret = NULL;
  		break;
  	    default:
! 		internal_error("option_iter_next()");
  		return NULL;
  	}
      }
***************
*** 10496,10502 ****
  #ifdef FEAT_SIGNS
  	case PV_SCL:	return (char_u *)&(curwin->w_p_scl);
  #endif
! 	default:	EMSG(_("E356: get_varp ERROR"));
      }
      /* always return a valid pointer to avoid a crash! */
      return (char_u *)&(curbuf->b_p_wm);
--- 10496,10502 ----
  #ifdef FEAT_SIGNS
  	case PV_SCL:	return (char_u *)&(curwin->w_p_scl);
  #endif
! 	default:	IEMSG(_("E356: get_varp ERROR"));
      }
      /* always return a valid pointer to avoid a crash! */
      return (char_u *)&(curbuf->b_p_wm);
*** ../vim-8.0.0073/src/quickfix.c	2016-11-06 15:25:37.697627447 +0100
--- src/quickfix.c	2016-11-10 18:32:41.083370781 +0100
***************
*** 3231,3237 ****
      {
  	if (buf != curbuf)
  	{
! 	    EMSG2(_(e_intern2), "qf_fill_buffer()");
  	    return;
  	}
  
--- 3231,3237 ----
      {
  	if (buf != curbuf)
  	{
! 	    internal_error("qf_fill_buffer()");
  	    return;
  	}
  
*** ../vim-8.0.0073/src/regexp.c	2016-10-02 16:51:32.744592886 +0200
--- src/regexp.c	2016-11-10 19:30:29.309471156 +0100
***************
*** 335,345 ****
--- 335,347 ----
  /* Used for an error (down from) vim_regcomp(): give the error message, set
   * rc_did_emsg and return NULL */
  #define EMSG_RET_NULL(m) return (EMSG(m), rc_did_emsg = TRUE, (void *)NULL)
+ #define IEMSG_RET_NULL(m) return (IEMSG(m), rc_did_emsg = TRUE, (void *)NULL)
  #define EMSG_RET_FAIL(m) return (EMSG(m), rc_did_emsg = TRUE, FAIL)
  #define EMSG2_RET_NULL(m, c) return (EMSG2((m), (c) ? "" : "\\"), rc_did_emsg = TRUE, (void *)NULL)
  #define EMSG2_RET_FAIL(m, c) return (EMSG2((m), (c) ? "" : "\\"), rc_did_emsg = TRUE, FAIL)
  #define EMSG_ONE_RET_NULL EMSG2_RET_NULL(_("E369: invalid item in %s%%[]"), reg_magic == MAGIC_ALL)
  
+ 
  #define MAX_LIMIT	(32767L << 16L)
  
  static int re_multi_type(int);
***************
*** 2043,2049 ****
        case Magic(')'):
  	if (one_exactly)
  	    EMSG_ONE_RET_NULL;
! 	EMSG_RET_NULL(_(e_internal));	/* Supposed to be caught earlier. */
  	/* NOTREACHED */
  
        case Magic('='):
--- 2045,2051 ----
        case Magic(')'):
  	if (one_exactly)
  	    EMSG_ONE_RET_NULL;
! 	IEMSG_RET_NULL(_(e_internal));	/* Supposed to be caught earlier. */
  	/* NOTREACHED */
  
        case Magic('='):
***************
*** 5070,5076 ****
  		}
  		else
  		{
! 		    EMSG(_(e_internal));	    /* Shouldn't happen */
  		    status = RA_FAIL;
  		}
  	    }
--- 5072,5078 ----
  		}
  		else
  		{
! 		    internal_error("BRACE_LIMITS");
  		    status = RA_FAIL;
  		}
  	    }
*** ../vim-8.0.0073/src/spell.c	2016-10-15 17:06:42.090912729 +0200
--- src/spell.c	2016-11-10 18:32:45.507342935 +0100
***************
*** 6428,6434 ****
      sfwordnr = soundfold_find(slang, goodword);
      if (sfwordnr < 0)
      {
! 	EMSG2(_(e_intern2), "add_sound_suggest()");
  	return;
      }
  
--- 6428,6434 ----
      sfwordnr = soundfold_find(slang, goodword);
      if (sfwordnr < 0)
      {
! 	internal_error("add_sound_suggest()");
  	return;
      }
  
*** ../vim-8.0.0073/src/undo.c	2016-11-05 14:58:30.767225798 +0100
--- src/undo.c	2016-11-10 18:33:12.555172690 +0100
***************
*** 2582,2588 ****
  	    if (uhp == NULL || uhp->uh_walk != mark)
  	    {
  		/* Need to redo more but can't find it... */
! 		EMSG2(_(e_intern2), "undo_time()");
  		break;
  	    }
  	}
--- 2582,2588 ----
  	    if (uhp == NULL || uhp->uh_walk != mark)
  	    {
  		/* Need to redo more but can't find it... */
! 		internal_error("undo_time()");
  		break;
  	    }
  	}
***************
*** 2654,2660 ****
  #ifdef FEAT_AUTOCMD
  	    unblock_autocmds();
  #endif
! 	    EMSG(_("E438: u_undo: line numbers wrong"));
  	    changed();		/* don't want UNCHANGED now */
  	    return;
  	}
--- 2654,2660 ----
  #ifdef FEAT_AUTOCMD
  	    unblock_autocmds();
  #endif
! 	    IEMSG(_("E438: u_undo: line numbers wrong"));
  	    changed();		/* don't want UNCHANGED now */
  	    return;
  	}
***************
*** 3234,3240 ****
  {
      if (curbuf->b_u_newhead == NULL || curbuf->b_u_newhead->uh_entry == NULL)
      {
! 	EMSG(_("E439: undo list corrupt"));
  	return NULL;
      }
      return curbuf->b_u_newhead->uh_entry;
--- 3234,3240 ----
  {
      if (curbuf->b_u_newhead == NULL || curbuf->b_u_newhead->uh_entry == NULL)
      {
! 	IEMSG(_("E439: undo list corrupt"));
  	return NULL;
      }
      return curbuf->b_u_newhead->uh_entry;
***************
*** 3266,3272 ****
  	uep->ue_bot = uep->ue_top + uep->ue_size + 1 + extra;
  	if (uep->ue_bot < 1 || uep->ue_bot > curbuf->b_ml.ml_line_count)
  	{
! 	    EMSG(_("E440: undo line missing"));
  	    uep->ue_bot = uep->ue_top + 1;  /* assume all lines deleted, will
  					     * get all the old lines back
  					     * without deleting the current
--- 3266,3272 ----
  	uep->ue_bot = uep->ue_top + uep->ue_size + 1 + extra;
  	if (uep->ue_bot < 1 || uep->ue_bot > curbuf->b_ml.ml_line_count)
  	{
! 	    IEMSG(_("E440: undo line missing"));
  	    uep->ue_bot = uep->ue_top + 1;  /* assume all lines deleted, will
  					     * get all the old lines back
  					     * without deleting the current
*** ../vim-8.0.0073/src/userfunc.c	2016-08-29 22:42:21.000000000 +0200
--- src/userfunc.c	2016-11-10 18:33:33.335041901 +0100
***************
*** 2771,2777 ****
  #ifdef EXITFREE
  	if (!entered_free_all_mem)
  #endif
! 	    EMSG2(_(e_intern2), "func_unref()");
      }
      if (fp != NULL && --fp->uf_refcount <= 0)
      {
--- 2771,2777 ----
  #ifdef EXITFREE
  	if (!entered_free_all_mem)
  #endif
! 	    internal_error("func_unref()");
      }
      if (fp != NULL && --fp->uf_refcount <= 0)
      {
***************
*** 2814,2820 ****
      else if (isdigit(*name))
  	/* Only give an error for a numbered function.
  	 * Fail silently, when named or lambda function isn't found. */
! 	EMSG2(_(e_intern2), "func_ref()");
  }
  
  /*
--- 2814,2820 ----
      else if (isdigit(*name))
  	/* Only give an error for a numbered function.
  	 * Fail silently, when named or lambda function isn't found. */
! 	internal_error("func_ref()");
  }
  
  /*
*** ../vim-8.0.0073/src/vim.h	2016-10-15 19:33:47.264689748 +0200
--- src/vim.h	2016-11-10 18:24:37.562411357 +0100
***************
*** 1623,1628 ****
--- 1623,1631 ----
  #define EMSG3(s, p, q)		    emsg3((char_u *)(s), (char_u *)(p), (char_u *)(q))
  #define EMSGN(s, n)		    emsgn((char_u *)(s), (long)(n))
  #define EMSGU(s, n)		    emsgu((char_u *)(s), (long_u)(n))
+ #define IEMSG(s)		    iemsg((char_u *)(s))
+ #define IEMSG2(s, p)		    iemsg2((char_u *)(s), (char_u *)(p))
+ #define IEMSGN(s, n)		    iemsgn((char_u *)(s), (long)(n))
  #define OUT_STR(s)		    out_str((char_u *)(s))
  #define OUT_STR_NF(s)		    out_str_nf((char_u *)(s))
  #define MSG_PUTS(s)		    msg_puts((char_u *)(s))
*** ../vim-8.0.0073/src/window.c	2016-11-10 18:16:30.085477176 +0100
--- src/window.c	2016-11-10 18:33:40.198998700 +0100
***************
*** 2538,2544 ****
  		;
  	    if (ptp == NULL)
  	    {
! 		EMSG2(_(e_intern2), "win_close_othertab()");
  		return;
  	    }
  	    ptp->tp_next = tp->tp_next;
--- 2538,2544 ----
  		;
  	    if (ptp == NULL)
  	    {
! 		internal_error("win_close_othertab()");
  		return;
  	    }
  	    ptp->tp_next = tp->tp_next;
*** ../vim-8.0.0073/src/proto/misc2.pro	2016-09-12 13:04:13.000000000 +0200
--- src/proto/misc2.pro	2016-11-10 18:33:58.170885586 +0100
***************
*** 99,106 ****
  void sort_strings(char_u **files, int count);
  int pathcmp(const char *p, const char *q, int maxlen);
  int filewritable(char_u *fname);
- int emsg3(char_u *s, char_u *a1, char_u *a2);
- int emsgn(char_u *s, long n);
  int get2c(FILE *fd);
  int get3c(FILE *fd);
  int get4c(FILE *fd);
--- 99,104 ----
*** ../vim-8.0.0073/src/proto/message.pro	2016-09-12 13:04:12.000000000 +0200
--- src/proto/message.pro	2016-11-10 19:31:16.885168138 +0100
***************
*** 11,16 ****
--- 11,22 ----
  void do_perror(char *msg);
  int emsg(char_u *s);
  int emsg2(char_u *s, char_u *a1);
+ int emsg3(char_u *s, char_u *a1, char_u *a2);
+ int emsgn(char_u *s, long n);
+ void iemsg(char_u *s);
+ void iemsg2(char_u *s, char_u *a1);
+ void iemsgn(char_u *s, long n);
+ void internal_error(char *where);
  void emsg_invreg(int name);
  char_u *msg_trunc_attr(char_u *s, int force, int attr);
  char_u *msg_may_trunc(int force, char_u *s);
*** ../vim-8.0.0073/src/Makefile	2016-10-15 17:06:42.094912699 +0200
--- src/Makefile	2016-11-10 19:56:03.919720882 +0100
***************
*** 681,686 ****
--- 681,690 ----
  #LEAK_CFLAGS = -DEXITFREE
  #LEAK_LIBS = -lccmalloc
  
+ # Uncomment this line to have Vim call abort() when an internal error is
+ # detected.  Useful when using a tool to find errors.
+ #ABORT_CLFAGS = -DABORT_ON_INTERNAL_ERROR
+ 
  #####################################################
  ###  Specific systems, check if yours is listed!  ### {{{
  #####################################################
***************
*** 1409,1415 ****
  PRE_DEFS = -Iproto $(DEFS) $(GUI_DEFS) $(GUI_IPATH) $(CPPFLAGS) $(EXTRA_IPATHS)
  POST_DEFS = $(X_CFLAGS) $(MZSCHEME_CFLAGS) $(EXTRA_DEFS)
  
! ALL_CFLAGS = $(PRE_DEFS) $(CFLAGS) $(PROFILE_CFLAGS) $(SANITIZER_CFLAGS) $(LEAK_CFLAGS) $(POST_DEFS)
  
  # Exclude $CFLAGS for osdef.sh, for Mac 10.4 some flags don't work together
  # with "-E".
--- 1413,1419 ----
  PRE_DEFS = -Iproto $(DEFS) $(GUI_DEFS) $(GUI_IPATH) $(CPPFLAGS) $(EXTRA_IPATHS)
  POST_DEFS = $(X_CFLAGS) $(MZSCHEME_CFLAGS) $(EXTRA_DEFS)
  
! ALL_CFLAGS = $(PRE_DEFS) $(CFLAGS) $(PROFILE_CFLAGS) $(SANITIZER_CFLAGS) $(LEAK_CFLAGS) $(ABORT_CLFAGS) $(POST_DEFS)
  
  # Exclude $CFLAGS for osdef.sh, for Mac 10.4 some flags don't work together
  # with "-E".
*** ../vim-8.0.0073/src/version.c	2016-11-10 18:16:30.085477176 +0100
--- src/version.c	2016-11-10 19:41:18.085342236 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     74,
  /**/

-- 
Me?  A skeptic?  I trust you have proof.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0075
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0075
Problem:    Using number for exception type lacks type checking.
Solution:   Use an enum.
Files:      src/structs.h, src/ex_docmd.c, src/ex_eval.c,
            src/proto/ex_eval.pro


*** ../vim-8.0.0074/src/structs.h	2016-10-27 21:13:04.886665573 +0200
--- src/structs.h	2016-11-10 20:12:36.997428856 +0100
***************
*** 815,827 ****
  };
  
  /*
   * Structure describing an exception.
   * (don't use "struct exception", it's used by the math library).
   */
  typedef struct vim_exception except_T;
  struct vim_exception
  {
!     int			type;		/* exception type */
      char_u		*value;		/* exception value */
      struct msglist	*messages;	/* message(s) causing error exception */
      char_u		*throw_name;	/* name of the throw point */
--- 815,837 ----
  };
  
  /*
+  * The exception types.
+  */
+ typedef enum
+ {
+     ET_USER,		/* exception caused by ":throw" command */
+     ET_ERROR,		/* error exception */
+     ET_INTERRUPT	/* interrupt exception triggered by Ctrl-C */
+ } except_type_T;
+ 
+ /*
   * Structure describing an exception.
   * (don't use "struct exception", it's used by the math library).
   */
  typedef struct vim_exception except_T;
  struct vim_exception
  {
!     except_type_T	type;		/* exception type */
      char_u		*value;		/* exception value */
      struct msglist	*messages;	/* message(s) causing error exception */
      char_u		*throw_name;	/* name of the throw point */
***************
*** 830,842 ****
  };
  
  /*
-  * The exception types.
-  */
- #define ET_USER		0	/* exception caused by ":throw" command */
- #define ET_ERROR	1	/* error exception */
- #define ET_INTERRUPT	2	/* interrupt exception triggered by Ctrl-C */
- 
- /*
   * Structure to save the error/interrupt/exception state between calls to
   * enter_cleanup() and leave_cleanup().  Must be allocated as an automatic
   * variable by the (common) caller of these functions.
--- 840,845 ----
*** ../vim-8.0.0074/src/ex_docmd.c	2016-11-10 18:16:30.081477202 +0100
--- src/ex_docmd.c	2016-11-10 20:09:12.926721098 +0100
***************
*** 1388,1395 ****
  		    break;
  		case ET_INTERRUPT:
  		    break;
- 		default:
- 		    p = vim_strsave((char_u *)_(e_internal));
  	    }
  
  	    saved_sourcing_name = sourcing_name;
--- 1388,1393 ----
*** ../vim-8.0.0074/src/ex_eval.c	2016-11-10 20:01:41.189582944 +0100
--- src/ex_eval.c	2016-11-10 20:10:32.982214119 +0100
***************
*** 16,22 ****
  #if defined(FEAT_EVAL) || defined(PROTO)
  
  static void	free_msglist(struct msglist *l);
! static int	throw_exception(void *, int, char_u *);
  static char_u	*get_end_emsg(struct condstack *cstack);
  
  /*
--- 16,22 ----
  #if defined(FEAT_EVAL) || defined(PROTO)
  
  static void	free_msglist(struct msglist *l);
! static int	throw_exception(void *, except_type_T, char_u *);
  static char_u	*get_end_emsg(struct condstack *cstack);
  
  /*
***************
*** 422,428 ****
      char_u *
  get_exception_string(
      void	*value,
!     int		type,
      char_u	*cmdname,
      int		*should_free)
  {
--- 422,428 ----
      char_u *
  get_exception_string(
      void	*value,
!     except_type_T type,
      char_u	*cmdname,
      int		*should_free)
  {
***************
*** 503,509 ****
   * error exception.
   */
      static int
! throw_exception(void *value, int type, char_u *cmdname)
  {
      except_T	*excp;
      int		should_free;
--- 503,509 ----
   * error exception.
   */
      static int
! throw_exception(void *value, except_type_T type, char_u *cmdname)
  {
      except_T	*excp;
      int		should_free;
*** ../vim-8.0.0074/src/proto/ex_eval.pro	2016-09-12 13:04:02.000000000 +0200
--- src/proto/ex_eval.pro	2016-11-10 20:12:48.261357539 +0100
***************
*** 7,13 ****
  void free_global_msglist(void);
  void do_errthrow(struct condstack *cstack, char_u *cmdname);
  int do_intthrow(struct condstack *cstack);
! char_u *get_exception_string(void *value, int type, char_u *cmdname, int *should_free);
  void discard_current_exception(void);
  void report_make_pending(int pending, void *value);
  void report_resume_pending(int pending, void *value);
--- 7,13 ----
  void free_global_msglist(void);
  void do_errthrow(struct condstack *cstack, char_u *cmdname);
  int do_intthrow(struct condstack *cstack);
! char_u *get_exception_string(void *value, except_type_T type, char_u *cmdname, int *should_free);
  void discard_current_exception(void);
  void report_make_pending(int pending, void *value);
  void report_resume_pending(int pending, void *value);
*** ../vim-8.0.0074/src/version.c	2016-11-10 20:01:41.201582868 +0100
--- src/version.c	2016-11-10 20:19:35.890768627 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     75,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
12. You turn off your modem and get this awful empty feeling, like you just
    pulled the plug on a loved one.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0076
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0076
Problem:    Channel log has double parens ()().
Solution:   Remove () for write_buf_line. (Yasuhiro Matsumoto)
Files:      src/channel.c


*** ../vim-8.0.0075/src/channel.c	2016-10-27 20:00:03.661357429 +0200
--- src/channel.c	2016-11-11 21:12:04.681464310 +0100
***************
*** 1341,1347 ****
  
      p[len] = NL;
      p[len + 1] = NUL;
!     channel_send(channel, PART_IN, p, len + 1, "write_buf_line()");
      vim_free(p);
  }
  
--- 1341,1347 ----
  
      p[len] = NL;
      p[len + 1] = NUL;
!     channel_send(channel, PART_IN, p, len + 1, "write_buf_line");
      vim_free(p);
  }
  
***************
*** 3450,3456 ****
   * Return FAIL or OK.
   */
      int
! channel_send(channel_T *channel, ch_part_T part, char_u *buf, int len, char *fun)
  {
      int		res;
      sock_T	fd;
--- 3450,3461 ----
   * Return FAIL or OK.
   */
      int
! channel_send(
! 	channel_T *channel,
! 	ch_part_T part,
! 	char_u	  *buf,
! 	int	  len,
! 	char	  *fun)
  {
      int		res;
      sock_T	fd;
*** ../vim-8.0.0075/src/version.c	2016-11-10 20:20:01.874602675 +0100
--- src/version.c	2016-11-11 21:12:53.829152426 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     76,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
14. You start introducing yourself as "Jim at I-I-Net dot net dot au"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0077
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0077
Problem:    The GUI code is not tested by Travis.
Solution:   Install the virtual framebuffer.
Files:      .travis.yml


*** ../vim-8.0.0076/.travis.yml	2016-01-03 23:04:38.000000000 +0100
--- .travis.yml	2016-11-11 21:53:37.469393214 +0100
***************
*** 32,37 ****
--- 32,43 ----
  before_install:
    - pip install --user cpp-coveralls
  
+ # Start virtual framebuffer to be able to test the GUI.
+ before_script:
+   - "export DISPLAY=:99.0"
+   - "sh -e /etc/init.d/xvfb start"
+   - sleep 3 # give xvfb some time to start
+ 
  script:
    - NPROC=$(getconf _NPROCESSORS_ONLN)
    - if [ "$CHECK_AUTOCONF" = "yes" -a "$CC" = "gcc" ]; then make -C src autoconf; fi
*** ../vim-8.0.0076/src/version.c	2016-11-11 21:13:56.836753930 +0100
--- src/version.c	2016-11-11 21:57:08.388039500 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     77,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
15. Your heart races faster and beats irregularly each time you see a new WWW
    site address in print or on TV, even though you've never had heart
    problems before.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0078
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0078
Problem:    Accessing freed memory in quickfix.
Solution:   Reset pointer when freeing 'errorformat'. (Domenique Pelle)
Files:      src/quickfix.c, src/testdir/test_quickfix.vim


*** ../vim-8.0.0077/src/quickfix.c	2016-11-10 20:01:41.197582893 +0100
--- src/quickfix.c	2016-11-12 15:32:55.305622514 +0100
***************
*** 114,119 ****
--- 114,121 ----
      int		    conthere;	/* %> used */
  };
  
+ static efm_T	*fmt_start = NULL; /* cached across qf_parse_line() calls */
+ 
  static int	qf_init_ext(qf_info_T *qi, char_u *efile, buf_T *buf, typval_T *tv, char_u *errorformat, int newlist, linenr_T lnumfirst, linenr_T lnumlast, char_u *qf_title);
  static void	qf_store_title(qf_info_T *qi, char_u *title);
  static void	qf_new_list(qf_info_T *qi, char_u *qf_title);
***************
*** 389,394 ****
--- 391,397 ----
  	vim_regfree(efm_ptr->prog);
  	vim_free(efm_ptr);
      }
+     fmt_start = NULL;
  }
  
  /* Parse 'errorformat' option */
***************
*** 786,792 ****
  	qffields_T	*fields)
  {
      efm_T		*fmt_ptr;
-     static efm_T	*fmt_start = NULL; /* cached across calls */
      char_u		*ptr;
      int			len;
      int			i;
--- 789,794 ----
*** ../vim-8.0.0077/src/testdir/test_quickfix.vim	2016-11-06 14:46:40.644143343 +0100
--- src/testdir/test_quickfix.vim	2016-11-12 15:27:04.183936416 +0100
***************
*** 1648,1650 ****
--- 1648,1660 ----
  
    set efm&vim
  endfunction
+ 
+ function Test_caddbuffer()
+   " This used to cause a memory access in freed memory
+   let save_efm = &efm
+   set efm=%EEEE%m,%WWWW,%+CCCC%>%#,%GGGG%.#
+   cgetexpr ['WWWW', 'EEEE', 'CCCC']
+   let &efm = save_efm
+   cad
+   bwipe!
+ endfunc
*** ../vim-8.0.0077/src/version.c	2016-11-11 21:57:42.339822540 +0100
--- src/version.c	2016-11-12 15:33:58.377207364 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     78,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
19. All of your friends have an @ in their names.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0079
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0079
Problem:    Accessing freed memory in quickfix. (Domenique Pelle)
Solution:   Do not free the current list when adding to it.
Files:      src/quickfix.c, src/testdir/test_quickfix.vim


*** ../vim-8.0.0078/src/quickfix.c	2016-11-12 15:36:50.284076568 +0100
--- src/quickfix.c	2016-11-12 18:11:19.331186720 +0100
***************
*** 1112,1117 ****
--- 1112,1118 ----
      qffields_T	    fields = {NULL, NULL, 0, 0L, 0, FALSE, NULL, 0, 0, 0};
  #ifdef FEAT_WINDOWS
      qfline_T	    *old_last = NULL;
+     int		    adding = FALSE;
  #endif
      static efm_T    *fmt_first = NULL;
      char_u	    *efm;
***************
*** 1140,1145 ****
--- 1141,1147 ----
      else if (qi->qf_lists[qi->qf_curlist].qf_count > 0)
      {
  	/* Adding to existing list, use last entry. */
+ 	adding = TRUE;
  	old_last = qi->qf_lists[qi->qf_curlist].qf_last;
      }
  #endif
***************
*** 1266,1275 ****
      }
      EMSG(_(e_readerrf));
  error2:
!     qf_free(qi, qi->qf_curlist);
!     qi->qf_listcount--;
!     if (qi->qf_curlist > 0)
! 	--qi->qf_curlist;
  qf_init_end:
      if (state.fd != NULL)
  	fclose(state.fd);
--- 1268,1280 ----
      }
      EMSG(_(e_readerrf));
  error2:
!     if (!adding)
!     {
! 	qf_free(qi, qi->qf_curlist);
! 	qi->qf_listcount--;
! 	if (qi->qf_curlist > 0)
! 	    --qi->qf_curlist;
!     }
  qf_init_end:
      if (state.fd != NULL)
  	fclose(state.fd);
*** ../vim-8.0.0078/src/testdir/test_quickfix.vim	2016-11-12 15:36:50.288076542 +0100
--- src/testdir/test_quickfix.vim	2016-11-12 18:09:29.515893989 +0100
***************
*** 6,12 ****
  
  set encoding=utf-8
  
! function! s:setup_commands(cchar)
    if a:cchar == 'c'
      command! -nargs=* -bang Xlist <mods>clist<bang> <args>
      command! -nargs=* Xgetexpr <mods>cgetexpr <args>
--- 6,12 ----
  
  set encoding=utf-8
  
! func s:setup_commands(cchar)
    if a:cchar == 'c'
      command! -nargs=* -bang Xlist <mods>clist<bang> <args>
      command! -nargs=* Xgetexpr <mods>cgetexpr <args>
***************
*** 68,77 ****
      let g:Xgetlist = function('getloclist', [0])
      let g:Xsetlist = function('setloclist', [0])
    endif
! endfunction
  
  " Tests for the :clist and :llist commands
! function XlistTests(cchar)
    call s:setup_commands(a:cchar)
  
    " With an empty list, command should return error
--- 68,77 ----
      let g:Xgetlist = function('getloclist', [0])
      let g:Xsetlist = function('setloclist', [0])
    endif
! endfunc
  
  " Tests for the :clist and :llist commands
! func XlistTests(cchar)
    call s:setup_commands(a:cchar)
  
    " With an empty list, command should return error
***************
*** 128,144 ****
    let l = split(result, "\n")
    call assert_equal([' 2 Xtestfile1:1 col 3: Line1',
  		   \ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)
! endfunction
  
! function Test_clist()
    call XlistTests('c')
    call XlistTests('l')
! endfunction
  
  " Tests for the :colder, :cnewer, :lolder and :lnewer commands
  " Note that this test assumes that a quickfix/location list is
  " already set by the caller.
! function XageTests(cchar)
    call s:setup_commands(a:cchar)
  
    " Jumping to a non existent list should return error
--- 128,144 ----
    let l = split(result, "\n")
    call assert_equal([' 2 Xtestfile1:1 col 3: Line1',
  		   \ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)
! endfunc
  
! func Test_clist()
    call XlistTests('c')
    call XlistTests('l')
! endfunc
  
  " Tests for the :colder, :cnewer, :lolder and :lnewer commands
  " Note that this test assumes that a quickfix/location list is
  " already set by the caller.
! func XageTests(cchar)
    call s:setup_commands(a:cchar)
  
    " Jumping to a non existent list should return error
***************
*** 171,190 ****
    Xnewer 2
    let l = g:Xgetlist()
    call assert_equal('Line3', l[0].text)
! endfunction
  
! function Test_cage()
    let list = [{'bufnr': 1, 'lnum': 1}]
    call setqflist(list)
    call XageTests('c')
  
    call setloclist(0, list)
    call XageTests('l')
! endfunction
  
  " Tests for the :cwindow, :lwindow :cclose, :lclose, :copen and :lopen
  " commands
! function XwindowTests(cchar)
    call s:setup_commands(a:cchar)
  
    " Create a list with no valid entries
--- 171,190 ----
    Xnewer 2
    let l = g:Xgetlist()
    call assert_equal('Line3', l[0].text)
! endfunc
  
! func Test_cage()
    let list = [{'bufnr': 1, 'lnum': 1}]
    call setqflist(list)
    call XageTests('c')
  
    call setloclist(0, list)
    call XageTests('l')
! endfunc
  
  " Tests for the :cwindow, :lwindow :cclose, :lclose, :copen and :lopen
  " commands
! func XwindowTests(cchar)
    call s:setup_commands(a:cchar)
  
    " Create a list with no valid entries
***************
*** 227,242 ****
    " Calling cwindow should close the quickfix window with no valid errors
    Xwindow
    call assert_true(winnr('$') == 1)
! endfunction
  
! function Test_cwindow()
    call XwindowTests('c')
    call XwindowTests('l')
! endfunction
  
  " Tests for the :cfile, :lfile, :caddfile, :laddfile, :cgetfile and :lgetfile
  " commands.
! function XfileTests(cchar)
    call s:setup_commands(a:cchar)
  
    call writefile(['Xtestfile1:700:10:Line 700',
--- 227,242 ----
    " Calling cwindow should close the quickfix window with no valid errors
    Xwindow
    call assert_true(winnr('$') == 1)
! endfunc
  
! func Test_cwindow()
    call XwindowTests('c')
    call XwindowTests('l')
! endfunc
  
  " Tests for the :cfile, :lfile, :caddfile, :laddfile, :cgetfile and :lgetfile
  " commands.
! func XfileTests(cchar)
    call s:setup_commands(a:cchar)
  
    call writefile(['Xtestfile1:700:10:Line 700',
***************
*** 275,290 ****
  	\ l[1].lnum == 333 && l[1].col == 88 && l[1].text ==# 'Line 333')
  
    call delete('Xqftestfile1')
! endfunction
  
! function Test_cfile()
    call XfileTests('c')
    call XfileTests('l')
! endfunction
  
  " Tests for the :cbuffer, :lbuffer, :caddbuffer, :laddbuffer, :cgetbuffer and
  " :lgetbuffer commands.
! function XbufferTests(cchar)
    call s:setup_commands(a:cchar)
  
    enew!
--- 275,290 ----
  	\ l[1].lnum == 333 && l[1].col == 88 && l[1].text ==# 'Line 333')
  
    call delete('Xqftestfile1')
! endfunc
  
! func Test_cfile()
    call XfileTests('c')
    call XfileTests('l')
! endfunc
  
  " Tests for the :cbuffer, :lbuffer, :caddbuffer, :laddbuffer, :cgetbuffer and
  " :lgetbuffer commands.
! func XbufferTests(cchar)
    call s:setup_commands(a:cchar)
  
    enew!
***************
*** 316,341 ****
  	\ l[3].lnum == 750 && l[3].col == 25 && l[3].text ==# 'Line 750')
    enew!
  
! endfunction
  
! function Test_cbuffer()
    call XbufferTests('c')
    call XbufferTests('l')
! endfunction
  
! function XexprTests(cchar)
    call s:setup_commands(a:cchar)
  
    call assert_fails('Xexpr 10', 'E777:')
! endfunction
  
! function Test_cexpr()
    call XexprTests('c')
    call XexprTests('l')
! endfunction
  
  " Tests for :cnext, :cprev, :cfirst, :clast commands
! function Xtest_browse(cchar)
    call s:setup_commands(a:cchar)
  
    call s:create_test_file('Xqftestfile1')
--- 316,341 ----
  	\ l[3].lnum == 750 && l[3].col == 25 && l[3].text ==# 'Line 750')
    enew!
  
! endfunc
  
! func Test_cbuffer()
    call XbufferTests('c')
    call XbufferTests('l')
! endfunc
  
! func XexprTests(cchar)
    call s:setup_commands(a:cchar)
  
    call assert_fails('Xexpr 10', 'E777:')
! endfunc
  
! func Test_cexpr()
    call XexprTests('c')
    call XexprTests('l')
! endfunc
  
  " Tests for :cnext, :cprev, :cfirst, :clast commands
! func Xtest_browse(cchar)
    call s:setup_commands(a:cchar)
  
    call s:create_test_file('Xqftestfile1')
***************
*** 366,379 ****
  
    call delete('Xqftestfile1')
    call delete('Xqftestfile2')
! endfunction
  
! function Test_browse()
    call Xtest_browse('c')
    call Xtest_browse('l')
! endfunction
  
! function Test_nomem()
    call test_alloc_fail(GetAllocId('qf_dirname_start'), 0, 0)
    call assert_fails('vimgrep vim runtest.vim', 'E342:')
  
--- 366,379 ----
  
    call delete('Xqftestfile1')
    call delete('Xqftestfile2')
! endfunc
  
! func Test_browse()
    call Xtest_browse('c')
    call Xtest_browse('l')
! endfunc
  
! func Test_nomem()
    call test_alloc_fail(GetAllocId('qf_dirname_start'), 0, 0)
    call assert_fails('vimgrep vim runtest.vim', 'E342:')
  
***************
*** 391,397 ****
  
  endfunc
  
! function! s:test_xhelpgrep(cchar)
    call s:setup_commands(a:cchar)
    Xhelpgrep quickfix
    Xopen
--- 391,397 ----
  
  endfunc
  
! func s:test_xhelpgrep(cchar)
    call s:setup_commands(a:cchar)
    Xhelpgrep quickfix
    Xopen
***************
*** 403,411 ****
    call assert_true(w:quickfix_title =~ title_text, w:quickfix_title)
    " This wipes out the buffer, make sure that doesn't cause trouble.
    Xclose
! endfunction
  
! function Test_helpgrep()
    call s:test_xhelpgrep('c')
    helpclose
    call s:test_xhelpgrep('l')
--- 403,411 ----
    call assert_true(w:quickfix_title =~ title_text, w:quickfix_title)
    " This wipes out the buffer, make sure that doesn't cause trouble.
    Xclose
! endfunc
  
! func Test_helpgrep()
    call s:test_xhelpgrep('c')
    helpclose
    call s:test_xhelpgrep('l')
***************
*** 443,449 ****
    augroup! QfBufWinEnter
  endfunc
  
! function XqfTitleTests(cchar)
    call s:setup_commands(a:cchar)
  
    Xgetexpr ['file:1:1:message']
--- 443,449 ----
    augroup! QfBufWinEnter
  endfunc
  
! func XqfTitleTests(cchar)
    call s:setup_commands(a:cchar)
  
    Xgetexpr ['file:1:1:message']
***************
*** 462,477 ****
    endif
    call assert_equal(title, w:quickfix_title)
    Xclose
! endfunction
  
  " Tests for quickfix window's title
! function Test_qf_title()
    call XqfTitleTests('c')
    call XqfTitleTests('l')
! endfunction
  
  " Tests for 'errorformat'
! function Test_efm()
    let save_efm = &efm
    set efm=%EEEE%m,%WWWW%m,%+CCCC%.%#,%-GGGG%.%#
    cgetexpr ['WWWW', 'EEEE', 'CCCC']
--- 462,477 ----
    endif
    call assert_equal(title, w:quickfix_title)
    Xclose
! endfunc
  
  " Tests for quickfix window's title
! func Test_qf_title()
    call XqfTitleTests('c')
    call XqfTitleTests('l')
! endfunc
  
  " Tests for 'errorformat'
! func Test_efm()
    let save_efm = &efm
    set efm=%EEEE%m,%WWWW%m,%+CCCC%.%#,%-GGGG%.%#
    cgetexpr ['WWWW', 'EEEE', 'CCCC']
***************
*** 484,490 ****
    let l = strtrans(string(map(getqflist(), '[v:val.text, v:val.valid]')))
    call assert_equal("[['W', 1], ['ZZZZ', 0], ['E^@CCCC', 1], ['YYYY', 0]]", l)
    let &efm = save_efm
! endfunction
  
  " This will test for problems in quickfix:
  " A. incorrectly copying location lists which caused the location list to show
--- 484,490 ----
    let l = strtrans(string(map(getqflist(), '[v:val.text, v:val.valid]')))
    call assert_equal("[['W', 1], ['ZZZZ', 0], ['E^@CCCC', 1], ['YYYY', 0]]", l)
    let &efm = save_efm
! endfunc
  
  " This will test for problems in quickfix:
  " A. incorrectly copying location lists which caused the location list to show
***************
*** 495,501 ****
  "    window it belongs to.
  "
  " Set up the test environment:
! function! ReadTestProtocol(name)
    let base = substitute(a:name, '\v^test://(.*)%(\.[^.]+)?', '\1', '')
    let word = substitute(base, '\v(.*)\..*', '\1', '')
  
--- 495,501 ----
  "    window it belongs to.
  "
  " Set up the test environment:
! func ReadTestProtocol(name)
    let base = substitute(a:name, '\v^test://(.*)%(\.[^.]+)?', '\1', '')
    let word = substitute(base, '\v(.*)\..*', '\1', '')
  
***************
*** 514,522 ****
    setl nomodifiable
    setl readonly
    exe 'doautocmd BufRead ' . substitute(a:name, '\v^test://(.*)', '\1', '')
! endfunction
  
! function Test_locationlist()
      enew
  
      augroup testgroup
--- 514,522 ----
    setl nomodifiable
    setl readonly
    exe 'doautocmd BufRead ' . substitute(a:name, '\v^test://(.*)', '\1', '')
! endfunc
  
! func Test_locationlist()
      enew
  
      augroup testgroup
***************
*** 596,610 ****
      wincmd n | only
  
      augroup! testgroup
! endfunction
  
! function Test_locationlist_curwin_was_closed()
      augroup testgroup
        au!
        autocmd BufReadCmd test_curwin.txt call R(expand("<amatch>"))
      augroup END
  
!     function! R(n)
        quit
      endfunc
  
--- 596,610 ----
      wincmd n | only
  
      augroup! testgroup
!   endfunc
  
! func Test_locationlist_curwin_was_closed()
      augroup testgroup
        au!
        autocmd BufReadCmd test_curwin.txt call R(expand("<amatch>"))
      augroup END
  
!     func! R(n)
        quit
      endfunc
  
***************
*** 615,623 ****
      call assert_fails('lrewind', 'E924:')
  
      augroup! testgroup
! endfunction
  
! function Test_locationlist_cross_tab_jump()
    call writefile(['loclistfoo'], 'loclistfoo')
    call writefile(['loclistbar'], 'loclistbar')
    set switchbuf=usetab
--- 615,623 ----
      call assert_fails('lrewind', 'E924:')
  
      augroup! testgroup
!   endfunc
  
! func Test_locationlist_cross_tab_jump()
    call writefile(['loclistfoo'], 'loclistfoo')
    call writefile(['loclistbar'], 'loclistbar')
    set switchbuf=usetab
***************
*** 631,640 ****
    set switchbuf&vim
    call delete('loclistfoo')
    call delete('loclistbar')
! endfunction
  
  " More tests for 'errorformat'
! function! Test_efm1()
      if !has('unix')
  	" The 'errorformat' setting is different on non-Unix systems.
  	" This test works only on Unix-like systems.
--- 631,640 ----
    set switchbuf&vim
    call delete('loclistfoo')
    call delete('loclistbar')
! endfunc
  
  " More tests for 'errorformat'
! func Test_efm1()
      if !has('unix')
  	" The 'errorformat' setting is different on non-Unix systems.
  	" This test works only on Unix-like systems.
***************
*** 752,761 ****
      call delete('Xerrorfile1')
      call delete('Xerrorfile2')
      call delete('Xtestfile')
! endfunction
  
  " Test for quickfix directory stack support
! function! s:dir_stack_tests(cchar)
    call s:setup_commands(a:cchar)
  
    let save_efm=&efm
--- 752,761 ----
      call delete('Xerrorfile1')
      call delete('Xerrorfile2')
      call delete('Xtestfile')
!   endfunc
  
  " Test for quickfix directory stack support
! func s:dir_stack_tests(cchar)
    call s:setup_commands(a:cchar)
  
    let save_efm=&efm
***************
*** 797,806 ****
    call assert_equal(5, qf[11].lnum)
  
    let &efm=save_efm
! endfunction
  
  " Tests for %D and %X errorformat options
! function! Test_efm_dirstack()
    " Create the directory stack and files
    call mkdir('dir1')
    call mkdir('dir1/a')
--- 797,806 ----
    call assert_equal(5, qf[11].lnum)
  
    let &efm=save_efm
! endfunc
  
  " Tests for %D and %X errorformat options
! func Test_efm_dirstack()
    " Create the directory stack and files
    call mkdir('dir1')
    call mkdir('dir1/a')
***************
*** 832,841 ****
    call delete('dir1', 'rf')
    call delete('dir2', 'rf')
    call delete('habits1.txt')
! endfunction
  
  " Test for resync after continuing an ignored message
! function! Xefm_ignore_continuations(cchar)
    call s:setup_commands(a:cchar)
  
    let save_efm = &efm
--- 832,841 ----
    call delete('dir1', 'rf')
    call delete('dir2', 'rf')
    call delete('habits1.txt')
! endfunc
  
  " Test for resync after continuing an ignored message
! func Xefm_ignore_continuations(cchar)
    call s:setup_commands(a:cchar)
  
    let save_efm = &efm
***************
*** 850,864 ****
    call assert_equal([['resync', 1, 4, 'E']], l)
  
    let &efm = save_efm
! endfunction
  
! function! Test_efm_ignore_continuations()
    call Xefm_ignore_continuations('c')
    call Xefm_ignore_continuations('l')
! endfunction
  
  " Tests for invalid error format specifies
! function Xinvalid_efm_Tests(cchar)
    call s:setup_commands(a:cchar)
  
    let save_efm = &efm
--- 850,864 ----
    call assert_equal([['resync', 1, 4, 'E']], l)
  
    let &efm = save_efm
! endfunc
  
! func Test_efm_ignore_continuations()
    call Xefm_ignore_continuations('c')
    call Xefm_ignore_continuations('l')
! endfunc
  
  " Tests for invalid error format specifies
! func Xinvalid_efm_Tests(cchar)
    call s:setup_commands(a:cchar)
  
    let save_efm = &efm
***************
*** 891,907 ****
    call assert_fails('Xexpr ["Entering dir abc", "abc.txt:1:Hello world"]', 'E379:')
  
    let &efm = save_efm
! endfunction
  
! function Test_invalid_efm()
    call Xinvalid_efm_Tests('c')
    call Xinvalid_efm_Tests('l')
! endfunction
  
  " TODO:
  " Add tests for the following formats in 'errorformat'
  "	%r  %O
! function! Test_efm2()
    let save_efm = &efm
  
    " Test for %s format in efm
--- 891,907 ----
    call assert_fails('Xexpr ["Entering dir abc", "abc.txt:1:Hello world"]', 'E379:')
  
    let &efm = save_efm
! endfunc
  
! func Test_invalid_efm()
    call Xinvalid_efm_Tests('c')
    call Xinvalid_efm_Tests('l')
! endfunc
  
  " TODO:
  " Add tests for the following formats in 'errorformat'
  "	%r  %O
! func Test_efm2()
    let save_efm = &efm
  
    " Test for %s format in efm
***************
*** 987,1005 ****
    call assert_equal('unittests/dbfacadeTest.py', bufname(l[4].bufnr))
  
    let &efm = save_efm
! endfunction
  
! function XquickfixChangedByAutocmd(cchar)
    call s:setup_commands(a:cchar)
    if a:cchar == 'c'
      let ErrorNr = 'E925'
!     function! ReadFunc()
        colder
        cgetexpr []
      endfunc
    else
      let ErrorNr = 'E926'
!     function! ReadFunc()
        lolder
        lgetexpr []
      endfunc
--- 987,1005 ----
    call assert_equal('unittests/dbfacadeTest.py', bufname(l[4].bufnr))
  
    let &efm = save_efm
! endfunc
  
! func XquickfixChangedByAutocmd(cchar)
    call s:setup_commands(a:cchar)
    if a:cchar == 'c'
      let ErrorNr = 'E925'
!     func! ReadFunc()
        colder
        cgetexpr []
      endfunc
    else
      let ErrorNr = 'E926'
!     func! ReadFunc()
        lolder
        lgetexpr []
      endfunc
***************
*** 1022,1031 ****
    augroup! testgroup
  endfunc
  
! function Test_quickfix_was_changed_by_autocmd()
    call XquickfixChangedByAutocmd('c')
    call XquickfixChangedByAutocmd('l')
! endfunction
  
  func Test_caddbuffer_to_empty()
    helpgr quickfix
--- 1022,1031 ----
    augroup! testgroup
  endfunc
  
! func Test_quickfix_was_changed_by_autocmd()
    call XquickfixChangedByAutocmd('c')
    call XquickfixChangedByAutocmd('l')
! endfunc
  
  func Test_caddbuffer_to_empty()
    helpgr quickfix
***************
*** 1047,1053 ****
  endfunc
  
  " Tests for the setqflist() and setloclist() functions
! function SetXlistTests(cchar, bnum)
    call s:setup_commands(a:cchar)
  
    call g:Xsetlist([{'bufnr': a:bnum, 'lnum': 1},
--- 1047,1053 ----
  endfunc
  
  " Tests for the setqflist() and setloclist() functions
! func SetXlistTests(cchar, bnum)
    call s:setup_commands(a:cchar)
  
    call g:Xsetlist([{'bufnr': a:bnum, 'lnum': 1},
***************
*** 1082,1090 ****
    call g:Xsetlist([])
    let l = g:Xgetlist()
    call assert_equal(0, len(l))
! endfunction
  
! function Test_setqflist()
    new Xtestfile | only
    let bnum = bufnr('%')
    call setline(1, range(1,5))
--- 1082,1090 ----
    call g:Xsetlist([])
    let l = g:Xgetlist()
    call assert_equal(0, len(l))
! endfunc
  
! func Test_setqflist()
    new Xtestfile | only
    let bnum = bufnr('%')
    call setline(1, range(1,5))
***************
*** 1094,1102 ****
  
    enew!
    call delete('Xtestfile')
! endfunction
  
! function Xlist_empty_middle(cchar)
    call s:setup_commands(a:cchar)
  
    " create three quickfix lists
--- 1094,1102 ----
  
    enew!
    call delete('Xtestfile')
! endfunc
  
! func Xlist_empty_middle(cchar)
    call s:setup_commands(a:cchar)
  
    " create three quickfix lists
***************
*** 1119,1130 ****
    call assert_equal(matchlen, len(g:Xgetlist()))
  endfunc
  
! function Test_setqflist_empty_middle()
    call Xlist_empty_middle('c')
    call Xlist_empty_middle('l')
! endfunction
  
! function Xlist_empty_older(cchar)
    call s:setup_commands(a:cchar)
  
    " create three quickfix lists
--- 1119,1130 ----
    call assert_equal(matchlen, len(g:Xgetlist()))
  endfunc
  
! func Test_setqflist_empty_middle()
    call Xlist_empty_middle('c')
    call Xlist_empty_middle('l')
! endfunc
  
! func Xlist_empty_older(cchar)
    call s:setup_commands(a:cchar)
  
    " create three quickfix lists
***************
*** 1145,1158 ****
    call assert_equal(twolen, len(g:Xgetlist()))
    Xnewer
    call assert_equal(threelen, len(g:Xgetlist()))
! endfunction
  
! function Test_setqflist_empty_older()
    call Xlist_empty_older('c')
    call Xlist_empty_older('l')
! endfunction
  
! function! XquickfixSetListWithAct(cchar)
    call s:setup_commands(a:cchar)
  
    let list1 = [{'filename': 'fnameA', 'text': 'A'},
--- 1145,1158 ----
    call assert_equal(twolen, len(g:Xgetlist()))
    Xnewer
    call assert_equal(threelen, len(g:Xgetlist()))
! endfunc
  
! func Test_setqflist_empty_older()
    call Xlist_empty_older('c')
    call Xlist_empty_older('l')
! endfunc
  
! func XquickfixSetListWithAct(cchar)
    call s:setup_commands(a:cchar)
  
    let list1 = [{'filename': 'fnameA', 'text': 'A'},
***************
*** 1226,1237 ****
    call assert_fails("call g:Xsetlist(list1, 0)", 'E928:')
  endfunc
  
! function Test_quickfix_set_list_with_act()
    call XquickfixSetListWithAct('c')
    call XquickfixSetListWithAct('l')
! endfunction
  
! function XLongLinesTests(cchar)
    let l = g:Xgetlist()
  
    call assert_equal(4, len(l))
--- 1226,1237 ----
    call assert_fails("call g:Xsetlist(list1, 0)", 'E928:')
  endfunc
  
! func Test_quickfix_set_list_with_act()
    call XquickfixSetListWithAct('c')
    call XquickfixSetListWithAct('l')
! endfunc
  
! func XLongLinesTests(cchar)
    let l = g:Xgetlist()
  
    call assert_equal(4, len(l))
***************
*** 1249,1257 ****
    call assert_equal(10, len(l[3].text))
  
    call g:Xsetlist([], 'r')
! endfunction
  
! function s:long_lines_tests(cchar)
    call s:setup_commands(a:cchar)
  
    let testfile = 'samples/quickfix.txt'
--- 1249,1257 ----
    call assert_equal(10, len(l[3].text))
  
    call g:Xsetlist([], 'r')
! endfunc
  
! func s:long_lines_tests(cchar)
    call s:setup_commands(a:cchar)
  
    let testfile = 'samples/quickfix.txt'
***************
*** 1272,1293 ****
    exe 'edit' testfile
    exe 'Xbuffer' bufnr('%')
    call XLongLinesTests(a:cchar)
! endfunction
  
! function Test_long_lines()
    call s:long_lines_tests('c')
    call s:long_lines_tests('l')
! endfunction
  
! function! s:create_test_file(filename)
    let l = []
    for i in range(1, 20)
        call add(l, 'Line' . i)
    endfor
    call writefile(l, a:filename)
! endfunction
  
! function! Test_switchbuf()
    call s:create_test_file('Xqftestfile1')
    call s:create_test_file('Xqftestfile2')
    call s:create_test_file('Xqftestfile3')
--- 1272,1293 ----
    exe 'edit' testfile
    exe 'Xbuffer' bufnr('%')
    call XLongLinesTests(a:cchar)
! endfunc
  
! func Test_long_lines()
    call s:long_lines_tests('c')
    call s:long_lines_tests('l')
! endfunc
  
! func s:create_test_file(filename)
    let l = []
    for i in range(1, 20)
        call add(l, 'Line' . i)
    endfor
    call writefile(l, a:filename)
! endfunc
  
! func Test_switchbuf()
    call s:create_test_file('Xqftestfile1')
    call s:create_test_file('Xqftestfile2')
    call s:create_test_file('Xqftestfile3')
***************
*** 1374,1382 ****
    call delete('Xqftestfile1')
    call delete('Xqftestfile2')
    call delete('Xqftestfile3')
! endfunction
  
! function! Xadjust_qflnum(cchar)
    call s:setup_commands(a:cchar)
  
    enew | only
--- 1374,1382 ----
    call delete('Xqftestfile1')
    call delete('Xqftestfile2')
    call delete('Xqftestfile3')
! endfunc
  
! func Xadjust_qflnum(cchar)
    call s:setup_commands(a:cchar)
  
    enew | only
***************
*** 1401,1417 ****
  
    enew!
    call delete(fname)
! endfunction
  
! function! Test_adjust_lnum()
    call setloclist(0, [])
    call Xadjust_qflnum('c')
    call setqflist([])
    call Xadjust_qflnum('l')
! endfunction
  
  " Tests for the :grep/:lgrep and :grepadd/:lgrepadd commands
! function! s:test_xgrep(cchar)
    call s:setup_commands(a:cchar)
  
    " The following lines are used for the grep test. Don't remove.
--- 1401,1417 ----
  
    enew!
    call delete(fname)
! endfunc
  
! func Test_adjust_lnum()
    call setloclist(0, [])
    call Xadjust_qflnum('c')
    call setqflist([])
    call Xadjust_qflnum('l')
! endfunc
  
  " Tests for the :grep/:lgrep and :grepadd/:lgrepadd commands
! func s:test_xgrep(cchar)
    call s:setup_commands(a:cchar)
  
    " The following lines are used for the grep test. Don't remove.
***************
*** 1430,1438 ****
    set makeef=Temp_File_##
    silent Xgrepadd GrepAdd_Test_Text: test_quickfix.vim
    call assert_true(len(g:Xgetlist()) == 6)
! endfunction
  
! function! Test_grep()
    if !has('unix')
      " The grepprg may not be set on non-Unix systems
      return
--- 1430,1438 ----
    set makeef=Temp_File_##
    silent Xgrepadd GrepAdd_Test_Text: test_quickfix.vim
    call assert_true(len(g:Xgetlist()) == 6)
! endfunc
  
! func Test_grep()
    if !has('unix')
      " The grepprg may not be set on non-Unix systems
      return
***************
*** 1440,1448 ****
  
    call s:test_xgrep('c')
    call s:test_xgrep('l')
! endfunction
  
! function! Test_two_windows()
    " Use one 'errorformat' for two windows.  Add an expression to each of them,
    " make sure they each keep their own state.
    set efm=%DEntering\ dir\ '%f',%f:%l:%m,%XLeaving\ dir\ '%f'
--- 1440,1448 ----
  
    call s:test_xgrep('c')
    call s:test_xgrep('l')
! endfunc
  
! func Test_two_windows()
    " Use one 'errorformat' for two windows.  Add an expression to each of them,
    " make sure they each keep their own state.
    set efm=%DEntering\ dir\ '%f',%f:%l:%m,%XLeaving\ dir\ '%f'
***************
*** 1483,1489 ****
    call delete('Xtwo', 'rf')
  endfunc
  
! function XbottomTests(cchar)
    call s:setup_commands(a:cchar)
  
    call g:Xsetlist([{'filename': 'foo', 'lnum': 42}]) 
--- 1483,1489 ----
    call delete('Xtwo', 'rf')
  endfunc
  
! func XbottomTests(cchar)
    call s:setup_commands(a:cchar)
  
    call g:Xsetlist([{'filename': 'foo', 'lnum': 42}]) 
***************
*** 1499,1510 ****
  endfunc
  
  " Tests for the :cbottom and :lbottom commands
! function Test_cbottom()
    call XbottomTests('c')
    call XbottomTests('l')
! endfunction
  
! function HistoryTest(cchar)
    call s:setup_commands(a:cchar)
  
    call assert_fails(a:cchar . 'older 99', 'E380:')
--- 1499,1510 ----
  endfunc
  
  " Tests for the :cbottom and :lbottom commands
! func Test_cbottom()
    call XbottomTests('c')
    call XbottomTests('l')
! endfunc
  
! func HistoryTest(cchar)
    call s:setup_commands(a:cchar)
  
    call assert_fails(a:cchar . 'older 99', 'E380:')
***************
*** 1544,1550 ****
  endfunc
  
  " Quickfix/Location list set/get properties tests
! function Xproperty_tests(cchar)
      call s:setup_commands(a:cchar)
  
      " Error cases
--- 1544,1550 ----
  endfunc
  
  " Quickfix/Location list set/get properties tests
! func Xproperty_tests(cchar)
      call s:setup_commands(a:cchar)
  
      " Error cases
***************
*** 1590,1608 ****
      if a:cchar == 'l'
  	call assert_equal({}, getloclist(99, {'title': 1}))
      endif
! endfunction
  
! function Test_qf_property()
      call Xproperty_tests('c')
      call Xproperty_tests('l')
! endfunction
  
  " Tests for the QuickFixCmdPre/QuickFixCmdPost autocommands
! function QfAutoCmdHandler(loc, cmd)
    call add(g:acmds, a:loc . a:cmd)
! endfunction
  
! function Test_Autocmd()
    autocmd QuickFixCmdPre * call QfAutoCmdHandler('pre', expand('<amatch>'))
    autocmd QuickFixCmdPost * call QfAutoCmdHandler('post', expand('<amatch>'))
  
--- 1590,1608 ----
      if a:cchar == 'l'
  	call assert_equal({}, getloclist(99, {'title': 1}))
      endif
!   endfunc
  
! func Test_qf_property()
      call Xproperty_tests('c')
      call Xproperty_tests('l')
!   endfunc
  
  " Tests for the QuickFixCmdPre/QuickFixCmdPost autocommands
! func QfAutoCmdHandler(loc, cmd)
    call add(g:acmds, a:loc . a:cmd)
! endfunc
  
! func Test_Autocmd()
    autocmd QuickFixCmdPre * call QfAutoCmdHandler('pre', expand('<amatch>'))
    autocmd QuickFixCmdPost * call QfAutoCmdHandler('post', expand('<amatch>'))
  
***************
*** 1630,1638 ****
  	      \ 'precaddbuffer',
  	      \ 'postcaddbuffer']
    call assert_equal(l, g:acmds)
! endfunction
  
! function! Test_Autocmd_Exception()
    set efm=%m
    lgetexpr '?'
  
--- 1630,1638 ----
  	      \ 'precaddbuffer',
  	      \ 'postcaddbuffer']
    call assert_equal(l, g:acmds)
! endfunc
  
! func Test_Autocmd_Exception()
    set efm=%m
    lgetexpr '?'
  
***************
*** 1647,1660 ****
    call assert_equal('1', getloclist(0)[0].text)
  
    set efm&vim
! endfunction
  
! function Test_caddbuffer()
!   " This used to cause a memory access in freed memory
    let save_efm = &efm
    set efm=%EEEE%m,%WWWW,%+CCCC%>%#,%GGGG%.#
    cgetexpr ['WWWW', 'EEEE', 'CCCC']
    let &efm = save_efm
!   cad
    bwipe!
  endfunc
--- 1647,1671 ----
    call assert_equal('1', getloclist(0)[0].text)
  
    set efm&vim
! endfunc
  
! func Test_caddbuffer_wrong()
!   " This used to cause a memory access in freed memory.
    let save_efm = &efm
    set efm=%EEEE%m,%WWWW,%+CCCC%>%#,%GGGG%.#
    cgetexpr ['WWWW', 'EEEE', 'CCCC']
    let &efm = save_efm
!   caddbuffer
    bwipe!
  endfunc
+ 
+ func Test_caddexpr_wrong()
+   " This used to cause a memory access in freed memory.
+   cbuffer
+   cbuffer
+   copen
+   let save_efm = &efm
+   set efm=%
+   call assert_fails('caddexpr ""', 'E376:')
+   let &efm = save_efm
+ endfunc
*** ../vim-8.0.0078/src/version.c	2016-11-12 15:36:50.288076542 +0100
--- src/version.c	2016-11-12 18:14:08.246098751 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     79,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
20. When looking at a pageful of someone else's links, you notice all of them
    are already highlighted in purple.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0080
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0080
Problem:    The OS X build fails on Travis.
Solution:   Skip the virtual framebuffer on OS X.
Files:      .travis.yml


*** ../vim-8.0.0079/.travis.yml	2016-11-11 21:57:42.339822540 +0100
--- .travis.yml	2016-11-12 18:30:23.331789362 +0100
***************
*** 32,42 ****
  before_install:
    - pip install --user cpp-coveralls
  
! # Start virtual framebuffer to be able to test the GUI.
  before_script:
!   - "export DISPLAY=:99.0"
!   - "sh -e /etc/init.d/xvfb start"
!   - sleep 3 # give xvfb some time to start
  
  script:
    - NPROC=$(getconf _NPROCESSORS_ONLN)
--- 32,40 ----
  before_install:
    - pip install --user cpp-coveralls
  
! # Start virtual framebuffer to be able to test the GUI. Does not work on OS X.
  before_script:
!   - if [ "$TRAVIS_OS_NAME" = "linux" ]; then export DISPLAY=:99.0 && sh -e /etc/init.d/xvfb start && sleep 3; fi
  
  script:
    - NPROC=$(getconf _NPROCESSORS_ONLN)
*** ../vim-8.0.0079/src/version.c	2016-11-12 18:14:39.609896729 +0100
--- src/version.c	2016-11-12 18:29:50.660001461 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     80,
  /**/

-- 
Shift happens.
                -- Doppler

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0081
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0081
Problem:    Inconsistent function names.
Solution:   Rename do_cscope to ex_cscope.  Clean up comments.
Files:      src/ex_cmds.h, src/if_cscope.c, src/ex_docmd.c,
            src/proto/if_cscope.pro


*** ../vim-8.0.0080/src/ex_cmds.h	2016-09-20 21:39:11.354199194 +0200
--- src/ex_cmds.h	2016-11-12 19:05:58.313384777 +0100
***************
*** 391,400 ****
  EX(CMD_crewind,		"crewind",	ex_cc,
  			RANGE|NOTADR|COUNT|TRLBAR|BANG,
  			ADDR_LINES),
! EX(CMD_cscope,		"cscope",	do_cscope,
  			EXTRA|NOTRLCOM|XFILE,
  			ADDR_LINES),
! EX(CMD_cstag,		"cstag",	do_cstag,
  			BANG|TRLBAR|WORD1,
  			ADDR_LINES),
  EX(CMD_cunmap,		"cunmap",	ex_unmap,
--- 391,400 ----
  EX(CMD_crewind,		"crewind",	ex_cc,
  			RANGE|NOTADR|COUNT|TRLBAR|BANG,
  			ADDR_LINES),
! EX(CMD_cscope,		"cscope",	ex_cscope,
  			EXTRA|NOTRLCOM|XFILE,
  			ADDR_LINES),
! EX(CMD_cstag,		"cstag",	ex_cstag,
  			BANG|TRLBAR|WORD1,
  			ADDR_LINES),
  EX(CMD_cunmap,		"cunmap",	ex_unmap,
***************
*** 745,751 ****
  EX(CMD_lclose,		"lclose",	ex_cclose,
  			RANGE|NOTADR|COUNT|TRLBAR,
  			ADDR_LINES),
! EX(CMD_lcscope,		"lcscope",	do_cscope,
  			EXTRA|NOTRLCOM|XFILE,
  			ADDR_LINES),
  EX(CMD_ldo,		"ldo",		ex_listdo,
--- 745,751 ----
  EX(CMD_lclose,		"lclose",	ex_cclose,
  			RANGE|NOTADR|COUNT|TRLBAR,
  			ADDR_LINES),
! EX(CMD_lcscope,		"lcscope",	ex_cscope,
  			EXTRA|NOTRLCOM|XFILE,
  			ADDR_LINES),
  EX(CMD_ldo,		"ldo",		ex_listdo,
***************
*** 1249,1255 ****
  EX(CMD_scriptencoding,	"scriptencoding", ex_scriptencoding,
  			WORD1|TRLBAR|CMDWIN,
  			ADDR_LINES),
! EX(CMD_scscope,		"scscope",	do_scscope,
  			EXTRA|NOTRLCOM,
  			ADDR_LINES),
  EX(CMD_set,		"set",		ex_set,
--- 1249,1255 ----
  EX(CMD_scriptencoding,	"scriptencoding", ex_scriptencoding,
  			WORD1|TRLBAR|CMDWIN,
  			ADDR_LINES),
! EX(CMD_scscope,		"scscope",	ex_scscope,
  			EXTRA|NOTRLCOM,
  			ADDR_LINES),
  EX(CMD_set,		"set",		ex_set,
*** ../vim-8.0.0080/src/if_cscope.c	2016-11-10 20:01:41.193582919 +0100
--- src/if_cscope.c	2016-11-12 19:13:14.386427848 +0100
***************
*** 201,208 ****
  #endif /* FEAT_CMDL_COMPL */
  
  /*
-  * PRIVATE: do_cscope_general
-  *
   * Find the command, print help if invalid, and then call the corresponding
   * command function.
   */
--- 201,206 ----
***************
*** 242,272 ****
  }
  
  /*
!  * PUBLIC: do_cscope
   */
      void
! do_cscope(exarg_T *eap)
  {
      do_cscope_general(eap, FALSE);
  }
  
  /*
!  * PUBLIC: do_scscope
!  *
!  * same as do_cscope, but splits window, too.
   */
      void
! do_scscope(exarg_T *eap)
  {
      do_cscope_general(eap, TRUE);
  }
  
  /*
!  * PUBLIC: do_cstag
!  *
   */
      void
! do_cstag(exarg_T *eap)
  {
      int ret = FALSE;
  
--- 240,267 ----
  }
  
  /*
!  * Implementation of ":cscope" and ":lcscope"
   */
      void
! ex_cscope(exarg_T *eap)
  {
      do_cscope_general(eap, FALSE);
  }
  
  /*
!  * Implementation of ":scscope". Same as ex_cscope(), but splits window, too.
   */
      void
! ex_scscope(exarg_T *eap)
  {
      do_cscope_general(eap, TRUE);
  }
  
  /*
!  * Implementation of ":cstag"
   */
      void
! ex_cstag(exarg_T *eap)
  {
      int ret = FALSE;
  
***************
*** 336,348 ****
  #endif
      }
  
! } /* do_cscope */
  
  
  /*
!  * PUBLIC: cs_find
!  *
!  * this simulates a vim_fgets(), but for cscope, returns the next line
   * from the cscope output.  should only be called from find_tags()
   *
   * returns TRUE if eof, FALSE otherwise
--- 331,341 ----
  #endif
      }
  
! }
  
  
  /*
!  * This simulates a vim_fgets(), but for cscope, returns the next line
   * from the cscope output.  should only be called from find_tags()
   *
   * returns TRUE if eof, FALSE otherwise
***************
*** 361,369 ****
  
  
  /*
!  * PUBLIC: cs_free_tags
!  *
!  * called only from do_tag(), when popping the tag stack
   */
      void
  cs_free_tags(void)
--- 354,360 ----
  
  
  /*
!  * Called only from do_tag(), when popping the tag stack.
   */
      void
  cs_free_tags(void)
***************
*** 373,381 ****
  
  
  /*
!  * PUBLIC: cs_print_tags
!  *
!  * called from do_tag()
   */
      void
  cs_print_tags(void)
--- 364,370 ----
  
  
  /*
!  * Called from do_tag().
   */
      void
  cs_print_tags(void)
***************
*** 467,478 ****
   ****************************************************************************/
  
  /*
!  * PRIVATE: cs_add
!  *
!  * add cscope database or a directory name (to look for cscope.out)
!  * to the cscope connection list
!  *
!  * MAXPATHL 256
   */
      static int
  cs_add(exarg_T *eap UNUSED)
--- 456,463 ----
   ****************************************************************************/
  
  /*
!  * Add cscope database or a directory name (to look for cscope.out)
!  * to the cscope connection list.
   */
      static int
  cs_add(exarg_T *eap UNUSED)
***************
*** 508,517 ****
  
  
  /*
!  * PRIVATE: cs_add_common
!  *
!  * the common routine to add a new cscope connection.  called by
!  * cs_add() and cs_reset().  i really don't like to do this, but this
   * routine uses a number of goto statements.
   */
      static int
--- 493,500 ----
  
  
  /*
!  * The common routine to add a new cscope connection.  Called by
!  * cs_add() and cs_reset().  I really don't like to do this, but this
   * routine uses a number of goto statements.
   */
      static int
***************
*** 666,674 ****
  
  
  /*
!  * PRIVATE: cs_cnt_connections
!  *
!  * count the number of cscope connections
   */
      static int
  cs_cnt_connections(void)
--- 649,655 ----
  
  
  /*
!  * Count the number of cscope connections.
   */
      static int
  cs_cnt_connections(void)
***************
*** 693,701 ****
  
  #define	CSREAD_BUFSIZE	2048
  /*
!  * PRIVATE: cs_cnt_matches
!  *
!  * count the number of matches for a given cscope connection.
   */
      static int
  cs_cnt_matches(int idx)
--- 674,680 ----
  
  #define	CSREAD_BUFSIZE	2048
  /*
!  * Count the number of matches for a given cscope connection.
   */
      static int
  cs_cnt_matches(int idx)
***************
*** 754,761 ****
  
  
  /*
-  * PRIVATE: cs_create_cmd
-  *
   * Creates the actual cscope command query from what the user entered.
   */
      static char *
--- 733,738 ----
***************
*** 817,824 ****
  
  
  /*
-  * PRIVATE: cs_create_connection
-  *
   * This piece of code was taken/adapted from nvi.  do we need to add
   * the BSD license notice?
   */
--- 794,799 ----
***************
*** 1056,1063 ****
  
  
  /*
-  * PRIVATE: cs_find
-  *
   * Query cscope using command line interface.  Parse the output and use tselect
   * to allow choices.  Like Nvi, creates a pipe to send to/from query/cscope.
   *
--- 1031,1036 ----
***************
*** 1102,1110 ****
  
  
  /*
!  * PRIVATE: cs_find_common
!  *
!  * common code for cscope find, shared by cs_find() and do_cstag()
   */
      static int
  cs_find_common(
--- 1075,1081 ----
  
  
  /*
!  * Common code for cscope find, shared by cs_find() and ex_cstag().
   */
      static int
  cs_find_common(
***************
*** 1323,1331 ****
  } /* cs_find_common */
  
  /*
!  * PRIVATE: cs_help
!  *
!  * print help
   */
      static int
  cs_help(exarg_T *eap UNUSED)
--- 1294,1300 ----
  } /* cs_find_common */
  
  /*
!  * Print help.
   */
      static int
  cs_help(exarg_T *eap UNUSED)
***************
*** 1408,1416 ****
  #endif
  
  /*
!  * PRIVATE: cs_insert_filelist
!  *
!  * insert a new cscope database filename into the filelist
   */
      static int
  cs_insert_filelist(
--- 1377,1383 ----
  #endif
  
  /*
!  * Insert a new cscope database filename into the filelist.
   */
      static int
  cs_insert_filelist(
***************
*** 1551,1559 ****
  
  
  /*
!  * PRIVATE: cs_lookup_cmd
!  *
!  * find cscope command in command table
   */
      static cscmd_T *
  cs_lookup_cmd(exarg_T *eap)
--- 1518,1524 ----
  
  
  /*
!  * Find cscope command in command table.
   */
      static cscmd_T *
  cs_lookup_cmd(exarg_T *eap)
***************
*** 1582,1590 ****
  
  
  /*
!  * PRIVATE: cs_kill
!  *
!  * nuke em
   */
      static int
  cs_kill(exarg_T *eap UNUSED)
--- 1547,1553 ----
  
  
  /*
!  * Nuke em.
   */
      static int
  cs_kill(exarg_T *eap UNUSED)
***************
*** 1639,1646 ****
  
  
  /*
-  * PRIVATE: cs_kill_execute
-  *
   * Actually kills a specific cscope connection.
   */
      static void
--- 1602,1607 ----
***************
*** 1659,1680 ****
  
  
  /*
!  * PRIVATE: cs_make_vim_style_matches
!  *
!  * convert the cscope output into a ctags style entry (as might be found
   * in a ctags tags file).  there's one catch though: cscope doesn't tell you
   * the type of the tag you are looking for.  for example, in Darren Hiebert's
   * ctags (the one that comes with vim), #define's use a line number to find the
   * tag in a file while function definitions use a regexp search pattern.
   *
!  * i'm going to always use the line number because cscope does something
   * quirky (and probably other things i don't know about):
   *
   *     if you have "#  define" in your source file, which is
   *     perfectly legal, cscope thinks you have "#define".  this
   *     will result in a failed regexp search. :(
   *
!  * besides, even if this particular case didn't happen, the search pattern
   * would still have to be modified to escape all the special regular expression
   * characters to comply with ctags formatting.
   */
--- 1620,1639 ----
  
  
  /*
!  * Convert the cscope output into a ctags style entry (as might be found
   * in a ctags tags file).  there's one catch though: cscope doesn't tell you
   * the type of the tag you are looking for.  for example, in Darren Hiebert's
   * ctags (the one that comes with vim), #define's use a line number to find the
   * tag in a file while function definitions use a regexp search pattern.
   *
!  * I'm going to always use the line number because cscope does something
   * quirky (and probably other things i don't know about):
   *
   *     if you have "#  define" in your source file, which is
   *     perfectly legal, cscope thinks you have "#define".  this
   *     will result in a failed regexp search. :(
   *
!  * Besides, even if this particular case didn't happen, the search pattern
   * would still have to be modified to escape all the special regular expression
   * characters to comply with ctags formatting.
   */
***************
*** 1721,1729 ****
  
  
  /*
!  * PRIVATE: cs_manage_matches
!  *
!  * this is kind of hokey, but i don't see an easy way round this..
   *
   * Store: keep a ptr to the (malloc'd) memory of matches originally
   * generated from cs_find().  the matches are originally lines directly
--- 1680,1686 ----
  
  
  /*
!  * This is kind of hokey, but i don't see an easy way round this.
   *
   * Store: keep a ptr to the (malloc'd) memory of matches originally
   * generated from cs_find().  the matches are originally lines directly
***************
*** 1801,1809 ****
  
  
  /*
!  * PRIVATE: cs_parse_results
!  *
!  * parse cscope output
   */
      static char *
  cs_parse_results(
--- 1758,1764 ----
  
  
  /*
!  * Parse cscope output.
   */
      static char *
  cs_parse_results(
***************
*** 1864,1872 ****
  
  #ifdef FEAT_QUICKFIX
  /*
!  * PRIVATE: cs_file_results
!  *
!  * write cscope find results to file
   */
      static void
  cs_file_results(FILE *f, int *nummatches_a)
--- 1819,1825 ----
  
  #ifdef FEAT_QUICKFIX
  /*
!  * Write cscope find results to file.
   */
      static void
  cs_file_results(FILE *f, int *nummatches_a)
***************
*** 1919,1928 ****
  #endif
  
  /*
!  * PRIVATE: cs_fill_results
!  *
!  * get parsed cscope output and calls cs_make_vim_style_matches to convert
!  * into ctags format
   * When there are no matches sets "*matches_p" to NULL.
   */
      static void
--- 1872,1879 ----
  #endif
  
  /*
!  * Get parsed cscope output and calls cs_make_vim_style_matches to convert
!  * into ctags format.
   * When there are no matches sets "*matches_p" to NULL.
   */
      static void
***************
*** 2032,2040 ****
  }
  
  /*
!  * PRIVATE: cs_print_tags_priv
!  *
!  * called from cs_manage_matches()
   */
      static void
  cs_print_tags_priv(char **matches, char **cntxts, int num_matches)
--- 1983,1989 ----
  }
  
  /*
!  * Called from cs_manage_matches().
   */
      static void
  cs_print_tags_priv(char **matches, char **cntxts, int num_matches)
***************
*** 2182,2190 ****
  
  
  /*
!  * PRIVATE: cs_read_prompt
!  *
!  * read a cscope prompt (basically, skip over the ">> ")
   */
      static int
  cs_read_prompt(int i)
--- 2131,2137 ----
  
  
  /*
!  * Read a cscope prompt (basically, skip over the ">> ").
   */
      static int
  cs_read_prompt(int i)
***************
*** 2280,2287 ****
  #endif
  
  /*
-  * PRIVATE: cs_release_csp
-  *
   * Does the actual free'ing for the cs ptr with an optional flag of whether
   * or not to free the filename.  Called by cs_kill and cs_reset.
   */
--- 2227,2232 ----
***************
*** 2408,2416 ****
  
  
  /*
!  * PRIVATE: cs_reset
!  *
!  * calls cs_kill on all cscope connections then reinits
   */
      static int
  cs_reset(exarg_T *eap UNUSED)
--- 2353,2359 ----
  
  
  /*
!  * Calls cs_kill on all cscope connections then reinits.
   */
      static int
  cs_reset(exarg_T *eap UNUSED)
***************
*** 2474,2481 ****
  
  
  /*
-  * PRIVATE: cs_resolve_file
-  *
   * Construct the full pathname to a file found in the cscope database.
   * (Prepends ppath, if there is one and if it's not already prepended,
   * otherwise just uses the name found.)
--- 2417,2422 ----
***************
*** 2544,2552 ****
  
  
  /*
!  * PRIVATE: cs_show
!  *
!  * show all cscope connections
   */
      static int
  cs_show(exarg_T *eap UNUSED)
--- 2485,2491 ----
  
  
  /*
!  * Show all cscope connections.
   */
      static int
  cs_show(exarg_T *eap UNUSED)
***************
*** 2579,2586 ****
  
  
  /*
-  * PUBLIC: cs_end
-  *
   * Only called when VIM exits to quit any cscope sessions.
   */
      void
--- 2518,2523 ----
*** ../vim-8.0.0080/src/ex_docmd.c	2016-11-10 20:20:01.874602675 +0100
--- src/ex_docmd.c	2016-11-12 19:05:37.725523650 +0100
***************
*** 243,251 ****
  # define ex_helpfind		ex_ni
  #endif
  #ifndef FEAT_CSCOPE
! # define do_cscope		ex_ni
! # define do_scscope		ex_ni
! # define do_cstag		ex_ni
  #endif
  #ifndef FEAT_SYN_HL
  # define ex_syntax		ex_ni
--- 243,251 ----
  # define ex_helpfind		ex_ni
  #endif
  #ifndef FEAT_CSCOPE
! # define ex_cscope		ex_ni
! # define ex_scscope		ex_ni
! # define ex_cstag		ex_ni
  #endif
  #ifndef FEAT_SYN_HL
  # define ex_syntax		ex_ni
***************
*** 10427,10433 ****
  #ifdef FEAT_CSCOPE
  		  if (p_cst && *eap->arg != NUL)
  		  {
! 		      do_cstag(eap);
  		      return;
  		  }
  #endif
--- 10427,10433 ----
  #ifdef FEAT_CSCOPE
  		  if (p_cst && *eap->arg != NUL)
  		  {
! 		      ex_cstag(eap);
  		      return;
  		  }
  #endif
*** ../vim-8.0.0080/src/proto/if_cscope.pro	2016-09-12 13:04:06.000000000 +0200
--- src/proto/if_cscope.pro	2016-11-12 19:06:02.421357070 +0100
***************
*** 1,9 ****
  /* if_cscope.c */
  char_u *get_cscope_name(expand_T *xp, int idx);
  void set_context_in_cscope_cmd(expand_T *xp, char_u *arg, cmdidx_T cmdidx);
! void do_cscope(exarg_T *eap);
! void do_scscope(exarg_T *eap);
! void do_cstag(exarg_T *eap);
  int cs_fgets(char_u *buf, int size);
  void cs_free_tags(void);
  void cs_print_tags(void);
--- 1,9 ----
  /* if_cscope.c */
  char_u *get_cscope_name(expand_T *xp, int idx);
  void set_context_in_cscope_cmd(expand_T *xp, char_u *arg, cmdidx_T cmdidx);
! void ex_cscope(exarg_T *eap);
! void ex_scscope(exarg_T *eap);
! void ex_cstag(exarg_T *eap);
  int cs_fgets(char_u *buf, int size);
  void cs_free_tags(void);
  void cs_print_tags(void);
*** ../vim-8.0.0080/src/version.c	2016-11-12 18:30:35.115712865 +0100
--- src/version.c	2016-11-12 19:15:58.557299522 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     81,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
25. You believe nothing looks sexier than a man in boxer shorts illuminated
    only by a 17" inch svga monitor.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0082
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0082
Problem:    Extension for configure should be ".ac".
Solution:   Rename configure.in to configure.ac. (James McCoy, closes #1173)
Files:      src/configure.in, src/configure.ac, Filelist, src/Makefile,
            src/blowfish.c, src/channel.c, src/config.h.in, src/main.aap,
            src/os_unix.c, src/INSTALL, src/mysign


*** ../vim-8.0.0081/src/configure.in	2016-10-18 16:27:20.544756017 +0200
--- src/configure.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,4314 ****
- dnl configure.in: autoconf script for Vim
- 
- dnl Process this file with autoconf 2.12 or 2.13 to produce "configure".
- dnl Should also work with autoconf 2.54 and later.
- 
- AC_INIT(vim.h)
- AC_CONFIG_HEADER(auto/config.h:config.h.in)
- 
- dnl Being able to run configure means the system is Unix (compatible).
- AC_DEFINE(UNIX)
- AC_PROG_MAKE_SET
- 
- dnl Checks for programs.
- AC_PROG_CC	dnl required by almost everything
- AC_PROG_CPP	dnl required by header file checks
- AC_PROGRAM_EGREP dnl required by AC_EGREP_CPP
- AC_PROG_FGREP	dnl finds working grep -F
- AC_ISC_POSIX	dnl required by AC_C_CROSS
- AC_PROG_AWK	dnl required for "make html" in ../doc
- 
- dnl Don't strip if we don't have it
- AC_CHECK_PROG(STRIP, strip, strip, :)
- 
- dnl Check for extension of executables
- AC_EXEEXT
- 
- dnl Check for standard headers.  We don't use this in Vim but other stuff
- dnl in autoconf needs it, where it uses STDC_HEADERS.
- AC_HEADER_STDC
- AC_HEADER_SYS_WAIT
- 
- dnl Check for the flag that fails if stuff are missing.
- 
- AC_MSG_CHECKING(--enable-fail-if-missing argument)
- AC_ARG_ENABLE(fail_if_missing,
- 	[  --enable-fail-if-missing    Fail if dependencies on additional features
-      specified on the command line are missing.], 
- 	[fail_if_missing="yes"],
- 	[fail_if_missing="no"])
- AC_MSG_RESULT($fail_if_missing)
- 
- dnl Set default value for CFLAGS if none is defined or it's empty
- if test -z "$CFLAGS"; then
-   CFLAGS="-O"
-   test "$GCC" = yes && CFLAGS="-O2 -fno-strength-reduce -Wall"
- fi
- if test "$GCC" = yes; then
-   dnl method that should work for nearly all versions
-   gccversion=`$CC -dumpversion`
-   if test "x$gccversion" = "x"; then
-     dnl old method; fall-back for when -dumpversion doesn't work
-     gccversion=`$CC --version | sed -e '2,$d' -e 's/darwin.//' -e 's/^[[^0-9]]*\([[0-9]]\.[[0-9.]]*\).*$/\1/g'`
-   fi
-   dnl version 4.0.1 was reported to cause trouble on Macintosh by Marcin Dalecki
-   if test "$gccversion" = "3.0.1" -o "$gccversion" = "3.0.2" -o "$gccversion" = "4.0.1"; then
-     echo 'GCC [[34]].0.[[12]] has a bug in the optimizer, disabling "-O#"'
-     CFLAGS=`echo "$CFLAGS" | sed 's/-O[[23456789]]/-O/'`
-   else
-     if test "$gccversion" = "3.1" -o "$gccversion" = "3.2" -o "$gccversion" = "3.2.1" && `echo "$CFLAGS" | grep -v fno-strength-reduce >/dev/null`; then
-       echo 'GCC 3.1 and 3.2 have a bug in the optimizer, adding "-fno-strength-reduce"'
-       CFLAGS="$CFLAGS -fno-strength-reduce"
-     fi
-   fi
- fi
- 
- dnl clang-500.2.75 or around has abandoned -f[no-]strength-reduce and issues a
- dnl warning when that flag is passed to.  Accordingly, adjust CFLAGS based on
- dnl the version number of the clang in use.
- dnl Note that this does not work to get the version of clang 3.1 or 3.2.
- AC_MSG_CHECKING(for recent clang version)
- CLANG_VERSION_STRING=`$CC --version 2>/dev/null | sed  -n -e 's/^.*clang.*\([[0-9]][[0-9]]*\.[[0-9]][[0-9]]*\.[[0-9]][[0-9]]*\).*$/\1/p'`
- if test x"$CLANG_VERSION_STRING" != x"" ; then
-   CLANG_MAJOR=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/\([[0-9]][[0-9]]*\)\.[[0-9]][[0-9]]*\.[[0-9]][[0-9]]*/\1/p'`
-   CLANG_MINOR=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/[[0-9]][[0-9]]*\.\([[0-9]][[0-9]]*\)\.[[0-9]][[0-9]]*/\1/p'`
-   CLANG_REVISION=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/[[0-9]][[0-9]]*\.[[0-9]][[0-9]]*\.\([[0-9]][[0-9]]*\)/\1/p'`
-   CLANG_VERSION=`expr $CLANG_MAJOR '*' 1000000 '+' $CLANG_MINOR '*' 1000 '+' $CLANG_REVISION`
-   AC_MSG_RESULT($CLANG_VERSION)
-   dnl If you find the same issue with versions earlier than 500.2.75,
-   dnl change the constant 500002075 below appropriately.  To get the
-   dnl integer corresponding to a version number, refer to the
-   dnl definition of CLANG_VERSION above.
-   if test "$CLANG_VERSION" -ge 500002075 ; then
-     CFLAGS=`echo "$CFLAGS" | sed -n -e 's/-fno-strength-reduce/ /p'`
-   fi
- else
-   AC_MSG_RESULT(no)
- fi
- 
- dnl If configure thinks we are cross compiling, there might be something
- dnl wrong with the CC or CFLAGS settings, give a useful warning message
- CROSS_COMPILING=
- if test "$cross_compiling" = yes; then
-   AC_MSG_RESULT([cannot compile a simple program; if not cross compiling check CC and CFLAGS])
-   CROSS_COMPILING=1
- fi
- AC_SUBST(CROSS_COMPILING)
- 
- dnl gcc-cpp has the wonderful -MM option to produce nicer dependencies.
- dnl But gcc 3.1 changed the meaning!  See near the end.
- test "$GCC" = yes && CPP_MM=M; AC_SUBST(CPP_MM)
- 
- if test -f ./toolcheck; then
-   AC_CHECKING(for buggy tools)
-   sh ./toolcheck 1>&AC_FD_MSG
- fi
- 
- OS_EXTRA_SRC=""; OS_EXTRA_OBJ=""
- 
- dnl Check for BeOS, which needs an extra source file
- AC_MSG_CHECKING(for BeOS)
- case `uname` in
-     BeOS)	OS_EXTRA_SRC=os_beos.c; OS_EXTRA_OBJ=objects/os_beos.o
- 		BEOS=yes; AC_MSG_RESULT(yes);;
-     *)		BEOS=no; AC_MSG_RESULT(no);;
- esac
- 
- dnl If QNX is found, assume we don't want to use Xphoton
- dnl unless it was specifically asked for (--with-x)
- AC_MSG_CHECKING(for QNX)
- case `uname` in
-     QNX)	OS_EXTRA_SRC=os_qnx.c; OS_EXTRA_OBJ=objects/os_qnx.o
- 		test -z "$with_x" && with_x=no
- 		QNX=yes; AC_MSG_RESULT(yes);;
-     *)		QNX=no; AC_MSG_RESULT(no);;
- esac
- 
- dnl Check for Darwin and MacOS X
- dnl We do a check for MacOS X in the very beginning because there
- dnl are a lot of other things we need to change besides GUI stuff
- AC_MSG_CHECKING([for Darwin (Mac OS X)])
- if test "`(uname) 2>/dev/null`" = Darwin; then
-   AC_MSG_RESULT(yes)
- 
-   AC_MSG_CHECKING(--disable-darwin argument)
-   AC_ARG_ENABLE(darwin,
- 	  [  --disable-darwin        Disable Darwin (Mac OS X) support.],
- 	  , [enable_darwin="yes"])
-   if test "$enable_darwin" = "yes"; then
-     AC_MSG_RESULT(no)
-     AC_MSG_CHECKING(if Darwin files are there)
-     if test -f os_macosx.m; then
-       AC_MSG_RESULT(yes)
-     else
-       AC_MSG_RESULT([no, Darwin support disabled])
-       enable_darwin=no
-     fi
-   else
-     AC_MSG_RESULT([yes, Darwin support excluded])
-   fi
- 
-   AC_MSG_CHECKING(--with-mac-arch argument)
-   AC_ARG_WITH(mac-arch, [  --with-mac-arch=ARCH    current, intel, ppc or both],
- 	MACARCH="$withval"; AC_MSG_RESULT($MACARCH),
- 	MACARCH="current"; AC_MSG_RESULT(defaulting to $MACARCH))
- 
-   AC_MSG_CHECKING(--with-developer-dir argument)
-   AC_ARG_WITH(developer-dir, [  --with-developer-dir=PATH    use PATH as location for Xcode developer tools],
- 	DEVELOPER_DIR="$withval"; AC_MSG_RESULT($DEVELOPER_DIR),
-         AC_MSG_RESULT(not present))
-   
-   if test "x$DEVELOPER_DIR" = "x"; then
-     AC_PATH_PROG(XCODE_SELECT, xcode-select)
-     if test "x$XCODE_SELECT" != "x"; then
-       AC_MSG_CHECKING(for developer dir using xcode-select)
-       DEVELOPER_DIR=`$XCODE_SELECT -print-path`
-       AC_MSG_RESULT([$DEVELOPER_DIR])
-     else
-       DEVELOPER_DIR=/Developer
-     fi
-   fi
- 
-   if test "x$MACARCH" = "xboth"; then
-     AC_MSG_CHECKING(for 10.4 universal SDK)
-     dnl There is a terrible inconsistency (but we appear to get away with it):
-     dnl $CFLAGS uses the 10.4u SDK library for the headers, while $CPPFLAGS
-     dnl doesn't, because "gcc -E" doesn't grok it.  That means the configure
-     dnl tests using the preprocessor are actually done with the wrong header
-     dnl files. $LDFLAGS is set at the end, because configure uses it together
-     dnl with $CFLAGS and we can only have one -sysroot argument.
-     save_cppflags="$CPPFLAGS"
-     save_cflags="$CFLAGS"
-     save_ldflags="$LDFLAGS"
-     CFLAGS="$CFLAGS -isysroot $DEVELOPER_DIR/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc"
-     AC_TRY_LINK([ ], [ ],
- 	AC_MSG_RESULT(found, will make universal binary),
- 
- 	AC_MSG_RESULT(not found)
- 	CFLAGS="$save_cflags"
- 	AC_MSG_CHECKING(if Intel architecture is supported)
- 	CPPFLAGS="$CPPFLAGS -arch i386"
- 	LDFLAGS="$save_ldflags -arch i386"
- 	AC_TRY_LINK([ ], [ ],
- 	    AC_MSG_RESULT(yes); MACARCH="intel",
- 	    AC_MSG_RESULT(no, using PowerPC)
- 		MACARCH="ppc"
- 		CPPFLAGS="$save_cppflags -arch ppc"
- 		LDFLAGS="$save_ldflags -arch ppc"))
-   elif test "x$MACARCH" = "xintel"; then
-     CPPFLAGS="$CPPFLAGS -arch intel"
-     LDFLAGS="$LDFLAGS -arch intel"
-   elif test "x$MACARCH" = "xppc"; then
-     CPPFLAGS="$CPPFLAGS -arch ppc"
-     LDFLAGS="$LDFLAGS -arch ppc"
-   fi
- 
-   if test "$enable_darwin" = "yes"; then
-     MACOSX=yes
-     OS_EXTRA_SRC="os_macosx.m os_mac_conv.c";
-     OS_EXTRA_OBJ="objects/os_macosx.o objects/os_mac_conv.o"
-     dnl TODO: use -arch i386 on Intel machines
-     dnl Removed -no-cpp-precomp, only for very old compilers.
-     CPPFLAGS="$CPPFLAGS -DMACOS_X_UNIX"
- 
-     dnl If Carbon is found, assume we don't want X11
-     dnl unless it was specifically asked for (--with-x)
-     dnl or Motif, Athena or GTK GUI is used.
-     AC_CHECK_HEADER(Carbon/Carbon.h, CARBON=yes)
-     if test "x$CARBON" = "xyes"; then
-       if test -z "$with_x" -a "X$enable_gui" != Xmotif -a "X$enable_gui" != Xathena -a "X$enable_gui" != Xgtk2 -a "X$enable_gui" != Xgtk3; then
- 	with_x=no
-       fi
-     fi
-   fi
- 
-   dnl Avoid a bug with -O2 with gcc 4.0.1.  Symptom: malloc() reports double
-   dnl free.  This happens in expand_filename(), because the optimizer swaps
-   dnl two blocks of code, both using "repl", that can't be swapped.
-   if test "$MACARCH" = "intel" -o "$MACARCH" = "both"; then
-     CFLAGS=`echo "$CFLAGS" | sed 's/-O[[23456789]]/-Oz/'`
-   fi
- 
- else
-   AC_MSG_RESULT(no)
- fi
- 
- dnl Mac OS X 10.9+ no longer include AvailabilityMacros.h in Carbon
- dnl so we need to include it to have access to version macros.
- AC_CHECK_HEADERS(AvailabilityMacros.h)
- 
- AC_SUBST(OS_EXTRA_SRC)
- AC_SUBST(OS_EXTRA_OBJ)
- 
- dnl Add /usr/local/lib to $LDFLAGS and /usr/local/include to CFLAGS.
- dnl Only when the directory exists and it wasn't there yet.
- dnl For gcc don't do this when it is already in the default search path.
- dnl Skip all of this when cross-compiling.
- if test "$cross_compiling" = no; then
-   AC_MSG_CHECKING(--with-local-dir argument)
-   have_local_include=''
-   have_local_lib=''
-   AC_ARG_WITH([local-dir], [  --with-local-dir=PATH   search PATH instead of /usr/local for local libraries.
-   --without-local-dir     do not search /usr/local for local libraries.], [
-     local_dir="$withval"
-     case "$withval" in
-     */*) ;;
-     no)
-       # avoid adding local dir to LDFLAGS and CPPFLAGS
-       have_local_include=yes
-       have_local_lib=yes
-       ;;
-     *) AC_MSG_ERROR(must pass path argument to --with-local-dir) ;;
-     esac
- 	AC_MSG_RESULT($local_dir)
-   ], [
-     local_dir=/usr/local
-     AC_MSG_RESULT(Defaulting to $local_dir)
-   ])
-   if test "$GCC" = yes -a "$local_dir" != no; then
-     echo 'void f(){}' > conftest.c
-     dnl Removed -no-cpp-precomp, only needed for OS X 10.2 (Ben Fowler)
-     have_local_include=`${CC-cc} -c -v conftest.c 2>&1 | grep "${local_dir}/include"`
-     have_local_lib=`${CC-cc} -c -v conftest.c 2>&1 | grep "${local_dir}/lib"`
-     rm -f conftest.c conftest.o
-   fi
-   if test -z "$have_local_lib" -a -d "${local_dir}/lib"; then
-     tt=`echo "$LDFLAGS" | sed -e "s+-L${local_dir}/lib ++g" -e "s+-L${local_dir}/lib$++g"`
-     if test "$tt" = "$LDFLAGS"; then
-       LDFLAGS="$LDFLAGS -L${local_dir}/lib"
-     fi
-   fi
-   if test -z "$have_local_include" -a -d "${local_dir}/include"; then
-     tt=`echo "$CPPFLAGS" | sed -e "s+-I${local_dir}/include ++g" -e "s+-I${local_dir}/include$++g"`
-     if test "$tt" = "$CPPFLAGS"; then
-       CPPFLAGS="$CPPFLAGS -I${local_dir}/include"
-     fi
-   fi
- fi
- 
- AC_MSG_CHECKING(--with-vim-name argument)
- AC_ARG_WITH(vim-name, [  --with-vim-name=NAME    what to call the Vim executable],
- 	VIMNAME="$withval"; AC_MSG_RESULT($VIMNAME),
- 	VIMNAME="vim"; AC_MSG_RESULT(Defaulting to $VIMNAME))
- AC_SUBST(VIMNAME)
- AC_MSG_CHECKING(--with-ex-name argument)
- AC_ARG_WITH(ex-name, [  --with-ex-name=NAME     what to call the Ex executable],
- 	EXNAME="$withval"; AC_MSG_RESULT($EXNAME),
- 	EXNAME="ex"; AC_MSG_RESULT(Defaulting to ex))
- AC_SUBST(EXNAME)
- AC_MSG_CHECKING(--with-view-name argument)
- AC_ARG_WITH(view-name, [  --with-view-name=NAME   what to call the View executable],
- 	VIEWNAME="$withval"; AC_MSG_RESULT($VIEWNAME),
- 	VIEWNAME="view"; AC_MSG_RESULT(Defaulting to view))
- AC_SUBST(VIEWNAME)
- 
- AC_MSG_CHECKING(--with-global-runtime argument)
- AC_ARG_WITH(global-runtime, [  --with-global-runtime=DIR    global runtime directory in 'runtimepath'],
- 	AC_MSG_RESULT($withval); AC_DEFINE_UNQUOTED(RUNTIME_GLOBAL, "$withval"),
- 	AC_MSG_RESULT(no))
- 
- AC_MSG_CHECKING(--with-modified-by argument)
- AC_ARG_WITH(modified-by, [  --with-modified-by=NAME       name of who modified a release version],
- 	AC_MSG_RESULT($withval); AC_DEFINE_UNQUOTED(MODIFIED_BY, "$withval"),
- 	AC_MSG_RESULT(no))
- 
- dnl Check for EBCDIC stolen from the LYNX port to z/OS Unix
- AC_MSG_CHECKING(if character set is EBCDIC)
- AC_TRY_COMPILE([ ],
- [ /* TryCompile function for CharSet.
-    Treat any failure as ASCII for compatibility with existing art.
-    Use compile-time rather than run-time tests for cross-compiler
-    tolerance.  */
- #if '0'!=240
- make an error "Character set is not EBCDIC"
- #endif ],
- [ # TryCompile action if true
- cf_cv_ebcdic=yes ],
- [ # TryCompile action if false
- cf_cv_ebcdic=no])
- # end of TryCompile ])
- # end of CacheVal CvEbcdic
- AC_MSG_RESULT($cf_cv_ebcdic)
- case "$cf_cv_ebcdic" in  #(vi
-     yes)	AC_DEFINE(EBCDIC)
- 		line_break='"\\n"'
- 		;;
-     *)		line_break='"\\012"';;
- esac
- AC_SUBST(line_break)
- 
- if test "$cf_cv_ebcdic" = "yes"; then
- dnl If we have EBCDIC we most likely have z/OS Unix, let's test it!
- AC_MSG_CHECKING(for z/OS Unix)
- case `uname` in
-     OS/390)	zOSUnix="yes";
- 		dnl If using cc the environment variable _CC_CCMODE must be
- 		dnl set to "1", so that some compiler extensions are enabled.
- 		dnl If using c89 the environment variable is named _CC_C89MODE.
- 		dnl Note: compile with c89 never tested.
- 		if test "$CC" = "cc"; then
- 		  ccm="$_CC_CCMODE"
- 		  ccn="CC"
- 		else
- 		  if test "$CC" = "c89"; then
- 		    ccm="$_CC_C89MODE"
- 		    ccn="C89"
- 		  else
- 		    ccm=1
- 		  fi
- 		fi
- 		if test "$ccm" != "1"; then
- 		  echo ""
- 		  echo "------------------------------------------"
- 		  echo " On z/OS Unix, the environment variable"
- 		  echo " _CC_${ccn}MODE must be set to \"1\"!"
- 		  echo " Do:"
- 		  echo "    export _CC_${ccn}MODE=1"
- 		  echo " and then call configure again."
- 		  echo "------------------------------------------"
- 		  exit 1
- 		fi
- 		# Set CFLAGS for configure process.
- 		# This will be reset later for config.mk.
- 		# Use haltonmsg to force error for missing H files.
- 		CFLAGS="$CFLAGS -D_ALL_SOURCE -Wc,float(ieee),haltonmsg(3296)";
- 		LDFLAGS="$LDFLAGS -Wl,EDIT=NO"
- 		AC_MSG_RESULT(yes)
- 		;;
-     *)		zOSUnix="no";
- 		AC_MSG_RESULT(no)
- 		;;
- esac
- fi
- 
- dnl Set QUOTESED. Needs additional backslashes on zOS
- if test "$zOSUnix" = "yes"; then
-     QUOTESED="sed -e 's/[[\\\\\"]]/\\\\\\\\&/g' -e 's/\\\\\\\\\"/\"/' -e 's/\\\\\\\\\";\$\$/\";/'"
- else
-     QUOTESED="sed -e 's/[[\\\\\"]]/\\\\&/g' -e 's/\\\\\"/\"/' -e 's/\\\\\";\$\$/\";/'"
- fi
- AC_SUBST(QUOTESED)
- 
- 
- dnl Link with -lsmack for Smack stuff; if not found
- AC_MSG_CHECKING(--disable-smack argument)
- AC_ARG_ENABLE(smack,
- 	[  --disable-smack	  Do not check for Smack support.],
- 	, enable_smack="yes")
- if test "$enable_smack" = "yes"; then
-   AC_MSG_RESULT(no)
-   AC_CHECK_HEADER([linux/xattr.h], true, enable_smack="no")
- else
-   AC_MSG_RESULT(yes)
- fi
- if test "$enable_smack" = "yes"; then
-   AC_CHECK_HEADER([attr/xattr.h], true, enable_smack="no")
- fi
- if test "$enable_smack" = "yes"; then
-   AC_MSG_CHECKING(for XATTR_NAME_SMACKEXEC in linux/xattr.h)
-   AC_EGREP_CPP(XATTR_NAME_SMACKEXEC, [#include <linux/xattr.h>],
- 	       AC_MSG_RESULT(yes),
- 	       AC_MSG_RESULT(no); enable_smack="no")
- fi
- if test "$enable_smack" = "yes"; then
-   AC_CHECK_LIB(attr, setxattr,
- 	  [LIBS="$LIBS -lattr"
- 	   found_smack="yes"
- 	   AC_DEFINE(HAVE_SMACK)])
- fi
- 
- dnl When smack was found don't search for SELinux
- if test "x$found_smack" = "x"; then
-   dnl Link with -lselinux for SELinux stuff; if not found
-   AC_MSG_CHECKING(--disable-selinux argument)
-   AC_ARG_ENABLE(selinux,
- 	  [  --disable-selinux	  Do not check for SELinux support.],
- 	  , enable_selinux="yes")
-   if test "$enable_selinux" = "yes"; then
-     AC_MSG_RESULT(no)
-     AC_CHECK_LIB(selinux, is_selinux_enabled,
- 	    [LIBS="$LIBS -lselinux"
- 	     AC_DEFINE(HAVE_SELINUX)])
-   else
-      AC_MSG_RESULT(yes)
-   fi
- fi
- 
- dnl Check user requested features.
- 
- AC_MSG_CHECKING(--with-features argument)
- AC_ARG_WITH(features, [  --with-features=TYPE    tiny, small, normal, big or huge (default: huge)],
- 	features="$withval"; AC_MSG_RESULT($features),
- 	features="huge"; AC_MSG_RESULT(Defaulting to huge))
- 
- dovimdiff=""
- dogvimdiff=""
- case "$features" in
-   tiny)		AC_DEFINE(FEAT_TINY) ;;
-   small)	AC_DEFINE(FEAT_SMALL) ;;
-   normal)	AC_DEFINE(FEAT_NORMAL) dovimdiff="installvimdiff";
- 			dogvimdiff="installgvimdiff" ;;
-   big)		AC_DEFINE(FEAT_BIG) dovimdiff="installvimdiff";
- 			dogvimdiff="installgvimdiff" ;;
-   huge)		AC_DEFINE(FEAT_HUGE) dovimdiff="installvimdiff";
- 			dogvimdiff="installgvimdiff" ;;
-   *)		AC_MSG_RESULT([Sorry, $features is not supported]) ;;
- esac
- 
- AC_SUBST(dovimdiff)
- AC_SUBST(dogvimdiff)
- 
- AC_MSG_CHECKING(--with-compiledby argument)
- AC_ARG_WITH(compiledby, [  --with-compiledby=NAME  name to show in :version message],
- 	compiledby="$withval"; AC_MSG_RESULT($withval),
- 	compiledby=""; AC_MSG_RESULT(no))
- AC_SUBST(compiledby)
- 
- AC_MSG_CHECKING(--disable-xsmp argument)
- AC_ARG_ENABLE(xsmp,
- 	[  --disable-xsmp          Disable XSMP session management],
- 	, enable_xsmp="yes")
- 
- if test "$enable_xsmp" = "yes"; then
-   AC_MSG_RESULT(no)
-   AC_MSG_CHECKING(--disable-xsmp-interact argument)
-   AC_ARG_ENABLE(xsmp-interact,
- 	  [  --disable-xsmp-interact Disable XSMP interaction],
- 	  , enable_xsmp_interact="yes")
-   if test "$enable_xsmp_interact" = "yes"; then
-     AC_MSG_RESULT(no)
-     AC_DEFINE(USE_XSMP_INTERACT)
-   else
-     AC_MSG_RESULT(yes)
-   fi
- else
-   AC_MSG_RESULT(yes)
- fi
- 
- dnl Check for Lua feature.
- AC_MSG_CHECKING(--enable-luainterp argument)
- AC_ARG_ENABLE(luainterp,
- 	[  --enable-luainterp[=OPTS]     Include Lua interpreter.  [default=no] [OPTS=no/yes/dynamic]], ,
- 	[enable_luainterp="no"])
- AC_MSG_RESULT($enable_luainterp)
- 
- if test "$enable_luainterp" = "yes" -o "$enable_luainterp" = "dynamic"; then
-   if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
-     AC_MSG_ERROR([cannot use Lua with tiny or small features])
-   fi
- 
-   dnl -- find the lua executable
-   AC_SUBST(vi_cv_path_lua)
- 
-   AC_MSG_CHECKING(--with-lua-prefix argument)
-   AC_ARG_WITH(lua_prefix,
- 	[  --with-lua-prefix=PFX   Prefix where Lua is installed.],
- 	with_lua_prefix="$withval"; AC_MSG_RESULT($with_lua_prefix),
- 	with_lua_prefix="";AC_MSG_RESULT(no))
- 
-   if test "X$with_lua_prefix" != "X"; then
-        vi_cv_path_lua_pfx="$with_lua_prefix"
-   else
-     AC_MSG_CHECKING(LUA_PREFIX environment var)
-     if test "X$LUA_PREFIX" != "X"; then
- 	AC_MSG_RESULT("$LUA_PREFIX")
- 	vi_cv_path_lua_pfx="$LUA_PREFIX"
-     else
- 	AC_MSG_RESULT([not set, default to /usr])
- 	vi_cv_path_lua_pfx="/usr"
-     fi
-   fi
- 
-   AC_MSG_CHECKING(--with-luajit)
-   AC_ARG_WITH(luajit,
- 	[  --with-luajit           Link with LuaJIT instead of Lua.],
- 	[vi_cv_with_luajit="$withval"],
- 	[vi_cv_with_luajit="no"])
-   AC_MSG_RESULT($vi_cv_with_luajit)
- 
-   LUA_INC=
-   if test "X$vi_cv_path_lua_pfx" != "X"; then
-     if test "x$vi_cv_with_luajit" != "xno"; then
-       dnl -- try to find LuaJIT executable
-       AC_PATH_PROG(vi_cv_path_luajit, luajit)
-       if test "X$vi_cv_path_luajit" != "X"; then
- 	dnl -- find LuaJIT version
- 	AC_CACHE_CHECK(LuaJIT version, vi_cv_version_luajit,
- 	[ vi_cv_version_luajit=`${vi_cv_path_luajit} -v 2>&1 | sed 's/LuaJIT \([[0-9.]]*\)\.[[0-9]]\(-[[a-z0-9]]*\)* .*/\1/'` ])
- 	AC_CACHE_CHECK(Lua version of LuaJIT, vi_cv_version_lua_luajit,
- 	[ vi_cv_version_lua_luajit=`${vi_cv_path_luajit} -e "print(_VERSION)" | sed 's/.* //'` ])
- 	vi_cv_path_lua="$vi_cv_path_luajit"
- 	vi_cv_version_lua="$vi_cv_version_lua_luajit"
-       fi
-     else
-       dnl -- try to find Lua executable
-       AC_PATH_PROG(vi_cv_path_plain_lua, lua)
-       if test "X$vi_cv_path_plain_lua" != "X"; then
- 	dnl -- find Lua version
- 	AC_CACHE_CHECK(Lua version, vi_cv_version_plain_lua,
- 	[ vi_cv_version_plain_lua=`${vi_cv_path_plain_lua} -e "print(_VERSION)" | sed 's/.* //'` ])
-       fi
-       vi_cv_path_lua="$vi_cv_path_plain_lua"
-       vi_cv_version_lua="$vi_cv_version_plain_lua"
-     fi
-     if test "x$vi_cv_with_luajit" != "xno" && test "X$vi_cv_version_luajit" != "X"; then
-       AC_MSG_CHECKING(if lua.h can be found in $vi_cv_path_lua_pfx/include/luajit-$vi_cv_version_luajit)
-       if test -f "$vi_cv_path_lua_pfx/include/luajit-$vi_cv_version_luajit/lua.h"; then
- 	AC_MSG_RESULT(yes)
- 	LUA_INC=/luajit-$vi_cv_version_luajit
-       fi
-     fi
-     if test "X$LUA_INC" = "X"; then
-       AC_MSG_CHECKING(if lua.h can be found in $vi_cv_path_lua_pfx/include)
-       if test -f "$vi_cv_path_lua_pfx/include/lua.h"; then
- 	AC_MSG_RESULT(yes)
-       else
- 	AC_MSG_RESULT(no)
- 	AC_MSG_CHECKING(if lua.h can be found in $vi_cv_path_lua_pfx/include/lua$vi_cv_version_lua)
- 	if test -f "$vi_cv_path_lua_pfx/include/lua$vi_cv_version_lua/lua.h"; then
- 	  AC_MSG_RESULT(yes)
- 	  LUA_INC=/lua$vi_cv_version_lua
- 	else
- 	  AC_MSG_RESULT(no)
- 	  vi_cv_path_lua_pfx=
- 	fi
-       fi
-     fi
-   fi
- 
-   if test "X$vi_cv_path_lua_pfx" != "X"; then
-     if test "x$vi_cv_with_luajit" != "xno"; then
-       multiarch=`dpkg-architecture -qDEB_HOST_MULTIARCH 2> /dev/null`
-       if test "X$multiarch" != "X"; then
- 	lib_multiarch="lib/${multiarch}"
-       else
- 	lib_multiarch="lib"
-       fi
-       if test "X$vi_cv_version_lua" = "X"; then
- 	LUA_LIBS="-L${vi_cv_path_lua_pfx}/${lib_multiarch} -lluajit"
-       else
- 	LUA_LIBS="-L${vi_cv_path_lua_pfx}/${lib_multiarch} -lluajit-$vi_cv_version_lua"
-       fi
-     else
-       if test "X$LUA_INC" != "X"; then
- 	dnl Test alternate location using version
- 	LUA_LIBS="-L${vi_cv_path_lua_pfx}/lib -llua$vi_cv_version_lua"
-       else
- 	LUA_LIBS="-L${vi_cv_path_lua_pfx}/lib -llua"
-       fi
-     fi
-     if test "$enable_luainterp" = "dynamic"; then
-       lua_ok="yes"
-     else
-       AC_MSG_CHECKING([if link with ${LUA_LIBS} is sane])
-       libs_save=$LIBS
-       LIBS="$LIBS $LUA_LIBS"
-       AC_TRY_LINK(,[ ],
- 	AC_MSG_RESULT(yes); lua_ok="yes",
- 	AC_MSG_RESULT(no); lua_ok="no"; LUA_LIBS="")
-       LIBS=$libs_save
-     fi
-     if test "x$lua_ok" = "xyes"; then
-       LUA_CFLAGS="-I${vi_cv_path_lua_pfx}/include${LUA_INC}"
-       LUA_SRC="if_lua.c"
-       LUA_OBJ="objects/if_lua.o"
-       LUA_PRO="if_lua.pro"
-       AC_DEFINE(FEAT_LUA)
-     fi
-     if test "$enable_luainterp" = "dynamic"; then
-       if test "x$vi_cv_with_luajit" != "xno"; then
- 	luajit="jit"
-       fi
-       if test -f "${vi_cv_path_lua_pfx}/bin/cyglua-${vi_cv_version_lua}.dll"; then
- 	vi_cv_dll_name_lua="cyglua-${vi_cv_version_lua}.dll"
-       else
- 	if test "x$MACOSX" = "xyes"; then
- 	  ext="dylib"
- 	  indexes=""
- 	else
- 	  ext="so"
- 	  indexes=".0 .1 .2 .3 .4 .5 .6 .7 .8 .9"
- 	  multiarch=`dpkg-architecture -qDEB_HOST_MULTIARCH 2> /dev/null`
- 	  if test "X$multiarch" != "X"; then
- 	    lib_multiarch="lib/${multiarch}"
- 	  fi
- 	fi
- 	dnl Determine the sover for the current version, but fallback to
- 	dnl liblua${vi_cv_version_lua}.so if no sover-versioned file is found.
- 	AC_MSG_CHECKING(if liblua${luajit}*.${ext}* can be found in $vi_cv_path_lua_pfx)
- 	for subdir in "${lib_multiarch}" lib64 lib; do
- 	  if test -z "$subdir"; then
- 	    continue
- 	  fi
- 	  for sover in "${vi_cv_version_lua}.${ext}" "-${vi_cv_version_lua}.${ext}" \
- 	    ".${vi_cv_version_lua}.${ext}" ".${ext}.${vi_cv_version_lua}"; do
- 	    for i in $indexes ""; do
- 	      if test -f "${vi_cv_path_lua_pfx}/${subdir}/liblua${luajit}${sover}$i"; then
- 		sover2="$i"
- 		break 3
- 	      fi
- 	    done
- 	  done
- 	  sover=""
- 	done
- 	if test "X$sover" = "X"; then
- 	  AC_MSG_RESULT(no)
- 	  lua_ok="no"
- 	  vi_cv_dll_name_lua="liblua${luajit}.${ext}"
- 	else
- 	  AC_MSG_RESULT(yes)
- 	  lua_ok="yes"
- 	  vi_cv_dll_name_lua="liblua${luajit}${sover}$sover2"
- 	fi
-       fi
-       AC_DEFINE(DYNAMIC_LUA)
-       LUA_LIBS=""
-       LUA_CFLAGS="-DDYNAMIC_LUA_DLL=\\\"${vi_cv_dll_name_lua}\\\" $LUA_CFLAGS"
-     fi
-     if test "X$LUA_CFLAGS$LUA_LIBS" != "X" && \
-        test "x$MACOSX" = "xyes" && test "x$vi_cv_with_luajit" != "xno" && \
-        test "`(uname -m) 2>/dev/null`" = "x86_64"; then
-       dnl OSX/x64 requires these flags. See http://luajit.org/install.html
-       LUA_LIBS="-pagezero_size 10000 -image_base 100000000 $LUA_LIBS"
-     fi
-   fi
-   if test "$fail_if_missing" = "yes" -a "$lua_ok" != "yes"; then
-     AC_MSG_ERROR([could not configure lua])
-   fi
-   AC_SUBST(LUA_SRC)
-   AC_SUBST(LUA_OBJ)
-   AC_SUBST(LUA_PRO)
-   AC_SUBST(LUA_LIBS)
-   AC_SUBST(LUA_CFLAGS)
- fi
- 
- 
- dnl Check for MzScheme feature.
- AC_MSG_CHECKING(--enable-mzschemeinterp argument)
- AC_ARG_ENABLE(mzschemeinterp,
- 	[  --enable-mzschemeinterp   Include MzScheme interpreter.], ,
- 	[enable_mzschemeinterp="no"])
- AC_MSG_RESULT($enable_mzschemeinterp)
- 
- if test "$enable_mzschemeinterp" = "yes"; then
-   dnl -- find the mzscheme executable
-   AC_SUBST(vi_cv_path_mzscheme)
- 
-   AC_MSG_CHECKING(--with-plthome argument)
-   AC_ARG_WITH(plthome,
- 	[  --with-plthome=PLTHOME   Use PLTHOME.],
- 	with_plthome="$withval"; AC_MSG_RESULT($with_plthome),
- 	with_plthome="";AC_MSG_RESULT("no"))
- 
-   if test "X$with_plthome" != "X"; then
-        vi_cv_path_mzscheme_pfx="$with_plthome"
-        vi_cv_path_mzscheme="${vi_cv_path_mzscheme_pfx}/bin/mzscheme"
-   else
-     AC_MSG_CHECKING(PLTHOME environment var)
-     if test "X$PLTHOME" != "X"; then
- 	AC_MSG_RESULT("$PLTHOME")
- 	vi_cv_path_mzscheme_pfx="$PLTHOME"
- 	vi_cv_path_mzscheme="${vi_cv_path_mzscheme_pfx}/bin/mzscheme"
-     else
- 	AC_MSG_RESULT(not set)
- 	dnl -- try to find MzScheme executable
- 	AC_PATH_PROG(vi_cv_path_mzscheme, mzscheme)
- 
- 	dnl resolve symbolic link, the executable is often elsewhere and there
- 	dnl are no links for the include files.
- 	if test "X$vi_cv_path_mzscheme" != "X"; then
- 	  lsout=`ls -l $vi_cv_path_mzscheme`
- 	  if echo "$lsout" | grep -e '->' >/dev/null 2>/dev/null; then
- 	    vi_cv_path_mzscheme=`echo "$lsout" | sed 's/.*-> \(.*\)/\1/'`
- 	  fi
- 	fi
- 
- 	if test "X$vi_cv_path_mzscheme" != "X"; then
- 	    dnl -- find where MzScheme thinks it was installed
- 	    AC_CACHE_CHECK(MzScheme install prefix,vi_cv_path_mzscheme_pfx,
- 	    dnl different versions of MzScheme differ in command line processing
- 	    dnl use universal approach
- 	    echo "(display (simplify-path		\
- 	       (build-path (call-with-values	\
- 		(lambda () (split-path (find-system-path (quote exec-file)))) \
- 		(lambda (base name must-be-dir?) base)) (quote up))))" > mzdirs.scm
- 	    dnl Remove a trailing slash
- 	    [ vi_cv_path_mzscheme_pfx=`${vi_cv_path_mzscheme} -r mzdirs.scm | \
- 		sed -e 's+/$++'` ])
- 	    rm -f mzdirs.scm
- 	fi
-     fi
-   fi
- 
-   if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
-     AC_MSG_CHECKING(for racket include directory)
-     SCHEME_INC=`${vi_cv_path_mzscheme} -e '(require setup/dirs)(let ((p (find-include-dir))) (when (path? p) (display p)))'`
-     if test "X$SCHEME_INC" != "X"; then
-       AC_MSG_RESULT(${SCHEME_INC})
-     else
-       AC_MSG_RESULT(not found)
-       AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include)
-       if test -f "$vi_cv_path_mzscheme_pfx/include/scheme.h"; then
- 	SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include
- 	AC_MSG_RESULT(yes)
-       else
- 	AC_MSG_RESULT(no)
- 	AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/plt)
- 	if test -f "$vi_cv_path_mzscheme_pfx/include/plt/scheme.h"; then
- 	  AC_MSG_RESULT(yes)
- 	  SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include/plt
- 	else
- 	  AC_MSG_RESULT(no)
- 	  AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/racket)
- 	  if test -f "$vi_cv_path_mzscheme_pfx/include/racket/scheme.h"; then
- 	    AC_MSG_RESULT(yes)
- 	    SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include/racket
- 	  else
- 	    AC_MSG_RESULT(no)
- 	    AC_MSG_CHECKING(if scheme.h can be found in /usr/include/plt/)
- 	    if test -f /usr/include/plt/scheme.h; then
- 	      AC_MSG_RESULT(yes)
- 	      SCHEME_INC=/usr/include/plt
- 	    else
- 	      AC_MSG_RESULT(no)
- 	      AC_MSG_CHECKING(if scheme.h can be found in /usr/include/racket/)
- 	      if test -f /usr/include/racket/scheme.h; then
- 		AC_MSG_RESULT(yes)
- 		SCHEME_INC=/usr/include/racket
- 	      else
- 		AC_MSG_RESULT(no)
- 		vi_cv_path_mzscheme_pfx=
- 	      fi
- 	    fi
- 	  fi
- 	fi
-       fi
-     fi
-   fi
- 
-   if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
- 
-     AC_MSG_CHECKING(for racket lib directory)
-     SCHEME_LIB=`${vi_cv_path_mzscheme} -e '(require setup/dirs)(let ((p (find-lib-dir))) (when (path? p) (display p)))'`
-     if test "X$SCHEME_LIB" != "X"; then
-       AC_MSG_RESULT(${SCHEME_LIB})
-     else
-       AC_MSG_RESULT(not found)
-     fi
- 
-     for path in "${vi_cv_path_mzscheme_pfx}/lib" "${SCHEME_LIB}"; do
-       if test "X$path" != "X"; then
- 	if test "x$MACOSX" = "xyes"; then
- 	  MZSCHEME_LIBS="-framework Racket"
- 	  MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
- 	elif test -f "${path}/libmzscheme3m.a"; then
- 	  MZSCHEME_LIBS="${path}/libmzscheme3m.a"
- 	  MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
- 	elif test -f "${path}/libracket3m.a"; then
- 	  MZSCHEME_LIBS="${path}/libracket3m.a"
- 	  MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
- 	elif test -f "${path}/libracket.a"; then
- 	  MZSCHEME_LIBS="${path}/libracket.a ${path}/libmzgc.a"
- 	elif test -f "${path}/libmzscheme.a"; then
- 	  MZSCHEME_LIBS="${path}/libmzscheme.a ${path}/libmzgc.a"
- 	else
- 	  dnl Using shared objects
- 	  if test -f "${path}/libmzscheme3m.so"; then
- 	    MZSCHEME_LIBS="-L${path} -lmzscheme3m"
- 	    MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
- 	  elif test -f "${path}/libracket3m.so"; then
- 	    MZSCHEME_LIBS="-L${path} -lracket3m"
- 	    MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
- 	  elif test -f "${path}/libracket.so"; then
- 	    MZSCHEME_LIBS="-L${path} -lracket -lmzgc"
- 	  else
- 	    dnl try next until last
- 	    if test "$path" != "$SCHEME_LIB"; then
- 	      continue
- 	    fi
- 	    MZSCHEME_LIBS="-L${path} -lmzscheme -lmzgc"
- 	  fi
- 	  if test "$GCC" = yes; then
- 	    dnl Make Vim remember the path to the library.  For when it's not in
- 	    dnl $LD_LIBRARY_PATH.
- 	    MZSCHEME_LIBS="${MZSCHEME_LIBS} -Wl,-rpath -Wl,${path}"
- 	  elif test "`(uname) 2>/dev/null`" = SunOS &&
- 				   uname -r | grep '^5' >/dev/null; then
- 	    MZSCHEME_LIBS="${MZSCHEME_LIBS} -R ${path}"
- 	  fi
- 	fi
-       fi
-       if test "X$MZSCHEME_LIBS" != "X"; then
- 	break
-       fi
-     done
- 
-     AC_MSG_CHECKING([if racket requires -pthread])
-     if test "X$SCHEME_LIB" != "X" && $FGREP -e -pthread "$SCHEME_LIB/buildinfo" >/dev/null ; then
-       AC_MSG_RESULT(yes)
-       MZSCHEME_LIBS="${MZSCHEME_LIBS} -pthread"
-       MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -pthread"
-     else
-       AC_MSG_RESULT(no)
-     fi
- 
-     AC_MSG_CHECKING(for racket config directory)
-     SCHEME_CONFIGDIR=`${vi_cv_path_mzscheme} -e '(require setup/dirs)(let ((p (find-config-dir))) (when (path? p) (display p)))'`
-     if test "X$SCHEME_CONFIGDIR" != "X"; then
-       MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -DMZSCHEME_CONFIGDIR='\"${SCHEME_CONFIGDIR}\"'"
-       AC_MSG_RESULT(${SCHEME_CONFIGDIR})
-     else
-       AC_MSG_RESULT(not found)
-     fi
- 
-     AC_MSG_CHECKING(for racket collects directory)
-     SCHEME_COLLECTS=`${vi_cv_path_mzscheme} -e '(require setup/dirs)(let ((p (find-collects-dir))) (when (path? p) (let-values (((base _1 _2) (split-path p))) (display base))))'`
-     if test "X$SCHEME_COLLECTS" = "X"; then
-       if test -d "$vi_cv_path_mzscheme_pfx/lib/plt/collects"; then
- 	SCHEME_COLLECTS=$vi_cv_path_mzscheme_pfx/lib/plt/
-       else
- 	if test -d "$vi_cv_path_mzscheme_pfx/lib/racket/collects"; then
- 	  SCHEME_COLLECTS=$vi_cv_path_mzscheme_pfx/lib/racket/
- 	else
- 	  if test -d "$vi_cv_path_mzscheme_pfx/share/racket/collects"; then
- 	    SCHEME_COLLECTS=$vi_cv_path_mzscheme_pfx/share/racket/
- 	  else
- 	    if test -d "$vi_cv_path_mzscheme_pfx/collects"; then
- 	      SCHEME_COLLECTS=$vi_cv_path_mzscheme_pfx/
- 	    fi
- 	  fi
- 	fi
-       fi
-     fi
-     if test "X$SCHEME_COLLECTS" != "X" ; then
-       AC_MSG_RESULT(${SCHEME_COLLECTS})
-     else
-       AC_MSG_RESULT(not found)
-     fi
- 
-     AC_MSG_CHECKING(for mzscheme_base.c)
-     if test -f "${SCHEME_COLLECTS}collects/scheme/base.ss" ; then
-       MZSCHEME_EXTRA="mzscheme_base.c"
-       MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/mzc"
-       MZSCHEME_MOD="++lib scheme/base"
-     else
-       if test -f "${SCHEME_COLLECTS}collects/scheme/base.rkt" ; then
- 	MZSCHEME_EXTRA="mzscheme_base.c"
- 	MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/mzc"
- 	MZSCHEME_MOD="++lib scheme/base"
-       else
- 	if test -f "${SCHEME_COLLECTS}collects/racket/base.rkt" ; then
- 	  MZSCHEME_EXTRA="mzscheme_base.c"
- 	  MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/raco ctool"
- 	  MZSCHEME_MOD=""
- 	fi
-       fi
-     fi
-     if test "X$MZSCHEME_EXTRA" != "X" ; then
-       dnl need to generate bytecode for MzScheme base
-       MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -DINCLUDE_MZSCHEME_BASE"
-       AC_MSG_RESULT(needed)
-     else
-       AC_MSG_RESULT(not needed)
-     fi
- 
-     dnl On Ubuntu this fixes "undefined reference to symbol 'ffi_type_void'".
-     AC_CHECK_LIB(ffi, ffi_type_void, [MZSCHEME_LIBS="$MZSCHEME_LIBS -lffi"])
- 
-     MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -I${SCHEME_INC} \
-       -DMZSCHEME_COLLECTS='\"${SCHEME_COLLECTS}collects\"'"
- 
-     dnl Test that we can compile a simple program with these CFLAGS and LIBS.
-     AC_MSG_CHECKING([if compile and link flags for MzScheme are sane])
-     cflags_save=$CFLAGS
-     libs_save=$LIBS
-     CFLAGS="$CFLAGS $MZSCHEME_CFLAGS"
-     LIBS="$LIBS $MZSCHEME_LIBS"
-     AC_TRY_LINK(,[ ],
- 	   AC_MSG_RESULT(yes); mzs_ok=yes,
- 	   AC_MSG_RESULT(no: MZSCHEME DISABLED); mzs_ok=no)
-     CFLAGS=$cflags_save
-     LIBS=$libs_save
-     if test $mzs_ok = yes; then
-       MZSCHEME_SRC="if_mzsch.c"
-       MZSCHEME_OBJ="objects/if_mzsch.o"
-       MZSCHEME_PRO="if_mzsch.pro"
-       AC_DEFINE(FEAT_MZSCHEME)
-     else
-       MZSCHEME_CFLAGS=
-       MZSCHEME_LIBS=
-       MZSCHEME_EXTRA=
-       MZSCHEME_MZC=
-     fi
-   fi
-   AC_SUBST(MZSCHEME_SRC)
-   AC_SUBST(MZSCHEME_OBJ)
-   AC_SUBST(MZSCHEME_PRO)
-   AC_SUBST(MZSCHEME_LIBS)
-   AC_SUBST(MZSCHEME_CFLAGS)
-   AC_SUBST(MZSCHEME_EXTRA)
-   AC_SUBST(MZSCHEME_MZC)
- fi
- 
- 
- AC_MSG_CHECKING(--enable-perlinterp argument)
- AC_ARG_ENABLE(perlinterp,
- 	[  --enable-perlinterp[=OPTS]     Include Perl interpreter.  [default=no] [OPTS=no/yes/dynamic]], ,
- 	[enable_perlinterp="no"])
- AC_MSG_RESULT($enable_perlinterp)
- if test "$enable_perlinterp" = "yes" -o "$enable_perlinterp" = "dynamic"; then
-   if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
-     AC_MSG_ERROR([cannot use Perl with tiny or small features])
-   fi
-   AC_SUBST(vi_cv_path_perl)
-   AC_PATH_PROG(vi_cv_path_perl, perl)
-   if test "X$vi_cv_path_perl" != "X"; then
-     AC_MSG_CHECKING(Perl version)
-     if $vi_cv_path_perl -e 'require 5.003_01' >/dev/null 2>/dev/null; then
-      eval `$vi_cv_path_perl -V:usethreads`
-      eval `$vi_cv_path_perl -V:libperl`
-      if test "X$usethreads" = "XUNKNOWN" -o "X$usethreads" = "Xundef"; then
-        badthreads=no
-      else
-        if $vi_cv_path_perl -e 'require 5.6.0' >/dev/null 2>/dev/null; then
- 	 eval `$vi_cv_path_perl -V:use5005threads`
- 	 if test "X$use5005threads" = "XUNKNOWN" -o "X$use5005threads" = "Xundef"; then
- 	   badthreads=no
- 	 else
- 	   badthreads=yes
- 	   AC_MSG_RESULT(>>> Perl > 5.6 with 5.5 threads cannot be used <<<)
- 	 fi
-        else
- 	 badthreads=yes
- 	 AC_MSG_RESULT(>>> Perl 5.5 with threads cannot be used <<<)
-        fi
-      fi
-      if test $badthreads = no; then
-       AC_MSG_RESULT(OK)
-       eval `$vi_cv_path_perl -V:shrpenv`
-       if test "X$shrpenv" = "XUNKNOWN"; then # pre 5.003_04
- 	shrpenv=""
-       fi
-       vi_cv_perllib=`$vi_cv_path_perl -MConfig -e 'print $Config{privlibexp}'`
-       AC_SUBST(vi_cv_perllib)
-       vi_cv_perl_extutils=unknown_perl_extutils_path
-       for extutils_rel_path in ExtUtils vendor_perl/ExtUtils; do
- 	xsubpp_path="$vi_cv_perllib/$extutils_rel_path/xsubpp"
- 	if test -f "$xsubpp_path"; then
- 	  vi_cv_perl_xsubpp="$xsubpp_path"
- 	fi
-       done
-       AC_SUBST(vi_cv_perl_xsubpp)
-       dnl Remove "-fno-something", it breaks using cproto.
-       dnl Remove "-fdebug-prefix-map", it isn't supported by clang.
-       perlcppflags=`$vi_cv_path_perl -Mlib=$srcdir -MExtUtils::Embed \
- 	      -e 'ccflags;perl_inc;print"\n"' | sed -e 's/-fno[[^ ]]*//' \
- 			-e 's/-fdebug-prefix-map[[^ ]]*//g'`
-       dnl Remove "-lc", it breaks on FreeBSD when using "-pthread".
-       perllibs=`cd $srcdir; $vi_cv_path_perl -MExtUtils::Embed -e 'ldopts' | \
- 		sed -e '/Warning/d' -e '/Note (probably harmless)/d' \
- 			-e 's/-bE:perl.exp//' -e 's/-lc //'`
-       dnl Don't add perl lib to $LIBS: if it's not in LD_LIBRARY_PATH
-       dnl a test in configure may fail because of that.
-       perlldflags=`cd $srcdir; $vi_cv_path_perl -MExtUtils::Embed \
- 		-e 'ccdlflags' | sed -e 's/-bE:perl.exp//'`
- 
-       dnl check that compiling a simple program still works with the flags
-       dnl added for Perl.
-       AC_MSG_CHECKING([if compile and link flags for Perl are sane])
-       cflags_save=$CFLAGS
-       libs_save=$LIBS
-       ldflags_save=$LDFLAGS
-       CFLAGS="$CFLAGS $perlcppflags"
-       LIBS="$LIBS $perllibs"
-       perlldflags=`echo "$perlldflags" | sed -e 's/^ *//g'`
-       LDFLAGS="$perlldflags $LDFLAGS"
-       AC_TRY_LINK(,[ ],
- 	     AC_MSG_RESULT(yes); perl_ok=yes,
- 	     AC_MSG_RESULT(no: PERL DISABLED); perl_ok=no)
-       CFLAGS=$cflags_save
-       LIBS=$libs_save
-       LDFLAGS=$ldflags_save
-       if test $perl_ok = yes; then
- 	if test "X$perlcppflags" != "X"; then
- 	  dnl remove -pipe and -Wxxx, it confuses cproto
- 	  PERL_CFLAGS=`echo "$perlcppflags" | sed -e 's/-pipe //' -e 's/-W[[^ ]]*//'`
- 	fi
- 	if test "X$perlldflags" != "X"; then
- 	  if test "X`echo \"$LDFLAGS\" | $FGREP -e \"$perlldflags\"`" = "X"; then
- 	    LDFLAGS="$perlldflags $LDFLAGS"
- 	  fi
- 	fi
- 	PERL_LIBS=$perllibs
- 	PERL_SRC="auto/if_perl.c if_perlsfio.c"
- 	PERL_OBJ="objects/if_perl.o objects/if_perlsfio.o"
- 	PERL_PRO="if_perl.pro if_perlsfio.pro"
- 	AC_DEFINE(FEAT_PERL)
-       fi
-      fi
-     else
-       AC_MSG_RESULT(>>> too old; need Perl version 5.003_01 or later <<<)
-     fi
-   fi
- 
-   if test "x$MACOSX" = "xyes"; then
-     dnl Mac OS X 10.2 or later
-     dir=/System/Library/Perl
-     darwindir=$dir/darwin
-     if test -d $darwindir; then
-       PERL=/usr/bin/perl
-     else
-       dnl Mac OS X 10.3
-       dir=/System/Library/Perl/5.8.1
-       darwindir=$dir/darwin-thread-multi-2level
-       if test -d $darwindir; then
- 	PERL=/usr/bin/perl
-       fi
-     fi
-     if test -n "$PERL"; then
-       PERL_DIR="$dir"
-       PERL_CFLAGS="-DFEAT_PERL -I$darwindir/CORE"
-       PERL_OBJ="objects/if_perl.o objects/if_perlsfio.o $darwindir/auto/DynaLoader/DynaLoader.a"
-       PERL_LIBS="-L$darwindir/CORE -lperl"
-     fi
-     dnl Perl on Mac OS X 10.5 adds "-arch" flags but these should only
-     dnl be included if requested by passing --with-mac-arch to
-     dnl configure, so strip these flags first (if present)
-     PERL_LIBS=`echo "$PERL_LIBS" | sed -e 's/-arch\ ppc//' -e 's/-arch\ i386//' -e 's/-arch\ x86_64//'`
-     PERL_CFLAGS=`echo "$PERL_CFLAGS" | sed -e 's/-arch\ ppc//' -e 's/-arch\ i386//' -e 's/-arch\ x86_64//'`
-   fi
-   if test "$enable_perlinterp" = "dynamic"; then
-     if test "$perl_ok" = "yes" -a "X$libperl" != "X"; then
-       AC_DEFINE(DYNAMIC_PERL)
-       PERL_CFLAGS="-DDYNAMIC_PERL_DLL=\\\"$libperl\\\" $PERL_CFLAGS"
-     fi
-   fi
- 
-   if test "$fail_if_missing" = "yes" -a "$perl_ok" != "yes"; then
-     AC_MSG_ERROR([could not configure perl])
-   fi
- fi
- AC_SUBST(shrpenv)
- AC_SUBST(PERL_SRC)
- AC_SUBST(PERL_OBJ)
- AC_SUBST(PERL_PRO)
- AC_SUBST(PERL_CFLAGS)
- AC_SUBST(PERL_LIBS)
- 
- AC_MSG_CHECKING(--enable-pythoninterp argument)
- AC_ARG_ENABLE(pythoninterp,
- 	[  --enable-pythoninterp[=OPTS]   Include Python interpreter. [default=no] [OPTS=no/yes/dynamic]], ,
- 	[enable_pythoninterp="no"])
- AC_MSG_RESULT($enable_pythoninterp)
- if test "$enable_pythoninterp" = "yes" -o "$enable_pythoninterp" = "dynamic"; then
-   if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
-     AC_MSG_ERROR([cannot use Python with tiny or small features])
-   fi
- 
-   dnl -- find the python executable
-   AC_PATH_PROGS(vi_cv_path_python, python2 python)
-   if test "X$vi_cv_path_python" != "X"; then
- 
-     dnl -- get its version number
-     AC_CACHE_CHECK(Python version,vi_cv_var_python_version,
-     [[vi_cv_var_python_version=`
- 	    ${vi_cv_path_python} -c 'import sys; print sys.version[:3]'`
-     ]])
- 
-     dnl -- it must be at least version 2.3
-     AC_MSG_CHECKING(Python is 2.3 or better)
-     if ${vi_cv_path_python} -c \
- 	"import sys; sys.exit(${vi_cv_var_python_version} < 2.3)"
-     then
-       AC_MSG_RESULT(yep)
- 
-       dnl -- find where python thinks it was installed
-       AC_CACHE_CHECK(Python's install prefix,vi_cv_path_python_pfx,
-       [ vi_cv_path_python_pfx=`
- 	    ${vi_cv_path_python} -c \
- 		"import sys; print sys.prefix"` ])
- 
-       dnl -- and where it thinks it runs
-       AC_CACHE_CHECK(Python's execution prefix,vi_cv_path_python_epfx,
-       [ vi_cv_path_python_epfx=`
- 	    ${vi_cv_path_python} -c \
- 		"import sys; print sys.exec_prefix"` ])
- 
-       dnl -- python's internal library path
- 
-       AC_CACHE_VAL(vi_cv_path_pythonpath,
-       [ vi_cv_path_pythonpath=`
- 	    unset PYTHONPATH;
- 	    ${vi_cv_path_python} -c \
- 		"import sys, string; print string.join(sys.path,':')"` ])
- 
-       dnl -- where the Python implementation library archives are
- 
-       AC_ARG_WITH(python-config-dir,
- 	[  --with-python-config-dir=PATH  Python's config directory],
- 	[ vi_cv_path_python_conf="${withval}" ] )
- 
-       AC_CACHE_CHECK(Python's configuration directory,vi_cv_path_python_conf,
-       [
- 	vi_cv_path_python_conf=
- 	d=`${vi_cv_path_python} -c "import distutils.sysconfig; print distutils.sysconfig.get_config_var('LIBPL')"`
- 	if test -d "$d" && test -f "$d/config.c"; then
- 	  vi_cv_path_python_conf="$d"
- 	else
- 	  for path in "${vi_cv_path_python_pfx}" "${vi_cv_path_python_epfx}"; do
- 	    for subdir in lib64 lib share; do
- 	      d="${path}/${subdir}/python${vi_cv_var_python_version}/config"
- 	      if test -d "$d" && test -f "$d/config.c"; then
- 		vi_cv_path_python_conf="$d"
- 	      fi
- 	    done
- 	  done
- 	fi
-       ])
- 
-       PYTHON_CONFDIR="${vi_cv_path_python_conf}"
- 
-       if test "X$PYTHON_CONFDIR" = "X"; then
- 	AC_MSG_RESULT([can't find it!])
-       else
- 
- 	dnl -- we need to examine Python's config/Makefile too
- 	dnl    see what the interpreter is built from
- 	AC_CACHE_VAL(vi_cv_path_python_plibs,
- 	[
- 	    pwd=`pwd`
- 	    tmp_mkf="$pwd/config-PyMake$$"
- 	    cat -- "${PYTHON_CONFDIR}/Makefile" - <<'eof' >"${tmp_mkf}"
- __:
- 	@echo "python_BASEMODLIBS='$(BASEMODLIBS)'"
- 	@echo "python_LIBS='$(LIBS)'"
- 	@echo "python_SYSLIBS='$(SYSLIBS)'"
- 	@echo "python_LINKFORSHARED='$(LINKFORSHARED)'"
- 	@echo "python_DLLLIBRARY='$(DLLLIBRARY)'"
- 	@echo "python_INSTSONAME='$(INSTSONAME)'"
- 	@echo "python_PYTHONFRAMEWORK='$(PYTHONFRAMEWORK)'"
- 	@echo "python_PYTHONFRAMEWORKPREFIX='$(PYTHONFRAMEWORKPREFIX)'"
- 	@echo "python_PYTHONFRAMEWORKINSTALLDIR='$(PYTHONFRAMEWORKINSTALLDIR)'"
- eof
- 	    dnl -- delete the lines from make about Entering/Leaving directory
- 	    eval "`cd ${PYTHON_CONFDIR} && make -f "${tmp_mkf}" __ | sed '/ directory /d'`"
- 	    rm -f -- "${tmp_mkf}"
- 	    if test "x$MACOSX" = "xyes" && test -n "${python_PYTHONFRAMEWORK}" && ${vi_cv_path_python} -c \
- 		"import sys; sys.exit(${vi_cv_var_python_version} < 2.3)"; then
- 	      vi_cv_path_python_plibs="-framework Python"
- 	      if test "x${vi_cv_path_python}" != "x/usr/bin/python" && test -n "${python_PYTHONFRAMEWORKPREFIX}"; then
- 		  vi_cv_path_python_plibs="-F${python_PYTHONFRAMEWORKPREFIX} -framework Python"
- 	      fi
- 	    else
- 	      if test "${vi_cv_var_python_version}" = "1.4"; then
- 		  vi_cv_path_python_plibs="${PYTHON_CONFDIR}/libModules.a ${PYTHON_CONFDIR}/libPython.a ${PYTHON_CONFDIR}/libObjects.a ${PYTHON_CONFDIR}/libParser.a"
- 	      else
- 		  vi_cv_path_python_plibs="-L${PYTHON_CONFDIR} -lpython${vi_cv_var_python_version}"
- 	      fi
- 	      dnl -- Check if the path contained in python_LINKFORSHARED is
- 	      dnl    usable for vim build. If not, make and try other
- 	      dnl    candidates.
- 	      if test -n "${python_LINKFORSHARED}" && test -n "${python_PYTHONFRAMEWORKPREFIX}"; then
- 	        python_link_symbol=`echo ${python_LINKFORSHARED} | sed 's/\([[^ \t]][[^ \t]]*[[ \t]][[ \t]]*[[^ \t]][[^ \t]]*\)[[ \t]].*/\1/'`
- 		python_link_path=`echo ${python_LINKFORSHARED} |   sed 's/\([[^ \t]][[^ \t]]*[[ \t]][[ \t]]*[[^ \t]][[^ \t]]*\)[[ \t]][[ \t]]*\(.*\)/\2/'`
- 	        if test -n "${python_link_path}" && ! test -x "${python_link_path}"; then
- 	          dnl -- The path looks relative. Guess the absolute one using
- 		  dnl    the prefix and try that.
- 	          python_link_path="${python_PYTHONFRAMEWORKPREFIX}/${python_link_path}"
- 		  if test -n "${python_link_path}" && ! test -x "${python_link_path}"; then
- 		    dnl -- A last resort.
- 		    python_link_path="${python_PYTHONFRAMEWORKINSTALLDIR}/Versions/${vi_cv_var_python_version}/${python_PYTHONFRAMEWORK}"
- 	            dnl -- No check is done. The last word is left to the
- 	            dnl    "sanity" test on link flags that follows shortly.
- 		  fi
- 	          python_LINKFORSHARED="${python_link_symbol} ${python_link_path}"
- 	        fi
- 	      fi
- 	      vi_cv_path_python_plibs="${vi_cv_path_python_plibs} ${python_BASEMODLIBS} ${python_LIBS} ${python_SYSLIBS} ${python_LINKFORSHARED}"
- 	      dnl remove -ltermcap, it can conflict with an earlier -lncurses
- 	      vi_cv_path_python_plibs=`echo $vi_cv_path_python_plibs | sed s/-ltermcap//`
- 	    fi
- 	])
- 	AC_CACHE_CHECK(Python's dll name,vi_cv_dll_name_python,
- 	[
- 	  if test "X$python_DLLLIBRARY" != "X"; then
- 	    vi_cv_dll_name_python="$python_DLLLIBRARY"
- 	  else
- 	    vi_cv_dll_name_python="$python_INSTSONAME"
- 	  fi
- 	])
- 
- 	PYTHON_LIBS="${vi_cv_path_python_plibs}"
- 	if test "${vi_cv_path_python_pfx}" = "${vi_cv_path_python_epfx}"; then
- 	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version} -DPYTHON_HOME='\"${vi_cv_path_python_pfx}\"'"
- 	else
- 	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version} -I${vi_cv_path_python_epfx}/include/python${vi_cv_var_python_version} -DPYTHON_HOME='\"${vi_cv_path_python_pfx}\"'"
- 	fi
- 	PYTHON_SRC="if_python.c"
- 	PYTHON_OBJ="objects/if_python.o"
- 	if test "${vi_cv_var_python_version}" = "1.4"; then
- 	   PYTHON_OBJ="$PYTHON_OBJ objects/py_getpath.o"
- 	fi
-     PYTHON_GETPATH_CFLAGS="-DPYTHONPATH='\"${vi_cv_path_pythonpath}\"' -DPREFIX='\"${vi_cv_path_python_pfx}\"' -DEXEC_PREFIX='\"${vi_cv_path_python_epfx}\"'"
- 
- 	dnl On FreeBSD linking with "-pthread" is required to use threads.
- 	dnl _THREAD_SAFE must be used for compiling then.
- 	dnl The "-pthread" is added to $LIBS, so that the following check for
- 	dnl sigaltstack() will look in libc_r (it's there in libc!).
- 	dnl Otherwise, when using GCC, try adding -pthread to $CFLAGS.  GCC
- 	dnl will then define target-specific defines, e.g., -D_REENTRANT.
- 	dnl Don't do this for Mac OSX, -pthread will generate a warning.
- 	AC_MSG_CHECKING([if -pthread should be used])
- 	threadsafe_flag=
- 	thread_lib=
- 	dnl if test "x$MACOSX" != "xyes"; then
-         if test "`(uname) 2>/dev/null`" != Darwin; then
- 	  test "$GCC" = yes && threadsafe_flag="-pthread"
- 	  if test "`(uname) 2>/dev/null`" = FreeBSD; then
- 	    threadsafe_flag="-D_THREAD_SAFE"
- 	    thread_lib="-pthread"
- 	  fi
- 	  if test "`(uname) 2>/dev/null`" = SunOS; then
- 	    threadsafe_flag="-pthreads"
- 	  fi
- 	fi
- 	libs_save_old=$LIBS
- 	if test -n "$threadsafe_flag"; then
- 	  cflags_save=$CFLAGS
- 	  CFLAGS="$CFLAGS $threadsafe_flag"
- 	  LIBS="$LIBS $thread_lib"
- 	  AC_TRY_LINK(,[ ],
- 	     AC_MSG_RESULT(yes); PYTHON_CFLAGS="$PYTHON_CFLAGS $threadsafe_flag",
- 	     AC_MSG_RESULT(no); LIBS=$libs_save_old
- 	     )
- 	  CFLAGS=$cflags_save
- 	else
- 	  AC_MSG_RESULT(no)
- 	fi
- 
- 	dnl Check that compiling a simple program still works with the flags
- 	dnl added for Python.
- 	AC_MSG_CHECKING([if compile and link flags for Python are sane])
- 	cflags_save=$CFLAGS
- 	libs_save=$LIBS
- 	CFLAGS="$CFLAGS $PYTHON_CFLAGS"
- 	LIBS="$LIBS $PYTHON_LIBS"
- 	AC_TRY_LINK(,[ ],
- 	       AC_MSG_RESULT(yes); python_ok=yes,
- 	       AC_MSG_RESULT(no: PYTHON DISABLED); python_ok=no)
- 	CFLAGS=$cflags_save
- 	LIBS=$libs_save
- 	if test $python_ok = yes; then
- 	  AC_DEFINE(FEAT_PYTHON)
- 	else
- 	  LIBS=$libs_save_old
- 	  PYTHON_SRC=
- 	  PYTHON_OBJ=
- 	  PYTHON_LIBS=
- 	  PYTHON_CFLAGS=
- 	fi
-       fi
-     else
-       AC_MSG_RESULT(too old)
-     fi
-   fi
- 
-   if test "$fail_if_missing" = "yes" -a "$python_ok" != "yes"; then
-     AC_MSG_ERROR([could not configure python])
-   fi
- fi
- 
- AC_SUBST(PYTHON_CONFDIR)
- AC_SUBST(PYTHON_LIBS)
- AC_SUBST(PYTHON_GETPATH_CFLAGS)
- AC_SUBST(PYTHON_CFLAGS)
- AC_SUBST(PYTHON_SRC)
- AC_SUBST(PYTHON_OBJ)
- 
- 
- AC_MSG_CHECKING(--enable-python3interp argument)
- AC_ARG_ENABLE(python3interp,
- 	[  --enable-python3interp[=OPTS]   Include Python3 interpreter. [default=no] [OPTS=no/yes/dynamic]], ,
- 	[enable_python3interp="no"])
- AC_MSG_RESULT($enable_python3interp)
- if test "$enable_python3interp" = "yes" -o "$enable_python3interp" = "dynamic"; then
-   if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
-     AC_MSG_ERROR([cannot use Python with tiny or small features])
-   fi
- 
-   dnl -- find the python3 executable
-   AC_PATH_PROGS(vi_cv_path_python3, python3 python)
-   if test "X$vi_cv_path_python3" != "X"; then
- 
-     dnl -- get its version number
-     AC_CACHE_CHECK(Python version,vi_cv_var_python3_version,
-     [[vi_cv_var_python3_version=`
-           ${vi_cv_path_python3} -c 'import sys; print(sys.version[:3])'`
-     ]])
- 
-     dnl -- it must be at least version 3
-     AC_MSG_CHECKING(Python is 3.0 or better)
-     if ${vi_cv_path_python3} -c \
-       "import sys; sys.exit(${vi_cv_var_python3_version} < 3.0)"
-     then
-       AC_MSG_RESULT(yep)
- 
-       dnl -- get abiflags for python 3.2 or higher (PEP 3149)
-       AC_CACHE_CHECK(Python's abiflags,vi_cv_var_python3_abiflags,
-       [
-        vi_cv_var_python3_abiflags=
-        if ${vi_cv_path_python3} -c \
-            "import sys; sys.exit(${vi_cv_var_python3_version} < 3.2)"
-        then
-          vi_cv_var_python3_abiflags=`${vi_cv_path_python3} -c \    
-            "import sys; print(sys.abiflags)"`
-        fi ])
-   
-       dnl -- find where python3 thinks it was installed
-       AC_CACHE_CHECK(Python's install prefix,vi_cv_path_python3_pfx,
-       [ vi_cv_path_python3_pfx=`
-        ${vi_cv_path_python3} -c \
-        "import sys; print(sys.prefix)"` ])
-   
-       dnl -- and where it thinks it runs
-       AC_CACHE_CHECK(Python's execution prefix,vi_cv_path_python3_epfx,
-       [ vi_cv_path_python3_epfx=`
-        ${vi_cv_path_python3} -c \
-        "import sys; print(sys.exec_prefix)"` ])
-   
-       dnl -- python3's internal library path
-   
-       AC_CACHE_VAL(vi_cv_path_python3path,
-       [ vi_cv_path_python3path=`
-        unset PYTHONPATH;
-        ${vi_cv_path_python3} -c \
-        "import sys, string; print(':'.join(sys.path))"` ])
-   
-       dnl -- where the Python implementation library archives are
-   
-       AC_ARG_WITH(python3-config-dir,
-        [  --with-python3-config-dir=PATH  Python's config directory],
-        [ vi_cv_path_python3_conf="${withval}" ] )
-   
-       AC_CACHE_CHECK(Python's configuration directory,vi_cv_path_python3_conf,
-       [
-        vi_cv_path_python3_conf=
-        config_dir="config-${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags}"
-        d=`${vi_cv_path_python3} -c "import distutils.sysconfig; print(distutils.sysconfig.get_config_var('LIBPL'))"`
-        if test -d "$d" && test -f "$d/config.c"; then
-          vi_cv_path_python3_conf="$d"
-        else
-          for path in "${vi_cv_path_python3_pfx}" "${vi_cv_path_python3_epfx}"; do
- 	   for subdir in lib64 lib share; do
- 	     d="${path}/${subdir}/python${vi_cv_var_python3_version}/${config_dir}"
- 	     if test -d "$d" && test -f "$d/config.c"; then
- 	       vi_cv_path_python3_conf="$d"
- 	     fi
- 	   done
-          done
-        fi
-       ])
-   
-       PYTHON3_CONFDIR="${vi_cv_path_python3_conf}"
-   
-       if test "X$PYTHON3_CONFDIR" = "X"; then
-         AC_MSG_RESULT([can't find it!])
-       else
-   
-         dnl -- we need to examine Python's config/Makefile too
-         dnl    see what the interpreter is built from
-         AC_CACHE_VAL(vi_cv_path_python3_plibs,
-         [
-             pwd=`pwd`
-             tmp_mkf="$pwd/config-PyMake$$"
-             cat -- "${PYTHON3_CONFDIR}/Makefile" - <<'eof' >"${tmp_mkf}"
- __:
- 	@echo "python3_BASEMODLIBS='$(BASEMODLIBS)'"
- 	@echo "python3_LIBS='$(LIBS)'"
- 	@echo "python3_SYSLIBS='$(SYSLIBS)'"
- 	@echo "python3_DLLLIBRARY='$(DLLLIBRARY)'"
- 	@echo "python3_INSTSONAME='$(INSTSONAME)'"
- eof
- 	    dnl -- delete the lines from make about Entering/Leaving directory
- 	    eval "`cd ${PYTHON3_CONFDIR} && make -f "${tmp_mkf}" __ | sed '/ directory /d'`"
- 	    rm -f -- "${tmp_mkf}"
- 	    vi_cv_path_python3_plibs="-L${PYTHON3_CONFDIR} -lpython${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags}"
- 	    vi_cv_path_python3_plibs="${vi_cv_path_python3_plibs} ${python3_BASEMODLIBS} ${python3_LIBS} ${python3_SYSLIBS}"
- 	    dnl remove -ltermcap, it can conflict with an earlier -lncurses
- 	    vi_cv_path_python3_plibs=`echo $vi_cv_path_python3_plibs | sed s/-ltermcap//`
- 	    vi_cv_path_python3_plibs=`echo $vi_cv_path_python3_plibs | sed s/-lffi//`
- 	])
- 	AC_CACHE_CHECK(Python3's dll name,vi_cv_dll_name_python3,
- 	[
- 	  if test "X$python3_DLLLIBRARY" != "X"; then
- 	    vi_cv_dll_name_python3="$python3_DLLLIBRARY"
- 	  else
- 	    vi_cv_dll_name_python3="$python3_INSTSONAME"
- 	  fi
- 	])
- 
-         PYTHON3_LIBS="${vi_cv_path_python3_plibs}"
-         if test "${vi_cv_path_python3_pfx}" = "${vi_cv_path_python3_epfx}"; then
-           PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags} -DPYTHON3_HOME='L\"${vi_cv_path_python3_pfx}\"'"
-         else
-           PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags} -I${vi_cv_path_python3_epfx}/include/python${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags} -DPYTHON3_HOME='L\"${vi_cv_path_python3_pfx}\"'"
-         fi
-         PYTHON3_SRC="if_python3.c"
-         PYTHON3_OBJ="objects/if_python3.o"
-   
-         dnl On FreeBSD linking with "-pthread" is required to use threads.
-         dnl _THREAD_SAFE must be used for compiling then.
-         dnl The "-pthread" is added to $LIBS, so that the following check for
-         dnl sigaltstack() will look in libc_r (it's there in libc!).
-         dnl Otherwise, when using GCC, try adding -pthread to $CFLAGS.  GCC
-         dnl will then define target-specific defines, e.g., -D_REENTRANT.
-         dnl Don't do this for Mac OSX, -pthread will generate a warning.
-         AC_MSG_CHECKING([if -pthread should be used])
-         threadsafe_flag=
-         thread_lib=
-         dnl if test "x$MACOSX" != "xyes"; then
-         if test "`(uname) 2>/dev/null`" != Darwin; then
-           test "$GCC" = yes && threadsafe_flag="-pthread"
-           if test "`(uname) 2>/dev/null`" = FreeBSD; then
-             threadsafe_flag="-D_THREAD_SAFE"
-             thread_lib="-pthread"
-           fi
-           if test "`(uname) 2>/dev/null`" = SunOS; then
-             threadsafe_flag="-pthreads"
-           fi
-         fi
-         libs_save_old=$LIBS
-         if test -n "$threadsafe_flag"; then
-           cflags_save=$CFLAGS
-           CFLAGS="$CFLAGS $threadsafe_flag"
-           LIBS="$LIBS $thread_lib"
-           AC_TRY_LINK(,[ ],
-              AC_MSG_RESULT(yes); PYTHON3_CFLAGS="$PYTHON3_CFLAGS $threadsafe_flag",
-              AC_MSG_RESULT(no); LIBS=$libs_save_old
-              )
-           CFLAGS=$cflags_save
-         else
-           AC_MSG_RESULT(no)
-         fi
-   
-         dnl check that compiling a simple program still works with the flags
-         dnl added for Python.
-         AC_MSG_CHECKING([if compile and link flags for Python 3 are sane])
-         cflags_save=$CFLAGS
-         libs_save=$LIBS
-         CFLAGS="$CFLAGS $PYTHON3_CFLAGS"
-         LIBS="$LIBS $PYTHON3_LIBS"
-         AC_TRY_LINK(,[ ],
-                AC_MSG_RESULT(yes); python3_ok=yes,
-                AC_MSG_RESULT(no: PYTHON3 DISABLED); python3_ok=no)
-         CFLAGS=$cflags_save
-         LIBS=$libs_save
-         if test "$python3_ok" = yes; then
-           AC_DEFINE(FEAT_PYTHON3)
-         else
-           LIBS=$libs_save_old
-           PYTHON3_SRC=
-           PYTHON3_OBJ=
-           PYTHON3_LIBS=
-           PYTHON3_CFLAGS=
-         fi
-       fi
-     else
-       AC_MSG_RESULT(too old)
-     fi
-   fi
-   if test "$fail_if_missing" = "yes" -a "$python3_ok" != "yes"; then
-     AC_MSG_ERROR([could not configure python3])
-   fi
- fi
- 
- AC_SUBST(PYTHON3_CONFDIR)
- AC_SUBST(PYTHON3_LIBS)
- AC_SUBST(PYTHON3_CFLAGS)
- AC_SUBST(PYTHON3_SRC)
- AC_SUBST(PYTHON3_OBJ)
- 
- dnl if python2.x and python3.x are enabled one can only link in code
- dnl with dlopen(), dlsym(), dlclose() 
- if test "$python_ok" = yes && test "$python3_ok" = yes; then
-   AC_DEFINE(DYNAMIC_PYTHON)
-   AC_DEFINE(DYNAMIC_PYTHON3)
-   AC_MSG_CHECKING(whether we can do without RTLD_GLOBAL for Python)
-   cflags_save=$CFLAGS
-   CFLAGS="$CFLAGS $PYTHON_CFLAGS"
-   libs_save=$LIBS
-   dnl -ldl must go first to make this work on Archlinux (Roland Puntaier)
-   LIBS="-ldl $LIBS"
-   AC_RUN_IFELSE([AC_LANG_SOURCE([
-     #include <dlfcn.h>
-     /* If this program fails, then RTLD_GLOBAL is needed.
-      * RTLD_GLOBAL will be used and then it is not possible to
-      * have both python versions enabled in the same vim instance.
-      * Only the first python version used will be switched on.
-      */
- 
-     int no_rtl_global_needed_for(char *python_instsoname, char *prefix)
-     {
-       int needed = 0;
-       void* pylib = dlopen(python_instsoname, RTLD_LAZY|RTLD_LOCAL);
-       if (pylib != 0)
-       {
-           void (*pfx)(char *home) = dlsym(pylib, "Py_SetPythonHome");
-           void (*init)(void) = dlsym(pylib, "Py_Initialize");
-           int (*simple)(char*) = dlsym(pylib, "PyRun_SimpleString");
-           void (*final)(void) = dlsym(pylib, "Py_Finalize");
-           (*pfx)(prefix);
-           (*init)();
-           needed = (*simple)("import termios") == -1;
-           (*final)();
-           dlclose(pylib);
-       }
-       return !needed;
-     }
- 
-     int main(int argc, char** argv)
-     {
-       int not_needed = 0;
-       if (no_rtl_global_needed_for("${vi_cv_dll_name_python}", "${vi_cv_path_python_pfx}"))
-             not_needed = 1;
-       return !not_needed;
-     }])],
-     [AC_MSG_RESULT(yes);AC_DEFINE(PY_NO_RTLD_GLOBAL)], [AC_MSG_RESULT(no)])
- 
-   CFLAGS=$cflags_save
-   LIBS=$libs_save
- 
-   AC_MSG_CHECKING(whether we can do without RTLD_GLOBAL for Python3)
-   cflags_save=$CFLAGS
-   CFLAGS="$CFLAGS $PYTHON3_CFLAGS"
-   libs_save=$LIBS
-   dnl -ldl must go first to make this work on Archlinux (Roland Puntaier)
-   LIBS="-ldl $LIBS"
-   AC_RUN_IFELSE([AC_LANG_SOURCE([
-     #include <dlfcn.h>
-     #include <wchar.h>
-     /* If this program fails, then RTLD_GLOBAL is needed.
-      * RTLD_GLOBAL will be used and then it is not possible to
-      * have both python versions enabled in the same vim instance.
-      * Only the first python version used will be switched on.
-      */
- 
-     int no_rtl_global_needed_for(char *python_instsoname, wchar_t *prefix)
-     {
-       int needed = 0;
-       void* pylib = dlopen(python_instsoname, RTLD_LAZY|RTLD_LOCAL);
-       if (pylib != 0)
-       {
-           void (*pfx)(wchar_t *home) = dlsym(pylib, "Py_SetPythonHome");
-           void (*init)(void) = dlsym(pylib, "Py_Initialize");
-           int (*simple)(char*) = dlsym(pylib, "PyRun_SimpleString");
-           void (*final)(void) = dlsym(pylib, "Py_Finalize");
-           (*pfx)(prefix);
-           (*init)();
-           needed = (*simple)("import termios") == -1;
-           (*final)();
-           dlclose(pylib);
-       }
-       return !needed;
-     }
- 
-     int main(int argc, char** argv)
-     {
-       int not_needed = 0;
-       if (no_rtl_global_needed_for("${vi_cv_dll_name_python3}", L"${vi_cv_path_python3_pfx}"))
-             not_needed = 1;
-       return !not_needed;
-     }])],
-     [AC_MSG_RESULT(yes);AC_DEFINE(PY3_NO_RTLD_GLOBAL)], [AC_MSG_RESULT(no)])
- 
-   CFLAGS=$cflags_save
-   LIBS=$libs_save
- 
-   PYTHON_SRC="if_python.c"
-   PYTHON_OBJ="objects/if_python.o"
-   PYTHON_CFLAGS="$PYTHON_CFLAGS -DDYNAMIC_PYTHON_DLL=\\\"${vi_cv_dll_name_python}\\\""
-   PYTHON_LIBS=
-   PYTHON3_SRC="if_python3.c"
-   PYTHON3_OBJ="objects/if_python3.o"
-   PYTHON3_CFLAGS="$PYTHON3_CFLAGS -DDYNAMIC_PYTHON3_DLL=\\\"${vi_cv_dll_name_python3}\\\""
-   PYTHON3_LIBS=
- elif test "$python_ok" = yes && test "$enable_pythoninterp" = "dynamic"; then
-   AC_DEFINE(DYNAMIC_PYTHON)
-   PYTHON_SRC="if_python.c"
-   PYTHON_OBJ="objects/if_python.o"
-   PYTHON_CFLAGS="$PYTHON_CFLAGS -DDYNAMIC_PYTHON_DLL=\\\"${vi_cv_dll_name_python}\\\""
-   PYTHON_LIBS=
- elif test "$python_ok" = yes; then
-   dnl Check that adding -fPIE works.  It may be needed when using a static
-   dnl Python library.
-   AC_MSG_CHECKING([if -fPIE can be added for Python])
-   cflags_save=$CFLAGS
-   libs_save=$LIBS
-   CFLAGS="$CFLAGS $PYTHON_CFLAGS -fPIE"
-   LIBS="$LIBS $PYTHON_LIBS"
-   AC_TRY_LINK(,[ ],
- 	 AC_MSG_RESULT(yes); fpie_ok=yes,
- 	 AC_MSG_RESULT(no); fpie_ok=no)
-   CFLAGS=$cflags_save
-   LIBS=$libs_save
-   if test $fpie_ok = yes; then
-     PYTHON_CFLAGS="$PYTHON_CFLAGS -fPIE"
-   fi
- elif test "$python3_ok" = yes && test "$enable_python3interp" = "dynamic"; then
-   AC_DEFINE(DYNAMIC_PYTHON3)
-   PYTHON3_SRC="if_python3.c"
-   PYTHON3_OBJ="objects/if_python3.o"
-   PYTHON3_CFLAGS="$PYTHON3_CFLAGS -DDYNAMIC_PYTHON3_DLL=\\\"${vi_cv_dll_name_python3}\\\""
-   PYTHON3_LIBS=
- elif test "$python3_ok" = yes; then
-   dnl Check that adding -fPIE works.  It may be needed when using a static
-   dnl Python library.
-   AC_MSG_CHECKING([if -fPIE can be added for Python3])
-   cflags_save=$CFLAGS
-   libs_save=$LIBS
-   CFLAGS="$CFLAGS $PYTHON3_CFLAGS -fPIE"
-   LIBS="$LIBS $PYTHON3_LIBS"
-   AC_TRY_LINK(,[ ],
- 	 AC_MSG_RESULT(yes); fpie_ok=yes,
- 	 AC_MSG_RESULT(no); fpie_ok=no)
-   CFLAGS=$cflags_save
-   LIBS=$libs_save
-   if test $fpie_ok = yes; then
-     PYTHON3_CFLAGS="$PYTHON3_CFLAGS -fPIE"
-   fi
- fi
- 
- AC_MSG_CHECKING(--enable-tclinterp argument)
- AC_ARG_ENABLE(tclinterp,
- 	[  --enable-tclinterp[=OPTS]      Include Tcl interpreter. [default=no] [OPTS=no/yes/dynamic]], ,
- 	[enable_tclinterp="no"])
- AC_MSG_RESULT($enable_tclinterp)
- 
- if test "$enable_tclinterp" = "yes" -o "$enable_tclinterp" = "dynamic"; then
- 
-   dnl on FreeBSD tclsh is a silly script, look for tclsh8.[5420]
-   AC_MSG_CHECKING(--with-tclsh argument)
-   AC_ARG_WITH(tclsh, [  --with-tclsh=PATH       which tclsh to use (default: tclsh8.0)],
- 	tclsh_name="$withval"; AC_MSG_RESULT($tclsh_name),
- 	tclsh_name="tclsh8.5"; AC_MSG_RESULT(no))
-   AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)
-   AC_SUBST(vi_cv_path_tcl)
- 
-   dnl when no specific version specified, also try 8.4, 8.2 and 8.0
-   if test "X$vi_cv_path_tcl" = "X" -a $tclsh_name = "tclsh8.5"; then
-     tclsh_name="tclsh8.4"
-     AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)
-   fi
-   if test "X$vi_cv_path_tcl" = "X" -a $tclsh_name = "tclsh8.4"; then
-     tclsh_name="tclsh8.2"
-     AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)
-   fi
-   if test "X$vi_cv_path_tcl" = "X" -a $tclsh_name = "tclsh8.2"; then
-     tclsh_name="tclsh8.0"
-     AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)
-   fi
-   dnl still didn't find it, try without version number
-   if test "X$vi_cv_path_tcl" = "X"; then
-     tclsh_name="tclsh"
-     AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)
-   fi
-   if test "X$vi_cv_path_tcl" != "X"; then
-     AC_MSG_CHECKING(Tcl version)
-     if echo 'exit [[expr [info tclversion] < 8.0]]' | "$vi_cv_path_tcl" - ; then
-       tclver=`echo 'puts [[info tclversion]]' | $vi_cv_path_tcl -`
-       AC_MSG_RESULT($tclver - OK);
-       tclloc=`echo 'set l [[info library]];set i [[string last lib $l]];incr i -2;puts [[string range $l 0 $i]]' | $vi_cv_path_tcl -`
-       tcldll=`echo 'puts libtcl[[info tclversion]][[info sharedlibextension]]' | $vi_cv_path_tcl -`
- 
-       AC_MSG_CHECKING(for location of Tcl include)
-       if test "x$MACOSX" != "xyes"; then
- 	tclinc="$tclloc/include $tclloc/include/tcl $tclloc/include/tcl$tclver /usr/local/include /usr/local/include/tcl$tclver /usr/include /usr/include/tcl$tclver"
-       else
- 	dnl For Mac OS X 10.3, use the OS-provided framework location
- 	tclinc="/System/Library/Frameworks/Tcl.framework/Headers"
-       fi
-       TCL_INC=
-       for try in $tclinc; do
- 	if test -f "$try/tcl.h"; then
- 	  AC_MSG_RESULT($try/tcl.h)
- 	  TCL_INC=$try
- 	  break
- 	fi
-       done
-       if test -z "$TCL_INC"; then
- 	AC_MSG_RESULT(<not found>)
- 	SKIP_TCL=YES
-       fi
-       if test -z "$SKIP_TCL"; then
- 	AC_MSG_CHECKING(for location of tclConfig.sh script)
- 	if test "x$MACOSX" != "xyes"; then
- 	  tclcnf=`echo $tclinc | sed s/include/lib/g`
- 	  tclcnf="$tclcnf `echo $tclinc | sed s/include/lib64/g`"
- 	else
- 	  dnl For Mac OS X 10.3, use the OS-provided framework location
- 	  tclcnf="/System/Library/Frameworks/Tcl.framework"
- 	fi
- 	for try in $tclcnf; do
- 	  if test -f "$try/tclConfig.sh"; then
- 	    AC_MSG_RESULT($try/tclConfig.sh)
- 	    . "$try/tclConfig.sh"
- 	    dnl use eval, because tcl 8.2 includes ${TCL_DBGX}
- 	    if test "$enable_tclinterp" = "dynamic"; then
- 	      TCL_LIBS=`eval echo "$TCL_STUB_LIB_SPEC $TCL_LIBS"`
- 	    else
- 	      TCL_LIBS=`eval echo "$TCL_LIB_SPEC $TCL_LIBS"`
- 	    fi
- 	    dnl Use $TCL_DEFS for -D_THREAD_SAFE et al.  But only use the
- 	    dnl "-D_ABC" items.  Watch out for -DFOO=long\ long.
- 	    TCL_DEFS=`echo $TCL_DEFS | sed -e 's/\\\\ /\\\\X/g' | tr ' ' '\012' | sed -e '/^[[^-]]/d' -e '/^-[[^D]]/d' -e '/-D[[^_]]/d' -e 's/-D_/ -D_/' | tr '\012' ' ' | sed -e 's/\\\\X/\\\\ /g'`
- 	    break
- 	  fi
- 	done
- 	if test -z "$TCL_LIBS"; then
- 	  AC_MSG_RESULT(<not found>)
- 	  AC_MSG_CHECKING(for Tcl library by myself)
- 	  tcllib=`echo $tclinc | sed s/include/lib/g`
- 	  tcllib="$tcllib `echo $tclinc | sed s/include/lib64/g`"
- 	  for ext in .so .a ; do
- 	    for ver in "" $tclver ; do
- 	      for try in $tcllib ; do
- 		trylib=tcl$ver$ext
- 		if test -f "$try/lib$trylib" ; then
- 		  AC_MSG_RESULT($try/lib$trylib)
- 		  TCL_LIBS="-L\"$try\" -ltcl$ver -ldl -lm"
- 		  if test "`(uname) 2>/dev/null`" = SunOS &&
- 					 uname -r | grep '^5' >/dev/null; then
- 		    TCL_LIBS="$TCL_LIBS -R $try"
- 		  fi
- 		  break 3
- 		fi
- 	      done
- 	    done
- 	  done
- 	  if test -z "$TCL_LIBS"; then
- 	    AC_MSG_RESULT(<not found>)
- 	    SKIP_TCL=YES
- 	  fi
- 	fi
- 	if test -z "$SKIP_TCL"; then
- 	  AC_DEFINE(FEAT_TCL)
- 	  TCL_SRC=if_tcl.c
- 	  TCL_OBJ=objects/if_tcl.o
- 	  TCL_PRO=if_tcl.pro
- 	  TCL_CFLAGS="-I$TCL_INC $TCL_DEFS"
- 	fi
-       fi
-     else
-       AC_MSG_RESULT(too old; need Tcl version 8.0 or later)
-     fi
-   fi
-   if test "$enable_tclinterp" = "dynamic"; then
-     if test "X$TCL_SRC" != "X" -a "X$tcldll" != "X"; then
-       AC_DEFINE(DYNAMIC_TCL)
-       TCL_CFLAGS="-DDYNAMIC_TCL_DLL=\\\"$tcldll\\\" -DDYNAMIC_TCL_VER=\\\"$tclver\\\" $TCL_CFLAGS"
-     fi
-   fi
-   if test "$fail_if_missing" = "yes" -a -z "$TCL_SRC"; then
-     AC_MSG_ERROR([could not configure Tcl])
-   fi
- fi
- AC_SUBST(TCL_SRC)
- AC_SUBST(TCL_OBJ)
- AC_SUBST(TCL_PRO)
- AC_SUBST(TCL_CFLAGS)
- AC_SUBST(TCL_LIBS)
- 
- AC_MSG_CHECKING(--enable-rubyinterp argument)
- AC_ARG_ENABLE(rubyinterp,
- 	[  --enable-rubyinterp[=OPTS]     Include Ruby interpreter.  [default=no] [OPTS=no/yes/dynamic]], ,
- 	[enable_rubyinterp="no"])
- AC_MSG_RESULT($enable_rubyinterp)
- if test "$enable_rubyinterp" = "yes" -o "$enable_rubyinterp" = "dynamic"; then
-   if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
-     AC_MSG_ERROR([cannot use Ruby with tiny or small features])
-   fi
- 
-   AC_MSG_CHECKING(--with-ruby-command argument)
-   AC_SUBST(vi_cv_path_ruby)
-   AC_ARG_WITH(ruby-command, [  --with-ruby-command=RUBY  name of the Ruby command (default: ruby)],
- 	RUBY_CMD="$withval"; vi_cv_path_ruby="$withval"; AC_MSG_RESULT($RUBY_CMD),
- 	RUBY_CMD="ruby"; AC_MSG_RESULT(defaulting to $RUBY_CMD))
-   AC_PATH_PROG(vi_cv_path_ruby, $RUBY_CMD)
-   if test "X$vi_cv_path_ruby" != "X"; then
-     AC_MSG_CHECKING(Ruby version)
-     if $vi_cv_path_ruby -e '(VERSION rescue RUBY_VERSION) >= "1.6.0" or exit 1' >/dev/null 2>/dev/null; then
-       AC_MSG_RESULT(OK)
-       AC_MSG_CHECKING(Ruby rbconfig)
-       ruby_rbconfig="RbConfig"
-       if ! $vi_cv_path_ruby -r rbconfig -e 'RbConfig' >/dev/null 2>/dev/null; then
- 	ruby_rbconfig="Config"
-       fi
-       AC_MSG_RESULT($ruby_rbconfig)
-       AC_MSG_CHECKING(Ruby header files)
-       rubyhdrdir=`$vi_cv_path_ruby -r mkmf -e "print $ruby_rbconfig::CONFIG[['rubyhdrdir']] || $ruby_rbconfig::CONFIG[['archdir']] || \\$hdrdir" 2>/dev/null`
-       if test "X$rubyhdrdir" != "X"; then
- 	AC_MSG_RESULT($rubyhdrdir)
- 	RUBY_CFLAGS="-I$rubyhdrdir"
-         rubyarchdir=`$vi_cv_path_ruby -r rbconfig -e "print ($ruby_rbconfig::CONFIG.has_key? 'rubyarchhdrdir') ? $ruby_rbconfig::CONFIG[['rubyarchhdrdir']] : '$rubyhdrdir/'+$ruby_rbconfig::CONFIG[['arch']]"`
-         if test -d "$rubyarchdir"; then
-           RUBY_CFLAGS="$RUBY_CFLAGS -I$rubyarchdir"
-         fi
-         rubyversion=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig::CONFIG[['ruby_version']].gsub(/\./, '')[[0,2]]"`
- 	if test "X$rubyversion" = "X"; then
- 	  rubyversion=`$vi_cv_path_ruby -e "print ((VERSION rescue RUBY_VERSION)).gsub(/\./, '')[[0,2]]"`
- 	fi
-         RUBY_CFLAGS="$RUBY_CFLAGS -DRUBY_VERSION=$rubyversion"
- 	rubylibs=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig::CONFIG[['LIBS']]"`
- 	if test "X$rubylibs" != "X"; then
- 	  RUBY_LIBS="$rubylibs"
- 	fi
- 	librubyarg=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig.expand($ruby_rbconfig::CONFIG[['LIBRUBYARG']])"`
- 	librubya=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig.expand($ruby_rbconfig::CONFIG[['LIBRUBY_A']])"`
- 	rubylibdir=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig.expand($ruby_rbconfig::CONFIG[['libdir']])"`
- 	if test -f "$rubylibdir/$librubya"; then
- 	  librubyarg="$librubyarg"
- 	  RUBY_LIBS="$RUBY_LIBS -L$rubylibdir"
- 	elif test "$librubyarg" = "libruby.a"; then
- 	  dnl required on Mac OS 10.3 where libruby.a doesn't exist
- 	  librubyarg="-lruby"
- 	  RUBY_LIBS="$RUBY_LIBS -L$rubylibdir"
- 	fi
- 
- 	if test "X$librubyarg" != "X"; then
- 	  RUBY_LIBS="$librubyarg $RUBY_LIBS"
- 	fi
- 	rubyldflags=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig::CONFIG[['LDFLAGS']]"`
- 	if test "X$rubyldflags" != "X"; then
- 	  dnl Ruby on Mac OS X 10.5 adds "-arch" flags but these should only
- 	  dnl be included if requested by passing --with-mac-arch to
- 	  dnl configure, so strip these flags first (if present)
- 	  rubyldflags=`echo "$rubyldflags" | sed -e 's/-arch\ ppc//' -e 's/-arch\ i386//' -e 's/-arch\ x86_64//'`
- 	  if test "X$rubyldflags" != "X"; then
- 	    if test "X`echo \"$LDFLAGS\" | $FGREP -e \"$rubyldflags\"`" = "X"; then
- 	      LDFLAGS="$rubyldflags $LDFLAGS"
- 	    fi
- 	  fi
- 	fi
- 	RUBY_SRC="if_ruby.c"
- 	RUBY_OBJ="objects/if_ruby.o"
- 	RUBY_PRO="if_ruby.pro"
- 	AC_DEFINE(FEAT_RUBY)
- 	if test "$enable_rubyinterp" = "dynamic"; then
- 	  libruby=`$vi_cv_path_ruby -r rbconfig -e "puts $ruby_rbconfig::CONFIG[['LIBRUBY_SO']]"`
- 	  AC_DEFINE(DYNAMIC_RUBY)
- 	  RUBY_CFLAGS="-DDYNAMIC_RUBY_DLL=\\\"$libruby\\\" -DDYNAMIC_RUBY_VER=$rubyversion $RUBY_CFLAGS"
- 	  RUBY_LIBS=
- 	fi
-       else
- 	AC_MSG_RESULT(not found; disabling Ruby)
-       fi
-     else
-       AC_MSG_RESULT(too old; need Ruby version 1.6.0 or later)
-     fi
-   fi
- 
-   if test "$fail_if_missing" = "yes" -a -z "$RUBY_OBJ"; then
-     AC_MSG_ERROR([could not configure Ruby])
-   fi
- fi
- AC_SUBST(RUBY_SRC)
- AC_SUBST(RUBY_OBJ)
- AC_SUBST(RUBY_PRO)
- AC_SUBST(RUBY_CFLAGS)
- AC_SUBST(RUBY_LIBS)
- 
- AC_MSG_CHECKING(--enable-cscope argument)
- AC_ARG_ENABLE(cscope,
- 	[  --enable-cscope         Include cscope interface.], ,
- 	[enable_cscope="no"])
- AC_MSG_RESULT($enable_cscope)
- if test "$enable_cscope" = "yes"; then
-   AC_DEFINE(FEAT_CSCOPE)
- fi
- 
- AC_MSG_CHECKING(--enable-workshop argument)
- AC_ARG_ENABLE(workshop,
- 	[  --enable-workshop       Include Sun Visual Workshop support.], ,
- 	[enable_workshop="no"])
- AC_MSG_RESULT($enable_workshop)
- if test "$enable_workshop" = "yes"; then
-   AC_DEFINE(FEAT_SUN_WORKSHOP)
-   WORKSHOP_SRC="workshop.c integration.c"
-   AC_SUBST(WORKSHOP_SRC)
-   WORKSHOP_OBJ="objects/workshop.o objects/integration.o"
-   AC_SUBST(WORKSHOP_OBJ)
-   if test "${enable_gui-xxx}" = xxx; then
-     enable_gui=motif
-   fi
- fi
- 
- AC_MSG_CHECKING(--disable-netbeans argument)
- AC_ARG_ENABLE(netbeans,
- 	[  --disable-netbeans      Disable NetBeans integration support.],
- 	, [enable_netbeans="yes"])
- if test "$enable_netbeans" = "yes"; then
-   if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
-     AC_MSG_RESULT([cannot use NetBeans with tiny or small features])
-     enable_netbeans="no"
-   else
-     AC_MSG_RESULT(no)
-   fi
- else
-   AC_MSG_RESULT(yes)
- fi
- 
- AC_MSG_CHECKING(--disable-channel argument)
- AC_ARG_ENABLE(channel,
- 	[  --disable-channel      Disable process communication support.],
- 	, [enable_channel="yes"])
- if test "$enable_channel" = "yes"; then
-   if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
-     AC_MSG_RESULT([cannot use channels with tiny or small features])
-     enable_channel="no"
-   else
-     AC_MSG_RESULT(no)
-   fi
- else
-   if test "$enable_netbeans" = "yes"; then
-     AC_MSG_RESULT([yes, netbeans also disabled])
-     enable_netbeans="no"
-   else
-     AC_MSG_RESULT(yes)
-   fi
- fi
- 
- if test "$enable_channel" = "yes"; then
-   dnl On Solaris we need the socket and nsl library.
-   AC_CHECK_LIB(socket, socket)
-   AC_CHECK_LIB(nsl, gethostbyname)
-   AC_MSG_CHECKING(whether compiling with process communication is possible)
-   AC_TRY_LINK([
- #include <stdio.h>
- #include <stdlib.h>
- #include <stdarg.h>
- #include <fcntl.h>
- #include <netdb.h>
- #include <netinet/in.h>
- #include <errno.h>
- #include <sys/types.h>
- #include <sys/socket.h>
- 	/* Check bitfields */
- 	struct nbbuf {
- 	unsigned int  initDone:1;
- 	ushort signmaplen;
- 	};
- 	    ], [
- 		/* Check creating a socket. */
- 		struct sockaddr_in server;
- 		(void)socket(AF_INET, SOCK_STREAM, 0);
- 		(void)htons(100);
- 		(void)gethostbyname("microsoft.com");
- 		if (errno == ECONNREFUSED)
- 		  (void)connect(1, (struct sockaddr *)&server, sizeof(server));
- 	    ],
- 	AC_MSG_RESULT(yes),
- 	AC_MSG_RESULT(no); enable_netbeans="no"; enable_channel="no")
- fi
- if test "$enable_netbeans" = "yes"; then
-   AC_DEFINE(FEAT_NETBEANS_INTG)
-   NETBEANS_SRC="netbeans.c"
-   AC_SUBST(NETBEANS_SRC)
-   NETBEANS_OBJ="objects/netbeans.o"
-   AC_SUBST(NETBEANS_OBJ)
- fi
- if test "$enable_channel" = "yes"; then
-   AC_DEFINE(FEAT_JOB_CHANNEL)
-   CHANNEL_SRC="channel.c"
-   AC_SUBST(CHANNEL_SRC)
-   CHANNEL_OBJ="objects/channel.o"
-   AC_SUBST(CHANNEL_OBJ)
- fi
- 
- AC_MSG_CHECKING(--enable-multibyte argument)
- AC_ARG_ENABLE(multibyte,
- 	[  --enable-multibyte      Include multibyte editing support.], ,
- 	[enable_multibyte="no"])
- AC_MSG_RESULT($enable_multibyte)
- if test "$enable_multibyte" = "yes"; then
-   AC_DEFINE(FEAT_MBYTE)
- fi
- 
- AC_MSG_CHECKING(--enable-hangulinput argument)
- AC_ARG_ENABLE(hangulinput,
- 	[  --enable-hangulinput    Include Hangul input support.], ,
- 	[enable_hangulinput="no"])
- AC_MSG_RESULT($enable_hangulinput)
- 
- AC_MSG_CHECKING(--enable-xim argument)
- AC_ARG_ENABLE(xim,
- 	[  --enable-xim            Include XIM input support.],
- 	AC_MSG_RESULT($enable_xim),
- 	[enable_xim="auto"; AC_MSG_RESULT(defaulting to auto)])
- 
- AC_MSG_CHECKING(--enable-fontset argument)
- AC_ARG_ENABLE(fontset,
- 	[  --enable-fontset        Include X fontset output support.], ,
- 	[enable_fontset="no"])
- AC_MSG_RESULT($enable_fontset)
- dnl defining FEAT_XFONTSET is delayed, so that it can be disabled for no GUI
- 
- test -z "$with_x" && with_x=yes
- test "${enable_gui-yes}" != no -a "x$MACOSX" != "xyes" -a "x$QNX" != "xyes" && with_x=yes
- if test "$with_x" = no; then
-   AC_MSG_RESULT(defaulting to: don't HAVE_X11)
- else
-   dnl Do this check early, so that its failure can override user requests.
- 
-   AC_PATH_PROG(xmkmfpath, xmkmf)
- 
-   AC_PATH_XTRA
- 
-   dnl On z/OS Unix the X libraries are DLLs. To use them the code must
-   dnl be compiled with a special option.
-   dnl Also add SM, ICE and Xmu to X_EXTRA_LIBS.
-   if test "$zOSUnix" = "yes"; then
-     CFLAGS="$CFLAGS -W c,dll"
-     LDFLAGS="$LDFLAGS -W l,dll"
-     X_EXTRA_LIBS="$X_EXTRA_LIBS -lSM -lICE -lXmu"
-   fi
- 
-   dnl On my HPUX system the X include dir is found, but the lib dir not.
-   dnl This is a desparate try to fix this.
- 
-   if test -d "$x_includes" && test ! -d "$x_libraries"; then
-     x_libraries=`echo "$x_includes" | sed s/include/lib/`
-     AC_MSG_RESULT(Corrected X libraries to $x_libraries)
-     X_LIBS="$X_LIBS -L$x_libraries"
-     if test "`(uname) 2>/dev/null`" = SunOS &&
- 					 uname -r | grep '^5' >/dev/null; then
-       X_LIBS="$X_LIBS -R $x_libraries"
-     fi
-   fi
- 
-   if test -d "$x_libraries" && test ! -d "$x_includes"; then
-     x_includes=`echo "$x_libraries" | sed s/lib/include/`
-     AC_MSG_RESULT(Corrected X includes to $x_includes)
-     X_CFLAGS="$X_CFLAGS -I$x_includes"
-   fi
- 
-   dnl Remove "-I/usr/include " from X_CFLAGS, should not be needed.
-   X_CFLAGS="`echo $X_CFLAGS\  | sed 's%-I/usr/include %%'`"
-   dnl Remove "-L/usr/lib " from X_LIBS, should not be needed.
-   X_LIBS="`echo $X_LIBS\  | sed 's%-L/usr/lib %%'`"
-   dnl Same for "-R/usr/lib ".
-   X_LIBS="`echo $X_LIBS\  | sed -e 's%-R/usr/lib %%' -e 's%-R /usr/lib %%'`"
- 
- 
-   dnl Check if the X11 header files are correctly installed. On some systems
-   dnl Xlib.h includes files that don't exist.  On some systems X11/Intrinsic.h
-   dnl is missing.
-   AC_MSG_CHECKING(if X11 header files can be found)
-   cflags_save=$CFLAGS
-   CFLAGS="$CFLAGS $X_CFLAGS"
-   AC_TRY_COMPILE([#include <X11/Xlib.h>
- #include <X11/Intrinsic.h>], ,
- 	AC_MSG_RESULT(yes),
- 	AC_MSG_RESULT(no); no_x=yes)
-   CFLAGS=$cflags_save
- 
-   if test "${no_x-no}" = yes; then
-     with_x=no
-   else
-     AC_DEFINE(HAVE_X11)
-     X_LIB="-lXt -lX11";
-     AC_SUBST(X_LIB)
- 
-     ac_save_LDFLAGS="$LDFLAGS"
-     LDFLAGS="-L$x_libraries $LDFLAGS"
- 
-     dnl Check for -lXdmcp (needed on SunOS 4.1.4)
-     dnl For HP-UX 10.20 it must be before -lSM -lICE
-     AC_CHECK_LIB(Xdmcp, _XdmcpAuthDoIt, [X_EXTRA_LIBS="$X_EXTRA_LIBS -lXdmcp"],,
- 		[-lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS -lXdmcp])
- 
-     dnl Some systems need -lnsl -lsocket when testing for ICE.
-     dnl The check above doesn't do this, try here (again).  Also needed to get
-     dnl them after Xdmcp.  link.sh will remove them when not needed.
-     dnl Check for other function than above to avoid the cached value
-     AC_CHECK_LIB(ICE, IceOpenConnection,
- 		  [X_EXTRA_LIBS="$X_EXTRA_LIBS -lSM -lICE"],, [$X_EXTRA_LIBS])
- 
-     dnl Check for -lXpm (needed for some versions of Motif)
-     LDFLAGS="$X_LIBS $ac_save_LDFLAGS"
-     AC_CHECK_LIB(Xpm, XpmCreatePixmapFromData, [X_PRE_LIBS="$X_PRE_LIBS -lXpm"],,
- 		[-lXt $X_PRE_LIBS -lXpm -lX11 $X_EXTRA_LIBS])
- 
-     dnl Check that the X11 header files don't use implicit declarations
-     AC_MSG_CHECKING(if X11 header files implicitly declare return values)
-     cflags_save=$CFLAGS
-     dnl -Werror is GCC only, others like Solaris Studio might not like it
-     if test "$GCC" = yes; then
-       CFLAGS="$CFLAGS $X_CFLAGS -Werror"
-     else
-       CFLAGS="$CFLAGS $X_CFLAGS"
-     fi
-     AC_TRY_COMPILE([#include <X11/Xlib.h>], ,
- 	AC_MSG_RESULT(no),
- 	CFLAGS="$CFLAGS -Wno-implicit-int"
- 	AC_TRY_COMPILE([#include <X11/Xlib.h>], ,
- 	    AC_MSG_RESULT(yes); cflags_save="$cflags_save -Wno-implicit-int",
- 	    AC_MSG_RESULT(test failed)
- 	)
-     )
-     CFLAGS=$cflags_save
- 
-     LDFLAGS="$ac_save_LDFLAGS"
- 
-     AC_MSG_CHECKING(size of wchar_t is 2 bytes)
-     AC_CACHE_VAL(ac_cv_small_wchar_t,
- 	[AC_TRY_RUN([
- #include <X11/Xlib.h>
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- 		main()
- 		{
- 		  if (sizeof(wchar_t) <= 2)
- 		    exit(1);
- 		  exit(0);
- 		}],
- 		ac_cv_small_wchar_t="no",
- 		ac_cv_small_wchar_t="yes",
- 		AC_MSG_ERROR(failed to compile test program))])
-     AC_MSG_RESULT($ac_cv_small_wchar_t)
-     if test "x$ac_cv_small_wchar_t" = "xyes" ; then
-       AC_DEFINE(SMALL_WCHAR_T)
-     fi
- 
-   fi
- fi
- 
- test "x$with_x" = xno -a "x$MACOSX" != "xyes" -a "x$QNX" != "xyes" && enable_gui=no
- 
- AC_MSG_CHECKING(--enable-gui argument)
- AC_ARG_ENABLE(gui,
-  [  --enable-gui[=OPTS]     X11 GUI [default=auto] [OPTS=auto/no/gtk2/gnome2/gtk3/motif/athena/neXtaw/photon/carbon]], , enable_gui="auto")
- 
- dnl Canonicalize the --enable-gui= argument so that it can be easily compared.
- dnl Do not use character classes for portability with old tools.
- enable_gui_canon=`echo "_$enable_gui" | \
- 	sed 's/[[ _+-]]//g;y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/'`
- 
- dnl Skip everything by default.
- SKIP_GTK2=YES
- SKIP_GTK3=YES
- SKIP_GNOME=YES
- SKIP_MOTIF=YES
- SKIP_ATHENA=YES
- SKIP_NEXTAW=YES
- SKIP_PHOTON=YES
- SKIP_CARBON=YES
- GUITYPE=NONE
- 
- if test "x$QNX" = "xyes" -a "x$with_x" = "xno" ; then
-   SKIP_PHOTON=
-   case "$enable_gui_canon" in
-     no)		AC_MSG_RESULT(no GUI support)
- 		SKIP_PHOTON=YES ;;
-     yes|"")	AC_MSG_RESULT(yes - automatic GUI support) ;;
-     auto)	AC_MSG_RESULT(auto - automatic GUI support) ;;
-     photon)	AC_MSG_RESULT(Photon GUI support) ;;
-     *)		AC_MSG_RESULT([Sorry, $enable_gui GUI is not supported])
- 		SKIP_PHOTON=YES ;;
-   esac
- 
- elif test "x$MACOSX" = "xyes" -a "x$with_x" = "xno" ; then
-   SKIP_CARBON=
-   case "$enable_gui_canon" in
-     no)		AC_MSG_RESULT(no GUI support)
- 		SKIP_CARBON=YES ;;
-     yes|"")	AC_MSG_RESULT(yes - automatic GUI support) ;;
-     auto)	AC_MSG_RESULT(auto - Carbon GUI is outdated - disable GUI support)
- 		SKIP_CARBON=YES ;;
-     carbon)	AC_MSG_RESULT(Carbon GUI support) ;;
-     *)		AC_MSG_RESULT([Sorry, $enable_gui GUI is not supported])
- 		SKIP_CARBON=YES ;;
-   esac
- 
- else
- 
-   case "$enable_gui_canon" in
-     no|none)	AC_MSG_RESULT(no GUI support) ;;
-     yes|""|auto)	AC_MSG_RESULT(yes/auto - automatic GUI support)
- 		SKIP_GTK2=
- 		SKIP_GNOME=
- 		SKIP_MOTIF=
- 		SKIP_ATHENA=
- 		SKIP_NEXTAW=
- 		SKIP_CARBON=;;
-     gtk2)	AC_MSG_RESULT(GTK+ 2.x GUI support)
- 		SKIP_GTK2=;;
-     gnome2)	AC_MSG_RESULT(GNOME 2.x GUI support)
- 		SKIP_GNOME=
- 		SKIP_GTK2=;;
-     gtk3)	AC_MSG_RESULT(GTK+ 3.x GUI support)
- 		SKIP_GTK3=;;
-     motif)	AC_MSG_RESULT(Motif GUI support)
- 		SKIP_MOTIF=;;
-     athena)	AC_MSG_RESULT(Athena GUI support)
- 		SKIP_ATHENA=;;
-     nextaw)	AC_MSG_RESULT(neXtaw GUI support)
- 		SKIP_NEXTAW=;;
-     *)		AC_MSG_RESULT([Sorry, $enable_gui GUI is not supported]) ;;
-   esac
- 
- fi
- 
- if test "x$SKIP_GTK2" != "xYES" -a "$enable_gui_canon" != "gtk2" \
- 				-a "$enable_gui_canon" != "gnome2"; then
-   AC_MSG_CHECKING(whether or not to look for GTK+ 2)
-   AC_ARG_ENABLE(gtk2-check,
- 	[  --enable-gtk2-check     If auto-select GUI, check for GTK+ 2 [default=yes]],
- 	, enable_gtk2_check="yes")
-   AC_MSG_RESULT($enable_gtk2_check)
-   if test "x$enable_gtk2_check" = "xno"; then
-     SKIP_GTK2=YES
-     SKIP_GNOME=YES
-   fi
- fi
- 
- if test "x$SKIP_GNOME" != "xYES" -a "$enable_gui_canon" != "gnome2"; then
-   AC_MSG_CHECKING(whether or not to look for GNOME)
-   AC_ARG_ENABLE(gnome-check,
- 	[  --enable-gnome-check    If GTK GUI, check for GNOME [default=no]],
- 	, enable_gnome_check="no")
-   AC_MSG_RESULT($enable_gnome_check)
-   if test "x$enable_gnome_check" = "xno"; then
-     SKIP_GNOME=YES
-   fi
- fi
- 
- if test "x$SKIP_GTK3" != "xYES" -a "$enable_gui_canon" != "gtk3"; then
-   AC_MSG_CHECKING(whether or not to look for GTK+ 3)
-   AC_ARG_ENABLE(gtk3-check,
- 	[  --enable-gtk3-check     If auto-select GUI, check for GTK+ 3 [default=yes]],
- 	, enable_gtk3_check="yes")
-   AC_MSG_RESULT($enable_gtk3_check)
-   if test "x$enable_gtk3_check" = "xno"; then
-     SKIP_GTK3=YES
-   fi
- fi
- 
- if test "x$SKIP_MOTIF" != "xYES" -a "$enable_gui_canon" != "motif"; then
-   AC_MSG_CHECKING(whether or not to look for Motif)
-   AC_ARG_ENABLE(motif-check,
- 	[  --enable-motif-check    If auto-select GUI, check for Motif [default=yes]],
- 	, enable_motif_check="yes")
-   AC_MSG_RESULT($enable_motif_check)
-   if test "x$enable_motif_check" = "xno"; then
-     SKIP_MOTIF=YES
-   fi
- fi
- 
- if test "x$SKIP_ATHENA" != "xYES" -a "$enable_gui_canon" != "athena"; then
-   AC_MSG_CHECKING(whether or not to look for Athena)
-   AC_ARG_ENABLE(athena-check,
- 	[  --enable-athena-check   If auto-select GUI, check for Athena [default=yes]],
- 	, enable_athena_check="yes")
-   AC_MSG_RESULT($enable_athena_check)
-   if test "x$enable_athena_check" = "xno"; then
-     SKIP_ATHENA=YES
-   fi
- fi
- 
- if test "x$SKIP_NEXTAW" != "xYES" -a "$enable_gui_canon" != "nextaw"; then
-   AC_MSG_CHECKING(whether or not to look for neXtaw)
-   AC_ARG_ENABLE(nextaw-check,
- 	[  --enable-nextaw-check   If auto-select GUI, check for neXtaw [default=yes]],
- 	, enable_nextaw_check="yes")
-   AC_MSG_RESULT($enable_nextaw_check);
-   if test "x$enable_nextaw_check" = "xno"; then
-     SKIP_NEXTAW=YES
-   fi
- fi
- 
- if test "x$SKIP_CARBON" != "xYES" -a "$enable_gui_canon" != "carbon"; then
-   AC_MSG_CHECKING(whether or not to look for Carbon)
-   AC_ARG_ENABLE(carbon-check,
- 	[  --enable-carbon-check   If auto-select GUI, check for Carbon [default=yes]],
- 	, enable_carbon_check="yes")
-   AC_MSG_RESULT($enable_carbon_check);
-   if test "x$enable_carbon_check" = "xno"; then
-     SKIP_CARBON=YES
-   fi
- fi
- 
- 
- if test "x$MACOSX" = "xyes" -a -z "$SKIP_CARBON" -a "x$CARBON" = "xyes"; then
-   AC_MSG_CHECKING(for Carbon GUI)
-   dnl already did the check, just give the message
-   AC_MSG_RESULT(yes);
-   GUITYPE=CARBONGUI
-   if test "$VIMNAME" = "vim"; then
-     VIMNAME=Vim
-   fi
- 
-   if test "x$MACARCH" = "xboth"; then
-     CPPFLAGS="$CPPFLAGS -I$DEVELOPER_DIR/SDKs/MacOSX10.4u.sdk/Developer/Headers/FlatCarbon"
-   else
-     CPPFLAGS="$CPPFLAGS -I$DEVELOPER_DIR/Headers/FlatCarbon"
-   fi
- 
-   dnl Default install directory is not /usr/local
-   if test x$prefix = xNONE; then
-     prefix=/Applications
-   fi
- 
-   dnl Sorry for the hard coded default
-   datadir='${prefix}/Vim.app/Contents/Resources'
- 
-   dnl skip everything else
-   SKIP_GTK2=YES;
-   SKIP_GNOME=YES;
-   SKIP_MOTIF=YES;
-   SKIP_ATHENA=YES;
-   SKIP_NEXTAW=YES;
-   SKIP_PHOTON=YES;
-   SKIP_CARBON=YES
- fi
- 
- dnl define an autoconf function to check for a specified version of GTK, and
- dnl try to compile/link a GTK program.
- dnl
- dnl AM_PATH_GTK([MINIMUM-VERSION, [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND]]])
- dnl Test for GTK, and define GTK_CFLAGS, GTK_LIBDIR and GTK_LIBS
- dnl
- AC_DEFUN(AM_PATH_GTK,
- [
-   if test "X$GTK_CONFIG" != "Xno" -o "X$PKG_CONFIG" != "Xno"; then
-   {
-     no_gtk=""
-     if (test "X$SKIP_GTK2" != "XYES" -a "X$PKG_CONFIG" != "Xno") \
- 	  && $PKG_CONFIG --exists gtk+-2.0; then
-     {
-       min_gtk_version=ifelse([$1], ,2.2.0,$1)
-       AC_MSG_CHECKING(for GTK - version >= $min_gtk_version)
-       dnl We should be using PKG_CHECK_MODULES() instead of this hack.
-       dnl But I guess the dependency on pkgconfig.m4 is not wanted or
-       dnl something like that.
-       GTK_CFLAGS=`$PKG_CONFIG --cflags gtk+-2.0`
-       GTK_LIBDIR=`$PKG_CONFIG --libs-only-L gtk+-2.0`
-       GTK_LIBS=`$PKG_CONFIG --libs gtk+-2.0`
-       gtk_major_version=`$PKG_CONFIG --modversion gtk+-2.0 | \
- 	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\1/'`
-       gtk_minor_version=`$PKG_CONFIG --modversion gtk+-2.0 | \
- 	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\2/'`
-       gtk_micro_version=`$PKG_CONFIG --modversion gtk+-2.0 | \
- 	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\3/'`
-     }
-     elif (test "X$SKIP_GTK3" != "XYES" -a "X$PKG_CONFIG" != "Xno") \
- 	  && $PKG_CONFIG --exists gtk+-3.0; then
-     {
-       min_gtk_version=ifelse([$1], ,3.0.0,$1)
-       AC_MSG_CHECKING(for GTK - version >= $min_gtk_version)
- 
-       GTK_CFLAGS=`$PKG_CONFIG --cflags gtk+-3.0`
-       GTK_LIBDIR=`$PKG_CONFIG --libs-only-L gtk+-3.0`
-       GTK_LIBS=`$PKG_CONFIG --libs gtk+-3.0`
-       gtk_major_version=`$PKG_CONFIG --modversion gtk+-3.0 | \
- 	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\1/'`
-       gtk_minor_version=`$PKG_CONFIG --modversion gtk+-3.0 | \
- 	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\2/'`
-       gtk_micro_version=`$PKG_CONFIG --modversion gtk+-3.0 | \
- 	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\3/'`
-     }
-     else
-       no_gtk=yes
-     fi
- 
-     if test "x$enable_gtktest" = "xyes" -a "x$no_gtk" = "x"; then
-     {
-       ac_save_CFLAGS="$CFLAGS"
-       ac_save_LIBS="$LIBS"
-       CFLAGS="$CFLAGS $GTK_CFLAGS"
-       LIBS="$LIBS $GTK_LIBS"
- 
-       dnl
-       dnl Now check if the installed GTK is sufficiently new.
-       dnl
-       rm -f conf.gtktest
-       AC_TRY_RUN([
- #include <gtk/gtk.h>
- #include <stdio.h>
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- 
- int
- main ()
- {
- int major, minor, micro;
- char *tmp_version;
- 
- system ("touch conf.gtktest");
- 
- /* HP/UX 9 (%@#!) writes to sscanf strings */
- tmp_version = g_strdup("$min_gtk_version");
- if (sscanf(tmp_version, "%d.%d.%d", &major, &minor, &micro) != 3) {
-    printf("%s, bad version string\n", "$min_gtk_version");
-    exit(1);
-  }
- 
- if ((gtk_major_version > major) ||
-     ((gtk_major_version == major) && (gtk_minor_version > minor)) ||
-     ((gtk_major_version == major) && (gtk_minor_version == minor) &&
- 				     (gtk_micro_version >= micro)))
- {
-     return 0;
- }
- return 1;
- }
- ],, no_gtk=yes,[echo $ac_n "cross compiling; assumed OK... $ac_c"])
-       CFLAGS="$ac_save_CFLAGS"
-       LIBS="$ac_save_LIBS"
-     }
-     fi
-     if test "x$no_gtk" = x ; then
-       if test "x$enable_gtktest" = "xyes"; then
- 	AC_MSG_RESULT(yes; found version $gtk_major_version.$gtk_minor_version.$gtk_micro_version)
-       else
- 	AC_MSG_RESULT(found version $gtk_major_version.$gtk_minor_version.$gtk_micro_version)
-       fi
-       ifelse([$2], , :, [$2])
-     else
-     {
-       AC_MSG_RESULT(no)
-       GTK_CFLAGS=""
-       GTK_LIBS=""
-       ifelse([$3], , :, [$3])
-     }
-     fi
-   }
-   else
-     GTK_CFLAGS=""
-     GTK_LIBS=""
-     ifelse([$3], , :, [$3])
-   fi
-   AC_SUBST(GTK_CFLAGS)
-   AC_SUBST(GTK_LIBS)
-   rm -f conf.gtktest
- ])
- 
- dnl ---------------------------------------------------------------------------
- dnl gnome
- dnl ---------------------------------------------------------------------------
- AC_DEFUN([GNOME_INIT_HOOK],
- [
-   AC_SUBST(GNOME_LIBS)
-   AC_SUBST(GNOME_LIBDIR)
-   AC_SUBST(GNOME_INCLUDEDIR)
- 
-   AC_ARG_WITH(gnome-includes,
-     [  --with-gnome-includes=DIR Specify location of GNOME headers],
-     [CFLAGS="$CFLAGS -I$withval"]
-   )
- 
-   AC_ARG_WITH(gnome-libs,
-     [  --with-gnome-libs=DIR   Specify location of GNOME libs],
-     [LDFLAGS="$LDFLAGS -L$withval" gnome_prefix=$withval]
-   )
- 
-   AC_ARG_WITH(gnome,
-     [  --with-gnome            Specify prefix for GNOME files],
-     if test x$withval = xyes; then
-       want_gnome=yes
-       ifelse([$1], [], :, [$1])
-     else
-       if test "x$withval" = xno; then
- 	want_gnome=no
-       else
- 	want_gnome=yes
- 	LDFLAGS="$LDFLAGS -L$withval/lib"
- 	CFLAGS="$CFLAGS -I$withval/include"
- 	gnome_prefix=$withval/lib
-       fi
-     fi,
-     want_gnome=yes)
- 
-   if test "x$want_gnome" = xyes; then
-   {
-     AC_MSG_CHECKING(for libgnomeui-2.0)
-     if $PKG_CONFIG --exists libgnomeui-2.0; then
-       AC_MSG_RESULT(yes)
-       GNOME_LIBS=`$PKG_CONFIG --libs-only-l libgnomeui-2.0`
-       GNOME_LIBDIR=`$PKG_CONFIG --libs-only-L libgnomeui-2.0`
-       GNOME_INCLUDEDIR=`$PKG_CONFIG --cflags libgnomeui-2.0`
- 
-       dnl On FreeBSD we need -pthread but pkg-config doesn't include it.
-       dnl This might not be the right way but it works for me...
-       AC_MSG_CHECKING(for FreeBSD)
-       if test "`(uname) 2>/dev/null`" = FreeBSD; then
- 	AC_MSG_RESULT(yes, adding -pthread)
- 	GNOME_INCLUDEDIR="$GNOME_INCLUDEDIR -D_THREAD_SAFE"
- 	GNOME_LIBS="$GNOME_LIBS -pthread"
-       else
- 	AC_MSG_RESULT(no)
-       fi
-       $1
-     else
-       AC_MSG_RESULT(not found)
-       if test "x$2" = xfail; then
- 	AC_MSG_ERROR(Could not find libgnomeui-2.0 via pkg-config)
-       fi
-     fi
-   }
-   fi
- ])
- 
- AC_DEFUN([GNOME_INIT],[
- 	GNOME_INIT_HOOK([],fail)
- ])
- 
- 
- dnl ---------------------------------------------------------------------------
- dnl Check for GTK2.  If it fails, then continue on for Motif as before...
- dnl ---------------------------------------------------------------------------
- if test -z "$SKIP_GTK2"; then
- 
-   AC_MSG_CHECKING(--disable-gtktest argument)
-   AC_ARG_ENABLE(gtktest, [  --disable-gtktest       Do not try to compile and run a test GTK program],
- 	, enable_gtktest=yes)
-   if test "x$enable_gtktest" = "xyes" ; then
-     AC_MSG_RESULT(gtk test enabled)
-   else
-     AC_MSG_RESULT(gtk test disabled)
-   fi
- 
-   if test "X$PKG_CONFIG" = "X"; then
-     AC_PATH_PROG(PKG_CONFIG, pkg-config, no)
-   fi
- 
-   if test "x$PKG_CONFIG" != "xno"; then
-     dnl First try finding version 2.2.0 or later.  The 2.0.x series has
-     dnl problems (bold fonts, --remote doesn't work).
-     AM_PATH_GTK(2.2.0,
- 		[GUI_LIB_LOC="$GTK_LIBDIR"
- 		 GTK_LIBNAME="$GTK_LIBS"
- 		GUI_INC_LOC="$GTK_CFLAGS"], )
-     if test "x$GTK_CFLAGS" != "x"; then
-       SKIP_GTK3=YES
-       SKIP_ATHENA=YES
-       SKIP_NEXTAW=YES
-       SKIP_MOTIF=YES
-       GUITYPE=GTK
-       AC_SUBST(GTK_LIBNAME)
-     fi
-   fi
-   if test "x$GUITYPE" = "xGTK"; then
-     if test "$gtk_minor_version" = 1 -a "0$gtk_micro_version" -ge 1 \
- 	|| test "0$gtk_minor_version" -ge 2; then
-       AC_DEFINE(HAVE_GTK_MULTIHEAD)
-     fi
-     dnl
-     dnl if GTK exists, then check for GNOME.
-     dnl
-     if test -z "$SKIP_GNOME"; then
-     {
-       GNOME_INIT_HOOK([have_gnome=yes])
-       if test "x$have_gnome" = xyes ; then
- 	AC_DEFINE(FEAT_GUI_GNOME)
- 	GUI_INC_LOC="$GUI_INC_LOC $GNOME_INCLUDEDIR"
- 	GTK_LIBNAME="$GTK_LIBNAME $GNOME_LIBDIR $GNOME_LIBS"
-       fi
-     }
-     fi
-   fi
- fi
- 
- 
- dnl ---------------------------------------------------------------------------
- dnl Check for GTK3.
- dnl ---------------------------------------------------------------------------
- if test -z "$SKIP_GTK3"; then
- 
-   AC_MSG_CHECKING(--disable-gtktest argument)
-   AC_ARG_ENABLE(gtktest, [  --disable-gtktest       Do not try to compile and run a test GTK program],
- 	, enable_gtktest=yes)
-   if test "x$enable_gtktest" = "xyes" ; then
-     AC_MSG_RESULT(gtk test enabled)
-   else
-     AC_MSG_RESULT(gtk test disabled)
-   fi
- 
-   if test "X$PKG_CONFIG" = "X"; then
-     AC_PATH_PROG(PKG_CONFIG, pkg-config, no)
-   fi
- 
-   if test "x$PKG_CONFIG" != "xno"; then
-     AM_PATH_GTK(3.0.0,
- 		[GUI_LIB_LOC="$GTK_LIBDIR"
- 		 GTK_LIBNAME="$GTK_LIBS"
- 		GUI_INC_LOC="$GTK_CFLAGS"], )
-     if test "x$GTK_CFLAGS" != "x"; then
-       SKIP_GTK2=YES
-       SKIP_GNOME=YES
-       SKIP_ATHENA=YES
-       SKIP_NEXTAW=YES
-       SKIP_MOTIF=YES
-       GUITYPE=GTK
-       AC_SUBST(GTK_LIBNAME)
-       AC_DEFINE(HAVE_GTK_MULTIHEAD)
-       AC_DEFINE(USE_GTK3)
-     fi
-   fi
- fi
- 
- dnl Check the version of Gdk-Pixbuf.  If the version is 2.31 or later and
- dnl glib-compile-resources is found in PATH, use GResource.
- if test "x$GUITYPE" = "xGTK"; then
-   AC_MSG_CHECKING([version of Gdk-Pixbuf])
-   gdk_pixbuf_version=`$PKG_CONFIG --modversion gdk-pixbuf-2.0`
-   if test "x$gdk_pixbuf_version" != x ; then
-     gdk_pixbuf_version_minor=`echo $gdk_pixbuf_version | \
-       sed -e 's/[[0-9]][[0-9]]*\.\([[0-9]][[0-9]]*\)\.[[0-9]][[0-9]]*/\1/'`
-     if test "x$gdk_pixbuf_version_minor" != x -a \
- 	$gdk_pixbuf_version_minor -ge 31 ; then
-       AC_MSG_RESULT([OK.])
-       AC_PATH_PROG(GLIB_COMPILE_RESOURCES,[glib-compile-resources],no)
-       AC_MSG_CHECKING([glib-compile-resources])
-       if test "x$GLIB_COMPILE_RESOURCES" = xno ; then
- 	GLIB_COMPILE_RESOURCES=""
- 	AC_MSG_RESULT([cannot be found in PATH.])
-       else
- 	AC_MSG_RESULT([usable.])
- 	AC_DEFINE(USE_GRESOURCE)
- 	GRESOURCE_SRC="auto/gui_gtk_gresources.c"
- 	GRESOURCE_OBJ="objects/gui_gtk_gresources.o"
-       fi
-     else
-       AC_MSG_RESULT([not usable.])
-     fi
-   else
-     AC_MSG_RESULT([cannot obtain from pkg_config.])
-   fi
- 
-   AC_MSG_CHECKING([--disable-icon-cache-update argument])
-   AC_ARG_ENABLE(icon_cache_update,
-           [  --disable-icon-cache-update        update disabled],
-           [],
-           [enable_icon_cache_update="yes"])
-   if test "$enable_icon_cache_update" = "yes"; then
-     AC_MSG_RESULT([not set])
-     AC_PATH_PROG(GTK_UPDATE_ICON_CACHE,[gtk-update-icon-cache],no)
-     if test "x$GTK_UPDATE_ICON_CACHE" = "xno" ; then
-       AC_MSG_RESULT([not found in PATH.])
-     fi
-   else
-     AC_MSG_RESULT([update disabled])
-   fi
- 
-   AC_MSG_CHECKING([--disable-desktop-database-update argument])
-   AC_ARG_ENABLE(desktop_database_update,
-           [  --disable-desktop-database-update  update disabled],
-           [],
-           [enable_desktop_database_update="yes"])
-   if test "$enable_desktop_database_update" = "yes"; then
-     AC_MSG_RESULT([not set])
-     AC_PATH_PROG(UPDATE_DESKTOP_DATABASE,[update-desktop-database],no)
-     if test "x$UPDATE_DESKTOP_DATABASE" = "xno" ; then
-       AC_MSG_RESULT([not found in PATH.])
-     fi
-   else
-     AC_MSG_RESULT([update disabled])
-   fi
- fi
- AC_SUBST(GLIB_COMPILE_RESOURCES)
- AC_SUBST(GRESOURCE_SRC)
- AC_SUBST(GRESOURCE_OBJ)
- AC_SUBST(GTK_UPDATE_ICON_CACHE)
- AC_SUBST(UPDATE_DESKTOP_DATABASE)
- 
- dnl Check for Motif include files location.
- dnl The LAST one found is used, this makes the highest version to be used,
- dnl e.g. when Motif1.2 and Motif2.0 are both present.
- 
- if test -z "$SKIP_MOTIF"; then
-   gui_XXX="/usr/XXX/Motif* /usr/Motif*/XXX /usr/XXX /usr/shlib /usr/X11*/XXX /usr/XXX/X11* /usr/dt/XXX /local/Motif*/XXX /local/XXX/Motif* /usr/local/Motif*/XXX /usr/local/XXX/Motif* /usr/local/XXX /usr/local/X11*/XXX /usr/local/LessTif/Motif*/XXX $MOTIFHOME/XXX"
-   dnl Remove "-I" from before $GUI_INC_LOC if it's there
-   GUI_INC_LOC="`echo $GUI_INC_LOC|sed 's%-I%%g'`"
- 
-   AC_MSG_CHECKING(for location of Motif GUI includes)
-   gui_includes="`echo $x_includes|sed 's%/[^/][^/]*$%%'` `echo "$gui_XXX" | sed s/XXX/include/g` $GUI_INC_LOC"
-   GUI_INC_LOC=
-   for try in $gui_includes; do
-     if test -f "$try/Xm/Xm.h"; then
-       GUI_INC_LOC=$try
-     fi
-   done
-   if test -n "$GUI_INC_LOC"; then
-     if test "$GUI_INC_LOC" = /usr/include; then
-       GUI_INC_LOC=
-       AC_MSG_RESULT(in default path)
-     else
-       AC_MSG_RESULT($GUI_INC_LOC)
-     fi
-   else
-     AC_MSG_RESULT(<not found>)
-     SKIP_MOTIF=YES
-   fi
- fi
- 
- dnl Check for Motif library files location.  In the same order as the include
- dnl files, to avoid a mixup if several versions are present
- 
- if test -z "$SKIP_MOTIF"; then
-   AC_MSG_CHECKING(--with-motif-lib argument)
-   AC_ARG_WITH(motif-lib,
-   [  --with-motif-lib=STRING   Library for Motif ],
-   [ MOTIF_LIBNAME="${withval}" ] )
- 
-   if test -n "$MOTIF_LIBNAME"; then
-     AC_MSG_RESULT($MOTIF_LIBNAME)
-     GUI_LIB_LOC=
-   else
-     AC_MSG_RESULT(no)
- 
-     dnl Remove "-L" from before $GUI_LIB_LOC if it's there
-     GUI_LIB_LOC="`echo $GUI_LIB_LOC|sed 's%-L%%g'`"
- 
-     dnl Ubuntu has libXm.so in /usr/lib/i386-linux-gnu and elsewhere.  The
-     dnl linker will figure out which one to use, we only check if one exists.
-     AC_MSG_CHECKING(for location of Motif GUI libs)
-     gui_libs="`echo $x_libraries|sed 's%/[^/][^/]*$%%'` `echo "$gui_XXX" | sed s/XXX/lib/g` /usr/lib/i386-linux-gnu /usr/lib/x86_64-linux-gnu `echo "$GUI_INC_LOC" | sed s/include/lib/` $GUI_LIB_LOC"
-     GUI_LIB_LOC=
-     for try in $gui_libs; do
-       for libtry in "$try"/libXm.a "$try"/libXm.so* "$try"/libXm.sl "$try"/libXm.dylib; do
- 	if test -f "$libtry"; then
- 	  GUI_LIB_LOC=$try
- 	fi
-       done
-     done
-     if test -n "$GUI_LIB_LOC"; then
-       dnl Remove /usr/lib, it causes trouble on some systems
-       if test "$GUI_LIB_LOC" = /usr/lib \
- 	   -o "$GUI_LIB_LOC" = /usr/lib/i386-linux-gnu \
- 	   -o "$GUI_LIB_LOC" = /usr/lib/x86_64-linux-gnu; then
- 	GUI_LIB_LOC=
- 	AC_MSG_RESULT(in default path)
-       else
- 	if test -n "$GUI_LIB_LOC"; then
- 	  AC_MSG_RESULT($GUI_LIB_LOC)
- 	  if test "`(uname) 2>/dev/null`" = SunOS &&
- 					 uname -r | grep '^5' >/dev/null; then
- 	    GUI_LIB_LOC="$GUI_LIB_LOC -R $GUI_LIB_LOC"
- 	  fi
- 	fi
-       fi
-       MOTIF_LIBNAME=-lXm
-     else
-       AC_MSG_RESULT(<not found>)
-       SKIP_MOTIF=YES
-     fi
-   fi
- fi
- 
- if test -z "$SKIP_MOTIF"; then
-   SKIP_ATHENA=YES
-   SKIP_NEXTAW=YES
-   GUITYPE=MOTIF
-   AC_SUBST(MOTIF_LIBNAME)
- fi
- 
- dnl Check if the Athena files can be found
- 
- GUI_X_LIBS=
- 
- if test -z "$SKIP_ATHENA"; then
-   AC_MSG_CHECKING(if Athena header files can be found)
-   cflags_save=$CFLAGS
-   CFLAGS="$CFLAGS $X_CFLAGS"
-   AC_TRY_COMPILE([
- #include <X11/Intrinsic.h>
- #include <X11/Xaw/Paned.h>], ,
- 	AC_MSG_RESULT(yes),
- 	AC_MSG_RESULT(no); SKIP_ATHENA=YES )
-   CFLAGS=$cflags_save
- fi
- 
- if test -z "$SKIP_ATHENA"; then
-   GUITYPE=ATHENA
- fi
- 
- if test -z "$SKIP_NEXTAW"; then
-   AC_MSG_CHECKING(if neXtaw header files can be found)
-   cflags_save=$CFLAGS
-   CFLAGS="$CFLAGS $X_CFLAGS"
-   AC_TRY_COMPILE([
- #include <X11/Intrinsic.h>
- #include <X11/neXtaw/Paned.h>], ,
- 	AC_MSG_RESULT(yes),
- 	AC_MSG_RESULT(no); SKIP_NEXTAW=YES )
-   CFLAGS=$cflags_save
- fi
- 
- if test -z "$SKIP_NEXTAW"; then
-   GUITYPE=NEXTAW
- fi
- 
- if test -z "$SKIP_ATHENA" -o -z "$SKIP_NEXTAW" -o -z "$SKIP_MOTIF"; then
-   dnl Prepend -I and -L to $GUI_INC_LOC and $GUI_LIB_LOC if not empty
-   dnl Avoid adding it when it twice
-   if test -n "$GUI_INC_LOC"; then
-     GUI_INC_LOC=-I"`echo $GUI_INC_LOC|sed 's%-I%%'`"
-   fi
-   if test -n "$GUI_LIB_LOC"; then
-     GUI_LIB_LOC=-L"`echo $GUI_LIB_LOC|sed 's%-L%%'`"
-   fi
- 
-   dnl Check for -lXext and then for -lXmu
-   ldflags_save=$LDFLAGS
-   LDFLAGS="$X_LIBS $LDFLAGS"
-   AC_CHECK_LIB(Xext, XShapeQueryExtension, [GUI_X_LIBS="-lXext"],,
- 		[-lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])
-   dnl For Solaris we need -lw and -ldl before linking with -lXmu works.
-   AC_CHECK_LIB(w, wslen, [X_EXTRA_LIBS="$X_EXTRA_LIBS -lw"],,
- 		[$GUI_X_LIBS -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])
-   AC_CHECK_LIB(dl, dlsym, [X_EXTRA_LIBS="$X_EXTRA_LIBS -ldl"],,
- 		[$GUI_X_LIBS -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])
-   AC_CHECK_LIB(Xmu, XmuCreateStippledPixmap, [GUI_X_LIBS="-lXmu $GUI_X_LIBS"],,
- 		[$GUI_X_LIBS -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])
-   if test -z "$SKIP_MOTIF"; then
-     AC_CHECK_LIB(Xp, XpEndJob, [GUI_X_LIBS="-lXp $GUI_X_LIBS"],,
- 		[$GUI_X_LIBS -lXm -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])
-   fi
-   LDFLAGS=$ldflags_save
- 
-   dnl Execute xmkmf to figure out if -DNARROWPROTO is needed.
-   AC_MSG_CHECKING(for extra X11 defines)
-   NARROW_PROTO=
-   rm -fr conftestdir
-   if mkdir conftestdir; then
-     cd conftestdir
-     cat > Imakefile <<'EOF'
- acfindx:
- 	@echo 'NARROW_PROTO="${PROTO_DEFINES}"'
- EOF
-     if (xmkmf) >/dev/null 2>/dev/null && test -f Makefile; then
-       eval `${MAKE-make} acfindx 2>/dev/null | grep -v make`
-     fi
-     cd ..
-     rm -fr conftestdir
-   fi
-   if test -z "$NARROW_PROTO"; then
-     AC_MSG_RESULT(no)
-   else
-     AC_MSG_RESULT($NARROW_PROTO)
-   fi
-   AC_SUBST(NARROW_PROTO)
- fi
- 
- dnl Look for XSMP support - but don't necessarily restrict it to X11 GUIs
- dnl use the X11 include path
- if test "$enable_xsmp" = "yes"; then
-   cppflags_save=$CPPFLAGS
-   CPPFLAGS="$CPPFLAGS $X_CFLAGS"
-   AC_CHECK_HEADERS(X11/SM/SMlib.h)
-   CPPFLAGS=$cppflags_save
- fi
- 
- 
- if test -z "$SKIP_ATHENA" -o -z "$SKIP_NEXTAW" -o -z "$SKIP_MOTIF" -o -z "$SKIP_GTK2" -o -z "$SKIP_GTK3"; then
-   dnl Check for X11/xpm.h and X11/Sunkeysym.h with the GUI include path
-   cppflags_save=$CPPFLAGS
-   CPPFLAGS="$CPPFLAGS $X_CFLAGS"
-   AC_CHECK_HEADERS(X11/xpm.h X11/Sunkeysym.h)
- 
-   dnl automatically disable XIM when XIMtext isn't in X11/Xlib.h
-   if test ! "$enable_xim" = "no"; then
-     AC_MSG_CHECKING(for XIMText in X11/Xlib.h)
-     AC_EGREP_CPP(XIMText, [#include <X11/Xlib.h>],
- 		  AC_MSG_RESULT(yes),
- 		  AC_MSG_RESULT(no; xim has been disabled); enable_xim="no")
-   fi
-   CPPFLAGS=$cppflags_save
- 
-   dnl automatically enable XIM when hangul input isn't enabled
-   if test "$enable_xim" = "auto" -a "$enable_hangulinput" != "yes" \
- 		-a "x$GUITYPE" != "xNONE" ; then
-     AC_MSG_RESULT(X GUI selected; xim has been enabled)
-     enable_xim="yes"
-   fi
- fi
- 
- if test -z "$SKIP_ATHENA" -o -z "$SKIP_NEXTAW" -o -z "$SKIP_MOTIF"; then
-   cppflags_save=$CPPFLAGS
-   CPPFLAGS="$CPPFLAGS $X_CFLAGS"
- dnl Xmu/Editres.h may exist but can only be used after including Intrinsic.h
-   AC_MSG_CHECKING([for X11/Xmu/Editres.h])
-   AC_TRY_COMPILE([
- #include <X11/Intrinsic.h>
- #include <X11/Xmu/Editres.h>],
- 		      [int i; i = 0;],
- 	      AC_MSG_RESULT(yes)
- 		      AC_DEFINE(HAVE_X11_XMU_EDITRES_H),
- 	      AC_MSG_RESULT(no))
-   CPPFLAGS=$cppflags_save
- fi
- 
- dnl Only use the Xm directory when compiling Motif, don't use it for Athena
- if test -z "$SKIP_MOTIF"; then
-   cppflags_save=$CPPFLAGS
-   CPPFLAGS="$CPPFLAGS $X_CFLAGS"
-   if test "$zOSUnix" = "yes"; then
- 	xmheader="Xm/Xm.h"
-   else
- 	xmheader="Xm/Xm.h Xm/XpmP.h Xm/JoinSideT.h Xm/TraitP.h Xm/Manager.h
- 	   Xm/UnhighlightT.h Xm/Notebook.h"  
-   fi    
-   AC_CHECK_HEADERS($xmheader)
- 
-   if test "x$ac_cv_header_Xm_XpmP_h" = "xyes"; then
-     dnl Solaris uses XpmAttributes_21, very annoying.
-     AC_MSG_CHECKING([for XpmAttributes_21 in Xm/XpmP.h])
-     AC_TRY_COMPILE([#include <Xm/XpmP.h>], [XpmAttributes_21 attr;],
- 	AC_MSG_RESULT(yes); AC_DEFINE(XPMATTRIBUTES_TYPE, XpmAttributes_21),
- 	AC_MSG_RESULT(no); AC_DEFINE(XPMATTRIBUTES_TYPE, XpmAttributes)
- 	)
-   else
-     AC_DEFINE(XPMATTRIBUTES_TYPE, XpmAttributes)
-   fi
-   CPPFLAGS=$cppflags_save
- fi
- 
- if test "x$GUITYPE" = "xNONE" -a "$enable_xim" = "yes"; then
-   AC_MSG_RESULT(no GUI selected; xim has been disabled)
-   enable_xim="no"
- fi
- if test "x$GUITYPE" = "xNONE" -a "$enable_fontset" = "yes"; then
-   AC_MSG_RESULT(no GUI selected; fontset has been disabled)
-   enable_fontset="no"
- fi
- if test "x$GUITYPE:$enable_fontset" = "xGTK:yes"; then
-   AC_MSG_RESULT(GTK+ 2 GUI selected; fontset has been disabled)
-   enable_fontset="no"
- fi
- 
- if test -z "$SKIP_PHOTON"; then
-   GUITYPE=PHOTONGUI
- fi
- 
- AC_SUBST(GUI_INC_LOC)
- AC_SUBST(GUI_LIB_LOC)
- AC_SUBST(GUITYPE)
- AC_SUBST(GUI_X_LIBS)
- 
- if test "$enable_workshop" = "yes" -a -n "$SKIP_MOTIF"; then
-   AC_MSG_ERROR([cannot use workshop without Motif])
- fi
- 
- dnl defining FEAT_XIM and FEAT_XFONTSET is delayed, so that they can be disabled
- if test "$enable_xim" = "yes"; then
-   AC_DEFINE(FEAT_XIM)
- fi
- if test "$enable_fontset" = "yes"; then
-   AC_DEFINE(FEAT_XFONTSET)
- fi
- 
- 
- dnl ---------------------------------------------------------------------------
- dnl end of GUI-checking
- dnl ---------------------------------------------------------------------------
- 
- dnl Check for Cygwin, which needs an extra source file if not using X11
- AC_MSG_CHECKING(for CYGWIN or MSYS environment)
- case `uname` in
-     CYGWIN*|MSYS*)    CYGWIN=yes; AC_MSG_RESULT(yes)
-                 AC_MSG_CHECKING(for CYGWIN clipboard support)
-                 if test "x$with_x" = "xno" ; then
-                   OS_EXTRA_SRC=winclip.c; OS_EXTRA_OBJ=objects/winclip.o
-                   AC_MSG_RESULT(yes)
-                   AC_DEFINE(FEAT_CYGWIN_WIN32_CLIPBOARD)
-                 else
-                   AC_MSG_RESULT(no - using X11)
-                 fi ;;
- 
-     *)          CYGWIN=no; AC_MSG_RESULT(no);;
- esac
- 
- dnl Only really enable hangul input when GUI and XFONTSET are available
- if test "$enable_hangulinput" = "yes"; then
-   if test "x$GUITYPE" = "xNONE"; then
-     AC_MSG_RESULT(no GUI selected; hangul input has been disabled)
-     enable_hangulinput=no
-   else
-     AC_DEFINE(FEAT_HANGULIN)
-     HANGULIN_SRC=hangulin.c
-     AC_SUBST(HANGULIN_SRC)
-     HANGULIN_OBJ=objects/hangulin.o
-     AC_SUBST(HANGULIN_OBJ)
-   fi
- fi
- 
- dnl Checks for libraries and include files.
- 
- AC_CACHE_CHECK([whether toupper is broken], [vim_cv_toupper_broken],
-   [
-     AC_RUN_IFELSE([AC_LANG_SOURCE([[
- #include "confdefs.h"
- #include <ctype.h>
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- main() { exit(toupper('A') == 'A' && tolower('z') == 'z'); }
-   ]])],[
-     vim_cv_toupper_broken=yes
-   ],[
-     vim_cv_toupper_broken=no
-   ],[
-     AC_MSG_ERROR(cross-compiling: please set 'vim_cv_toupper_broken')
-   ])])
- 
- if test "x$vim_cv_toupper_broken" = "xyes" ; then
-   AC_DEFINE(BROKEN_TOUPPER)
- fi
- 
- AC_MSG_CHECKING(whether __DATE__ and __TIME__ work)
- AC_TRY_COMPILE([#include <stdio.h>], [printf("(" __DATE__ " " __TIME__ ")");],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_DATE_TIME),
- 	AC_MSG_RESULT(no))
- 
- AC_MSG_CHECKING(whether __attribute__((unused)) is allowed)
- AC_TRY_COMPILE([#include <stdio.h>], [int x __attribute__((unused));],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_ATTRIBUTE_UNUSED),
- 	AC_MSG_RESULT(no))
- 
- dnl Checks for header files.
- AC_CHECK_HEADER(elf.h, HAS_ELF=1)
- dnl AC_CHECK_HEADER(dwarf.h, SVR4=1)
- if test "$HAS_ELF" = 1; then
-   AC_CHECK_LIB(elf, main)
- fi
- 
- AC_HEADER_DIRENT
- 
- dnl If sys/wait.h is not found it might still exist but not be POSIX
- dnl compliant. In that case we define HAVE_UNION_WAIT (for NeXT)
- if test $ac_cv_header_sys_wait_h = no; then
-   AC_MSG_CHECKING([for sys/wait.h that defines union wait])
-   AC_TRY_COMPILE([#include <sys/wait.h>],
- 			[union wait xx, yy; xx = yy],
- 		AC_MSG_RESULT(yes)
- 			AC_DEFINE(HAVE_SYS_WAIT_H)
- 			AC_DEFINE(HAVE_UNION_WAIT),
- 		AC_MSG_RESULT(no))
- fi
- 
- AC_CHECK_HEADERS(stdint.h stdlib.h string.h \
- 	sys/select.h sys/utsname.h termcap.h fcntl.h \
- 	sgtty.h sys/ioctl.h sys/time.h sys/types.h \
- 	termio.h iconv.h inttypes.h langinfo.h math.h \
- 	unistd.h stropts.h errno.h sys/resource.h \
- 	sys/systeminfo.h locale.h sys/stream.h termios.h \
- 	libc.h sys/statfs.h poll.h sys/poll.h pwd.h \
- 	utime.h sys/param.h libintl.h libgen.h \
- 	util/debug.h util/msg18n.h frame.h sys/acl.h \
- 	sys/access.h sys/sysinfo.h wchar.h wctype.h)
- 
- dnl sys/ptem.h depends on sys/stream.h on Solaris
- AC_CHECK_HEADERS(sys/ptem.h, [], [],
- [#if defined HAVE_SYS_STREAM_H
- #  include <sys/stream.h>
- #endif])
- 
- dnl sys/sysctl.h depends on sys/param.h on OpenBSD
- AC_CHECK_HEADERS(sys/sysctl.h, [], [],
- [#if defined HAVE_SYS_PARAM_H
- #  include <sys/param.h>
- #endif])
- 
- 
- dnl pthread_np.h may exist but can only be used after including pthread.h
- AC_MSG_CHECKING([for pthread_np.h])
- AC_TRY_COMPILE([
- #include <pthread.h>
- #include <pthread_np.h>],
- 		      [int i; i = 0;],
- 	      AC_MSG_RESULT(yes)
- 		      AC_DEFINE(HAVE_PTHREAD_NP_H),
- 	      AC_MSG_RESULT(no))
- 
- AC_CHECK_HEADERS(strings.h)
- if test "x$MACOSX" = "xyes"; then
-   dnl The strings.h file on OS/X contains a warning and nothing useful.
-   AC_DEFINE(NO_STRINGS_WITH_STRING_H)
- else
- 
- dnl Check if strings.h and string.h can both be included when defined.
- AC_MSG_CHECKING([if strings.h can be included after string.h])
- cppflags_save=$CPPFLAGS
- CPPFLAGS="$CPPFLAGS $X_CFLAGS"
- AC_TRY_COMPILE([
- #if defined(_AIX) && !defined(_AIX51) && !defined(_NO_PROTO)
- # define _NO_PROTO	/* like in os_unix.h, causes conflict for AIX (Winn) */
- 			/* but don't do it on AIX 5.1 (Uribarri) */
- #endif
- #ifdef HAVE_XM_XM_H
- # include <Xm/Xm.h>	/* This breaks it for HP-UX 11 (Squassabia) */
- #endif
- #ifdef HAVE_STRING_H
- # include <string.h>
- #endif
- #if defined(HAVE_STRINGS_H)
- # include <strings.h>
- #endif
- 		], [int i; i = 0;],
- 		AC_MSG_RESULT(yes),
- 		AC_DEFINE(NO_STRINGS_WITH_STRING_H)
- 		AC_MSG_RESULT(no))
- CPPFLAGS=$cppflags_save
- fi
- 
- dnl Checks for typedefs, structures, and compiler characteristics.
- AC_PROG_GCC_TRADITIONAL
- AC_C_CONST
- AC_C_VOLATILE
- AC_TYPE_MODE_T
- AC_TYPE_OFF_T
- AC_TYPE_PID_T
- AC_TYPE_SIZE_T
- AC_TYPE_UID_T
- AC_TYPE_UINT32_T
- 
- AC_HEADER_TIME
- AC_CHECK_TYPE(ino_t, long)
- AC_CHECK_TYPE(dev_t, unsigned)
- AC_C_BIGENDIAN(,,,)
- AC_C_INLINE
- 
- AC_MSG_CHECKING(for rlim_t)
- if eval "test \"`echo '$''{'ac_cv_type_rlim_t'+set}'`\" = set"; then
-   AC_MSG_RESULT([(cached) $ac_cv_type_rlim_t])
- else
-   AC_EGREP_CPP(dnl
- changequote(<<,>>)dnl
- <<(^|[^a-zA-Z_0-9])rlim_t[^a-zA-Z_0-9]>>dnl
- changequote([,]),
-   [
- #include <sys/types.h>
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- #ifdef HAVE_SYS_RESOURCE_H
- # include <sys/resource.h>
- #endif
- 	  ], ac_cv_type_rlim_t=yes, ac_cv_type_rlim_t=no)
- 	  AC_MSG_RESULT($ac_cv_type_rlim_t)
- fi
- if test $ac_cv_type_rlim_t = no; then
-   cat >> confdefs.h <<\EOF
- #define rlim_t unsigned long
- EOF
- fi
- 
- AC_MSG_CHECKING(for stack_t)
- if eval "test \"`echo '$''{'ac_cv_type_stack_t'+set}'`\" = set"; then
-   AC_MSG_RESULT([(cached) $ac_cv_type_stack_t])
- else
-   AC_EGREP_CPP(stack_t,
-   [
- #include <sys/types.h>
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- #include <signal.h>
- 	  ], ac_cv_type_stack_t=yes, ac_cv_type_stack_t=no)
- 	  AC_MSG_RESULT($ac_cv_type_stack_t)
- fi
- if test $ac_cv_type_stack_t = no; then
-   cat >> confdefs.h <<\EOF
- #define stack_t struct sigaltstack
- EOF
- fi
- 
- dnl BSDI uses ss_base while others use ss_sp for the stack pointer.
- AC_MSG_CHECKING(whether stack_t has an ss_base field)
- AC_TRY_COMPILE([
- #include <sys/types.h>
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- #include <signal.h>
- #include "confdefs.h"
- 			], [stack_t sigstk; sigstk.ss_base = 0; ],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SS_BASE),
- 	AC_MSG_RESULT(no))
- 
- olibs="$LIBS"
- AC_MSG_CHECKING(--with-tlib argument)
- AC_ARG_WITH(tlib, [  --with-tlib=library     terminal library to be used ],)
- if test -n "$with_tlib"; then
-   AC_MSG_RESULT($with_tlib)
-   LIBS="$LIBS -l$with_tlib"
-   AC_MSG_CHECKING(for linking with $with_tlib library)
-   AC_TRY_LINK([], [], AC_MSG_RESULT(OK), AC_MSG_ERROR(FAILED))
-   dnl Need to check for tgetent() below.
-   olibs="$LIBS"
- else
-   AC_MSG_RESULT([empty: automatic terminal library selection])
-   dnl  On HP-UX 10.10 termcap or termlib should be used instead of
-   dnl  curses, because curses is much slower.
-   dnl  Newer versions of ncurses are preferred over anything, except
-   dnl  when tinfo has been split off, it contains all we need.
-   dnl  Older versions of ncurses have bugs, get a new one!
-   dnl  Digital Unix (OSF1) should use curses (Ronald Schild).
-   dnl  On SCO Openserver should prefer termlib (Roger Cornelius).
-   case "`uname -s 2>/dev/null`" in
- 	OSF1|SCO_SV)	tlibs="tinfo ncurses curses termlib termcap";;
- 	*)	tlibs="tinfo ncurses termlib termcap curses";;
-   esac
-   for libname in $tlibs; do
-     AC_CHECK_LIB(${libname}, tgetent,,)
-     if test "x$olibs" != "x$LIBS"; then
-       dnl It's possible that a library is found but it doesn't work
-       dnl e.g., shared library that cannot be found
-       dnl compile and run a test program to be sure
-       AC_TRY_RUN([
- #ifdef HAVE_TERMCAP_H
- # include <termcap.h>
- #endif
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- main() {char *s; s=(char *)tgoto("%p1%d", 0, 1); exit(0); }],
- 			  res="OK", res="FAIL", res="FAIL")
-       if test "$res" = "OK"; then
- 	break
-       fi
-       AC_MSG_RESULT($libname library is not usable)
-       LIBS="$olibs"
-     fi
-   done
-   if test "x$olibs" = "x$LIBS"; then
-     AC_MSG_RESULT(no terminal library found)
-   fi
- fi
- 
- if test "x$olibs" = "x$LIBS"; then
-   AC_MSG_CHECKING([for tgetent()])
-   AC_TRY_LINK([],
-       [char s[10000]; int res = tgetent(s, "thisterminaldoesnotexist");],
- 	AC_MSG_RESULT(yes),
- 	AC_MSG_ERROR([NOT FOUND!
-       You need to install a terminal library; for example ncurses.
-       Or specify the name of the library with --with-tlib.]))
- fi
- 
- AC_CACHE_CHECK([whether we talk terminfo], [vim_cv_terminfo],
-   [
-     AC_RUN_IFELSE([AC_LANG_SOURCE([[
- #include "confdefs.h"
- #ifdef HAVE_TERMCAP_H
- # include <termcap.h>
- #endif
- #ifdef HAVE_STRING_H
- # include <string.h>
- #endif
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- main()
- {char *s; s=(char *)tgoto("%p1%d", 0, 1); exit(!strcmp(s==0 ? "" : s, "1")); }
-     ]])],[
-       vim_cv_terminfo=no
-     ],[
-       vim_cv_terminfo=yes
-     ],[
-       AC_MSG_ERROR(cross-compiling: please set 'vim_cv_terminfo')
-     ])
-   ])
- 
- if test "x$vim_cv_terminfo" = "xyes" ; then
-   AC_DEFINE(TERMINFO)
- fi
- 
- if test "x$olibs" != "x$LIBS"; then
-   AC_CACHE_CHECK([what tgetent() returns for an unknown terminal], [vim_cv_tgent],
-     [
-       AC_RUN_IFELSE([AC_LANG_SOURCE([[
- #include "confdefs.h"
- #ifdef HAVE_TERMCAP_H
- # include <termcap.h>
- #endif
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- main()
- {char s[10000]; int res = tgetent(s, "thisterminaldoesnotexist"); exit(res != 0); }
-       ]])],[
- 	vim_cv_tgent=zero
-       ],[
- 	vim_cv_tgent=non-zero
-       ],[
- 	AC_MSG_ERROR(failed to compile test program.)
-       ])
-     ])
-   
-   if test "x$vim_cv_tgent" = "xzero" ; then
-     AC_DEFINE(TGETENT_ZERO_ERR, 0)
-   fi
- fi
- 
- AC_MSG_CHECKING(whether termcap.h contains ospeed)
- AC_TRY_LINK([
- #ifdef HAVE_TERMCAP_H
- # include <termcap.h>
- #endif
- 			], [ospeed = 20000],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_OSPEED),
- 	[AC_MSG_RESULT(no)
- 	AC_MSG_CHECKING(whether ospeed can be extern)
- 	AC_TRY_LINK([
- #ifdef HAVE_TERMCAP_H
- # include <termcap.h>
- #endif
- extern short ospeed;
- 			], [ospeed = 20000],
- 		AC_MSG_RESULT(yes); AC_DEFINE(OSPEED_EXTERN),
- 		AC_MSG_RESULT(no))]
- 	)
- 
- AC_MSG_CHECKING([whether termcap.h contains UP, BC and PC])
- AC_TRY_LINK([
- #ifdef HAVE_TERMCAP_H
- # include <termcap.h>
- #endif
- 			], [if (UP == 0 && BC == 0) PC = 1],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_UP_BC_PC),
- 	[AC_MSG_RESULT(no)
- 	AC_MSG_CHECKING([whether UP, BC and PC can be extern])
- 	AC_TRY_LINK([
- #ifdef HAVE_TERMCAP_H
- # include <termcap.h>
- #endif
- extern char *UP, *BC, PC;
- 			], [if (UP == 0 && BC == 0) PC = 1],
- 		AC_MSG_RESULT(yes); AC_DEFINE(UP_BC_PC_EXTERN),
- 		AC_MSG_RESULT(no))]
- 	)
- 
- AC_MSG_CHECKING(whether tputs() uses outfuntype)
- AC_TRY_COMPILE([
- #ifdef HAVE_TERMCAP_H
- # include <termcap.h>
- #endif
- 			], [extern int xx(); tputs("test", 1, (outfuntype)xx)],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_OUTFUNTYPE),
- 	AC_MSG_RESULT(no))
- 
- dnl On some SCO machines sys/select redefines struct timeval
- AC_MSG_CHECKING([whether sys/select.h and sys/time.h may both be included])
- AC_TRY_COMPILE([
- #include <sys/types.h>
- #include <sys/time.h>
- #include <sys/select.h>], ,
- 	  AC_MSG_RESULT(yes)
- 			AC_DEFINE(SYS_SELECT_WITH_SYS_TIME),
- 	  AC_MSG_RESULT(no))
- 
- dnl AC_DECL_SYS_SIGLIST
- 
- dnl Checks for pty.c (copied from screen) ==========================
- AC_MSG_CHECKING(for /dev/ptc)
- if test -r /dev/ptc; then
-   AC_DEFINE(HAVE_DEV_PTC)
-   AC_MSG_RESULT(yes)
- else
-   AC_MSG_RESULT(no)
- fi
- 
- AC_MSG_CHECKING(for SVR4 ptys)
- if test -c /dev/ptmx ; then
-   AC_TRY_LINK([], [ptsname(0);grantpt(0);unlockpt(0);],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SVR4_PTYS),
- 	AC_MSG_RESULT(no))
- else
-   AC_MSG_RESULT(no)
- fi
- 
- AC_MSG_CHECKING(for ptyranges)
- if test -d /dev/ptym ; then
-   pdir='/dev/ptym'
- else
-   pdir='/dev'
- fi
- dnl SCO uses ptyp%d
- AC_EGREP_CPP(yes,
- [#ifdef M_UNIX
-    yes;
- #endif
- 	], ptys=`echo /dev/ptyp??`, ptys=`echo $pdir/pty??`)
- dnl if test -c /dev/ptyp19; then
- dnl ptys=`echo /dev/ptyp??`
- dnl else
- dnl ptys=`echo $pdir/pty??`
- dnl fi
- if test "$ptys" != "$pdir/pty??" ; then
-   p0=`echo $ptys | tr ' ' '\012' | sed -e 's/^.*\(.\).$/\1/g' | sort -u | tr -d '\012'`
-   p1=`echo $ptys | tr ' ' '\012' | sed -e 's/^.*\(.\)$/\1/g'  | sort -u | tr -d '\012'`
-   AC_DEFINE_UNQUOTED(PTYRANGE0,"$p0")
-   AC_DEFINE_UNQUOTED(PTYRANGE1,"$p1")
-   AC_MSG_RESULT([$p0 / $p1])
- else
-   AC_MSG_RESULT([don't know])
- fi
- 
- dnl    ****  pty mode/group handling ****
- dnl
- dnl support provided by Luke Mewburn <lm@rmit.edu.au>, 931222
- rm -f conftest_grp
- AC_CACHE_CHECK([default tty permissions/group], [vim_cv_tty_group],
-   [
-     AC_RUN_IFELSE([AC_LANG_SOURCE([[
- #include "confdefs.h"
- #include <sys/types.h>
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- #ifdef HAVE_UNISTD_H
- #include <unistd.h>
- #endif
- #include <sys/stat.h>
- #include <stdio.h>
- main()
- {
-   struct stat sb;
-   char *x,*ttyname();
-   int om, m;
-   FILE *fp;
- 
-   if (!(x = ttyname(0))) exit(1);
-   if (stat(x, &sb)) exit(1);
-   om = sb.st_mode;
-   if (om & 002) exit(0);
-   m = system("mesg y");
-   if (m == -1 || m == 127) exit(1);
-   if (stat(x, &sb)) exit(1);
-   m = sb.st_mode;
-   if (chmod(x, om)) exit(1);
-   if (m & 002) exit(0);
-   if (sb.st_gid == getgid()) exit(1);
-   if (!(fp=fopen("conftest_grp", "w")))
-     exit(1);
-   fprintf(fp, "%d\n", sb.st_gid);
-   fclose(fp);
-   exit(0);
- }
-     ]])],[
-       if test -f conftest_grp; then
- 	vim_cv_tty_group=`cat conftest_grp`
- 	if test "x$vim_cv_tty_mode" = "x" ; then
- 	  vim_cv_tty_mode=0620
- 	fi
- 	AC_MSG_RESULT([pty mode: $vim_cv_tty_mode, group: $vim_cv_tty_group])
-       else
- 	vim_cv_tty_group=world
- 	AC_MSG_RESULT([ptys are world accessible])
-       fi
-     ],[
-       vim_cv_tty_group=world
-       AC_MSG_RESULT([can't determine - assume ptys are world accessible])
-     ],[
-       AC_MSG_ERROR(cross-compiling: please set 'vim_cv_tty_group' and 'vim_cv_tty_mode')
-     ])
-   ])
- rm -f conftest_grp
- 
- if test "x$vim_cv_tty_group" != "xworld" ; then
-   AC_DEFINE_UNQUOTED(PTYGROUP,$vim_cv_tty_group)
-   if test "x$vim_cv_tty_mode" = "x" ; then
-     AC_MSG_ERROR([It seems you're cross compiling and have 'vim_cv_tty_group' set, please also set the environment variable 'vim_cv_tty_mode' to the correct mode (probably 0620)])
-   else
-     AC_DEFINE(PTYMODE, 0620)
-   fi
- fi
- 
- dnl Checks for library functions. ===================================
- 
- AC_TYPE_SIGNAL
- 
- dnl find out what to use at the end of a signal function
- if test $ac_cv_type_signal = void; then
-   AC_DEFINE(SIGRETURN, [return])
- else
-   AC_DEFINE(SIGRETURN, [return 0])
- fi
- 
- dnl check if struct sigcontext is defined (used for SGI only)
- AC_MSG_CHECKING(for struct sigcontext)
- AC_TRY_COMPILE([
- #include <signal.h>
- test_sig()
- {
-     struct sigcontext *scont;
-     scont = (struct sigcontext *)0;
-     return 1;
- } ], ,
- 	  AC_MSG_RESULT(yes)
- 		AC_DEFINE(HAVE_SIGCONTEXT),
- 	  AC_MSG_RESULT(no))
- 
- dnl tricky stuff: try to find out if getcwd() is implemented with
- dnl system("sh -c pwd")
- AC_CACHE_CHECK([getcwd implementation is broken], [vim_cv_getcwd_broken],
-   [
-     AC_RUN_IFELSE([AC_LANG_SOURCE([[
- #include "confdefs.h"
- #ifdef HAVE_UNISTD_H
- #include <unistd.h>
- #endif
- char *dagger[] = { "IFS=pwd", 0 };
- main()
- {
-   char buffer[500];
-   extern char **environ;
-   environ = dagger;
-   return getcwd(buffer, 500) ? 0 : 1;
- }
-     ]])],[
-       vim_cv_getcwd_broken=no
-     ],[
-       vim_cv_getcwd_broken=yes
-     ],[
-       AC_MSG_ERROR(cross-compiling: please set 'vim_cv_getcwd_broken')
-     ])
-   ])
- 
- if test "x$vim_cv_getcwd_broken" = "xyes" ; then
-   AC_DEFINE(BAD_GETCWD)
- fi
- 
- dnl Check for functions in one big call, to reduce the size of configure.
- dnl Can only be used for functions that do not require any include.
- AC_CHECK_FUNCS(bcmp fchdir fchown fsync getcwd getpseudotty \
- 	getpwent getpwnam getpwuid getrlimit gettimeofday getwd lstat memcmp \
- 	memset mkdtemp nanosleep opendir putenv qsort readlink select setenv \
- 	setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction \
- 	sigprocmask sigvec strcasecmp strerror strftime stricmp strncasecmp \
- 	strnicmp strpbrk strtol tgetent towlower towupper iswupper \
- 	usleep utime utimes)
- AC_FUNC_FSEEKO
- 
- dnl define _LARGE_FILES, _FILE_OFFSET_BITS and _LARGEFILE_SOURCE when
- dnl appropriate, so that off_t is 64 bits when needed.
- AC_SYS_LARGEFILE
- 
- dnl fstatfs() can take 2 to 4 arguments, try to use st_blksize if possible
- AC_MSG_CHECKING(for st_blksize)
- AC_TRY_COMPILE(
- [#include <sys/types.h>
- #include <sys/stat.h>],
- [	struct stat st;
- 	int n;
- 
- 	stat("/", &st);
- 	n = (int)st.st_blksize;],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_ST_BLKSIZE),
- 	AC_MSG_RESULT(no))
- 
- AC_CACHE_CHECK([whether stat() ignores a trailing slash], [vim_cv_stat_ignores_slash],
-   [
-     AC_RUN_IFELSE([AC_LANG_SOURCE([[
- #include "confdefs.h"
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- #include <sys/types.h>
- #include <sys/stat.h>
- main() {struct stat st;  exit(stat("configure/", &st) != 0); }
-     ]])],[
-       vim_cv_stat_ignores_slash=yes
-     ],[
-       vim_cv_stat_ignores_slash=no
-     ],[
-       AC_MSG_ERROR(cross-compiling: please set 'vim_cv_stat_ignores_slash')
-     ])
-   ])
- 
- if test "x$vim_cv_stat_ignores_slash" = "xyes" ; then
-   AC_DEFINE(STAT_IGNORES_SLASH)
- fi
-   
- dnl Link with iconv for charset translation, if not found without library.
- dnl check for iconv() requires including iconv.h
- dnl Add "-liconv" when possible; Solaris has iconv but use GNU iconv when it
- dnl has been installed.
- AC_MSG_CHECKING(for iconv_open())
- save_LIBS="$LIBS"
- LIBS="$LIBS -liconv"
- AC_TRY_LINK([
- #ifdef HAVE_ICONV_H
- # include <iconv.h>
- #endif
-     ], [iconv_open("fr", "to");],
-     AC_MSG_RESULT(yes; with -liconv); AC_DEFINE(HAVE_ICONV),
-     LIBS="$save_LIBS"
-     AC_TRY_LINK([
- #ifdef HAVE_ICONV_H
- # include <iconv.h>
- #endif
- 	], [iconv_open("fr", "to");],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_ICONV),
- 	AC_MSG_RESULT(no)))
- 
- 
- AC_MSG_CHECKING(for nl_langinfo(CODESET))
- AC_TRY_LINK([
- #ifdef HAVE_LANGINFO_H
- # include <langinfo.h>
- #endif
- ], [char *cs = nl_langinfo(CODESET);],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_NL_LANGINFO_CODESET),
- 	AC_MSG_RESULT(no))
- 
- dnl Need various functions for floating point support.  Only enable
- dnl floating point when they are all present.
- AC_CHECK_LIB(m, strtod)
- AC_MSG_CHECKING([for strtod() and other floating point functions])
- AC_TRY_LINK([
- #ifdef HAVE_MATH_H
- # include <math.h>
- #endif
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- ], [char *s; double d;
-     d = strtod("1.1", &s);
-     d = fabs(1.11);
-     d = ceil(1.11);
-     d = floor(1.11);
-     d = log10(1.11);
-     d = pow(1.11, 2.22);
-     d = sqrt(1.11);
-     d = sin(1.11);
-     d = cos(1.11);
-     d = atan(1.11);
-     ],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_FLOAT_FUNCS),
- 	AC_MSG_RESULT(no))
- 
- dnl isinf() and isnan() need to include header files and may need -lm.
- AC_MSG_CHECKING([for isinf()])
- AC_TRY_LINK([
- #ifdef HAVE_MATH_H
- # include <math.h>
- #endif
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- ], [int r = isinf(1.11); ],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_ISINF),
- 	AC_MSG_RESULT(no))
- 
- AC_MSG_CHECKING([for isnan()])
- AC_TRY_LINK([
- #ifdef HAVE_MATH_H
- # include <math.h>
- #endif
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- ], [int r = isnan(1.11); ],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_ISNAN),
- 	AC_MSG_RESULT(no))
- 
- dnl Link with -lposix1e for ACL stuff; if not found, try -lacl for SGI
- dnl when -lacl works, also try to use -lattr (required for Debian).
- dnl On Solaris, use the acl_get/set functions in libsec, if present.
- AC_MSG_CHECKING(--disable-acl argument)
- AC_ARG_ENABLE(acl,
- 	[  --disable-acl           Don't check for ACL support.],
- 	, [enable_acl="yes"])
- if test "$enable_acl" = "yes"; then
- AC_MSG_RESULT(no)
- AC_CHECK_LIB(posix1e, acl_get_file, [LIBS="$LIBS -lposix1e"],
- 	AC_CHECK_LIB(acl, acl_get_file, [LIBS="$LIBS -lacl"
- 		  AC_CHECK_LIB(attr, fgetxattr, LIBS="$LIBS -lattr",,)],,),)
- 
- AC_MSG_CHECKING(for POSIX ACL support)
- AC_TRY_LINK([
- #include <sys/types.h>
- #ifdef HAVE_SYS_ACL_H
- # include <sys/acl.h>
- #endif
- acl_t acl;], [acl = acl_get_file("foo", ACL_TYPE_ACCESS);
- 	acl_set_file("foo", ACL_TYPE_ACCESS, acl);
- 	acl_free(acl);],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_POSIX_ACL),
- 	AC_MSG_RESULT(no))
- 
- AC_CHECK_LIB(sec, acl_get, [LIBS="$LIBS -lsec"; AC_DEFINE(HAVE_SOLARIS_ZFS_ACL)],
- AC_MSG_CHECKING(for Solaris ACL support)
- AC_TRY_LINK([
- #ifdef HAVE_SYS_ACL_H
- # include <sys/acl.h>
- #endif], [acl("foo", GETACLCNT, 0, NULL);
- 	],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SOLARIS_ACL),
- 	AC_MSG_RESULT(no)))
- 
- AC_MSG_CHECKING(for AIX ACL support)
- AC_TRY_LINK([
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- #ifdef HAVE_SYS_ACL_H
- # include <sys/acl.h>
- #endif
- #ifdef HAVE_SYS_ACCESS_H
- # include <sys/access.h>
- #endif
- #define _ALL_SOURCE
- 
- #include <sys/stat.h>
- 
- int aclsize;
- struct acl *aclent;], [aclsize = sizeof(struct acl);
- 	aclent = (void *)malloc(aclsize);
- 	statacl("foo", STX_NORMAL, aclent, aclsize);
- 	],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_AIX_ACL),
- 	AC_MSG_RESULT(no))
- else
-   AC_MSG_RESULT(yes)
- fi
- 
- if test "x$GTK_CFLAGS" != "x"; then
-   dnl pango_shape_full() is new, fall back to pango_shape().
-   AC_MSG_CHECKING(for pango_shape_full)
-   ac_save_CFLAGS="$CFLAGS"
-   ac_save_LIBS="$LIBS"
-   CFLAGS="$CFLAGS $GTK_CFLAGS"
-   LIBS="$LIBS $GTK_LIBS"
-   AC_TRY_LINK(
-   [#include <gtk/gtk.h>],
-   [ pango_shape_full(NULL, 0, NULL, 0, NULL, NULL); ],
- 	  AC_MSG_RESULT(yes); AC_DEFINE(HAVE_PANGO_SHAPE_FULL),
- 	  AC_MSG_RESULT(no))
-   CFLAGS="$ac_save_CFLAGS"
-   LIBS="$ac_save_LIBS"
- fi
- 
- AC_MSG_CHECKING(--disable-gpm argument)
- AC_ARG_ENABLE(gpm,
- 	[  --disable-gpm           Don't use gpm (Linux mouse daemon).], ,
- 	[enable_gpm="yes"])
- 
- if test "$enable_gpm" = "yes"; then
-   AC_MSG_RESULT(no)
-   dnl Checking if gpm support can be compiled
-   AC_CACHE_CHECK([for gpm], vi_cv_have_gpm,
- 	[olibs="$LIBS" ; LIBS="-lgpm"]
- 	AC_TRY_LINK(
- 	    [#include <gpm.h>
- 	    #include <linux/keyboard.h>],
- 	    [Gpm_GetLibVersion(NULL);],
- 	    dnl Configure defines HAVE_GPM, if it is defined feature.h defines
- 	    dnl FEAT_MOUSE_GPM if mouse support is included
- 	    [vi_cv_have_gpm=yes],
- 	    [vi_cv_have_gpm=no])
- 	[LIBS="$olibs"]
-     )
-   if test $vi_cv_have_gpm = yes; then
-     LIBS="$LIBS -lgpm"
-     AC_DEFINE(HAVE_GPM)
-   fi
- else
-   AC_MSG_RESULT(yes)
- fi
- 
- AC_MSG_CHECKING(--disable-sysmouse argument)
- AC_ARG_ENABLE(sysmouse,
- 	[  --disable-sysmouse    Don't use sysmouse (mouse in *BSD console).], ,
- 	[enable_sysmouse="yes"])
- 
- if test "$enable_sysmouse" = "yes"; then
-   AC_MSG_RESULT(no)
-   dnl Checking if sysmouse support can be compiled
-   dnl Configure defines HAVE_SYSMOUSE, if it is defined feature.h
-   dnl defines FEAT_SYSMOUSE if mouse support is included
-   AC_CACHE_CHECK([for sysmouse], vi_cv_have_sysmouse,
- 	AC_TRY_LINK(
- 	    [#include <sys/consio.h>
- 	     #include <signal.h>
- 	     #include <sys/fbio.h>],
- 	    [struct mouse_info   mouse;
- 	     mouse.operation = MOUSE_MODE;
- 	     mouse.operation = MOUSE_SHOW;
- 	     mouse.u.mode.mode = 0;
- 	     mouse.u.mode.signal = SIGUSR2;],
- 	    [vi_cv_have_sysmouse=yes],
- 	    [vi_cv_have_sysmouse=no])
-     )
-   if test $vi_cv_have_sysmouse = yes; then
-     AC_DEFINE(HAVE_SYSMOUSE)
-   fi
- else
-   AC_MSG_RESULT(yes)
- fi
- 
- dnl make sure the FD_CLOEXEC flag for fcntl()'s F_SETFD command is known
- AC_MSG_CHECKING(for FD_CLOEXEC)
- AC_TRY_COMPILE(
- [#if HAVE_FCNTL_H
- # include <fcntl.h>
- #endif],
- [	int flag = FD_CLOEXEC;],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_FD_CLOEXEC),
- 	AC_MSG_RESULT(not usable))
- 
- dnl rename needs to be checked separately to work on Nextstep with cc
- AC_MSG_CHECKING(for rename)
- AC_TRY_LINK([#include <stdio.h>], [rename("this", "that")],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_RENAME),
- 	AC_MSG_RESULT(no))
- 
- dnl sysctl() may exist but not the arguments we use
- AC_MSG_CHECKING(for sysctl)
- AC_TRY_COMPILE(
- [#include <sys/types.h>
- #include <sys/sysctl.h>],
- [	int mib[2], r;
- 	size_t len;
- 
- 	mib[0] = CTL_HW;
- 	mib[1] = HW_USERMEM;
- 	len = sizeof(r);
- 	(void)sysctl(mib, 2, &r, &len, (void *)0, (size_t)0);
- 	],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SYSCTL),
- 	AC_MSG_RESULT(not usable))
- 
- dnl sysinfo() may exist but not be Linux compatible
- AC_MSG_CHECKING(for sysinfo)
- AC_TRY_COMPILE(
- [#include <sys/types.h>
- #include <sys/sysinfo.h>],
- [	struct sysinfo sinfo;
- 	int t;
- 
- 	(void)sysinfo(&sinfo);
- 	t = sinfo.totalram;
- 	],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SYSINFO),
- 	AC_MSG_RESULT(not usable))
- 
- dnl struct sysinfo may have the mem_unit field or not
- AC_MSG_CHECKING(for sysinfo.mem_unit)
- AC_TRY_COMPILE(
- [#include <sys/types.h>
- #include <sys/sysinfo.h>],
- [	struct sysinfo sinfo;
- 	sinfo.mem_unit = 1;
- 	],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SYSINFO_MEM_UNIT),
- 	AC_MSG_RESULT(no))
- 
- dnl sysconf() may exist but not support what we want to use
- AC_MSG_CHECKING(for sysconf)
- AC_TRY_COMPILE(
- [#include <unistd.h>],
- [	(void)sysconf(_SC_PAGESIZE);
- 	(void)sysconf(_SC_PHYS_PAGES);
- 	],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SYSCONF),
- 	AC_MSG_RESULT(not usable))
- 
- AC_CHECK_SIZEOF([int])
- AC_CHECK_SIZEOF([long])
- AC_CHECK_SIZEOF([time_t])
- AC_CHECK_SIZEOF([off_t])
- 
- dnl Use different names to avoid clashing with other header files.
- AC_DEFINE_UNQUOTED(VIM_SIZEOF_INT, [$ac_cv_sizeof_int])
- AC_DEFINE_UNQUOTED(VIM_SIZEOF_LONG, [$ac_cv_sizeof_long])
- 
- dnl Make sure that uint32_t is really 32 bits unsigned.
- AC_MSG_CHECKING([uint32_t is 32 bits])
- AC_TRY_RUN([
- #ifdef HAVE_STDINT_H
- # include <stdint.h>
- #endif
- #ifdef HAVE_INTTYPES_H
- # include <inttypes.h>
- #endif
- main() {
-   uint32_t nr1 = (uint32_t)-1;
-   uint32_t nr2 = (uint32_t)0xffffffffUL;
-   if (sizeof(uint32_t) != 4 || nr1 != 0xffffffffUL || nr2 + 1 != 0) exit(1);
-   exit(0);
- }],
- AC_MSG_RESULT(ok),
- AC_MSG_ERROR([WRONG!  uint32_t not defined correctly.]),
- AC_MSG_WARN([cannot check uint32_t when cross-compiling.]))
- 
- dnl Check for memmove() before bcopy(), makes memmove() be used when both are
- dnl present, fixes problem with incompatibility between Solaris 2.4 and 2.5.
- 
- [bcopy_test_prog='
- #include "confdefs.h"
- #ifdef HAVE_STRING_H
- # include <string.h>
- #endif
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- main() {
-   char buf[10];
-   strcpy(buf, "abcdefghi");
-   mch_memmove(buf, buf + 2, 3);
-   if (strncmp(buf, "ababcf", 6))
-     exit(1);
-   strcpy(buf, "abcdefghi");
-   mch_memmove(buf + 2, buf, 3);
-   if (strncmp(buf, "cdedef", 6))
-     exit(1);
-   exit(0); /* libc version works properly.  */
- }']
- 
- AC_CACHE_CHECK([whether memmove handles overlaps],[vim_cv_memmove_handles_overlap],
-   [
-     AC_RUN_IFELSE([AC_LANG_SOURCE([[#define mch_memmove(s,d,l) memmove(d,s,l) $bcopy_test_prog]])],
-       [
- 	vim_cv_memmove_handles_overlap=yes
-       ],[
- 	vim_cv_memmove_handles_overlap=no
-       ],[
- 	AC_MSG_ERROR(cross-compiling: please set 'vim_cv_memmove_handles_overlap')
-       ])
-   ])
- 
- if test "x$vim_cv_memmove_handles_overlap" = "xyes" ; then
-   AC_DEFINE(USEMEMMOVE)
- else
-   AC_CACHE_CHECK([whether bcopy handles overlaps],[vim_cv_bcopy_handles_overlap],
-     [
-       AC_RUN_IFELSE([AC_LANG_SOURCE([[#define mch_bcopy(s,d,l) bcopy(d,s,l) $bcopy_test_prog]])],
-       [
- 	vim_cv_bcopy_handles_overlap=yes
-       ],[
- 	vim_cv_bcopy_handles_overlap=no
-       ],[
- 	AC_MSG_ERROR(cross-compiling: please set 'vim_cv_bcopy_handles_overlap')
-       ])
-     ])
- 
-   if test "x$vim_cv_bcopy_handles_overlap" = "xyes" ; then
-     AC_DEFINE(USEBCOPY)
-   else
-     AC_CACHE_CHECK([whether memcpy handles overlaps],[vim_cv_memcpy_handles_overlap],
-       [
- 	AC_RUN_IFELSE([AC_LANG_SOURCE([[#define mch_memcpy(s,d,l) memcpy(d,s,l) $bcopy_test_prog]])],
- 	  [
- 	    vim_cv_memcpy_handles_overlap=yes
- 	  ],[
- 	    vim_cv_memcpy_handles_overlap=no
- 	  ],[
- 	    AC_MSG_ERROR(cross-compiling: please set 'vim_cv_memcpy_handles_overlap')
- 	  ])
-       ])
- 
-     if test "x$vim_cv_memcpy_handles_overlap" = "xyes" ; then
-       AC_DEFINE(USEMEMCPY)
-     fi
-   fi
- fi
- 
- 
- dnl Check for multibyte locale functions
- dnl Find out if _Xsetlocale() is supported by libX11.
- dnl Check if X_LOCALE should be defined.
- if test "x$with_x" = "xyes"; then
-   cflags_save=$CFLAGS
-   libs_save=$LIBS
-   LIBS="$LIBS $X_LIBS $GUI_LIB_LOC $GUI_X_LIBS $X_PRE_LIBS $X_LIB $X_EXTRA_LIBS"
-   CFLAGS="$CFLAGS $X_CFLAGS"
- 
-   AC_MSG_CHECKING(whether X_LOCALE needed)
-   AC_TRY_COMPILE([#include <X11/Xlocale.h>],,
-       AC_TRY_LINK_FUNC([_Xsetlocale], [AC_MSG_RESULT(yes)
- 	      AC_DEFINE(X_LOCALE)], AC_MSG_RESULT(no)),
-       AC_MSG_RESULT(no))
- 
-   AC_MSG_CHECKING(whether Xutf8SetWMProperties() can be used)
-   AC_TRY_LINK_FUNC([Xutf8SetWMProperties], [AC_MSG_RESULT(yes)
- 	      AC_DEFINE(HAVE_XUTF8SETWMPROPERTIES)], AC_MSG_RESULT(no))
- 
-   CFLAGS=$cflags_save
-   LIBS=$libs_save
- fi
- 
- dnl Link with xpg4, it is said to make Korean locale working
- AC_CHECK_LIB(xpg4, _xpg4_setrunelocale, [LIBS="$LIBS -lxpg4"],,)
- 
- dnl Check how we can run ctags.  Default to "ctags" when nothing works.
- dnl Use --version to detect Exuberant ctags (preferred)
- dnl       Add --fields=+S to get function signatures for omni completion.
- dnl -t for typedefs (many ctags have this)
- dnl -s for static functions (Elvis ctags only?)
- dnl -v for variables. Dangerous, most ctags take this for 'vgrind style'.
- dnl -i+m to test for older Exuberant ctags
- AC_MSG_CHECKING(how to create tags)
- test -f tags && mv tags tags.save
- if (eval ctags --version /dev/null | grep Exuberant) < /dev/null 1>&AC_FD_CC 2>&1; then
-   TAGPRG="ctags -I INIT+ --fields=+S"
- elif (eval exctags --version /dev/null | grep Exuberant) < /dev/null 1>&AC_FD_CC 2>&1; then
-   TAGPRG="exctags -I INIT+ --fields=+S"
- elif (eval exuberant-ctags --version /dev/null | grep Exuberant) < /dev/null 1>&AC_FD_CC 2>&1; then
-   TAGPRG="exuberant-ctags -I INIT+ --fields=+S"
- else
-   TAGPRG="ctags"
-   (eval etags	   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="etags"
-   (eval etags -c   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="etags -c"
-   (eval ctags	   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags"
-   (eval ctags -t   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags -t"
-   (eval ctags -ts  /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags -ts"
-   (eval ctags -tvs /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags -tvs"
-   (eval ctags -i+m /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags -i+m"
- fi
- test -f tags.save && mv tags.save tags
- AC_MSG_RESULT($TAGPRG) AC_SUBST(TAGPRG)
- 
- dnl Check how we can run man with a section number
- AC_MSG_CHECKING(how to run man with a section nr)
- MANDEF="man"
- (eval MANPAGER=cat PAGER=cat man -s 2 read) < /dev/null > /dev/null 2>&AC_FD_CC && MANDEF="man -s"
- AC_MSG_RESULT($MANDEF)
- if test "$MANDEF" = "man -s"; then
-   AC_DEFINE(USEMAN_S)
- fi
- 
- dnl Check if gettext() is working and if it needs -lintl
- dnl We take care to base this on an empty LIBS: on some systems libelf would be
- dnl in LIBS and implicitly take along libintl. The final LIBS would then not
- dnl contain libintl, and the link step would fail due to -Wl,--as-needed.
- AC_MSG_CHECKING(--disable-nls argument)
- AC_ARG_ENABLE(nls,
- 	[  --disable-nls           Don't support NLS (gettext()).], ,
- 	[enable_nls="yes"])
- 
- if test "$enable_nls" = "yes"; then
-   AC_MSG_RESULT(no)
- 
-   INSTALL_LANGS=install-languages
-   AC_SUBST(INSTALL_LANGS)
-   INSTALL_TOOL_LANGS=install-tool-languages
-   AC_SUBST(INSTALL_TOOL_LANGS)
- 
-   AC_CHECK_PROG(MSGFMT, msgfmt, msgfmt, )
-   AC_MSG_CHECKING([for NLS])
-   if test -f po/Makefile; then
-     have_gettext="no"
-     if test -n "$MSGFMT"; then
-       olibs=$LIBS
-       LIBS=""
-       AC_TRY_LINK(
- 	[#include <libintl.h>],
- 	[gettext("Test");],
- 	AC_MSG_RESULT([gettext() works]); have_gettext="yes"; LIBS=$olibs,
- 	  LIBS="-lintl"
- 	  AC_TRY_LINK(
- 	      [#include <libintl.h>],
- 	      [gettext("Test");],
- 	      AC_MSG_RESULT([gettext() works with -lintl]); have_gettext="yes";
- 	      LIBS="$olibs -lintl",
- 	      AC_MSG_RESULT([gettext() doesn't work]);
- 	      LIBS=$olibs))
-     else
-       AC_MSG_RESULT([msgfmt not found - disabled]);
-     fi
-     if test $have_gettext = "yes" -a "x$features" != "xtiny" -a "x$features" != "xsmall"; then
-       AC_DEFINE(HAVE_GETTEXT)
-       MAKEMO=yes
-       AC_SUBST(MAKEMO)
-       dnl this was added in GNU gettext 0.10.36
-       AC_CHECK_FUNCS(bind_textdomain_codeset)
-       dnl _nl_msg_cat_cntr is required for GNU gettext
-       AC_MSG_CHECKING([for _nl_msg_cat_cntr])
-       AC_TRY_LINK(
- 		[#include <libintl.h>
- 		extern int _nl_msg_cat_cntr;],
- 		[++_nl_msg_cat_cntr;],
- 		AC_MSG_RESULT([yes]); AC_DEFINE(HAVE_NL_MSG_CAT_CNTR),
- 		AC_MSG_RESULT([no]))
-     fi
-   else
-     AC_MSG_RESULT([no "po/Makefile" - disabled]);
-   fi
- else
-   AC_MSG_RESULT(yes)
- fi
- 
- dnl Check for dynamic linking loader
- AC_CHECK_HEADER(dlfcn.h, DLL=dlfcn.h, [AC_CHECK_HEADER(dl.h, DLL=dl.h)])
- if test x${DLL} = xdlfcn.h; then
-   AC_DEFINE(HAVE_DLFCN_H, 1, [ Define if we have dlfcn.h. ])
-   AC_MSG_CHECKING([for dlopen()])
-   AC_TRY_LINK(,[
- 		extern void* dlopen();
- 		dlopen();
-       ],
-       AC_MSG_RESULT(yes);
- 	      AC_DEFINE(HAVE_DLOPEN, 1, [ Define if we have dlopen() ]),
-       AC_MSG_RESULT(no);
- 	      AC_MSG_CHECKING([for dlopen() in -ldl])
- 	      olibs=$LIBS
- 	      LIBS="$LIBS -ldl"
- 	      AC_TRY_LINK(,[
- 				extern void* dlopen();
- 				dlopen();
- 		 ],
- 		 AC_MSG_RESULT(yes);
- 			  AC_DEFINE(HAVE_DLOPEN, 1, [ Define if we have dlopen() ]),
- 		 AC_MSG_RESULT(no);
- 			  LIBS=$olibs))
-   dnl ReliantUNIX has dlopen() in libc but everything else in libdl
-   dnl ick :-)
-   AC_MSG_CHECKING([for dlsym()])
-   AC_TRY_LINK(,[
- 		extern void* dlsym();
- 		dlsym();
-       ],
-       AC_MSG_RESULT(yes);
- 	      AC_DEFINE(HAVE_DLSYM, 1, [ Define if we have dlsym() ]),
-       AC_MSG_RESULT(no);
- 	      AC_MSG_CHECKING([for dlsym() in -ldl])
- 	      olibs=$LIBS
- 	      LIBS="$LIBS -ldl"
- 	      AC_TRY_LINK(,[
- 				extern void* dlsym();
- 				dlsym();
- 		 ],
- 		 AC_MSG_RESULT(yes);
- 			  AC_DEFINE(HAVE_DLSYM, 1, [ Define if we have dlsym() ]),
- 		 AC_MSG_RESULT(no);
- 			  LIBS=$olibs))
- elif test x${DLL} = xdl.h; then
-   AC_DEFINE(HAVE_DL_H, 1, [ Define if we have dl.h. ])
-   AC_MSG_CHECKING([for shl_load()])
-   AC_TRY_LINK(,[
- 		extern void* shl_load();
- 		shl_load();
-      ],
-      AC_MSG_RESULT(yes);
- 	  AC_DEFINE(HAVE_SHL_LOAD, 1, [ Define if we have shl_load() ]),
-      AC_MSG_RESULT(no);
- 	  AC_MSG_CHECKING([for shl_load() in -ldld])
- 	  olibs=$LIBS
- 	  LIBS="$LIBS -ldld"
- 	  AC_TRY_LINK(,[
- 			extern void* shl_load();
- 			shl_load();
- 	     ],
- 	     AC_MSG_RESULT(yes);
- 		  AC_DEFINE(HAVE_SHL_LOAD, 1, [ Define if we have shl_load() ]),
- 	     AC_MSG_RESULT(no);
- 		  LIBS=$olibs))
- fi
- AC_CHECK_HEADERS(setjmp.h)
- 
- if test "x$MACOSX" = "xyes" -a -n "$PERL"; then
-   dnl -ldl must come after DynaLoader.a
-   if echo $LIBS | grep -e '-ldl' >/dev/null; then
-     LIBS=`echo $LIBS | sed s/-ldl//`
-     PERL_LIBS="$PERL_LIBS -ldl"
-   fi
- fi
- 
- if test "x$MACOSX" = "xyes"; then
-   AC_MSG_CHECKING(whether we need -framework Cocoa)
-   dnl Cocoa is needed with FEAT_CLIPBOARD or FEAT_MBYTE (the former is
-   dnl disabled during tiny build)
-   if test "x$features" != "xtiny" || test "x$enable_multibyte" = "xyes"; then
-     LIBS=$"$LIBS -framework Cocoa"
-     AC_MSG_RESULT(yes)
-   else
-     AC_MSG_RESULT(no)
-   fi
-   dnl As mentioned above, tiny build implies os_macosx.m isn't needed.  
-   dnl Exclude it from OS_EXTRA_SRC so that linker won't complain about
-   dnl missing Objective-C symbols.
-   if test "x$features" = "xtiny"; then
-     OS_EXTRA_SRC=`echo "$OS_EXTRA_SRC" | sed -e 's+os_macosx.m++'`
-     OS_EXTRA_OBJ=`echo "$OS_EXTRA_OBJ" | sed -e 's+objects/os_macosx.o++'`
-   fi
- fi
- if test "x$MACARCH" = "xboth" && test "x$GUITYPE" = "xCARBONGUI"; then
-   LDFLAGS="$LDFLAGS -isysroot $DEVELOPER_DIR/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc"
- fi
- 
- dnl gcc 3.1 changed the meaning of -MM.  The only solution appears to be to
- dnl use "-isystem" instead of "-I" for all non-Vim include dirs.
- dnl But only when making dependencies, cproto and lint don't take "-isystem".
- dnl Mac gcc returns "powerpc-apple-darwin8-gcc-4.0.1 (GCC)...", need to allow
- dnl the number before the version number.
- DEPEND_CFLAGS_FILTER=
- if test "$GCC" = yes; then
-   AC_MSG_CHECKING(for GCC 3 or later)
-   gccmajor=`echo "$gccversion" | sed -e 's/^\([[1-9]]\)\..*$/\1/g'`
-   if test "$gccmajor" -gt "2"; then
-     DEPEND_CFLAGS_FILTER="| sed 's+-I */+-isystem /+g'"
-     AC_MSG_RESULT(yes)
-   else
-     AC_MSG_RESULT(no)
-   fi
-   dnl -D_FORTIFY_SOURCE=2 crashes Vim on strcpy(buf, "000") when buf is
-   dnl declared as char x[1] but actually longer.  Introduced in gcc 4.0.
-   dnl Also remove duplicate _FORTIFY_SOURCE arguments.
-   dnl And undefine it first to avoid a warning.
-   AC_MSG_CHECKING(whether we need -D_FORTIFY_SOURCE=1)
-   if test "$gccmajor" -gt "3"; then
-     CFLAGS=`echo "$CFLAGS" | sed -e 's/ *-Wp,-D_FORTIFY_SOURCE=.//g' -e 's/ *-D_FORTIFY_SOURCE=.//g' -e 's/ *-U_FORTIFY_SOURCE//g' -e 's/$/ -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1/'`
-     AC_MSG_RESULT(yes)
-   else
-     AC_MSG_RESULT(no)
-   fi
- fi
- AC_SUBST(DEPEND_CFLAGS_FILTER)
- 
- dnl link.sh tries to avoid overlinking in a hackish way.
- dnl At least GNU ld supports --as-needed which provides the same functionality
- dnl at linker level. Let's use it.
- AC_MSG_CHECKING(linker --as-needed support)
- LINK_AS_NEEDED=
- # Check if linker supports --as-needed and --no-as-needed options
- if $CC -Wl,--help 2>/dev/null | grep as-needed > /dev/null; then
-   LDFLAGS=`echo "$LDFLAGS" | sed -e 's/ *-Wl,--as-needed//g' | sed -e 's/$/ -Wl,--as-needed/'`
-   LINK_AS_NEEDED=yes
- fi
- if test "$LINK_AS_NEEDED" = yes; then
-   AC_MSG_RESULT(yes)
- else
-   AC_MSG_RESULT(no)
- fi
- AC_SUBST(LINK_AS_NEEDED)
- 
- # IBM z/OS reset CFLAGS for config.mk
- if test "$zOSUnix" = "yes"; then
- 	CFLAGS="-D_ALL_SOURCE -Wc,float\(ieee\),dll"
- fi
- 
- dnl write output files
- AC_OUTPUT(auto/config.mk:config.mk.in)
- 
- dnl vim: set sw=2 tw=78 fo+=l:
--- 0 ----
*** ../vim-8.0.0081/src/configure.ac	2016-11-12 21:11:48.758573129 +0100
--- src/configure.ac	2016-11-12 20:10:17.939642034 +0100
***************
*** 0 ****
--- 1,4314 ----
+ dnl configure.ac: autoconf script for Vim
+ 
+ dnl Process this file with autoconf 2.12 or 2.13 to produce "configure".
+ dnl Should also work with autoconf 2.54 and later.
+ 
+ AC_INIT(vim.h)
+ AC_CONFIG_HEADER(auto/config.h:config.h.in)
+ 
+ dnl Being able to run configure means the system is Unix (compatible).
+ AC_DEFINE(UNIX)
+ AC_PROG_MAKE_SET
+ 
+ dnl Checks for programs.
+ AC_PROG_CC	dnl required by almost everything
+ AC_PROG_CPP	dnl required by header file checks
+ AC_PROGRAM_EGREP dnl required by AC_EGREP_CPP
+ AC_PROG_FGREP	dnl finds working grep -F
+ AC_ISC_POSIX	dnl required by AC_C_CROSS
+ AC_PROG_AWK	dnl required for "make html" in ../doc
+ 
+ dnl Don't strip if we don't have it
+ AC_CHECK_PROG(STRIP, strip, strip, :)
+ 
+ dnl Check for extension of executables
+ AC_EXEEXT
+ 
+ dnl Check for standard headers.  We don't use this in Vim but other stuff
+ dnl in autoconf needs it, where it uses STDC_HEADERS.
+ AC_HEADER_STDC
+ AC_HEADER_SYS_WAIT
+ 
+ dnl Check for the flag that fails if stuff are missing.
+ 
+ AC_MSG_CHECKING(--enable-fail-if-missing argument)
+ AC_ARG_ENABLE(fail_if_missing,
+ 	[  --enable-fail-if-missing    Fail if dependencies on additional features
+      specified on the command line are missing.], 
+ 	[fail_if_missing="yes"],
+ 	[fail_if_missing="no"])
+ AC_MSG_RESULT($fail_if_missing)
+ 
+ dnl Set default value for CFLAGS if none is defined or it's empty
+ if test -z "$CFLAGS"; then
+   CFLAGS="-O"
+   test "$GCC" = yes && CFLAGS="-O2 -fno-strength-reduce -Wall"
+ fi
+ if test "$GCC" = yes; then
+   dnl method that should work for nearly all versions
+   gccversion=`$CC -dumpversion`
+   if test "x$gccversion" = "x"; then
+     dnl old method; fall-back for when -dumpversion doesn't work
+     gccversion=`$CC --version | sed -e '2,$d' -e 's/darwin.//' -e 's/^[[^0-9]]*\([[0-9]]\.[[0-9.]]*\).*$/\1/g'`
+   fi
+   dnl version 4.0.1 was reported to cause trouble on Macintosh by Marcin Dalecki
+   if test "$gccversion" = "3.0.1" -o "$gccversion" = "3.0.2" -o "$gccversion" = "4.0.1"; then
+     echo 'GCC [[34]].0.[[12]] has a bug in the optimizer, disabling "-O#"'
+     CFLAGS=`echo "$CFLAGS" | sed 's/-O[[23456789]]/-O/'`
+   else
+     if test "$gccversion" = "3.1" -o "$gccversion" = "3.2" -o "$gccversion" = "3.2.1" && `echo "$CFLAGS" | grep -v fno-strength-reduce >/dev/null`; then
+       echo 'GCC 3.1 and 3.2 have a bug in the optimizer, adding "-fno-strength-reduce"'
+       CFLAGS="$CFLAGS -fno-strength-reduce"
+     fi
+   fi
+ fi
+ 
+ dnl clang-500.2.75 or around has abandoned -f[no-]strength-reduce and issues a
+ dnl warning when that flag is passed to.  Accordingly, adjust CFLAGS based on
+ dnl the version number of the clang in use.
+ dnl Note that this does not work to get the version of clang 3.1 or 3.2.
+ AC_MSG_CHECKING(for recent clang version)
+ CLANG_VERSION_STRING=`$CC --version 2>/dev/null | sed  -n -e 's/^.*clang.*\([[0-9]][[0-9]]*\.[[0-9]][[0-9]]*\.[[0-9]][[0-9]]*\).*$/\1/p'`
+ if test x"$CLANG_VERSION_STRING" != x"" ; then
+   CLANG_MAJOR=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/\([[0-9]][[0-9]]*\)\.[[0-9]][[0-9]]*\.[[0-9]][[0-9]]*/\1/p'`
+   CLANG_MINOR=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/[[0-9]][[0-9]]*\.\([[0-9]][[0-9]]*\)\.[[0-9]][[0-9]]*/\1/p'`
+   CLANG_REVISION=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/[[0-9]][[0-9]]*\.[[0-9]][[0-9]]*\.\([[0-9]][[0-9]]*\)/\1/p'`
+   CLANG_VERSION=`expr $CLANG_MAJOR '*' 1000000 '+' $CLANG_MINOR '*' 1000 '+' $CLANG_REVISION`
+   AC_MSG_RESULT($CLANG_VERSION)
+   dnl If you find the same issue with versions earlier than 500.2.75,
+   dnl change the constant 500002075 below appropriately.  To get the
+   dnl integer corresponding to a version number, refer to the
+   dnl definition of CLANG_VERSION above.
+   if test "$CLANG_VERSION" -ge 500002075 ; then
+     CFLAGS=`echo "$CFLAGS" | sed -n -e 's/-fno-strength-reduce/ /p'`
+   fi
+ else
+   AC_MSG_RESULT(no)
+ fi
+ 
+ dnl If configure thinks we are cross compiling, there might be something
+ dnl wrong with the CC or CFLAGS settings, give a useful warning message
+ CROSS_COMPILING=
+ if test "$cross_compiling" = yes; then
+   AC_MSG_RESULT([cannot compile a simple program; if not cross compiling check CC and CFLAGS])
+   CROSS_COMPILING=1
+ fi
+ AC_SUBST(CROSS_COMPILING)
+ 
+ dnl gcc-cpp has the wonderful -MM option to produce nicer dependencies.
+ dnl But gcc 3.1 changed the meaning!  See near the end.
+ test "$GCC" = yes && CPP_MM=M; AC_SUBST(CPP_MM)
+ 
+ if test -f ./toolcheck; then
+   AC_CHECKING(for buggy tools)
+   sh ./toolcheck 1>&AC_FD_MSG
+ fi
+ 
+ OS_EXTRA_SRC=""; OS_EXTRA_OBJ=""
+ 
+ dnl Check for BeOS, which needs an extra source file
+ AC_MSG_CHECKING(for BeOS)
+ case `uname` in
+     BeOS)	OS_EXTRA_SRC=os_beos.c; OS_EXTRA_OBJ=objects/os_beos.o
+ 		BEOS=yes; AC_MSG_RESULT(yes);;
+     *)		BEOS=no; AC_MSG_RESULT(no);;
+ esac
+ 
+ dnl If QNX is found, assume we don't want to use Xphoton
+ dnl unless it was specifically asked for (--with-x)
+ AC_MSG_CHECKING(for QNX)
+ case `uname` in
+     QNX)	OS_EXTRA_SRC=os_qnx.c; OS_EXTRA_OBJ=objects/os_qnx.o
+ 		test -z "$with_x" && with_x=no
+ 		QNX=yes; AC_MSG_RESULT(yes);;
+     *)		QNX=no; AC_MSG_RESULT(no);;
+ esac
+ 
+ dnl Check for Darwin and MacOS X
+ dnl We do a check for MacOS X in the very beginning because there
+ dnl are a lot of other things we need to change besides GUI stuff
+ AC_MSG_CHECKING([for Darwin (Mac OS X)])
+ if test "`(uname) 2>/dev/null`" = Darwin; then
+   AC_MSG_RESULT(yes)
+ 
+   AC_MSG_CHECKING(--disable-darwin argument)
+   AC_ARG_ENABLE(darwin,
+ 	  [  --disable-darwin        Disable Darwin (Mac OS X) support.],
+ 	  , [enable_darwin="yes"])
+   if test "$enable_darwin" = "yes"; then
+     AC_MSG_RESULT(no)
+     AC_MSG_CHECKING(if Darwin files are there)
+     if test -f os_macosx.m; then
+       AC_MSG_RESULT(yes)
+     else
+       AC_MSG_RESULT([no, Darwin support disabled])
+       enable_darwin=no
+     fi
+   else
+     AC_MSG_RESULT([yes, Darwin support excluded])
+   fi
+ 
+   AC_MSG_CHECKING(--with-mac-arch argument)
+   AC_ARG_WITH(mac-arch, [  --with-mac-arch=ARCH    current, intel, ppc or both],
+ 	MACARCH="$withval"; AC_MSG_RESULT($MACARCH),
+ 	MACARCH="current"; AC_MSG_RESULT(defaulting to $MACARCH))
+ 
+   AC_MSG_CHECKING(--with-developer-dir argument)
+   AC_ARG_WITH(developer-dir, [  --with-developer-dir=PATH    use PATH as location for Xcode developer tools],
+ 	DEVELOPER_DIR="$withval"; AC_MSG_RESULT($DEVELOPER_DIR),
+         AC_MSG_RESULT(not present))
+   
+   if test "x$DEVELOPER_DIR" = "x"; then
+     AC_PATH_PROG(XCODE_SELECT, xcode-select)
+     if test "x$XCODE_SELECT" != "x"; then
+       AC_MSG_CHECKING(for developer dir using xcode-select)
+       DEVELOPER_DIR=`$XCODE_SELECT -print-path`
+       AC_MSG_RESULT([$DEVELOPER_DIR])
+     else
+       DEVELOPER_DIR=/Developer
+     fi
+   fi
+ 
+   if test "x$MACARCH" = "xboth"; then
+     AC_MSG_CHECKING(for 10.4 universal SDK)
+     dnl There is a terrible inconsistency (but we appear to get away with it):
+     dnl $CFLAGS uses the 10.4u SDK library for the headers, while $CPPFLAGS
+     dnl doesn't, because "gcc -E" doesn't grok it.  That means the configure
+     dnl tests using the preprocessor are actually done with the wrong header
+     dnl files. $LDFLAGS is set at the end, because configure uses it together
+     dnl with $CFLAGS and we can only have one -sysroot argument.
+     save_cppflags="$CPPFLAGS"
+     save_cflags="$CFLAGS"
+     save_ldflags="$LDFLAGS"
+     CFLAGS="$CFLAGS -isysroot $DEVELOPER_DIR/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc"
+     AC_TRY_LINK([ ], [ ],
+ 	AC_MSG_RESULT(found, will make universal binary),
+ 
+ 	AC_MSG_RESULT(not found)
+ 	CFLAGS="$save_cflags"
+ 	AC_MSG_CHECKING(if Intel architecture is supported)
+ 	CPPFLAGS="$CPPFLAGS -arch i386"
+ 	LDFLAGS="$save_ldflags -arch i386"
+ 	AC_TRY_LINK([ ], [ ],
+ 	    AC_MSG_RESULT(yes); MACARCH="intel",
+ 	    AC_MSG_RESULT(no, using PowerPC)
+ 		MACARCH="ppc"
+ 		CPPFLAGS="$save_cppflags -arch ppc"
+ 		LDFLAGS="$save_ldflags -arch ppc"))
+   elif test "x$MACARCH" = "xintel"; then
+     CPPFLAGS="$CPPFLAGS -arch intel"
+     LDFLAGS="$LDFLAGS -arch intel"
+   elif test "x$MACARCH" = "xppc"; then
+     CPPFLAGS="$CPPFLAGS -arch ppc"
+     LDFLAGS="$LDFLAGS -arch ppc"
+   fi
+ 
+   if test "$enable_darwin" = "yes"; then
+     MACOSX=yes
+     OS_EXTRA_SRC="os_macosx.m os_mac_conv.c";
+     OS_EXTRA_OBJ="objects/os_macosx.o objects/os_mac_conv.o"
+     dnl TODO: use -arch i386 on Intel machines
+     dnl Removed -no-cpp-precomp, only for very old compilers.
+     CPPFLAGS="$CPPFLAGS -DMACOS_X_UNIX"
+ 
+     dnl If Carbon is found, assume we don't want X11
+     dnl unless it was specifically asked for (--with-x)
+     dnl or Motif, Athena or GTK GUI is used.
+     AC_CHECK_HEADER(Carbon/Carbon.h, CARBON=yes)
+     if test "x$CARBON" = "xyes"; then
+       if test -z "$with_x" -a "X$enable_gui" != Xmotif -a "X$enable_gui" != Xathena -a "X$enable_gui" != Xgtk2 -a "X$enable_gui" != Xgtk3; then
+ 	with_x=no
+       fi
+     fi
+   fi
+ 
+   dnl Avoid a bug with -O2 with gcc 4.0.1.  Symptom: malloc() reports double
+   dnl free.  This happens in expand_filename(), because the optimizer swaps
+   dnl two blocks of code, both using "repl", that can't be swapped.
+   if test "$MACARCH" = "intel" -o "$MACARCH" = "both"; then
+     CFLAGS=`echo "$CFLAGS" | sed 's/-O[[23456789]]/-Oz/'`
+   fi
+ 
+ else
+   AC_MSG_RESULT(no)
+ fi
+ 
+ dnl Mac OS X 10.9+ no longer include AvailabilityMacros.h in Carbon
+ dnl so we need to include it to have access to version macros.
+ AC_CHECK_HEADERS(AvailabilityMacros.h)
+ 
+ AC_SUBST(OS_EXTRA_SRC)
+ AC_SUBST(OS_EXTRA_OBJ)
+ 
+ dnl Add /usr/local/lib to $LDFLAGS and /usr/local/include to CFLAGS.
+ dnl Only when the directory exists and it wasn't there yet.
+ dnl For gcc don't do this when it is already in the default search path.
+ dnl Skip all of this when cross-compiling.
+ if test "$cross_compiling" = no; then
+   AC_MSG_CHECKING(--with-local-dir argument)
+   have_local_include=''
+   have_local_lib=''
+   AC_ARG_WITH([local-dir], [  --with-local-dir=PATH   search PATH instead of /usr/local for local libraries.
+   --without-local-dir     do not search /usr/local for local libraries.], [
+     local_dir="$withval"
+     case "$withval" in
+     */*) ;;
+     no)
+       # avoid adding local dir to LDFLAGS and CPPFLAGS
+       have_local_include=yes
+       have_local_lib=yes
+       ;;
+     *) AC_MSG_ERROR(must pass path argument to --with-local-dir) ;;
+     esac
+ 	AC_MSG_RESULT($local_dir)
+   ], [
+     local_dir=/usr/local
+     AC_MSG_RESULT(Defaulting to $local_dir)
+   ])
+   if test "$GCC" = yes -a "$local_dir" != no; then
+     echo 'void f(){}' > conftest.c
+     dnl Removed -no-cpp-precomp, only needed for OS X 10.2 (Ben Fowler)
+     have_local_include=`${CC-cc} -c -v conftest.c 2>&1 | grep "${local_dir}/include"`
+     have_local_lib=`${CC-cc} -c -v conftest.c 2>&1 | grep "${local_dir}/lib"`
+     rm -f conftest.c conftest.o
+   fi
+   if test -z "$have_local_lib" -a -d "${local_dir}/lib"; then
+     tt=`echo "$LDFLAGS" | sed -e "s+-L${local_dir}/lib ++g" -e "s+-L${local_dir}/lib$++g"`
+     if test "$tt" = "$LDFLAGS"; then
+       LDFLAGS="$LDFLAGS -L${local_dir}/lib"
+     fi
+   fi
+   if test -z "$have_local_include" -a -d "${local_dir}/include"; then
+     tt=`echo "$CPPFLAGS" | sed -e "s+-I${local_dir}/include ++g" -e "s+-I${local_dir}/include$++g"`
+     if test "$tt" = "$CPPFLAGS"; then
+       CPPFLAGS="$CPPFLAGS -I${local_dir}/include"
+     fi
+   fi
+ fi
+ 
+ AC_MSG_CHECKING(--with-vim-name argument)
+ AC_ARG_WITH(vim-name, [  --with-vim-name=NAME    what to call the Vim executable],
+ 	VIMNAME="$withval"; AC_MSG_RESULT($VIMNAME),
+ 	VIMNAME="vim"; AC_MSG_RESULT(Defaulting to $VIMNAME))
+ AC_SUBST(VIMNAME)
+ AC_MSG_CHECKING(--with-ex-name argument)
+ AC_ARG_WITH(ex-name, [  --with-ex-name=NAME     what to call the Ex executable],
+ 	EXNAME="$withval"; AC_MSG_RESULT($EXNAME),
+ 	EXNAME="ex"; AC_MSG_RESULT(Defaulting to ex))
+ AC_SUBST(EXNAME)
+ AC_MSG_CHECKING(--with-view-name argument)
+ AC_ARG_WITH(view-name, [  --with-view-name=NAME   what to call the View executable],
+ 	VIEWNAME="$withval"; AC_MSG_RESULT($VIEWNAME),
+ 	VIEWNAME="view"; AC_MSG_RESULT(Defaulting to view))
+ AC_SUBST(VIEWNAME)
+ 
+ AC_MSG_CHECKING(--with-global-runtime argument)
+ AC_ARG_WITH(global-runtime, [  --with-global-runtime=DIR    global runtime directory in 'runtimepath'],
+ 	AC_MSG_RESULT($withval); AC_DEFINE_UNQUOTED(RUNTIME_GLOBAL, "$withval"),
+ 	AC_MSG_RESULT(no))
+ 
+ AC_MSG_CHECKING(--with-modified-by argument)
+ AC_ARG_WITH(modified-by, [  --with-modified-by=NAME       name of who modified a release version],
+ 	AC_MSG_RESULT($withval); AC_DEFINE_UNQUOTED(MODIFIED_BY, "$withval"),
+ 	AC_MSG_RESULT(no))
+ 
+ dnl Check for EBCDIC stolen from the LYNX port to z/OS Unix
+ AC_MSG_CHECKING(if character set is EBCDIC)
+ AC_TRY_COMPILE([ ],
+ [ /* TryCompile function for CharSet.
+    Treat any failure as ASCII for compatibility with existing art.
+    Use compile-time rather than run-time tests for cross-compiler
+    tolerance.  */
+ #if '0'!=240
+ make an error "Character set is not EBCDIC"
+ #endif ],
+ [ # TryCompile action if true
+ cf_cv_ebcdic=yes ],
+ [ # TryCompile action if false
+ cf_cv_ebcdic=no])
+ # end of TryCompile ])
+ # end of CacheVal CvEbcdic
+ AC_MSG_RESULT($cf_cv_ebcdic)
+ case "$cf_cv_ebcdic" in  #(vi
+     yes)	AC_DEFINE(EBCDIC)
+ 		line_break='"\\n"'
+ 		;;
+     *)		line_break='"\\012"';;
+ esac
+ AC_SUBST(line_break)
+ 
+ if test "$cf_cv_ebcdic" = "yes"; then
+ dnl If we have EBCDIC we most likely have z/OS Unix, let's test it!
+ AC_MSG_CHECKING(for z/OS Unix)
+ case `uname` in
+     OS/390)	zOSUnix="yes";
+ 		dnl If using cc the environment variable _CC_CCMODE must be
+ 		dnl set to "1", so that some compiler extensions are enabled.
+ 		dnl If using c89 the environment variable is named _CC_C89MODE.
+ 		dnl Note: compile with c89 never tested.
+ 		if test "$CC" = "cc"; then
+ 		  ccm="$_CC_CCMODE"
+ 		  ccn="CC"
+ 		else
+ 		  if test "$CC" = "c89"; then
+ 		    ccm="$_CC_C89MODE"
+ 		    ccn="C89"
+ 		  else
+ 		    ccm=1
+ 		  fi
+ 		fi
+ 		if test "$ccm" != "1"; then
+ 		  echo ""
+ 		  echo "------------------------------------------"
+ 		  echo " On z/OS Unix, the environment variable"
+ 		  echo " _CC_${ccn}MODE must be set to \"1\"!"
+ 		  echo " Do:"
+ 		  echo "    export _CC_${ccn}MODE=1"
+ 		  echo " and then call configure again."
+ 		  echo "------------------------------------------"
+ 		  exit 1
+ 		fi
+ 		# Set CFLAGS for configure process.
+ 		# This will be reset later for config.mk.
+ 		# Use haltonmsg to force error for missing H files.
+ 		CFLAGS="$CFLAGS -D_ALL_SOURCE -Wc,float(ieee),haltonmsg(3296)";
+ 		LDFLAGS="$LDFLAGS -Wl,EDIT=NO"
+ 		AC_MSG_RESULT(yes)
+ 		;;
+     *)		zOSUnix="no";
+ 		AC_MSG_RESULT(no)
+ 		;;
+ esac
+ fi
+ 
+ dnl Set QUOTESED. Needs additional backslashes on zOS
+ if test "$zOSUnix" = "yes"; then
+     QUOTESED="sed -e 's/[[\\\\\"]]/\\\\\\\\&/g' -e 's/\\\\\\\\\"/\"/' -e 's/\\\\\\\\\";\$\$/\";/'"
+ else
+     QUOTESED="sed -e 's/[[\\\\\"]]/\\\\&/g' -e 's/\\\\\"/\"/' -e 's/\\\\\";\$\$/\";/'"
+ fi
+ AC_SUBST(QUOTESED)
+ 
+ 
+ dnl Link with -lsmack for Smack stuff; if not found
+ AC_MSG_CHECKING(--disable-smack argument)
+ AC_ARG_ENABLE(smack,
+ 	[  --disable-smack	  Do not check for Smack support.],
+ 	, enable_smack="yes")
+ if test "$enable_smack" = "yes"; then
+   AC_MSG_RESULT(no)
+   AC_CHECK_HEADER([linux/xattr.h], true, enable_smack="no")
+ else
+   AC_MSG_RESULT(yes)
+ fi
+ if test "$enable_smack" = "yes"; then
+   AC_CHECK_HEADER([attr/xattr.h], true, enable_smack="no")
+ fi
+ if test "$enable_smack" = "yes"; then
+   AC_MSG_CHECKING(for XATTR_NAME_SMACKEXEC in linux/xattr.h)
+   AC_EGREP_CPP(XATTR_NAME_SMACKEXEC, [#include <linux/xattr.h>],
+ 	       AC_MSG_RESULT(yes),
+ 	       AC_MSG_RESULT(no); enable_smack="no")
+ fi
+ if test "$enable_smack" = "yes"; then
+   AC_CHECK_LIB(attr, setxattr,
+ 	  [LIBS="$LIBS -lattr"
+ 	   found_smack="yes"
+ 	   AC_DEFINE(HAVE_SMACK)])
+ fi
+ 
+ dnl When smack was found don't search for SELinux
+ if test "x$found_smack" = "x"; then
+   dnl Link with -lselinux for SELinux stuff; if not found
+   AC_MSG_CHECKING(--disable-selinux argument)
+   AC_ARG_ENABLE(selinux,
+ 	  [  --disable-selinux	  Do not check for SELinux support.],
+ 	  , enable_selinux="yes")
+   if test "$enable_selinux" = "yes"; then
+     AC_MSG_RESULT(no)
+     AC_CHECK_LIB(selinux, is_selinux_enabled,
+ 	    [LIBS="$LIBS -lselinux"
+ 	     AC_DEFINE(HAVE_SELINUX)])
+   else
+      AC_MSG_RESULT(yes)
+   fi
+ fi
+ 
+ dnl Check user requested features.
+ 
+ AC_MSG_CHECKING(--with-features argument)
+ AC_ARG_WITH(features, [  --with-features=TYPE    tiny, small, normal, big or huge (default: huge)],
+ 	features="$withval"; AC_MSG_RESULT($features),
+ 	features="huge"; AC_MSG_RESULT(Defaulting to huge))
+ 
+ dovimdiff=""
+ dogvimdiff=""
+ case "$features" in
+   tiny)		AC_DEFINE(FEAT_TINY) ;;
+   small)	AC_DEFINE(FEAT_SMALL) ;;
+   normal)	AC_DEFINE(FEAT_NORMAL) dovimdiff="installvimdiff";
+ 			dogvimdiff="installgvimdiff" ;;
+   big)		AC_DEFINE(FEAT_BIG) dovimdiff="installvimdiff";
+ 			dogvimdiff="installgvimdiff" ;;
+   huge)		AC_DEFINE(FEAT_HUGE) dovimdiff="installvimdiff";
+ 			dogvimdiff="installgvimdiff" ;;
+   *)		AC_MSG_RESULT([Sorry, $features is not supported]) ;;
+ esac
+ 
+ AC_SUBST(dovimdiff)
+ AC_SUBST(dogvimdiff)
+ 
+ AC_MSG_CHECKING(--with-compiledby argument)
+ AC_ARG_WITH(compiledby, [  --with-compiledby=NAME  name to show in :version message],
+ 	compiledby="$withval"; AC_MSG_RESULT($withval),
+ 	compiledby=""; AC_MSG_RESULT(no))
+ AC_SUBST(compiledby)
+ 
+ AC_MSG_CHECKING(--disable-xsmp argument)
+ AC_ARG_ENABLE(xsmp,
+ 	[  --disable-xsmp          Disable XSMP session management],
+ 	, enable_xsmp="yes")
+ 
+ if test "$enable_xsmp" = "yes"; then
+   AC_MSG_RESULT(no)
+   AC_MSG_CHECKING(--disable-xsmp-interact argument)
+   AC_ARG_ENABLE(xsmp-interact,
+ 	  [  --disable-xsmp-interact Disable XSMP interaction],
+ 	  , enable_xsmp_interact="yes")
+   if test "$enable_xsmp_interact" = "yes"; then
+     AC_MSG_RESULT(no)
+     AC_DEFINE(USE_XSMP_INTERACT)
+   else
+     AC_MSG_RESULT(yes)
+   fi
+ else
+   AC_MSG_RESULT(yes)
+ fi
+ 
+ dnl Check for Lua feature.
+ AC_MSG_CHECKING(--enable-luainterp argument)
+ AC_ARG_ENABLE(luainterp,
+ 	[  --enable-luainterp[=OPTS]     Include Lua interpreter.  [default=no] [OPTS=no/yes/dynamic]], ,
+ 	[enable_luainterp="no"])
+ AC_MSG_RESULT($enable_luainterp)
+ 
+ if test "$enable_luainterp" = "yes" -o "$enable_luainterp" = "dynamic"; then
+   if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
+     AC_MSG_ERROR([cannot use Lua with tiny or small features])
+   fi
+ 
+   dnl -- find the lua executable
+   AC_SUBST(vi_cv_path_lua)
+ 
+   AC_MSG_CHECKING(--with-lua-prefix argument)
+   AC_ARG_WITH(lua_prefix,
+ 	[  --with-lua-prefix=PFX   Prefix where Lua is installed.],
+ 	with_lua_prefix="$withval"; AC_MSG_RESULT($with_lua_prefix),
+ 	with_lua_prefix="";AC_MSG_RESULT(no))
+ 
+   if test "X$with_lua_prefix" != "X"; then
+        vi_cv_path_lua_pfx="$with_lua_prefix"
+   else
+     AC_MSG_CHECKING(LUA_PREFIX environment var)
+     if test "X$LUA_PREFIX" != "X"; then
+ 	AC_MSG_RESULT("$LUA_PREFIX")
+ 	vi_cv_path_lua_pfx="$LUA_PREFIX"
+     else
+ 	AC_MSG_RESULT([not set, default to /usr])
+ 	vi_cv_path_lua_pfx="/usr"
+     fi
+   fi
+ 
+   AC_MSG_CHECKING(--with-luajit)
+   AC_ARG_WITH(luajit,
+ 	[  --with-luajit           Link with LuaJIT instead of Lua.],
+ 	[vi_cv_with_luajit="$withval"],
+ 	[vi_cv_with_luajit="no"])
+   AC_MSG_RESULT($vi_cv_with_luajit)
+ 
+   LUA_INC=
+   if test "X$vi_cv_path_lua_pfx" != "X"; then
+     if test "x$vi_cv_with_luajit" != "xno"; then
+       dnl -- try to find LuaJIT executable
+       AC_PATH_PROG(vi_cv_path_luajit, luajit)
+       if test "X$vi_cv_path_luajit" != "X"; then
+ 	dnl -- find LuaJIT version
+ 	AC_CACHE_CHECK(LuaJIT version, vi_cv_version_luajit,
+ 	[ vi_cv_version_luajit=`${vi_cv_path_luajit} -v 2>&1 | sed 's/LuaJIT \([[0-9.]]*\)\.[[0-9]]\(-[[a-z0-9]]*\)* .*/\1/'` ])
+ 	AC_CACHE_CHECK(Lua version of LuaJIT, vi_cv_version_lua_luajit,
+ 	[ vi_cv_version_lua_luajit=`${vi_cv_path_luajit} -e "print(_VERSION)" | sed 's/.* //'` ])
+ 	vi_cv_path_lua="$vi_cv_path_luajit"
+ 	vi_cv_version_lua="$vi_cv_version_lua_luajit"
+       fi
+     else
+       dnl -- try to find Lua executable
+       AC_PATH_PROG(vi_cv_path_plain_lua, lua)
+       if test "X$vi_cv_path_plain_lua" != "X"; then
+ 	dnl -- find Lua version
+ 	AC_CACHE_CHECK(Lua version, vi_cv_version_plain_lua,
+ 	[ vi_cv_version_plain_lua=`${vi_cv_path_plain_lua} -e "print(_VERSION)" | sed 's/.* //'` ])
+       fi
+       vi_cv_path_lua="$vi_cv_path_plain_lua"
+       vi_cv_version_lua="$vi_cv_version_plain_lua"
+     fi
+     if test "x$vi_cv_with_luajit" != "xno" && test "X$vi_cv_version_luajit" != "X"; then
+       AC_MSG_CHECKING(if lua.h can be found in $vi_cv_path_lua_pfx/include/luajit-$vi_cv_version_luajit)
+       if test -f "$vi_cv_path_lua_pfx/include/luajit-$vi_cv_version_luajit/lua.h"; then
+ 	AC_MSG_RESULT(yes)
+ 	LUA_INC=/luajit-$vi_cv_version_luajit
+       fi
+     fi
+     if test "X$LUA_INC" = "X"; then
+       AC_MSG_CHECKING(if lua.h can be found in $vi_cv_path_lua_pfx/include)
+       if test -f "$vi_cv_path_lua_pfx/include/lua.h"; then
+ 	AC_MSG_RESULT(yes)
+       else
+ 	AC_MSG_RESULT(no)
+ 	AC_MSG_CHECKING(if lua.h can be found in $vi_cv_path_lua_pfx/include/lua$vi_cv_version_lua)
+ 	if test -f "$vi_cv_path_lua_pfx/include/lua$vi_cv_version_lua/lua.h"; then
+ 	  AC_MSG_RESULT(yes)
+ 	  LUA_INC=/lua$vi_cv_version_lua
+ 	else
+ 	  AC_MSG_RESULT(no)
+ 	  vi_cv_path_lua_pfx=
+ 	fi
+       fi
+     fi
+   fi
+ 
+   if test "X$vi_cv_path_lua_pfx" != "X"; then
+     if test "x$vi_cv_with_luajit" != "xno"; then
+       multiarch=`dpkg-architecture -qDEB_HOST_MULTIARCH 2> /dev/null`
+       if test "X$multiarch" != "X"; then
+ 	lib_multiarch="lib/${multiarch}"
+       else
+ 	lib_multiarch="lib"
+       fi
+       if test "X$vi_cv_version_lua" = "X"; then
+ 	LUA_LIBS="-L${vi_cv_path_lua_pfx}/${lib_multiarch} -lluajit"
+       else
+ 	LUA_LIBS="-L${vi_cv_path_lua_pfx}/${lib_multiarch} -lluajit-$vi_cv_version_lua"
+       fi
+     else
+       if test "X$LUA_INC" != "X"; then
+ 	dnl Test alternate location using version
+ 	LUA_LIBS="-L${vi_cv_path_lua_pfx}/lib -llua$vi_cv_version_lua"
+       else
+ 	LUA_LIBS="-L${vi_cv_path_lua_pfx}/lib -llua"
+       fi
+     fi
+     if test "$enable_luainterp" = "dynamic"; then
+       lua_ok="yes"
+     else
+       AC_MSG_CHECKING([if link with ${LUA_LIBS} is sane])
+       libs_save=$LIBS
+       LIBS="$LIBS $LUA_LIBS"
+       AC_TRY_LINK(,[ ],
+ 	AC_MSG_RESULT(yes); lua_ok="yes",
+ 	AC_MSG_RESULT(no); lua_ok="no"; LUA_LIBS="")
+       LIBS=$libs_save
+     fi
+     if test "x$lua_ok" = "xyes"; then
+       LUA_CFLAGS="-I${vi_cv_path_lua_pfx}/include${LUA_INC}"
+       LUA_SRC="if_lua.c"
+       LUA_OBJ="objects/if_lua.o"
+       LUA_PRO="if_lua.pro"
+       AC_DEFINE(FEAT_LUA)
+     fi
+     if test "$enable_luainterp" = "dynamic"; then
+       if test "x$vi_cv_with_luajit" != "xno"; then
+ 	luajit="jit"
+       fi
+       if test -f "${vi_cv_path_lua_pfx}/bin/cyglua-${vi_cv_version_lua}.dll"; then
+ 	vi_cv_dll_name_lua="cyglua-${vi_cv_version_lua}.dll"
+       else
+ 	if test "x$MACOSX" = "xyes"; then
+ 	  ext="dylib"
+ 	  indexes=""
+ 	else
+ 	  ext="so"
+ 	  indexes=".0 .1 .2 .3 .4 .5 .6 .7 .8 .9"
+ 	  multiarch=`dpkg-architecture -qDEB_HOST_MULTIARCH 2> /dev/null`
+ 	  if test "X$multiarch" != "X"; then
+ 	    lib_multiarch="lib/${multiarch}"
+ 	  fi
+ 	fi
+ 	dnl Determine the sover for the current version, but fallback to
+ 	dnl liblua${vi_cv_version_lua}.so if no sover-versioned file is found.
+ 	AC_MSG_CHECKING(if liblua${luajit}*.${ext}* can be found in $vi_cv_path_lua_pfx)
+ 	for subdir in "${lib_multiarch}" lib64 lib; do
+ 	  if test -z "$subdir"; then
+ 	    continue
+ 	  fi
+ 	  for sover in "${vi_cv_version_lua}.${ext}" "-${vi_cv_version_lua}.${ext}" \
+ 	    ".${vi_cv_version_lua}.${ext}" ".${ext}.${vi_cv_version_lua}"; do
+ 	    for i in $indexes ""; do
+ 	      if test -f "${vi_cv_path_lua_pfx}/${subdir}/liblua${luajit}${sover}$i"; then
+ 		sover2="$i"
+ 		break 3
+ 	      fi
+ 	    done
+ 	  done
+ 	  sover=""
+ 	done
+ 	if test "X$sover" = "X"; then
+ 	  AC_MSG_RESULT(no)
+ 	  lua_ok="no"
+ 	  vi_cv_dll_name_lua="liblua${luajit}.${ext}"
+ 	else
+ 	  AC_MSG_RESULT(yes)
+ 	  lua_ok="yes"
+ 	  vi_cv_dll_name_lua="liblua${luajit}${sover}$sover2"
+ 	fi
+       fi
+       AC_DEFINE(DYNAMIC_LUA)
+       LUA_LIBS=""
+       LUA_CFLAGS="-DDYNAMIC_LUA_DLL=\\\"${vi_cv_dll_name_lua}\\\" $LUA_CFLAGS"
+     fi
+     if test "X$LUA_CFLAGS$LUA_LIBS" != "X" && \
+        test "x$MACOSX" = "xyes" && test "x$vi_cv_with_luajit" != "xno" && \
+        test "`(uname -m) 2>/dev/null`" = "x86_64"; then
+       dnl OSX/x64 requires these flags. See http://luajit.org/install.html
+       LUA_LIBS="-pagezero_size 10000 -image_base 100000000 $LUA_LIBS"
+     fi
+   fi
+   if test "$fail_if_missing" = "yes" -a "$lua_ok" != "yes"; then
+     AC_MSG_ERROR([could not configure lua])
+   fi
+   AC_SUBST(LUA_SRC)
+   AC_SUBST(LUA_OBJ)
+   AC_SUBST(LUA_PRO)
+   AC_SUBST(LUA_LIBS)
+   AC_SUBST(LUA_CFLAGS)
+ fi
+ 
+ 
+ dnl Check for MzScheme feature.
+ AC_MSG_CHECKING(--enable-mzschemeinterp argument)
+ AC_ARG_ENABLE(mzschemeinterp,
+ 	[  --enable-mzschemeinterp   Include MzScheme interpreter.], ,
+ 	[enable_mzschemeinterp="no"])
+ AC_MSG_RESULT($enable_mzschemeinterp)
+ 
+ if test "$enable_mzschemeinterp" = "yes"; then
+   dnl -- find the mzscheme executable
+   AC_SUBST(vi_cv_path_mzscheme)
+ 
+   AC_MSG_CHECKING(--with-plthome argument)
+   AC_ARG_WITH(plthome,
+ 	[  --with-plthome=PLTHOME   Use PLTHOME.],
+ 	with_plthome="$withval"; AC_MSG_RESULT($with_plthome),
+ 	with_plthome="";AC_MSG_RESULT("no"))
+ 
+   if test "X$with_plthome" != "X"; then
+        vi_cv_path_mzscheme_pfx="$with_plthome"
+        vi_cv_path_mzscheme="${vi_cv_path_mzscheme_pfx}/bin/mzscheme"
+   else
+     AC_MSG_CHECKING(PLTHOME environment var)
+     if test "X$PLTHOME" != "X"; then
+ 	AC_MSG_RESULT("$PLTHOME")
+ 	vi_cv_path_mzscheme_pfx="$PLTHOME"
+ 	vi_cv_path_mzscheme="${vi_cv_path_mzscheme_pfx}/bin/mzscheme"
+     else
+ 	AC_MSG_RESULT(not set)
+ 	dnl -- try to find MzScheme executable
+ 	AC_PATH_PROG(vi_cv_path_mzscheme, mzscheme)
+ 
+ 	dnl resolve symbolic link, the executable is often elsewhere and there
+ 	dnl are no links for the include files.
+ 	if test "X$vi_cv_path_mzscheme" != "X"; then
+ 	  lsout=`ls -l $vi_cv_path_mzscheme`
+ 	  if echo "$lsout" | grep -e '->' >/dev/null 2>/dev/null; then
+ 	    vi_cv_path_mzscheme=`echo "$lsout" | sed 's/.*-> \(.*\)/\1/'`
+ 	  fi
+ 	fi
+ 
+ 	if test "X$vi_cv_path_mzscheme" != "X"; then
+ 	    dnl -- find where MzScheme thinks it was installed
+ 	    AC_CACHE_CHECK(MzScheme install prefix,vi_cv_path_mzscheme_pfx,
+ 	    dnl different versions of MzScheme differ in command line processing
+ 	    dnl use universal approach
+ 	    echo "(display (simplify-path		\
+ 	       (build-path (call-with-values	\
+ 		(lambda () (split-path (find-system-path (quote exec-file)))) \
+ 		(lambda (base name must-be-dir?) base)) (quote up))))" > mzdirs.scm
+ 	    dnl Remove a trailing slash
+ 	    [ vi_cv_path_mzscheme_pfx=`${vi_cv_path_mzscheme} -r mzdirs.scm | \
+ 		sed -e 's+/$++'` ])
+ 	    rm -f mzdirs.scm
+ 	fi
+     fi
+   fi
+ 
+   if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
+     AC_MSG_CHECKING(for racket include directory)
+     SCHEME_INC=`${vi_cv_path_mzscheme} -e '(require setup/dirs)(let ((p (find-include-dir))) (when (path? p) (display p)))'`
+     if test "X$SCHEME_INC" != "X"; then
+       AC_MSG_RESULT(${SCHEME_INC})
+     else
+       AC_MSG_RESULT(not found)
+       AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include)
+       if test -f "$vi_cv_path_mzscheme_pfx/include/scheme.h"; then
+ 	SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include
+ 	AC_MSG_RESULT(yes)
+       else
+ 	AC_MSG_RESULT(no)
+ 	AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/plt)
+ 	if test -f "$vi_cv_path_mzscheme_pfx/include/plt/scheme.h"; then
+ 	  AC_MSG_RESULT(yes)
+ 	  SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include/plt
+ 	else
+ 	  AC_MSG_RESULT(no)
+ 	  AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/racket)
+ 	  if test -f "$vi_cv_path_mzscheme_pfx/include/racket/scheme.h"; then
+ 	    AC_MSG_RESULT(yes)
+ 	    SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include/racket
+ 	  else
+ 	    AC_MSG_RESULT(no)
+ 	    AC_MSG_CHECKING(if scheme.h can be found in /usr/include/plt/)
+ 	    if test -f /usr/include/plt/scheme.h; then
+ 	      AC_MSG_RESULT(yes)
+ 	      SCHEME_INC=/usr/include/plt
+ 	    else
+ 	      AC_MSG_RESULT(no)
+ 	      AC_MSG_CHECKING(if scheme.h can be found in /usr/include/racket/)
+ 	      if test -f /usr/include/racket/scheme.h; then
+ 		AC_MSG_RESULT(yes)
+ 		SCHEME_INC=/usr/include/racket
+ 	      else
+ 		AC_MSG_RESULT(no)
+ 		vi_cv_path_mzscheme_pfx=
+ 	      fi
+ 	    fi
+ 	  fi
+ 	fi
+       fi
+     fi
+   fi
+ 
+   if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
+ 
+     AC_MSG_CHECKING(for racket lib directory)
+     SCHEME_LIB=`${vi_cv_path_mzscheme} -e '(require setup/dirs)(let ((p (find-lib-dir))) (when (path? p) (display p)))'`
+     if test "X$SCHEME_LIB" != "X"; then
+       AC_MSG_RESULT(${SCHEME_LIB})
+     else
+       AC_MSG_RESULT(not found)
+     fi
+ 
+     for path in "${vi_cv_path_mzscheme_pfx}/lib" "${SCHEME_LIB}"; do
+       if test "X$path" != "X"; then
+ 	if test "x$MACOSX" = "xyes"; then
+ 	  MZSCHEME_LIBS="-framework Racket"
+ 	  MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+ 	elif test -f "${path}/libmzscheme3m.a"; then
+ 	  MZSCHEME_LIBS="${path}/libmzscheme3m.a"
+ 	  MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+ 	elif test -f "${path}/libracket3m.a"; then
+ 	  MZSCHEME_LIBS="${path}/libracket3m.a"
+ 	  MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+ 	elif test -f "${path}/libracket.a"; then
+ 	  MZSCHEME_LIBS="${path}/libracket.a ${path}/libmzgc.a"
+ 	elif test -f "${path}/libmzscheme.a"; then
+ 	  MZSCHEME_LIBS="${path}/libmzscheme.a ${path}/libmzgc.a"
+ 	else
+ 	  dnl Using shared objects
+ 	  if test -f "${path}/libmzscheme3m.so"; then
+ 	    MZSCHEME_LIBS="-L${path} -lmzscheme3m"
+ 	    MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+ 	  elif test -f "${path}/libracket3m.so"; then
+ 	    MZSCHEME_LIBS="-L${path} -lracket3m"
+ 	    MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+ 	  elif test -f "${path}/libracket.so"; then
+ 	    MZSCHEME_LIBS="-L${path} -lracket -lmzgc"
+ 	  else
+ 	    dnl try next until last
+ 	    if test "$path" != "$SCHEME_LIB"; then
+ 	      continue
+ 	    fi
+ 	    MZSCHEME_LIBS="-L${path} -lmzscheme -lmzgc"
+ 	  fi
+ 	  if test "$GCC" = yes; then
+ 	    dnl Make Vim remember the path to the library.  For when it's not in
+ 	    dnl $LD_LIBRARY_PATH.
+ 	    MZSCHEME_LIBS="${MZSCHEME_LIBS} -Wl,-rpath -Wl,${path}"
+ 	  elif test "`(uname) 2>/dev/null`" = SunOS &&
+ 				   uname -r | grep '^5' >/dev/null; then
+ 	    MZSCHEME_LIBS="${MZSCHEME_LIBS} -R ${path}"
+ 	  fi
+ 	fi
+       fi
+       if test "X$MZSCHEME_LIBS" != "X"; then
+ 	break
+       fi
+     done
+ 
+     AC_MSG_CHECKING([if racket requires -pthread])
+     if test "X$SCHEME_LIB" != "X" && $FGREP -e -pthread "$SCHEME_LIB/buildinfo" >/dev/null ; then
+       AC_MSG_RESULT(yes)
+       MZSCHEME_LIBS="${MZSCHEME_LIBS} -pthread"
+       MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -pthread"
+     else
+       AC_MSG_RESULT(no)
+     fi
+ 
+     AC_MSG_CHECKING(for racket config directory)
+     SCHEME_CONFIGDIR=`${vi_cv_path_mzscheme} -e '(require setup/dirs)(let ((p (find-config-dir))) (when (path? p) (display p)))'`
+     if test "X$SCHEME_CONFIGDIR" != "X"; then
+       MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -DMZSCHEME_CONFIGDIR='\"${SCHEME_CONFIGDIR}\"'"
+       AC_MSG_RESULT(${SCHEME_CONFIGDIR})
+     else
+       AC_MSG_RESULT(not found)
+     fi
+ 
+     AC_MSG_CHECKING(for racket collects directory)
+     SCHEME_COLLECTS=`${vi_cv_path_mzscheme} -e '(require setup/dirs)(let ((p (find-collects-dir))) (when (path? p) (let-values (((base _1 _2) (split-path p))) (display base))))'`
+     if test "X$SCHEME_COLLECTS" = "X"; then
+       if test -d "$vi_cv_path_mzscheme_pfx/lib/plt/collects"; then
+ 	SCHEME_COLLECTS=$vi_cv_path_mzscheme_pfx/lib/plt/
+       else
+ 	if test -d "$vi_cv_path_mzscheme_pfx/lib/racket/collects"; then
+ 	  SCHEME_COLLECTS=$vi_cv_path_mzscheme_pfx/lib/racket/
+ 	else
+ 	  if test -d "$vi_cv_path_mzscheme_pfx/share/racket/collects"; then
+ 	    SCHEME_COLLECTS=$vi_cv_path_mzscheme_pfx/share/racket/
+ 	  else
+ 	    if test -d "$vi_cv_path_mzscheme_pfx/collects"; then
+ 	      SCHEME_COLLECTS=$vi_cv_path_mzscheme_pfx/
+ 	    fi
+ 	  fi
+ 	fi
+       fi
+     fi
+     if test "X$SCHEME_COLLECTS" != "X" ; then
+       AC_MSG_RESULT(${SCHEME_COLLECTS})
+     else
+       AC_MSG_RESULT(not found)
+     fi
+ 
+     AC_MSG_CHECKING(for mzscheme_base.c)
+     if test -f "${SCHEME_COLLECTS}collects/scheme/base.ss" ; then
+       MZSCHEME_EXTRA="mzscheme_base.c"
+       MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/mzc"
+       MZSCHEME_MOD="++lib scheme/base"
+     else
+       if test -f "${SCHEME_COLLECTS}collects/scheme/base.rkt" ; then
+ 	MZSCHEME_EXTRA="mzscheme_base.c"
+ 	MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/mzc"
+ 	MZSCHEME_MOD="++lib scheme/base"
+       else
+ 	if test -f "${SCHEME_COLLECTS}collects/racket/base.rkt" ; then
+ 	  MZSCHEME_EXTRA="mzscheme_base.c"
+ 	  MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/raco ctool"
+ 	  MZSCHEME_MOD=""
+ 	fi
+       fi
+     fi
+     if test "X$MZSCHEME_EXTRA" != "X" ; then
+       dnl need to generate bytecode for MzScheme base
+       MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -DINCLUDE_MZSCHEME_BASE"
+       AC_MSG_RESULT(needed)
+     else
+       AC_MSG_RESULT(not needed)
+     fi
+ 
+     dnl On Ubuntu this fixes "undefined reference to symbol 'ffi_type_void'".
+     AC_CHECK_LIB(ffi, ffi_type_void, [MZSCHEME_LIBS="$MZSCHEME_LIBS -lffi"])
+ 
+     MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -I${SCHEME_INC} \
+       -DMZSCHEME_COLLECTS='\"${SCHEME_COLLECTS}collects\"'"
+ 
+     dnl Test that we can compile a simple program with these CFLAGS and LIBS.
+     AC_MSG_CHECKING([if compile and link flags for MzScheme are sane])
+     cflags_save=$CFLAGS
+     libs_save=$LIBS
+     CFLAGS="$CFLAGS $MZSCHEME_CFLAGS"
+     LIBS="$LIBS $MZSCHEME_LIBS"
+     AC_TRY_LINK(,[ ],
+ 	   AC_MSG_RESULT(yes); mzs_ok=yes,
+ 	   AC_MSG_RESULT(no: MZSCHEME DISABLED); mzs_ok=no)
+     CFLAGS=$cflags_save
+     LIBS=$libs_save
+     if test $mzs_ok = yes; then
+       MZSCHEME_SRC="if_mzsch.c"
+       MZSCHEME_OBJ="objects/if_mzsch.o"
+       MZSCHEME_PRO="if_mzsch.pro"
+       AC_DEFINE(FEAT_MZSCHEME)
+     else
+       MZSCHEME_CFLAGS=
+       MZSCHEME_LIBS=
+       MZSCHEME_EXTRA=
+       MZSCHEME_MZC=
+     fi
+   fi
+   AC_SUBST(MZSCHEME_SRC)
+   AC_SUBST(MZSCHEME_OBJ)
+   AC_SUBST(MZSCHEME_PRO)
+   AC_SUBST(MZSCHEME_LIBS)
+   AC_SUBST(MZSCHEME_CFLAGS)
+   AC_SUBST(MZSCHEME_EXTRA)
+   AC_SUBST(MZSCHEME_MZC)
+ fi
+ 
+ 
+ AC_MSG_CHECKING(--enable-perlinterp argument)
+ AC_ARG_ENABLE(perlinterp,
+ 	[  --enable-perlinterp[=OPTS]     Include Perl interpreter.  [default=no] [OPTS=no/yes/dynamic]], ,
+ 	[enable_perlinterp="no"])
+ AC_MSG_RESULT($enable_perlinterp)
+ if test "$enable_perlinterp" = "yes" -o "$enable_perlinterp" = "dynamic"; then
+   if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
+     AC_MSG_ERROR([cannot use Perl with tiny or small features])
+   fi
+   AC_SUBST(vi_cv_path_perl)
+   AC_PATH_PROG(vi_cv_path_perl, perl)
+   if test "X$vi_cv_path_perl" != "X"; then
+     AC_MSG_CHECKING(Perl version)
+     if $vi_cv_path_perl -e 'require 5.003_01' >/dev/null 2>/dev/null; then
+      eval `$vi_cv_path_perl -V:usethreads`
+      eval `$vi_cv_path_perl -V:libperl`
+      if test "X$usethreads" = "XUNKNOWN" -o "X$usethreads" = "Xundef"; then
+        badthreads=no
+      else
+        if $vi_cv_path_perl -e 'require 5.6.0' >/dev/null 2>/dev/null; then
+ 	 eval `$vi_cv_path_perl -V:use5005threads`
+ 	 if test "X$use5005threads" = "XUNKNOWN" -o "X$use5005threads" = "Xundef"; then
+ 	   badthreads=no
+ 	 else
+ 	   badthreads=yes
+ 	   AC_MSG_RESULT(>>> Perl > 5.6 with 5.5 threads cannot be used <<<)
+ 	 fi
+        else
+ 	 badthreads=yes
+ 	 AC_MSG_RESULT(>>> Perl 5.5 with threads cannot be used <<<)
+        fi
+      fi
+      if test $badthreads = no; then
+       AC_MSG_RESULT(OK)
+       eval `$vi_cv_path_perl -V:shrpenv`
+       if test "X$shrpenv" = "XUNKNOWN"; then # pre 5.003_04
+ 	shrpenv=""
+       fi
+       vi_cv_perllib=`$vi_cv_path_perl -MConfig -e 'print $Config{privlibexp}'`
+       AC_SUBST(vi_cv_perllib)
+       vi_cv_perl_extutils=unknown_perl_extutils_path
+       for extutils_rel_path in ExtUtils vendor_perl/ExtUtils; do
+ 	xsubpp_path="$vi_cv_perllib/$extutils_rel_path/xsubpp"
+ 	if test -f "$xsubpp_path"; then
+ 	  vi_cv_perl_xsubpp="$xsubpp_path"
+ 	fi
+       done
+       AC_SUBST(vi_cv_perl_xsubpp)
+       dnl Remove "-fno-something", it breaks using cproto.
+       dnl Remove "-fdebug-prefix-map", it isn't supported by clang.
+       perlcppflags=`$vi_cv_path_perl -Mlib=$srcdir -MExtUtils::Embed \
+ 	      -e 'ccflags;perl_inc;print"\n"' | sed -e 's/-fno[[^ ]]*//' \
+ 			-e 's/-fdebug-prefix-map[[^ ]]*//g'`
+       dnl Remove "-lc", it breaks on FreeBSD when using "-pthread".
+       perllibs=`cd $srcdir; $vi_cv_path_perl -MExtUtils::Embed -e 'ldopts' | \
+ 		sed -e '/Warning/d' -e '/Note (probably harmless)/d' \
+ 			-e 's/-bE:perl.exp//' -e 's/-lc //'`
+       dnl Don't add perl lib to $LIBS: if it's not in LD_LIBRARY_PATH
+       dnl a test in configure may fail because of that.
+       perlldflags=`cd $srcdir; $vi_cv_path_perl -MExtUtils::Embed \
+ 		-e 'ccdlflags' | sed -e 's/-bE:perl.exp//'`
+ 
+       dnl check that compiling a simple program still works with the flags
+       dnl added for Perl.
+       AC_MSG_CHECKING([if compile and link flags for Perl are sane])
+       cflags_save=$CFLAGS
+       libs_save=$LIBS
+       ldflags_save=$LDFLAGS
+       CFLAGS="$CFLAGS $perlcppflags"
+       LIBS="$LIBS $perllibs"
+       perlldflags=`echo "$perlldflags" | sed -e 's/^ *//g'`
+       LDFLAGS="$perlldflags $LDFLAGS"
+       AC_TRY_LINK(,[ ],
+ 	     AC_MSG_RESULT(yes); perl_ok=yes,
+ 	     AC_MSG_RESULT(no: PERL DISABLED); perl_ok=no)
+       CFLAGS=$cflags_save
+       LIBS=$libs_save
+       LDFLAGS=$ldflags_save
+       if test $perl_ok = yes; then
+ 	if test "X$perlcppflags" != "X"; then
+ 	  dnl remove -pipe and -Wxxx, it confuses cproto
+ 	  PERL_CFLAGS=`echo "$perlcppflags" | sed -e 's/-pipe //' -e 's/-W[[^ ]]*//'`
+ 	fi
+ 	if test "X$perlldflags" != "X"; then
+ 	  if test "X`echo \"$LDFLAGS\" | $FGREP -e \"$perlldflags\"`" = "X"; then
+ 	    LDFLAGS="$perlldflags $LDFLAGS"
+ 	  fi
+ 	fi
+ 	PERL_LIBS=$perllibs
+ 	PERL_SRC="auto/if_perl.c if_perlsfio.c"
+ 	PERL_OBJ="objects/if_perl.o objects/if_perlsfio.o"
+ 	PERL_PRO="if_perl.pro if_perlsfio.pro"
+ 	AC_DEFINE(FEAT_PERL)
+       fi
+      fi
+     else
+       AC_MSG_RESULT(>>> too old; need Perl version 5.003_01 or later <<<)
+     fi
+   fi
+ 
+   if test "x$MACOSX" = "xyes"; then
+     dnl Mac OS X 10.2 or later
+     dir=/System/Library/Perl
+     darwindir=$dir/darwin
+     if test -d $darwindir; then
+       PERL=/usr/bin/perl
+     else
+       dnl Mac OS X 10.3
+       dir=/System/Library/Perl/5.8.1
+       darwindir=$dir/darwin-thread-multi-2level
+       if test -d $darwindir; then
+ 	PERL=/usr/bin/perl
+       fi
+     fi
+     if test -n "$PERL"; then
+       PERL_DIR="$dir"
+       PERL_CFLAGS="-DFEAT_PERL -I$darwindir/CORE"
+       PERL_OBJ="objects/if_perl.o objects/if_perlsfio.o $darwindir/auto/DynaLoader/DynaLoader.a"
+       PERL_LIBS="-L$darwindir/CORE -lperl"
+     fi
+     dnl Perl on Mac OS X 10.5 adds "-arch" flags but these should only
+     dnl be included if requested by passing --with-mac-arch to
+     dnl configure, so strip these flags first (if present)
+     PERL_LIBS=`echo "$PERL_LIBS" | sed -e 's/-arch\ ppc//' -e 's/-arch\ i386//' -e 's/-arch\ x86_64//'`
+     PERL_CFLAGS=`echo "$PERL_CFLAGS" | sed -e 's/-arch\ ppc//' -e 's/-arch\ i386//' -e 's/-arch\ x86_64//'`
+   fi
+   if test "$enable_perlinterp" = "dynamic"; then
+     if test "$perl_ok" = "yes" -a "X$libperl" != "X"; then
+       AC_DEFINE(DYNAMIC_PERL)
+       PERL_CFLAGS="-DDYNAMIC_PERL_DLL=\\\"$libperl\\\" $PERL_CFLAGS"
+     fi
+   fi
+ 
+   if test "$fail_if_missing" = "yes" -a "$perl_ok" != "yes"; then
+     AC_MSG_ERROR([could not configure perl])
+   fi
+ fi
+ AC_SUBST(shrpenv)
+ AC_SUBST(PERL_SRC)
+ AC_SUBST(PERL_OBJ)
+ AC_SUBST(PERL_PRO)
+ AC_SUBST(PERL_CFLAGS)
+ AC_SUBST(PERL_LIBS)
+ 
+ AC_MSG_CHECKING(--enable-pythoninterp argument)
+ AC_ARG_ENABLE(pythoninterp,
+ 	[  --enable-pythoninterp[=OPTS]   Include Python interpreter. [default=no] [OPTS=no/yes/dynamic]], ,
+ 	[enable_pythoninterp="no"])
+ AC_MSG_RESULT($enable_pythoninterp)
+ if test "$enable_pythoninterp" = "yes" -o "$enable_pythoninterp" = "dynamic"; then
+   if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
+     AC_MSG_ERROR([cannot use Python with tiny or small features])
+   fi
+ 
+   dnl -- find the python executable
+   AC_PATH_PROGS(vi_cv_path_python, python2 python)
+   if test "X$vi_cv_path_python" != "X"; then
+ 
+     dnl -- get its version number
+     AC_CACHE_CHECK(Python version,vi_cv_var_python_version,
+     [[vi_cv_var_python_version=`
+ 	    ${vi_cv_path_python} -c 'import sys; print sys.version[:3]'`
+     ]])
+ 
+     dnl -- it must be at least version 2.3
+     AC_MSG_CHECKING(Python is 2.3 or better)
+     if ${vi_cv_path_python} -c \
+ 	"import sys; sys.exit(${vi_cv_var_python_version} < 2.3)"
+     then
+       AC_MSG_RESULT(yep)
+ 
+       dnl -- find where python thinks it was installed
+       AC_CACHE_CHECK(Python's install prefix,vi_cv_path_python_pfx,
+       [ vi_cv_path_python_pfx=`
+ 	    ${vi_cv_path_python} -c \
+ 		"import sys; print sys.prefix"` ])
+ 
+       dnl -- and where it thinks it runs
+       AC_CACHE_CHECK(Python's execution prefix,vi_cv_path_python_epfx,
+       [ vi_cv_path_python_epfx=`
+ 	    ${vi_cv_path_python} -c \
+ 		"import sys; print sys.exec_prefix"` ])
+ 
+       dnl -- python's internal library path
+ 
+       AC_CACHE_VAL(vi_cv_path_pythonpath,
+       [ vi_cv_path_pythonpath=`
+ 	    unset PYTHONPATH;
+ 	    ${vi_cv_path_python} -c \
+ 		"import sys, string; print string.join(sys.path,':')"` ])
+ 
+       dnl -- where the Python implementation library archives are
+ 
+       AC_ARG_WITH(python-config-dir,
+ 	[  --with-python-config-dir=PATH  Python's config directory],
+ 	[ vi_cv_path_python_conf="${withval}" ] )
+ 
+       AC_CACHE_CHECK(Python's configuration directory,vi_cv_path_python_conf,
+       [
+ 	vi_cv_path_python_conf=
+ 	d=`${vi_cv_path_python} -c "import distutils.sysconfig; print distutils.sysconfig.get_config_var('LIBPL')"`
+ 	if test -d "$d" && test -f "$d/config.c"; then
+ 	  vi_cv_path_python_conf="$d"
+ 	else
+ 	  for path in "${vi_cv_path_python_pfx}" "${vi_cv_path_python_epfx}"; do
+ 	    for subdir in lib64 lib share; do
+ 	      d="${path}/${subdir}/python${vi_cv_var_python_version}/config"
+ 	      if test -d "$d" && test -f "$d/config.c"; then
+ 		vi_cv_path_python_conf="$d"
+ 	      fi
+ 	    done
+ 	  done
+ 	fi
+       ])
+ 
+       PYTHON_CONFDIR="${vi_cv_path_python_conf}"
+ 
+       if test "X$PYTHON_CONFDIR" = "X"; then
+ 	AC_MSG_RESULT([can't find it!])
+       else
+ 
+ 	dnl -- we need to examine Python's config/Makefile too
+ 	dnl    see what the interpreter is built from
+ 	AC_CACHE_VAL(vi_cv_path_python_plibs,
+ 	[
+ 	    pwd=`pwd`
+ 	    tmp_mkf="$pwd/config-PyMake$$"
+ 	    cat -- "${PYTHON_CONFDIR}/Makefile" - <<'eof' >"${tmp_mkf}"
+ __:
+ 	@echo "python_BASEMODLIBS='$(BASEMODLIBS)'"
+ 	@echo "python_LIBS='$(LIBS)'"
+ 	@echo "python_SYSLIBS='$(SYSLIBS)'"
+ 	@echo "python_LINKFORSHARED='$(LINKFORSHARED)'"
+ 	@echo "python_DLLLIBRARY='$(DLLLIBRARY)'"
+ 	@echo "python_INSTSONAME='$(INSTSONAME)'"
+ 	@echo "python_PYTHONFRAMEWORK='$(PYTHONFRAMEWORK)'"
+ 	@echo "python_PYTHONFRAMEWORKPREFIX='$(PYTHONFRAMEWORKPREFIX)'"
+ 	@echo "python_PYTHONFRAMEWORKINSTALLDIR='$(PYTHONFRAMEWORKINSTALLDIR)'"
+ eof
+ 	    dnl -- delete the lines from make about Entering/Leaving directory
+ 	    eval "`cd ${PYTHON_CONFDIR} && make -f "${tmp_mkf}" __ | sed '/ directory /d'`"
+ 	    rm -f -- "${tmp_mkf}"
+ 	    if test "x$MACOSX" = "xyes" && test -n "${python_PYTHONFRAMEWORK}" && ${vi_cv_path_python} -c \
+ 		"import sys; sys.exit(${vi_cv_var_python_version} < 2.3)"; then
+ 	      vi_cv_path_python_plibs="-framework Python"
+ 	      if test "x${vi_cv_path_python}" != "x/usr/bin/python" && test -n "${python_PYTHONFRAMEWORKPREFIX}"; then
+ 		  vi_cv_path_python_plibs="-F${python_PYTHONFRAMEWORKPREFIX} -framework Python"
+ 	      fi
+ 	    else
+ 	      if test "${vi_cv_var_python_version}" = "1.4"; then
+ 		  vi_cv_path_python_plibs="${PYTHON_CONFDIR}/libModules.a ${PYTHON_CONFDIR}/libPython.a ${PYTHON_CONFDIR}/libObjects.a ${PYTHON_CONFDIR}/libParser.a"
+ 	      else
+ 		  vi_cv_path_python_plibs="-L${PYTHON_CONFDIR} -lpython${vi_cv_var_python_version}"
+ 	      fi
+ 	      dnl -- Check if the path contained in python_LINKFORSHARED is
+ 	      dnl    usable for vim build. If not, make and try other
+ 	      dnl    candidates.
+ 	      if test -n "${python_LINKFORSHARED}" && test -n "${python_PYTHONFRAMEWORKPREFIX}"; then
+ 	        python_link_symbol=`echo ${python_LINKFORSHARED} | sed 's/\([[^ \t]][[^ \t]]*[[ \t]][[ \t]]*[[^ \t]][[^ \t]]*\)[[ \t]].*/\1/'`
+ 		python_link_path=`echo ${python_LINKFORSHARED} |   sed 's/\([[^ \t]][[^ \t]]*[[ \t]][[ \t]]*[[^ \t]][[^ \t]]*\)[[ \t]][[ \t]]*\(.*\)/\2/'`
+ 	        if test -n "${python_link_path}" && ! test -x "${python_link_path}"; then
+ 	          dnl -- The path looks relative. Guess the absolute one using
+ 		  dnl    the prefix and try that.
+ 	          python_link_path="${python_PYTHONFRAMEWORKPREFIX}/${python_link_path}"
+ 		  if test -n "${python_link_path}" && ! test -x "${python_link_path}"; then
+ 		    dnl -- A last resort.
+ 		    python_link_path="${python_PYTHONFRAMEWORKINSTALLDIR}/Versions/${vi_cv_var_python_version}/${python_PYTHONFRAMEWORK}"
+ 	            dnl -- No check is done. The last word is left to the
+ 	            dnl    "sanity" test on link flags that follows shortly.
+ 		  fi
+ 	          python_LINKFORSHARED="${python_link_symbol} ${python_link_path}"
+ 	        fi
+ 	      fi
+ 	      vi_cv_path_python_plibs="${vi_cv_path_python_plibs} ${python_BASEMODLIBS} ${python_LIBS} ${python_SYSLIBS} ${python_LINKFORSHARED}"
+ 	      dnl remove -ltermcap, it can conflict with an earlier -lncurses
+ 	      vi_cv_path_python_plibs=`echo $vi_cv_path_python_plibs | sed s/-ltermcap//`
+ 	    fi
+ 	])
+ 	AC_CACHE_CHECK(Python's dll name,vi_cv_dll_name_python,
+ 	[
+ 	  if test "X$python_DLLLIBRARY" != "X"; then
+ 	    vi_cv_dll_name_python="$python_DLLLIBRARY"
+ 	  else
+ 	    vi_cv_dll_name_python="$python_INSTSONAME"
+ 	  fi
+ 	])
+ 
+ 	PYTHON_LIBS="${vi_cv_path_python_plibs}"
+ 	if test "${vi_cv_path_python_pfx}" = "${vi_cv_path_python_epfx}"; then
+ 	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version} -DPYTHON_HOME='\"${vi_cv_path_python_pfx}\"'"
+ 	else
+ 	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version} -I${vi_cv_path_python_epfx}/include/python${vi_cv_var_python_version} -DPYTHON_HOME='\"${vi_cv_path_python_pfx}\"'"
+ 	fi
+ 	PYTHON_SRC="if_python.c"
+ 	PYTHON_OBJ="objects/if_python.o"
+ 	if test "${vi_cv_var_python_version}" = "1.4"; then
+ 	   PYTHON_OBJ="$PYTHON_OBJ objects/py_getpath.o"
+ 	fi
+     PYTHON_GETPATH_CFLAGS="-DPYTHONPATH='\"${vi_cv_path_pythonpath}\"' -DPREFIX='\"${vi_cv_path_python_pfx}\"' -DEXEC_PREFIX='\"${vi_cv_path_python_epfx}\"'"
+ 
+ 	dnl On FreeBSD linking with "-pthread" is required to use threads.
+ 	dnl _THREAD_SAFE must be used for compiling then.
+ 	dnl The "-pthread" is added to $LIBS, so that the following check for
+ 	dnl sigaltstack() will look in libc_r (it's there in libc!).
+ 	dnl Otherwise, when using GCC, try adding -pthread to $CFLAGS.  GCC
+ 	dnl will then define target-specific defines, e.g., -D_REENTRANT.
+ 	dnl Don't do this for Mac OSX, -pthread will generate a warning.
+ 	AC_MSG_CHECKING([if -pthread should be used])
+ 	threadsafe_flag=
+ 	thread_lib=
+ 	dnl if test "x$MACOSX" != "xyes"; then
+         if test "`(uname) 2>/dev/null`" != Darwin; then
+ 	  test "$GCC" = yes && threadsafe_flag="-pthread"
+ 	  if test "`(uname) 2>/dev/null`" = FreeBSD; then
+ 	    threadsafe_flag="-D_THREAD_SAFE"
+ 	    thread_lib="-pthread"
+ 	  fi
+ 	  if test "`(uname) 2>/dev/null`" = SunOS; then
+ 	    threadsafe_flag="-pthreads"
+ 	  fi
+ 	fi
+ 	libs_save_old=$LIBS
+ 	if test -n "$threadsafe_flag"; then
+ 	  cflags_save=$CFLAGS
+ 	  CFLAGS="$CFLAGS $threadsafe_flag"
+ 	  LIBS="$LIBS $thread_lib"
+ 	  AC_TRY_LINK(,[ ],
+ 	     AC_MSG_RESULT(yes); PYTHON_CFLAGS="$PYTHON_CFLAGS $threadsafe_flag",
+ 	     AC_MSG_RESULT(no); LIBS=$libs_save_old
+ 	     )
+ 	  CFLAGS=$cflags_save
+ 	else
+ 	  AC_MSG_RESULT(no)
+ 	fi
+ 
+ 	dnl Check that compiling a simple program still works with the flags
+ 	dnl added for Python.
+ 	AC_MSG_CHECKING([if compile and link flags for Python are sane])
+ 	cflags_save=$CFLAGS
+ 	libs_save=$LIBS
+ 	CFLAGS="$CFLAGS $PYTHON_CFLAGS"
+ 	LIBS="$LIBS $PYTHON_LIBS"
+ 	AC_TRY_LINK(,[ ],
+ 	       AC_MSG_RESULT(yes); python_ok=yes,
+ 	       AC_MSG_RESULT(no: PYTHON DISABLED); python_ok=no)
+ 	CFLAGS=$cflags_save
+ 	LIBS=$libs_save
+ 	if test $python_ok = yes; then
+ 	  AC_DEFINE(FEAT_PYTHON)
+ 	else
+ 	  LIBS=$libs_save_old
+ 	  PYTHON_SRC=
+ 	  PYTHON_OBJ=
+ 	  PYTHON_LIBS=
+ 	  PYTHON_CFLAGS=
+ 	fi
+       fi
+     else
+       AC_MSG_RESULT(too old)
+     fi
+   fi
+ 
+   if test "$fail_if_missing" = "yes" -a "$python_ok" != "yes"; then
+     AC_MSG_ERROR([could not configure python])
+   fi
+ fi
+ 
+ AC_SUBST(PYTHON_CONFDIR)
+ AC_SUBST(PYTHON_LIBS)
+ AC_SUBST(PYTHON_GETPATH_CFLAGS)
+ AC_SUBST(PYTHON_CFLAGS)
+ AC_SUBST(PYTHON_SRC)
+ AC_SUBST(PYTHON_OBJ)
+ 
+ 
+ AC_MSG_CHECKING(--enable-python3interp argument)
+ AC_ARG_ENABLE(python3interp,
+ 	[  --enable-python3interp[=OPTS]   Include Python3 interpreter. [default=no] [OPTS=no/yes/dynamic]], ,
+ 	[enable_python3interp="no"])
+ AC_MSG_RESULT($enable_python3interp)
+ if test "$enable_python3interp" = "yes" -o "$enable_python3interp" = "dynamic"; then
+   if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
+     AC_MSG_ERROR([cannot use Python with tiny or small features])
+   fi
+ 
+   dnl -- find the python3 executable
+   AC_PATH_PROGS(vi_cv_path_python3, python3 python)
+   if test "X$vi_cv_path_python3" != "X"; then
+ 
+     dnl -- get its version number
+     AC_CACHE_CHECK(Python version,vi_cv_var_python3_version,
+     [[vi_cv_var_python3_version=`
+           ${vi_cv_path_python3} -c 'import sys; print(sys.version[:3])'`
+     ]])
+ 
+     dnl -- it must be at least version 3
+     AC_MSG_CHECKING(Python is 3.0 or better)
+     if ${vi_cv_path_python3} -c \
+       "import sys; sys.exit(${vi_cv_var_python3_version} < 3.0)"
+     then
+       AC_MSG_RESULT(yep)
+ 
+       dnl -- get abiflags for python 3.2 or higher (PEP 3149)
+       AC_CACHE_CHECK(Python's abiflags,vi_cv_var_python3_abiflags,
+       [
+        vi_cv_var_python3_abiflags=
+        if ${vi_cv_path_python3} -c \
+            "import sys; sys.exit(${vi_cv_var_python3_version} < 3.2)"
+        then
+          vi_cv_var_python3_abiflags=`${vi_cv_path_python3} -c \    
+            "import sys; print(sys.abiflags)"`
+        fi ])
+   
+       dnl -- find where python3 thinks it was installed
+       AC_CACHE_CHECK(Python's install prefix,vi_cv_path_python3_pfx,
+       [ vi_cv_path_python3_pfx=`
+        ${vi_cv_path_python3} -c \
+        "import sys; print(sys.prefix)"` ])
+   
+       dnl -- and where it thinks it runs
+       AC_CACHE_CHECK(Python's execution prefix,vi_cv_path_python3_epfx,
+       [ vi_cv_path_python3_epfx=`
+        ${vi_cv_path_python3} -c \
+        "import sys; print(sys.exec_prefix)"` ])
+   
+       dnl -- python3's internal library path
+   
+       AC_CACHE_VAL(vi_cv_path_python3path,
+       [ vi_cv_path_python3path=`
+        unset PYTHONPATH;
+        ${vi_cv_path_python3} -c \
+        "import sys, string; print(':'.join(sys.path))"` ])
+   
+       dnl -- where the Python implementation library archives are
+   
+       AC_ARG_WITH(python3-config-dir,
+        [  --with-python3-config-dir=PATH  Python's config directory],
+        [ vi_cv_path_python3_conf="${withval}" ] )
+   
+       AC_CACHE_CHECK(Python's configuration directory,vi_cv_path_python3_conf,
+       [
+        vi_cv_path_python3_conf=
+        config_dir="config-${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags}"
+        d=`${vi_cv_path_python3} -c "import distutils.sysconfig; print(distutils.sysconfig.get_config_var('LIBPL'))"`
+        if test -d "$d" && test -f "$d/config.c"; then
+          vi_cv_path_python3_conf="$d"
+        else
+          for path in "${vi_cv_path_python3_pfx}" "${vi_cv_path_python3_epfx}"; do
+ 	   for subdir in lib64 lib share; do
+ 	     d="${path}/${subdir}/python${vi_cv_var_python3_version}/${config_dir}"
+ 	     if test -d "$d" && test -f "$d/config.c"; then
+ 	       vi_cv_path_python3_conf="$d"
+ 	     fi
+ 	   done
+          done
+        fi
+       ])
+   
+       PYTHON3_CONFDIR="${vi_cv_path_python3_conf}"
+   
+       if test "X$PYTHON3_CONFDIR" = "X"; then
+         AC_MSG_RESULT([can't find it!])
+       else
+   
+         dnl -- we need to examine Python's config/Makefile too
+         dnl    see what the interpreter is built from
+         AC_CACHE_VAL(vi_cv_path_python3_plibs,
+         [
+             pwd=`pwd`
+             tmp_mkf="$pwd/config-PyMake$$"
+             cat -- "${PYTHON3_CONFDIR}/Makefile" - <<'eof' >"${tmp_mkf}"
+ __:
+ 	@echo "python3_BASEMODLIBS='$(BASEMODLIBS)'"
+ 	@echo "python3_LIBS='$(LIBS)'"
+ 	@echo "python3_SYSLIBS='$(SYSLIBS)'"
+ 	@echo "python3_DLLLIBRARY='$(DLLLIBRARY)'"
+ 	@echo "python3_INSTSONAME='$(INSTSONAME)'"
+ eof
+ 	    dnl -- delete the lines from make about Entering/Leaving directory
+ 	    eval "`cd ${PYTHON3_CONFDIR} && make -f "${tmp_mkf}" __ | sed '/ directory /d'`"
+ 	    rm -f -- "${tmp_mkf}"
+ 	    vi_cv_path_python3_plibs="-L${PYTHON3_CONFDIR} -lpython${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags}"
+ 	    vi_cv_path_python3_plibs="${vi_cv_path_python3_plibs} ${python3_BASEMODLIBS} ${python3_LIBS} ${python3_SYSLIBS}"
+ 	    dnl remove -ltermcap, it can conflict with an earlier -lncurses
+ 	    vi_cv_path_python3_plibs=`echo $vi_cv_path_python3_plibs | sed s/-ltermcap//`
+ 	    vi_cv_path_python3_plibs=`echo $vi_cv_path_python3_plibs | sed s/-lffi//`
+ 	])
+ 	AC_CACHE_CHECK(Python3's dll name,vi_cv_dll_name_python3,
+ 	[
+ 	  if test "X$python3_DLLLIBRARY" != "X"; then
+ 	    vi_cv_dll_name_python3="$python3_DLLLIBRARY"
+ 	  else
+ 	    vi_cv_dll_name_python3="$python3_INSTSONAME"
+ 	  fi
+ 	])
+ 
+         PYTHON3_LIBS="${vi_cv_path_python3_plibs}"
+         if test "${vi_cv_path_python3_pfx}" = "${vi_cv_path_python3_epfx}"; then
+           PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags} -DPYTHON3_HOME='L\"${vi_cv_path_python3_pfx}\"'"
+         else
+           PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags} -I${vi_cv_path_python3_epfx}/include/python${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags} -DPYTHON3_HOME='L\"${vi_cv_path_python3_pfx}\"'"
+         fi
+         PYTHON3_SRC="if_python3.c"
+         PYTHON3_OBJ="objects/if_python3.o"
+   
+         dnl On FreeBSD linking with "-pthread" is required to use threads.
+         dnl _THREAD_SAFE must be used for compiling then.
+         dnl The "-pthread" is added to $LIBS, so that the following check for
+         dnl sigaltstack() will look in libc_r (it's there in libc!).
+         dnl Otherwise, when using GCC, try adding -pthread to $CFLAGS.  GCC
+         dnl will then define target-specific defines, e.g., -D_REENTRANT.
+         dnl Don't do this for Mac OSX, -pthread will generate a warning.
+         AC_MSG_CHECKING([if -pthread should be used])
+         threadsafe_flag=
+         thread_lib=
+         dnl if test "x$MACOSX" != "xyes"; then
+         if test "`(uname) 2>/dev/null`" != Darwin; then
+           test "$GCC" = yes && threadsafe_flag="-pthread"
+           if test "`(uname) 2>/dev/null`" = FreeBSD; then
+             threadsafe_flag="-D_THREAD_SAFE"
+             thread_lib="-pthread"
+           fi
+           if test "`(uname) 2>/dev/null`" = SunOS; then
+             threadsafe_flag="-pthreads"
+           fi
+         fi
+         libs_save_old=$LIBS
+         if test -n "$threadsafe_flag"; then
+           cflags_save=$CFLAGS
+           CFLAGS="$CFLAGS $threadsafe_flag"
+           LIBS="$LIBS $thread_lib"
+           AC_TRY_LINK(,[ ],
+              AC_MSG_RESULT(yes); PYTHON3_CFLAGS="$PYTHON3_CFLAGS $threadsafe_flag",
+              AC_MSG_RESULT(no); LIBS=$libs_save_old
+              )
+           CFLAGS=$cflags_save
+         else
+           AC_MSG_RESULT(no)
+         fi
+   
+         dnl check that compiling a simple program still works with the flags
+         dnl added for Python.
+         AC_MSG_CHECKING([if compile and link flags for Python 3 are sane])
+         cflags_save=$CFLAGS
+         libs_save=$LIBS
+         CFLAGS="$CFLAGS $PYTHON3_CFLAGS"
+         LIBS="$LIBS $PYTHON3_LIBS"
+         AC_TRY_LINK(,[ ],
+                AC_MSG_RESULT(yes); python3_ok=yes,
+                AC_MSG_RESULT(no: PYTHON3 DISABLED); python3_ok=no)
+         CFLAGS=$cflags_save
+         LIBS=$libs_save
+         if test "$python3_ok" = yes; then
+           AC_DEFINE(FEAT_PYTHON3)
+         else
+           LIBS=$libs_save_old
+           PYTHON3_SRC=
+           PYTHON3_OBJ=
+           PYTHON3_LIBS=
+           PYTHON3_CFLAGS=
+         fi
+       fi
+     else
+       AC_MSG_RESULT(too old)
+     fi
+   fi
+   if test "$fail_if_missing" = "yes" -a "$python3_ok" != "yes"; then
+     AC_MSG_ERROR([could not configure python3])
+   fi
+ fi
+ 
+ AC_SUBST(PYTHON3_CONFDIR)
+ AC_SUBST(PYTHON3_LIBS)
+ AC_SUBST(PYTHON3_CFLAGS)
+ AC_SUBST(PYTHON3_SRC)
+ AC_SUBST(PYTHON3_OBJ)
+ 
+ dnl if python2.x and python3.x are enabled one can only link in code
+ dnl with dlopen(), dlsym(), dlclose() 
+ if test "$python_ok" = yes && test "$python3_ok" = yes; then
+   AC_DEFINE(DYNAMIC_PYTHON)
+   AC_DEFINE(DYNAMIC_PYTHON3)
+   AC_MSG_CHECKING(whether we can do without RTLD_GLOBAL for Python)
+   cflags_save=$CFLAGS
+   CFLAGS="$CFLAGS $PYTHON_CFLAGS"
+   libs_save=$LIBS
+   dnl -ldl must go first to make this work on Archlinux (Roland Puntaier)
+   LIBS="-ldl $LIBS"
+   AC_RUN_IFELSE([AC_LANG_SOURCE([
+     #include <dlfcn.h>
+     /* If this program fails, then RTLD_GLOBAL is needed.
+      * RTLD_GLOBAL will be used and then it is not possible to
+      * have both python versions enabled in the same vim instance.
+      * Only the first python version used will be switched on.
+      */
+ 
+     int no_rtl_global_needed_for(char *python_instsoname, char *prefix)
+     {
+       int needed = 0;
+       void* pylib = dlopen(python_instsoname, RTLD_LAZY|RTLD_LOCAL);
+       if (pylib != 0)
+       {
+           void (*pfx)(char *home) = dlsym(pylib, "Py_SetPythonHome");
+           void (*init)(void) = dlsym(pylib, "Py_Initialize");
+           int (*simple)(char*) = dlsym(pylib, "PyRun_SimpleString");
+           void (*final)(void) = dlsym(pylib, "Py_Finalize");
+           (*pfx)(prefix);
+           (*init)();
+           needed = (*simple)("import termios") == -1;
+           (*final)();
+           dlclose(pylib);
+       }
+       return !needed;
+     }
+ 
+     int main(int argc, char** argv)
+     {
+       int not_needed = 0;
+       if (no_rtl_global_needed_for("${vi_cv_dll_name_python}", "${vi_cv_path_python_pfx}"))
+             not_needed = 1;
+       return !not_needed;
+     }])],
+     [AC_MSG_RESULT(yes);AC_DEFINE(PY_NO_RTLD_GLOBAL)], [AC_MSG_RESULT(no)])
+ 
+   CFLAGS=$cflags_save
+   LIBS=$libs_save
+ 
+   AC_MSG_CHECKING(whether we can do without RTLD_GLOBAL for Python3)
+   cflags_save=$CFLAGS
+   CFLAGS="$CFLAGS $PYTHON3_CFLAGS"
+   libs_save=$LIBS
+   dnl -ldl must go first to make this work on Archlinux (Roland Puntaier)
+   LIBS="-ldl $LIBS"
+   AC_RUN_IFELSE([AC_LANG_SOURCE([
+     #include <dlfcn.h>
+     #include <wchar.h>
+     /* If this program fails, then RTLD_GLOBAL is needed.
+      * RTLD_GLOBAL will be used and then it is not possible to
+      * have both python versions enabled in the same vim instance.
+      * Only the first python version used will be switched on.
+      */
+ 
+     int no_rtl_global_needed_for(char *python_instsoname, wchar_t *prefix)
+     {
+       int needed = 0;
+       void* pylib = dlopen(python_instsoname, RTLD_LAZY|RTLD_LOCAL);
+       if (pylib != 0)
+       {
+           void (*pfx)(wchar_t *home) = dlsym(pylib, "Py_SetPythonHome");
+           void (*init)(void) = dlsym(pylib, "Py_Initialize");
+           int (*simple)(char*) = dlsym(pylib, "PyRun_SimpleString");
+           void (*final)(void) = dlsym(pylib, "Py_Finalize");
+           (*pfx)(prefix);
+           (*init)();
+           needed = (*simple)("import termios") == -1;
+           (*final)();
+           dlclose(pylib);
+       }
+       return !needed;
+     }
+ 
+     int main(int argc, char** argv)
+     {
+       int not_needed = 0;
+       if (no_rtl_global_needed_for("${vi_cv_dll_name_python3}", L"${vi_cv_path_python3_pfx}"))
+             not_needed = 1;
+       return !not_needed;
+     }])],
+     [AC_MSG_RESULT(yes);AC_DEFINE(PY3_NO_RTLD_GLOBAL)], [AC_MSG_RESULT(no)])
+ 
+   CFLAGS=$cflags_save
+   LIBS=$libs_save
+ 
+   PYTHON_SRC="if_python.c"
+   PYTHON_OBJ="objects/if_python.o"
+   PYTHON_CFLAGS="$PYTHON_CFLAGS -DDYNAMIC_PYTHON_DLL=\\\"${vi_cv_dll_name_python}\\\""
+   PYTHON_LIBS=
+   PYTHON3_SRC="if_python3.c"
+   PYTHON3_OBJ="objects/if_python3.o"
+   PYTHON3_CFLAGS="$PYTHON3_CFLAGS -DDYNAMIC_PYTHON3_DLL=\\\"${vi_cv_dll_name_python3}\\\""
+   PYTHON3_LIBS=
+ elif test "$python_ok" = yes && test "$enable_pythoninterp" = "dynamic"; then
+   AC_DEFINE(DYNAMIC_PYTHON)
+   PYTHON_SRC="if_python.c"
+   PYTHON_OBJ="objects/if_python.o"
+   PYTHON_CFLAGS="$PYTHON_CFLAGS -DDYNAMIC_PYTHON_DLL=\\\"${vi_cv_dll_name_python}\\\""
+   PYTHON_LIBS=
+ elif test "$python_ok" = yes; then
+   dnl Check that adding -fPIE works.  It may be needed when using a static
+   dnl Python library.
+   AC_MSG_CHECKING([if -fPIE can be added for Python])
+   cflags_save=$CFLAGS
+   libs_save=$LIBS
+   CFLAGS="$CFLAGS $PYTHON_CFLAGS -fPIE"
+   LIBS="$LIBS $PYTHON_LIBS"
+   AC_TRY_LINK(,[ ],
+ 	 AC_MSG_RESULT(yes); fpie_ok=yes,
+ 	 AC_MSG_RESULT(no); fpie_ok=no)
+   CFLAGS=$cflags_save
+   LIBS=$libs_save
+   if test $fpie_ok = yes; then
+     PYTHON_CFLAGS="$PYTHON_CFLAGS -fPIE"
+   fi
+ elif test "$python3_ok" = yes && test "$enable_python3interp" = "dynamic"; then
+   AC_DEFINE(DYNAMIC_PYTHON3)
+   PYTHON3_SRC="if_python3.c"
+   PYTHON3_OBJ="objects/if_python3.o"
+   PYTHON3_CFLAGS="$PYTHON3_CFLAGS -DDYNAMIC_PYTHON3_DLL=\\\"${vi_cv_dll_name_python3}\\\""
+   PYTHON3_LIBS=
+ elif test "$python3_ok" = yes; then
+   dnl Check that adding -fPIE works.  It may be needed when using a static
+   dnl Python library.
+   AC_MSG_CHECKING([if -fPIE can be added for Python3])
+   cflags_save=$CFLAGS
+   libs_save=$LIBS
+   CFLAGS="$CFLAGS $PYTHON3_CFLAGS -fPIE"
+   LIBS="$LIBS $PYTHON3_LIBS"
+   AC_TRY_LINK(,[ ],
+ 	 AC_MSG_RESULT(yes); fpie_ok=yes,
+ 	 AC_MSG_RESULT(no); fpie_ok=no)
+   CFLAGS=$cflags_save
+   LIBS=$libs_save
+   if test $fpie_ok = yes; then
+     PYTHON3_CFLAGS="$PYTHON3_CFLAGS -fPIE"
+   fi
+ fi
+ 
+ AC_MSG_CHECKING(--enable-tclinterp argument)
+ AC_ARG_ENABLE(tclinterp,
+ 	[  --enable-tclinterp[=OPTS]      Include Tcl interpreter. [default=no] [OPTS=no/yes/dynamic]], ,
+ 	[enable_tclinterp="no"])
+ AC_MSG_RESULT($enable_tclinterp)
+ 
+ if test "$enable_tclinterp" = "yes" -o "$enable_tclinterp" = "dynamic"; then
+ 
+   dnl on FreeBSD tclsh is a silly script, look for tclsh8.[5420]
+   AC_MSG_CHECKING(--with-tclsh argument)
+   AC_ARG_WITH(tclsh, [  --with-tclsh=PATH       which tclsh to use (default: tclsh8.0)],
+ 	tclsh_name="$withval"; AC_MSG_RESULT($tclsh_name),
+ 	tclsh_name="tclsh8.5"; AC_MSG_RESULT(no))
+   AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)
+   AC_SUBST(vi_cv_path_tcl)
+ 
+   dnl when no specific version specified, also try 8.4, 8.2 and 8.0
+   if test "X$vi_cv_path_tcl" = "X" -a $tclsh_name = "tclsh8.5"; then
+     tclsh_name="tclsh8.4"
+     AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)
+   fi
+   if test "X$vi_cv_path_tcl" = "X" -a $tclsh_name = "tclsh8.4"; then
+     tclsh_name="tclsh8.2"
+     AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)
+   fi
+   if test "X$vi_cv_path_tcl" = "X" -a $tclsh_name = "tclsh8.2"; then
+     tclsh_name="tclsh8.0"
+     AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)
+   fi
+   dnl still didn't find it, try without version number
+   if test "X$vi_cv_path_tcl" = "X"; then
+     tclsh_name="tclsh"
+     AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)
+   fi
+   if test "X$vi_cv_path_tcl" != "X"; then
+     AC_MSG_CHECKING(Tcl version)
+     if echo 'exit [[expr [info tclversion] < 8.0]]' | "$vi_cv_path_tcl" - ; then
+       tclver=`echo 'puts [[info tclversion]]' | $vi_cv_path_tcl -`
+       AC_MSG_RESULT($tclver - OK);
+       tclloc=`echo 'set l [[info library]];set i [[string last lib $l]];incr i -2;puts [[string range $l 0 $i]]' | $vi_cv_path_tcl -`
+       tcldll=`echo 'puts libtcl[[info tclversion]][[info sharedlibextension]]' | $vi_cv_path_tcl -`
+ 
+       AC_MSG_CHECKING(for location of Tcl include)
+       if test "x$MACOSX" != "xyes"; then
+ 	tclinc="$tclloc/include $tclloc/include/tcl $tclloc/include/tcl$tclver /usr/local/include /usr/local/include/tcl$tclver /usr/include /usr/include/tcl$tclver"
+       else
+ 	dnl For Mac OS X 10.3, use the OS-provided framework location
+ 	tclinc="/System/Library/Frameworks/Tcl.framework/Headers"
+       fi
+       TCL_INC=
+       for try in $tclinc; do
+ 	if test -f "$try/tcl.h"; then
+ 	  AC_MSG_RESULT($try/tcl.h)
+ 	  TCL_INC=$try
+ 	  break
+ 	fi
+       done
+       if test -z "$TCL_INC"; then
+ 	AC_MSG_RESULT(<not found>)
+ 	SKIP_TCL=YES
+       fi
+       if test -z "$SKIP_TCL"; then
+ 	AC_MSG_CHECKING(for location of tclConfig.sh script)
+ 	if test "x$MACOSX" != "xyes"; then
+ 	  tclcnf=`echo $tclinc | sed s/include/lib/g`
+ 	  tclcnf="$tclcnf `echo $tclinc | sed s/include/lib64/g`"
+ 	else
+ 	  dnl For Mac OS X 10.3, use the OS-provided framework location
+ 	  tclcnf="/System/Library/Frameworks/Tcl.framework"
+ 	fi
+ 	for try in $tclcnf; do
+ 	  if test -f "$try/tclConfig.sh"; then
+ 	    AC_MSG_RESULT($try/tclConfig.sh)
+ 	    . "$try/tclConfig.sh"
+ 	    dnl use eval, because tcl 8.2 includes ${TCL_DBGX}
+ 	    if test "$enable_tclinterp" = "dynamic"; then
+ 	      TCL_LIBS=`eval echo "$TCL_STUB_LIB_SPEC $TCL_LIBS"`
+ 	    else
+ 	      TCL_LIBS=`eval echo "$TCL_LIB_SPEC $TCL_LIBS"`
+ 	    fi
+ 	    dnl Use $TCL_DEFS for -D_THREAD_SAFE et al.  But only use the
+ 	    dnl "-D_ABC" items.  Watch out for -DFOO=long\ long.
+ 	    TCL_DEFS=`echo $TCL_DEFS | sed -e 's/\\\\ /\\\\X/g' | tr ' ' '\012' | sed -e '/^[[^-]]/d' -e '/^-[[^D]]/d' -e '/-D[[^_]]/d' -e 's/-D_/ -D_/' | tr '\012' ' ' | sed -e 's/\\\\X/\\\\ /g'`
+ 	    break
+ 	  fi
+ 	done
+ 	if test -z "$TCL_LIBS"; then
+ 	  AC_MSG_RESULT(<not found>)
+ 	  AC_MSG_CHECKING(for Tcl library by myself)
+ 	  tcllib=`echo $tclinc | sed s/include/lib/g`
+ 	  tcllib="$tcllib `echo $tclinc | sed s/include/lib64/g`"
+ 	  for ext in .so .a ; do
+ 	    for ver in "" $tclver ; do
+ 	      for try in $tcllib ; do
+ 		trylib=tcl$ver$ext
+ 		if test -f "$try/lib$trylib" ; then
+ 		  AC_MSG_RESULT($try/lib$trylib)
+ 		  TCL_LIBS="-L\"$try\" -ltcl$ver -ldl -lm"
+ 		  if test "`(uname) 2>/dev/null`" = SunOS &&
+ 					 uname -r | grep '^5' >/dev/null; then
+ 		    TCL_LIBS="$TCL_LIBS -R $try"
+ 		  fi
+ 		  break 3
+ 		fi
+ 	      done
+ 	    done
+ 	  done
+ 	  if test -z "$TCL_LIBS"; then
+ 	    AC_MSG_RESULT(<not found>)
+ 	    SKIP_TCL=YES
+ 	  fi
+ 	fi
+ 	if test -z "$SKIP_TCL"; then
+ 	  AC_DEFINE(FEAT_TCL)
+ 	  TCL_SRC=if_tcl.c
+ 	  TCL_OBJ=objects/if_tcl.o
+ 	  TCL_PRO=if_tcl.pro
+ 	  TCL_CFLAGS="-I$TCL_INC $TCL_DEFS"
+ 	fi
+       fi
+     else
+       AC_MSG_RESULT(too old; need Tcl version 8.0 or later)
+     fi
+   fi
+   if test "$enable_tclinterp" = "dynamic"; then
+     if test "X$TCL_SRC" != "X" -a "X$tcldll" != "X"; then
+       AC_DEFINE(DYNAMIC_TCL)
+       TCL_CFLAGS="-DDYNAMIC_TCL_DLL=\\\"$tcldll\\\" -DDYNAMIC_TCL_VER=\\\"$tclver\\\" $TCL_CFLAGS"
+     fi
+   fi
+   if test "$fail_if_missing" = "yes" -a -z "$TCL_SRC"; then
+     AC_MSG_ERROR([could not configure Tcl])
+   fi
+ fi
+ AC_SUBST(TCL_SRC)
+ AC_SUBST(TCL_OBJ)
+ AC_SUBST(TCL_PRO)
+ AC_SUBST(TCL_CFLAGS)
+ AC_SUBST(TCL_LIBS)
+ 
+ AC_MSG_CHECKING(--enable-rubyinterp argument)
+ AC_ARG_ENABLE(rubyinterp,
+ 	[  --enable-rubyinterp[=OPTS]     Include Ruby interpreter.  [default=no] [OPTS=no/yes/dynamic]], ,
+ 	[enable_rubyinterp="no"])
+ AC_MSG_RESULT($enable_rubyinterp)
+ if test "$enable_rubyinterp" = "yes" -o "$enable_rubyinterp" = "dynamic"; then
+   if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
+     AC_MSG_ERROR([cannot use Ruby with tiny or small features])
+   fi
+ 
+   AC_MSG_CHECKING(--with-ruby-command argument)
+   AC_SUBST(vi_cv_path_ruby)
+   AC_ARG_WITH(ruby-command, [  --with-ruby-command=RUBY  name of the Ruby command (default: ruby)],
+ 	RUBY_CMD="$withval"; vi_cv_path_ruby="$withval"; AC_MSG_RESULT($RUBY_CMD),
+ 	RUBY_CMD="ruby"; AC_MSG_RESULT(defaulting to $RUBY_CMD))
+   AC_PATH_PROG(vi_cv_path_ruby, $RUBY_CMD)
+   if test "X$vi_cv_path_ruby" != "X"; then
+     AC_MSG_CHECKING(Ruby version)
+     if $vi_cv_path_ruby -e '(VERSION rescue RUBY_VERSION) >= "1.6.0" or exit 1' >/dev/null 2>/dev/null; then
+       AC_MSG_RESULT(OK)
+       AC_MSG_CHECKING(Ruby rbconfig)
+       ruby_rbconfig="RbConfig"
+       if ! $vi_cv_path_ruby -r rbconfig -e 'RbConfig' >/dev/null 2>/dev/null; then
+ 	ruby_rbconfig="Config"
+       fi
+       AC_MSG_RESULT($ruby_rbconfig)
+       AC_MSG_CHECKING(Ruby header files)
+       rubyhdrdir=`$vi_cv_path_ruby -r mkmf -e "print $ruby_rbconfig::CONFIG[['rubyhdrdir']] || $ruby_rbconfig::CONFIG[['archdir']] || \\$hdrdir" 2>/dev/null`
+       if test "X$rubyhdrdir" != "X"; then
+ 	AC_MSG_RESULT($rubyhdrdir)
+ 	RUBY_CFLAGS="-I$rubyhdrdir"
+         rubyarchdir=`$vi_cv_path_ruby -r rbconfig -e "print ($ruby_rbconfig::CONFIG.has_key? 'rubyarchhdrdir') ? $ruby_rbconfig::CONFIG[['rubyarchhdrdir']] : '$rubyhdrdir/'+$ruby_rbconfig::CONFIG[['arch']]"`
+         if test -d "$rubyarchdir"; then
+           RUBY_CFLAGS="$RUBY_CFLAGS -I$rubyarchdir"
+         fi
+         rubyversion=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig::CONFIG[['ruby_version']].gsub(/\./, '')[[0,2]]"`
+ 	if test "X$rubyversion" = "X"; then
+ 	  rubyversion=`$vi_cv_path_ruby -e "print ((VERSION rescue RUBY_VERSION)).gsub(/\./, '')[[0,2]]"`
+ 	fi
+         RUBY_CFLAGS="$RUBY_CFLAGS -DRUBY_VERSION=$rubyversion"
+ 	rubylibs=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig::CONFIG[['LIBS']]"`
+ 	if test "X$rubylibs" != "X"; then
+ 	  RUBY_LIBS="$rubylibs"
+ 	fi
+ 	librubyarg=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig.expand($ruby_rbconfig::CONFIG[['LIBRUBYARG']])"`
+ 	librubya=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig.expand($ruby_rbconfig::CONFIG[['LIBRUBY_A']])"`
+ 	rubylibdir=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig.expand($ruby_rbconfig::CONFIG[['libdir']])"`
+ 	if test -f "$rubylibdir/$librubya"; then
+ 	  librubyarg="$librubyarg"
+ 	  RUBY_LIBS="$RUBY_LIBS -L$rubylibdir"
+ 	elif test "$librubyarg" = "libruby.a"; then
+ 	  dnl required on Mac OS 10.3 where libruby.a doesn't exist
+ 	  librubyarg="-lruby"
+ 	  RUBY_LIBS="$RUBY_LIBS -L$rubylibdir"
+ 	fi
+ 
+ 	if test "X$librubyarg" != "X"; then
+ 	  RUBY_LIBS="$librubyarg $RUBY_LIBS"
+ 	fi
+ 	rubyldflags=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig::CONFIG[['LDFLAGS']]"`
+ 	if test "X$rubyldflags" != "X"; then
+ 	  dnl Ruby on Mac OS X 10.5 adds "-arch" flags but these should only
+ 	  dnl be included if requested by passing --with-mac-arch to
+ 	  dnl configure, so strip these flags first (if present)
+ 	  rubyldflags=`echo "$rubyldflags" | sed -e 's/-arch\ ppc//' -e 's/-arch\ i386//' -e 's/-arch\ x86_64//'`
+ 	  if test "X$rubyldflags" != "X"; then
+ 	    if test "X`echo \"$LDFLAGS\" | $FGREP -e \"$rubyldflags\"`" = "X"; then
+ 	      LDFLAGS="$rubyldflags $LDFLAGS"
+ 	    fi
+ 	  fi
+ 	fi
+ 	RUBY_SRC="if_ruby.c"
+ 	RUBY_OBJ="objects/if_ruby.o"
+ 	RUBY_PRO="if_ruby.pro"
+ 	AC_DEFINE(FEAT_RUBY)
+ 	if test "$enable_rubyinterp" = "dynamic"; then
+ 	  libruby=`$vi_cv_path_ruby -r rbconfig -e "puts $ruby_rbconfig::CONFIG[['LIBRUBY_SO']]"`
+ 	  AC_DEFINE(DYNAMIC_RUBY)
+ 	  RUBY_CFLAGS="-DDYNAMIC_RUBY_DLL=\\\"$libruby\\\" -DDYNAMIC_RUBY_VER=$rubyversion $RUBY_CFLAGS"
+ 	  RUBY_LIBS=
+ 	fi
+       else
+ 	AC_MSG_RESULT(not found; disabling Ruby)
+       fi
+     else
+       AC_MSG_RESULT(too old; need Ruby version 1.6.0 or later)
+     fi
+   fi
+ 
+   if test "$fail_if_missing" = "yes" -a -z "$RUBY_OBJ"; then
+     AC_MSG_ERROR([could not configure Ruby])
+   fi
+ fi
+ AC_SUBST(RUBY_SRC)
+ AC_SUBST(RUBY_OBJ)
+ AC_SUBST(RUBY_PRO)
+ AC_SUBST(RUBY_CFLAGS)
+ AC_SUBST(RUBY_LIBS)
+ 
+ AC_MSG_CHECKING(--enable-cscope argument)
+ AC_ARG_ENABLE(cscope,
+ 	[  --enable-cscope         Include cscope interface.], ,
+ 	[enable_cscope="no"])
+ AC_MSG_RESULT($enable_cscope)
+ if test "$enable_cscope" = "yes"; then
+   AC_DEFINE(FEAT_CSCOPE)
+ fi
+ 
+ AC_MSG_CHECKING(--enable-workshop argument)
+ AC_ARG_ENABLE(workshop,
+ 	[  --enable-workshop       Include Sun Visual Workshop support.], ,
+ 	[enable_workshop="no"])
+ AC_MSG_RESULT($enable_workshop)
+ if test "$enable_workshop" = "yes"; then
+   AC_DEFINE(FEAT_SUN_WORKSHOP)
+   WORKSHOP_SRC="workshop.c integration.c"
+   AC_SUBST(WORKSHOP_SRC)
+   WORKSHOP_OBJ="objects/workshop.o objects/integration.o"
+   AC_SUBST(WORKSHOP_OBJ)
+   if test "${enable_gui-xxx}" = xxx; then
+     enable_gui=motif
+   fi
+ fi
+ 
+ AC_MSG_CHECKING(--disable-netbeans argument)
+ AC_ARG_ENABLE(netbeans,
+ 	[  --disable-netbeans      Disable NetBeans integration support.],
+ 	, [enable_netbeans="yes"])
+ if test "$enable_netbeans" = "yes"; then
+   if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
+     AC_MSG_RESULT([cannot use NetBeans with tiny or small features])
+     enable_netbeans="no"
+   else
+     AC_MSG_RESULT(no)
+   fi
+ else
+   AC_MSG_RESULT(yes)
+ fi
+ 
+ AC_MSG_CHECKING(--disable-channel argument)
+ AC_ARG_ENABLE(channel,
+ 	[  --disable-channel      Disable process communication support.],
+ 	, [enable_channel="yes"])
+ if test "$enable_channel" = "yes"; then
+   if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
+     AC_MSG_RESULT([cannot use channels with tiny or small features])
+     enable_channel="no"
+   else
+     AC_MSG_RESULT(no)
+   fi
+ else
+   if test "$enable_netbeans" = "yes"; then
+     AC_MSG_RESULT([yes, netbeans also disabled])
+     enable_netbeans="no"
+   else
+     AC_MSG_RESULT(yes)
+   fi
+ fi
+ 
+ if test "$enable_channel" = "yes"; then
+   dnl On Solaris we need the socket and nsl library.
+   AC_CHECK_LIB(socket, socket)
+   AC_CHECK_LIB(nsl, gethostbyname)
+   AC_MSG_CHECKING(whether compiling with process communication is possible)
+   AC_TRY_LINK([
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <stdarg.h>
+ #include <fcntl.h>
+ #include <netdb.h>
+ #include <netinet/in.h>
+ #include <errno.h>
+ #include <sys/types.h>
+ #include <sys/socket.h>
+ 	/* Check bitfields */
+ 	struct nbbuf {
+ 	unsigned int  initDone:1;
+ 	ushort signmaplen;
+ 	};
+ 	    ], [
+ 		/* Check creating a socket. */
+ 		struct sockaddr_in server;
+ 		(void)socket(AF_INET, SOCK_STREAM, 0);
+ 		(void)htons(100);
+ 		(void)gethostbyname("microsoft.com");
+ 		if (errno == ECONNREFUSED)
+ 		  (void)connect(1, (struct sockaddr *)&server, sizeof(server));
+ 	    ],
+ 	AC_MSG_RESULT(yes),
+ 	AC_MSG_RESULT(no); enable_netbeans="no"; enable_channel="no")
+ fi
+ if test "$enable_netbeans" = "yes"; then
+   AC_DEFINE(FEAT_NETBEANS_INTG)
+   NETBEANS_SRC="netbeans.c"
+   AC_SUBST(NETBEANS_SRC)
+   NETBEANS_OBJ="objects/netbeans.o"
+   AC_SUBST(NETBEANS_OBJ)
+ fi
+ if test "$enable_channel" = "yes"; then
+   AC_DEFINE(FEAT_JOB_CHANNEL)
+   CHANNEL_SRC="channel.c"
+   AC_SUBST(CHANNEL_SRC)
+   CHANNEL_OBJ="objects/channel.o"
+   AC_SUBST(CHANNEL_OBJ)
+ fi
+ 
+ AC_MSG_CHECKING(--enable-multibyte argument)
+ AC_ARG_ENABLE(multibyte,
+ 	[  --enable-multibyte      Include multibyte editing support.], ,
+ 	[enable_multibyte="no"])
+ AC_MSG_RESULT($enable_multibyte)
+ if test "$enable_multibyte" = "yes"; then
+   AC_DEFINE(FEAT_MBYTE)
+ fi
+ 
+ AC_MSG_CHECKING(--enable-hangulinput argument)
+ AC_ARG_ENABLE(hangulinput,
+ 	[  --enable-hangulinput    Include Hangul input support.], ,
+ 	[enable_hangulinput="no"])
+ AC_MSG_RESULT($enable_hangulinput)
+ 
+ AC_MSG_CHECKING(--enable-xim argument)
+ AC_ARG_ENABLE(xim,
+ 	[  --enable-xim            Include XIM input support.],
+ 	AC_MSG_RESULT($enable_xim),
+ 	[enable_xim="auto"; AC_MSG_RESULT(defaulting to auto)])
+ 
+ AC_MSG_CHECKING(--enable-fontset argument)
+ AC_ARG_ENABLE(fontset,
+ 	[  --enable-fontset        Include X fontset output support.], ,
+ 	[enable_fontset="no"])
+ AC_MSG_RESULT($enable_fontset)
+ dnl defining FEAT_XFONTSET is delayed, so that it can be disabled for no GUI
+ 
+ test -z "$with_x" && with_x=yes
+ test "${enable_gui-yes}" != no -a "x$MACOSX" != "xyes" -a "x$QNX" != "xyes" && with_x=yes
+ if test "$with_x" = no; then
+   AC_MSG_RESULT(defaulting to: don't HAVE_X11)
+ else
+   dnl Do this check early, so that its failure can override user requests.
+ 
+   AC_PATH_PROG(xmkmfpath, xmkmf)
+ 
+   AC_PATH_XTRA
+ 
+   dnl On z/OS Unix the X libraries are DLLs. To use them the code must
+   dnl be compiled with a special option.
+   dnl Also add SM, ICE and Xmu to X_EXTRA_LIBS.
+   if test "$zOSUnix" = "yes"; then
+     CFLAGS="$CFLAGS -W c,dll"
+     LDFLAGS="$LDFLAGS -W l,dll"
+     X_EXTRA_LIBS="$X_EXTRA_LIBS -lSM -lICE -lXmu"
+   fi
+ 
+   dnl On my HPUX system the X include dir is found, but the lib dir not.
+   dnl This is a desparate try to fix this.
+ 
+   if test -d "$x_includes" && test ! -d "$x_libraries"; then
+     x_libraries=`echo "$x_includes" | sed s/include/lib/`
+     AC_MSG_RESULT(Corrected X libraries to $x_libraries)
+     X_LIBS="$X_LIBS -L$x_libraries"
+     if test "`(uname) 2>/dev/null`" = SunOS &&
+ 					 uname -r | grep '^5' >/dev/null; then
+       X_LIBS="$X_LIBS -R $x_libraries"
+     fi
+   fi
+ 
+   if test -d "$x_libraries" && test ! -d "$x_includes"; then
+     x_includes=`echo "$x_libraries" | sed s/lib/include/`
+     AC_MSG_RESULT(Corrected X includes to $x_includes)
+     X_CFLAGS="$X_CFLAGS -I$x_includes"
+   fi
+ 
+   dnl Remove "-I/usr/include " from X_CFLAGS, should not be needed.
+   X_CFLAGS="`echo $X_CFLAGS\  | sed 's%-I/usr/include %%'`"
+   dnl Remove "-L/usr/lib " from X_LIBS, should not be needed.
+   X_LIBS="`echo $X_LIBS\  | sed 's%-L/usr/lib %%'`"
+   dnl Same for "-R/usr/lib ".
+   X_LIBS="`echo $X_LIBS\  | sed -e 's%-R/usr/lib %%' -e 's%-R /usr/lib %%'`"
+ 
+ 
+   dnl Check if the X11 header files are correctly installed. On some systems
+   dnl Xlib.h includes files that don't exist.  On some systems X11/Intrinsic.h
+   dnl is missing.
+   AC_MSG_CHECKING(if X11 header files can be found)
+   cflags_save=$CFLAGS
+   CFLAGS="$CFLAGS $X_CFLAGS"
+   AC_TRY_COMPILE([#include <X11/Xlib.h>
+ #include <X11/Intrinsic.h>], ,
+ 	AC_MSG_RESULT(yes),
+ 	AC_MSG_RESULT(no); no_x=yes)
+   CFLAGS=$cflags_save
+ 
+   if test "${no_x-no}" = yes; then
+     with_x=no
+   else
+     AC_DEFINE(HAVE_X11)
+     X_LIB="-lXt -lX11";
+     AC_SUBST(X_LIB)
+ 
+     ac_save_LDFLAGS="$LDFLAGS"
+     LDFLAGS="-L$x_libraries $LDFLAGS"
+ 
+     dnl Check for -lXdmcp (needed on SunOS 4.1.4)
+     dnl For HP-UX 10.20 it must be before -lSM -lICE
+     AC_CHECK_LIB(Xdmcp, _XdmcpAuthDoIt, [X_EXTRA_LIBS="$X_EXTRA_LIBS -lXdmcp"],,
+ 		[-lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS -lXdmcp])
+ 
+     dnl Some systems need -lnsl -lsocket when testing for ICE.
+     dnl The check above doesn't do this, try here (again).  Also needed to get
+     dnl them after Xdmcp.  link.sh will remove them when not needed.
+     dnl Check for other function than above to avoid the cached value
+     AC_CHECK_LIB(ICE, IceOpenConnection,
+ 		  [X_EXTRA_LIBS="$X_EXTRA_LIBS -lSM -lICE"],, [$X_EXTRA_LIBS])
+ 
+     dnl Check for -lXpm (needed for some versions of Motif)
+     LDFLAGS="$X_LIBS $ac_save_LDFLAGS"
+     AC_CHECK_LIB(Xpm, XpmCreatePixmapFromData, [X_PRE_LIBS="$X_PRE_LIBS -lXpm"],,
+ 		[-lXt $X_PRE_LIBS -lXpm -lX11 $X_EXTRA_LIBS])
+ 
+     dnl Check that the X11 header files don't use implicit declarations
+     AC_MSG_CHECKING(if X11 header files implicitly declare return values)
+     cflags_save=$CFLAGS
+     dnl -Werror is GCC only, others like Solaris Studio might not like it
+     if test "$GCC" = yes; then
+       CFLAGS="$CFLAGS $X_CFLAGS -Werror"
+     else
+       CFLAGS="$CFLAGS $X_CFLAGS"
+     fi
+     AC_TRY_COMPILE([#include <X11/Xlib.h>], ,
+ 	AC_MSG_RESULT(no),
+ 	CFLAGS="$CFLAGS -Wno-implicit-int"
+ 	AC_TRY_COMPILE([#include <X11/Xlib.h>], ,
+ 	    AC_MSG_RESULT(yes); cflags_save="$cflags_save -Wno-implicit-int",
+ 	    AC_MSG_RESULT(test failed)
+ 	)
+     )
+     CFLAGS=$cflags_save
+ 
+     LDFLAGS="$ac_save_LDFLAGS"
+ 
+     AC_MSG_CHECKING(size of wchar_t is 2 bytes)
+     AC_CACHE_VAL(ac_cv_small_wchar_t,
+ 	[AC_TRY_RUN([
+ #include <X11/Xlib.h>
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ 		main()
+ 		{
+ 		  if (sizeof(wchar_t) <= 2)
+ 		    exit(1);
+ 		  exit(0);
+ 		}],
+ 		ac_cv_small_wchar_t="no",
+ 		ac_cv_small_wchar_t="yes",
+ 		AC_MSG_ERROR(failed to compile test program))])
+     AC_MSG_RESULT($ac_cv_small_wchar_t)
+     if test "x$ac_cv_small_wchar_t" = "xyes" ; then
+       AC_DEFINE(SMALL_WCHAR_T)
+     fi
+ 
+   fi
+ fi
+ 
+ test "x$with_x" = xno -a "x$MACOSX" != "xyes" -a "x$QNX" != "xyes" && enable_gui=no
+ 
+ AC_MSG_CHECKING(--enable-gui argument)
+ AC_ARG_ENABLE(gui,
+  [  --enable-gui[=OPTS]     X11 GUI [default=auto] [OPTS=auto/no/gtk2/gnome2/gtk3/motif/athena/neXtaw/photon/carbon]], , enable_gui="auto")
+ 
+ dnl Canonicalize the --enable-gui= argument so that it can be easily compared.
+ dnl Do not use character classes for portability with old tools.
+ enable_gui_canon=`echo "_$enable_gui" | \
+ 	sed 's/[[ _+-]]//g;y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/'`
+ 
+ dnl Skip everything by default.
+ SKIP_GTK2=YES
+ SKIP_GTK3=YES
+ SKIP_GNOME=YES
+ SKIP_MOTIF=YES
+ SKIP_ATHENA=YES
+ SKIP_NEXTAW=YES
+ SKIP_PHOTON=YES
+ SKIP_CARBON=YES
+ GUITYPE=NONE
+ 
+ if test "x$QNX" = "xyes" -a "x$with_x" = "xno" ; then
+   SKIP_PHOTON=
+   case "$enable_gui_canon" in
+     no)		AC_MSG_RESULT(no GUI support)
+ 		SKIP_PHOTON=YES ;;
+     yes|"")	AC_MSG_RESULT(yes - automatic GUI support) ;;
+     auto)	AC_MSG_RESULT(auto - automatic GUI support) ;;
+     photon)	AC_MSG_RESULT(Photon GUI support) ;;
+     *)		AC_MSG_RESULT([Sorry, $enable_gui GUI is not supported])
+ 		SKIP_PHOTON=YES ;;
+   esac
+ 
+ elif test "x$MACOSX" = "xyes" -a "x$with_x" = "xno" ; then
+   SKIP_CARBON=
+   case "$enable_gui_canon" in
+     no)		AC_MSG_RESULT(no GUI support)
+ 		SKIP_CARBON=YES ;;
+     yes|"")	AC_MSG_RESULT(yes - automatic GUI support) ;;
+     auto)	AC_MSG_RESULT(auto - Carbon GUI is outdated - disable GUI support)
+ 		SKIP_CARBON=YES ;;
+     carbon)	AC_MSG_RESULT(Carbon GUI support) ;;
+     *)		AC_MSG_RESULT([Sorry, $enable_gui GUI is not supported])
+ 		SKIP_CARBON=YES ;;
+   esac
+ 
+ else
+ 
+   case "$enable_gui_canon" in
+     no|none)	AC_MSG_RESULT(no GUI support) ;;
+     yes|""|auto)	AC_MSG_RESULT(yes/auto - automatic GUI support)
+ 		SKIP_GTK2=
+ 		SKIP_GNOME=
+ 		SKIP_MOTIF=
+ 		SKIP_ATHENA=
+ 		SKIP_NEXTAW=
+ 		SKIP_CARBON=;;
+     gtk2)	AC_MSG_RESULT(GTK+ 2.x GUI support)
+ 		SKIP_GTK2=;;
+     gnome2)	AC_MSG_RESULT(GNOME 2.x GUI support)
+ 		SKIP_GNOME=
+ 		SKIP_GTK2=;;
+     gtk3)	AC_MSG_RESULT(GTK+ 3.x GUI support)
+ 		SKIP_GTK3=;;
+     motif)	AC_MSG_RESULT(Motif GUI support)
+ 		SKIP_MOTIF=;;
+     athena)	AC_MSG_RESULT(Athena GUI support)
+ 		SKIP_ATHENA=;;
+     nextaw)	AC_MSG_RESULT(neXtaw GUI support)
+ 		SKIP_NEXTAW=;;
+     *)		AC_MSG_RESULT([Sorry, $enable_gui GUI is not supported]) ;;
+   esac
+ 
+ fi
+ 
+ if test "x$SKIP_GTK2" != "xYES" -a "$enable_gui_canon" != "gtk2" \
+ 				-a "$enable_gui_canon" != "gnome2"; then
+   AC_MSG_CHECKING(whether or not to look for GTK+ 2)
+   AC_ARG_ENABLE(gtk2-check,
+ 	[  --enable-gtk2-check     If auto-select GUI, check for GTK+ 2 [default=yes]],
+ 	, enable_gtk2_check="yes")
+   AC_MSG_RESULT($enable_gtk2_check)
+   if test "x$enable_gtk2_check" = "xno"; then
+     SKIP_GTK2=YES
+     SKIP_GNOME=YES
+   fi
+ fi
+ 
+ if test "x$SKIP_GNOME" != "xYES" -a "$enable_gui_canon" != "gnome2"; then
+   AC_MSG_CHECKING(whether or not to look for GNOME)
+   AC_ARG_ENABLE(gnome-check,
+ 	[  --enable-gnome-check    If GTK GUI, check for GNOME [default=no]],
+ 	, enable_gnome_check="no")
+   AC_MSG_RESULT($enable_gnome_check)
+   if test "x$enable_gnome_check" = "xno"; then
+     SKIP_GNOME=YES
+   fi
+ fi
+ 
+ if test "x$SKIP_GTK3" != "xYES" -a "$enable_gui_canon" != "gtk3"; then
+   AC_MSG_CHECKING(whether or not to look for GTK+ 3)
+   AC_ARG_ENABLE(gtk3-check,
+ 	[  --enable-gtk3-check     If auto-select GUI, check for GTK+ 3 [default=yes]],
+ 	, enable_gtk3_check="yes")
+   AC_MSG_RESULT($enable_gtk3_check)
+   if test "x$enable_gtk3_check" = "xno"; then
+     SKIP_GTK3=YES
+   fi
+ fi
+ 
+ if test "x$SKIP_MOTIF" != "xYES" -a "$enable_gui_canon" != "motif"; then
+   AC_MSG_CHECKING(whether or not to look for Motif)
+   AC_ARG_ENABLE(motif-check,
+ 	[  --enable-motif-check    If auto-select GUI, check for Motif [default=yes]],
+ 	, enable_motif_check="yes")
+   AC_MSG_RESULT($enable_motif_check)
+   if test "x$enable_motif_check" = "xno"; then
+     SKIP_MOTIF=YES
+   fi
+ fi
+ 
+ if test "x$SKIP_ATHENA" != "xYES" -a "$enable_gui_canon" != "athena"; then
+   AC_MSG_CHECKING(whether or not to look for Athena)
+   AC_ARG_ENABLE(athena-check,
+ 	[  --enable-athena-check   If auto-select GUI, check for Athena [default=yes]],
+ 	, enable_athena_check="yes")
+   AC_MSG_RESULT($enable_athena_check)
+   if test "x$enable_athena_check" = "xno"; then
+     SKIP_ATHENA=YES
+   fi
+ fi
+ 
+ if test "x$SKIP_NEXTAW" != "xYES" -a "$enable_gui_canon" != "nextaw"; then
+   AC_MSG_CHECKING(whether or not to look for neXtaw)
+   AC_ARG_ENABLE(nextaw-check,
+ 	[  --enable-nextaw-check   If auto-select GUI, check for neXtaw [default=yes]],
+ 	, enable_nextaw_check="yes")
+   AC_MSG_RESULT($enable_nextaw_check);
+   if test "x$enable_nextaw_check" = "xno"; then
+     SKIP_NEXTAW=YES
+   fi
+ fi
+ 
+ if test "x$SKIP_CARBON" != "xYES" -a "$enable_gui_canon" != "carbon"; then
+   AC_MSG_CHECKING(whether or not to look for Carbon)
+   AC_ARG_ENABLE(carbon-check,
+ 	[  --enable-carbon-check   If auto-select GUI, check for Carbon [default=yes]],
+ 	, enable_carbon_check="yes")
+   AC_MSG_RESULT($enable_carbon_check);
+   if test "x$enable_carbon_check" = "xno"; then
+     SKIP_CARBON=YES
+   fi
+ fi
+ 
+ 
+ if test "x$MACOSX" = "xyes" -a -z "$SKIP_CARBON" -a "x$CARBON" = "xyes"; then
+   AC_MSG_CHECKING(for Carbon GUI)
+   dnl already did the check, just give the message
+   AC_MSG_RESULT(yes);
+   GUITYPE=CARBONGUI
+   if test "$VIMNAME" = "vim"; then
+     VIMNAME=Vim
+   fi
+ 
+   if test "x$MACARCH" = "xboth"; then
+     CPPFLAGS="$CPPFLAGS -I$DEVELOPER_DIR/SDKs/MacOSX10.4u.sdk/Developer/Headers/FlatCarbon"
+   else
+     CPPFLAGS="$CPPFLAGS -I$DEVELOPER_DIR/Headers/FlatCarbon"
+   fi
+ 
+   dnl Default install directory is not /usr/local
+   if test x$prefix = xNONE; then
+     prefix=/Applications
+   fi
+ 
+   dnl Sorry for the hard coded default
+   datadir='${prefix}/Vim.app/Contents/Resources'
+ 
+   dnl skip everything else
+   SKIP_GTK2=YES;
+   SKIP_GNOME=YES;
+   SKIP_MOTIF=YES;
+   SKIP_ATHENA=YES;
+   SKIP_NEXTAW=YES;
+   SKIP_PHOTON=YES;
+   SKIP_CARBON=YES
+ fi
+ 
+ dnl define an autoconf function to check for a specified version of GTK, and
+ dnl try to compile/link a GTK program.
+ dnl
+ dnl AM_PATH_GTK([MINIMUM-VERSION, [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND]]])
+ dnl Test for GTK, and define GTK_CFLAGS, GTK_LIBDIR and GTK_LIBS
+ dnl
+ AC_DEFUN(AM_PATH_GTK,
+ [
+   if test "X$GTK_CONFIG" != "Xno" -o "X$PKG_CONFIG" != "Xno"; then
+   {
+     no_gtk=""
+     if (test "X$SKIP_GTK2" != "XYES" -a "X$PKG_CONFIG" != "Xno") \
+ 	  && $PKG_CONFIG --exists gtk+-2.0; then
+     {
+       min_gtk_version=ifelse([$1], ,2.2.0,$1)
+       AC_MSG_CHECKING(for GTK - version >= $min_gtk_version)
+       dnl We should be using PKG_CHECK_MODULES() instead of this hack.
+       dnl But I guess the dependency on pkgconfig.m4 is not wanted or
+       dnl something like that.
+       GTK_CFLAGS=`$PKG_CONFIG --cflags gtk+-2.0`
+       GTK_LIBDIR=`$PKG_CONFIG --libs-only-L gtk+-2.0`
+       GTK_LIBS=`$PKG_CONFIG --libs gtk+-2.0`
+       gtk_major_version=`$PKG_CONFIG --modversion gtk+-2.0 | \
+ 	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\1/'`
+       gtk_minor_version=`$PKG_CONFIG --modversion gtk+-2.0 | \
+ 	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\2/'`
+       gtk_micro_version=`$PKG_CONFIG --modversion gtk+-2.0 | \
+ 	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\3/'`
+     }
+     elif (test "X$SKIP_GTK3" != "XYES" -a "X$PKG_CONFIG" != "Xno") \
+ 	  && $PKG_CONFIG --exists gtk+-3.0; then
+     {
+       min_gtk_version=ifelse([$1], ,3.0.0,$1)
+       AC_MSG_CHECKING(for GTK - version >= $min_gtk_version)
+ 
+       GTK_CFLAGS=`$PKG_CONFIG --cflags gtk+-3.0`
+       GTK_LIBDIR=`$PKG_CONFIG --libs-only-L gtk+-3.0`
+       GTK_LIBS=`$PKG_CONFIG --libs gtk+-3.0`
+       gtk_major_version=`$PKG_CONFIG --modversion gtk+-3.0 | \
+ 	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\1/'`
+       gtk_minor_version=`$PKG_CONFIG --modversion gtk+-3.0 | \
+ 	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\2/'`
+       gtk_micro_version=`$PKG_CONFIG --modversion gtk+-3.0 | \
+ 	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\3/'`
+     }
+     else
+       no_gtk=yes
+     fi
+ 
+     if test "x$enable_gtktest" = "xyes" -a "x$no_gtk" = "x"; then
+     {
+       ac_save_CFLAGS="$CFLAGS"
+       ac_save_LIBS="$LIBS"
+       CFLAGS="$CFLAGS $GTK_CFLAGS"
+       LIBS="$LIBS $GTK_LIBS"
+ 
+       dnl
+       dnl Now check if the installed GTK is sufficiently new.
+       dnl
+       rm -f conf.gtktest
+       AC_TRY_RUN([
+ #include <gtk/gtk.h>
+ #include <stdio.h>
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ 
+ int
+ main ()
+ {
+ int major, minor, micro;
+ char *tmp_version;
+ 
+ system ("touch conf.gtktest");
+ 
+ /* HP/UX 9 (%@#!) writes to sscanf strings */
+ tmp_version = g_strdup("$min_gtk_version");
+ if (sscanf(tmp_version, "%d.%d.%d", &major, &minor, &micro) != 3) {
+    printf("%s, bad version string\n", "$min_gtk_version");
+    exit(1);
+  }
+ 
+ if ((gtk_major_version > major) ||
+     ((gtk_major_version == major) && (gtk_minor_version > minor)) ||
+     ((gtk_major_version == major) && (gtk_minor_version == minor) &&
+ 				     (gtk_micro_version >= micro)))
+ {
+     return 0;
+ }
+ return 1;
+ }
+ ],, no_gtk=yes,[echo $ac_n "cross compiling; assumed OK... $ac_c"])
+       CFLAGS="$ac_save_CFLAGS"
+       LIBS="$ac_save_LIBS"
+     }
+     fi
+     if test "x$no_gtk" = x ; then
+       if test "x$enable_gtktest" = "xyes"; then
+ 	AC_MSG_RESULT(yes; found version $gtk_major_version.$gtk_minor_version.$gtk_micro_version)
+       else
+ 	AC_MSG_RESULT(found version $gtk_major_version.$gtk_minor_version.$gtk_micro_version)
+       fi
+       ifelse([$2], , :, [$2])
+     else
+     {
+       AC_MSG_RESULT(no)
+       GTK_CFLAGS=""
+       GTK_LIBS=""
+       ifelse([$3], , :, [$3])
+     }
+     fi
+   }
+   else
+     GTK_CFLAGS=""
+     GTK_LIBS=""
+     ifelse([$3], , :, [$3])
+   fi
+   AC_SUBST(GTK_CFLAGS)
+   AC_SUBST(GTK_LIBS)
+   rm -f conf.gtktest
+ ])
+ 
+ dnl ---------------------------------------------------------------------------
+ dnl gnome
+ dnl ---------------------------------------------------------------------------
+ AC_DEFUN([GNOME_INIT_HOOK],
+ [
+   AC_SUBST(GNOME_LIBS)
+   AC_SUBST(GNOME_LIBDIR)
+   AC_SUBST(GNOME_INCLUDEDIR)
+ 
+   AC_ARG_WITH(gnome-includes,
+     [  --with-gnome-includes=DIR Specify location of GNOME headers],
+     [CFLAGS="$CFLAGS -I$withval"]
+   )
+ 
+   AC_ARG_WITH(gnome-libs,
+     [  --with-gnome-libs=DIR   Specify location of GNOME libs],
+     [LDFLAGS="$LDFLAGS -L$withval" gnome_prefix=$withval]
+   )
+ 
+   AC_ARG_WITH(gnome,
+     [  --with-gnome            Specify prefix for GNOME files],
+     if test x$withval = xyes; then
+       want_gnome=yes
+       ifelse([$1], [], :, [$1])
+     else
+       if test "x$withval" = xno; then
+ 	want_gnome=no
+       else
+ 	want_gnome=yes
+ 	LDFLAGS="$LDFLAGS -L$withval/lib"
+ 	CFLAGS="$CFLAGS -I$withval/include"
+ 	gnome_prefix=$withval/lib
+       fi
+     fi,
+     want_gnome=yes)
+ 
+   if test "x$want_gnome" = xyes; then
+   {
+     AC_MSG_CHECKING(for libgnomeui-2.0)
+     if $PKG_CONFIG --exists libgnomeui-2.0; then
+       AC_MSG_RESULT(yes)
+       GNOME_LIBS=`$PKG_CONFIG --libs-only-l libgnomeui-2.0`
+       GNOME_LIBDIR=`$PKG_CONFIG --libs-only-L libgnomeui-2.0`
+       GNOME_INCLUDEDIR=`$PKG_CONFIG --cflags libgnomeui-2.0`
+ 
+       dnl On FreeBSD we need -pthread but pkg-config doesn't include it.
+       dnl This might not be the right way but it works for me...
+       AC_MSG_CHECKING(for FreeBSD)
+       if test "`(uname) 2>/dev/null`" = FreeBSD; then
+ 	AC_MSG_RESULT(yes, adding -pthread)
+ 	GNOME_INCLUDEDIR="$GNOME_INCLUDEDIR -D_THREAD_SAFE"
+ 	GNOME_LIBS="$GNOME_LIBS -pthread"
+       else
+ 	AC_MSG_RESULT(no)
+       fi
+       $1
+     else
+       AC_MSG_RESULT(not found)
+       if test "x$2" = xfail; then
+ 	AC_MSG_ERROR(Could not find libgnomeui-2.0 via pkg-config)
+       fi
+     fi
+   }
+   fi
+ ])
+ 
+ AC_DEFUN([GNOME_INIT],[
+ 	GNOME_INIT_HOOK([],fail)
+ ])
+ 
+ 
+ dnl ---------------------------------------------------------------------------
+ dnl Check for GTK2.  If it fails, then continue on for Motif as before...
+ dnl ---------------------------------------------------------------------------
+ if test -z "$SKIP_GTK2"; then
+ 
+   AC_MSG_CHECKING(--disable-gtktest argument)
+   AC_ARG_ENABLE(gtktest, [  --disable-gtktest       Do not try to compile and run a test GTK program],
+ 	, enable_gtktest=yes)
+   if test "x$enable_gtktest" = "xyes" ; then
+     AC_MSG_RESULT(gtk test enabled)
+   else
+     AC_MSG_RESULT(gtk test disabled)
+   fi
+ 
+   if test "X$PKG_CONFIG" = "X"; then
+     AC_PATH_PROG(PKG_CONFIG, pkg-config, no)
+   fi
+ 
+   if test "x$PKG_CONFIG" != "xno"; then
+     dnl First try finding version 2.2.0 or later.  The 2.0.x series has
+     dnl problems (bold fonts, --remote doesn't work).
+     AM_PATH_GTK(2.2.0,
+ 		[GUI_LIB_LOC="$GTK_LIBDIR"
+ 		 GTK_LIBNAME="$GTK_LIBS"
+ 		GUI_INC_LOC="$GTK_CFLAGS"], )
+     if test "x$GTK_CFLAGS" != "x"; then
+       SKIP_GTK3=YES
+       SKIP_ATHENA=YES
+       SKIP_NEXTAW=YES
+       SKIP_MOTIF=YES
+       GUITYPE=GTK
+       AC_SUBST(GTK_LIBNAME)
+     fi
+   fi
+   if test "x$GUITYPE" = "xGTK"; then
+     if test "$gtk_minor_version" = 1 -a "0$gtk_micro_version" -ge 1 \
+ 	|| test "0$gtk_minor_version" -ge 2; then
+       AC_DEFINE(HAVE_GTK_MULTIHEAD)
+     fi
+     dnl
+     dnl if GTK exists, then check for GNOME.
+     dnl
+     if test -z "$SKIP_GNOME"; then
+     {
+       GNOME_INIT_HOOK([have_gnome=yes])
+       if test "x$have_gnome" = xyes ; then
+ 	AC_DEFINE(FEAT_GUI_GNOME)
+ 	GUI_INC_LOC="$GUI_INC_LOC $GNOME_INCLUDEDIR"
+ 	GTK_LIBNAME="$GTK_LIBNAME $GNOME_LIBDIR $GNOME_LIBS"
+       fi
+     }
+     fi
+   fi
+ fi
+ 
+ 
+ dnl ---------------------------------------------------------------------------
+ dnl Check for GTK3.
+ dnl ---------------------------------------------------------------------------
+ if test -z "$SKIP_GTK3"; then
+ 
+   AC_MSG_CHECKING(--disable-gtktest argument)
+   AC_ARG_ENABLE(gtktest, [  --disable-gtktest       Do not try to compile and run a test GTK program],
+ 	, enable_gtktest=yes)
+   if test "x$enable_gtktest" = "xyes" ; then
+     AC_MSG_RESULT(gtk test enabled)
+   else
+     AC_MSG_RESULT(gtk test disabled)
+   fi
+ 
+   if test "X$PKG_CONFIG" = "X"; then
+     AC_PATH_PROG(PKG_CONFIG, pkg-config, no)
+   fi
+ 
+   if test "x$PKG_CONFIG" != "xno"; then
+     AM_PATH_GTK(3.0.0,
+ 		[GUI_LIB_LOC="$GTK_LIBDIR"
+ 		 GTK_LIBNAME="$GTK_LIBS"
+ 		GUI_INC_LOC="$GTK_CFLAGS"], )
+     if test "x$GTK_CFLAGS" != "x"; then
+       SKIP_GTK2=YES
+       SKIP_GNOME=YES
+       SKIP_ATHENA=YES
+       SKIP_NEXTAW=YES
+       SKIP_MOTIF=YES
+       GUITYPE=GTK
+       AC_SUBST(GTK_LIBNAME)
+       AC_DEFINE(HAVE_GTK_MULTIHEAD)
+       AC_DEFINE(USE_GTK3)
+     fi
+   fi
+ fi
+ 
+ dnl Check the version of Gdk-Pixbuf.  If the version is 2.31 or later and
+ dnl glib-compile-resources is found in PATH, use GResource.
+ if test "x$GUITYPE" = "xGTK"; then
+   AC_MSG_CHECKING([version of Gdk-Pixbuf])
+   gdk_pixbuf_version=`$PKG_CONFIG --modversion gdk-pixbuf-2.0`
+   if test "x$gdk_pixbuf_version" != x ; then
+     gdk_pixbuf_version_minor=`echo $gdk_pixbuf_version | \
+       sed -e 's/[[0-9]][[0-9]]*\.\([[0-9]][[0-9]]*\)\.[[0-9]][[0-9]]*/\1/'`
+     if test "x$gdk_pixbuf_version_minor" != x -a \
+ 	$gdk_pixbuf_version_minor -ge 31 ; then
+       AC_MSG_RESULT([OK.])
+       AC_PATH_PROG(GLIB_COMPILE_RESOURCES,[glib-compile-resources],no)
+       AC_MSG_CHECKING([glib-compile-resources])
+       if test "x$GLIB_COMPILE_RESOURCES" = xno ; then
+ 	GLIB_COMPILE_RESOURCES=""
+ 	AC_MSG_RESULT([cannot be found in PATH.])
+       else
+ 	AC_MSG_RESULT([usable.])
+ 	AC_DEFINE(USE_GRESOURCE)
+ 	GRESOURCE_SRC="auto/gui_gtk_gresources.c"
+ 	GRESOURCE_OBJ="objects/gui_gtk_gresources.o"
+       fi
+     else
+       AC_MSG_RESULT([not usable.])
+     fi
+   else
+     AC_MSG_RESULT([cannot obtain from pkg_config.])
+   fi
+ 
+   AC_MSG_CHECKING([--disable-icon-cache-update argument])
+   AC_ARG_ENABLE(icon_cache_update,
+           [  --disable-icon-cache-update        update disabled],
+           [],
+           [enable_icon_cache_update="yes"])
+   if test "$enable_icon_cache_update" = "yes"; then
+     AC_MSG_RESULT([not set])
+     AC_PATH_PROG(GTK_UPDATE_ICON_CACHE,[gtk-update-icon-cache],no)
+     if test "x$GTK_UPDATE_ICON_CACHE" = "xno" ; then
+       AC_MSG_RESULT([not found in PATH.])
+     fi
+   else
+     AC_MSG_RESULT([update disabled])
+   fi
+ 
+   AC_MSG_CHECKING([--disable-desktop-database-update argument])
+   AC_ARG_ENABLE(desktop_database_update,
+           [  --disable-desktop-database-update  update disabled],
+           [],
+           [enable_desktop_database_update="yes"])
+   if test "$enable_desktop_database_update" = "yes"; then
+     AC_MSG_RESULT([not set])
+     AC_PATH_PROG(UPDATE_DESKTOP_DATABASE,[update-desktop-database],no)
+     if test "x$UPDATE_DESKTOP_DATABASE" = "xno" ; then
+       AC_MSG_RESULT([not found in PATH.])
+     fi
+   else
+     AC_MSG_RESULT([update disabled])
+   fi
+ fi
+ AC_SUBST(GLIB_COMPILE_RESOURCES)
+ AC_SUBST(GRESOURCE_SRC)
+ AC_SUBST(GRESOURCE_OBJ)
+ AC_SUBST(GTK_UPDATE_ICON_CACHE)
+ AC_SUBST(UPDATE_DESKTOP_DATABASE)
+ 
+ dnl Check for Motif include files location.
+ dnl The LAST one found is used, this makes the highest version to be used,
+ dnl e.g. when Motif1.2 and Motif2.0 are both present.
+ 
+ if test -z "$SKIP_MOTIF"; then
+   gui_XXX="/usr/XXX/Motif* /usr/Motif*/XXX /usr/XXX /usr/shlib /usr/X11*/XXX /usr/XXX/X11* /usr/dt/XXX /local/Motif*/XXX /local/XXX/Motif* /usr/local/Motif*/XXX /usr/local/XXX/Motif* /usr/local/XXX /usr/local/X11*/XXX /usr/local/LessTif/Motif*/XXX $MOTIFHOME/XXX"
+   dnl Remove "-I" from before $GUI_INC_LOC if it's there
+   GUI_INC_LOC="`echo $GUI_INC_LOC|sed 's%-I%%g'`"
+ 
+   AC_MSG_CHECKING(for location of Motif GUI includes)
+   gui_includes="`echo $x_includes|sed 's%/[^/][^/]*$%%'` `echo "$gui_XXX" | sed s/XXX/include/g` $GUI_INC_LOC"
+   GUI_INC_LOC=
+   for try in $gui_includes; do
+     if test -f "$try/Xm/Xm.h"; then
+       GUI_INC_LOC=$try
+     fi
+   done
+   if test -n "$GUI_INC_LOC"; then
+     if test "$GUI_INC_LOC" = /usr/include; then
+       GUI_INC_LOC=
+       AC_MSG_RESULT(in default path)
+     else
+       AC_MSG_RESULT($GUI_INC_LOC)
+     fi
+   else
+     AC_MSG_RESULT(<not found>)
+     SKIP_MOTIF=YES
+   fi
+ fi
+ 
+ dnl Check for Motif library files location.  In the same order as the include
+ dnl files, to avoid a mixup if several versions are present
+ 
+ if test -z "$SKIP_MOTIF"; then
+   AC_MSG_CHECKING(--with-motif-lib argument)
+   AC_ARG_WITH(motif-lib,
+   [  --with-motif-lib=STRING   Library for Motif ],
+   [ MOTIF_LIBNAME="${withval}" ] )
+ 
+   if test -n "$MOTIF_LIBNAME"; then
+     AC_MSG_RESULT($MOTIF_LIBNAME)
+     GUI_LIB_LOC=
+   else
+     AC_MSG_RESULT(no)
+ 
+     dnl Remove "-L" from before $GUI_LIB_LOC if it's there
+     GUI_LIB_LOC="`echo $GUI_LIB_LOC|sed 's%-L%%g'`"
+ 
+     dnl Ubuntu has libXm.so in /usr/lib/i386-linux-gnu and elsewhere.  The
+     dnl linker will figure out which one to use, we only check if one exists.
+     AC_MSG_CHECKING(for location of Motif GUI libs)
+     gui_libs="`echo $x_libraries|sed 's%/[^/][^/]*$%%'` `echo "$gui_XXX" | sed s/XXX/lib/g` /usr/lib/i386-linux-gnu /usr/lib/x86_64-linux-gnu `echo "$GUI_INC_LOC" | sed s/include/lib/` $GUI_LIB_LOC"
+     GUI_LIB_LOC=
+     for try in $gui_libs; do
+       for libtry in "$try"/libXm.a "$try"/libXm.so* "$try"/libXm.sl "$try"/libXm.dylib; do
+ 	if test -f "$libtry"; then
+ 	  GUI_LIB_LOC=$try
+ 	fi
+       done
+     done
+     if test -n "$GUI_LIB_LOC"; then
+       dnl Remove /usr/lib, it causes trouble on some systems
+       if test "$GUI_LIB_LOC" = /usr/lib \
+ 	   -o "$GUI_LIB_LOC" = /usr/lib/i386-linux-gnu \
+ 	   -o "$GUI_LIB_LOC" = /usr/lib/x86_64-linux-gnu; then
+ 	GUI_LIB_LOC=
+ 	AC_MSG_RESULT(in default path)
+       else
+ 	if test -n "$GUI_LIB_LOC"; then
+ 	  AC_MSG_RESULT($GUI_LIB_LOC)
+ 	  if test "`(uname) 2>/dev/null`" = SunOS &&
+ 					 uname -r | grep '^5' >/dev/null; then
+ 	    GUI_LIB_LOC="$GUI_LIB_LOC -R $GUI_LIB_LOC"
+ 	  fi
+ 	fi
+       fi
+       MOTIF_LIBNAME=-lXm
+     else
+       AC_MSG_RESULT(<not found>)
+       SKIP_MOTIF=YES
+     fi
+   fi
+ fi
+ 
+ if test -z "$SKIP_MOTIF"; then
+   SKIP_ATHENA=YES
+   SKIP_NEXTAW=YES
+   GUITYPE=MOTIF
+   AC_SUBST(MOTIF_LIBNAME)
+ fi
+ 
+ dnl Check if the Athena files can be found
+ 
+ GUI_X_LIBS=
+ 
+ if test -z "$SKIP_ATHENA"; then
+   AC_MSG_CHECKING(if Athena header files can be found)
+   cflags_save=$CFLAGS
+   CFLAGS="$CFLAGS $X_CFLAGS"
+   AC_TRY_COMPILE([
+ #include <X11/Intrinsic.h>
+ #include <X11/Xaw/Paned.h>], ,
+ 	AC_MSG_RESULT(yes),
+ 	AC_MSG_RESULT(no); SKIP_ATHENA=YES )
+   CFLAGS=$cflags_save
+ fi
+ 
+ if test -z "$SKIP_ATHENA"; then
+   GUITYPE=ATHENA
+ fi
+ 
+ if test -z "$SKIP_NEXTAW"; then
+   AC_MSG_CHECKING(if neXtaw header files can be found)
+   cflags_save=$CFLAGS
+   CFLAGS="$CFLAGS $X_CFLAGS"
+   AC_TRY_COMPILE([
+ #include <X11/Intrinsic.h>
+ #include <X11/neXtaw/Paned.h>], ,
+ 	AC_MSG_RESULT(yes),
+ 	AC_MSG_RESULT(no); SKIP_NEXTAW=YES )
+   CFLAGS=$cflags_save
+ fi
+ 
+ if test -z "$SKIP_NEXTAW"; then
+   GUITYPE=NEXTAW
+ fi
+ 
+ if test -z "$SKIP_ATHENA" -o -z "$SKIP_NEXTAW" -o -z "$SKIP_MOTIF"; then
+   dnl Prepend -I and -L to $GUI_INC_LOC and $GUI_LIB_LOC if not empty
+   dnl Avoid adding it when it twice
+   if test -n "$GUI_INC_LOC"; then
+     GUI_INC_LOC=-I"`echo $GUI_INC_LOC|sed 's%-I%%'`"
+   fi
+   if test -n "$GUI_LIB_LOC"; then
+     GUI_LIB_LOC=-L"`echo $GUI_LIB_LOC|sed 's%-L%%'`"
+   fi
+ 
+   dnl Check for -lXext and then for -lXmu
+   ldflags_save=$LDFLAGS
+   LDFLAGS="$X_LIBS $LDFLAGS"
+   AC_CHECK_LIB(Xext, XShapeQueryExtension, [GUI_X_LIBS="-lXext"],,
+ 		[-lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])
+   dnl For Solaris we need -lw and -ldl before linking with -lXmu works.
+   AC_CHECK_LIB(w, wslen, [X_EXTRA_LIBS="$X_EXTRA_LIBS -lw"],,
+ 		[$GUI_X_LIBS -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])
+   AC_CHECK_LIB(dl, dlsym, [X_EXTRA_LIBS="$X_EXTRA_LIBS -ldl"],,
+ 		[$GUI_X_LIBS -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])
+   AC_CHECK_LIB(Xmu, XmuCreateStippledPixmap, [GUI_X_LIBS="-lXmu $GUI_X_LIBS"],,
+ 		[$GUI_X_LIBS -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])
+   if test -z "$SKIP_MOTIF"; then
+     AC_CHECK_LIB(Xp, XpEndJob, [GUI_X_LIBS="-lXp $GUI_X_LIBS"],,
+ 		[$GUI_X_LIBS -lXm -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])
+   fi
+   LDFLAGS=$ldflags_save
+ 
+   dnl Execute xmkmf to figure out if -DNARROWPROTO is needed.
+   AC_MSG_CHECKING(for extra X11 defines)
+   NARROW_PROTO=
+   rm -fr conftestdir
+   if mkdir conftestdir; then
+     cd conftestdir
+     cat > Imakefile <<'EOF'
+ acfindx:
+ 	@echo 'NARROW_PROTO="${PROTO_DEFINES}"'
+ EOF
+     if (xmkmf) >/dev/null 2>/dev/null && test -f Makefile; then
+       eval `${MAKE-make} acfindx 2>/dev/null | grep -v make`
+     fi
+     cd ..
+     rm -fr conftestdir
+   fi
+   if test -z "$NARROW_PROTO"; then
+     AC_MSG_RESULT(no)
+   else
+     AC_MSG_RESULT($NARROW_PROTO)
+   fi
+   AC_SUBST(NARROW_PROTO)
+ fi
+ 
+ dnl Look for XSMP support - but don't necessarily restrict it to X11 GUIs
+ dnl use the X11 include path
+ if test "$enable_xsmp" = "yes"; then
+   cppflags_save=$CPPFLAGS
+   CPPFLAGS="$CPPFLAGS $X_CFLAGS"
+   AC_CHECK_HEADERS(X11/SM/SMlib.h)
+   CPPFLAGS=$cppflags_save
+ fi
+ 
+ 
+ if test -z "$SKIP_ATHENA" -o -z "$SKIP_NEXTAW" -o -z "$SKIP_MOTIF" -o -z "$SKIP_GTK2" -o -z "$SKIP_GTK3"; then
+   dnl Check for X11/xpm.h and X11/Sunkeysym.h with the GUI include path
+   cppflags_save=$CPPFLAGS
+   CPPFLAGS="$CPPFLAGS $X_CFLAGS"
+   AC_CHECK_HEADERS(X11/xpm.h X11/Sunkeysym.h)
+ 
+   dnl automatically disable XIM when XIMtext isn't in X11/Xlib.h
+   if test ! "$enable_xim" = "no"; then
+     AC_MSG_CHECKING(for XIMText in X11/Xlib.h)
+     AC_EGREP_CPP(XIMText, [#include <X11/Xlib.h>],
+ 		  AC_MSG_RESULT(yes),
+ 		  AC_MSG_RESULT(no; xim has been disabled); enable_xim="no")
+   fi
+   CPPFLAGS=$cppflags_save
+ 
+   dnl automatically enable XIM when hangul input isn't enabled
+   if test "$enable_xim" = "auto" -a "$enable_hangulinput" != "yes" \
+ 		-a "x$GUITYPE" != "xNONE" ; then
+     AC_MSG_RESULT(X GUI selected; xim has been enabled)
+     enable_xim="yes"
+   fi
+ fi
+ 
+ if test -z "$SKIP_ATHENA" -o -z "$SKIP_NEXTAW" -o -z "$SKIP_MOTIF"; then
+   cppflags_save=$CPPFLAGS
+   CPPFLAGS="$CPPFLAGS $X_CFLAGS"
+ dnl Xmu/Editres.h may exist but can only be used after including Intrinsic.h
+   AC_MSG_CHECKING([for X11/Xmu/Editres.h])
+   AC_TRY_COMPILE([
+ #include <X11/Intrinsic.h>
+ #include <X11/Xmu/Editres.h>],
+ 		      [int i; i = 0;],
+ 	      AC_MSG_RESULT(yes)
+ 		      AC_DEFINE(HAVE_X11_XMU_EDITRES_H),
+ 	      AC_MSG_RESULT(no))
+   CPPFLAGS=$cppflags_save
+ fi
+ 
+ dnl Only use the Xm directory when compiling Motif, don't use it for Athena
+ if test -z "$SKIP_MOTIF"; then
+   cppflags_save=$CPPFLAGS
+   CPPFLAGS="$CPPFLAGS $X_CFLAGS"
+   if test "$zOSUnix" = "yes"; then
+ 	xmheader="Xm/Xm.h"
+   else
+ 	xmheader="Xm/Xm.h Xm/XpmP.h Xm/JoinSideT.h Xm/TraitP.h Xm/Manager.h
+ 	   Xm/UnhighlightT.h Xm/Notebook.h"  
+   fi    
+   AC_CHECK_HEADERS($xmheader)
+ 
+   if test "x$ac_cv_header_Xm_XpmP_h" = "xyes"; then
+     dnl Solaris uses XpmAttributes_21, very annoying.
+     AC_MSG_CHECKING([for XpmAttributes_21 in Xm/XpmP.h])
+     AC_TRY_COMPILE([#include <Xm/XpmP.h>], [XpmAttributes_21 attr;],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(XPMATTRIBUTES_TYPE, XpmAttributes_21),
+ 	AC_MSG_RESULT(no); AC_DEFINE(XPMATTRIBUTES_TYPE, XpmAttributes)
+ 	)
+   else
+     AC_DEFINE(XPMATTRIBUTES_TYPE, XpmAttributes)
+   fi
+   CPPFLAGS=$cppflags_save
+ fi
+ 
+ if test "x$GUITYPE" = "xNONE" -a "$enable_xim" = "yes"; then
+   AC_MSG_RESULT(no GUI selected; xim has been disabled)
+   enable_xim="no"
+ fi
+ if test "x$GUITYPE" = "xNONE" -a "$enable_fontset" = "yes"; then
+   AC_MSG_RESULT(no GUI selected; fontset has been disabled)
+   enable_fontset="no"
+ fi
+ if test "x$GUITYPE:$enable_fontset" = "xGTK:yes"; then
+   AC_MSG_RESULT(GTK+ 2 GUI selected; fontset has been disabled)
+   enable_fontset="no"
+ fi
+ 
+ if test -z "$SKIP_PHOTON"; then
+   GUITYPE=PHOTONGUI
+ fi
+ 
+ AC_SUBST(GUI_INC_LOC)
+ AC_SUBST(GUI_LIB_LOC)
+ AC_SUBST(GUITYPE)
+ AC_SUBST(GUI_X_LIBS)
+ 
+ if test "$enable_workshop" = "yes" -a -n "$SKIP_MOTIF"; then
+   AC_MSG_ERROR([cannot use workshop without Motif])
+ fi
+ 
+ dnl defining FEAT_XIM and FEAT_XFONTSET is delayed, so that they can be disabled
+ if test "$enable_xim" = "yes"; then
+   AC_DEFINE(FEAT_XIM)
+ fi
+ if test "$enable_fontset" = "yes"; then
+   AC_DEFINE(FEAT_XFONTSET)
+ fi
+ 
+ 
+ dnl ---------------------------------------------------------------------------
+ dnl end of GUI-checking
+ dnl ---------------------------------------------------------------------------
+ 
+ dnl Check for Cygwin, which needs an extra source file if not using X11
+ AC_MSG_CHECKING(for CYGWIN or MSYS environment)
+ case `uname` in
+     CYGWIN*|MSYS*)    CYGWIN=yes; AC_MSG_RESULT(yes)
+                 AC_MSG_CHECKING(for CYGWIN clipboard support)
+                 if test "x$with_x" = "xno" ; then
+                   OS_EXTRA_SRC=winclip.c; OS_EXTRA_OBJ=objects/winclip.o
+                   AC_MSG_RESULT(yes)
+                   AC_DEFINE(FEAT_CYGWIN_WIN32_CLIPBOARD)
+                 else
+                   AC_MSG_RESULT(no - using X11)
+                 fi ;;
+ 
+     *)          CYGWIN=no; AC_MSG_RESULT(no);;
+ esac
+ 
+ dnl Only really enable hangul input when GUI and XFONTSET are available
+ if test "$enable_hangulinput" = "yes"; then
+   if test "x$GUITYPE" = "xNONE"; then
+     AC_MSG_RESULT(no GUI selected; hangul input has been disabled)
+     enable_hangulinput=no
+   else
+     AC_DEFINE(FEAT_HANGULIN)
+     HANGULIN_SRC=hangulin.c
+     AC_SUBST(HANGULIN_SRC)
+     HANGULIN_OBJ=objects/hangulin.o
+     AC_SUBST(HANGULIN_OBJ)
+   fi
+ fi
+ 
+ dnl Checks for libraries and include files.
+ 
+ AC_CACHE_CHECK([whether toupper is broken], [vim_cv_toupper_broken],
+   [
+     AC_RUN_IFELSE([AC_LANG_SOURCE([[
+ #include "confdefs.h"
+ #include <ctype.h>
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ main() { exit(toupper('A') == 'A' && tolower('z') == 'z'); }
+   ]])],[
+     vim_cv_toupper_broken=yes
+   ],[
+     vim_cv_toupper_broken=no
+   ],[
+     AC_MSG_ERROR(cross-compiling: please set 'vim_cv_toupper_broken')
+   ])])
+ 
+ if test "x$vim_cv_toupper_broken" = "xyes" ; then
+   AC_DEFINE(BROKEN_TOUPPER)
+ fi
+ 
+ AC_MSG_CHECKING(whether __DATE__ and __TIME__ work)
+ AC_TRY_COMPILE([#include <stdio.h>], [printf("(" __DATE__ " " __TIME__ ")");],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_DATE_TIME),
+ 	AC_MSG_RESULT(no))
+ 
+ AC_MSG_CHECKING(whether __attribute__((unused)) is allowed)
+ AC_TRY_COMPILE([#include <stdio.h>], [int x __attribute__((unused));],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_ATTRIBUTE_UNUSED),
+ 	AC_MSG_RESULT(no))
+ 
+ dnl Checks for header files.
+ AC_CHECK_HEADER(elf.h, HAS_ELF=1)
+ dnl AC_CHECK_HEADER(dwarf.h, SVR4=1)
+ if test "$HAS_ELF" = 1; then
+   AC_CHECK_LIB(elf, main)
+ fi
+ 
+ AC_HEADER_DIRENT
+ 
+ dnl If sys/wait.h is not found it might still exist but not be POSIX
+ dnl compliant. In that case we define HAVE_UNION_WAIT (for NeXT)
+ if test $ac_cv_header_sys_wait_h = no; then
+   AC_MSG_CHECKING([for sys/wait.h that defines union wait])
+   AC_TRY_COMPILE([#include <sys/wait.h>],
+ 			[union wait xx, yy; xx = yy],
+ 		AC_MSG_RESULT(yes)
+ 			AC_DEFINE(HAVE_SYS_WAIT_H)
+ 			AC_DEFINE(HAVE_UNION_WAIT),
+ 		AC_MSG_RESULT(no))
+ fi
+ 
+ AC_CHECK_HEADERS(stdint.h stdlib.h string.h \
+ 	sys/select.h sys/utsname.h termcap.h fcntl.h \
+ 	sgtty.h sys/ioctl.h sys/time.h sys/types.h \
+ 	termio.h iconv.h inttypes.h langinfo.h math.h \
+ 	unistd.h stropts.h errno.h sys/resource.h \
+ 	sys/systeminfo.h locale.h sys/stream.h termios.h \
+ 	libc.h sys/statfs.h poll.h sys/poll.h pwd.h \
+ 	utime.h sys/param.h libintl.h libgen.h \
+ 	util/debug.h util/msg18n.h frame.h sys/acl.h \
+ 	sys/access.h sys/sysinfo.h wchar.h wctype.h)
+ 
+ dnl sys/ptem.h depends on sys/stream.h on Solaris
+ AC_CHECK_HEADERS(sys/ptem.h, [], [],
+ [#if defined HAVE_SYS_STREAM_H
+ #  include <sys/stream.h>
+ #endif])
+ 
+ dnl sys/sysctl.h depends on sys/param.h on OpenBSD
+ AC_CHECK_HEADERS(sys/sysctl.h, [], [],
+ [#if defined HAVE_SYS_PARAM_H
+ #  include <sys/param.h>
+ #endif])
+ 
+ 
+ dnl pthread_np.h may exist but can only be used after including pthread.h
+ AC_MSG_CHECKING([for pthread_np.h])
+ AC_TRY_COMPILE([
+ #include <pthread.h>
+ #include <pthread_np.h>],
+ 		      [int i; i = 0;],
+ 	      AC_MSG_RESULT(yes)
+ 		      AC_DEFINE(HAVE_PTHREAD_NP_H),
+ 	      AC_MSG_RESULT(no))
+ 
+ AC_CHECK_HEADERS(strings.h)
+ if test "x$MACOSX" = "xyes"; then
+   dnl The strings.h file on OS/X contains a warning and nothing useful.
+   AC_DEFINE(NO_STRINGS_WITH_STRING_H)
+ else
+ 
+ dnl Check if strings.h and string.h can both be included when defined.
+ AC_MSG_CHECKING([if strings.h can be included after string.h])
+ cppflags_save=$CPPFLAGS
+ CPPFLAGS="$CPPFLAGS $X_CFLAGS"
+ AC_TRY_COMPILE([
+ #if defined(_AIX) && !defined(_AIX51) && !defined(_NO_PROTO)
+ # define _NO_PROTO	/* like in os_unix.h, causes conflict for AIX (Winn) */
+ 			/* but don't do it on AIX 5.1 (Uribarri) */
+ #endif
+ #ifdef HAVE_XM_XM_H
+ # include <Xm/Xm.h>	/* This breaks it for HP-UX 11 (Squassabia) */
+ #endif
+ #ifdef HAVE_STRING_H
+ # include <string.h>
+ #endif
+ #if defined(HAVE_STRINGS_H)
+ # include <strings.h>
+ #endif
+ 		], [int i; i = 0;],
+ 		AC_MSG_RESULT(yes),
+ 		AC_DEFINE(NO_STRINGS_WITH_STRING_H)
+ 		AC_MSG_RESULT(no))
+ CPPFLAGS=$cppflags_save
+ fi
+ 
+ dnl Checks for typedefs, structures, and compiler characteristics.
+ AC_PROG_GCC_TRADITIONAL
+ AC_C_CONST
+ AC_C_VOLATILE
+ AC_TYPE_MODE_T
+ AC_TYPE_OFF_T
+ AC_TYPE_PID_T
+ AC_TYPE_SIZE_T
+ AC_TYPE_UID_T
+ AC_TYPE_UINT32_T
+ 
+ AC_HEADER_TIME
+ AC_CHECK_TYPE(ino_t, long)
+ AC_CHECK_TYPE(dev_t, unsigned)
+ AC_C_BIGENDIAN(,,,)
+ AC_C_INLINE
+ 
+ AC_MSG_CHECKING(for rlim_t)
+ if eval "test \"`echo '$''{'ac_cv_type_rlim_t'+set}'`\" = set"; then
+   AC_MSG_RESULT([(cached) $ac_cv_type_rlim_t])
+ else
+   AC_EGREP_CPP(dnl
+ changequote(<<,>>)dnl
+ <<(^|[^a-zA-Z_0-9])rlim_t[^a-zA-Z_0-9]>>dnl
+ changequote([,]),
+   [
+ #include <sys/types.h>
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ #ifdef HAVE_SYS_RESOURCE_H
+ # include <sys/resource.h>
+ #endif
+ 	  ], ac_cv_type_rlim_t=yes, ac_cv_type_rlim_t=no)
+ 	  AC_MSG_RESULT($ac_cv_type_rlim_t)
+ fi
+ if test $ac_cv_type_rlim_t = no; then
+   cat >> confdefs.h <<\EOF
+ #define rlim_t unsigned long
+ EOF
+ fi
+ 
+ AC_MSG_CHECKING(for stack_t)
+ if eval "test \"`echo '$''{'ac_cv_type_stack_t'+set}'`\" = set"; then
+   AC_MSG_RESULT([(cached) $ac_cv_type_stack_t])
+ else
+   AC_EGREP_CPP(stack_t,
+   [
+ #include <sys/types.h>
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ #include <signal.h>
+ 	  ], ac_cv_type_stack_t=yes, ac_cv_type_stack_t=no)
+ 	  AC_MSG_RESULT($ac_cv_type_stack_t)
+ fi
+ if test $ac_cv_type_stack_t = no; then
+   cat >> confdefs.h <<\EOF
+ #define stack_t struct sigaltstack
+ EOF
+ fi
+ 
+ dnl BSDI uses ss_base while others use ss_sp for the stack pointer.
+ AC_MSG_CHECKING(whether stack_t has an ss_base field)
+ AC_TRY_COMPILE([
+ #include <sys/types.h>
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ #include <signal.h>
+ #include "confdefs.h"
+ 			], [stack_t sigstk; sigstk.ss_base = 0; ],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SS_BASE),
+ 	AC_MSG_RESULT(no))
+ 
+ olibs="$LIBS"
+ AC_MSG_CHECKING(--with-tlib argument)
+ AC_ARG_WITH(tlib, [  --with-tlib=library     terminal library to be used ],)
+ if test -n "$with_tlib"; then
+   AC_MSG_RESULT($with_tlib)
+   LIBS="$LIBS -l$with_tlib"
+   AC_MSG_CHECKING(for linking with $with_tlib library)
+   AC_TRY_LINK([], [], AC_MSG_RESULT(OK), AC_MSG_ERROR(FAILED))
+   dnl Need to check for tgetent() below.
+   olibs="$LIBS"
+ else
+   AC_MSG_RESULT([empty: automatic terminal library selection])
+   dnl  On HP-UX 10.10 termcap or termlib should be used instead of
+   dnl  curses, because curses is much slower.
+   dnl  Newer versions of ncurses are preferred over anything, except
+   dnl  when tinfo has been split off, it contains all we need.
+   dnl  Older versions of ncurses have bugs, get a new one!
+   dnl  Digital Unix (OSF1) should use curses (Ronald Schild).
+   dnl  On SCO Openserver should prefer termlib (Roger Cornelius).
+   case "`uname -s 2>/dev/null`" in
+ 	OSF1|SCO_SV)	tlibs="tinfo ncurses curses termlib termcap";;
+ 	*)	tlibs="tinfo ncurses termlib termcap curses";;
+   esac
+   for libname in $tlibs; do
+     AC_CHECK_LIB(${libname}, tgetent,,)
+     if test "x$olibs" != "x$LIBS"; then
+       dnl It's possible that a library is found but it doesn't work
+       dnl e.g., shared library that cannot be found
+       dnl compile and run a test program to be sure
+       AC_TRY_RUN([
+ #ifdef HAVE_TERMCAP_H
+ # include <termcap.h>
+ #endif
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ main() {char *s; s=(char *)tgoto("%p1%d", 0, 1); exit(0); }],
+ 			  res="OK", res="FAIL", res="FAIL")
+       if test "$res" = "OK"; then
+ 	break
+       fi
+       AC_MSG_RESULT($libname library is not usable)
+       LIBS="$olibs"
+     fi
+   done
+   if test "x$olibs" = "x$LIBS"; then
+     AC_MSG_RESULT(no terminal library found)
+   fi
+ fi
+ 
+ if test "x$olibs" = "x$LIBS"; then
+   AC_MSG_CHECKING([for tgetent()])
+   AC_TRY_LINK([],
+       [char s[10000]; int res = tgetent(s, "thisterminaldoesnotexist");],
+ 	AC_MSG_RESULT(yes),
+ 	AC_MSG_ERROR([NOT FOUND!
+       You need to install a terminal library; for example ncurses.
+       Or specify the name of the library with --with-tlib.]))
+ fi
+ 
+ AC_CACHE_CHECK([whether we talk terminfo], [vim_cv_terminfo],
+   [
+     AC_RUN_IFELSE([AC_LANG_SOURCE([[
+ #include "confdefs.h"
+ #ifdef HAVE_TERMCAP_H
+ # include <termcap.h>
+ #endif
+ #ifdef HAVE_STRING_H
+ # include <string.h>
+ #endif
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ main()
+ {char *s; s=(char *)tgoto("%p1%d", 0, 1); exit(!strcmp(s==0 ? "" : s, "1")); }
+     ]])],[
+       vim_cv_terminfo=no
+     ],[
+       vim_cv_terminfo=yes
+     ],[
+       AC_MSG_ERROR(cross-compiling: please set 'vim_cv_terminfo')
+     ])
+   ])
+ 
+ if test "x$vim_cv_terminfo" = "xyes" ; then
+   AC_DEFINE(TERMINFO)
+ fi
+ 
+ if test "x$olibs" != "x$LIBS"; then
+   AC_CACHE_CHECK([what tgetent() returns for an unknown terminal], [vim_cv_tgent],
+     [
+       AC_RUN_IFELSE([AC_LANG_SOURCE([[
+ #include "confdefs.h"
+ #ifdef HAVE_TERMCAP_H
+ # include <termcap.h>
+ #endif
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ main()
+ {char s[10000]; int res = tgetent(s, "thisterminaldoesnotexist"); exit(res != 0); }
+       ]])],[
+ 	vim_cv_tgent=zero
+       ],[
+ 	vim_cv_tgent=non-zero
+       ],[
+ 	AC_MSG_ERROR(failed to compile test program.)
+       ])
+     ])
+   
+   if test "x$vim_cv_tgent" = "xzero" ; then
+     AC_DEFINE(TGETENT_ZERO_ERR, 0)
+   fi
+ fi
+ 
+ AC_MSG_CHECKING(whether termcap.h contains ospeed)
+ AC_TRY_LINK([
+ #ifdef HAVE_TERMCAP_H
+ # include <termcap.h>
+ #endif
+ 			], [ospeed = 20000],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_OSPEED),
+ 	[AC_MSG_RESULT(no)
+ 	AC_MSG_CHECKING(whether ospeed can be extern)
+ 	AC_TRY_LINK([
+ #ifdef HAVE_TERMCAP_H
+ # include <termcap.h>
+ #endif
+ extern short ospeed;
+ 			], [ospeed = 20000],
+ 		AC_MSG_RESULT(yes); AC_DEFINE(OSPEED_EXTERN),
+ 		AC_MSG_RESULT(no))]
+ 	)
+ 
+ AC_MSG_CHECKING([whether termcap.h contains UP, BC and PC])
+ AC_TRY_LINK([
+ #ifdef HAVE_TERMCAP_H
+ # include <termcap.h>
+ #endif
+ 			], [if (UP == 0 && BC == 0) PC = 1],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_UP_BC_PC),
+ 	[AC_MSG_RESULT(no)
+ 	AC_MSG_CHECKING([whether UP, BC and PC can be extern])
+ 	AC_TRY_LINK([
+ #ifdef HAVE_TERMCAP_H
+ # include <termcap.h>
+ #endif
+ extern char *UP, *BC, PC;
+ 			], [if (UP == 0 && BC == 0) PC = 1],
+ 		AC_MSG_RESULT(yes); AC_DEFINE(UP_BC_PC_EXTERN),
+ 		AC_MSG_RESULT(no))]
+ 	)
+ 
+ AC_MSG_CHECKING(whether tputs() uses outfuntype)
+ AC_TRY_COMPILE([
+ #ifdef HAVE_TERMCAP_H
+ # include <termcap.h>
+ #endif
+ 			], [extern int xx(); tputs("test", 1, (outfuntype)xx)],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_OUTFUNTYPE),
+ 	AC_MSG_RESULT(no))
+ 
+ dnl On some SCO machines sys/select redefines struct timeval
+ AC_MSG_CHECKING([whether sys/select.h and sys/time.h may both be included])
+ AC_TRY_COMPILE([
+ #include <sys/types.h>
+ #include <sys/time.h>
+ #include <sys/select.h>], ,
+ 	  AC_MSG_RESULT(yes)
+ 			AC_DEFINE(SYS_SELECT_WITH_SYS_TIME),
+ 	  AC_MSG_RESULT(no))
+ 
+ dnl AC_DECL_SYS_SIGLIST
+ 
+ dnl Checks for pty.c (copied from screen) ==========================
+ AC_MSG_CHECKING(for /dev/ptc)
+ if test -r /dev/ptc; then
+   AC_DEFINE(HAVE_DEV_PTC)
+   AC_MSG_RESULT(yes)
+ else
+   AC_MSG_RESULT(no)
+ fi
+ 
+ AC_MSG_CHECKING(for SVR4 ptys)
+ if test -c /dev/ptmx ; then
+   AC_TRY_LINK([], [ptsname(0);grantpt(0);unlockpt(0);],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SVR4_PTYS),
+ 	AC_MSG_RESULT(no))
+ else
+   AC_MSG_RESULT(no)
+ fi
+ 
+ AC_MSG_CHECKING(for ptyranges)
+ if test -d /dev/ptym ; then
+   pdir='/dev/ptym'
+ else
+   pdir='/dev'
+ fi
+ dnl SCO uses ptyp%d
+ AC_EGREP_CPP(yes,
+ [#ifdef M_UNIX
+    yes;
+ #endif
+ 	], ptys=`echo /dev/ptyp??`, ptys=`echo $pdir/pty??`)
+ dnl if test -c /dev/ptyp19; then
+ dnl ptys=`echo /dev/ptyp??`
+ dnl else
+ dnl ptys=`echo $pdir/pty??`
+ dnl fi
+ if test "$ptys" != "$pdir/pty??" ; then
+   p0=`echo $ptys | tr ' ' '\012' | sed -e 's/^.*\(.\).$/\1/g' | sort -u | tr -d '\012'`
+   p1=`echo $ptys | tr ' ' '\012' | sed -e 's/^.*\(.\)$/\1/g'  | sort -u | tr -d '\012'`
+   AC_DEFINE_UNQUOTED(PTYRANGE0,"$p0")
+   AC_DEFINE_UNQUOTED(PTYRANGE1,"$p1")
+   AC_MSG_RESULT([$p0 / $p1])
+ else
+   AC_MSG_RESULT([don't know])
+ fi
+ 
+ dnl    ****  pty mode/group handling ****
+ dnl
+ dnl support provided by Luke Mewburn <lm@rmit.edu.au>, 931222
+ rm -f conftest_grp
+ AC_CACHE_CHECK([default tty permissions/group], [vim_cv_tty_group],
+   [
+     AC_RUN_IFELSE([AC_LANG_SOURCE([[
+ #include "confdefs.h"
+ #include <sys/types.h>
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ #ifdef HAVE_UNISTD_H
+ #include <unistd.h>
+ #endif
+ #include <sys/stat.h>
+ #include <stdio.h>
+ main()
+ {
+   struct stat sb;
+   char *x,*ttyname();
+   int om, m;
+   FILE *fp;
+ 
+   if (!(x = ttyname(0))) exit(1);
+   if (stat(x, &sb)) exit(1);
+   om = sb.st_mode;
+   if (om & 002) exit(0);
+   m = system("mesg y");
+   if (m == -1 || m == 127) exit(1);
+   if (stat(x, &sb)) exit(1);
+   m = sb.st_mode;
+   if (chmod(x, om)) exit(1);
+   if (m & 002) exit(0);
+   if (sb.st_gid == getgid()) exit(1);
+   if (!(fp=fopen("conftest_grp", "w")))
+     exit(1);
+   fprintf(fp, "%d\n", sb.st_gid);
+   fclose(fp);
+   exit(0);
+ }
+     ]])],[
+       if test -f conftest_grp; then
+ 	vim_cv_tty_group=`cat conftest_grp`
+ 	if test "x$vim_cv_tty_mode" = "x" ; then
+ 	  vim_cv_tty_mode=0620
+ 	fi
+ 	AC_MSG_RESULT([pty mode: $vim_cv_tty_mode, group: $vim_cv_tty_group])
+       else
+ 	vim_cv_tty_group=world
+ 	AC_MSG_RESULT([ptys are world accessible])
+       fi
+     ],[
+       vim_cv_tty_group=world
+       AC_MSG_RESULT([can't determine - assume ptys are world accessible])
+     ],[
+       AC_MSG_ERROR(cross-compiling: please set 'vim_cv_tty_group' and 'vim_cv_tty_mode')
+     ])
+   ])
+ rm -f conftest_grp
+ 
+ if test "x$vim_cv_tty_group" != "xworld" ; then
+   AC_DEFINE_UNQUOTED(PTYGROUP,$vim_cv_tty_group)
+   if test "x$vim_cv_tty_mode" = "x" ; then
+     AC_MSG_ERROR([It seems you're cross compiling and have 'vim_cv_tty_group' set, please also set the environment variable 'vim_cv_tty_mode' to the correct mode (probably 0620)])
+   else
+     AC_DEFINE(PTYMODE, 0620)
+   fi
+ fi
+ 
+ dnl Checks for library functions. ===================================
+ 
+ AC_TYPE_SIGNAL
+ 
+ dnl find out what to use at the end of a signal function
+ if test $ac_cv_type_signal = void; then
+   AC_DEFINE(SIGRETURN, [return])
+ else
+   AC_DEFINE(SIGRETURN, [return 0])
+ fi
+ 
+ dnl check if struct sigcontext is defined (used for SGI only)
+ AC_MSG_CHECKING(for struct sigcontext)
+ AC_TRY_COMPILE([
+ #include <signal.h>
+ test_sig()
+ {
+     struct sigcontext *scont;
+     scont = (struct sigcontext *)0;
+     return 1;
+ } ], ,
+ 	  AC_MSG_RESULT(yes)
+ 		AC_DEFINE(HAVE_SIGCONTEXT),
+ 	  AC_MSG_RESULT(no))
+ 
+ dnl tricky stuff: try to find out if getcwd() is implemented with
+ dnl system("sh -c pwd")
+ AC_CACHE_CHECK([getcwd implementation is broken], [vim_cv_getcwd_broken],
+   [
+     AC_RUN_IFELSE([AC_LANG_SOURCE([[
+ #include "confdefs.h"
+ #ifdef HAVE_UNISTD_H
+ #include <unistd.h>
+ #endif
+ char *dagger[] = { "IFS=pwd", 0 };
+ main()
+ {
+   char buffer[500];
+   extern char **environ;
+   environ = dagger;
+   return getcwd(buffer, 500) ? 0 : 1;
+ }
+     ]])],[
+       vim_cv_getcwd_broken=no
+     ],[
+       vim_cv_getcwd_broken=yes
+     ],[
+       AC_MSG_ERROR(cross-compiling: please set 'vim_cv_getcwd_broken')
+     ])
+   ])
+ 
+ if test "x$vim_cv_getcwd_broken" = "xyes" ; then
+   AC_DEFINE(BAD_GETCWD)
+ fi
+ 
+ dnl Check for functions in one big call, to reduce the size of configure.
+ dnl Can only be used for functions that do not require any include.
+ AC_CHECK_FUNCS(bcmp fchdir fchown fsync getcwd getpseudotty \
+ 	getpwent getpwnam getpwuid getrlimit gettimeofday getwd lstat memcmp \
+ 	memset mkdtemp nanosleep opendir putenv qsort readlink select setenv \
+ 	setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction \
+ 	sigprocmask sigvec strcasecmp strerror strftime stricmp strncasecmp \
+ 	strnicmp strpbrk strtol tgetent towlower towupper iswupper \
+ 	usleep utime utimes)
+ AC_FUNC_FSEEKO
+ 
+ dnl define _LARGE_FILES, _FILE_OFFSET_BITS and _LARGEFILE_SOURCE when
+ dnl appropriate, so that off_t is 64 bits when needed.
+ AC_SYS_LARGEFILE
+ 
+ dnl fstatfs() can take 2 to 4 arguments, try to use st_blksize if possible
+ AC_MSG_CHECKING(for st_blksize)
+ AC_TRY_COMPILE(
+ [#include <sys/types.h>
+ #include <sys/stat.h>],
+ [	struct stat st;
+ 	int n;
+ 
+ 	stat("/", &st);
+ 	n = (int)st.st_blksize;],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_ST_BLKSIZE),
+ 	AC_MSG_RESULT(no))
+ 
+ AC_CACHE_CHECK([whether stat() ignores a trailing slash], [vim_cv_stat_ignores_slash],
+   [
+     AC_RUN_IFELSE([AC_LANG_SOURCE([[
+ #include "confdefs.h"
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ #include <sys/types.h>
+ #include <sys/stat.h>
+ main() {struct stat st;  exit(stat("configure/", &st) != 0); }
+     ]])],[
+       vim_cv_stat_ignores_slash=yes
+     ],[
+       vim_cv_stat_ignores_slash=no
+     ],[
+       AC_MSG_ERROR(cross-compiling: please set 'vim_cv_stat_ignores_slash')
+     ])
+   ])
+ 
+ if test "x$vim_cv_stat_ignores_slash" = "xyes" ; then
+   AC_DEFINE(STAT_IGNORES_SLASH)
+ fi
+   
+ dnl Link with iconv for charset translation, if not found without library.
+ dnl check for iconv() requires including iconv.h
+ dnl Add "-liconv" when possible; Solaris has iconv but use GNU iconv when it
+ dnl has been installed.
+ AC_MSG_CHECKING(for iconv_open())
+ save_LIBS="$LIBS"
+ LIBS="$LIBS -liconv"
+ AC_TRY_LINK([
+ #ifdef HAVE_ICONV_H
+ # include <iconv.h>
+ #endif
+     ], [iconv_open("fr", "to");],
+     AC_MSG_RESULT(yes; with -liconv); AC_DEFINE(HAVE_ICONV),
+     LIBS="$save_LIBS"
+     AC_TRY_LINK([
+ #ifdef HAVE_ICONV_H
+ # include <iconv.h>
+ #endif
+ 	], [iconv_open("fr", "to");],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_ICONV),
+ 	AC_MSG_RESULT(no)))
+ 
+ 
+ AC_MSG_CHECKING(for nl_langinfo(CODESET))
+ AC_TRY_LINK([
+ #ifdef HAVE_LANGINFO_H
+ # include <langinfo.h>
+ #endif
+ ], [char *cs = nl_langinfo(CODESET);],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_NL_LANGINFO_CODESET),
+ 	AC_MSG_RESULT(no))
+ 
+ dnl Need various functions for floating point support.  Only enable
+ dnl floating point when they are all present.
+ AC_CHECK_LIB(m, strtod)
+ AC_MSG_CHECKING([for strtod() and other floating point functions])
+ AC_TRY_LINK([
+ #ifdef HAVE_MATH_H
+ # include <math.h>
+ #endif
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ ], [char *s; double d;
+     d = strtod("1.1", &s);
+     d = fabs(1.11);
+     d = ceil(1.11);
+     d = floor(1.11);
+     d = log10(1.11);
+     d = pow(1.11, 2.22);
+     d = sqrt(1.11);
+     d = sin(1.11);
+     d = cos(1.11);
+     d = atan(1.11);
+     ],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_FLOAT_FUNCS),
+ 	AC_MSG_RESULT(no))
+ 
+ dnl isinf() and isnan() need to include header files and may need -lm.
+ AC_MSG_CHECKING([for isinf()])
+ AC_TRY_LINK([
+ #ifdef HAVE_MATH_H
+ # include <math.h>
+ #endif
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ ], [int r = isinf(1.11); ],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_ISINF),
+ 	AC_MSG_RESULT(no))
+ 
+ AC_MSG_CHECKING([for isnan()])
+ AC_TRY_LINK([
+ #ifdef HAVE_MATH_H
+ # include <math.h>
+ #endif
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ ], [int r = isnan(1.11); ],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_ISNAN),
+ 	AC_MSG_RESULT(no))
+ 
+ dnl Link with -lposix1e for ACL stuff; if not found, try -lacl for SGI
+ dnl when -lacl works, also try to use -lattr (required for Debian).
+ dnl On Solaris, use the acl_get/set functions in libsec, if present.
+ AC_MSG_CHECKING(--disable-acl argument)
+ AC_ARG_ENABLE(acl,
+ 	[  --disable-acl           Don't check for ACL support.],
+ 	, [enable_acl="yes"])
+ if test "$enable_acl" = "yes"; then
+ AC_MSG_RESULT(no)
+ AC_CHECK_LIB(posix1e, acl_get_file, [LIBS="$LIBS -lposix1e"],
+ 	AC_CHECK_LIB(acl, acl_get_file, [LIBS="$LIBS -lacl"
+ 		  AC_CHECK_LIB(attr, fgetxattr, LIBS="$LIBS -lattr",,)],,),)
+ 
+ AC_MSG_CHECKING(for POSIX ACL support)
+ AC_TRY_LINK([
+ #include <sys/types.h>
+ #ifdef HAVE_SYS_ACL_H
+ # include <sys/acl.h>
+ #endif
+ acl_t acl;], [acl = acl_get_file("foo", ACL_TYPE_ACCESS);
+ 	acl_set_file("foo", ACL_TYPE_ACCESS, acl);
+ 	acl_free(acl);],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_POSIX_ACL),
+ 	AC_MSG_RESULT(no))
+ 
+ AC_CHECK_LIB(sec, acl_get, [LIBS="$LIBS -lsec"; AC_DEFINE(HAVE_SOLARIS_ZFS_ACL)],
+ AC_MSG_CHECKING(for Solaris ACL support)
+ AC_TRY_LINK([
+ #ifdef HAVE_SYS_ACL_H
+ # include <sys/acl.h>
+ #endif], [acl("foo", GETACLCNT, 0, NULL);
+ 	],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SOLARIS_ACL),
+ 	AC_MSG_RESULT(no)))
+ 
+ AC_MSG_CHECKING(for AIX ACL support)
+ AC_TRY_LINK([
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ #ifdef HAVE_SYS_ACL_H
+ # include <sys/acl.h>
+ #endif
+ #ifdef HAVE_SYS_ACCESS_H
+ # include <sys/access.h>
+ #endif
+ #define _ALL_SOURCE
+ 
+ #include <sys/stat.h>
+ 
+ int aclsize;
+ struct acl *aclent;], [aclsize = sizeof(struct acl);
+ 	aclent = (void *)malloc(aclsize);
+ 	statacl("foo", STX_NORMAL, aclent, aclsize);
+ 	],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_AIX_ACL),
+ 	AC_MSG_RESULT(no))
+ else
+   AC_MSG_RESULT(yes)
+ fi
+ 
+ if test "x$GTK_CFLAGS" != "x"; then
+   dnl pango_shape_full() is new, fall back to pango_shape().
+   AC_MSG_CHECKING(for pango_shape_full)
+   ac_save_CFLAGS="$CFLAGS"
+   ac_save_LIBS="$LIBS"
+   CFLAGS="$CFLAGS $GTK_CFLAGS"
+   LIBS="$LIBS $GTK_LIBS"
+   AC_TRY_LINK(
+   [#include <gtk/gtk.h>],
+   [ pango_shape_full(NULL, 0, NULL, 0, NULL, NULL); ],
+ 	  AC_MSG_RESULT(yes); AC_DEFINE(HAVE_PANGO_SHAPE_FULL),
+ 	  AC_MSG_RESULT(no))
+   CFLAGS="$ac_save_CFLAGS"
+   LIBS="$ac_save_LIBS"
+ fi
+ 
+ AC_MSG_CHECKING(--disable-gpm argument)
+ AC_ARG_ENABLE(gpm,
+ 	[  --disable-gpm           Don't use gpm (Linux mouse daemon).], ,
+ 	[enable_gpm="yes"])
+ 
+ if test "$enable_gpm" = "yes"; then
+   AC_MSG_RESULT(no)
+   dnl Checking if gpm support can be compiled
+   AC_CACHE_CHECK([for gpm], vi_cv_have_gpm,
+ 	[olibs="$LIBS" ; LIBS="-lgpm"]
+ 	AC_TRY_LINK(
+ 	    [#include <gpm.h>
+ 	    #include <linux/keyboard.h>],
+ 	    [Gpm_GetLibVersion(NULL);],
+ 	    dnl Configure defines HAVE_GPM, if it is defined feature.h defines
+ 	    dnl FEAT_MOUSE_GPM if mouse support is included
+ 	    [vi_cv_have_gpm=yes],
+ 	    [vi_cv_have_gpm=no])
+ 	[LIBS="$olibs"]
+     )
+   if test $vi_cv_have_gpm = yes; then
+     LIBS="$LIBS -lgpm"
+     AC_DEFINE(HAVE_GPM)
+   fi
+ else
+   AC_MSG_RESULT(yes)
+ fi
+ 
+ AC_MSG_CHECKING(--disable-sysmouse argument)
+ AC_ARG_ENABLE(sysmouse,
+ 	[  --disable-sysmouse    Don't use sysmouse (mouse in *BSD console).], ,
+ 	[enable_sysmouse="yes"])
+ 
+ if test "$enable_sysmouse" = "yes"; then
+   AC_MSG_RESULT(no)
+   dnl Checking if sysmouse support can be compiled
+   dnl Configure defines HAVE_SYSMOUSE, if it is defined feature.h
+   dnl defines FEAT_SYSMOUSE if mouse support is included
+   AC_CACHE_CHECK([for sysmouse], vi_cv_have_sysmouse,
+ 	AC_TRY_LINK(
+ 	    [#include <sys/consio.h>
+ 	     #include <signal.h>
+ 	     #include <sys/fbio.h>],
+ 	    [struct mouse_info   mouse;
+ 	     mouse.operation = MOUSE_MODE;
+ 	     mouse.operation = MOUSE_SHOW;
+ 	     mouse.u.mode.mode = 0;
+ 	     mouse.u.mode.signal = SIGUSR2;],
+ 	    [vi_cv_have_sysmouse=yes],
+ 	    [vi_cv_have_sysmouse=no])
+     )
+   if test $vi_cv_have_sysmouse = yes; then
+     AC_DEFINE(HAVE_SYSMOUSE)
+   fi
+ else
+   AC_MSG_RESULT(yes)
+ fi
+ 
+ dnl make sure the FD_CLOEXEC flag for fcntl()'s F_SETFD command is known
+ AC_MSG_CHECKING(for FD_CLOEXEC)
+ AC_TRY_COMPILE(
+ [#if HAVE_FCNTL_H
+ # include <fcntl.h>
+ #endif],
+ [	int flag = FD_CLOEXEC;],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_FD_CLOEXEC),
+ 	AC_MSG_RESULT(not usable))
+ 
+ dnl rename needs to be checked separately to work on Nextstep with cc
+ AC_MSG_CHECKING(for rename)
+ AC_TRY_LINK([#include <stdio.h>], [rename("this", "that")],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_RENAME),
+ 	AC_MSG_RESULT(no))
+ 
+ dnl sysctl() may exist but not the arguments we use
+ AC_MSG_CHECKING(for sysctl)
+ AC_TRY_COMPILE(
+ [#include <sys/types.h>
+ #include <sys/sysctl.h>],
+ [	int mib[2], r;
+ 	size_t len;
+ 
+ 	mib[0] = CTL_HW;
+ 	mib[1] = HW_USERMEM;
+ 	len = sizeof(r);
+ 	(void)sysctl(mib, 2, &r, &len, (void *)0, (size_t)0);
+ 	],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SYSCTL),
+ 	AC_MSG_RESULT(not usable))
+ 
+ dnl sysinfo() may exist but not be Linux compatible
+ AC_MSG_CHECKING(for sysinfo)
+ AC_TRY_COMPILE(
+ [#include <sys/types.h>
+ #include <sys/sysinfo.h>],
+ [	struct sysinfo sinfo;
+ 	int t;
+ 
+ 	(void)sysinfo(&sinfo);
+ 	t = sinfo.totalram;
+ 	],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SYSINFO),
+ 	AC_MSG_RESULT(not usable))
+ 
+ dnl struct sysinfo may have the mem_unit field or not
+ AC_MSG_CHECKING(for sysinfo.mem_unit)
+ AC_TRY_COMPILE(
+ [#include <sys/types.h>
+ #include <sys/sysinfo.h>],
+ [	struct sysinfo sinfo;
+ 	sinfo.mem_unit = 1;
+ 	],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SYSINFO_MEM_UNIT),
+ 	AC_MSG_RESULT(no))
+ 
+ dnl sysconf() may exist but not support what we want to use
+ AC_MSG_CHECKING(for sysconf)
+ AC_TRY_COMPILE(
+ [#include <unistd.h>],
+ [	(void)sysconf(_SC_PAGESIZE);
+ 	(void)sysconf(_SC_PHYS_PAGES);
+ 	],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SYSCONF),
+ 	AC_MSG_RESULT(not usable))
+ 
+ AC_CHECK_SIZEOF([int])
+ AC_CHECK_SIZEOF([long])
+ AC_CHECK_SIZEOF([time_t])
+ AC_CHECK_SIZEOF([off_t])
+ 
+ dnl Use different names to avoid clashing with other header files.
+ AC_DEFINE_UNQUOTED(VIM_SIZEOF_INT, [$ac_cv_sizeof_int])
+ AC_DEFINE_UNQUOTED(VIM_SIZEOF_LONG, [$ac_cv_sizeof_long])
+ 
+ dnl Make sure that uint32_t is really 32 bits unsigned.
+ AC_MSG_CHECKING([uint32_t is 32 bits])
+ AC_TRY_RUN([
+ #ifdef HAVE_STDINT_H
+ # include <stdint.h>
+ #endif
+ #ifdef HAVE_INTTYPES_H
+ # include <inttypes.h>
+ #endif
+ main() {
+   uint32_t nr1 = (uint32_t)-1;
+   uint32_t nr2 = (uint32_t)0xffffffffUL;
+   if (sizeof(uint32_t) != 4 || nr1 != 0xffffffffUL || nr2 + 1 != 0) exit(1);
+   exit(0);
+ }],
+ AC_MSG_RESULT(ok),
+ AC_MSG_ERROR([WRONG!  uint32_t not defined correctly.]),
+ AC_MSG_WARN([cannot check uint32_t when cross-compiling.]))
+ 
+ dnl Check for memmove() before bcopy(), makes memmove() be used when both are
+ dnl present, fixes problem with incompatibility between Solaris 2.4 and 2.5.
+ 
+ [bcopy_test_prog='
+ #include "confdefs.h"
+ #ifdef HAVE_STRING_H
+ # include <string.h>
+ #endif
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ main() {
+   char buf[10];
+   strcpy(buf, "abcdefghi");
+   mch_memmove(buf, buf + 2, 3);
+   if (strncmp(buf, "ababcf", 6))
+     exit(1);
+   strcpy(buf, "abcdefghi");
+   mch_memmove(buf + 2, buf, 3);
+   if (strncmp(buf, "cdedef", 6))
+     exit(1);
+   exit(0); /* libc version works properly.  */
+ }']
+ 
+ AC_CACHE_CHECK([whether memmove handles overlaps],[vim_cv_memmove_handles_overlap],
+   [
+     AC_RUN_IFELSE([AC_LANG_SOURCE([[#define mch_memmove(s,d,l) memmove(d,s,l) $bcopy_test_prog]])],
+       [
+ 	vim_cv_memmove_handles_overlap=yes
+       ],[
+ 	vim_cv_memmove_handles_overlap=no
+       ],[
+ 	AC_MSG_ERROR(cross-compiling: please set 'vim_cv_memmove_handles_overlap')
+       ])
+   ])
+ 
+ if test "x$vim_cv_memmove_handles_overlap" = "xyes" ; then
+   AC_DEFINE(USEMEMMOVE)
+ else
+   AC_CACHE_CHECK([whether bcopy handles overlaps],[vim_cv_bcopy_handles_overlap],
+     [
+       AC_RUN_IFELSE([AC_LANG_SOURCE([[#define mch_bcopy(s,d,l) bcopy(d,s,l) $bcopy_test_prog]])],
+       [
+ 	vim_cv_bcopy_handles_overlap=yes
+       ],[
+ 	vim_cv_bcopy_handles_overlap=no
+       ],[
+ 	AC_MSG_ERROR(cross-compiling: please set 'vim_cv_bcopy_handles_overlap')
+       ])
+     ])
+ 
+   if test "x$vim_cv_bcopy_handles_overlap" = "xyes" ; then
+     AC_DEFINE(USEBCOPY)
+   else
+     AC_CACHE_CHECK([whether memcpy handles overlaps],[vim_cv_memcpy_handles_overlap],
+       [
+ 	AC_RUN_IFELSE([AC_LANG_SOURCE([[#define mch_memcpy(s,d,l) memcpy(d,s,l) $bcopy_test_prog]])],
+ 	  [
+ 	    vim_cv_memcpy_handles_overlap=yes
+ 	  ],[
+ 	    vim_cv_memcpy_handles_overlap=no
+ 	  ],[
+ 	    AC_MSG_ERROR(cross-compiling: please set 'vim_cv_memcpy_handles_overlap')
+ 	  ])
+       ])
+ 
+     if test "x$vim_cv_memcpy_handles_overlap" = "xyes" ; then
+       AC_DEFINE(USEMEMCPY)
+     fi
+   fi
+ fi
+ 
+ 
+ dnl Check for multibyte locale functions
+ dnl Find out if _Xsetlocale() is supported by libX11.
+ dnl Check if X_LOCALE should be defined.
+ if test "x$with_x" = "xyes"; then
+   cflags_save=$CFLAGS
+   libs_save=$LIBS
+   LIBS="$LIBS $X_LIBS $GUI_LIB_LOC $GUI_X_LIBS $X_PRE_LIBS $X_LIB $X_EXTRA_LIBS"
+   CFLAGS="$CFLAGS $X_CFLAGS"
+ 
+   AC_MSG_CHECKING(whether X_LOCALE needed)
+   AC_TRY_COMPILE([#include <X11/Xlocale.h>],,
+       AC_TRY_LINK_FUNC([_Xsetlocale], [AC_MSG_RESULT(yes)
+ 	      AC_DEFINE(X_LOCALE)], AC_MSG_RESULT(no)),
+       AC_MSG_RESULT(no))
+ 
+   AC_MSG_CHECKING(whether Xutf8SetWMProperties() can be used)
+   AC_TRY_LINK_FUNC([Xutf8SetWMProperties], [AC_MSG_RESULT(yes)
+ 	      AC_DEFINE(HAVE_XUTF8SETWMPROPERTIES)], AC_MSG_RESULT(no))
+ 
+   CFLAGS=$cflags_save
+   LIBS=$libs_save
+ fi
+ 
+ dnl Link with xpg4, it is said to make Korean locale working
+ AC_CHECK_LIB(xpg4, _xpg4_setrunelocale, [LIBS="$LIBS -lxpg4"],,)
+ 
+ dnl Check how we can run ctags.  Default to "ctags" when nothing works.
+ dnl Use --version to detect Exuberant ctags (preferred)
+ dnl       Add --fields=+S to get function signatures for omni completion.
+ dnl -t for typedefs (many ctags have this)
+ dnl -s for static functions (Elvis ctags only?)
+ dnl -v for variables. Dangerous, most ctags take this for 'vgrind style'.
+ dnl -i+m to test for older Exuberant ctags
+ AC_MSG_CHECKING(how to create tags)
+ test -f tags && mv tags tags.save
+ if (eval ctags --version /dev/null | grep Exuberant) < /dev/null 1>&AC_FD_CC 2>&1; then
+   TAGPRG="ctags -I INIT+ --fields=+S"
+ elif (eval exctags --version /dev/null | grep Exuberant) < /dev/null 1>&AC_FD_CC 2>&1; then
+   TAGPRG="exctags -I INIT+ --fields=+S"
+ elif (eval exuberant-ctags --version /dev/null | grep Exuberant) < /dev/null 1>&AC_FD_CC 2>&1; then
+   TAGPRG="exuberant-ctags -I INIT+ --fields=+S"
+ else
+   TAGPRG="ctags"
+   (eval etags	   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="etags"
+   (eval etags -c   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="etags -c"
+   (eval ctags	   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags"
+   (eval ctags -t   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags -t"
+   (eval ctags -ts  /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags -ts"
+   (eval ctags -tvs /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags -tvs"
+   (eval ctags -i+m /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags -i+m"
+ fi
+ test -f tags.save && mv tags.save tags
+ AC_MSG_RESULT($TAGPRG) AC_SUBST(TAGPRG)
+ 
+ dnl Check how we can run man with a section number
+ AC_MSG_CHECKING(how to run man with a section nr)
+ MANDEF="man"
+ (eval MANPAGER=cat PAGER=cat man -s 2 read) < /dev/null > /dev/null 2>&AC_FD_CC && MANDEF="man -s"
+ AC_MSG_RESULT($MANDEF)
+ if test "$MANDEF" = "man -s"; then
+   AC_DEFINE(USEMAN_S)
+ fi
+ 
+ dnl Check if gettext() is working and if it needs -lintl
+ dnl We take care to base this on an empty LIBS: on some systems libelf would be
+ dnl in LIBS and implicitly take along libintl. The final LIBS would then not
+ dnl contain libintl, and the link step would fail due to -Wl,--as-needed.
+ AC_MSG_CHECKING(--disable-nls argument)
+ AC_ARG_ENABLE(nls,
+ 	[  --disable-nls           Don't support NLS (gettext()).], ,
+ 	[enable_nls="yes"])
+ 
+ if test "$enable_nls" = "yes"; then
+   AC_MSG_RESULT(no)
+ 
+   INSTALL_LANGS=install-languages
+   AC_SUBST(INSTALL_LANGS)
+   INSTALL_TOOL_LANGS=install-tool-languages
+   AC_SUBST(INSTALL_TOOL_LANGS)
+ 
+   AC_CHECK_PROG(MSGFMT, msgfmt, msgfmt, )
+   AC_MSG_CHECKING([for NLS])
+   if test -f po/Makefile; then
+     have_gettext="no"
+     if test -n "$MSGFMT"; then
+       olibs=$LIBS
+       LIBS=""
+       AC_TRY_LINK(
+ 	[#include <libintl.h>],
+ 	[gettext("Test");],
+ 	AC_MSG_RESULT([gettext() works]); have_gettext="yes"; LIBS=$olibs,
+ 	  LIBS="-lintl"
+ 	  AC_TRY_LINK(
+ 	      [#include <libintl.h>],
+ 	      [gettext("Test");],
+ 	      AC_MSG_RESULT([gettext() works with -lintl]); have_gettext="yes";
+ 	      LIBS="$olibs -lintl",
+ 	      AC_MSG_RESULT([gettext() doesn't work]);
+ 	      LIBS=$olibs))
+     else
+       AC_MSG_RESULT([msgfmt not found - disabled]);
+     fi
+     if test $have_gettext = "yes" -a "x$features" != "xtiny" -a "x$features" != "xsmall"; then
+       AC_DEFINE(HAVE_GETTEXT)
+       MAKEMO=yes
+       AC_SUBST(MAKEMO)
+       dnl this was added in GNU gettext 0.10.36
+       AC_CHECK_FUNCS(bind_textdomain_codeset)
+       dnl _nl_msg_cat_cntr is required for GNU gettext
+       AC_MSG_CHECKING([for _nl_msg_cat_cntr])
+       AC_TRY_LINK(
+ 		[#include <libintl.h>
+ 		extern int _nl_msg_cat_cntr;],
+ 		[++_nl_msg_cat_cntr;],
+ 		AC_MSG_RESULT([yes]); AC_DEFINE(HAVE_NL_MSG_CAT_CNTR),
+ 		AC_MSG_RESULT([no]))
+     fi
+   else
+     AC_MSG_RESULT([no "po/Makefile" - disabled]);
+   fi
+ else
+   AC_MSG_RESULT(yes)
+ fi
+ 
+ dnl Check for dynamic linking loader
+ AC_CHECK_HEADER(dlfcn.h, DLL=dlfcn.h, [AC_CHECK_HEADER(dl.h, DLL=dl.h)])
+ if test x${DLL} = xdlfcn.h; then
+   AC_DEFINE(HAVE_DLFCN_H, 1, [ Define if we have dlfcn.h. ])
+   AC_MSG_CHECKING([for dlopen()])
+   AC_TRY_LINK(,[
+ 		extern void* dlopen();
+ 		dlopen();
+       ],
+       AC_MSG_RESULT(yes);
+ 	      AC_DEFINE(HAVE_DLOPEN, 1, [ Define if we have dlopen() ]),
+       AC_MSG_RESULT(no);
+ 	      AC_MSG_CHECKING([for dlopen() in -ldl])
+ 	      olibs=$LIBS
+ 	      LIBS="$LIBS -ldl"
+ 	      AC_TRY_LINK(,[
+ 				extern void* dlopen();
+ 				dlopen();
+ 		 ],
+ 		 AC_MSG_RESULT(yes);
+ 			  AC_DEFINE(HAVE_DLOPEN, 1, [ Define if we have dlopen() ]),
+ 		 AC_MSG_RESULT(no);
+ 			  LIBS=$olibs))
+   dnl ReliantUNIX has dlopen() in libc but everything else in libdl
+   dnl ick :-)
+   AC_MSG_CHECKING([for dlsym()])
+   AC_TRY_LINK(,[
+ 		extern void* dlsym();
+ 		dlsym();
+       ],
+       AC_MSG_RESULT(yes);
+ 	      AC_DEFINE(HAVE_DLSYM, 1, [ Define if we have dlsym() ]),
+       AC_MSG_RESULT(no);
+ 	      AC_MSG_CHECKING([for dlsym() in -ldl])
+ 	      olibs=$LIBS
+ 	      LIBS="$LIBS -ldl"
+ 	      AC_TRY_LINK(,[
+ 				extern void* dlsym();
+ 				dlsym();
+ 		 ],
+ 		 AC_MSG_RESULT(yes);
+ 			  AC_DEFINE(HAVE_DLSYM, 1, [ Define if we have dlsym() ]),
+ 		 AC_MSG_RESULT(no);
+ 			  LIBS=$olibs))
+ elif test x${DLL} = xdl.h; then
+   AC_DEFINE(HAVE_DL_H, 1, [ Define if we have dl.h. ])
+   AC_MSG_CHECKING([for shl_load()])
+   AC_TRY_LINK(,[
+ 		extern void* shl_load();
+ 		shl_load();
+      ],
+      AC_MSG_RESULT(yes);
+ 	  AC_DEFINE(HAVE_SHL_LOAD, 1, [ Define if we have shl_load() ]),
+      AC_MSG_RESULT(no);
+ 	  AC_MSG_CHECKING([for shl_load() in -ldld])
+ 	  olibs=$LIBS
+ 	  LIBS="$LIBS -ldld"
+ 	  AC_TRY_LINK(,[
+ 			extern void* shl_load();
+ 			shl_load();
+ 	     ],
+ 	     AC_MSG_RESULT(yes);
+ 		  AC_DEFINE(HAVE_SHL_LOAD, 1, [ Define if we have shl_load() ]),
+ 	     AC_MSG_RESULT(no);
+ 		  LIBS=$olibs))
+ fi
+ AC_CHECK_HEADERS(setjmp.h)
+ 
+ if test "x$MACOSX" = "xyes" -a -n "$PERL"; then
+   dnl -ldl must come after DynaLoader.a
+   if echo $LIBS | grep -e '-ldl' >/dev/null; then
+     LIBS=`echo $LIBS | sed s/-ldl//`
+     PERL_LIBS="$PERL_LIBS -ldl"
+   fi
+ fi
+ 
+ if test "x$MACOSX" = "xyes"; then
+   AC_MSG_CHECKING(whether we need -framework Cocoa)
+   dnl Cocoa is needed with FEAT_CLIPBOARD or FEAT_MBYTE (the former is
+   dnl disabled during tiny build)
+   if test "x$features" != "xtiny" || test "x$enable_multibyte" = "xyes"; then
+     LIBS=$"$LIBS -framework Cocoa"
+     AC_MSG_RESULT(yes)
+   else
+     AC_MSG_RESULT(no)
+   fi
+   dnl As mentioned above, tiny build implies os_macosx.m isn't needed.  
+   dnl Exclude it from OS_EXTRA_SRC so that linker won't complain about
+   dnl missing Objective-C symbols.
+   if test "x$features" = "xtiny"; then
+     OS_EXTRA_SRC=`echo "$OS_EXTRA_SRC" | sed -e 's+os_macosx.m++'`
+     OS_EXTRA_OBJ=`echo "$OS_EXTRA_OBJ" | sed -e 's+objects/os_macosx.o++'`
+   fi
+ fi
+ if test "x$MACARCH" = "xboth" && test "x$GUITYPE" = "xCARBONGUI"; then
+   LDFLAGS="$LDFLAGS -isysroot $DEVELOPER_DIR/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc"
+ fi
+ 
+ dnl gcc 3.1 changed the meaning of -MM.  The only solution appears to be to
+ dnl use "-isystem" instead of "-I" for all non-Vim include dirs.
+ dnl But only when making dependencies, cproto and lint don't take "-isystem".
+ dnl Mac gcc returns "powerpc-apple-darwin8-gcc-4.0.1 (GCC)...", need to allow
+ dnl the number before the version number.
+ DEPEND_CFLAGS_FILTER=
+ if test "$GCC" = yes; then
+   AC_MSG_CHECKING(for GCC 3 or later)
+   gccmajor=`echo "$gccversion" | sed -e 's/^\([[1-9]]\)\..*$/\1/g'`
+   if test "$gccmajor" -gt "2"; then
+     DEPEND_CFLAGS_FILTER="| sed 's+-I */+-isystem /+g'"
+     AC_MSG_RESULT(yes)
+   else
+     AC_MSG_RESULT(no)
+   fi
+   dnl -D_FORTIFY_SOURCE=2 crashes Vim on strcpy(buf, "000") when buf is
+   dnl declared as char x[1] but actually longer.  Introduced in gcc 4.0.
+   dnl Also remove duplicate _FORTIFY_SOURCE arguments.
+   dnl And undefine it first to avoid a warning.
+   AC_MSG_CHECKING(whether we need -D_FORTIFY_SOURCE=1)
+   if test "$gccmajor" -gt "3"; then
+     CFLAGS=`echo "$CFLAGS" | sed -e 's/ *-Wp,-D_FORTIFY_SOURCE=.//g' -e 's/ *-D_FORTIFY_SOURCE=.//g' -e 's/ *-U_FORTIFY_SOURCE//g' -e 's/$/ -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1/'`
+     AC_MSG_RESULT(yes)
+   else
+     AC_MSG_RESULT(no)
+   fi
+ fi
+ AC_SUBST(DEPEND_CFLAGS_FILTER)
+ 
+ dnl link.sh tries to avoid overlinking in a hackish way.
+ dnl At least GNU ld supports --as-needed which provides the same functionality
+ dnl at linker level. Let's use it.
+ AC_MSG_CHECKING(linker --as-needed support)
+ LINK_AS_NEEDED=
+ # Check if linker supports --as-needed and --no-as-needed options
+ if $CC -Wl,--help 2>/dev/null | grep as-needed > /dev/null; then
+   LDFLAGS=`echo "$LDFLAGS" | sed -e 's/ *-Wl,--as-needed//g' | sed -e 's/$/ -Wl,--as-needed/'`
+   LINK_AS_NEEDED=yes
+ fi
+ if test "$LINK_AS_NEEDED" = yes; then
+   AC_MSG_RESULT(yes)
+ else
+   AC_MSG_RESULT(no)
+ fi
+ AC_SUBST(LINK_AS_NEEDED)
+ 
+ # IBM z/OS reset CFLAGS for config.mk
+ if test "$zOSUnix" = "yes"; then
+ 	CFLAGS="-D_ALL_SOURCE -Wc,float\(ieee\),dll"
+ fi
+ 
+ dnl write output files
+ AC_OUTPUT(auto/config.mk:config.mk.in)
+ 
+ dnl vim: set sw=2 tw=78 fo+=l:
*** ../vim-8.0.0081/Filelist	2016-08-28 20:13:39.000000000 +0200
--- Filelist	2016-11-12 20:12:35.618728568 +0100
***************
*** 207,213 ****
  		src/config.mk.dist \
  		src/config.mk.in \
  		src/configure \
! 		src/configure.in \
  		src/gui_at_fs.c \
  		src/gui_at_sb.c \
  		src/gui_at_sb.h \
--- 207,213 ----
  		src/config.mk.dist \
  		src/config.mk.in \
  		src/configure \
! 		src/configure.ac \
  		src/gui_at_fs.c \
  		src/gui_at_sb.c \
  		src/gui_at_sb.h \
*** ../vim-8.0.0081/src/Makefile	2016-11-10 20:01:41.201582868 +0100
--- src/Makefile	2016-11-12 20:11:51.591020603 +0100
***************
*** 690,697 ****
  #####################################################
  
  ### Uncomment things here only if the values chosen by configure are wrong.
! ### It's better to adjust configure.in and "make autoconf", if you can!
! ### Then send the required changes to configure.in to the bugs list.
  
  ### (1) BSD/OS 2.0.1, 2.1 or 3.0 using shared libraries
  ###
--- 690,697 ----
  #####################################################
  
  ### Uncomment things here only if the values chosen by configure are wrong.
! ### It's better to adjust configure.ac and "make autoconf", if you can!
! ### Then send the required changes to configure.ac to the bugs list.
  
  ### (1) BSD/OS 2.0.1, 2.1 or 3.0 using shared libraries
  ###
***************
*** 1832,1838 ****
  # - DO NOT RUN autoconf MANUALLY!  It will overwrite ./configure instead of
  #   producing auto/configure.
  # - autoconf is not run automatically, because a patch usually changes both
! #   configure.in and auto/configure but can't update the timestamps.  People
  #   who do not have (the correct version of) autoconf would run into trouble.
  #
  # Two tricks are required to make autoconf put its output in the "auto" dir:
--- 1832,1838 ----
  # - DO NOT RUN autoconf MANUALLY!  It will overwrite ./configure instead of
  #   producing auto/configure.
  # - autoconf is not run automatically, because a patch usually changes both
! #   configure.ac and auto/configure but can't update the timestamps.  People
  #   who do not have (the correct version of) autoconf would run into trouble.
  #
  # Two tricks are required to make autoconf put its output in the "auto" dir:
*** ../vim-8.0.0081/src/blowfish.c	2016-11-10 20:01:41.181582995 +0100
--- src/blowfish.c	2016-11-12 20:08:09.272496358 +0100
***************
*** 38,44 ****
    /* MS-Windows is always little endian */
  #else
  # ifdef HAVE_CONFIG_H
!    /* in configure.in AC_C_BIGENDIAN() defines WORDS_BIGENDIAN when needed */
  # else
     error!
     Please change this code to define WORDS_BIGENDIAN for big-endian machines.
--- 38,44 ----
    /* MS-Windows is always little endian */
  #else
  # ifdef HAVE_CONFIG_H
!    /* in configure.ac AC_C_BIGENDIAN() defines WORDS_BIGENDIAN when needed */
  # else
     error!
     Please change this code to define WORDS_BIGENDIAN for big-endian machines.
*** ../vim-8.0.0081/src/channel.c	2016-11-11 21:13:56.836753930 +0100
--- src/channel.c	2016-11-12 20:08:27.040378345 +0100
***************
*** 19,25 ****
  # define CH_HAS_GUI (gui.in_use || gui.starting)
  #endif
  
! /* Note: when making changes here also adjust configure.in. */
  #ifdef WIN32
  /* WinSock API is separated from C API, thus we can't use read(), write(),
   * errno... */
--- 19,25 ----
  # define CH_HAS_GUI (gui.in_use || gui.starting)
  #endif
  
! /* Note: when making changes here also adjust configure.ac. */
  #ifdef WIN32
  /* WinSock API is separated from C API, thus we can't use read(), write(),
   * errno... */
*** ../vim-8.0.0081/src/config.h.in	2016-10-18 16:27:20.540756047 +0200
--- src/config.h.in	2016-11-12 20:09:15.712055133 +0100
***************
*** 1,6 ****
  /*
!  * config.h.in.  Generated automatically from configure.in by autoheader, and
!  * manually changed after that.
   */
  
  /* Define if we have EBCDIC code */
--- 1,6 ----
  /*
!  * config.h.in.  Originally generated automatically from configure.ac by
!  * autoheader and manually changed after that.
   */
  
  /* Define if we have EBCDIC code */
*** ../vim-8.0.0081/src/main.aap	2016-09-25 21:44:59.441600148 +0200
--- src/main.aap	2016-11-12 20:10:45.471459311 +0100
***************
*** 22,32 ****
      # A U T O C O N F
      #
  
!     # Run autoconf when configure.in has been changed since it was last run.
      # This is skipped when the signatures in "mysign" are up-to-date.  When
      # there is no autoconf program skip this (the signature is often the only
      # thing that's outdated)
!     auto/configure {signfile = mysign} : configure.in
          @if not program_path("autoconf"):
              :print Can't find autoconf, using existing configure script.
          @else:
--- 22,32 ----
      # A U T O C O N F
      #
  
!     # Run autoconf when configure.ac has been changed since it was last run.
      # This is skipped when the signatures in "mysign" are up-to-date.  When
      # there is no autoconf program skip this (the signature is often the only
      # thing that's outdated)
!     auto/configure {signfile = mysign} : configure.ac
          @if not program_path("autoconf"):
              :print Can't find autoconf, using existing configure script.
          @else:
*** ../vim-8.0.0081/src/os_unix.c	2016-11-07 22:42:48.828350757 +0100
--- src/os_unix.c	2016-11-12 20:11:05.415326964 +0100
***************
*** 265,271 ****
   * that describe the signals. That is nearly what we want here.  But
   * autoconf does only check for sys_siglist (without the underscore), I
   * do not want to change everything today.... jw.
!  * This is why AC_DECL_SYS_SIGLIST is commented out in configure.in
   */
  #endif
  
--- 265,271 ----
   * that describe the signals. That is nearly what we want here.  But
   * autoconf does only check for sys_siglist (without the underscore), I
   * do not want to change everything today.... jw.
!  * This is why AC_DECL_SYS_SIGLIST is commented out in configure.ac.
   */
  #endif
  
*** ../vim-8.0.0081/src/INSTALL	2016-04-12 22:44:00.000000000 +0200
--- src/INSTALL	2016-11-12 20:11:25.459193970 +0100
***************
*** 221,228 ****
  be considered for the next release.  If at some point `config.cache'
  contains results you don't want to keep, you may remove or edit it.
  
!    The file `configure.in' is used to create `configure' by a program
! called `autoconf'.  You only need `configure.in' if you want to change
  it or regenerate `configure' using a newer version of `autoconf'.
  
  The simplest way to compile this package is:
--- 221,228 ----
  be considered for the next release.  If at some point `config.cache'
  contains results you don't want to keep, you may remove or edit it.
  
!    The file `configure.ac' is used to create `configure' by a program
! called `autoconf'.  You only need `configure.ac' if you want to change
  it or regenerate `configure' using a newer version of `autoconf'.
  
  The simplest way to compile this package is:
*** ../vim-8.0.0081/src/mysign	2010-05-15 13:04:12.000000000 +0200
--- src/mysign	2016-11-12 21:01:30.478617518 +0100
***************
*** 1 ****
! =auto/configure-lastupdate=1178970549.78-@buildcheck=dfc15c059b7ce88a951584995c49a201=configure.in@md5=e0d6e9a7d7b986d63ce4e8e7362fd0b9
--- 1 ----
! =auto/configure-lastupdate=1178970549.78-@buildcheck=dfc15c059b7ce88a951584995c49a201=configure.ac@md5=e0d6e9a7d7b986d63ce4e8e7362fd0b9
*** ../vim-8.0.0081/src/version.c	2016-11-12 19:16:42.216999886 +0100
--- src/version.c	2016-11-12 20:06:39.673091660 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     82,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
27. You refer to your age as 3.x.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0083
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0083
Problem:    Using freed memory with win_getid(). (Domenique Pelle)
Solution:   For the current tab use curwin.
Files:      src/window.c, src/testdir/test_window_id.vim


*** ../vim-8.0.0082/src/window.c	2016-11-10 20:01:41.201582868 +0100
--- src/window.c	2016-11-13 14:30:24.411958067 +0100
***************
*** 7133,7139 ****
  		    break;
  	    if (tp == NULL)
  		return -1;
! 	    wp = tp->tp_firstwin;
  	}
  	for ( ; wp != NULL; wp = wp->w_next)
  	    if (--winnr == 0)
--- 7133,7142 ----
  		    break;
  	    if (tp == NULL)
  		return -1;
! 	    if (tp == curtab)
! 		wp = firstwin;
! 	    else
! 		wp = tp->tp_firstwin;
  	}
  	for ( ; wp != NULL; wp = wp->w_next)
  	    if (--winnr == 0)
*** ../vim-8.0.0082/src/testdir/test_window_id.vim	2016-06-04 18:45:17.000000000 +0200
--- src/testdir/test_window_id.vim	2016-11-13 14:25:47.545713017 +0100
***************
*** 92,94 ****
--- 92,103 ----
  
    only!
  endfunc
+ 
+ func Test_win_getid_curtab()
+   tabedit X
+   tabfirst
+   copen
+   only
+   call assert_equal(win_getid(1), win_getid(1, 1))
+   tabclose!
+ endfunc
*** ../vim-8.0.0082/src/version.c	2016-11-12 21:12:48.538182233 +0100
--- src/version.c	2016-11-13 14:29:18.912373539 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     83,
  /**/

-- 
Bypasses are devices that allow some people to dash from point A to
point B very fast while other people dash from point B to point A very
fast.  People living at point C, being a point directly in between, are
often given to wonder what's so great about point A that so many people
from point B are so keen to get there and what's so great about point B
that so many people from point A are so keen to get there.  They often
wish that people would just once and for all work out where the hell
they wanted to be.
		-- Douglas Adams, "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0084
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0084
Problem:    Using freed memory when adding to a quickfix list. (Domenique
            Pelle)
Solution:   Clear the directory name.
Files:      src/quicfix.c, src/testdir/test_quickfix.vim


*** ../vim-8.0.0083/src/quickfix.c	2016-11-12 18:14:39.605896756 +0100
--- src/quickfix.c	2016-11-13 15:02:08.327755407 +0100
***************
*** 1617,1623 ****
  static bufref_T  qf_last_bufref = {NULL, 0};
  
  /*
!  * Get buffer number for file "directory.fname".
   * Also sets the b_has_qf_entry flag.
   */
      static int
--- 1617,1623 ----
  static bufref_T  qf_last_bufref = {NULL, 0};
  
  /*
!  * Get buffer number for file "directory/fname".
   * Also sets the b_has_qf_entry flag.
   */
      static int
***************
*** 2711,2717 ****
--- 2711,2719 ----
      qi->qf_lists[idx].qf_index = 0;
  
      qf_clean_dir_stack(&qi->qf_dir_stack);
+     qi->qf_directory = NULL;
      qf_clean_dir_stack(&qi->qf_file_stack);
+     qi->qf_currfile = NULL;
  }
  
  /*
*** ../vim-8.0.0083/src/testdir/test_quickfix.vim	2016-11-12 18:14:39.609896729 +0100
--- src/testdir/test_quickfix.vim	2016-11-13 14:52:16.099512635 +0100
***************
*** 1669,1671 ****
--- 1669,1693 ----
    call assert_fails('caddexpr ""', 'E376:')
    let &efm = save_efm
  endfunc
+ 
+ func Test_dirstack_cleanup()
+   " This used to cause a memory access in freed memory.
+   let save_efm = &efm
+   lexpr '0'
+   lopen
+   fun X(c)
+     let save_efm=&efm
+     set efm=%D%f
+     if a:c == 'c'
+       caddexpr '::'
+     else
+       laddexpr ':0:0'
+     endif
+     let &efm=save_efm
+   endfun
+   call X('c')
+   call X('l')
+   call setqflist([], 'r')
+   caddbuffer
+   let &efm = save_efm
+ endfunc
*** ../vim-8.0.0083/src/version.c	2016-11-13 14:31:36.691499383 +0100
--- src/version.c	2016-11-13 15:08:25.177362299 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     84,
  /**/

-- 
Far back in the mists of ancient time, in the great and glorious days of the
former Galactic Empire, life was wild, rich and largely tax free.
Mighty starships plied their way between exotic suns, seeking adventure and
reward among the furthest reaches of Galactic space.  In those days, spirits
were brave, the stakes were high, men were real men, women were real women
and small furry creatures from Alpha Centauri were real small furry creatures
from Alpha Centauri.  And all dared to brave unknown terrors, to do mighty
deeds, to boldly split infinitives that no man had split before -- and thus
was the Empire forged.
		-- Douglas Adams, "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0085
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0085
Problem:    Using freed memory with recursive function call. (Dominique Pelle)
Solution:   Make a copy of the function name.
Files:      src/eval.c, src/testdir/test_nested_function.vim


*** ../vim-8.0.0084/src/eval.c	2016-11-10 20:01:41.185582969 +0100
--- src/eval.c	2016-11-14 21:46:38.269423032 +0100
***************
*** 4339,4348 ****
  		 * use its contents. */
  		s = deref_func_name(s, &len, &partial, !evaluate);
  
! 		/* Invoke the function. */
! 		ret = get_func_tv(s, len, rettv, arg,
! 			  curwin->w_cursor.lnum, curwin->w_cursor.lnum,
! 			  &len, evaluate, partial, NULL);
  
  		/* If evaluate is FALSE rettv->v_type was not set in
  		 * get_func_tv, but it's needed in handle_subscript() to parse
--- 4339,4355 ----
  		 * use its contents. */
  		s = deref_func_name(s, &len, &partial, !evaluate);
  
! 		/* Need to make a copy, in case evaluating the arguments makes
! 		 * the name invalid. */
! 		s = vim_strsave(s);
! 		if (s == NULL)
! 		    ret = FAIL;
! 		else
! 		    /* Invoke the function. */
! 		    ret = get_func_tv(s, len, rettv, arg,
! 			      curwin->w_cursor.lnum, curwin->w_cursor.lnum,
! 			      &len, evaluate, partial, NULL);
! 		vim_free(s);
  
  		/* If evaluate is FALSE rettv->v_type was not set in
  		 * get_func_tv, but it's needed in handle_subscript() to parse
*** ../vim-8.0.0084/src/testdir/test_nested_function.vim	2016-09-01 22:07:07.000000000 +0200
--- src/testdir/test_nested_function.vim	2016-11-14 21:43:56.074512335 +0100
***************
*** 1,32 ****
  "Tests for nested functions
  "
! function! NestedFunc()
!   fu! Func1()
      let g:text .= 'Func1 '
!   endfunction
    call Func1()
!   fu! s:func2()
      let g:text .= 's:func2 '
!   endfunction
    call s:func2()
!   fu! s:_func3()
      let g:text .= 's:_func3 '
!   endfunction
    call s:_func3()
    let fn = 'Func4'
!   fu! {fn}()
      let g:text .= 'Func4 '
!   endfunction
    call {fn}()
    let fn = 'func5'
!   fu! s:{fn}()
      let g:text .= 's:func5'
!   endfunction
    call s:{fn}()
! endfunction
  
! function! Test_nested_functions()
    let g:text = ''
    call NestedFunc()
    call assert_equal('Func1 s:func2 s:_func3 Func4 s:func5', g:text)
  endfunction
--- 1,42 ----
  "Tests for nested functions
  "
! func NestedFunc()
!   func! Func1()
      let g:text .= 'Func1 '
!   endfunc
    call Func1()
!   func! s:func2()
      let g:text .= 's:func2 '
!   endfunc
    call s:func2()
!   func! s:_func3()
      let g:text .= 's:_func3 '
!   endfunc
    call s:_func3()
    let fn = 'Func4'
!   func! {fn}()
      let g:text .= 'Func4 '
!   endfunc
    call {fn}()
    let fn = 'func5'
!   func! s:{fn}()
      let g:text .= 's:func5'
!   endfunc
    call s:{fn}()
! endfunc
  
! func Test_nested_functions()
    let g:text = ''
    call NestedFunc()
    call assert_equal('Func1 s:func2 s:_func3 Func4 s:func5', g:text)
  endfunction
+ 
+ func Test_nested_argument()
+   func g:X()
+     let g:Y = function('sort')
+   endfunc
+   let g:Y = function('sort')
+   echo g:Y([], g:X())
+   delfunc g:X
+   unlet g:Y
+ endfunc
*** ../vim-8.0.0084/src/version.c	2016-11-13 15:09:21.301005386 +0100
--- src/version.c	2016-11-14 21:40:08.616043065 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     85,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
3. Every time someone asks you to do something, ask if they want fries
   with that.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0086
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0086
Problem:    Cannot add a comment after ":hide". (Norio Takagi)
Solution:   Make it work, add a test. (Hirohito Higashi)
Files:      src/Makefile, src/ex_cmds.h, src/ex_docmd.c,
            src/testdir/Make_all.mak, src/testdir/test_hide.vim


*** ../vim-8.0.0085/src/Makefile	2016-11-12 21:12:48.534182259 +0100
--- src/Makefile	2016-11-15 20:38:20.349739241 +0100
***************
*** 2097,2102 ****
--- 2097,2103 ----
  	test_gui \
  	test_hardcopy \
  	test_help_tagjump \
+ 	test_hide \
  	test_history \
  	test_hlsearch \
  	test_increment \
*** ../vim-8.0.0085/src/ex_cmds.h	2016-11-12 19:16:42.212999914 +0100
--- src/ex_cmds.h	2016-11-15 20:38:20.349739241 +0100
***************
*** 623,629 ****
  			BANG|EXTRA|TRLBAR|SBOXOK|CMDWIN,
  			ADDR_LINES),
  EX(CMD_hide,		"hide",		ex_hide,
! 			BANG|RANGE|NOTADR|COUNT|EXTRA|NOTRLCOM,
  			ADDR_WINDOWS),
  EX(CMD_history,		"history",	ex_history,
  			EXTRA|TRLBAR|CMDWIN,
--- 623,629 ----
  			BANG|EXTRA|TRLBAR|SBOXOK|CMDWIN,
  			ADDR_LINES),
  EX(CMD_hide,		"hide",		ex_hide,
! 			BANG|RANGE|NOTADR|COUNT|EXTRA|TRLBAR,
  			ADDR_WINDOWS),
  EX(CMD_history,		"history",	ex_history,
  			EXTRA|TRLBAR|CMDWIN,
*** ../vim-8.0.0085/src/ex_docmd.c	2016-11-12 19:16:42.216999886 +0100
--- src/ex_docmd.c	2016-11-15 20:38:20.353739214 +0100
***************
*** 5632,5646 ****
  #endif
  
  /*
!  * Check if *p is a separator between Ex commands.
!  * Return NULL if it isn't, (p + 1) if it is.
   */
      char_u *
  check_nextcmd(char_u *p)
  {
!     p = skipwhite(p);
!     if (*p == '|' || *p == '\n')
! 	return (p + 1);
      else
  	return NULL;
  }
--- 5632,5647 ----
  #endif
  
  /*
!  * Check if *p is a separator between Ex commands, skipping over white space.
!  * Return NULL if it isn't, the following character if it is.
   */
      char_u *
  check_nextcmd(char_u *p)
  {
!     char_u *s = skipwhite(p);
! 
!     if (*s == '|' || *s == '\n')
! 	return (s + 1);
      else
  	return NULL;
  }
***************
*** 7572,7609 ****
      static void
  ex_hide(exarg_T *eap)
  {
!     if (*eap->arg != NUL && check_nextcmd(eap->arg) == NULL)
! 	eap->errmsg = e_invarg;
!     else
!     {
! 	/* ":hide" or ":hide | cmd": hide current window */
! 	eap->nextcmd = check_nextcmd(eap->arg);
  #ifdef FEAT_WINDOWS
! 	if (!eap->skip)
! 	{
  # ifdef FEAT_GUI
! 	    need_mouse_correct = TRUE;
  # endif
! 	    if (eap->addr_count == 0)
! 		win_close(curwin, FALSE);	/* don't free buffer */
! 	    else
! 	    {
! 		int	winnr = 0;
! 		win_T	*win;
  
! 		FOR_ALL_WINDOWS(win)
! 		{
! 		    winnr++;
! 		    if (winnr == eap->line2)
! 			break;
! 		}
! 		if (win == NULL)
! 		    win = lastwin;
! 		win_close(win, FALSE);
  	    }
  	}
- #endif
      }
  }
  
  /*
--- 7573,7604 ----
      static void
  ex_hide(exarg_T *eap)
  {
!     /* ":hide" or ":hide | cmd": hide current window */
  #ifdef FEAT_WINDOWS
!     if (!eap->skip)
!     {
  # ifdef FEAT_GUI
! 	need_mouse_correct = TRUE;
  # endif
! 	if (eap->addr_count == 0)
! 	    win_close(curwin, FALSE);	/* don't free buffer */
! 	else
! 	{
! 	    int	winnr = 0;
! 	    win_T	*win;
  
! 	    FOR_ALL_WINDOWS(win)
! 	    {
! 		winnr++;
! 		if (winnr == eap->line2)
! 		    break;
  	    }
+ 	    if (win == NULL)
+ 		win = lastwin;
+ 	    win_close(win, FALSE);
  	}
      }
+ #endif
  }
  
  /*
*** ../vim-8.0.0085/src/testdir/Make_all.mak	2016-10-15 17:06:42.094912699 +0200
--- src/testdir/Make_all.mak	2016-11-15 20:38:20.357739188 +0100
***************
*** 156,161 ****
--- 156,162 ----
  	    test_gn.res \
  	    test_gui.res \
  	    test_hardcopy.res \
+ 	    test_hide.res \
  	    test_history.res \
  	    test_hlsearch.res \
  	    test_increment.res \
*** ../vim-8.0.0085/src/testdir/test_hide.vim	2016-11-15 21:16:01.358754552 +0100
--- src/testdir/test_hide.vim	2016-11-15 20:38:20.357739188 +0100
***************
*** 0 ****
--- 1,97 ----
+ " Tests for :hide command/modifier and 'hidden' option
+ 
+ function SetUp()
+   let s:save_hidden = &hidden
+   let s:save_bufhidden = &bufhidden
+   let s:save_autowrite = &autowrite
+   set nohidden
+   set bufhidden=
+   set noautowrite
+ endfunc
+ 
+ function TearDown()
+   let &hidden = s:save_hidden
+   let &bufhidden = s:save_bufhidden
+   let &autowrite = s:save_autowrite
+ endfunc
+ 
+ function Test_hide()
+   let orig_bname = bufname('')
+   let orig_winnr = winnr('$')
+ 
+   new Xf1
+   set modified
+   call assert_fails('edit Xf2')
+   bwipeout! Xf1
+ 
+   new Xf1
+   set modified
+   edit! Xf2
+   call assert_equal(['Xf2', 2], [bufname(''), winnr('$')])
+   call assert_equal([1, 0], [buflisted('Xf1'), bufloaded('Xf1')])
+   bwipeout! Xf1
+   bwipeout! Xf2
+ 
+   new Xf1
+   set modified
+   " :hide as a command
+   hide
+   call assert_equal([orig_bname, orig_winnr], [bufname(''), winnr('$')])
+   call assert_equal([1, 1], [buflisted('Xf1'), bufloaded('Xf1')])
+   bwipeout! Xf1
+ 
+   new Xf1
+   set modified
+   " :hide as a command with trailing comment
+   hide " comment
+   call assert_equal([orig_bname, orig_winnr], [bufname(''), winnr('$')])
+   call assert_equal([1, 1], [buflisted('Xf1'), bufloaded('Xf1')])
+   bwipeout! Xf1
+ 
+   new Xf1
+   set modified
+   " :hide as a command with bar
+   hide | new Xf2 " comment
+   call assert_equal(['Xf2', 2], [bufname(''), winnr('$')])
+   call assert_equal([1, 1], [buflisted('Xf1'), bufloaded('Xf1')])
+   bwipeout! Xf1
+   bwipeout! Xf2
+ 
+   new Xf1
+   set modified
+   " :hide as a modifier with trailing comment
+   hide edit Xf2 " comment
+   call assert_equal(['Xf2', 2], [bufname(''), winnr('$')])
+   call assert_equal([1, 1], [buflisted('Xf1'), bufloaded('Xf1')])
+   bwipeout! Xf1
+   bwipeout! Xf2
+ 
+   new Xf1
+   set modified
+   " To check that the bar is not recognized to separate commands
+   hide echo "one|two"
+   call assert_equal(['Xf1', 2], [bufname(''), winnr('$')])
+   call assert_equal([1, 1], [buflisted('Xf1'), bufloaded('Xf1')])
+   bwipeout! Xf1
+ 
+   " set hidden
+   new Xf1
+   set hidden
+   set modified
+   edit Xf2 " comment
+   call assert_equal(['Xf2', 2], [bufname(''), winnr('$')])
+   call assert_equal([1, 1], [buflisted('Xf1'), bufloaded('Xf1')])
+   bwipeout! Xf1
+   bwipeout! Xf2
+ 
+   " set hidden bufhidden=wipe
+   new Xf1
+   set bufhidden=wipe
+   set modified
+   hide edit! Xf2 " comment
+   call assert_equal(['Xf2', 2], [bufname(''), winnr('$')])
+   call assert_equal([0, 0], [buflisted('Xf1'), bufloaded('Xf1')])
+   bwipeout! Xf2
+ endfunc
+ 
+ " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.0.0085/src/version.c	2016-11-14 21:49:57.080090226 +0100
--- src/version.c	2016-11-15 20:39:04.805438063 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     86,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
10. Ask people what sex they are. Laugh hysterically after they answer.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0087
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0087
Problem:    When the channel callback gets job info the job may already have
            been deleted. (lifepillar)
Solution:   Do not delete the job when the channel is still useful. (ichizok,
            closes #1242, closes #1245)
Files:      src/channel.c, src/eval.c, src/os_unix.c, src/os_win32.c,
            src/structs.h, src/testdir/test_channel.vim


*** ../vim-8.0.0086/src/channel.c	2016-11-12 21:12:48.538182233 +0100
--- src/channel.c	2016-11-17 17:13:15.080933875 +0100
***************
*** 4433,4451 ****
      }
  }
  
      static void
  job_cleanup(job_T *job)
  {
      if (job->jv_status != JOB_ENDED)
  	return;
  
      if (job->jv_exit_cb != NULL)
      {
  	typval_T	argv[3];
  	typval_T	rettv;
  	int		dummy;
  
! 	/* invoke the exit callback; make sure the refcount is > 0 */
  	++job->jv_refcount;
  	argv[0].v_type = VAR_JOB;
  	argv[0].vval.v_job = job;
--- 4433,4498 ----
      }
  }
  
+ #if defined(EXITFREE) || defined(PROTO)
+     void
+ job_free_all(void)
+ {
+     while (first_job != NULL)
+ 	job_free(first_job);
+ }
+ #endif
+ 
+ /*
+  * Return TRUE if we need to check if the process of "job" has ended.
+  */
+     static int
+ job_need_end_check(job_T *job)
+ {
+     return job->jv_status == JOB_STARTED
+ 		   && (job->jv_stoponexit != NULL || job->jv_exit_cb != NULL);
+ }
+ 
+ /*
+  * Return TRUE if the channel of "job" is still useful.
+  */
+     static int
+ job_channel_still_useful(job_T *job)
+ {
+     return job->jv_channel != NULL && channel_still_useful(job->jv_channel);
+ }
+ 
+ /*
+  * Return TRUE if the job should not be freed yet.  Do not free the job when
+  * it has not ended yet and there is a "stoponexit" flag, an exit callback
+  * or when the associated channel will do something with the job output.
+  */
+     static int
+ job_still_useful(job_T *job)
+ {
+     return job_need_end_check(job) || job_channel_still_useful(job);
+ }
+ 
+ /*
+  * NOTE: Must call job_cleanup() only once right after the status of "job"
+  * changed to JOB_ENDED (i.e. after job_status() returned "dead" first or
+  * mch_detect_ended_job() returned non-NULL).
+  */
      static void
  job_cleanup(job_T *job)
  {
      if (job->jv_status != JOB_ENDED)
  	return;
  
+     /* Ready to cleanup the job. */
+     job->jv_status = JOB_FINISHED;
+ 
      if (job->jv_exit_cb != NULL)
      {
  	typval_T	argv[3];
  	typval_T	rettv;
  	int		dummy;
  
! 	/* Invoke the exit callback. Make sure the refcount is > 0. */
  	++job->jv_refcount;
  	argv[0].v_type = VAR_JOB;
  	argv[0].vval.v_job = job;
***************
*** 4458,4499 ****
  	--job->jv_refcount;
  	channel_need_redraw = TRUE;
      }
!     if (job->jv_refcount == 0)
!     {
! 	/* The job was already unreferenced, now that it ended it can be
! 	 * freed. Careful: caller must not use "job" after this! */
  	job_free(job);
      }
  }
  
- #if defined(EXITFREE) || defined(PROTO)
-     void
- job_free_all(void)
- {
-     while (first_job != NULL)
- 	job_free(first_job);
- }
- #endif
- 
- /*
-  * Return TRUE if the job should not be freed yet.  Do not free the job when
-  * it has not ended yet and there is a "stoponexit" flag, an exit callback
-  * or when the associated channel will do something with the job output.
-  */
-     static int
- job_still_useful(job_T *job)
- {
-     return (job->jv_stoponexit != NULL || job->jv_exit_cb != NULL
- 	    || (job->jv_channel != NULL
- 		&& channel_still_useful(job->jv_channel)));
- }
- 
-     static int
- job_still_alive(job_T *job)
- {
-     return (job->jv_status == JOB_STARTED) && job_still_useful(job);
- }
- 
  /*
   * Mark references in jobs that are still useful.
   */
--- 4505,4522 ----
  	--job->jv_refcount;
  	channel_need_redraw = TRUE;
      }
! 
!     /* Do not free the job in case the close callback of the associated channel
!      * isn't invoked yet and may get information by job_info(). */
!     if (job->jv_refcount == 0 && !job_channel_still_useful(job))
!     {
! 	/* The job was already unreferenced and the associated channel was
! 	 * detached, now that it ended it can be freed. Careful: caller must
! 	 * not use "job" after this! */
  	job_free(job);
      }
  }
  
  /*
   * Mark references in jobs that are still useful.
   */
***************
*** 4505,4511 ****
      typval_T	tv;
  
      for (job = first_job; job != NULL; job = job->jv_next)
! 	if (job_still_alive(job))
  	{
  	    tv.v_type = VAR_JOB;
  	    tv.vval.v_job = job;
--- 4528,4534 ----
      typval_T	tv;
  
      for (job = first_job; job != NULL; job = job->jv_next)
! 	if (job_still_useful(job))
  	{
  	    tv.v_type = VAR_JOB;
  	    tv.vval.v_job = job;
***************
*** 4514,4539 ****
      return abort;
  }
  
      void
  job_unref(job_T *job)
  {
      if (job != NULL && --job->jv_refcount <= 0)
      {
! 	/* Do not free the job when it has not ended yet and there is a
! 	 * "stoponexit" flag or an exit callback. */
! 	if (!job_still_alive(job))
! 	{
! 	    job_free(job);
! 	}
! 	else if (job->jv_channel != NULL
! 				    && !channel_still_useful(job->jv_channel))
! 	{
! 	    /* Do remove the link to the channel, otherwise it hangs
! 	     * around until Vim exits. See job_free() for refcount. */
! 	    ch_log(job->jv_channel, "detaching channel from job");
! 	    job->jv_channel->ch_job = NULL;
! 	    channel_unref(job->jv_channel);
! 	    job->jv_channel = NULL;
  	}
      }
  }
--- 4537,4569 ----
      return abort;
  }
  
+ /*
+  * Dereference "job".  Note that after this "job" may have been freed.
+  */
      void
  job_unref(job_T *job)
  {
      if (job != NULL && --job->jv_refcount <= 0)
      {
! 	/* Do not free the job if there is a channel where the close callback
! 	 * may get the job info. */
! 	if (!job_channel_still_useful(job))
! 	{
! 	    /* Do not free the job when it has not ended yet and there is a
! 	     * "stoponexit" flag or an exit callback. */
! 	    if (!job_need_end_check(job))
! 	    {
! 		job_free(job);
! 	    }
! 	    else if (job->jv_channel != NULL)
! 	    {
! 		/* Do remove the link to the channel, otherwise it hangs
! 		 * around until Vim exits. See job_free() for refcount. */
! 		ch_log(job->jv_channel, "detaching channel from job");
! 		job->jv_channel->ch_job = NULL;
! 		channel_unref(job->jv_channel);
! 		job->jv_channel = NULL;
! 	    }
  	}
      }
  }
***************
*** 4546,4552 ****
  
      for (job = first_job; job != NULL; job = job->jv_next)
  	if ((job->jv_copyID & mask) != (copyID & mask)
! 						     && !job_still_alive(job))
  	{
  	    /* Free the channel and ordinary items it contains, but don't
  	     * recurse into Lists, Dictionaries etc. */
--- 4576,4582 ----
  
      for (job = first_job; job != NULL; job = job->jv_next)
  	if ((job->jv_copyID & mask) != (copyID & mask)
! 						    && !job_still_useful(job))
  	{
  	    /* Free the channel and ordinary items it contains, but don't
  	     * recurse into Lists, Dictionaries etc. */
***************
*** 4566,4572 ****
      {
  	job_next = job->jv_next;
  	if ((job->jv_copyID & mask) != (copyID & mask)
! 						     && !job_still_alive(job))
  	{
  	    /* Free the job struct itself. */
  	    job_free_job(job);
--- 4596,4602 ----
      {
  	job_next = job->jv_next;
  	if ((job->jv_copyID & mask) != (copyID & mask)
! 						    && !job_still_useful(job))
  	{
  	    /* Free the job struct itself. */
  	    job_free_job(job);
***************
*** 4660,4667 ****
  	/* Only should check if the channel has been closed, if the channel is
  	 * open the job won't exit. */
  	if (job->jv_status == JOB_STARTED && job->jv_exit_cb != NULL
! 		&& (job->jv_channel == NULL
! 		    || !channel_still_useful(job->jv_channel)))
  	    return TRUE;
      return FALSE;
  }
--- 4690,4696 ----
  	/* Only should check if the channel has been closed, if the channel is
  	 * open the job won't exit. */
  	if (job->jv_status == JOB_STARTED && job->jv_exit_cb != NULL
! 					    && !job_channel_still_useful(job))
  	    return TRUE;
      return FALSE;
  }
***************
*** 4676,4689 ****
  {
      int		i;
  
      for (i = 0; i < MAX_CHECK_ENDED; ++i)
      {
  	job_T	*job = mch_detect_ended_job(first_job);
  
  	if (job == NULL)
  	    break;
! 	if (job_still_useful(job))
! 	    job_cleanup(job); /* may free "job" */
      }
  
      if (channel_need_redraw)
--- 4705,4722 ----
  {
      int		i;
  
+     if (first_job == NULL)
+ 	return;
+ 
      for (i = 0; i < MAX_CHECK_ENDED; ++i)
      {
+ 	/* NOTE: mch_detect_ended_job() must only return a job of which the
+ 	 * status was just set to JOB_ENDED. */
  	job_T	*job = mch_detect_ended_job(first_job);
  
  	if (job == NULL)
  	    break;
! 	job_cleanup(job); /* may free "job" */
      }
  
      if (channel_need_redraw)
***************
*** 4897,4903 ****
  {
      char	*result;
  
!     if (job->jv_status == JOB_ENDED)
  	/* No need to check, dead is dead. */
  	result = "dead";
      else if (job->jv_status == JOB_FAILED)
--- 4930,4936 ----
  {
      char	*result;
  
!     if (job->jv_status >= JOB_ENDED)
  	/* No need to check, dead is dead. */
  	result = "dead";
      else if (job->jv_status == JOB_FAILED)
*** ../vim-8.0.0086/src/eval.c	2016-11-14 21:49:57.080090226 +0100
--- src/eval.c	2016-11-17 16:09:44.478455636 +0100
***************
*** 7290,7296 ****
  		if (job == NULL)
  		    return (char_u *)"no process";
  		status = job->jv_status == JOB_FAILED ? "fail"
! 				: job->jv_status == JOB_ENDED ? "dead"
  				: "run";
  # ifdef UNIX
  		vim_snprintf((char *)buf, NUMBUFLEN,
--- 7290,7296 ----
  		if (job == NULL)
  		    return (char_u *)"no process";
  		status = job->jv_status == JOB_FAILED ? "fail"
! 				: job->jv_status >= JOB_ENDED ? "dead"
  				: "run";
  # ifdef UNIX
  		vim_snprintf((char *)buf, NUMBUFLEN,
*** ../vim-8.0.0086/src/os_unix.c	2016-11-12 21:12:48.538182233 +0100
--- src/os_unix.c	2016-11-17 16:09:44.478455636 +0100
***************
*** 5354,5360 ****
      return "run";
  
  return_dead:
!     if (job->jv_status != JOB_ENDED)
      {
  	ch_log(job->jv_channel, "Job ended");
  	job->jv_status = JOB_ENDED;
--- 5354,5360 ----
      return "run";
  
  return_dead:
!     if (job->jv_status < JOB_ENDED)
      {
  	ch_log(job->jv_channel, "Job ended");
  	job->jv_status = JOB_ENDED;
***************
*** 5398,5404 ****
  		job->jv_exitval = WEXITSTATUS(status);
  	    else if (WIFSIGNALED(status))
  		job->jv_exitval = -1;
! 	    if (job->jv_status != JOB_ENDED)
  	    {
  		ch_log(job->jv_channel, "Job ended");
  		job->jv_status = JOB_ENDED;
--- 5398,5404 ----
  		job->jv_exitval = WEXITSTATUS(status);
  	    else if (WIFSIGNALED(status))
  		job->jv_exitval = -1;
! 	    if (job->jv_status < JOB_ENDED)
  	    {
  		ch_log(job->jv_channel, "Job ended");
  		job->jv_status = JOB_ENDED;
*** ../vim-8.0.0086/src/os_win32.c	2016-10-29 14:54:56.628135821 +0200
--- src/os_win32.c	2016-11-17 16:09:44.478455636 +0100
***************
*** 4978,4984 ****
  	    || dwExitCode != STILL_ACTIVE)
      {
  	job->jv_exitval = (int)dwExitCode;
! 	if (job->jv_status != JOB_ENDED)
  	{
  	    ch_log(job->jv_channel, "Job ended");
  	    job->jv_status = JOB_ENDED;
--- 4978,4984 ----
  	    || dwExitCode != STILL_ACTIVE)
      {
  	job->jv_exitval = (int)dwExitCode;
! 	if (job->jv_status < JOB_ENDED)
  	{
  	    ch_log(job->jv_channel, "Job ended");
  	    job->jv_status = JOB_ENDED;
*** ../vim-8.0.0086/src/structs.h	2016-11-10 20:20:01.870602701 +0100
--- src/structs.h	2016-11-17 16:17:49.727271673 +0100
***************
*** 1421,1431 ****
      dict_T	*pt_dict;	/* dict for "self" */
  };
  
  typedef enum
  {
      JOB_FAILED,
      JOB_STARTED,
!     JOB_ENDED
  } jobstatus_T;
  
  /*
--- 1421,1433 ----
      dict_T	*pt_dict;	/* dict for "self" */
  };
  
+ /* Status of a job.  Order matters! */
  typedef enum
  {
      JOB_FAILED,
      JOB_STARTED,
!     JOB_ENDED,	    /* detected job done */
!     JOB_FINISHED    /* job done and cleanup done */
  } jobstatus_T;
  
  /*
*** ../vim-8.0.0086/src/testdir/test_channel.vim	2016-10-27 20:00:03.665357405 +0200
--- src/testdir/test_channel.vim	2016-11-17 16:07:29.307354887 +0100
***************
*** 1232,1237 ****
--- 1232,1263 ----
    endtry
  endfunc
  
+ func Test_close_and_exit_cb()
+   if !has('job')
+     return
+   endif
+   call ch_log('Test_close_and_exit_cb')
+ 
+   let dict = {'ret': {}}
+   func dict.close_cb(ch) dict
+     let self.ret['close_cb'] = job_status(ch_getjob(a:ch))
+   endfunc
+   func dict.exit_cb(job, status) dict
+     let self.ret['exit_cb'] = job_status(a:job)
+   endfunc
+ 
+   let g:job = job_start('echo', {
+         \ 'close_cb': dict.close_cb,
+         \ 'exit_cb': dict.exit_cb,
+         \ })
+   call assert_equal('run', job_status(g:job))
+   unlet g:job
+   call WaitFor('len(dict.ret) >= 2')
+   call assert_equal(2, len(dict.ret))
+   call assert_match('^\%(dead\|run\)', dict.ret['close_cb'])
+   call assert_equal('dead', dict.ret['exit_cb'])
+ endfunc
+ 
  """"""""""
  
  let g:Ch_unletResponse = ''
*** ../vim-8.0.0086/src/version.c	2016-11-15 21:16:46.754453019 +0100
--- src/version.c	2016-11-17 16:10:21.326213761 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     87,
  /**/

-- 
The technology involved in making anything invisible is so infinitely
complex that nine hundred and ninety-nine billion, nine hundred and
ninety-nine million, nine hundred and ninety-nine thousand, nine hundred
and ninety-nine times out of a trillion it is much simpler and more
effective just to take the thing away and do without it.
		-- Douglas Adams, "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0088
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0088
Problem:    When a test fails in Setup or Teardown the problem is not reported.
Solution:   Add a try/catch. (Hirohito Higashi)
Files:      src/testdir/runtest.vim


*** ../vim-8.0.0087/src/testdir/runtest.vim	2016-09-25 22:27:33.709341985 +0200
--- src/testdir/runtest.vim	2016-11-17 17:33:55.192759713 +0100
***************
*** 89,95 ****
  function RunTheTest(test)
    echo 'Executing ' . a:test
    if exists("*SetUp")
!     call SetUp()
    endif
  
    call add(s:messages, 'Executing ' . a:test)
--- 89,99 ----
  function RunTheTest(test)
    echo 'Executing ' . a:test
    if exists("*SetUp")
!     try
!       call SetUp()
!     catch
!       call add(v:errors, 'Caught exception in SetUp() before ' . a:test . ': ' . v:exception . ' @ ' . v:throwpoint)
!     endtry
    endif
  
    call add(s:messages, 'Executing ' . a:test)
***************
*** 104,110 ****
    endtry
  
    if exists("*TearDown")
!     call TearDown()
    endif
  
    " Close any extra windows and make the current one not modified.
--- 108,118 ----
    endtry
  
    if exists("*TearDown")
!     try
!       call TearDown()
!     catch
!       call add(v:errors, 'Caught exception in TearDown() after ' . a:test . ': ' . v:exception . ' @ ' . v:throwpoint)
!     endtry
    endif
  
    " Close any extra windows and make the current one not modified.
***************
*** 221,223 ****
--- 229,233 ----
  write
  
  qall!
+ 
+ " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.0.0087/src/version.c	2016-11-17 17:25:28.212093109 +0100
--- src/version.c	2016-11-17 17:34:43.256423233 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     88,
  /**/

-- 
Time is an illusion.  Lunchtime doubly so.
		-- Ford Prefect, in Douglas Adams'
		   "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0089
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0089
Problem:    Various problems with GTK 3.22.2.
Solution:   Fix the problems, add #ifdefs. (Kazunobu Kuriyama)
Files:      src/gui_beval.c, src/gui_gtk.c, src/gui_gtk_x11.c


*** ../vim-8.0.0088/src/gui_beval.c	2016-11-10 20:01:41.189582944 +0100
--- src/gui_beval.c	2016-11-17 19:09:58.650122624 +0100
***************
*** 1178,1189 ****
--- 1178,1200 ----
  	int		y_offset = EVAL_OFFSET_Y;
  	PangoLayout	*layout;
  # ifdef HAVE_GTK_MULTIHEAD
+ #  if GTK_CHECK_VERSION(3,22,2)
+ 	GdkRectangle rect;
+ 	GdkMonitor * const mon = gdk_display_get_monitor_at_window(
+ 		gtk_widget_get_display(beval->balloonShell),
+ 		gtk_widget_get_window(beval->balloonShell));
+ 	gdk_monitor_get_geometry(mon, &rect);
+ 
+ 	screen_w = rect.width;
+ 	screen_h = rect.height;
+ #  else
  	GdkScreen	*screen;
  
  	screen = gtk_widget_get_screen(beval->target);
  	gtk_window_set_screen(GTK_WINDOW(beval->balloonShell), screen);
  	screen_w = gdk_screen_get_width(screen);
  	screen_h = gdk_screen_get_height(screen);
+ #  endif
  # else
  	screen_w = gdk_screen_width();
  	screen_h = gdk_screen_height();
*** ../vim-8.0.0088/src/gui_gtk.c	2016-08-29 22:42:20.000000000 +0200
--- src/gui_gtk.c	2016-11-17 19:09:58.650122624 +0100
***************
*** 1881,1890 ****
--- 1881,1916 ----
  #  endif
  # endif /* FEAT_XIM */
  
+ # if GTK_CHECK_VERSION(3,22,2)
+     {
+ 	GdkEventButton trigger;
+ 
+ 	/* A pseudo event to have gtk_menu_popup_at_pointer() work. Since the
+ 	 * function calculates the popup menu position on the basis of the
+ 	 * actual pointer position when it is invoked, the fields x, y, x_root
+ 	 * and y_root are set to zero for convenience. */
+ 	trigger.type       = GDK_BUTTON_PRESS;
+ 	trigger.window     = gtk_widget_get_window(gui.drawarea);
+ 	trigger.send_event = FALSE;
+ 	trigger.time       = gui.event_time;
+ 	trigger.x          = 0.0;
+ 	trigger.y          = 0.0;
+ 	trigger.axes       = NULL;
+ 	trigger.state      = 0;
+ 	trigger.button     = 3;
+ 	trigger.device     = NULL;
+ 	trigger.x_root     = 0.0;
+ 	trigger.y_root     = 0.0;
+ 
+ 	gtk_menu_popup_at_pointer(GTK_MENU(menu->submenu_id),
+ 				  (GdkEvent *)&trigger);
+     }
+ #else
      gtk_menu_popup(GTK_MENU(menu->submenu_id),
  		   NULL, NULL,
  		   (GtkMenuPositionFunc)NULL, NULL,
  		   3U, gui.event_time);
+ #endif
  }
  
  /* Ugly global variable to pass "mouse_pos" flag from gui_make_popup() to
***************
*** 1942,1951 ****
--- 1968,2022 ----
  
      if (menu != NULL && menu->submenu_id != NULL)
      {
+ # if GTK_CHECK_VERSION(3,22,2)
+ 	GdkWindow * const win = gtk_widget_get_window(gui.drawarea);
+ 	GdkEventButton trigger;
+ 
+ 	/* A pseudo event to have gtk_menu_popup_at_*() functions work. Since
+ 	 * the position where the menu pops up is automatically adjusted by
+ 	 * the functions, none of the fields x, y, x_root and y_root has to be
+ 	 * set to a specific value here; therefore, they are set to zero for
+ 	 * convenience.*/
+ 	trigger.type       = GDK_BUTTON_PRESS;
+ 	trigger.window     = win;
+ 	trigger.send_event = FALSE;
+ 	trigger.time       = GDK_CURRENT_TIME;
+ 	trigger.x          = 0.0;
+ 	trigger.y          = 0.0;
+ 	trigger.axes       = NULL;
+ 	trigger.state      = 0;
+ 	trigger.button     = 0;
+ 	trigger.device     = NULL;
+ 	trigger.x_root     = 0.0;
+ 	trigger.y_root     = 0.0;
+ 
+ 	if (mouse_pos)
+ 	    gtk_menu_popup_at_pointer(GTK_MENU(menu->submenu_id),
+ 				      (GdkEvent *)&trigger);
+ 	else
+ 	{
+ 	    gint origin_x, origin_y;
+ 	    GdkRectangle rect = { 0, 0, 0, 0 };
+ 
+ 	    gdk_window_get_origin(win, &origin_x, &origin_y);
+ 	    popup_menu_position_func(NULL, &rect.x, &rect.y, NULL, NULL);
+ 
+ 	    rect.x -= origin_x;
+ 	    rect.y -= origin_y;
+ 
+ 	    gtk_menu_popup_at_rect(GTK_MENU(menu->submenu_id),
+ 				   win,
+ 				   &rect,
+ 				   GDK_GRAVITY_SOUTH_EAST,
+ 				   GDK_GRAVITY_NORTH_WEST,
+ 				   (GdkEvent *)&trigger);
+ 	}
+ # else
  	gtk_menu_popup(GTK_MENU(menu->submenu_id),
  		       NULL, NULL,
  		       &popup_menu_position_func, NULL,
  		       0U, (guint32)GDK_CURRENT_TIME);
+ # endif
      }
  }
  
*** ../vim-8.0.0088/src/gui_gtk_x11.c	2016-08-29 22:42:20.000000000 +0200
--- src/gui_gtk_x11.c	2016-11-17 19:09:58.650122624 +0100
***************
*** 3076,3085 ****
--- 3076,3091 ----
      gui.blank_pointer = NULL;
  }
  
+ #if GTK_CHECK_VERSION(3,22,2)
+     static void
+ drawarea_style_updated_cb(GtkWidget *widget UNUSED,
+ 			 gpointer data UNUSED)
+ #else
      static void
  drawarea_style_set_cb(GtkWidget	*widget UNUSED,
  		      GtkStyle	*previous_style UNUSED,
  		      gpointer	data UNUSED)
+ #endif
  {
      gui_mch_new_colors();
  }
***************
*** 3096,3101 ****
--- 3102,3132 ----
      g_return_val_if_fail(event
  	    && event->width >= 1 && event->height >= 1, TRUE);
  
+ # if GTK_CHECK_VERSION(3,22,2)
+     /* As of 3.22.2, GdkWindows have started distributing configure events to
+      * their "native" children (https://git.gnome.org/browse/gtk+/commit/?h=gtk-3-22&id=12579fe71b3b8f79eb9c1b80e429443bcc437dd0).
+      *
+      * As can be seen from the implementation of move_native_children() and
+      * configure_native_child() in gdkwindow.c, those functions actually
+      * propagate configure events to every child, failing to distinguish
+      * "native" one from non-native one.
+      *
+      * Naturally, configure events propagated to here like that are fallacious
+      * and, as a matter of fact, they trigger a geometric collapse of
+      * gui.drawarea in fullscreen and miximized modes.
+      *
+      * To filter out such nuisance events, we are making use of the fact that
+      * the field send_event of such GdkEventConfigures is set to FALSE in
+      * configure_native_child().
+      *
+      * Obviously, this is a terrible hack making GVim depend on GTK's
+      * implementation details.  Therefore, watch out any relevant internal
+      * changes happening in GTK in the feature (sigh).
+      */
+     if (event->send_event == FALSE)
+ 	return TRUE;
+ # endif
+ 
      if (event->width == cur_width && event->height == cur_height)
  	return TRUE;
  
***************
*** 3519,3526 ****
--- 3550,3561 ----
  	/* If the event was generated for 3rd button popup the menu. */
  	if (bevent->button == 3)
  	{
+ # if GTK_CHECK_VERSION(3,22,2)
+ 	    gtk_menu_popup_at_pointer(GTK_MENU(widget), event);
+ # else
  	    gtk_menu_popup(GTK_MENU(widget), NULL, NULL, NULL, NULL,
  						bevent->button, bevent->time);
+ # endif
  	    /* We handled the event. */
  	    return TRUE;
  	}
***************
*** 4116,4121 ****
--- 4151,4159 ----
  #endif
  
      gui.drawarea = gtk_drawing_area_new();
+ #if GTK_CHECK_VERSION(3,22,2)
+     gtk_widget_set_name(gui.drawarea, "vim-gui-drawarea");
+ #endif
  #if GTK_CHECK_VERSION(3,0,0)
      gui.surface = NULL;
      gui.by_signal = FALSE;
***************
*** 4167,4174 ****
--- 4205,4217 ----
  		     G_CALLBACK(drawarea_unrealize_cb), NULL);
      g_signal_connect(G_OBJECT(gui.drawarea), "configure-event",
  	    G_CALLBACK(drawarea_configure_event_cb), NULL);
+ # if GTK_CHECK_VERSION(3,22,2)
+     g_signal_connect_after(G_OBJECT(gui.drawarea), "style-updated",
+ 			   G_CALLBACK(&drawarea_style_updated_cb), NULL);
+ # else
      g_signal_connect_after(G_OBJECT(gui.drawarea), "style-set",
  			   G_CALLBACK(&drawarea_style_set_cb), NULL);
+ # endif
  #else
      gtk_signal_connect(GTK_OBJECT(gui.drawarea), "realize",
  		       GTK_SIGNAL_FUNC(drawarea_realize_cb), NULL);
***************
*** 4384,4397 ****
  gui_mch_new_colors(void)
  {
  #if GTK_CHECK_VERSION(3,0,0)
      GdkWindow * const da_win = gtk_widget_get_window(gui.drawarea);
  
      if (gui.drawarea != NULL && gtk_widget_get_window(gui.drawarea) != NULL)
  #else
      if (gui.drawarea != NULL && gui.drawarea->window != NULL)
  #endif
      {
! #if GTK_CHECK_VERSION(3,4,0)
  	GdkRGBA rgba;
  
  	rgba = color_to_rgba(gui.back_pixel);
--- 4427,4460 ----
  gui_mch_new_colors(void)
  {
  #if GTK_CHECK_VERSION(3,0,0)
+ # if !GTK_CHECK_VERSION(3,22,2)
      GdkWindow * const da_win = gtk_widget_get_window(gui.drawarea);
+ # endif
  
      if (gui.drawarea != NULL && gtk_widget_get_window(gui.drawarea) != NULL)
  #else
      if (gui.drawarea != NULL && gui.drawarea->window != NULL)
  #endif
      {
! #if GTK_CHECK_VERSION(3,22,2)
! 	GtkStyleContext * const context
! 	    = gtk_widget_get_style_context(gui.drawarea);
! 	GtkCssProvider * const provider = gtk_css_provider_new();
! 	gchar * const css = g_strdup_printf(
! 		"widget#vim-gui-drawarea {\n"
! 		"  background-color: #%.2lx%.2lx%.2lx;\n"
! 		"}\n",
! 		 (gui.back_pixel >> 16) & 0xff,
! 		 (gui.back_pixel >> 8) & 0xff,
! 		 gui.back_pixel & 0xff);
! 
! 	gtk_css_provider_load_from_data(provider, css, -1, NULL);
! 	gtk_style_context_add_provider(context,
! 		GTK_STYLE_PROVIDER(provider), G_MAXUINT);
! 
! 	g_free(css);
! 	g_object_unref(provider);
! #elif GTK_CHECK_VERSION(3,4,0) /* !GTK_CHECK_VERSION(3,22,2) */
  	GdkRGBA rgba;
  
  	rgba = color_to_rgba(gui.back_pixel);
***************
*** 4415,4421 ****
  # else
  	gdk_window_set_background(gui.drawarea->window, &color);
  # endif
! #endif /* !GTK_CHECK_VERSION(3,4,0) */
      }
  }
  
--- 4478,4484 ----
  # else
  	gdk_window_set_background(gui.drawarea->window, &color);
  # endif
! #endif /* !GTK_CHECK_VERSION(3,22,2) */
      }
  }
  
***************
*** 4429,4434 ****
--- 4492,4517 ----
  {
      int usable_height = event->height;
  
+ #if GTK_CHECK_VERSION(3,22,2)
+     /* As of 3.22.2, GdkWindows have started distributing configure events to
+      * their "native" children (https://git.gnome.org/browse/gtk+/commit/?h=gtk-3-22&id=12579fe71b3b8f79eb9c1b80e429443bcc437dd0).
+      *
+      * As can be seen from the implementation of move_native_children() and
+      * configure_native_child() in gdkwindow.c, those functions actually
+      * propagate configure events to every child, failing to distinguish
+      * "native" one from non-native one.
+      *
+      * Naturally, configure events propagated to here like that are fallacious
+      * and, as a matter of fact, they trigger a geometric collapse of
+      * gui.formwin.
+      *
+      * To filter out such fallacious events, check if the given event is the
+      * one that was sent out to the right place. Ignore it if not.
+      */
+     if (event->window != gtk_widget_get_window(gui.formwin))
+ 	return TRUE;
+ #endif
+ 
      /* When in a GtkPlug, we can't guarantee valid heights (as a round
       * no. of char-heights), so we have to manually sanitise them.
       * Widths seem to sort themselves out, don't ask me why.
***************
*** 4890,4895 ****
--- 4973,4988 ----
  gui_mch_get_screen_dimensions(int *screen_w, int *screen_h)
  {
  #ifdef HAVE_GTK_MULTIHEAD
+ # if GTK_CHECK_VERSION(3,22,2)
+     GdkRectangle rect;
+     GdkMonitor * const mon = gdk_display_get_monitor_at_window(
+ 	    gtk_widget_get_display(gui.mainwin),
+ 	    gtk_widget_get_window(gui.mainwin));
+     gdk_monitor_get_geometry(mon, &rect);
+ 
+     *screen_w = rect.width;
+     *screen_h = rect.height - p_ghr;
+ # else
      GdkScreen* screen;
  
      if (gui.mainwin != NULL && gtk_widget_has_screen(gui.mainwin))
***************
*** 4899,4904 ****
--- 4992,4998 ----
  
      *screen_w = gdk_screen_get_width(screen);
      *screen_h = gdk_screen_get_height(screen) - p_ghr;
+ # endif
  #else
      *screen_w = gdk_screen_width();
      /* Subtract 'guiheadroom' from the height to allow some room for the
***************
*** 6626,6636 ****
--- 6720,6734 ----
  	};
  	GdkWindow * const win = gtk_widget_get_window(gui.drawarea);
  	cairo_t * const cr = cairo_create(gui.surface);
+ # if GTK_CHECK_VERSION(3,22,2)
+ 	set_cairo_source_rgba_from_color(cr, gui.back_pixel);
+ # else
  	cairo_pattern_t * const pat = gdk_window_get_background_pattern(win);
  	if (pat != NULL)
  	    cairo_set_source(cr, pat);
  	else
  	    set_cairo_source_rgba_from_color(cr, gui.back_pixel);
+ # endif
  	gdk_cairo_rectangle(cr, &rect);
  	cairo_fill(cr);
  	cairo_destroy(cr);
***************
*** 6659,6669 ****
--- 6757,6771 ----
  	0, 0, gdk_window_get_width(win), gdk_window_get_height(win)
      };
      cairo_t * const cr = cairo_create(gui.surface);
+ # if GTK_CHECK_VERSION(3,22,2)
+     set_cairo_source_rgba_from_color(cr, gui.back_pixel);
+ # else
      cairo_pattern_t * const pat = gdk_window_get_background_pattern(win);
      if (pat != NULL)
  	cairo_set_source(cr, pat);
      else
  	set_cairo_source_rgba_from_color(cr, gui.back_pixel);
+ # endif
      gdk_cairo_rectangle(cr, &rect);
      cairo_fill(cr);
      cairo_destroy(cr);
*** ../vim-8.0.0088/src/version.c	2016-11-17 17:56:10.103449001 +0100
--- src/version.c	2016-11-17 19:10:50.549780930 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     89,
  /**/

-- 
What a wonderfully exciting cough!  Do you mind if I join you?
		-- Douglas Adams, "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0090
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0090
Problem:    Cursor moved after last character when using 'breakindent'.
Solution:   Fix the cursor positioning.  Turn the breakindent test into new
            style.  (Christian Brabandt)
Files:      src/screen.c, src/testdir/Make_all.mak,
            src/testdir/test_breakindent.in, src/testdir/test_breakindent.ok,
            src/testdir/test_breakindent.vim, src/Makefile


*** ../vim-8.0.0089/src/screen.c	2016-11-06 15:25:37.697627447 +0100
--- src/screen.c	2016-11-17 19:27:22.767064438 +0100
***************
*** 3010,3016 ****
  #endif
      colnr_T	trailcol = MAXCOL;	/* start of trailing spaces */
  #ifdef FEAT_LINEBREAK
!     int		need_showbreak = FALSE;
  #endif
  #if defined(FEAT_SIGNS) || (defined(FEAT_QUICKFIX) && defined(FEAT_WINDOWS)) \
  	|| defined(FEAT_SYN_HL) || defined(FEAT_DIFF)
--- 3010,3017 ----
  #endif
      colnr_T	trailcol = MAXCOL;	/* start of trailing spaces */
  #ifdef FEAT_LINEBREAK
!     int		need_showbreak = FALSE; /* overlong line, skipping first x
! 					   chars */
  #endif
  #if defined(FEAT_SIGNS) || (defined(FEAT_QUICKFIX) && defined(FEAT_WINDOWS)) \
  	|| defined(FEAT_SYN_HL) || defined(FEAT_DIFF)
***************
*** 3793,3805 ****
  	    if (draw_state == WL_BRI - 1 && n_extra == 0)
  	    {
  		draw_state = WL_BRI;
! 		if (wp->w_p_bri && n_extra == 0 && row != startrow
  # ifdef FEAT_DIFF
  			&& filler_lines == 0
  # endif
  		   )
  		{
! 		    char_attr = 0; /* was: hl_attr(HLF_AT); */
  # ifdef FEAT_DIFF
  		    if (diff_hlf != (hlf_T)0)
  		    {
--- 3794,3808 ----
  	    if (draw_state == WL_BRI - 1 && n_extra == 0)
  	    {
  		draw_state = WL_BRI;
! 		/* if need_showbreak is set, breakindent also applies */
! 		if (wp->w_p_bri && n_extra == 0
! 					 && (row != startrow || need_showbreak)
  # ifdef FEAT_DIFF
  			&& filler_lines == 0
  # endif
  		   )
  		{
! 		    char_attr = 0;
  # ifdef FEAT_DIFF
  		    if (diff_hlf != (hlf_T)0)
  		    {
*** ../vim-8.0.0089/src/testdir/Make_all.mak	2016-11-15 21:16:46.754453019 +0100
--- src/testdir/Make_all.mak	2016-11-17 19:24:06.120428121 +0100
***************
*** 75,81 ****
  	test108.out \
  	test_autocmd_option.out \
  	test_autoformat_join.out \
- 	test_breakindent.out \
  	test_changelist.out \
  	test_close_count.out \
  	test_comparators.out \
--- 75,80 ----
***************
*** 141,146 ****
--- 140,146 ----
  	    test_assert.res \
  	    test_autochdir.res \
  	    test_backspace_opt.res \
+ 	    test_breakindent.res \
  	    test_bufwintabinfo.res \
  	    test_cdo.res \
  	    test_channel.res \
*** ../vim-8.0.0089/src/testdir/test_breakindent.in	2015-01-27 17:07:20.000000000 +0100
--- src/testdir/test_breakindent.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,122 ****
- Test for breakindent
- 
- STARTTEST
- :so small.vim
- :if !exists("+breakindent") | e! test.ok | w! test.out | qa! | endif
- :10new|:vsp|:vert resize 20
- :put =\"\tabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOP\"
- :set ts=4 sw=4 sts=4 breakindent
- :fu! ScreenChar(line, width)
- :	let c=''
- :	for i in range(1,a:width)
- :		let c.=nr2char(screenchar(a:line, i))
- :	endfor
- :       let c.="\n"
- :	for i in range(1,a:width)
- :		let c.=nr2char(screenchar(a:line+1, i))
- :	endfor
- :       let c.="\n"
- :	for i in range(1,a:width)
- :		let c.=nr2char(screenchar(a:line+2, i))
- :	endfor
- :	return c
- :endfu
- :fu DoRecordScreen()
- :	wincmd l
- :	$put =printf(\"\n%s\", g:test)
- :	$put =g:line1
- :	wincmd p
- :endfu
- :set briopt=min:0
- :let g:test="Test 1: Simple breakindent"
- :let line1=ScreenChar(line('.'),8)
- :call DoRecordScreen()
- :let g:test="Test 2: Simple breakindent + sbr=>>"
- :set sbr=>>
- :let line1=ScreenChar(line('.'),8)
- :call DoRecordScreen()
- :let g:test ="Test 3: Simple breakindent + briopt:sbr"
- :set briopt=sbr,min:0 sbr=++
- :let line1=ScreenChar(line('.'),8)
- :call DoRecordScreen()
- :let g:test ="Test 4: Simple breakindent + min width: 18"
- :set sbr= briopt=min:18
- :let line1=ScreenChar(line('.'),8)
- :call DoRecordScreen()
- :let g:test =" Test 5: Simple breakindent + shift by 2"
- :set briopt=shift:2,min:0
- :let line1=ScreenChar(line('.'),8)
- :call DoRecordScreen()
- :let g:test=" Test 6: Simple breakindent + shift by -1"
- :set briopt=shift:-1,min:0
- :let line1=ScreenChar(line('.'),8)
- :call DoRecordScreen()
- :let g:test=" Test 7: breakindent + shift by +1 + nu + sbr=? briopt:sbr"
- :set briopt=shift:1,sbr,min:0 nu sbr=? nuw=4
- :let line1=ScreenChar(line('.'),10)
- :call DoRecordScreen()
- :let g:test=" Test 8: breakindent + shift:1 + nu + sbr=# list briopt:sbr"
- :set briopt=shift:1,sbr,min:0 nu sbr=# list
- :let line1=ScreenChar(line('.'),10)
- :call DoRecordScreen()
- :let g:test=" Test 9: breakindent + shift by +1 + 'nu' + sbr=# list"
- :set briopt-=sbr
- :let line1=ScreenChar(line('.'),10)
- :call DoRecordScreen()
- :let g:test=" Test 10: breakindent + shift by +1 + 'nu' + sbr=~ cpo+=n"
- :set cpo+=n sbr=~ nu nuw=4 nolist briopt=sbr,min:0
- :let line1=ScreenChar(line('.'),10)
- :call DoRecordScreen()
- :wincmd p
- :let g:test="\n Test 11: strdisplaywidth when breakindent is on"
- :set cpo-=n sbr=>> nu nuw=4 nolist briopt= ts=4
- :let text=getline(2) "skip leading tab when calculating text width
- :let width = strlen(text[1:])+indent(2)*4+strlen(&sbr)*3 " text wraps 3 times
- :$put =g:test
- :$put =printf(\"strdisplaywidth: %d == calculated: %d\", strdisplaywidth(text), width)
- :let g:str="\t\t\t\t\t{"
- :let g:test=" Test 12: breakindent + long indent"
- :wincmd p
- :set all& breakindent linebreak briopt=min:10 nu numberwidth=3 ts=4
- :$put =g:str
- zt:let line1=ScreenChar(1,10)
- :wincmd p
- :call DoRecordScreen()
- :"
- :" Test, that the string "    a\tb\tc\td\te" is correctly
- :" displayed in a 20 column wide window (see bug report
- :" https://groups.google.com/d/msg/vim_dev/ZOdg2mc9c9Y/TT8EhFjEy0IJ
- :only
- :vert 20new
- :set all& nocp breakindent briopt=min:10
- :call setline(1, ["    a\tb\tc\td\te", "    z   y       x       w       v"])
- :/^\s*a
- fbgjyl:let line1 = @0
- :?^\s*z
- fygjyl:let line2 = @0
- :quit!
- :$put ='Test 13: breakindent with wrapping Tab'
- :$put =line1
- :$put =line2
- :"
- :let g:test="Test 14: breakindent + visual blockwise delete #1"
- :set all& breakindent viminfo+=nviminfo
- :30vnew
- :normal! 3a1234567890
- :normal! a    abcde
- :exec "normal! 0\<C-V>tex"
- :let line1=ScreenChar(line('.'),8)
- :call DoRecordScreen()
- :"
- :let g:test="Test 15: breakindent + visual blockwise delete #2"
- :%d
- :normal! 4a1234567890
- :exec "normal! >>\<C-V>3f0x"
- :let line1=ScreenChar(line('.'),20)
- :call DoRecordScreen()
- :quit!
- :"
- :%w! test.out
- :qa!
- ENDTEST
- dummy text
--- 0 ----
*** ../vim-8.0.0089/src/testdir/test_breakindent.ok	2015-01-27 13:06:51.000000000 +0100
--- src/testdir/test_breakindent.ok	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,74 ****
- 
- 	abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOP
- 
- Test 1: Simple breakindent
-     abcd
-     qrst
-     GHIJ
- 
- Test 2: Simple breakindent + sbr=>>
-     abcd
-     >>qr
-     >>EF
- 
- Test 3: Simple breakindent + briopt:sbr
-     abcd
- ++  qrst
- ++  GHIJ
- 
- Test 4: Simple breakindent + min width: 18
-     abcd
-   qrstuv
-   IJKLMN
- 
-  Test 5: Simple breakindent + shift by 2
-     abcd
-       qr
-       EF
- 
-  Test 6: Simple breakindent + shift by -1
-     abcd
-    qrstu
-    HIJKL
- 
-  Test 7: breakindent + shift by +1 + nu + sbr=? briopt:sbr
-   2     ab
- ?        m
- ?        x
- 
-  Test 8: breakindent + shift:1 + nu + sbr=# list briopt:sbr
-   2 ^Iabcd
- #      opq
- #      BCD
- 
-  Test 9: breakindent + shift by +1 + 'nu' + sbr=# list
-   2 ^Iabcd
-        #op
-        #AB
- 
-  Test 10: breakindent + shift by +1 + 'nu' + sbr=~ cpo+=n
-   2     ab
- ~       mn
- ~       yz
- 
-  Test 11: strdisplaywidth when breakindent is on
- strdisplaywidth: 46 == calculated: 64
- 					{
- 
-  Test 12: breakindent + long indent
- 56        
-           
- ~         
- Test 13: breakindent with wrapping Tab
- d
- w
- 
- Test 14: breakindent + visual blockwise delete #1
- e       
- ~       
- ~       
- 
- Test 15: breakindent + visual blockwise delete #2
-         1234567890  
- ~                   
- ~                   
--- 0 ----
*** ../vim-8.0.0089/src/testdir/test_breakindent.vim	2016-11-17 19:31:49.285221709 +0100
--- src/testdir/test_breakindent.vim	2016-11-17 19:26:47.999305286 +0100
***************
*** 0 ****
--- 1,241 ----
+ " Test for breakindent
+ "
+ " Note: if you get strange failures when adding new tests, it might be that
+ " while the test is run, the breakindent cacheing gets in its way.
+ " It helps to change the tabastop setting and force a redraw (e.g. see
+ " Test_breakindent08())
+ if !exists('+breakindent')
+   finish
+ endif
+ 
+ let s:input ="\tabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOP"
+ 
+ function s:screenline(lnum, width) abort
+   " always get 4 screen lines
+   redraw!
+   let line = []
+   for j in range(3)
+     for c in range(1, a:width)
+   call add(line, nr2char(screenchar(a:lnum+j, c)))
+     endfor
+     call add(line, "\n")
+   endfor
+   return join(line, '')
+ endfunction
+ 
+ function s:testwindows(...)
+   10new
+   vsp
+   vert resize 20
+   setl ts=4 sw=4 sts=4 breakindent 
+   put =s:input
+   if a:0
+     exe a:1
+   endif
+ endfunction
+ 
+ function s:close_windows(...)
+   bw!
+   if a:0
+     exe a:1
+   endif
+   unlet! g:line g:expect
+ endfunction
+ 
+ function Test_breakindent01()
+   " simple breakindent test
+   call s:testwindows('setl briopt=min:0')
+   let g:line=s:screenline(line('.'),8)
+   let g:expect="    abcd\n    qrst\n    GHIJ\n"
+   call assert_equal(g:expect, g:line)
+   call s:close_windows()
+ endfunction
+ 
+ function Test_breakindent02()
+   " simple breakindent test with showbreak set
+   call s:testwindows('setl briopt=min:0 sbr=>>')
+   let g:line=s:screenline(line('.'),8)
+   let g:expect="    abcd\n    >>qr\n    >>EF\n"
+   call assert_equal(g:expect, g:line)
+   call s:close_windows('set sbr=')
+ endfunction
+ 
+ function Test_breakindent03()
+   " simple breakindent test with showbreak set and briopt including sbr
+   call s:testwindows('setl briopt=sbr,min:0 sbr=++')
+   let g:line=s:screenline(line('.'),8)
+   let g:expect="    abcd\n++  qrst\n++  GHIJ\n"
+   call assert_equal(g:expect, g:line)
+   " clean up
+   call s:close_windows('set sbr=')
+ endfunction
+ 
+ function Test_breakindent04()
+   " breakindent set with min width 18
+   call s:testwindows('setl sbr= briopt=min:18')
+   let g:line=s:screenline(line('.'),8)
+   let g:expect="    abcd\n  qrstuv\n  IJKLMN\n"
+   call assert_equal(g:expect, g:line)
+   " clean up
+   call s:close_windows('set sbr=')
+ endfunction
+ 
+ function Test_breakindent05()
+   " breakindent set and shift by 2
+   call s:testwindows('setl briopt=shift:2,min:0')
+   let g:line=s:screenline(line('.'),8)
+   let g:expect="    abcd\n      qr\n      EF\n"
+   call assert_equal(g:expect, g:line)
+   call s:close_windows()
+ endfunction
+ 
+ function Test_breakindent06()
+   " breakindent set and shift by -1
+   call s:testwindows('setl briopt=shift:-1,min:0')
+   let g:line=s:screenline(line('.'),8)
+   let g:expect="    abcd\n   qrstu\n   HIJKL\n"
+   call assert_equal(g:expect, g:line)
+   call s:close_windows()
+ endfunction
+ 
+ function Test_breakindent07()
+   " breakindent set and shift by 1, Number  set sbr=? and briopt:sbr
+   call s:testwindows('setl briopt=shift:1,sbr,min:0 nu sbr=? nuw=4 cpo+=n')
+   let g:line=s:screenline(line('.'),10)
+   let g:expect="  2     ab\n?        m\n?        x\n"
+   call assert_equal(g:expect, g:line)
+   " clean up
+   call s:close_windows('set sbr= cpo-=n')
+ endfunction
+ 
+ function Test_breakindent07a()
+   " breakindent set and shift by 1, Number  set sbr=? and briopt:sbr
+   call s:testwindows('setl briopt=shift:1,sbr,min:0 nu sbr=? nuw=4')
+   let g:line=s:screenline(line('.'),10)
+   let g:expect="  2     ab\n    ?    m\n    ?    x\n"
+   call assert_equal(g:expect, g:line)
+   " clean up
+   call s:close_windows('set sbr=')
+ endfunction
+ 
+ function Test_breakindent08()
+   " breakindent set and shift by 1, Number and list set sbr=# and briopt:sbr
+   call s:testwindows('setl briopt=shift:1,sbr,min:0 nu nuw=4 sbr=# list cpo+=n ts=4')
+   " make sure, cache is invalidated!
+   set ts=8
+   redraw!
+   set ts=4
+   redraw!
+   let g:line=s:screenline(line('.'),10)
+   let g:expect="  2 ^Iabcd\n#      opq\n#      BCD\n"
+   call assert_equal(g:expect, g:line)
+   call s:close_windows('set sbr= cpo-=n')
+ endfunction
+ 
+ function Test_breakindent08a()
+   " breakindent set and shift by 1, Number and list set sbr=# and briopt:sbr
+   call s:testwindows('setl briopt=shift:1,sbr,min:0 nu nuw=4 sbr=# list')
+   let g:line=s:screenline(line('.'),10)
+   let g:expect="  2 ^Iabcd\n    #  opq\n    #  BCD\n"
+   call assert_equal(g:expect, g:line)
+   call s:close_windows('set sbr=')
+ endfunction
+ 
+ function Test_breakindent09()
+   " breakindent set and shift by 1, Number and list set sbr=#
+   call s:testwindows('setl briopt=shift:1,min:0 nu nuw=4 sbr=# list')
+   let g:line=s:screenline(line('.'),10)
+   let g:expect="  2 ^Iabcd\n       #op\n       #AB\n"
+   call assert_equal(g:expect, g:line)
+   call s:close_windows('set sbr=')
+ endfunction
+ 
+ function Test_breakindent10()
+   " breakindent set, Number set sbr=~
+   call s:testwindows('setl cpo+=n sbr=~ nu nuw=4 nolist briopt=sbr,min:0')
+   " make sure, cache is invalidated!
+   set ts=8
+   redraw!
+   set ts=4
+   redraw!
+   let g:line=s:screenline(line('.'),10)
+   let g:expect="  2     ab\n~       mn\n~       yz\n"
+   call assert_equal(g:expect, g:line)
+   call s:close_windows('set sbr= cpo-=n')
+ endfunction
+ 
+ function Test_breakindent11()
+   " test strdisplaywidth()
+   call s:testwindows('setl cpo-=n sbr=>> nu nuw=4 nolist briopt= ts=4')
+   let text=getline(2)
+   let width = strlen(text[1:])+indent(2)+strlen(&sbr)*3 " text wraps 3 times
+   call assert_equal(width, strdisplaywidth(text))
+   call s:close_windows('set sbr=')
+ endfunction
+ 
+ function Test_breakindent12()
+   " test breakindent with long indent
+   let s:input="\t\t\t\t\t{"
+   call s:testwindows('setl breakindent linebreak briopt=min:10 nu numberwidth=3 ts=4 list listchars=tab:>-')
+   let g:line=s:screenline(2,16)
+   let g:expect=" 2 >--->--->--->\n          ---{  \n~               \n"
+   call assert_equal(g:expect, g:line)
+   call s:close_windows('set nuw=4 listchars=')
+ endfunction
+ 
+ function Test_breakindent13()
+   let s:input=""
+   call s:testwindows('setl breakindent briopt=min:10 ts=8')
+   vert resize 20
+   call setline(1, ["    a\tb\tc\td\te", "    z   y       x       w       v"])
+   1
+   norm! fbgj"ayl
+   2
+   norm! fygj"byl
+   call assert_equal('d', @a)
+   call assert_equal('w', @b)
+   call s:close_windows()
+ endfunction
+ 
+ function Test_breakindent14()
+   let s:input=""
+   call s:testwindows('setl breakindent briopt= ts=8')
+   vert resize 30
+   norm! 3a1234567890
+   norm! a    abcde
+   exec "norm! 0\<C-V>tex"
+   let g:line=s:screenline(line('.'),8)
+   let g:expect="e       \n~       \n~       \n"
+   call assert_equal(g:expect, g:line)
+   call s:close_windows()
+ endfunction
+ 
+ function Test_breakindent15()
+   let s:input=""
+   call s:testwindows('setl breakindent briopt= ts=8 sw=8')
+   vert resize 30
+   norm! 4a1234567890
+   exe "normal! >>\<C-V>3f0x"
+   let g:line=s:screenline(line('.'),20)
+   let g:expect="        1234567890  \n~                   \n~                   \n"
+   call assert_equal(g:expect, g:line)
+   call s:close_windows()
+ endfunction
+ 
+ function Test_breakindent16()
+   " Check that overlong lines are indented correctly.
+   " TODO: currently it does not fail even when the bug is not fixed.
+   let s:input=""
+   call s:testwindows('setl breakindent briopt=min:0 ts=4')
+   call setline(1, "\t".repeat("1234567890", 10))
+   resize 6
+   norm! 1gg$
+   redraw!
+   let g:line=s:screenline(1,10)
+   let g:expect="    123456\n    789012\n    345678\n"
+   call assert_equal(g:expect, g:line)
+   let g:line=s:screenline(4,10)
+   let g:expect="    901234\n    567890\n    123456\n"
+   call assert_equal(g:expect, g:line)
+   call s:close_windows()
+ endfunction
*** ../vim-8.0.0089/src/Makefile	2016-11-15 21:16:46.746453073 +0100
--- src/Makefile	2016-11-17 19:25:11.119976976 +0100
***************
*** 2029,2035 ****
  test1 \
  	test_autocmd_option \
  	test_autoformat_join \
- 	test_breakindent \
  	test_changelist \
  	test_close_count \
  	test_comparators \
--- 2029,2034 ----
***************
*** 2064,2069 ****
--- 2063,2069 ----
  	test_autochdir \
  	test_autocmd \
  	test_backspace_opt \
+ 	test_breakindent \
  	test_bufwintabinfo \
  	test_cdo \
  	test_channel \
*** ../vim-8.0.0089/src/version.c	2016-11-17 19:11:51.717378244 +0100
--- src/version.c	2016-11-17 19:24:36.424217741 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     90,
  /**/

-- 
"You know, it's at times like this when I'm trapped in a Vogon airlock with
a man from Betelgeuse and about to die of asphyxiation in deep space that I
really wish I'd listened to what my mother told me when I was young!"
"Why, what did she tell you?"
"I don't know, I didn't listen!"
		-- Arthur Dent and Ford Prefect in Douglas Adams'
		   "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0091
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0091
Problem:    Test_help_complete sometimes fails in MS-Windows console.
Solution:   Use getcompletion() instead of feedkeys() and command line
            completion. (Hirohito Higashi)
Files:      src/testdir/test_help_tagjump.vim


*** ../vim-8.0.0090/src/testdir/test_help_tagjump.vim	2016-08-18 22:59:47.000000000 +0200
--- src/testdir/test_help_tagjump.vim	2016-11-17 19:38:16.806536964 +0100
***************
*** 77,93 ****
    endif
  endfunc
  
! func s:get_cmd_compl_list(cmd)
!   let list = []
!   let str = ''
!   for cnt in range(1, 999)
!     call feedkeys(a:cmd . repeat("\<Tab>", cnt) . "'\<C-B>let str='\<CR>", 'tx')
!     if str ==# a:cmd[1:]
!       break
!     endif
!     call add(list, str)
!   endfor
!   return list
  endfunc
  
  func Test_help_complete()
--- 77,84 ----
    endif
  endfunc
  
! func s:get_help_compl_list(cmd)
!   return getcompletion(a:cmd, 'help')
  endfunc
  
  func Test_help_complete()
***************
*** 99,147 ****
      if has('multi_lang')
        set helplang=
      endif
!     let list = s:get_cmd_compl_list(":h test")
!     call assert_equal(['h test-col', 'h test-char'], list)
  
      if has('multi_lang')
        " 'helplang=ab' and help file lang is 'en'
        set helplang=ab
!       let list = s:get_cmd_compl_list(":h test")
!       call assert_equal(['h test-col', 'h test-char'], list)
  
        " 'helplang=' and help file lang is 'en' and 'ab'
        set rtp+=Xdir1/doc-ab
        set helplang=
!       let list = s:get_cmd_compl_list(":h test")
!       call assert_equal(sort(['h test-col@en', 'h test-col@ab',
!             \             'h test-char@en', 'h test-char@ab']), sort(list))
  
        " 'helplang=ab' and help file lang is 'en' and 'ab'
        set helplang=ab
!       let list = s:get_cmd_compl_list(":h test")
!       call assert_equal(sort(['h test-col', 'h test-col@en',
!             \             'h test-char', 'h test-char@en']), sort(list))
  
        " 'helplang=' and help file lang is 'en', 'ab' and 'ja'
        set rtp+=Xdir1/doc-ja
        set helplang=
!       let list = s:get_cmd_compl_list(":h test")
!       call assert_equal(sort(['h test-col@en', 'h test-col@ab',
!             \             'h test-col@ja', 'h test-char@en',
!             \             'h test-char@ab', 'h test-char@ja']), sort(list))
  
        " 'helplang=ab' and help file lang is 'en', 'ab' and 'ja'
        set helplang=ab
!       let list = s:get_cmd_compl_list(":h test")
!       call assert_equal(sort(['h test-col', 'h test-col@en',
!             \             'h test-col@ja', 'h test-char',
!             \             'h test-char@en', 'h test-char@ja']), sort(list))
  
        " 'helplang=ab,ja' and help file lang is 'en', 'ab' and 'ja'
        set helplang=ab,ja
!       let list = s:get_cmd_compl_list(":h test")
!       call assert_equal(sort(['h test-col', 'h test-col@ja',
!             \             'h test-col@en', 'h test-char',
!             \             'h test-char@ja', 'h test-char@en']), sort(list))
      endif
    catch
      call assert_exception('X')
--- 90,138 ----
      if has('multi_lang')
        set helplang=
      endif
!     let list = s:get_help_compl_list("test")
!     call assert_equal(['test-col', 'test-char'], list)
  
      if has('multi_lang')
        " 'helplang=ab' and help file lang is 'en'
        set helplang=ab
!       let list = s:get_help_compl_list("test")
!       call assert_equal(['test-col', 'test-char'], list)
  
        " 'helplang=' and help file lang is 'en' and 'ab'
        set rtp+=Xdir1/doc-ab
        set helplang=
!       let list = s:get_help_compl_list("test")
!       call assert_equal(sort(['test-col@en', 'test-col@ab',
!             \             'test-char@en', 'test-char@ab']), sort(list))
  
        " 'helplang=ab' and help file lang is 'en' and 'ab'
        set helplang=ab
!       let list = s:get_help_compl_list("test")
!       call assert_equal(sort(['test-col', 'test-col@en',
!             \             'test-char', 'test-char@en']), sort(list))
  
        " 'helplang=' and help file lang is 'en', 'ab' and 'ja'
        set rtp+=Xdir1/doc-ja
        set helplang=
!       let list = s:get_help_compl_list("test")
!       call assert_equal(sort(['test-col@en', 'test-col@ab',
!             \             'test-col@ja', 'test-char@en',
!             \             'test-char@ab', 'test-char@ja']), sort(list))
  
        " 'helplang=ab' and help file lang is 'en', 'ab' and 'ja'
        set helplang=ab
!       let list = s:get_help_compl_list("test")
!       call assert_equal(sort(['test-col', 'test-col@en',
!             \             'test-col@ja', 'test-char',
!             \             'test-char@en', 'test-char@ja']), sort(list))
  
        " 'helplang=ab,ja' and help file lang is 'en', 'ab' and 'ja'
        set helplang=ab,ja
!       let list = s:get_help_compl_list("test")
!       call assert_equal(sort(['test-col', 'test-col@ja',
!             \             'test-col@en', 'test-char',
!             \             'test-char@ja', 'test-char@en']), sort(list))
      endif
    catch
      call assert_exception('X')
*** ../vim-8.0.0090/src/version.c	2016-11-17 19:32:17.901024218 +0100
--- src/version.c	2016-11-17 19:42:02.032924245 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     91,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
29. Your phone bill comes to your doorstep in a box.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0092
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0092
Problem:    C indenting does not support nested namespaces that C++ 17 has.
Solution:   Add check that passes double colon inside a name. (Pauli, closes
            #1214)
Files:      src/misc1.c, src/testdir/test3.in, src/testdir/test3.ok


*** ../vim-8.0.0091/src/misc1.c	2016-10-12 14:19:55.746357751 +0200
--- src/misc1.c	2016-11-17 21:21:03.040128865 +0100
***************
*** 5762,5767 ****
--- 5762,5768 ----
  {
      char_u	*p;
      int		has_name = FALSE;
+     int		has_name_start = FALSE;
  
      s = cin_skipcomment(s);
      if (STRNCMP(s, "namespace", 9) == 0 && (s[9] == NUL || !vim_iswordc(s[9])))
***************
*** 5780,5789 ****
--- 5781,5798 ----
  	    }
  	    else if (vim_iswordc(*p))
  	    {
+ 		has_name_start = TRUE;
  		if (has_name)
  		    return FALSE; /* word character after skipping past name */
  		++p;
  	    }
+ 	    else if (p[0] == ':' && p[1] == ':' && vim_iswordc(p[2]))
+ 	    {
+ 		if (!has_name_start || has_name)
+ 		    return FALSE;
+ 		/* C++ 17 nested namespace */
+ 		p += 3;
+ 	    }
  	    else
  	    {
  		return FALSE;
*** ../vim-8.0.0091/src/testdir/test3.in	2015-11-10 13:56:14.000000000 +0100
--- src/testdir/test3.in	2016-11-17 21:16:53.861790464 +0100
***************
*** 1932,1937 ****
--- 1932,1957 ----
  {
    111111111111111111;
  }
+ namespace test::cpp17
+ {
+   111111111111111111;
+ }
+ namespace ::incorrectcpp17
+ {
+   111111111111111111;
+ }
+ namespace test::incorrectcpp17::
+ {
+   111111111111111111;
+ }
+ namespace test:incorrectcpp17
+ {
+   111111111111111111;
+ }
+ namespace test:::incorrectcpp17
+ {
+   111111111111111111;
+ }
  namespace{
    111111111111111111;
  }
*** ../vim-8.0.0091/src/testdir/test3.ok	2015-11-10 13:56:40.000000000 +0100
--- src/testdir/test3.ok	2016-11-17 21:16:53.861790464 +0100
***************
*** 1730,1735 ****
--- 1730,1755 ----
  {
  111111111111111111;
  }
+ namespace test::cpp17
+ {
+ 111111111111111111;
+ }
+ namespace ::incorrectcpp17
+ {
+ 	111111111111111111;
+ }
+ namespace test::incorrectcpp17::
+ {
+ 	111111111111111111;
+ }
+ namespace test:incorrectcpp17
+ {
+ 	111111111111111111;
+ }
+ namespace test:::incorrectcpp17
+ {
+ 	111111111111111111;
+ }
  namespace{
  111111111111111111;
  }
*** ../vim-8.0.0091/src/version.c	2016-11-17 19:44:56.627678988 +0100
--- src/version.c	2016-11-17 21:18:59.916949760 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     92,
  /**/

-- 
Due knot trussed yore spell chequer two fined awl miss steaks.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0093
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0093
Problem:    Not using multiprocess build feature.
Solution:   Enable multiprocess build with MSVC 10. (Ken Takata)
Files:      src/Make_mvc.mak


*** ../vim-8.0.0092/src/Make_mvc.mak	2016-10-12 14:19:55.738357808 +0200
--- src/Make_mvc.mak	2016-11-19 17:14:13.715603450 +0100
***************
*** 297,302 ****
--- 297,305 ----
  # Flag to turn on Win64 compatibility warnings for VC7.x and VC8.
  WP64CHECK = /Wp64
  
+ # Use multiprocess build
+ USE_MP = yes
+ 
  #>>>>> path of the compiler and linker; name of include and lib directories
  # PATH = c:\msvc20\bin;$(PATH)
  # INCLUDE = c:\msvc20\include
***************
*** 473,478 ****
--- 476,489 ----
  NODEFAULTLIB = /nodefaultlib
  !endif
  
+ # Use multiprocess build on MSVC 10
+ !if "$(USE_MP)"=="yes"
+ !if $(MSVC_MAJOR) >= 10
+ CFLAGS = $(CFLAGS) /MP
+ !endif
+ !endif
+ 
+ 
  !ifdef NODEBUG
  VIM = vim
  !if "$(OPTIMIZE)" == "SPACE"
*** ../vim-8.0.0092/src/version.c	2016-11-17 21:30:17.144445729 +0100
--- src/version.c	2016-11-19 17:15:10.123226082 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     93,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
38. You wake up at 3 a.m. to go to the bathroom and stop and check your e-mail
    on the way back to bed.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0094
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0094
Problem:    When vimrun.exe is not found the error message is not properly
            encoded.
Solution:   Use utf-16 and MessageBoxW(). (Ken Takata)
Files:      src/os_win32.c
    

*** ../vim-8.0.0093/src/os_win32.c	2016-11-17 17:25:28.212093109 +0100
--- src/os_win32.c	2016-11-19 17:28:31.537877020 +0100
***************
*** 4705,4716 ****
  #if defined(FEAT_GUI_W32)
  		if (need_vimrun_warning)
  		{
! 		    MessageBox(NULL,
! 			    _("VIMRUN.EXE not found in your $PATH.\n"
! 				"External commands will not pause after completion.\n"
! 				"See  :help win32-vimrun  for more information."),
! 			    _("Vim Warning"),
! 			    MB_ICONWARNING);
  		    need_vimrun_warning = FALSE;
  		}
  		if (!s_dont_use_vimrun && p_stmp)
--- 4705,4728 ----
  #if defined(FEAT_GUI_W32)
  		if (need_vimrun_warning)
  		{
! 		    char *msg = _("VIMRUN.EXE not found in your $PATH.\n"
! 			"External commands will not pause after completion.\n"
! 			"See  :help win32-vimrun  for more information.");
! 		    char *title = _("Vim Warning");
! # ifdef FEAT_MBYTE
! 		    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
! 		    {
! 			WCHAR *wmsg = enc_to_utf16((char_u *)msg, NULL);
! 			WCHAR *wtitle = enc_to_utf16((char_u *)title, NULL);
! 
! 			if (wmsg != NULL && wtitle != NULL)
! 			    MessageBoxW(NULL, wmsg, wtitle, MB_ICONWARNING);
! 			vim_free(wmsg);
! 			vim_free(wtitle);
! 		    }
! 		    else
! # endif
! 			MessageBox(NULL, msg, title, MB_ICONWARNING);
  		    need_vimrun_warning = FALSE;
  		}
  		if (!s_dont_use_vimrun && p_stmp)
*** ../vim-8.0.0093/src/version.c	2016-11-19 17:17:09.442428237 +0100
--- src/version.c	2016-11-19 17:26:21.074746311 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     94,
  /**/

-- 
Everyone has a photographic memory. Some don't have film.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0095
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0095
Problem:    Problems with GTK 3.22.2 fixed in 3.22.4.
Solution:   Adjust the #ifdefs. (Kazunobu Kuriyama)
Files:      src/gui_gtk_x11.c


*** ../vim-8.0.0094/src/gui_gtk_x11.c	2016-11-17 19:11:51.713378271 +0100
--- src/gui_gtk_x11.c	2016-11-21 20:53:44.123726068 +0100
***************
*** 3102,3108 ****
      g_return_val_if_fail(event
  	    && event->width >= 1 && event->height >= 1, TRUE);
  
! # if GTK_CHECK_VERSION(3,22,2)
      /* As of 3.22.2, GdkWindows have started distributing configure events to
       * their "native" children (https://git.gnome.org/browse/gtk+/commit/?h=gtk-3-22&id=12579fe71b3b8f79eb9c1b80e429443bcc437dd0).
       *
--- 3102,3108 ----
      g_return_val_if_fail(event
  	    && event->width >= 1 && event->height >= 1, TRUE);
  
! # if GTK_CHECK_VERSION(3,22,2) && !GTK_CHECK_VERSION(3,22,4)
      /* As of 3.22.2, GdkWindows have started distributing configure events to
       * their "native" children (https://git.gnome.org/browse/gtk+/commit/?h=gtk-3-22&id=12579fe71b3b8f79eb9c1b80e429443bcc437dd0).
       *
***************
*** 3123,3128 ****
--- 3123,3132 ----
       * implementation details.  Therefore, watch out any relevant internal
       * changes happening in GTK in the feature (sigh).
       */
+     /* Follow-up
+      * After a few weeks later, the GdkWindow change mentioned above was
+      * reverted (https://git.gnome.org/browse/gtk+/commit/?h=gtk-3-22&id=f70039cb9603a02d2369fec4038abf40a1711155).
+      * The corresponding official release is 3.22.4. */
      if (event->send_event == FALSE)
  	return TRUE;
  # endif
***************
*** 4492,4498 ****
  {
      int usable_height = event->height;
  
! #if GTK_CHECK_VERSION(3,22,2)
      /* As of 3.22.2, GdkWindows have started distributing configure events to
       * their "native" children (https://git.gnome.org/browse/gtk+/commit/?h=gtk-3-22&id=12579fe71b3b8f79eb9c1b80e429443bcc437dd0).
       *
--- 4496,4502 ----
  {
      int usable_height = event->height;
  
! #if GTK_CHECK_VERSION(3,22,2) && !GTK_CHECK_VERSION(3,22,4)
      /* As of 3.22.2, GdkWindows have started distributing configure events to
       * their "native" children (https://git.gnome.org/browse/gtk+/commit/?h=gtk-3-22&id=12579fe71b3b8f79eb9c1b80e429443bcc437dd0).
       *
***************
*** 4508,4513 ****
--- 4512,4521 ----
       * To filter out such fallacious events, check if the given event is the
       * one that was sent out to the right place. Ignore it if not.
       */
+     /* Follow-up
+      * After a few weeks later, the GdkWindow change mentioned above was
+      * reverted (https://git.gnome.org/browse/gtk+/commit/?h=gtk-3-22&id=f70039cb9603a02d2369fec4038abf40a1711155).
+      * The corresponding official release is 3.22.4. */
      if (event->window != gtk_widget_get_window(gui.formwin))
  	return TRUE;
  #endif
*** ../vim-8.0.0094/src/version.c	2016-11-19 17:28:41.577810144 +0100
--- src/version.c	2016-11-21 20:54:36.527350483 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     95,
  /**/

-- 
Those who live by the sword get shot by those who don't.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0096
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0096
Problem:    When the input or output is not a tty Vim appears to hang.
Solution:   Add the --ttyfail argument.  Also add the "ttyin" and "ttyout"
            features to be able to check in Vim script.
Files:      src/globals.h, src/structs.h, src/main.c, src/evalfunc.c,
            runtime/doc/starting.txt, runtime/doc/eval.txt


*** ../vim-8.0.0095/src/globals.h	2016-11-10 20:01:41.181582995 +0100
--- src/globals.h	2016-11-24 14:47:12.106114198 +0100
***************
*** 643,648 ****
--- 643,650 ----
  EXTERN int	really_exiting INIT(= FALSE);
  				/* TRUE when we are sure to exit, e.g., after
  				 * a deadly signal */
+ EXTERN int	stdout_isatty INIT(= TRUE);	/* is stdout a terminal? */
+ 
  #if defined(FEAT_AUTOCHDIR)
  EXTERN int	test_autochdir INIT(= FALSE);
  #endif
*** ../vim-8.0.0095/src/structs.h	2016-11-17 17:25:28.212093109 +0100
--- src/structs.h	2016-11-24 14:47:01.506180720 +0100
***************
*** 3225,3232 ****
  #endif
  
      int		want_full_screen;
-     int		stdout_isatty;		/* is stdout a terminal? */
      int		not_a_term;		/* no warning for missing term? */
      char_u	*term;			/* specified terminal name */
  #ifdef FEAT_CRYPT
      int		ask_for_key;		/* -x argument */
--- 3225,3232 ----
  #endif
  
      int		want_full_screen;
      int		not_a_term;		/* no warning for missing term? */
+     int		tty_fail;		/* exit if not a tty */
      char_u	*term;			/* specified terminal name */
  #ifdef FEAT_CRYPT
      int		ask_for_key;		/* -x argument */
*** ../vim-8.0.0095/src/main.c	2016-08-29 22:42:20.000000000 +0200
--- src/main.c	2016-11-24 14:46:47.594268023 +0100
***************
*** 973,979 ****
       * (needed for :! to * work). mch_check_win() will also handle the -d or
       * -dev argument.
       */
!     paramp->stdout_isatty = (mch_check_win(paramp->argc, paramp->argv) != FAIL);
      TIME_MSG("window checked");
  
      /*
--- 973,979 ----
       * (needed for :! to * work). mch_check_win() will also handle the -d or
       * -dev argument.
       */
!     stdout_isatty = (mch_check_win(paramp->argc, paramp->argv) != FAIL);
      TIME_MSG("window checked");
  
      /*
***************
*** 1828,1833 ****
--- 1828,1834 ----
  				/* "--literal" take files literally */
  				/* "--nofork" don't fork */
  				/* "--not-a-term" don't warn for not a term */
+ 				/* "--ttyfail" exit if not a term */
  				/* "--noplugin[s]" skip plugins */
  				/* "--cmd <cmd>" execute cmd before vimrc */
  		if (STRICMP(argv[0] + argv_idx, "help") == 0)
***************
*** 1857,1862 ****
--- 1858,1865 ----
  		    p_lpl = FALSE;
  		else if (STRNICMP(argv[0] + argv_idx, "not-a-term", 10) == 0)
  		    parmp->not_a_term = TRUE;
+ 		else if (STRNICMP(argv[0] + argv_idx, "ttyfail", 7) == 0)
+ 		    parmp->tty_fail = TRUE;
  		else if (STRNICMP(argv[0] + argv_idx, "cmd", 3) == 0)
  		{
  		    want_argument = TRUE;
***************
*** 2489,2495 ****
  	if (!input_isatty)
  	    silent_mode = TRUE;
      }
!     else if (parmp->want_full_screen && (!parmp->stdout_isatty || !input_isatty)
  #ifdef FEAT_GUI
  	    /* don't want the delay when started from the desktop */
  	    && !gui.starting
--- 2492,2498 ----
  	if (!input_isatty)
  	    silent_mode = TRUE;
      }
!     else if (parmp->want_full_screen && (!stdout_isatty || !input_isatty)
  #ifdef FEAT_GUI
  	    /* don't want the delay when started from the desktop */
  	    && !gui.starting
***************
*** 2504,2510 ****
  	 * input buffer so fast I can't even kill the process in under 2
  	 * minutes (and it beeps continuously the whole time :-)
  	 */
! 	if (netbeans_active() && (!parmp->stdout_isatty || !input_isatty))
  	{
  	    mch_errmsg(_("Vim: Error: Failure to start gvim from NetBeans\n"));
  	    exit(1);
--- 2507,2513 ----
  	 * input buffer so fast I can't even kill the process in under 2
  	 * minutes (and it beeps continuously the whole time :-)
  	 */
! 	if (netbeans_active() && (!stdout_isatty || !input_isatty))
  	{
  	    mch_errmsg(_("Vim: Error: Failure to start gvim from NetBeans\n"));
  	    exit(1);
***************
*** 2517,2527 ****
  	    exit(1);
  	}
  #endif
! 	if (!parmp->stdout_isatty)
  	    mch_errmsg(_("Vim: Warning: Output is not to a terminal\n"));
  	if (!input_isatty)
  	    mch_errmsg(_("Vim: Warning: Input is not from a terminal\n"));
  	out_flush();
  	if (scriptin[0] == NULL)
  	    ui_delay(2000L, TRUE);
  	TIME_MSG("Warning delay");
--- 2520,2532 ----
  	    exit(1);
  	}
  #endif
! 	if (!stdout_isatty)
  	    mch_errmsg(_("Vim: Warning: Output is not to a terminal\n"));
  	if (!input_isatty)
  	    mch_errmsg(_("Vim: Warning: Input is not from a terminal\n"));
  	out_flush();
+ 	if (parmp->tty_fail && (!stdout_isatty || !input_isatty))
+ 	    exit(1);
  	if (scriptin[0] == NULL)
  	    ui_delay(2000L, TRUE);
  	TIME_MSG("Warning delay");
***************
*** 3287,3292 ****
--- 3292,3298 ----
  #endif
      main_msg(_("-T <terminal>\tSet terminal type to <terminal>"));
      main_msg(_("--not-a-term\t\tSkip warning for input/output not being a terminal"));
+     main_msg(_("--ttyfail\t\tExit if input or output is not a terminal"));
      main_msg(_("-u <vimrc>\t\tUse <vimrc> instead of any .vimrc"));
  #ifdef FEAT_GUI
      main_msg(_("-U <gvimrc>\t\tUse <gvimrc> instead of any .gvimrc"));
*** ../vim-8.0.0095/src/evalfunc.c	2016-11-10 20:01:41.189582944 +0100
--- src/evalfunc.c	2016-11-24 14:47:35.001970494 +0100
***************
*** 5959,5964 ****
--- 5959,5968 ----
  	}
  	else if (STRICMP(name, "vim_starting") == 0)
  	    n = (starting != 0);
+ 	else if (STRICMP(name, "ttyin") == 0)
+ 	    n = mch_input_isatty();
+ 	else if (STRICMP(name, "ttyout") == 0)
+ 	    n = stdout_isatty;
  #ifdef FEAT_MBYTE
  	else if (STRICMP(name, "multi_byte_encoding") == 0)
  	    n = has_mbyte;
*** ../vim-8.0.0095/runtime/doc/starting.txt	2016-09-12 12:45:48.000000000 +0200
--- runtime/doc/starting.txt	2016-11-24 14:39:52.460879969 +0100
***************
*** 421,426 ****
--- 421,430 ----
  		not connected to a terminal.  This will avoid the warning and
  		the two second delay that would happen. {not in Vi}
  
+ 							*--ttyfail*
+ --ttyfail	When the stdin or stdout is not a terminal (tty) then exit
+ 		right away.
+ 
  							*-d*
  -d		Start in diff mode, like |vimdiff|.
  		{not in Vi} {not available when compiled without the |+diff|
*** ../vim-8.0.0095/runtime/doc/eval.txt	2016-10-15 15:39:34.693059595 +0200
--- runtime/doc/eval.txt	2016-11-24 14:53:43.191657088 +0100
***************
*** 8405,8410 ****
--- 8416,8423 ----
  timers			Compiled with |timer_start()| support.
  title			Compiled with window title support |'title'|.
  toolbar			Compiled with support for |gui-toolbar|.
+ ttyin			input is a terminal (tty)
+ ttyout			output is a terminal (tty)
  unix			Unix version of Vim.
  user_commands		User-defined commands.
  vertsplit		Compiled with vertically split windows |:vsplit|.
*** ../vim-8.0.0095/src/version.c	2016-11-21 20:55:54.458792774 +0100
--- src/version.c	2016-11-24 14:40:18.220710851 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     96,
  /**/

-- 
George:  "I just got a new set of golf clubs for my wife!"
  John:  "Great trade!"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0097
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0097
Problem:    When a channel callback consumes a lot of time Vim becomes
            unresponsive. (skywind)
Solution:   Bail out of checking channel readahead after 100 msec.
Files:      src/os_unix.c, src/misc2.c, src/vim.h, src/os_win32.c


*** ../vim-8.0.0096/src/os_unix.c	2016-11-17 17:25:28.212093109 +0100
--- src/os_unix.c	2016-11-24 17:10:57.847711807 +0100
***************
*** 376,396 ****
  	RealWaitForChar(read_cmd_fd, p_wd, NULL, NULL);
  }
  
- #if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
- /*
-  * Return time in msec since "start_tv".
-  */
-     static long
- elapsed(struct timeval *start_tv)
- {
-     struct timeval  now_tv;
- 
-     gettimeofday(&now_tv, NULL);
-     return (now_tv.tv_sec - start_tv->tv_sec) * 1000L
- 	 + (now_tv.tv_usec - start_tv->tv_usec) / 1000L;
- }
- #endif
- 
  /*
   * mch_inchar(): low level input function.
   * Get a characters from the keyboard.
--- 376,381 ----
***************
*** 411,420 ****
      int		did_start_blocking = FALSE;
      long	wait_time;
      long	elapsed_time = 0;
! #if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
!     struct timeval  start_tv;
  
!     gettimeofday(&start_tv, NULL);
  #endif
  
      /* repeat until we got a character or waited long enough */
--- 396,405 ----
      int		did_start_blocking = FALSE;
      long	wait_time;
      long	elapsed_time = 0;
! #ifdef ELAPSED_FUNC
!     ELAPSED_TYPE start_tv;
  
!     ELAPSED_INIT(start_tv);
  #endif
  
      /* repeat until we got a character or waited long enough */
***************
*** 438,445 ****
  	    else
  		/* going to block after p_ut */
  		wait_time = p_ut;
! #if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
! 	    elapsed_time = elapsed(&start_tv);
  #endif
  	    wait_time -= elapsed_time;
  	    if (wait_time < 0)
--- 423,430 ----
  	    else
  		/* going to block after p_ut */
  		wait_time = p_ut;
! #ifdef ELAPSED_FUNC
! 	    elapsed_time = ELAPSED_FUNC(start_tv);
  #endif
  	    wait_time -= elapsed_time;
  	    if (wait_time < 0)
***************
*** 1554,1571 ****
  
  #ifdef FEAT_X11
  
! # if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H) \
  	&& (defined(FEAT_XCLIPBOARD) || defined(FEAT_TITLE))
  
- static void xopen_message(struct timeval *start_tv);
- 
  /*
   * Give a message about the elapsed time for opening the X window.
   */
      static void
! xopen_message(struct timeval *start_tv)
  {
!     smsg((char_u *)_("Opening the X display took %ld msec"), elapsed(start_tv));
  }
  # endif
  #endif
--- 1539,1554 ----
  
  #ifdef FEAT_X11
  
! # if defined(ELAPSED_TIMEVAL) \
  	&& (defined(FEAT_XCLIPBOARD) || defined(FEAT_TITLE))
  
  /*
   * Give a message about the elapsed time for opening the X window.
   */
      static void
! xopen_message(long elapsed_msec)
  {
!     smsg((char_u *)_("Opening the X display took %ld msec"), elapsed_msec);
  }
  # endif
  #endif
***************
*** 1864,1874 ****
  #endif
  	if (x11_display != NULL)
  	{
! # if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
  	    if (p_verbose > 0)
  	    {
  		verbose_enter();
! 		xopen_message(&start_tv);
  		verbose_leave();
  	    }
  # endif
--- 1847,1857 ----
  #endif
  	if (x11_display != NULL)
  	{
! # ifdef ELAPSED_FUNC
  	    if (p_verbose > 0)
  	    {
  		verbose_enter();
! 		xopen_message(ELAPSED_FUNC(start_tv));
  		verbose_leave();
  	    }
  # endif
***************
*** 4630,4637 ****
  		    ga_init2(&ga, 1, BUFLEN);
  
  		noread_cnt = 0;
! # if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
! 		gettimeofday(&start_tv, NULL);
  # endif
  		for (;;)
  		{
--- 4613,4620 ----
  		    ga_init2(&ga, 1, BUFLEN);
  
  		noread_cnt = 0;
! # ifdef ELAPSED_FUNC
! 		ELAPSED_INIT(start_tv);
  # endif
  		for (;;)
  		{
***************
*** 4666,4673 ****
  			  /* Get extra characters when we don't have any.
  			   * Reset the counter and timer. */
  			  noread_cnt = 0;
! # if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
! 			  gettimeofday(&start_tv, NULL);
  # endif
  			  len = ui_inchar(ta_buf, BUFLEN, 10L, 0);
  		      }
--- 4649,4656 ----
  			  /* Get extra characters when we don't have any.
  			   * Reset the counter and timer. */
  			  noread_cnt = 0;
! # ifdef ELAPSED_FUNC
! 			  ELAPSED_INIT(start_tv);
  # endif
  			  len = ui_inchar(ta_buf, BUFLEN, 10L, 0);
  		      }
***************
*** 4886,4895 ****
  			if (got_int)
  			    break;
  
! # if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
  			if (wait_pid == 0)
  			{
! 			    long	    msec = elapsed(&start_tv);
  
  			    /* Avoid that we keep looping here without
  			     * checking for a CTRL-C for a long time.  Don't
--- 4869,4878 ----
  			if (got_int)
  			    break;
  
! # ifdef ELAPSED_FUNC
  			if (wait_pid == 0)
  			{
! 			    long	msec = ELAPSED_FUNC(start_tv);
  
  			    /* Avoid that we keep looping here without
  			     * checking for a CTRL-C for a long time.  Don't
***************
*** 5632,5646 ****
      /* May retry getting characters after an event was handled. */
  # define MAY_LOOP
  
! # if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
      /* Remember at what time we started, so that we know how much longer we
       * should wait after being interrupted. */
- #  define USE_START_TV
      long	    start_msec = msec;
!     struct timeval  start_tv;
  
      if (msec > 0)
! 	gettimeofday(&start_tv, NULL);
  # endif
  
      /* Handle being called recursively.  This may happen for the session
--- 5615,5628 ----
      /* May retry getting characters after an event was handled. */
  # define MAY_LOOP
  
! # ifdef ELAPSED_FUNC
      /* Remember at what time we started, so that we know how much longer we
       * should wait after being interrupted. */
      long	    start_msec = msec;
!     ELAPSED_TYPE  start_tv;
  
      if (msec > 0)
! 	ELAPSED_INIT(start_tv);
  # endif
  
      /* Handle being called recursively.  This may happen for the session
***************
*** 5947,5955 ****
  	/* We're going to loop around again, find out for how long */
  	if (msec > 0)
  	{
! # ifdef USE_START_TV
  	    /* Compute remaining wait time. */
! 	    msec = start_msec - elapsed(&start_tv);
  # else
  	    /* Guess we got interrupted halfway. */
  	    msec = msec / 2;
--- 5929,5937 ----
  	/* We're going to loop around again, find out for how long */
  	if (msec > 0)
  	{
! # ifdef ELAPSED_FUNC
  	    /* Compute remaining wait time. */
! 	    msec = start_msec - ELAPSED_FUNC(start_tv);
  # else
  	    /* Guess we got interrupted halfway. */
  	    msec = msec / 2;
***************
*** 7046,7056 ****
  #if defined(HAVE_SETJMP_H)
  	int (*oldIOhandler)();
  #endif
! # if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
! 	struct timeval  start_tv;
  
  	if (p_verbose > 0)
! 	    gettimeofday(&start_tv, NULL);
  # endif
  
  	/* Ignore X errors while opening the display */
--- 7028,7038 ----
  #if defined(HAVE_SETJMP_H)
  	int (*oldIOhandler)();
  #endif
! # ifdef ELAPSED_FUNC
! 	ELAPSED_TYPE  start_tv;
  
  	if (p_verbose > 0)
! 	    ELAPSED_INIT(start_tv);
  # endif
  
  	/* Ignore X errors while opening the display */
***************
*** 7092,7102 ****
  	/* Catch terminating error of the X server connection. */
  	(void)XSetIOErrorHandler(x_IOerror_handler);
  
! # if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
  	if (p_verbose > 0)
  	{
  	    verbose_enter();
! 	    xopen_message(&start_tv);
  	    verbose_leave();
  	}
  # endif
--- 7074,7084 ----
  	/* Catch terminating error of the X server connection. */
  	(void)XSetIOErrorHandler(x_IOerror_handler);
  
! # ifdef ELAPSED_FUNC
  	if (p_verbose > 0)
  	{
  	    verbose_enter();
! 	    xopen_message(ELAPSED_FUNC(start_tv));
  	    verbose_leave();
  	}
  # endif
*** ../vim-8.0.0096/src/misc2.c	2016-11-10 20:01:41.193582919 +0100
--- src/misc2.c	2016-11-24 16:57:53.768987660 +0100
***************
*** 6263,6265 ****
--- 6263,6296 ----
  # endif
  }
  #endif
+ 
+ #ifdef ELAPSED_TIMEVAL  /* proto is defined in vim.h */
+ /*
+  * Return time in msec since "start_tv".
+  */
+     long
+ elapsed(struct timeval *start_tv)
+ {
+     struct timeval  now_tv;
+ 
+     gettimeofday(&now_tv, NULL);
+     return (now_tv.tv_sec - start_tv->tv_sec) * 1000L
+ 	 + (now_tv.tv_usec - start_tv->tv_usec) / 1000L;
+ }
+ #endif
+ 
+ #ifdef ELAPSED_TICKCOUNT
+ /*
+  * Return time in msec since "start_tick".
+  */
+     long
+ elapsed(DWORD start_tick)
+ {
+     DWORD	now = GetTickCount();
+ 
+     if (now < start_tick)
+ 	/* overflow */
+ 	return (long)now;
+     return (long)now - (long)start_tick;
+ }
+ #endif
*** ../vim-8.0.0096/src/vim.h	2016-11-10 20:01:41.201582868 +0100
--- src/vim.h	2016-11-24 16:58:55.288576323 +0100
***************
*** 2503,2506 ****
--- 2503,2522 ----
  # define OPEN_CHR_FILES
  #endif
  
+ #if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+ # define ELAPSED_TIMEVAL
+ # define ELAPSED_INIT(v) gettimeofday(&v, NULL)
+ # define ELAPSED_FUNC(v) elapsed(&v)
+ # define ELAPSED_TYPE struct timeval
+     long elapsed(struct timeval *start_tv);
+ #else
+ # if defined(WIN32)
+ #  define ELAPSED_TICKCOUNT
+ #  define ELAPSED_INIT(v) v = GetTickCount
+ #  define ELAPSED_FUNC(v) elapsed(v)
+ #  define ELAPSED_TYPE DWORD
+     long elapsed(DWORD start_tick);
+ # endif
+ #endif
+ 
  #endif /* VIM__H */
*** ../vim-8.0.0096/src/os_win32.c	2016-11-19 17:28:41.577810144 +0100
--- src/os_win32.c	2016-11-24 16:46:08.177711935 +0100
***************
*** 4287,4295 ****
  		    /* Get extra characters when we don't have any.  Reset the
  		     * counter and timer. */
  		    noread_cnt = 0;
- # if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
- 		    gettimeofday(&start_tv, NULL);
- # endif
  		    len = ui_inchar(ta_buf, BUFLEN, 10L, 0);
  		}
  		if (ta_len > 0 || len > 0)
--- 4287,4292 ----
*** ../vim-8.0.0096/src/channel.c	2016-11-17 17:25:28.208093136 +0100
--- src/channel.c	2016-11-24 17:04:11.666462247 +0100
***************
*** 3815,3820 ****
--- 3815,3825 ----
      int		ret = FALSE;
      int		r;
      ch_part_T	part = PART_SOCK;
+ #ifdef ELAPSED_FUNC
+     ELAPSED_TYPE  start_tv;
+ 
+     ELAPSED_INIT(start_tv);
+ #endif
  
      ++safe_to_invoke_callback;
  
***************
*** 3859,3865 ****
  	    r = may_invoke_callback(channel, part);
  	    if (r == OK)
  		ret = TRUE;
! 	    if (channel_unref(channel) || r == OK)
  	    {
  		/* channel was freed or something was done, start over */
  		channel = first_channel;
--- 3864,3877 ----
  	    r = may_invoke_callback(channel, part);
  	    if (r == OK)
  		ret = TRUE;
! 	    if (channel_unref(channel) || (r == OK
! #ifdef ELAPSED_FUNC
! 			/* Limit the time we loop here to 100 msec, otherwise
! 			 * Vim becomes unresponsive when the callback takes
! 			 * more than a bit of time. */
! 			&& ELAPSED_FUNC(start_tv) < 100L
! #endif
! 			))
  	    {
  		/* channel was freed or something was done, start over */
  		channel = first_channel;
*** ../vim-8.0.0096/src/version.c	2016-11-24 15:09:03.413856612 +0100
--- src/version.c	2016-11-24 17:16:25.453392518 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     97,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
39. You move into a new house and decide to Netscape before you landscape.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0098
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0098 (after 8.0.0097)
Problem:    Can't build on MS-Windows.
Solution:   Add missing parenthesis.
Files:      src/vim.h


*** ../vim-8.0.0097/src/vim.h	2016-11-24 17:22:46.150837087 +0100
--- src/vim.h	2016-11-24 17:31:56.371175210 +0100
***************
*** 2512,2518 ****
  #else
  # if defined(WIN32)
  #  define ELAPSED_TICKCOUNT
! #  define ELAPSED_INIT(v) v = GetTickCount
  #  define ELAPSED_FUNC(v) elapsed(v)
  #  define ELAPSED_TYPE DWORD
      long elapsed(DWORD start_tick);
--- 2512,2518 ----
  #else
  # if defined(WIN32)
  #  define ELAPSED_TICKCOUNT
! #  define ELAPSED_INIT(v) v = GetTickCount()
  #  define ELAPSED_FUNC(v) elapsed(v)
  #  define ELAPSED_TYPE DWORD
      long elapsed(DWORD start_tick);
*** ../vim-8.0.0097/src/version.c	2016-11-24 17:22:46.154837060 +0100
--- src/version.c	2016-11-24 17:32:38.990891710 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     98,
  /**/

-- 
"Oh, no!  NOT the Spanish Inquisition!"
"NOBODY expects the Spanish Inquisition!!!"
				-- Monty Python sketch --
"Oh, no!  NOT another option!"
"EVERYBODY expects another option!!!"
				-- Discussion in vim-dev mailing list --

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0099
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0099
Problem:    Popup menu always appears above the cursor when it is in the lower
            half of the screen. (Matt Gardner)
Solution:   Compute the available space better. (Hirohito Higashi,
            closes #1241)
Files:      src/popupmnu.c


*** ../vim-8.0.0098/src/popupmnu.c	2016-11-04 22:08:26.014082864 +0100
--- src/popupmnu.c	2016-11-24 17:37:44.964839700 +0100
***************
*** 105,111 ****
  
      /* Put the pum below "row" if possible.  If there are few lines decide on
       * where there is more room. */
!     if (row - above_row >= below_row - row)
      {
  	/* pum above "row" */
  
--- 105,112 ----
  
      /* Put the pum below "row" if possible.  If there are few lines decide on
       * where there is more room. */
!     if (row + 2 >= below_row - pum_height
! 			    && row - above_row > (below_row - above_row) / 2)
      {
  	/* pum above "row" */
  
*** ../vim-8.0.0098/src/version.c	2016-11-24 17:33:12.430669286 +0100
--- src/version.c	2016-11-24 17:38:35.820495843 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     99,
  /**/

-- 
Microsoft is to software what McDonalds is to gourmet cooking

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0100
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0100
Problem:    Options that are a file name may contain non-filename characters.
Solution:   Check for more invalid characters.
Files:      src/option.c


*** ../vim-8.0.0099/src/option.c	2016-11-10 20:01:41.197582893 +0100
--- src/option.c	2016-11-24 17:58:37.652276224 +0100
***************
*** 5880,5886 ****
       * separator (slash and/or backslash), wildcards and characters that are
       * often illegal in a file name. */
      else if ((options[opt_idx].flags & P_NFNAME)
! 			 && vim_strpbrk(*varp, (char_u *)"/\\*?[|<>") != NULL)
      {
  	errmsg = e_invarg;
      }
--- 5880,5886 ----
       * separator (slash and/or backslash), wildcards and characters that are
       * often illegal in a file name. */
      else if ((options[opt_idx].flags & P_NFNAME)
! 		    && vim_strpbrk(*varp, (char_u *)"/\\*?[|;&<>\r\n") != NULL)
      {
  	errmsg = e_invarg;
      }
*** ../vim-8.0.0099/src/version.c	2016-11-24 17:47:03.865021031 +0100
--- src/version.c	2016-11-24 17:59:26.683951638 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     100,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
40. You tell the cab driver you live at
    http://123.elm.street/house/bluetrim.html
41. You actually try that 123.elm.street address.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0101
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0101
Problem:    Some options are not strictly checked.
Solution:   Add flags for strickter checks.
Files:      src/option.c


*** ../vim-8.0.0100/src/option.c	2016-11-24 18:30:55.715444785 +0100
--- src/option.c	2016-11-24 21:38:32.823206218 +0100
***************
*** 992,998 ****
  			    (char_u *)NULL, PV_NONE,
  #endif
  			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
!     {"dictionary",  "dict", P_STRING|P_EXPAND|P_VI_DEF|P_ONECOMMA|P_NODUP,
  #ifdef FEAT_INS_EXPAND
  			    (char_u *)&p_dict, PV_DICT,
  #else
--- 992,998 ----
  			    (char_u *)NULL, PV_NONE,
  #endif
  			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
!     {"dictionary",  "dict", P_STRING|P_EXPAND|P_VI_DEF|P_ONECOMMA|P_NODUP|P_NFNAME,
  #ifdef FEAT_INS_EXPAND
  			    (char_u *)&p_dict, PV_DICT,
  #else
***************
*** 2058,2064 ****
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
  			    SCRIPTID_INIT},
!     {"printexpr", "pexpr",  P_STRING|P_VI_DEF,
  #ifdef FEAT_POSTSCRIPT
  			    (char_u *)&p_pexpr, PV_NONE,
  			    {(char_u *)"", (char_u *)0L}
--- 2058,2064 ----
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
  			    SCRIPTID_INIT},
!     {"printexpr", "pexpr",  P_STRING|P_VI_DEF|P_SECURE,
  #ifdef FEAT_POSTSCRIPT
  			    (char_u *)&p_pexpr, PV_NONE,
  			    {(char_u *)"", (char_u *)0L}
***************
*** 7021,7026 ****
--- 7021,7027 ----
  
  
  #if defined(FEAT_TOOLBAR) && !defined(FEAT_GUI_W32)
+     /* 'toolbar' */
      else if (varp == &p_toolbar)
      {
  	if (opt_strings_flags(p_toolbar, p_toolbar_values,
***************
*** 7235,7240 ****
--- 7236,7242 ----
  #endif
  
  #if defined(FEAT_RENDER_OPTIONS)
+     /* 'renderoptions' */
      else if (varp == &p_rop && gui.in_use)
      {
  	if (!gui_mch_set_rendering_options(p_rop))
***************
*** 7262,7280 ****
      else
      {
  	p = NULL;
! 	if (varp == &p_ww)
  	    p = (char_u *)WW_ALL;
! 	if (varp == &p_shm)
  	    p = (char_u *)SHM_ALL;
! 	else if (varp == &(p_cpo))
  	    p = (char_u *)CPO_ALL;
! 	else if (varp == &(curbuf->b_p_fo))
  	    p = (char_u *)FO_ALL;
  #ifdef FEAT_CONCEAL
! 	else if (varp == &curwin->w_p_cocu)
  	    p = (char_u *)COCU_ALL;
  #endif
! 	else if (varp == &p_mouse)
  	{
  #ifdef FEAT_MOUSE
  	    p = (char_u *)MOUSE_ALL;
--- 7264,7282 ----
      else
      {
  	p = NULL;
! 	if (varp == &p_ww) /* 'whichwrap' */
  	    p = (char_u *)WW_ALL;
! 	if (varp == &p_shm) /* 'shortmess' */
  	    p = (char_u *)SHM_ALL;
! 	else if (varp == &(p_cpo)) /* 'cpoptions' */
  	    p = (char_u *)CPO_ALL;
! 	else if (varp == &(curbuf->b_p_fo)) /* 'formatoptions' */
  	    p = (char_u *)FO_ALL;
  #ifdef FEAT_CONCEAL
! 	else if (varp == &curwin->w_p_cocu) /* 'concealcursor' */
  	    p = (char_u *)COCU_ALL;
  #endif
! 	else if (varp == &p_mouse) /* 'mouse' */
  	{
  #ifdef FEAT_MOUSE
  	    p = (char_u *)MOUSE_ALL;
***************
*** 7284,7290 ****
  #endif
  	}
  #if defined(FEAT_GUI)
! 	else if (varp == &p_go)
  	    p = (char_u *)GO_ALL;
  #endif
  	if (p != NULL)
--- 7286,7292 ----
  #endif
  	}
  #if defined(FEAT_GUI)
! 	else if (varp == &p_go) /* 'guioptions' */
  	    p = (char_u *)GO_ALL;
  #endif
  	if (p != NULL)
*** ../vim-8.0.0100/src/version.c	2016-11-24 18:30:55.715444785 +0100
--- src/version.c	2016-11-24 19:54:59.141485534 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     101,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
42. Your virtual girlfriend finds a new net sweetheart with a larger bandwidth.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0102
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0102 (after 8.0.0101)
Problem:    Cannot set 'dictionary' to a path.
Solution:   Allow for slash and backslash.  Add a test (partly by Daisuke
            Suzuki, closes #1279, closes #1284)
Files:      src/option.c, src/testdir/test_options.vim


*** ../vim-8.0.0101/src/option.c	2016-11-24 21:46:15.747996856 +0100
--- src/option.c	2016-11-25 22:01:14.532613523 +0100
***************
*** 452,461 ****
  #define P_NFNAME       0x400000L /* only normal file name chars allowed */
  #define P_INSECURE     0x800000L /* option was set from a modeline */
  #define P_PRI_MKRC    0x1000000L /* priority for :mkvimrc (setting option has
! 				   side effects) */
  #define P_NO_ML       0x2000000L /* not allowed in modeline */
  #define P_CURSWANT    0x4000000L /* update curswant required; not needed when
  				  * there is a redraw flag */
  
  #define ISK_LATIN1  (char_u *)"@,48-57,_,192-255"
  
--- 452,462 ----
  #define P_NFNAME       0x400000L /* only normal file name chars allowed */
  #define P_INSECURE     0x800000L /* option was set from a modeline */
  #define P_PRI_MKRC    0x1000000L /* priority for :mkvimrc (setting option has
! 				    side effects) */
  #define P_NO_ML       0x2000000L /* not allowed in modeline */
  #define P_CURSWANT    0x4000000L /* update curswant required; not needed when
  				  * there is a redraw flag */
+ #define P_NDNAME      0x8000000L /* only normal dir name chars allowed */
  
  #define ISK_LATIN1  (char_u *)"@,48-57,_,192-255"
  
***************
*** 992,998 ****
  			    (char_u *)NULL, PV_NONE,
  #endif
  			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
!     {"dictionary",  "dict", P_STRING|P_EXPAND|P_VI_DEF|P_ONECOMMA|P_NODUP|P_NFNAME,
  #ifdef FEAT_INS_EXPAND
  			    (char_u *)&p_dict, PV_DICT,
  #else
--- 993,999 ----
  			    (char_u *)NULL, PV_NONE,
  #endif
  			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
!     {"dictionary",  "dict", P_STRING|P_EXPAND|P_VI_DEF|P_ONECOMMA|P_NODUP|P_NDNAME,
  #ifdef FEAT_INS_EXPAND
  			    (char_u *)&p_dict, PV_DICT,
  #else
***************
*** 5876,5886 ****
  	errmsg = e_secure;
      }
  
!     /* Check for a "normal" file name in some options.  Disallow a path
!      * separator (slash and/or backslash), wildcards and characters that are
!      * often illegal in a file name. */
!     else if ((options[opt_idx].flags & P_NFNAME)
  		    && vim_strpbrk(*varp, (char_u *)"/\\*?[|;&<>\r\n") != NULL)
      {
  	errmsg = e_invarg;
      }
--- 5877,5889 ----
  	errmsg = e_secure;
      }
  
!     /* Check for a "normal" directory or file name in some options.  Disallow a
!      * path separator (slash and/or backslash), wildcards and characters that
!      * are often illegal in a file name. */
!     else if (((options[opt_idx].flags & P_NFNAME)
  		    && vim_strpbrk(*varp, (char_u *)"/\\*?[|;&<>\r\n") != NULL)
+ 	  || ((options[opt_idx].flags & P_NDNAME)
+ 		    && vim_strpbrk(*varp, (char_u *)"*?[|;&<>\r\n") != NULL))
      {
  	errmsg = e_invarg;
      }
*** ../vim-8.0.0101/src/testdir/test_options.vim	2016-11-04 16:41:16.559153991 +0100
--- src/testdir/test_options.vim	2016-11-25 21:54:48.015372273 +0100
***************
*** 106,108 ****
--- 106,123 ----
    call assert_fails(":set kmp=trunc\x00name", "E544:")
    call assert_fails(":set kmp=trunc\x00name", "trunc")
  endfunc
+ 
+ func Test_dictionary()
+   " Check that it's possible to set the option.
+   set dictionary=/usr/share/dict/words
+   call assert_equal('/usr/share/dict/words', &dictionary)
+   set dictionary=/usr/share/dict/words,/and/there
+   call assert_equal('/usr/share/dict/words,/and/there', &dictionary)
+   set dictionary=/usr/share/dict\ words
+   call assert_equal('/usr/share/dict words', &dictionary)
+ 
+   " Check rejecting weird characters.
+   call assert_fails("set dictionary=/not&there", "E474:")
+   call assert_fails("set dictionary=/not>there", "E474:")
+   call assert_fails("set dictionary=/not.*there", "E474:")
+ endfunc
*** ../vim-8.0.0101/src/version.c	2016-11-24 21:46:15.747996856 +0100
--- src/version.c	2016-11-25 21:57:55.062002830 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     102,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
47. You are so familiar with the WWW that you find the search engines useless.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0103
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0103
Problem:    May not process channel readahead. (skywind)
Solution:   If there is readahead don't block on input.
Files:      src/channel.c, src/proto/channel.pro, src/os_unix.c,
            src/os_win32.c, src/misc2.c


*** ../vim-8.0.0102/src/channel.c	2016-11-24 17:22:46.154837060 +0100
--- src/channel.c	2016-11-26 15:03:44.386121667 +0100
***************
*** 3900,3905 ****
--- 3900,3930 ----
  }
  
  /*
+  * Return TRUE if any channel has readahead.  That means we should not block on
+  * waiting for input.
+  */
+     int
+ channel_any_readahead(void)
+ {
+     channel_T	*channel = first_channel;
+     ch_part_T	part = PART_SOCK;
+ 
+     while (channel != NULL)
+     {
+ 	if (channel_has_readahead(channel, part))
+ 	    return TRUE;
+ 	if (part < PART_ERR)
+ 	    ++part;
+ 	else
+ 	{
+ 	    channel = channel->ch_next;
+ 	    part = PART_SOCK;
+ 	}
+     }
+     return FALSE;
+ }
+ 
+ /*
   * Mark references to lists used in channels.
   */
      int
*** ../vim-8.0.0102/src/proto/channel.pro	2016-10-09 17:27:56.863388510 +0200
--- src/proto/channel.pro	2016-11-26 15:03:47.522100708 +0100
***************
*** 44,49 ****
--- 44,50 ----
  int channel_select_setup(int maxfd_in, void *rfds_in, void *wfds_in);
  int channel_select_check(int ret_in, void *rfds_in, void *wfds_in);
  int channel_parse_messages(void);
+ int channel_any_readahead(void);
  int set_ref_in_channel(int copyID);
  ch_part_T channel_part_send(channel_T *channel);
  ch_part_T channel_part_read(channel_T *channel);
*** ../vim-8.0.0102/src/os_unix.c	2016-11-24 17:22:46.146837112 +0100
--- src/os_unix.c	2016-11-26 15:06:11.005142143 +0100
***************
*** 462,467 ****
--- 462,471 ----
  	/* Checking if a job ended requires polling.  Do this every 100 msec. */
  	if (has_pending_job() && (wait_time < 0 || wait_time > 100L))
  	    wait_time = 100L;
+ 	/* If there is readahead then parse_queued_messages() timed out and we
+ 	 * should call it again soon. */
+ 	if ((wait_time < 0 || wait_time > 100L) && channel_any_readahead())
+ 	    wait_time = 10L;
  #endif
  
  	/*
*** ../vim-8.0.0102/src/os_win32.c	2016-11-24 17:22:46.150837087 +0100
--- src/os_win32.c	2016-11-26 15:09:12.055933715 +0100
***************
*** 1351,1359 ****
  	    DWORD dwWaitTime = dwEndTime - dwNow;
  
  #ifdef FEAT_JOB_CHANNEL
! 	    /* Check channel while waiting input. */
  	    if (dwWaitTime > 100)
  		dwWaitTime = 100;
  #endif
  #ifdef FEAT_MZSCHEME
  	    if (mzthreads_allowed() && p_mzq > 0
--- 1351,1365 ----
  	    DWORD dwWaitTime = dwEndTime - dwNow;
  
  #ifdef FEAT_JOB_CHANNEL
! 	    /* Check channel while waiting for input. */
  	    if (dwWaitTime > 100)
+ 	    {
  		dwWaitTime = 100;
+ 		/* If there is readahead then parse_queued_messages() timed out
+ 		 * and we should call it again soon. */
+ 		if (channel_any_readahead())
+ 		    dwWaitTime = 10;
+ 	    }
  #endif
  #ifdef FEAT_MZSCHEME
  	    if (mzthreads_allowed() && p_mzq > 0
*** ../vim-8.0.0102/src/misc2.c	2016-11-24 17:22:46.150837087 +0100
--- src/misc2.c	2016-11-26 14:52:17.202709633 +0100
***************
*** 6264,6270 ****
  }
  #endif
  
! #ifdef ELAPSED_TIMEVAL  /* proto is defined in vim.h */
  /*
   * Return time in msec since "start_tv".
   */
--- 6264,6270 ----
  }
  #endif
  
! #ifdef ELAPSED_TIMEVAL  /* no PROTO here, proto is defined in vim.h */
  /*
   * Return time in msec since "start_tv".
   */
***************
*** 6288,6296 ****
  {
      DWORD	now = GetTickCount();
  
-     if (now < start_tick)
- 	/* overflow */
- 	return (long)now;
      return (long)now - (long)start_tick;
  }
  #endif
--- 6288,6293 ----
*** ../vim-8.0.0102/src/version.c	2016-11-25 22:04:09.607397081 +0100
--- src/version.c	2016-11-26 15:02:23.754660704 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     103,
  /**/

-- 
CVS sux, men don't like commitment

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0104
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0104
Problem:    Value of 'thesaurus' option not checked properly.
Solution:   Add P_NDNAME flag. (Daisuke Suzuki)
Files:      src/option.c, src/testdir/test_options.vim


*** ../vim-8.0.0103/src/option.c	2016-11-25 22:04:09.607397081 +0100
--- src/option.c	2016-11-26 17:35:20.089224386 +0100
***************
*** 2660,2666 ****
      {"textwidth",   "tw",   P_NUM|P_VI_DEF|P_VIM|P_RBUF,
  			    (char_u *)&p_tw, PV_TW,
  			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
!     {"thesaurus",   "tsr",  P_STRING|P_EXPAND|P_VI_DEF|P_ONECOMMA|P_NODUP,
  #ifdef FEAT_INS_EXPAND
  			    (char_u *)&p_tsr, PV_TSR,
  #else
--- 2660,2666 ----
      {"textwidth",   "tw",   P_NUM|P_VI_DEF|P_VIM|P_RBUF,
  			    (char_u *)&p_tw, PV_TW,
  			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
!     {"thesaurus",   "tsr",  P_STRING|P_EXPAND|P_VI_DEF|P_ONECOMMA|P_NODUP|P_NDNAME,
  #ifdef FEAT_INS_EXPAND
  			    (char_u *)&p_tsr, PV_TSR,
  #else
*** ../vim-8.0.0103/src/testdir/test_options.vim	2016-11-25 22:04:09.607397081 +0100
--- src/testdir/test_options.vim	2016-11-26 17:41:00.722891085 +0100
***************
*** 107,123 ****
    call assert_fails(":set kmp=trunc\x00name", "trunc")
  endfunc
  
! func Test_dictionary()
    " Check that it's possible to set the option.
!   set dictionary=/usr/share/dict/words
!   call assert_equal('/usr/share/dict/words', &dictionary)
!   set dictionary=/usr/share/dict/words,/and/there
!   call assert_equal('/usr/share/dict/words,/and/there', &dictionary)
!   set dictionary=/usr/share/dict\ words
!   call assert_equal('/usr/share/dict words', &dictionary)
  
    " Check rejecting weird characters.
!   call assert_fails("set dictionary=/not&there", "E474:")
!   call assert_fails("set dictionary=/not>there", "E474:")
!   call assert_fails("set dictionary=/not.*there", "E474:")
  endfunc
--- 107,131 ----
    call assert_fails(":set kmp=trunc\x00name", "trunc")
  endfunc
  
! func Check_dir_option(name)
    " Check that it's possible to set the option.
!   exe 'set ' . a:name . '=/usr/share/dict/words'
!   call assert_equal('/usr/share/dict/words', eval('&' . a:name))
!   exe 'set ' . a:name . '=/usr/share/dict/words,/and/there'
!   call assert_equal('/usr/share/dict/words,/and/there', eval('&' . a:name))
!   exe 'set ' . a:name . '=/usr/share/dict\ words'
!   call assert_equal('/usr/share/dict words', eval('&' . a:name))
  
    " Check rejecting weird characters.
!   call assert_fails("set " . a:name . "=/not&there", "E474:")
!   call assert_fails("set " . a:name . "=/not>there", "E474:")
!   call assert_fails("set " . a:name . "=/not.*there", "E474:")
! endfunc
! 
! func Test_dictionary()
!   call Check_dir_option('dictionary')
! endfunc
! 
! func Test_thesaurus()
!   call Check_dir_option('thesaurus')
  endfunc
*** ../vim-8.0.0103/src/version.c	2016-11-26 15:13:29.410218034 +0100
--- src/version.c	2016-11-26 17:36:23.568793629 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     104,
  /**/

-- 
Never go to the toilet in a paperless office.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0105
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0105
Problem:    When using ch_read() with zero timeout, can't tell the difference
            between reading an empty line and nothing available.
Solution:   Add ch_canread().
Files:      src/evalfunc.c, src/channel.c, src/proto/channel.pro,
            src/testdir/test_channel.vim, src/testdir/shared.vim,
            runtime/doc/eval.txt, runtime/doc/channel.txt


*** ../vim-8.0.0104/src/evalfunc.c	2016-11-24 15:09:03.409856638 +0100
--- src/evalfunc.c	2016-11-29 20:23:04.633430178 +0100
***************
*** 76,81 ****
--- 76,82 ----
  static void f_ceil(typval_T *argvars, typval_T *rettv);
  #endif
  #ifdef FEAT_JOB_CHANNEL
+ static void f_ch_canread(typval_T *argvars, typval_T *rettv);
  static void f_ch_close(typval_T *argvars, typval_T *rettv);
  static void f_ch_close_in(typval_T *argvars, typval_T *rettv);
  static void f_ch_evalexpr(typval_T *argvars, typval_T *rettv);
***************
*** 499,504 ****
--- 500,506 ----
      {"ceil",		1, 1, f_ceil},
  #endif
  #ifdef FEAT_JOB_CHANNEL
+     {"ch_canread",	1, 1, f_ch_canread},
      {"ch_close",	1, 1, f_ch_close},
      {"ch_close_in",	1, 1, f_ch_close_in},
      {"ch_evalexpr",	2, 3, f_ch_evalexpr},
***************
*** 1779,1784 ****
--- 1781,1801 ----
  
  #ifdef FEAT_JOB_CHANNEL
  /*
+  * "ch_canread()" function
+  */
+     static void
+ f_ch_canread(typval_T *argvars, typval_T *rettv)
+ {
+     channel_T *channel = get_channel_arg(&argvars[0], TRUE, TRUE, 0);
+ 
+     rettv->vval.v_number = 0;
+     if (channel != NULL)
+ 	rettv->vval.v_number = channel_has_readahead(channel, PART_SOCK)
+ 			    || channel_has_readahead(channel, PART_OUT)
+ 			    || channel_has_readahead(channel, PART_ERR);
+ }
+ 
+ /*
   * "ch_close()" function
   */
      static void
*** ../vim-8.0.0104/src/channel.c	2016-11-26 15:13:29.402218088 +0100
--- src/channel.c	2016-11-29 20:13:58.177247346 +0100
***************
*** 2603,2609 ****
  /*
   * Return TRUE if "channel" has JSON or other typeahead.
   */
!     static int
  channel_has_readahead(channel_T *channel, ch_part_T part)
  {
      ch_mode_T	ch_mode = channel->ch_part[part].ch_mode;
--- 2603,2609 ----
  /*
   * Return TRUE if "channel" has JSON or other typeahead.
   */
!     int
  channel_has_readahead(channel_T *channel, ch_part_T part)
  {
      ch_mode_T	ch_mode = channel->ch_part[part].ch_mode;
*** ../vim-8.0.0104/src/proto/channel.pro	2016-11-26 15:13:29.402218088 +0100
--- src/proto/channel.pro	2016-11-29 20:14:03.549209705 +0100
***************
*** 25,30 ****
--- 25,31 ----
  int channel_collapse(channel_T *channel, ch_part_T part, int want_nl);
  int channel_can_write_to(channel_T *channel);
  int channel_is_open(channel_T *channel);
+ int channel_has_readahead(channel_T *channel, ch_part_T part);
  char *channel_status(channel_T *channel, int req_part);
  void channel_info(channel_T *channel, dict_T *dict);
  void channel_close(channel_T *channel, int invoke_close_cb);
*** ../vim-8.0.0104/src/testdir/test_channel.vim	2016-11-17 17:25:28.212093109 +0100
--- src/testdir/test_channel.vim	2016-11-29 21:52:55.853041485 +0100
***************
*** 58,63 ****
--- 58,66 ----
    " string with ][ should work
    call assert_equal('this][that', ch_evalexpr(handle, 'echo this][that'))
  
+   " nothing to read now
+   call assert_equal(0, ch_canread(handle))
+ 
    " sending three messages quickly then reading should work
    for i in range(3)
      call ch_sendexpr(handle, 'echo hello ' . i)
***************
*** 368,374 ****
    endif
    call ch_setoptions(handle, {'mode': 'raw'})
  
!   " The message are sent raw, we do our own JSON strings here.
    call ch_sendraw(handle, "[1, \"hello!\"]\n", {'callback': 'Ch_handleRaw1'})
    call WaitFor('g:Ch_reply1 != ""')
    call assert_equal("[1, \"got it\"]", g:Ch_reply1)
--- 371,377 ----
    endif
    call ch_setoptions(handle, {'mode': 'raw'})
  
!   " The messages are sent raw, we do our own JSON strings here.
    call ch_sendraw(handle, "[1, \"hello!\"]\n", {'callback': 'Ch_handleRaw1'})
    call WaitFor('g:Ch_reply1 != ""')
    call assert_equal("[1, \"got it\"]", g:Ch_reply1)
***************
*** 431,437 ****
      return
    endif
    call ch_log('Test_raw_pipe()')
!   let job = job_start(s:python . " test_channel_pipe.py", {'mode': 'raw'})
    call assert_equal(v:t_job, type(job))
    call assert_equal("run", job_status(job))
  
--- 434,443 ----
      return
    endif
    call ch_log('Test_raw_pipe()')
!   " Add a dummy close callback to avoid that messages are dropped when calling
!   " ch_canread().
!   let job = job_start(s:python . " test_channel_pipe.py",
! 	\ {'mode': 'raw', 'close_cb': {chan -> 0}})
    call assert_equal(v:t_job, type(job))
    call assert_equal("run", job_status(job))
  
***************
*** 458,463 ****
--- 464,472 ----
      call assert_equal("something\n", substitute(msg, "\r", "", 'g'))
  
      call ch_sendraw(job, "double this\n")
+     let g:handle = job_getchannel(job)
+     call WaitFor('ch_canread(g:handle)')
+     unlet g:handle
      let msg = ch_readraw(job)
      call assert_equal("this\nAND this\n", substitute(msg, "\r", "", 'g'))
  
*** ../vim-8.0.0104/src/testdir/shared.vim	2016-10-27 20:00:03.665357405 +0200
--- src/testdir/shared.vim	2016-11-29 20:25:10.408554811 +0100
***************
*** 88,94 ****
  
      call call(function(a:testfunc), [port])
    catch
!     call assert_false(1, "Caught exception: " . v:exception)
    finally
      call s:kill_server(a:cmd)
    endtry
--- 88,94 ----
  
      call call(function(a:testfunc), [port])
    catch
!     call assert_false(1, 'Caught exception: "' . v:exception . '" in ' . v:throwpoint)
    finally
      call s:kill_server(a:cmd)
    endtry
*** ../vim-8.0.0104/runtime/doc/eval.txt	2016-11-24 15:09:03.413856612 +0100
--- runtime/doc/eval.txt	2016-11-29 21:45:28.872201614 +0100
***************
*** 2008,2013 ****
--- 2009,2015 ----
  call({func}, {arglist} [, {dict}])
  				any	call {func} with arguments {arglist}
  ceil({expr})			Float	round {expr} up
+ ch_canread({handle})		Number	check if there is something to read
  ch_close({handle})		none	close {handle}
  ch_close_in({handle})		none	close in part of {handle}
  ch_evalexpr({handle}, {expr} [, {options}])
***************
*** 2979,2994 ****
  		don't fit, a vertical layout is used anyway.  For some systems
  		the horizontal layout is always used.
  
  ch_close({handle})						*ch_close()*
  		Close {handle}.  See |channel-close|.
! 		{handle} can be Channel or a Job that has a Channel.
  		A close callback is not invoked.
  
  		{only available when compiled with the |+channel| feature}
  
  ch_close_in({handle})						*ch_close_in()*
  		Close the "in" part of {handle}.  See |channel-close-in|.
! 		{handle} can be Channel or a Job that has a Channel.
  		A close callback is not invoked.
  
  		{only available when compiled with the |+channel| feature}
--- 2981,3008 ----
  		don't fit, a vertical layout is used anyway.  For some systems
  		the horizontal layout is always used.
  
+ ch_canread({handle})						*ch_canread()*
+ 		Return non-zero when there is something to read from {handle}.
+ 		{handle} can be a Channel or a Job that has a Channel.
+ 
+ 		This is useful to read from a channel at a convenient time,
+ 		e.g. from a timer.
+ 
+ 		Note that messages are dropped when the channel does not have
+ 		a callback.  Add a close callback to avoid that.
+ 
+ 		{only available when compiled with the |+channel| feature}
+ 
  ch_close({handle})						*ch_close()*
  		Close {handle}.  See |channel-close|.
! 		{handle} can be a Channel or a Job that has a Channel.
  		A close callback is not invoked.
  
  		{only available when compiled with the |+channel| feature}
  
  ch_close_in({handle})						*ch_close_in()*
  		Close the "in" part of {handle}.  See |channel-close-in|.
! 		{handle} can be a Channel or a Job that has a Channel.
  		A close callback is not invoked.
  
  		{only available when compiled with the |+channel| feature}
***************
*** 2997,3003 ****
  		Send {expr} over {handle}.  The {expr} is encoded
  		according to the type of channel.  The function cannot be used
  		with a raw channel.  See |channel-use|.
! 		{handle} can be Channel or a Job that has a Channel.
  								*E917*
  		{options} must be a Dictionary.  It must not have a "callback"
  		entry.  It can have a "timeout" entry to specify the timeout
--- 3011,3017 ----
  		Send {expr} over {handle}.  The {expr} is encoded
  		according to the type of channel.  The function cannot be used
  		with a raw channel.  See |channel-use|.
! 		{handle} can be a Channel or a Job that has a Channel.
  								*E917*
  		{options} must be a Dictionary.  It must not have a "callback"
  		entry.  It can have a "timeout" entry to specify the timeout
***************
*** 3011,3017 ****
  
  ch_evalraw({handle}, {string} [, {options}])		*ch_evalraw()*
  		Send {string} over {handle}.
! 		{handle} can be Channel or a Job that has a Channel.
  
  		Works like |ch_evalexpr()|, but does not encode the request or
  		decode the response.  The caller is responsible for the
--- 3025,3031 ----
  
  ch_evalraw({handle}, {string} [, {options}])		*ch_evalraw()*
  		Send {string} over {handle}.
! 		{handle} can be a Channel or a Job that has a Channel.
  
  		Works like |ch_evalexpr()|, but does not encode the request or
  		decode the response.  The caller is responsible for the
***************
*** 3024,3030 ****
  
  ch_getbufnr({handle}, {what})				 *ch_getbufnr()*
  		Get the buffer number that {handle} is using for {what}.
! 		{handle} can be Channel or a Job that has a Channel.
  		{what} can be "err" for stderr, "out" for stdout or empty for
  		socket output.
  		Returns -1 when there is no buffer.
--- 3038,3044 ----
  
  ch_getbufnr({handle}, {what})				 *ch_getbufnr()*
  		Get the buffer number that {handle} is using for {what}.
! 		{handle} can be a Channel or a Job that has a Channel.
  		{what} can be "err" for stderr, "out" for stdout or empty for
  		socket output.
  		Returns -1 when there is no buffer.
***************
*** 3070,3077 ****
  		|ch_logfile()|.
  		When {handle} is passed the channel number is used for the
  		message.
! 		{handle} can be Channel or a Job that has a Channel.  The
! 		Channel must open.
  
  ch_logfile({fname} [, {mode}])					*ch_logfile()*
  		Start logging channel activity to {fname}.
--- 3084,3091 ----
  		|ch_logfile()|.
  		When {handle} is passed the channel number is used for the
  		message.
! 		{handle} can be a Channel or a Job that has a Channel.  The
! 		Channel must be open for the channel number to be used.
  
  ch_logfile({fname} [, {mode}])					*ch_logfile()*
  		Start logging channel activity to {fname}.
***************
*** 3098,3104 ****
  
  ch_read({handle} [, {options}])					*ch_read()*
  		Read from {handle} and return the received message.
! 		{handle} can be Channel or a Job that has a Channel.
  		See |channel-more|.
  		{only available when compiled with the |+channel| feature}
  
--- 3112,3118 ----
  
  ch_read({handle} [, {options}])					*ch_read()*
  		Read from {handle} and return the received message.
! 		{handle} can be a Channel or a Job that has a Channel.
  		See |channel-more|.
  		{only available when compiled with the |+channel| feature}
  
***************
*** 3112,3118 ****
  		according to the type of channel.  The function cannot be used
  		with a raw channel.
  		See |channel-use|.				*E912*
! 		{handle} can be Channel or a Job that has a Channel.
  
  		{only available when compiled with the |+channel| feature}
  
--- 3126,3132 ----
  		according to the type of channel.  The function cannot be used
  		with a raw channel.
  		See |channel-use|.				*E912*
! 		{handle} can be a Channel or a Job that has a Channel.
  
  		{only available when compiled with the |+channel| feature}
  
***************
*** 3133,3139 ****
  			"timeout"	default read timeout in msec
  			"mode"		mode for the whole channel
  		See |ch_open()| for more explanation.
! 		{handle} can be Channel or a Job that has a Channel.
  
  		Note that changing the mode may cause queued messages to be
  		lost.
--- 3147,3153 ----
  			"timeout"	default read timeout in msec
  			"mode"		mode for the whole channel
  		See |ch_open()| for more explanation.
! 		{handle} can be a Channel or a Job that has a Channel.
  
  		Note that changing the mode may cause queued messages to be
  		lost.
***************
*** 3147,3153 ****
  			"open"		channel can be used
  			"buffered"	channel can be read, not written to
  			"closed"	channel can not be used
! 		{handle} can be Channel or a Job that has a Channel.
  		"buffered" is used when the channel was closed but there is
  		still data that can be obtained with |ch_read()|.
  
--- 3161,3167 ----
  			"open"		channel can be used
  			"buffered"	channel can be read, not written to
  			"closed"	channel can not be used
! 		{handle} can be a Channel or a Job that has a Channel.
  		"buffered" is used when the channel was closed but there is
  		still data that can be obtained with |ch_read()|.
  
***************
*** 3708,3716 ****
  		is zero remove the item from the |List| or |Dictionary|.
  		{expr2} must be a |string| or |Funcref|.
  		
! 		if {expr2} is a |string|, inside {expr2} |v:val| has the value
  		of the current item.  For a |Dictionary| |v:key| has the key
! 		of the current item.
  		Examples: >
  			call filter(mylist, 'v:val !~ "OLD"')
  <		Removes the items where "OLD" appears. >
--- 3722,3731 ----
  		is zero remove the item from the |List| or |Dictionary|.
  		{expr2} must be a |string| or |Funcref|.
  		
! 		If {expr2} is a |string|, inside {expr2} |v:val| has the value
  		of the current item.  For a |Dictionary| |v:key| has the key
! 		of the current item and for a |List| |v:key| has the index of
! 		the current item.
  		Examples: >
  			call filter(mylist, 'v:val !~ "OLD"')
  <		Removes the items where "OLD" appears. >
*** ../vim-8.0.0104/runtime/doc/channel.txt	2016-09-12 12:45:25.000000000 +0200
--- runtime/doc/channel.txt	2016-11-29 21:43:53.144857530 +0100
***************
*** 418,424 ****
  message that is available: >
  	let output = ch_read(channel, {'timeout': 0})
  When no message was available then the result is v:none for a JSON or JS mode
! channels, an empty string for a RAW or NL channel.
  
  To read all output from a RAW channel that is available: >
  	let output = ch_readraw(channel)
--- 418,428 ----
  message that is available: >
  	let output = ch_read(channel, {'timeout': 0})
  When no message was available then the result is v:none for a JSON or JS mode
! channels, an empty string for a RAW or NL channel.  You can use |ch_canread()|
! to check if there is something to read.
! 
! Note that when there is no callback message are dropped.  To avoid that add a
! close callback to the channel.
  
  To read all output from a RAW channel that is available: >
  	let output = ch_readraw(channel)
***************
*** 465,470 ****
--- 469,479 ----
  Without the handler you need to read the output with |ch_read()| or
  |ch_readraw()|. You can do this in the close callback, see |read-in-close-cb|.
  
+ Note that if the job exits before you read the output, the output may be lost.
+ This depends on the system (on Unix this happens because closing the write end
+ of a pipe causes the read end to get EOF).  To avoid this make the job sleep
+ for a short while before it exits.
+ 
  The handler defined for "out_cb" will not receive stderr.  If you want to
  handle that separately, add an "err_cb" handler: >
      let job = job_start(command, {"out_cb": "MyHandler",
*** ../vim-8.0.0104/src/version.c	2016-11-26 17:45:50.040909819 +0100
--- src/version.c	2016-11-29 20:14:29.545027586 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     105,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
55. You ask your doctor to implant a gig in your brain.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0106
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0106 (after 8.0.0100)
Problem:    Cannot use a semicolon in 'backupext'. (Jeff)
Solution:   Allow for a few more characters when "secure" isn't set.
Files:      src/option.c


*** ../vim-8.0.0105/src/option.c	2016-11-26 17:45:50.040909819 +0100
--- src/option.c	2016-11-29 22:05:29.171482041 +0100
***************
*** 5879,5887 ****
  
      /* Check for a "normal" directory or file name in some options.  Disallow a
       * path separator (slash and/or backslash), wildcards and characters that
!      * are often illegal in a file name. */
      else if (((options[opt_idx].flags & P_NFNAME)
! 		    && vim_strpbrk(*varp, (char_u *)"/\\*?[|;&<>\r\n") != NULL)
  	  || ((options[opt_idx].flags & P_NDNAME)
  		    && vim_strpbrk(*varp, (char_u *)"*?[|;&<>\r\n") != NULL))
      {
--- 5879,5889 ----
  
      /* Check for a "normal" directory or file name in some options.  Disallow a
       * path separator (slash and/or backslash), wildcards and characters that
!      * are often illegal in a file name. Be more permissive if "secure" is off.
!      */
      else if (((options[opt_idx].flags & P_NFNAME)
! 		    && vim_strpbrk(*varp, (char_u *)(secure
! 			    ? "/\\*?[|;&<>\r\n" : "/\\*?[<>\r\n")) != NULL)
  	  || ((options[opt_idx].flags & P_NDNAME)
  		    && vim_strpbrk(*varp, (char_u *)"*?[|;&<>\r\n") != NULL))
      {
*** ../vim-8.0.0105/src/version.c	2016-11-29 21:54:41.120260177 +0100
--- src/version.c	2016-11-29 22:07:10.726739408 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     106,
  /**/

-- 
ERROR 047: Keyboard not found.  Press RETURN to continue.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0107
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0107
Problem:    When reading channel output in a timer, messages may go missing.
            (Skywind)
Solution:   Add the "drop" option.  Write error messages in the channel log.
            Don't have ch_canread() check for the channel being open.
Files:      src/structs.h, src/channel.c, src/message.c, src/evalfunc.c,
            src/proto/channel.pro, runtime/doc/channel.txt


*** ../vim-8.0.0106/src/structs.h	2016-11-24 15:09:03.405856662 +0100
--- src/structs.h	2016-12-01 13:04:30.094157140 +0100
***************
*** 1474,1479 ****
--- 1474,1480 ----
      typval_T	*jq_value;
      jsonq_T	*jq_next;
      jsonq_T	*jq_prev;
+     int		jq_no_callback; /* TRUE when no callback was found */
  };
  
  struct cbq_S
***************
*** 1597,1602 ****
--- 1598,1604 ----
      partial_T	*ch_partial;
      char_u	*ch_close_cb;	/* call when channel is closed */
      partial_T	*ch_close_partial;
+     int		ch_drop_never;
  
      job_T	*ch_job;	/* Job that uses this channel; this does not
  				 * count as a reference to avoid a circular
***************
*** 1684,1689 ****
--- 1686,1692 ----
      partial_T	*jo_close_partial; /* not referenced! */
      char_u	*jo_exit_cb;	/* not allocated! */
      partial_T	*jo_exit_partial; /* not referenced! */
+     int		jo_drop_never;
      int		jo_waittime;
      int		jo_timeout;
      int		jo_out_timeout;
*** ../vim-8.0.0106/src/channel.c	2016-11-29 21:54:41.116260206 +0100
--- src/channel.c	2016-12-01 15:21:38.504292378 +0100
***************
*** 1195,1200 ****
--- 1195,1201 ----
      if (opt->jo_set & JO_CLOSE_CALLBACK)
  	set_callback(&channel->ch_close_cb, &channel->ch_close_partial,
  		opt->jo_close_cb, opt->jo_close_partial);
+     channel->ch_drop_never = opt->jo_drop_never;
  
      if ((opt->jo_set & JO_OUT_IO) && opt->jo_io[PART_OUT] == JIO_BUFFER)
      {
***************
*** 1918,1923 ****
--- 1919,1925 ----
  		clear_tv(&listtv);
  	    else
  	    {
+ 		item->jq_no_callback = FALSE;
  		item->jq_value = alloc_tv();
  		if (item->jq_value == NULL)
  		{
***************
*** 2050,2060 ****
   * When "id" is positive it must match the first number in the list.
   * When "id" is zero or negative jut get the first message.  But not the one
   * with id ch_block_id.
   * Return OK when found and return the value in "rettv".
   * Return FAIL otherwise.
   */
      static int
! channel_get_json(channel_T *channel, ch_part_T part, int id, typval_T **rettv)
  {
      jsonq_T   *head = &channel->ch_part[part].ch_json_head;
      jsonq_T   *item = head->jq_next;
--- 2052,2068 ----
   * When "id" is positive it must match the first number in the list.
   * When "id" is zero or negative jut get the first message.  But not the one
   * with id ch_block_id.
+  * When "without_callback" is TRUE also get messages that were pushed back.
   * Return OK when found and return the value in "rettv".
   * Return FAIL otherwise.
   */
      static int
! channel_get_json(
! 	channel_T   *channel,
! 	ch_part_T   part,
! 	int	    id,
! 	int	    without_callback,
! 	typval_T    **rettv)
  {
      jsonq_T   *head = &channel->ch_part[part].ch_json_head;
      jsonq_T   *item = head->jq_next;
***************
*** 2064,2073 ****
  	list_T	    *l = item->jq_value->vval.v_list;
  	typval_T    *tv = &l->lv_first->li_tv;
  
! 	if ((id > 0 && tv->v_type == VAR_NUMBER && tv->vval.v_number == id)
  	      || (id <= 0 && (tv->v_type != VAR_NUMBER
  		 || tv->vval.v_number == 0
! 		 || tv->vval.v_number != channel->ch_part[part].ch_block_id)))
  	{
  	    *rettv = item->jq_value;
  	    if (tv->v_type == VAR_NUMBER)
--- 2072,2082 ----
  	list_T	    *l = item->jq_value->vval.v_list;
  	typval_T    *tv = &l->lv_first->li_tv;
  
! 	if ((without_callback || !item->jq_no_callback)
! 	    && ((id > 0 && tv->v_type == VAR_NUMBER && tv->vval.v_number == id)
  	      || (id <= 0 && (tv->v_type != VAR_NUMBER
  		 || tv->vval.v_number == 0
! 		 || tv->vval.v_number != channel->ch_part[part].ch_block_id))))
  	{
  	    *rettv = item->jq_value;
  	    if (tv->v_type == VAR_NUMBER)
***************
*** 2080,2085 ****
--- 2089,2153 ----
      return FAIL;
  }
  
+ /*
+  * Put back "rettv" into the JSON queue, there was no callback for it.
+  * Takes over the values in "rettv".
+  */
+     static void
+ channel_push_json(channel_T *channel, ch_part_T part, typval_T *rettv)
+ {
+     jsonq_T   *head = &channel->ch_part[part].ch_json_head;
+     jsonq_T   *item = head->jq_next;
+     jsonq_T   *newitem;
+ 
+     if (head->jq_prev != NULL && head->jq_prev->jq_no_callback)
+ 	/* last item was pushed back, append to the end */
+ 	item = NULL;
+     else while (item != NULL && item->jq_no_callback)
+ 	/* append after the last item that was pushed back */
+ 	item = item->jq_next;
+ 
+     newitem = (jsonq_T *)alloc((unsigned)sizeof(jsonq_T));
+     if (newitem == NULL)
+ 	clear_tv(rettv);
+     else
+     {
+ 	newitem->jq_value = alloc_tv();
+ 	if (newitem->jq_value == NULL)
+ 	{
+ 	    vim_free(newitem);
+ 	    clear_tv(rettv);
+ 	}
+ 	else
+ 	{
+ 	    newitem->jq_no_callback = FALSE;
+ 	    *newitem->jq_value = *rettv;
+ 	    if (item == NULL)
+ 	    {
+ 		/* append to the end */
+ 		newitem->jq_prev = head->jq_prev;
+ 		head->jq_prev = newitem;
+ 		newitem->jq_next = NULL;
+ 		if (newitem->jq_prev == NULL)
+ 		    head->jq_next = newitem;
+ 		else
+ 		    newitem->jq_prev->jq_next = newitem;
+ 	    }
+ 	    else
+ 	    {
+ 		/* append after "item" */
+ 		newitem->jq_prev = item;
+ 		newitem->jq_next = item->jq_next;
+ 		item->jq_next = newitem;
+ 		if (newitem->jq_next == NULL)
+ 		    head->jq_prev = newitem;
+ 		else
+ 		    newitem->jq_next->jq_prev = newitem;
+ 	    }
+ 	}
+     }
+ }
+ 
  #define CH_JSON_MAX_ARGS 4
  
  /*
***************
*** 2410,2420 ****
  	int		argc = 0;
  
  	/* Get any json message in the queue. */
! 	if (channel_get_json(channel, part, -1, &listtv) == FAIL)
  	{
  	    /* Parse readahead, return when there is still no message. */
  	    channel_parse_json(channel, part);
! 	    if (channel_get_json(channel, part, -1, &listtv) == FAIL)
  		return FALSE;
  	}
  
--- 2478,2488 ----
  	int		argc = 0;
  
  	/* Get any json message in the queue. */
! 	if (channel_get_json(channel, part, -1, FALSE, &listtv) == FAIL)
  	{
  	    /* Parse readahead, return when there is still no message. */
  	    channel_parse_json(channel, part);
! 	    if (channel_get_json(channel, part, -1, FALSE, &listtv) == FAIL)
  		return FALSE;
  	}
  
***************
*** 2454,2460 ****
  	{
  	    /* If there is a close callback it may use ch_read() to get the
  	     * messages. */
! 	    if (channel->ch_close_cb == NULL)
  		drop_messages(channel, part);
  	    return FALSE;
  	}
--- 2522,2528 ----
  	{
  	    /* If there is a close callback it may use ch_read() to get the
  	     * messages. */
! 	    if (channel->ch_close_cb == NULL && !channel->ch_drop_never)
  		drop_messages(channel, part);
  	    return FALSE;
  	}
***************
*** 2531,2537 ****
      {
  	int	done = FALSE;
  
! 	/* invoke the one-time callback with the matching nr */
  	for (cbitem = cbhead->cq_next; cbitem != NULL; cbitem = cbitem->cq_next)
  	    if (cbitem->cq_seq_nr == seq_nr)
  	    {
--- 2599,2605 ----
      {
  	int	done = FALSE;
  
! 	/* JSON or JS mode: invoke the one-time callback with the matching nr */
  	for (cbitem = cbhead->cq_next; cbitem != NULL; cbitem = cbitem->cq_next)
  	    if (cbitem->cq_seq_nr == seq_nr)
  	    {
***************
*** 2540,2546 ****
  		break;
  	    }
  	if (!done)
! 	    ch_logn(channel, "Dropping message %d without callback", seq_nr);
      }
      else if (callback != NULL || buffer != NULL)
      {
--- 2608,2624 ----
  		break;
  	    }
  	if (!done)
! 	{
! 	    if (channel->ch_drop_never)
! 	    {
! 		/* message must be read with ch_read() */
! 		channel_push_json(channel, part, listtv);
! 		listtv = NULL;
! 	    }
! 	    else
! 		ch_logn(channel, "Dropping message %d without callback",
! 								       seq_nr);
! 	}
      }
      else if (callback != NULL || buffer != NULL)
      {
***************
*** 2567,2573 ****
  	}
      }
      else
! 	ch_log(channel, "Dropping message");
  
      if (listtv != NULL)
  	free_tv(listtv);
--- 2645,2651 ----
  	}
      }
      else
! 	ch_logn(channel, "Dropping message %d", seq_nr);
  
      if (listtv != NULL)
  	free_tv(listtv);
***************
*** 2792,2800 ****
  	      redraw_after_callback();
  	  }
  
! 	  /* any remaining messages are useless now */
! 	  for (part = PART_SOCK; part < PART_IN; ++part)
! 	      drop_messages(channel, part);
      }
  
      channel->ch_nb_close_cb = NULL;
--- 2870,2879 ----
  	      redraw_after_callback();
  	  }
  
! 	  if (!channel->ch_drop_never)
! 	      /* any remaining messages are useless now */
! 	      for (part = PART_SOCK; part < PART_IN; ++part)
! 		  drop_messages(channel, part);
      }
  
      channel->ch_nb_close_cb = NULL;
***************
*** 3091,3099 ****
  channel_close_now(channel_T *channel)
  {
      ch_log(channel, "Closing channel because all readable fds are closed");
-     channel_close(channel, TRUE);
      if (channel->ch_nb_close_cb != NULL)
  	(*channel->ch_nb_close_cb)();
  }
  
  /*
--- 3170,3178 ----
  channel_close_now(channel_T *channel)
  {
      ch_log(channel, "Closing channel because all readable fds are closed");
      if (channel->ch_nb_close_cb != NULL)
  	(*channel->ch_nb_close_cb)();
+     channel_close(channel, TRUE);
  }
  
  /*
***************
*** 3243,3249 ****
   * When "id" is -1 accept any message;
   * Blocks until the message is received or the timeout is reached.
   */
!     int
  channel_read_json_block(
  	channel_T   *channel,
  	ch_part_T   part,
--- 3322,3328 ----
   * When "id" is -1 accept any message;
   * Blocks until the message is received or the timeout is reached.
   */
!     static int
  channel_read_json_block(
  	channel_T   *channel,
  	ch_part_T   part,
***************
*** 3264,3270 ****
  	more = channel_parse_json(channel, part);
  
  	/* search for message "id" */
! 	if (channel_get_json(channel, part, id, rettv) == OK)
  	{
  	    chanpart->ch_block_id = 0;
  	    return OK;
--- 3343,3349 ----
  	more = channel_parse_json(channel, part);
  
  	/* search for message "id" */
! 	if (channel_get_json(channel, part, id, TRUE, rettv) == OK)
  	{
  	    chanpart->ch_block_id = 0;
  	    return OK;
***************
*** 4290,4295 ****
--- 4369,4388 ----
  		    return FAIL;
  		}
  	    }
+ 	    else if (STRCMP(hi->hi_key, "drop") == 0)
+ 	    {
+ 		int never = FALSE;
+ 		val = get_tv_string(item);
+ 
+ 		if (STRCMP(val, "never") == 0)
+ 		    never = TRUE;
+ 		else if (STRCMP(val, "auto") != 0)
+ 		{
+ 		    EMSG2(_(e_invarg2), "drop");
+ 		    return FAIL;
+ 		}
+ 		opt->jo_drop_never = never;
+ 	    }
  	    else if (STRCMP(hi->hi_key, "exit_cb") == 0)
  	    {
  		if (!(supported & JO_EXIT_CB))
*** ../vim-8.0.0106/src/message.c	2016-11-10 20:01:41.193582919 +0100
--- src/message.c	2016-12-01 13:50:25.124167776 +0100
***************
*** 42,47 ****
--- 42,50 ----
  static char_u	*confirm_msg = NULL;		/* ":confirm" message */
  static char_u	*confirm_msg_tail;		/* tail of confirm_msg */
  #endif
+ #ifdef FEAT_JOB_CHANNEL
+ static int emsg_to_channel_log = FALSE;
+ #endif
  
  struct msg_hist
  {
***************
*** 166,171 ****
--- 169,182 ----
  		&& STRCMP(s, last_msg_hist->msg)))
  	add_msg_hist(s, -1, attr);
  
+ #ifdef FEAT_JOB_CHANNEL
+     if (emsg_to_channel_log)
+     {
+ 	/* Write message in the channel log. */
+ 	ch_logs(NULL, "ERROR: %s", (char *)s);
+     }
+ #endif
+ 
      /* When displaying keep_msg, don't let msg_start() free it, caller must do
       * that. */
      if (s == keep_msg)
***************
*** 556,561 ****
--- 567,573 ----
  {
      int		attr;
      char_u	*p;
+     int		r;
  #ifdef FEAT_EVAL
      int		ignore = FALSE;
      int		severe;
***************
*** 624,629 ****
--- 636,644 ----
  		}
  		redir_write(s, -1);
  	    }
+ #ifdef FEAT_JOB_CHANNEL
+ 	    ch_logs(NULL, "ERROR: %s", (char *)s);
+ #endif
  	    return TRUE;
  	}
  
***************
*** 650,655 ****
--- 665,673 ----
  				     * and a redraw is expected because
  				     * msg_scrolled is non-zero */
  
+ #ifdef FEAT_JOB_CHANNEL
+     emsg_to_channel_log = TRUE;
+ #endif
      /*
       * Display name and line number for the source of the error.
       */
***************
*** 659,665 ****
       * Display the error message itself.
       */
      msg_nowait = FALSE;			/* wait for this msg */
!     return msg_attr(s, attr);
  }
  
  
--- 677,688 ----
       * Display the error message itself.
       */
      msg_nowait = FALSE;			/* wait for this msg */
!     r = msg_attr(s, attr);
! 
! #ifdef FEAT_JOB_CHANNEL
!     emsg_to_channel_log = FALSE;
! #endif
!     return r;
  }
  
  
*** ../vim-8.0.0106/src/evalfunc.c	2016-11-29 21:54:41.116260206 +0100
--- src/evalfunc.c	2016-12-01 15:17:06.322073618 +0100
***************
*** 1786,1792 ****
      static void
  f_ch_canread(typval_T *argvars, typval_T *rettv)
  {
!     channel_T *channel = get_channel_arg(&argvars[0], TRUE, TRUE, 0);
  
      rettv->vval.v_number = 0;
      if (channel != NULL)
--- 1786,1792 ----
      static void
  f_ch_canread(typval_T *argvars, typval_T *rettv)
  {
!     channel_T *channel = get_channel_arg(&argvars[0], FALSE, FALSE, 0);
  
      rettv->vval.v_number = 0;
      if (channel != NULL)
*** ../vim-8.0.0106/src/proto/channel.pro	2016-11-29 21:54:41.116260206 +0100
--- src/proto/channel.pro	2016-12-01 12:47:07.212955490 +0100
***************
*** 33,39 ****
  void channel_clear(channel_T *channel);
  void channel_free_all(void);
  char_u *channel_read_block(channel_T *channel, ch_part_T part, int timeout);
- int channel_read_json_block(channel_T *channel, ch_part_T part, int timeout_arg, int id, typval_T **rettv);
  void common_channel_read(typval_T *argvars, typval_T *rettv, int raw);
  channel_T *channel_fd2channel(sock_T fd, ch_part_T *partp);
  void channel_handle_events(void);
--- 33,38 ----
*** ../vim-8.0.0106/runtime/doc/channel.txt	2016-11-29 21:54:41.120260177 +0100
--- runtime/doc/channel.txt	2016-12-01 12:20:43.087290042 +0100
***************
*** 155,161 ****
  	func MyCloseHandler(channel)
  <		Vim will invoke callbacks that handle data before invoking
  		close_cb, thus when this function is called no more data will
! 		be received.
  							*waittime*
  "waittime"	The time to wait for the connection to be made in
  		milliseconds.  A negative number waits forever.
--- 155,167 ----
  	func MyCloseHandler(channel)
  <		Vim will invoke callbacks that handle data before invoking
  		close_cb, thus when this function is called no more data will
! 		be passed to the callbacks.
! 							*channel-drop*
! "drop"		Specifies when to drop messages:
! 		    "auto"	When there is no callback to handle a message.
! 				The "close_cb" is also considered for this.
! 		    "never"	All messages will be kept.
! 
  							*waittime*
  "waittime"	The time to wait for the connection to be made in
  		milliseconds.  A negative number waits forever.
***************
*** 600,605 ****
  "close_cb": handler	Callback for when the channel is closed.  Same as
  			"close_cb" on |ch_open()|, see |close_cb|.
  						*job-exit_cb*
  "exit_cb": handler	Callback for when the job ends.  The arguments are the
  			job and the exit status.
  			Vim checks up to 10 times per second for jobs that
--- 606,615 ----
  "close_cb": handler	Callback for when the channel is closed.  Same as
  			"close_cb" on |ch_open()|, see |close_cb|.
  						*job-exit_cb*
+ "drop"			Specifies when to drop messages.  Same as "drop" on
+ 			|ch_open()|, see |channel-drop|.  For "auto" the
+ 			exit_cb is not considered.
+ 
  "exit_cb": handler	Callback for when the job ends.  The arguments are the
  			job and the exit status.
  			Vim checks up to 10 times per second for jobs that
*** ../vim-8.0.0106/src/version.c	2016-11-29 22:10:44.221151470 +0100
--- src/version.c	2016-12-01 12:21:52.086839902 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     107,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
62. If your doorbell rings, you think that new mail has arrived.  And then
    you're disappointed that it's only someone at the door.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0108
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0108 (after 8.0.0107)
Problem:    The channel "drop" option is not tested.
Solution:   Add a test.
Files:      src/testdir/test_channel.vim


*** ../vim-8.0.0107/src/testdir/test_channel.vim	2016-11-29 21:54:41.116260206 +0100
--- src/testdir/test_channel.vim	2016-12-01 16:38:49.326026563 +0100
***************
*** 129,134 ****
--- 129,137 ----
    call ch_setoptions(handle, {'mode': 'json'})
    call assert_fails("call ch_setoptions(handle, {'waittime': 111})", "E475")
    call ch_setoptions(handle, {'callback': ''})
+   call ch_setoptions(handle, {'drop': 'never'})
+   call ch_setoptions(handle, {'drop': 'auto'})
+   call assert_fails("call ch_setoptions(handle, {'drop': 'bad'})", "E475")
  
    " Send an eval request that works.
    call assert_equal('ok', ch_evalexpr(handle, 'eval-works'))
***************
*** 249,254 ****
--- 252,258 ----
  """""""""
  
  func Ch_handler(chan, msg)
+   call ch_log('Ch_handler()')
    unlet g:Ch_reply
    let g:Ch_reply = a:msg
  endfunc
***************
*** 272,277 ****
--- 276,282 ----
  endfunc
  
  func Test_channel_handler()
+ call ch_logfile('channellog', 'w')
    call ch_log('Test_channel_handler()')
    let g:Ch_reply = ""
    let s:chopt.callback = 'Ch_handler'
***************
*** 437,443 ****
    " Add a dummy close callback to avoid that messages are dropped when calling
    " ch_canread().
    let job = job_start(s:python . " test_channel_pipe.py",
! 	\ {'mode': 'raw', 'close_cb': {chan -> 0}})
    call assert_equal(v:t_job, type(job))
    call assert_equal("run", job_status(job))
  
--- 442,448 ----
    " Add a dummy close callback to avoid that messages are dropped when calling
    " ch_canread().
    let job = job_start(s:python . " test_channel_pipe.py",
! 	\ {'mode': 'raw', 'drop': 'never'})
    call assert_equal(v:t_job, type(job))
    call assert_equal("run", job_status(job))
  
*** ../vim-8.0.0107/src/version.c	2016-12-01 15:34:04.087413921 +0100
--- src/version.c	2016-12-01 16:31:56.204722973 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     108,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
63. You start using smileys in your snail mail.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0109
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0109
Problem:    Still checking if memcmp() exists while every system should have
            it now.
Solution:   Remove vim_memcmp().  (James McCoy, closes #1295)
Files:      src/config.h.in, src/configure.ac, src/misc2.c, src/os_vms_conf.h,
            src/osdef1.h.in, src/search.c, src/tag.c, src/vim.h


*** ../vim-8.0.0108/src/config.h.in	2016-11-12 21:12:48.538182233 +0100
--- src/config.h.in	2016-12-01 17:08:35.738390168 +0100
***************
*** 154,160 ****
  #undef BAD_GETCWD
  
  /* Define if you the function: */
- #undef HAVE_BCMP
  #undef HAVE_FCHDIR
  #undef HAVE_FCHOWN
  #undef HAVE_FSEEKO
--- 154,159 ----
***************
*** 170,176 ****
  #undef HAVE_ICONV
  #undef HAVE_NL_LANGINFO_CODESET
  #undef HAVE_LSTAT
- #undef HAVE_MEMCMP
  #undef HAVE_MEMSET
  #undef HAVE_MKDTEMP
  #undef HAVE_NANOSLEEP
--- 169,174 ----
*** ../vim-8.0.0108/src/configure.ac	2016-11-12 21:12:48.534182259 +0100
--- src/configure.ac	2016-12-01 17:08:35.742390142 +0100
***************
*** 3594,3601 ****
  
  dnl Check for functions in one big call, to reduce the size of configure.
  dnl Can only be used for functions that do not require any include.
! AC_CHECK_FUNCS(bcmp fchdir fchown fsync getcwd getpseudotty \
! 	getpwent getpwnam getpwuid getrlimit gettimeofday getwd lstat memcmp \
  	memset mkdtemp nanosleep opendir putenv qsort readlink select setenv \
  	setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction \
  	sigprocmask sigvec strcasecmp strerror strftime stricmp strncasecmp \
--- 3594,3601 ----
  
  dnl Check for functions in one big call, to reduce the size of configure.
  dnl Can only be used for functions that do not require any include.
! AC_CHECK_FUNCS(fchdir fchown fsync getcwd getpseudotty \
! 	getpwent getpwnam getpwuid getrlimit gettimeofday getwd lstat \
  	memset mkdtemp nanosleep opendir putenv qsort readlink select setenv \
  	setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction \
  	sigprocmask sigvec strcasecmp strerror strftime stricmp strncasecmp \
*** ../vim-8.0.0108/src/misc2.c	2016-11-26 15:13:29.410218034 +0100
--- src/misc2.c	2016-12-01 17:08:35.742390142 +0100
***************
*** 1740,1766 ****
  }
  #endif
  
- #ifdef VIM_MEMCMP
- /*
-  * Return zero when "b1" and "b2" are the same for "len" bytes.
-  * Return non-zero otherwise.
-  */
-     int
- vim_memcmp(void *b1, void *b2, size_t len)
- {
-     char_u  *p1 = (char_u *)b1, *p2 = (char_u *)b2;
- 
-     for ( ; len > 0; --len)
-     {
- 	if (*p1 != *p2)
- 	    return 1;
- 	++p1;
- 	++p2;
-     }
-     return 0;
- }
- #endif
- 
  /* skipped when generating prototypes, the prototype is in vim.h */
  #ifdef VIM_MEMMOVE
  /*
--- 1740,1745 ----
*** ../vim-8.0.0108/src/os_vms_conf.h	2016-11-04 20:35:27.352945991 +0100
--- src/os_vms_conf.h	2016-12-01 17:08:35.742390142 +0100
***************
*** 101,107 ****
  #define HAVE_STRTOL
  #define HAVE_TGETENT
  #define HAVE_MEMSET
- #define HAVE_MEMCMP
  #define HAVE_STRERROR
  #define HAVE_FCHOWN
  #define HAVE_RENAME
--- 101,106 ----
*** ../vim-8.0.0108/src/osdef1.h.in	2016-01-23 22:35:31.000000000 +0100
--- src/osdef1.h.in	2016-12-01 17:08:35.742390142 +0100
***************
*** 50,61 ****
  #ifdef HAVE_MEMSET
  extern void	*memset(void *, int, size_t);
  #endif
- #ifdef HAVE_BCMP
- extern int	bcmp(void *, void *, size_t);
- #endif
- #ifdef HAVE_MEMCMP
  extern int	memcmp(const void *, const void *, size_t);
- #endif
  #ifdef HAVE_STRPBRK
  extern char	*strpbrk(const char *, const char *);
  #endif
--- 50,56 ----
*** ../vim-8.0.0108/src/search.c	2016-10-15 17:06:42.090912729 +0200
--- src/search.c	2016-12-01 17:10:38.673588854 +0100
***************
*** 1695,1701 ****
  		}
  		else
  		{
! 		    if (vim_memcmp(p + col, lastc_bytes, lastc_bytelen) == 0 && stop)
  			break;
  		}
  		stop = TRUE;
--- 1695,1702 ----
  		}
  		else
  		{
! 		    if (memcmp(p + col, lastc_bytes, lastc_bytelen) == 0
! 								       && stop)
  			break;
  		}
  		stop = TRUE;
*** ../vim-8.0.0108/src/tag.c	2016-10-15 17:06:42.090912729 +0200
--- src/tag.c	2016-12-01 17:08:35.742390142 +0100
***************
*** 2400,2406 ****
  			      mfp2 = ((struct match_found **)
  						  (ga_match[mtt].ga_data))[i];
  			      if (mfp2->len == mfp->len
! 				      && vim_memcmp(mfp2->match, mfp->match,
  						       (size_t)mfp->len) == 0)
  				  break;
  			      fast_breakcheck();
--- 2400,2406 ----
  			      mfp2 = ((struct match_found **)
  						  (ga_match[mtt].ga_data))[i];
  			      if (mfp2->len == mfp->len
! 				      && memcmp(mfp2->match, mfp->match,
  						       (size_t)mfp->len) == 0)
  				  break;
  			      fast_breakcheck();
*** ../vim-8.0.0108/src/vim.h	2016-11-24 17:33:12.430669286 +0100
--- src/vim.h	2016-12-01 17:08:35.742390142 +0100
***************
*** 1733,1749 ****
  void *vim_memset(void *, int, size_t);
  #endif
  
- #ifdef HAVE_MEMCMP
- # define vim_memcmp(p1, p2, len)   memcmp((p1), (p2), (len))
- #else
- # ifdef HAVE_BCMP
- #  define vim_memcmp(p1, p2, len)   bcmp((p1), (p2), (len))
- # else
- int vim_memcmp(void *, void *, size_t);
- #  define VIM_MEMCMP
- # endif
- #endif
- 
  #if defined(UNIX) || defined(FEAT_GUI) || defined(VMS) \
  	|| defined(FEAT_CLIENTSERVER)
  # define USE_INPUT_BUF
--- 1733,1738 ----
*** ../vim-8.0.0108/src/version.c	2016-12-01 16:41:47.296864891 +0100
--- src/version.c	2016-12-01 17:09:45.649934472 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     109,
  /**/

-- 
I got a new desk stapler. It broke on the first desk I tried.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0110
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0110
Problem:    Drop command doesn't use existing window.
Solution:   Check the window width properly. (Hirohito Higashi)
Files:      src/buffer.c, src/testdir/test_tabpage.vim


*** ../vim-8.0.0109/src/buffer.c	2016-11-10 18:16:30.077477227 +0100
--- src/buffer.c	2016-12-01 17:37:29.307089016 +0100
***************
*** 4858,4865 ****
  	    wpnext = wp->w_next;
  	    buf = wp->w_buffer;
  	    if (buf->b_ffname == NULL
! 		    || (!keep_tabs && buf->b_nwindows > 1)
! 		    || wp->w_width != Columns)
  		i = opened_len;
  	    else
  	    {
--- 4858,4865 ----
  	    wpnext = wp->w_next;
  	    buf = wp->w_buffer;
  	    if (buf->b_ffname == NULL
! 		    || (!keep_tabs && (buf->b_nwindows > 1
! 			    || wp->w_width != Columns)))
  		i = opened_len;
  	    else
  	    {
*** ../vim-8.0.0109/src/testdir/test_tabpage.vim	2016-10-12 17:52:39.199701825 +0200
--- src/testdir/test_tabpage.vim	2016-12-01 17:36:45.351375597 +0100
***************
*** 65,70 ****
--- 65,79 ----
      call assert_true(tabpagenr() == 2 && tabpagewinnr(2, '$') == 2 && tabpagewinnr(2) == 1)
      tabclose
      q
+     "
+     "
+     " Test for ":tab drop vertical-split-window" to jump test1 buffer
+     tabedit test1
+     vnew
+     tabfirst
+     tab drop test1
+     call assert_equal([2, 2, 2, 2], [tabpagenr('$'), tabpagenr(), tabpagewinnr(2, '$'), tabpagewinnr(2)])
+     1tabonly
    endif
    "
    "
*** ../vim-8.0.0109/src/version.c	2016-12-01 17:25:16.795864620 +0100
--- src/version.c	2016-12-01 17:47:54.399002614 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     110,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
69. Yahoo welcomes you with your own start page

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0111
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0111
Problem:    The :history command is not tested.
Solution:   Add tests. (Dominique Pelle)
Files:      runtime/doc/cmdline.txt, src/testdir/test_history.vim


*** ../vim-8.0.0110/runtime/doc/cmdline.txt	2016-09-12 12:45:25.000000000 +0200
--- runtime/doc/cmdline.txt	2016-12-01 17:56:02.967807544 +0100
***************
*** 358,365 ****
  		List entries 6 to 12 from the search history: >
  			:history / 6,12
  <
! 		List the recent five entries from all histories: >
! 			:history all -5,
  
  :keepp[atterns] {command}			*:keepp* *:keeppatterns*
  		Execute {command}, without adding anything to the search
--- 359,369 ----
  		List entries 6 to 12 from the search history: >
  			:history / 6,12
  <
! 		List the penultimate entry from all histories: >
! 			:history all -2
! <
! 		List the most recent two entries from all histories: >
! 			:history all -2,
  
  :keepp[atterns] {command}			*:keepp* *:keeppatterns*
  		Execute {command}, without adding anything to the search
*** ../vim-8.0.0110/src/testdir/test_history.vim	2016-03-05 20:59:45.000000000 +0100
--- src/testdir/test_history.vim	2016-12-01 17:56:02.967807544 +0100
***************
*** 31,36 ****
--- 31,60 ----
    call assert_equal('ls', histget(a:hist, -1))
    call assert_equal(4, histnr(a:hist))
  
+   let a=execute('history ' . a:hist)
+   call assert_match("^\n      #  \\S* history\n      3  buffers\n>     4  ls$", a)
+   let a=execute('history all')
+   call assert_match("^\n      #  .* history\n      3  buffers\n>     4  ls", a)
+ 
+   if len(a:hist) > 0
+     let a=execute('history ' . a:hist . ' 2')
+     call assert_match("^\n      #  \\S* history$", a)
+     let a=execute('history ' . a:hist . ' 3')
+     call assert_match("^\n      #  \\S* history\n      3  buffers$", a)
+     let a=execute('history ' . a:hist . ' 4')
+     call assert_match("^\n      #  \\S* history\n>     4  ls$", a)
+     let a=execute('history ' . a:hist . ' 3,4')
+     call assert_match("^\n      #  \\S* history\n      3  buffers\n>     4  ls$", a)
+     let a=execute('history ' . a:hist . ' -1')
+     call assert_match("^\n      #  \\S* history\n>     4  ls$", a)
+     let a=execute('history ' . a:hist . ' -2')
+     call assert_match("^\n      #  \\S* history\n      3  buffers$", a)
+     let a=execute('history ' . a:hist . ' -2,')
+     call assert_match("^\n      #  \\S* history\n      3  buffers\n>     4  ls$", a)
+     let a=execute('history ' . a:hist . ' -3')
+     call assert_match("^\n      #  \\S* history$", a)
+   endif
+ 
    " Test for removing entries matching a pattern
    for i in range(1, 3)
        call histadd(a:hist, 'text_' . i)
*** ../vim-8.0.0110/src/version.c	2016-12-01 17:48:24.914803033 +0100
--- src/version.c	2016-12-01 17:56:32.831612262 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     111,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
70. ISDN lines are added to your house on a hourly basis

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0112
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0112
Problem:    Tests 92 and 93 are old style.
Solution:   Make test92 and test93 new style. (Hirohito Higashi, closes #1289)
Files:      src/Makefile, src/testdir/Make_all.mak, src/testdir/Make_vms.mms,
            src/testdir/test92.in, src/testdir/test92.ok,
            src/testdir/test93.in, src/testdir/test93.ok,
            src/testdir/test_mksession.vim,
            src/testdir/test_mksession_utf8.vim


*** ../vim-8.0.0111/src/Makefile	2016-11-17 19:32:17.897024245 +0100
--- src/Makefile	2016-12-01 18:14:12.212658597 +0100
***************
*** 2052,2058 ****
  	test60 test64 test65 test66 test67 test68 test69 \
  	test70 test72 test73 test74 test75 test77 test78 test79 \
  	test80 test82 test83 test84 test85 test86 test87 test88 test89 \
! 	test90 test91 test92 test93 test94 test95 test97 test98 test99 \
  	test100 test101 test103 test104 test107 test108:
  	cd testdir; rm -f $@.out; $(MAKE) -f Makefile $@.out VIMPROG=../$(VIMTARGET) $(GUI_TESTARG) SCRIPTSOURCE=../$(SCRIPTSOURCE)
  
--- 2061,2067 ----
  	test60 test64 test65 test66 test67 test68 test69 \
  	test70 test72 test73 test74 test75 test77 test78 test79 \
  	test80 test82 test83 test84 test85 test86 test87 test88 test89 \
! 	test90 test91 test94 test95 test97 test98 test99 \
  	test100 test101 test103 test104 test107 test108:
  	cd testdir; rm -f $@.out; $(MAKE) -f Makefile $@.out VIMPROG=../$(VIMTARGET) $(GUI_TESTARG) SCRIPTSOURCE=../$(SCRIPTSOURCE)
  
***************
*** 2118,2123 ****
--- 2127,2134 ----
  	test_matchadd_conceal_utf8 \
  	test_menu \
  	test_messages \
+ 	test_mksession \
+ 	test_mksession_utf8 \
  	test_nested_function \
  	test_netbeans \
  	test_normal \
*** ../vim-8.0.0111/src/testdir/Make_all.mak	2016-11-17 19:32:17.897024245 +0100
--- src/testdir/Make_all.mak	2016-12-01 18:14:12.212658597 +0100
***************
*** 63,70 ****
  	test88.out \
  	test90.out \
  	test91.out \
- 	test92.out \
- 	test93.out \
  	test94.out \
  	test95.out \
  	test98.out \
--- 63,68 ----
***************
*** 167,172 ****
--- 165,172 ----
  	    test_man.res \
  	    test_marks.res \
  	    test_matchadd_conceal.res \
+ 	    test_mksession.res \
+ 	    test_mksession_utf8.res \
  	    test_nested_function.res \
  	    test_netbeans.res \
  	    test_normal.res \
*** ../vim-8.0.0111/src/testdir/Make_vms.mms	2016-11-04 20:35:27.352945991 +0100
--- src/testdir/Make_vms.mms	2016-12-01 18:14:12.216658571 +0100
***************
*** 92,98 ****
         test72.out test75.out \
         test77a.out test78.out test79.out test80.out \
         test82.out test84.out test88.out test89.out \
!        test90.out test91.out test92.out test93.out test94.out \
         test95.out test98.out test99.out \
         test103.out test104.out \
         test107.out test108.out\
--- 92,98 ----
         test72.out test75.out \
         test77a.out test78.out test79.out test80.out \
         test82.out test84.out test88.out test89.out \
!        test90.out test91.out test94.out \
         test95.out test98.out test99.out \
         test103.out test104.out \
         test107.out test108.out\
*** ../vim-8.0.0111/src/testdir/test92.in	2013-09-22 14:45:06.000000000 +0200
--- src/testdir/test92.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,48 ****
- vim: set ft=vim fenc=utf-8:
- 
- Tests if :mksession saves cursor columns correctly in presence of tab and 
- multibyte characters when fileencoding=utf-8.
- 
- STARTTEST
- :so mbyte.vim
- :if !has('mksession')
- :  e! test.ok
- :  wq! test.out
- :endif
- :set sessionoptions=buffers splitbelow fileencoding=utf-8
- /^start:
- :vsplit
- j16|:split
- j16|:split
- j16|:split
- j8|:split
- j8|:split
- j16|:split
- j16|:split
- j16|:wincmd l
- /^start:
- :set nowrap
- j16|3zl:split
- j016|3zl:split
- j016|3zl:split
- j08|3zl:split
- j08|3zl:split
- j016|3zl:split
- j016|3zl:split
- j016|3zl:split
- :mksession! test.out
- :new test.out
- :v/\(^ *normal! 0\|^ *exe 'normal!\)/d
- :w! test.out
- :qa!
- ENDTEST
- 
- start:
- no multibyte chAracter
- 	one leaDing tab
-     four leadinG spaces
- two		consecutive tabs
- two	tabs	in one line
- one  multibyteCharacter
- a b two multiByte characters
- c1 three mulTibyte characters
--- 0 ----
*** ../vim-8.0.0111/src/testdir/test92.ok	2013-02-26 17:13:48.000000000 +0100
--- src/testdir/test92.ok	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,26 ****
- normal! 016|
- normal! 016|
- normal! 016|
- normal! 08|
- normal! 08|
- normal! 016|
- normal! 016|
- normal! 016|
-   exe 'normal! ' . s:c . '|zs' . 16 . '|'
-   normal! 016|
-   exe 'normal! ' . s:c . '|zs' . 16 . '|'
-   normal! 016|
-   exe 'normal! ' . s:c . '|zs' . 16 . '|'
-   normal! 016|
-   exe 'normal! ' . s:c . '|zs' . 8 . '|'
-   normal! 08|
-   exe 'normal! ' . s:c . '|zs' . 8 . '|'
-   normal! 08|
-   exe 'normal! ' . s:c . '|zs' . 16 . '|'
-   normal! 016|
-   exe 'normal! ' . s:c . '|zs' . 16 . '|'
-   normal! 016|
-   exe 'normal! ' . s:c . '|zs' . 16 . '|'
-   normal! 016|
-   exe 'normal! ' . s:c . '|zs' . 16 . '|'
-   normal! 016|
--- 0 ----
*** ../vim-8.0.0111/src/testdir/test93.in	2013-09-22 14:45:17.000000000 +0200
--- src/testdir/test93.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,48 ****
- vim: set ft=vim fenc=latin1:
- 
- Tests if :mksession saves cursor columns correctly in presence of tab and 
- multibyte characters when fileencoding=latin1.
- 
- STARTTEST
- :so mbyte.vim
- :if !has('mksession')
- :  e! test.ok
- :  wq! test.out
- :endif
- :set sessionoptions=buffers splitbelow fileencoding=latin1
- /^start:
- :vsplit
- j16|:split
- j16|:split
- j16|:split
- j8|:split
- j8|:split
- j16|:split
- j16|:split
- j16|:wincmd l
- /^start:
- :set nowrap
- j16|3zl:split
- j016|3zl:split
- j016|3zl:split
- j08|3zl:split
- j08|3zl:split
- j016|3zl:split
- j016|3zl:split
- j016|3zl:split
- :mksession! test.out
- :new test.out
- :v/\(^ *normal! 0\|^ *exe 'normal!\)/d
- :w! test.out
- :qa!
- ENDTEST
- 
- start:
- no multibyte chAracter
- 	one leaDing tab
-     four leadinG spaces
- two		consecutive tabs
- two	tabs	in one line
- one  multibyteCharacter
- a   two multiByte characters
- A  three mulTibyte characters
--- 0 ----
*** ../vim-8.0.0111/src/testdir/test93.ok	2013-02-26 17:14:02.000000000 +0100
--- src/testdir/test93.ok	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,26 ****
- normal! 016|
- normal! 016|
- normal! 016|
- normal! 08|
- normal! 08|
- normal! 016|
- normal! 016|
- normal! 016|
-   exe 'normal! ' . s:c . '|zs' . 16 . '|'
-   normal! 016|
-   exe 'normal! ' . s:c . '|zs' . 16 . '|'
-   normal! 016|
-   exe 'normal! ' . s:c . '|zs' . 16 . '|'
-   normal! 016|
-   exe 'normal! ' . s:c . '|zs' . 8 . '|'
-   normal! 08|
-   exe 'normal! ' . s:c . '|zs' . 8 . '|'
-   normal! 08|
-   exe 'normal! ' . s:c . '|zs' . 16 . '|'
-   normal! 016|
-   exe 'normal! ' . s:c . '|zs' . 16 . '|'
-   normal! 016|
-   exe 'normal! ' . s:c . '|zs' . 16 . '|'
-   normal! 016|
-   exe 'normal! ' . s:c . '|zs' . 16 . '|'
-   normal! 016|
--- 0 ----
*** ../vim-8.0.0111/src/testdir/test_mksession.vim	2016-12-01 18:46:12.704038446 +0100
--- src/testdir/test_mksession.vim	2016-12-01 18:14:12.216658571 +0100
***************
*** 0 ****
--- 1,104 ----
+ " Test for :mksession, :mkview and :loadview in latin1 encoding
+ 
+ set encoding=latin1
+ scriptencoding latin1
+ 
+ if !has('multi_byte') || !has('mksession')
+   finish
+ endif
+ 
+ func Test_mksession()
+   tabnew
+   let wrap_save = &wrap
+   set sessionoptions=buffers splitbelow fileencoding=latin1
+   call setline(1, [
+     \   'start:',
+     \   'no multibyte chAracter',
+     \   '	one leaDing tab',
+     \   '    four leadinG spaces',
+     \   'two		consecutive tabs',
+     \   'two	tabs	in one line',
+     \   'one  multibyteCharacter',
+     \   'a   two multiByte characters',
+     \   'A  three mulTibyte characters'
+     \ ])
+   let tmpfile = tempname()
+   exec 'w! ' . tmpfile
+   /^start:
+   set wrap
+   vsplit
+   norm! j16|
+   split
+   norm! j16|
+   split
+   norm! j16|
+   split
+   norm! j8|
+   split
+   norm! j8|
+   split
+   norm! j16|
+   split
+   norm! j16|
+   split
+   norm! j16|
+   wincmd l
+ 
+   set nowrap
+   /^start:
+   norm! j16|3zl
+   split
+   norm! j016|3zl
+   split
+   norm! j016|3zl
+   split
+   norm! j08|3zl
+   split
+   norm! j08|3zl
+   split
+   norm! j016|3zl
+   split
+   norm! j016|3zl
+   split
+   norm! j016|3zl
+   split
+   call wincol()
+   mksession! test_mks.out
+   let li = filter(readfile('test_mks.out'), 'v:val =~# "\\(^ *normal! 0\\|^ *exe ''normal!\\)"')
+   let expected = [
+     \   'normal! 016|',
+     \   'normal! 016|',
+     \   'normal! 016|',
+     \   'normal! 08|',
+     \   'normal! 08|',
+     \   'normal! 016|',
+     \   'normal! 016|',
+     \   'normal! 016|',
+     \   "  exe 'normal! ' . s:c . '|zs' . 16 . '|'",
+     \   "  normal! 016|",
+     \   "  exe 'normal! ' . s:c . '|zs' . 16 . '|'",
+     \   "  normal! 016|",
+     \   "  exe 'normal! ' . s:c . '|zs' . 16 . '|'",
+     \   "  normal! 016|",
+     \   "  exe 'normal! ' . s:c . '|zs' . 8 . '|'",
+     \   "  normal! 08|",
+     \   "  exe 'normal! ' . s:c . '|zs' . 8 . '|'",
+     \   "  normal! 08|",
+     \   "  exe 'normal! ' . s:c . '|zs' . 16 . '|'",
+     \   "  normal! 016|",
+     \   "  exe 'normal! ' . s:c . '|zs' . 16 . '|'",
+     \   "  normal! 016|",
+     \   "  exe 'normal! ' . s:c . '|zs' . 16 . '|'",
+     \   "  normal! 016|",
+     \   "  exe 'normal! ' . s:c . '|zs' . 16 . '|'",
+     \   "  normal! 016|"
+     \ ]
+   call assert_equal(expected, li)
+   tabclose!
+ 
+   call delete('test_mks.out')
+   call delete(tmpfile)
+   let &wrap = wrap_save
+ endfunc
+ 
+ " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.0.0111/src/testdir/test_mksession_utf8.vim	2016-12-01 18:46:12.708038420 +0100
--- src/testdir/test_mksession_utf8.vim	2016-12-01 18:14:12.216658571 +0100
***************
*** 0 ****
--- 1,104 ----
+ " Test for :mksession, :mkview and :loadview in utf-8 encoding
+ 
+ set encoding=utf-8
+ scriptencoding utf-8
+ 
+ if !has('multi_byte') || !has('mksession')
+   finish
+ endif
+ 
+ func Test_mksession_utf8()
+   tabnew
+   let wrap_save = &wrap
+   set sessionoptions=buffers splitbelow fileencoding=utf-8
+   call setline(1, [
+     \   'start:',
+     \   'no multibyte chAracter',
+     \   '	one leaDing tab',
+     \   '    four leadinG spaces',
+     \   'two		consecutive tabs',
+     \   'two	tabs	in one line',
+     \   'one  multibyteCharacter',
+     \   'a b two multiByte characters',
+     \   'c1 three mulTibyte characters'
+     \ ])
+   let tmpfile = tempname()
+   exec 'w! ' . tmpfile
+   /^start:
+   set wrap
+   vsplit
+   norm! j16|
+   split
+   norm! j16|
+   split
+   norm! j16|
+   split
+   norm! j8|
+   split
+   norm! j8|
+   split
+   norm! j16|
+   split
+   norm! j16|
+   split
+   norm! j16|
+   wincmd l
+ 
+   set nowrap
+   /^start:
+   norm! j16|3zl
+   split
+   norm! j016|3zl
+   split
+   norm! j016|3zl
+   split
+   norm! j08|3zl
+   split
+   norm! j08|3zl
+   split
+   norm! j016|3zl
+   split
+   norm! j016|3zl
+   split
+   norm! j016|3zl
+   split
+   call wincol()
+   mksession! test_mks.out
+   let li = filter(readfile('test_mks.out'), 'v:val =~# "\\(^ *normal! 0\\|^ *exe ''normal!\\)"')
+   let expected = [
+     \   'normal! 016|',
+     \   'normal! 016|',
+     \   'normal! 016|',
+     \   'normal! 08|',
+     \   'normal! 08|',
+     \   'normal! 016|',
+     \   'normal! 016|',
+     \   'normal! 016|',
+     \   "  exe 'normal! ' . s:c . '|zs' . 16 . '|'",
+     \   "  normal! 016|",
+     \   "  exe 'normal! ' . s:c . '|zs' . 16 . '|'",
+     \   "  normal! 016|",
+     \   "  exe 'normal! ' . s:c . '|zs' . 16 . '|'",
+     \   "  normal! 016|",
+     \   "  exe 'normal! ' . s:c . '|zs' . 8 . '|'",
+     \   "  normal! 08|",
+     \   "  exe 'normal! ' . s:c . '|zs' . 8 . '|'",
+     \   "  normal! 08|",
+     \   "  exe 'normal! ' . s:c . '|zs' . 16 . '|'",
+     \   "  normal! 016|",
+     \   "  exe 'normal! ' . s:c . '|zs' . 16 . '|'",
+     \   "  normal! 016|",
+     \   "  exe 'normal! ' . s:c . '|zs' . 16 . '|'",
+     \   "  normal! 016|",
+     \   "  exe 'normal! ' . s:c . '|zs' . 16 . '|'",
+     \   "  normal! 016|"
+     \ ]
+   call assert_equal(expected, li)
+   tabclose!
+ 
+   call delete('test_mks.out')
+   call delete(tmpfile)
+   let &wrap = wrap_save
+ endfunc
+ 
+ " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.0.0111/src/version.c	2016-12-01 17:57:40.779167445 +0100
--- src/version.c	2016-12-01 18:14:51.496400576 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     112,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
71. You wonder how people walk

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0113
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0113
Problem:    MS-Windows: message box to prompt for saving changes may appear on
            the wrong monitor.
Solution:   Adjust the CenterWindow function. (Ken Takata)
Files:      src/gui_w32.c


*** ../vim-8.0.0112/src/gui_w32.c	2016-11-10 20:01:41.193582919 +0100
--- src/gui_w32.c	2016-12-01 20:16:47.184213794 +0100
***************
*** 2297,2315 ****
  # define GetTextWidthEnc(h, s, l) GetTextWidth((h), (s), (l))
  #endif
  
  /*
   * A quick little routine that will center one window over another, handy for
!  * dialog boxes.  Taken from the Win32SDK samples.
   */
      static BOOL
  CenterWindow(
      HWND hwndChild,
      HWND hwndParent)
  {
!     RECT    rChild, rParent;
!     int     wChild, hChild, wParent, hParent;
!     int     wScreen, hScreen, xNew, yNew;
!     HDC     hdc;
  
      GetWindowRect(hwndChild, &rChild);
      wChild = rChild.right - rChild.left;
--- 2297,2320 ----
  # define GetTextWidthEnc(h, s, l) GetTextWidth((h), (s), (l))
  #endif
  
+ static void get_work_area(RECT *spi_rect);
+ 
  /*
   * A quick little routine that will center one window over another, handy for
!  * dialog boxes.  Taken from the Win32SDK samples and modified for multiple
!  * monitors.
   */
      static BOOL
  CenterWindow(
      HWND hwndChild,
      HWND hwndParent)
  {
!     HMONITOR	    mon;
!     MONITORINFO	    moninfo;
!     RECT	    rChild, rParent, rScreen;
!     int		    wChild, hChild, wParent, hParent;
!     int		    xNew, yNew;
!     HDC		    hdc;
  
      GetWindowRect(hwndChild, &rChild);
      wChild = rChild.right - rChild.left;
***************
*** 2317,2348 ****
  
      /* If Vim is minimized put the window in the middle of the screen. */
      if (hwndParent == NULL || IsMinimized(hwndParent))
! 	SystemParametersInfo(SPI_GETWORKAREA, 0, &rParent, 0);
      else
  	GetWindowRect(hwndParent, &rParent);
      wParent = rParent.right - rParent.left;
      hParent = rParent.bottom - rParent.top;
  
!     hdc = GetDC(hwndChild);
!     wScreen = GetDeviceCaps (hdc, HORZRES);
!     hScreen = GetDeviceCaps (hdc, VERTRES);
!     ReleaseDC(hwndChild, hdc);
! 
!     xNew = rParent.left + ((wParent - wChild) /2);
!     if (xNew < 0)
      {
! 	xNew = 0;
      }
!     else if ((xNew+wChild) > wScreen)
      {
! 	xNew = wScreen - wChild;
!     }
! 
!     yNew = rParent.top	+ ((hParent - hChild) /2);
!     if (yNew < 0)
! 	yNew = 0;
!     else if ((yNew+hChild) > hScreen)
! 	yNew = hScreen - hChild;
  
      return SetWindowPos(hwndChild, NULL, xNew, yNew, 0, 0,
  						   SWP_NOSIZE | SWP_NOZORDER);
--- 2322,2360 ----
  
      /* If Vim is minimized put the window in the middle of the screen. */
      if (hwndParent == NULL || IsMinimized(hwndParent))
! 	get_work_area(&rParent);
      else
  	GetWindowRect(hwndParent, &rParent);
      wParent = rParent.right - rParent.left;
      hParent = rParent.bottom - rParent.top;
  
!     moninfo.cbSize = sizeof(MONITORINFO);
!     mon = MonitorFromWindow(hwndChild, MONITOR_DEFAULTTOPRIMARY);
!     if (mon != NULL && GetMonitorInfo(mon, &moninfo))
      {
! 	rScreen = moninfo.rcWork;
      }
!     else
      {
! 	hdc = GetDC(hwndChild);
! 	rScreen.left = 0;
! 	rScreen.top = 0;
! 	rScreen.right = GetDeviceCaps(hdc, HORZRES);
! 	rScreen.bottom = GetDeviceCaps(hdc, VERTRES);
! 	ReleaseDC(hwndChild, hdc);
!     }
! 
!     xNew = rParent.left + ((wParent - wChild) / 2);
!     if (xNew < rScreen.left)
! 	xNew = rScreen.left;
!     else if ((xNew + wChild) > rScreen.right)
! 	xNew = rScreen.right - wChild;
! 
!     yNew = rParent.top + ((hParent - hChild) / 2);
!     if (yNew < rScreen.top)
! 	yNew = rScreen.top;
!     else if ((yNew + hChild) > rScreen.bottom)
! 	yNew = rScreen.bottom - hChild;
  
      return SetWindowPos(hwndChild, NULL, xNew, yNew, 0, 0,
  						   SWP_NOSIZE | SWP_NOZORDER);
***************
*** 5559,5565 ****
      MONITORINFO	    moninfo;
  
      /* work out which monitor the window is on, and get *it's* work area */
!     mon = MonitorFromWindow(s_hwnd, 1 /*MONITOR_DEFAULTTOPRIMARY*/);
      if (mon != NULL)
      {
  	moninfo.cbSize = sizeof(MONITORINFO);
--- 5571,5577 ----
      MONITORINFO	    moninfo;
  
      /* work out which monitor the window is on, and get *it's* work area */
!     mon = MonitorFromWindow(s_hwnd, MONITOR_DEFAULTTOPRIMARY);
      if (mon != NULL)
      {
  	moninfo.cbSize = sizeof(MONITORINFO);
*** ../vim-8.0.0112/src/version.c	2016-12-01 18:47:06.595684409 +0100
--- src/version.c	2016-12-01 20:18:09.215671446 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     113,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
72. Somebody at IRC just mentioned a way to obtain full motion video without
    a PC using a wireless protocol called NTSC, you wonder how you never
    heard about it

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0114
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0114
Problem:    Coding style not optimal.
Solution:   Add spaces. (Ken Takata)
Files:      src/gui_w32.c, src/os_mswin.c


*** ../vim-8.0.0113/src/gui_w32.c	2016-12-01 20:18:47.243420047 +0100
--- src/gui_w32.c	2016-12-01 20:31:04.638547599 +0100
***************
*** 3551,3562 ****
      filterp = convert_filterW(filter);
  
      vim_memset(&fileStruct, 0, sizeof(OPENFILENAMEW));
! #ifdef OPENFILENAME_SIZE_VERSION_400W
      /* be compatible with Windows NT 4.0 */
      fileStruct.lStructSize = OPENFILENAME_SIZE_VERSION_400W;
! #else
      fileStruct.lStructSize = sizeof(fileStruct);
! #endif
  
      if (title != NULL)
  	titlep = enc_to_utf16(title, NULL);
--- 3551,3562 ----
      filterp = convert_filterW(filter);
  
      vim_memset(&fileStruct, 0, sizeof(OPENFILENAMEW));
! #  ifdef OPENFILENAME_SIZE_VERSION_400W
      /* be compatible with Windows NT 4.0 */
      fileStruct.lStructSize = OPENFILENAME_SIZE_VERSION_400W;
! #  else
      fileStruct.lStructSize = sizeof(fileStruct);
! #  endif
  
      if (title != NULL)
  	titlep = enc_to_utf16(title, NULL);
***************
*** 3593,3602 ****
       * Don't use OFN_OVERWRITEPROMPT, Vim has its own ":confirm" dialog.
       */
      fileStruct.Flags = (OFN_NOCHANGEDIR | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY);
! #ifdef FEAT_SHORTCUT
      if (curbuf->b_p_bin)
  	fileStruct.Flags |= OFN_NODEREFERENCELINKS;
! #endif
      if (saving)
      {
  	if (!GetSaveFileNameW(&fileStruct))
--- 3593,3602 ----
       * Don't use OFN_OVERWRITEPROMPT, Vim has its own ":confirm" dialog.
       */
      fileStruct.Flags = (OFN_NOCHANGEDIR | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY);
! #  ifdef FEAT_SHORTCUT
      if (curbuf->b_p_bin)
  	fileStruct.Flags |= OFN_NODEREFERENCELINKS;
! #  endif
      if (saving)
      {
  	if (!GetSaveFileNameW(&fileStruct))
*** ../vim-8.0.0113/src/os_mswin.c	2016-11-10 17:10:47.494177267 +0100
--- src/os_mswin.c	2016-12-01 20:31:04.638547599 +0100
***************
*** 40,46 ****
  #  include <dlgs.h>
  #  include <winspool.h>
  #  include <commdlg.h>
! #endif
  
  #endif /* PROTO */
  
--- 40,46 ----
  #  include <dlgs.h>
  #  include <winspool.h>
  #  include <commdlg.h>
! # endif
  
  #endif /* PROTO */
  
***************
*** 1619,1625 ****
  
  	if (psettings->n_uncollated_copies == 0)
  	    psettings->n_uncollated_copies = 1;
!     } else {
  	psettings->n_collated_copies = 1;
  	psettings->n_uncollated_copies = 1;
      }
--- 1619,1627 ----
  
  	if (psettings->n_uncollated_copies == 0)
  	    psettings->n_uncollated_copies = 1;
!     }
!     else
!     {
  	psettings->n_collated_copies = 1;
  	psettings->n_uncollated_copies = 1;
      }
*** ../vim-8.0.0113/src/version.c	2016-12-01 20:18:47.243420047 +0100
--- src/version.c	2016-12-01 20:31:31.502370175 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     114,
  /**/

-- 
"Thou shalt not follow the Null Pointer, for at its end Chaos and
Madness lie."

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0115
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0115
Problem:    When building with Cygwin libwinpthread isn't found.
Solution:   Link winpthread statically. (jmmerz, closes #1255, closes #1256)
Files:      src/Make_cyg_ming.mak


*** ../vim-8.0.0114/src/Make_cyg_ming.mak	2016-09-08 20:25:34.000000000 +0200
--- src/Make_cyg_ming.mak	2016-12-01 20:36:04.852560447 +0100
***************
*** 81,86 ****
--- 81,93 ----
  STATIC_STDCPLUS=no
  endif
  
+ 
+ # Link against the shared version of libwinpthread by default.  Set
+ # STATIC_WINPTHREAD to "yes" to link against static version instead.
+ ifndef STATIC_WINPTHREAD
+ STATIC_WINPTHREAD=$(STATIC_STDCPLUS)
+ endif
+ 
  # If the user doesn't want gettext, undefine it.
  ifeq (no, $(GETTEXT))
  GETTEXT=
***************
*** 817,822 ****
--- 824,833 ----
  endif
  endif
  
+ ifeq (yes, $(STATIC_WINPTHREAD))
+ LIB += -Wl,-Bstatic -lwinpthread -Wl,-Bdynamic
+ endif
+ 
  all: $(TARGET) vimrun.exe xxd/xxd.exe install.exe uninstal.exe GvimExt/gvimext.dll
  
  vimrun.exe: vimrun.c
*** ../vim-8.0.0114/src/version.c	2016-12-01 20:32:23.958023740 +0100
--- src/version.c	2016-12-01 20:36:35.892354699 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     115,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
73. You give your dog used motherboards instead of bones

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0116
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0116
Problem:    When reading English help and using CTRl-] the language from
            'helplang' is used.
Solution:   Make help tag jumps keep the language. (Tatsuki, test by Hirohito
            Higashi, closes #1249)
Files:      src/tag.c, src/testdir/test_help_tagjump.vim


*** ../vim-8.0.0115/src/tag.c	2016-12-01 17:25:16.795864620 +0100
--- src/tag.c	2016-12-01 21:25:07.384984712 +0100
***************
*** 742,748 ****
  			/* skip backslash used for escaping a command char or
  			 * a backslash */
  			if (*p == '\\' && (*(p + 1) == *tagp.command
! 				        || *(p + 1) == '\\'))
  			    ++p;
  
  			if (*p == TAB)
--- 742,748 ----
  			/* skip backslash used for escaping a command char or
  			 * a backslash */
  			if (*p == '\\' && (*(p + 1) == *tagp.command
! 					|| *(p + 1) == '\\'))
  			    ++p;
  
  			if (*p == TAB)
***************
*** 1356,1361 ****
--- 1356,1362 ----
      char_u	*help_lang_find = NULL;		/* lang to be found */
      char_u	help_lang[3];			/* lang of current tags file */
      char_u	*saved_pat = NULL;		/* copy of pat[] */
+     int		is_txt = FALSE;			/* flag of file extension */
  #endif
  
      pat_T	orgpat;			/* holds unconverted pattern info */
***************
*** 1388,1394 ****
       */
      switch (curbuf->b_tc_flags ? curbuf->b_tc_flags : tc_flags)
      {
! 	case TC_FOLLOWIC:                break;
  	case TC_IGNORE:    p_ic = TRUE;  break;
  	case TC_MATCH:     p_ic = FALSE; break;
  	case TC_FOLLOWSCS: p_ic = ignorecase(pat); break;
--- 1389,1395 ----
       */
      switch (curbuf->b_tc_flags ? curbuf->b_tc_flags : tc_flags)
      {
! 	case TC_FOLLOWIC:		 break;
  	case TC_IGNORE:    p_ic = TRUE;  break;
  	case TC_MATCH:     p_ic = FALSE; break;
  	case TC_FOLLOWSCS: p_ic = ignorecase(pat); break;
***************
*** 1476,1481 ****
--- 1477,1491 ----
       * When the tag file is case-fold sorted, it is either one or the other.
       * Only ignore case when TAG_NOIC not used or 'ignorecase' set.
       */
+ #ifdef FEAT_MULTI_LANG
+     /* Set a flag if the file extension is .txt */
+     if ((flags & TAG_KEEP_LANG)
+ 	    && help_lang_find == NULL
+ 	    && curbuf->b_fname != NULL
+ 	    && (i = (int)STRLEN(curbuf->b_fname)) > 4
+ 	    && STRICMP(curbuf->b_fname + i - 4, ".txt") == 0)
+ 	is_txt = TRUE;
+ #endif
  #ifdef FEAT_TAG_BINS
      orgpat.regmatch.rm_ic = ((p_ic || !noic)
  				&& (findall || orgpat.headlen == 0 || !p_tbs));
***************
*** 1509,1522 ****
  #ifdef FEAT_MULTI_LANG
  	    if (curbuf->b_help)
  	    {
! 		/* Prefer help tags according to 'helplang'.  Put the
! 		 * two-letter language name in help_lang[]. */
! 		i = (int)STRLEN(tag_fname);
! 		if (i > 3 && tag_fname[i - 3] == '-')
! 		    STRCPY(help_lang, tag_fname + i - 2);
! 		else
  		    STRCPY(help_lang, "en");
! 
  		/* When searching for a specific language skip tags files
  		 * for other languages. */
  		if (help_lang_find != NULL
--- 1519,1537 ----
  #ifdef FEAT_MULTI_LANG
  	    if (curbuf->b_help)
  	    {
! 		/* Keep en if the file extension is .txt*/
! 		if (is_txt)
  		    STRCPY(help_lang, "en");
! 		else
! 		{
! 		    /* Prefer help tags according to 'helplang'.  Put the
! 		     * two-letter language name in help_lang[]. */
! 		    i = (int)STRLEN(tag_fname);
! 		    if (i > 3 && tag_fname[i - 3] == '-')
! 			STRCPY(help_lang, tag_fname + i - 2);
! 		    else
! 			STRCPY(help_lang, "en");
! 		}
  		/* When searching for a specific language skip tags files
  		 * for other languages. */
  		if (help_lang_find != NULL
*** ../vim-8.0.0115/src/testdir/test_help_tagjump.vim	2016-11-17 19:44:56.623679016 +0100
--- src/testdir/test_help_tagjump.vim	2016-12-01 21:23:59.121442847 +0100
***************
*** 141,144 ****
--- 141,176 ----
    endtry
  endfunc
  
+ func Test_help_respect_current_file_lang()
+   try
+     let list = []
+     call s:doc_config_setup()
+ 
+     if has('multi_lang')
+       function s:check_help_file_ext(help_keyword, ext)
+         exec 'help ' . a:help_keyword
+         call assert_equal(a:ext, expand('%:e'))
+         call feedkeys("\<C-]>", 'tx')
+         call assert_equal(a:ext, expand('%:e'))
+         pop
+         helpclose
+       endfunc
+ 
+       set rtp+=Xdir1/doc-ab
+       set rtp+=Xdir1/doc-ja
+ 
+       set helplang=ab
+       call s:check_help_file_ext('test-char', 'abx')
+       call s:check_help_file_ext('test-char@ja', 'jax')
+       set helplang=ab,ja
+       call s:check_help_file_ext('test-char@ja', 'jax')
+       call s:check_help_file_ext('test-char@en', 'txt')
+     endif
+   catch
+     call assert_exception('X')
+   finally
+     call s:doc_config_teardown()
+   endtry
+ endfunc
+ 
  " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.0.0115/src/version.c	2016-12-01 20:37:45.415893903 +0100
--- src/version.c	2016-12-01 21:28:24.051665342 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     116,
  /**/

-- 
Proof techniques #2: Proof by Oddity.
	SAMPLE: To prove that horses have an infinite number of legs.
(1) Horses have an even number of legs.
(2) They have two legs in back and fore legs in front.
(3) This makes a total of six legs, which certainly is an odd number of
    legs for a horse.
(4) But the only number that is both odd and even is infinity.
(5) Therefore, horses must have an infinite number of legs.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0117
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0117
Problem:    Parallel make fails. (J. Lewis Muir)
Solution:   Make sure the objects directory exists. (closes #1259)
Files:      src/Makefile


*** ../vim-8.0.0116/src/Makefile	2016-12-01 18:47:06.595684409 +0100
--- src/Makefile	2016-12-01 21:45:02.864966952 +0100
***************
*** 1684,1704 ****
  	objects/memfile.o \
  	objects/message.o
  
! JSON_TEST_OBJ = $(OBJ_COMMON) \
  	objects/memfile.o \
  	objects/message.o \
  	objects/json_test.o
  
! MEMFILE_TEST_OBJ = $(OBJ_COMMON) \
  	objects/json.o \
  	objects/message.o \
  	objects/memfile_test.o
  
! MESSAGE_TEST_OBJ = $(OBJ_COMMON) \
  	objects/json.o \
  	objects/memfile.o \
  	objects/message_test.o
  
  PRO_AUTO = \
  	arabic.pro \
  	blowfish.pro \
--- 1684,1713 ----
  	objects/memfile.o \
  	objects/message.o
  
! OBJ_JSON_TEST = \
  	objects/memfile.o \
  	objects/message.o \
  	objects/json_test.o
  
! JSON_TEST_OBJ = $(OBJ_COMMON) $(OBJ_JSON_TEST)
! 
! OBJ_MEMFILE_TEST = \
  	objects/json.o \
  	objects/message.o \
  	objects/memfile_test.o
  
! MEMFILE_TEST_OBJ = $(OBJ_COMMON) $(OBJ_MEMFILE_TEST)
! 
! OBJ_MESSAGE_TEST = \
  	objects/json.o \
  	objects/memfile.o \
  	objects/message_test.o
  
+ MESSAGE_TEST_OBJ = $(OBJ_COMMON) $(OBJ_MESSAGE_TEST)
+ 
+ ALL_OBJ = $(OBJ_COMMON) $(OBJ_JSON_TEST) $(OBJ_MEMFILE_TEST) $(OBJ_MESSAGE_TEST)
+ 
+ 
  PRO_AUTO = \
  	arabic.pro \
  	blowfish.pro \
***************
*** 2853,2860 ****
  # commands understand putting object files in another directory, it must be
  # specified for each file separately.
  
! objects:
! 	mkdir objects
  
  objects/arabic.o: arabic.c
  	$(CCC) -o $@ arabic.c
--- 2862,2875 ----
  # commands understand putting object files in another directory, it must be
  # specified for each file separately.
  
! objects objects/.dirstamp:
! 	mkdir -p objects
! 	touch objects/.dirstamp
! 
! # All object files depend on the objects directory, so that parallel make
! # works.  Can't depend on the directory itself, its timestamp changes all the
! # time.
! $(ALL_OBJ): objects/.dirstamp
  
  objects/arabic.o: arabic.c
  	$(CCC) -o $@ arabic.c
*** ../vim-8.0.0116/src/version.c	2016-12-01 21:32:28.678025257 +0100
--- src/version.c	2016-12-01 21:43:16.501686971 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     117,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
75. You start wondering whether you could actually upgrade your brain
    with a Pentium Pro microprocessor 80.  The upgrade works just fine.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0118
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0118
Problem:    "make proto" adds extra function prototype.
Solution:   Add #ifdef.
Files:      src/misc2.c


*** ../vim-8.0.0117/src/misc2.c	2016-12-01 17:25:16.791864646 +0100
--- src/misc2.c	2016-12-01 23:01:08.205892509 +0100
***************
*** 6243,6249 ****
  }
  #endif
  
! #ifdef ELAPSED_TIMEVAL  /* no PROTO here, proto is defined in vim.h */
  /*
   * Return time in msec since "start_tv".
   */
--- 6243,6250 ----
  }
  #endif
  
! #ifndef PROTO  /* proto is defined in vim.h */
! # ifdef ELAPSED_TIMEVAL
  /*
   * Return time in msec since "start_tv".
   */
***************
*** 6256,6264 ****
      return (now_tv.tv_sec - start_tv->tv_sec) * 1000L
  	 + (now_tv.tv_usec - start_tv->tv_usec) / 1000L;
  }
! #endif
  
! #ifdef ELAPSED_TICKCOUNT
  /*
   * Return time in msec since "start_tick".
   */
--- 6257,6265 ----
      return (now_tv.tv_sec - start_tv->tv_sec) * 1000L
  	 + (now_tv.tv_usec - start_tv->tv_usec) / 1000L;
  }
! # endif
  
! # ifdef ELAPSED_TICKCOUNT
  /*
   * Return time in msec since "start_tick".
   */
***************
*** 6269,6272 ****
--- 6270,6274 ----
  
      return (long)now - (long)start_tick;
  }
+ # endif
  #endif
*** ../vim-8.0.0117/src/version.c	2016-12-01 21:46:09.860509973 +0100
--- src/version.c	2016-12-01 22:58:45.350872130 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     118,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
76. Your ISP regards you as a business partner rather than as a customer.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0119
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0119
Problem:    No test for using CTRL-R on the command line.
Solution:   Add a test. (Dominique Pelle) And some more.
Files:      src/testdir/test_cmdline.vim


*** ../vim-8.0.0118/src/testdir/test_cmdline.vim	2016-10-15 15:39:34.689059624 +0200
--- src/testdir/test_cmdline.vim	2016-12-03 14:04:58.806031917 +0100
***************
*** 194,196 ****
--- 194,219 ----
    bwipe!
    call delete('a', 'rf')
  endfunc
+ 
+ func Test_paste_in_cmdline()
+   let @a = "def"
+   call feedkeys(":abc \<C-R>a ghi\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"abc def ghi', @:)
+ 
+   new
+   call setline(1, 'asdf.x /tmp/some verylongword a;b-c*d ')
+ 
+   call feedkeys(":aaa \<C-R>\<C-W> bbb\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"aaa asdf bbb', @:)
+ 
+   call feedkeys("ft:aaa \<C-R>\<C-F> bbb\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"aaa /tmp/some bbb', @:)
+ 
+   set incsearch
+   call feedkeys("fy:aaa veryl\<C-R>\<C-W> bbb\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"aaa verylongword bbb', @:)
+ 
+   call feedkeys("f;:aaa \<C-R>\<C-A> bbb\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"aaa a;b-c*d bbb', @:)
+   bwipe!
+ endfunc
*** ../vim-8.0.0118/src/version.c	2016-12-01 23:03:24.516958281 +0100
--- src/version.c	2016-12-03 13:51:51.679148757 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     119,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
84. Books in your bookcase bear the names Bongo, WinSock and Inside OLE

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0120
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0120
Problem:    Channel test is still flaky on OS X.
Solution:   Set the drop argument to "never".
Files:      src/testdir/test_channel.vim


*** ../vim-8.0.0119/src/testdir/test_channel.vim	2016-12-01 16:41:47.296864891 +0100
--- src/testdir/test_channel.vim	2016-12-03 14:24:40.810300771 +0100
***************
*** 26,32 ****
--- 26,35 ----
  endfunc
  
  func Ch_communicate(port)
+   " Avoid dropping messages, since we don't use a callback here.
+   let s:chopt.drop = 'never'
    let handle = ch_open('localhost:' . a:port, s:chopt)
+   unlet s:chopt.drop
    if ch_status(handle) == "fail"
      call assert_false(1, "Can't open channel")
      return
*** ../vim-8.0.0119/src/version.c	2016-12-03 14:05:44.333734329 +0100
--- src/version.c	2016-12-03 14:25:51.729835509 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     120,
  /**/

-- 
If your nose runs, and your feet smell, you might be upside down.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0121
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0121
Problem:    Setting 'cursorline' changes the curswant column. (Daniel Hahler)
Solution:   Add the P_RWINONLY flag. (closes #1297)
Files:      src/option.c, src/testdir/test_goto.vim


*** ../vim-8.0.0120/src/option.c	2016-11-29 22:10:44.221151470 +0100
--- src/option.c	2016-12-03 15:04:13.766727449 +0100
***************
*** 435,442 ****
  
  				/* when option changed, what to display: */
  #define P_RSTAT		0x1000	/* redraw status lines */
! #define P_RWIN		0x2000	/* redraw current window */
! #define P_RBUF		0x4000	/* redraw current buffer */
  #define P_RALL		0x6000	/* redraw all windows */
  #define P_RCLR		0x7000	/* clear and redraw all */
  
--- 435,442 ----
  
  				/* when option changed, what to display: */
  #define P_RSTAT		0x1000	/* redraw status lines */
! #define P_RWIN		0x2000	/* redraw current window and recompute text */
! #define P_RBUF		0x4000	/* redraw current buffer and recompute text */
  #define P_RALL		0x6000	/* redraw all windows */
  #define P_RCLR		0x7000	/* clear and redraw all */
  
***************
*** 457,462 ****
--- 457,463 ----
  #define P_CURSWANT    0x4000000L /* update curswant required; not needed when
  				  * there is a redraw flag */
  #define P_NDNAME      0x8000000L /* only normal dir name chars allowed */
+ #define P_RWINONLY   0x10000000L /* only redraw current window */
  
  #define ISK_LATIN1  (char_u *)"@,48-57,_,192-255"
  
***************
*** 967,973 ****
  			    (char_u *)NULL, PV_NONE,
  #endif
  			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
!     {"cursorline",   "cul", P_BOOL|P_VI_DEF|P_RWIN,
  #ifdef FEAT_SYN_HL
  			    (char_u *)VAR_WIN, PV_CUL,
  #else
--- 968,974 ----
  			    (char_u *)NULL, PV_NONE,
  #endif
  			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
!     {"cursorline",   "cul", P_BOOL|P_VI_DEF|P_RWINONLY,
  #ifdef FEAT_SYN_HL
  			    (char_u *)VAR_WIN, PV_CUL,
  #else
***************
*** 9055,9060 ****
--- 9056,9063 ----
  	changed_window_setting();
      if (flags & P_RBUF)
  	redraw_curbuf_later(NOT_VALID);
+     if (flags & P_RWINONLY)
+ 	redraw_later(NOT_VALID);
      if (doclear)
  	redraw_all_later(CLEAR);
      else if (all)
*** ../vim-8.0.0120/src/testdir/test_goto.vim	2016-10-09 15:50:45.927932466 +0200
--- src/testdir/test_goto.vim	2016-12-03 15:03:54.458854912 +0100
***************
*** 273,275 ****
--- 273,290 ----
  	\ ]
    call XTest_goto_decl('gd', lines, 5, 10)
  endfunc
+ 
+ " Check that setting 'cursorline' does not change curswant
+ func Test_cursorline_keep_col()
+   new
+   call setline(1, ['long long long line', 'short line'])
+   normal ggfi
+   let pos = getcurpos()
+   normal j
+   set cursorline
+   normal k
+   call assert_equal(pos, getcurpos())
+   bwipe!
+   set nocursorline
+ endfunc
+ 
*** ../vim-8.0.0120/src/version.c	2016-12-03 14:29:01.636589998 +0100
--- src/version.c	2016-12-03 15:01:47.067696037 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     121,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
86. E-mail Deficiency Depression (EDD) forces you to e-mail yourself.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0122
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0122
Problem:    Channel test is still flaky on OS X.
Solution:   Add a short sleep.
Files:      src/testdir/test_channel.py


*** ../vim-8.0.0121/src/testdir/test_channel.py	2016-08-26 17:22:37.000000000 +0200
--- src/testdir/test_channel.py	2016-12-03 15:22:24.811533565 +0100
***************
*** 126,131 ****
--- 126,134 ----
                          print("sending: {0}".format(cmd))
                          self.request.sendall(cmd.encode('utf-8'))
                          response = "ok"
+                         # Need to wait for Vim to give up, otherwise it
+                         # sometimes fails on OS X.
+                         time.sleep(0.2)
                      elif decoded[1] == 'malformed2':
                          cmd = '"unterminated string'
                          print("sending: {0}".format(cmd))
*** ../vim-8.0.0121/src/version.c	2016-12-03 15:13:16.415147422 +0100
--- src/version.c	2016-12-03 15:21:48.731771210 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     122,
  /**/

-- 
Ed's Radiator Shop: The Best Place in Town to Take a Leak.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0123
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0123
Problem:    Modern Sun compilers define "__sun" instead of "sun".
Solution:   Use __sun. (closes #1296)
Files:      src/mbyte.c, src/pty.c, src/os_unixx.h, src/vim.h


*** ../vim-8.0.0122/src/mbyte.c	2016-08-29 22:42:20.000000000 +0200
--- src/mbyte.c	2016-12-03 16:28:33.069347623 +0100
***************
*** 5735,5741 ****
  #endif
  
  #if defined(FEAT_GUI_X11) || defined(PROTO)
! # if defined(XtSpecificationRelease) && XtSpecificationRelease >= 6 && !defined(sun)
  #  define USE_X11R6_XIM
  # endif
  
--- 5735,5741 ----
  #endif
  
  #if defined(FEAT_GUI_X11) || defined(PROTO)
! # if defined(XtSpecificationRelease) && XtSpecificationRelease >= 6 && !defined(SUN_SYSTEM)
  #  define USE_X11R6_XIM
  # endif
  
*** ../vim-8.0.0122/src/pty.c	2016-08-29 22:42:20.000000000 +0200
--- src/pty.c	2016-12-03 16:30:02.416759344 +0100
***************
*** 62,68 ****
  #ifdef sinix
  #undef buf_T
  #endif
! # ifdef sun
  #  include <sys/conf.h>
  # endif
  #endif
--- 62,68 ----
  #ifdef sinix
  #undef buf_T
  #endif
! # ifdef SUN_SYSTEM
  #  include <sys/conf.h>
  # endif
  #endif
***************
*** 87,97 ****
  # include <sys/ptem.h>
  #endif
  
! #if !defined(sun) && !defined(VMS) && !defined(MACOS)
  # include <sys/ioctl.h>
  #endif
  
! #if defined(sun) && defined(LOCKPTY) && !defined(TIOCEXCL)
  # include <sys/ttold.h>
  #endif
  
--- 87,97 ----
  # include <sys/ptem.h>
  #endif
  
! #if !defined(SUN_SYSTEM) && !defined(VMS) && !defined(MACOS)
  # include <sys/ioctl.h>
  #endif
  
! #if defined(SUN_SYSTEM) && defined(LOCKPTY) && !defined(TIOCEXCL)
  # include <sys/ttold.h>
  #endif
  
***************
*** 166,172 ****
  # endif
      if (ioctl(fd, I_PUSH, "ldterm") != 0)
  	return -1;
! # ifdef sun
      if (ioctl(fd, I_PUSH, "ttcompat") != 0)
  	return -1;
  # endif
--- 166,172 ----
  # endif
      if (ioctl(fd, I_PUSH, "ldterm") != 0)
  	return -1;
! # ifdef SUN_SYSTEM
      if (ioctl(fd, I_PUSH, "ttcompat") != 0)
  	return -1;
  # endif
***************
*** 391,397 ****
  		continue;
  	    }
  #endif
! #if defined(sun) && defined(TIOCGPGRP) && !defined(SUNOS3)
  	    /* Hack to ensure that the slave side of the pty is
  	     * unused. May not work in anything other than SunOS4.1
  	     */
--- 391,397 ----
  		continue;
  	    }
  #endif
! #if defined(SUN_SYSTEM) && defined(TIOCGPGRP) && !defined(SUNOS3)
  	    /* Hack to ensure that the slave side of the pty is
  	     * unused. May not work in anything other than SunOS4.1
  	     */
*** ../vim-8.0.0122/src/os_unixx.h	2016-08-29 22:42:20.000000000 +0200
--- src/os_unixx.h	2016-12-03 16:39:47.200909192 +0100
***************
*** 17,24 ****
  # define signal sigset
  #endif
  
!    /* sun's sys/ioctl.h redefines symbols from termio world */
! #if defined(HAVE_SYS_IOCTL_H) && !defined(sun)
  # include <sys/ioctl.h>
  #endif
  
--- 17,24 ----
  # define signal sigset
  #endif
  
!    /* Sun's sys/ioctl.h redefines symbols from termio world */
! #if defined(HAVE_SYS_IOCTL_H) && !defined(SUN_SYSTEM)
  # include <sys/ioctl.h>
  #endif
  
*** ../vim-8.0.0122/src/vim.h	2016-12-01 17:25:16.795864620 +0100
--- src/vim.h	2016-12-03 16:32:05.895946348 +0100
***************
*** 268,273 ****
--- 268,278 ----
  # define UNUSED
  #endif
  
+ /* Used to check for "sun", "__sun" is used by newer compilers. */
+ #if defined(__sun)
+ # define SUN_SYSTEM
+ #endif
+ 
  /* if we're compiling in C++ (currently only KVim), the system
   * headers must have the correct prototypes or nothing will build.
   * conversely, our prototypes might clash due to throw() specifiers and
***************
*** 2487,2493 ****
  #define FNE_INCL_BR	1	/* include [] in name */
  #define FNE_CHECK_START	2	/* check name starts with valid character */
  
! #if (defined(sun) || defined(__FreeBSD__) || defined(__FreeBSD_kernel__)) \
  	&& defined(S_ISCHR)
  # define OPEN_CHR_FILES
  #endif
--- 2492,2498 ----
  #define FNE_INCL_BR	1	/* include [] in name */
  #define FNE_CHECK_START	2	/* check name starts with valid character */
  
! #if (defined(SUN_SYSTEM) || defined(__FreeBSD__) || defined(__FreeBSD_kernel__)) \
  	&& defined(S_ISCHR)
  # define OPEN_CHR_FILES
  #endif
*** ../vim-8.0.0122/src/version.c	2016-12-03 15:23:36.567060983 +0100
--- src/version.c	2016-12-03 16:40:28.632636420 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     123,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
89. In addition to your e-mail address being on your business
    cards you even have your own domain.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0124
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0124
Problem:    Internal error for assert_inrange(1, 1).
Solution:   Adjust number of allowed arguments. (Dominique Pelle)
Files:      src/evalfunc.c, src/testdir/test_assert.vim


*** ../vim-8.0.0123/src/evalfunc.c	2016-12-01 15:34:04.087413921 +0100
--- src/evalfunc.c	2016-12-04 13:35:51.062002139 +0100
***************
*** 471,477 ****
      {"assert_exception", 1, 2, f_assert_exception},
      {"assert_fails",	1, 2, f_assert_fails},
      {"assert_false",	1, 2, f_assert_false},
!     {"assert_inrange",	2, 3, f_assert_inrange},
      {"assert_match",	2, 3, f_assert_match},
      {"assert_notequal",	2, 3, f_assert_notequal},
      {"assert_notmatch",	2, 3, f_assert_notmatch},
--- 471,477 ----
      {"assert_exception", 1, 2, f_assert_exception},
      {"assert_fails",	1, 2, f_assert_fails},
      {"assert_false",	1, 2, f_assert_false},
!     {"assert_inrange",	3, 4, f_assert_inrange},
      {"assert_match",	2, 3, f_assert_match},
      {"assert_notequal",	2, 3, f_assert_notequal},
      {"assert_notmatch",	2, 3, f_assert_notmatch},
*** ../vim-8.0.0123/src/testdir/test_assert.vim	2016-07-23 15:13:09.000000000 +0200
--- src/testdir/test_assert.vim	2016-12-04 13:36:28.425758026 +0100
***************
*** 117,122 ****
--- 117,124 ----
    call assert_inrange(5, 7, 8)
    call assert_match("Expected range 5 - 7, but got 8", v:errors[0])
    call remove(v:errors, 0)
+ 
+   call assert_fails('call assert_inrange(1, 1)', 'E119:')
  endfunc
  
  func Test_user_is_happy()
*** ../vim-8.0.0123/src/version.c	2016-12-03 16:40:44.432532400 +0100
--- src/version.c	2016-12-04 13:35:14.590240433 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     124,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
91. It's Saturday afternoon in the middle of May and you
    are on computer.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0125
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0125
Problem:    Not enough testing for entering Ex commands.
Solution:   Add test for CTRL-\ e {expr}. (Dominique Pelle)
Files:      src/testdir/test_cmdline.vim


*** ../vim-8.0.0124/src/testdir/test_cmdline.vim	2016-12-03 14:05:44.333734329 +0100
--- src/testdir/test_cmdline.vim	2016-12-09 18:39:54.928321403 +0100
***************
*** 215,219 ****
--- 215,236 ----
  
    call feedkeys("f;:aaa \<C-R>\<C-A> bbb\<C-B>\"\<CR>", 'tx')
    call assert_equal('"aaa a;b-c*d bbb', @:)
+ 
+   call feedkeys(":\<C-\>etoupper(getline(1))\<CR>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"ASDF.X /TMP/SOME VERYLONGWORD A;B-C*D ', @:)
    bwipe!
  endfunc
+ 
+ func Test_remove_char_in_cmdline()
+   call feedkeys(":abc def\<S-Left>\<Del>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"abc ef', @:)
+ 
+   call feedkeys(":abc def\<S-Left>\<BS>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"abcdef', @:)
+ 
+   call feedkeys(":abc def ghi\<S-Left>\<C-W>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"abc ghi', @:)
+ 
+   call feedkeys(":abc def\<S-Left>\<C-U>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"def', @:)
+ endfunc
*** ../vim-8.0.0124/src/version.c	2016-12-04 13:37:38.425300719 +0100
--- src/version.c	2016-12-09 18:41:04.183868270 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     125,
  /**/

-- 
From "know your smileys":
 :-X	My lips are sealed

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0126
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0126
Problem:    Display problem with 'foldcolumn' and a wide character.
            (esiegerman)
Solution:   Don't use "extra" but an allocated buffer. (Christian Brabandt,
            closes #1310)
Files:      src/screen.c, src/testdir/Make_all.mak, src/Makefile,
            src/testdir/test_display.vim


*** ../vim-8.0.0125/src/screen.c	2016-11-17 19:32:17.897024245 +0100
--- src/screen.c	2016-12-09 19:25:26.466245177 +0100
***************
*** 3649,3661 ****
  		draw_state = WL_FOLD;
  		if (fdc > 0)
  		{
! 		    /* Draw the 'foldcolumn'. */
! 		    fill_foldcolumn(extra, wp, FALSE, lnum);
! 		    n_extra = fdc;
! 		    p_extra = extra;
! 		    p_extra[n_extra] = NUL;
! 		    c_extra = NUL;
! 		    char_attr = hl_attr(HLF_FC);
  		}
  	    }
  #endif
--- 3649,3667 ----
  		draw_state = WL_FOLD;
  		if (fdc > 0)
  		{
! 		    /* Draw the 'foldcolumn'.  Allocate a buffer, "extra" may
! 		     * already be in used. */
! 		    p_extra_free = alloc(12 + 1);
! 
! 		    if (p_extra_free != NULL)
! 		    {
! 			fill_foldcolumn(p_extra_free, wp, FALSE, lnum);
! 			n_extra = fdc;
! 			p_extra_free[n_extra] = NUL;
! 			p_extra = p_extra_free;
! 			c_extra = NUL;
! 			char_attr = hl_attr(HLF_FC);
! 		    }
  		}
  	    }
  #endif
*** ../vim-8.0.0125/src/testdir/Make_all.mak	2016-12-01 18:47:06.595684409 +0100
--- src/testdir/Make_all.mak	2016-12-09 19:14:49.522481488 +0100
***************
*** 148,153 ****
--- 148,154 ----
  	    test_cscope.res \
  	    test_diffmode.res \
  	    test_digraph.res \
+ 	    test_display.res \
  	    test_farsi.res \
  	    test_fnameescape.res \
  	    test_gf.res \
*** ../vim-8.0.0125/src/Makefile	2016-12-01 21:46:09.860509973 +0100
--- src/Makefile	2016-12-09 19:16:20.617879697 +0100
***************
*** 2085,2090 ****
--- 2091,2097 ----
  	test_delete \
  	test_diffmode \
  	test_digraph \
+ 	test_display \
  	test_ex_undo \
  	test_execute_func \
  	test_expand \
*** ../vim-8.0.0125/src/testdir/test_display.vim	2016-12-09 19:27:38.997358330 +0100
--- src/testdir/test_display.vim	2016-12-09 19:14:49.522481488 +0100
***************
*** 0 ****
--- 1,37 ----
+ " Test for displaying stuff
+ if !has('gui_running') && has('unix')
+   set term=ansi
+ endif
+ 
+ function! s:screenline(lnum, nr) abort
+   let line = []
+   for j in range(a:nr)
+     for c in range(1, winwidth(0))
+         call add(line, nr2char(screenchar(a:lnum+j, c)))
+     endfor
+     call add(line, "\n")
+   endfor
+   return join(line, '')
+ endfunction
+ 
+ function! Test_display_foldcolumn()
+   new
+   vnew
+   vert resize 25
+ 
+   1put='e more noise blah blah more stuff here'
+ 
+   let expect = "e more noise blah blah<82\n> more stuff here        \n"
+ 
+   call cursor(2, 1)
+   norm! zt
+   redraw!
+   call assert_equal(expect, s:screenline(1,2))
+   set fdc=2
+   redraw!
+   let expect = "  e more noise blah blah<\n  82> more stuff here    \n"
+   call assert_equal(expect, s:screenline(1,2))
+ 
+   quit!
+   quit!
+ endfunction
*** ../vim-8.0.0125/src/version.c	2016-12-09 18:42:16.415395684 +0100
--- src/version.c	2016-12-09 19:25:37.470171530 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     126,
  /**/

-- 
From "know your smileys":
 8<}}	Glasses, big nose, beard

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0127
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0127
Problem:    Cancelling completion still inserts text when formatting is done 
            for 'textwidth'. (lacygoill)
Solution:   Don't format when CTRL-E was typed. (Hirohito Higashi,
            closes #1312)
Files:      src/edit.c, src/testdir/test_popup.vim


*** ../vim-8.0.0126/src/edit.c	2016-11-10 20:01:41.185582969 +0100
--- src/edit.c	2016-12-09 19:35:16.822297340 +0100
***************
*** 3875,3881 ****
  		if (prev_col > 0)
  		    dec_cursor();
  		/* only format when something was inserted */
! 		if (!arrow_used && !ins_need_undo)
  		    insertchar(NUL, 0, -1);
  		if (prev_col > 0
  			     && ml_get_curline()[curwin->w_cursor.col] != NUL)
--- 3875,3881 ----
  		if (prev_col > 0)
  		    dec_cursor();
  		/* only format when something was inserted */
! 		if (!arrow_used && !ins_need_undo && c != Ctrl_E)
  		    insertchar(NUL, 0, -1);
  		if (prev_col > 0
  			     && ml_get_curline()[curwin->w_cursor.col] != NUL)
*** ../vim-8.0.0126/src/testdir/test_popup.vim	2016-10-29 14:37:51.970378370 +0200
--- src/testdir/test_popup.vim	2016-12-09 19:35:16.822297340 +0100
***************
*** 464,467 ****
--- 464,485 ----
    set completeopt&
  endfunc
  
+ " <C-E> - select original typed text before the completion started without
+ " auto-wrap text.
+ func Test_completion_ctrl_e_without_autowrap()
+   new
+   let tw_save=&tw
+   set tw=78
+   let li = [
+         \ '"                                                        zzz',
+         \ '" zzzyyyyyyyyyyyyyyyyyyy']
+   call setline(1, li)
+   0
+   call feedkeys("A\<C-X>\<C-N>\<C-E>\<Esc>", "tx")
+   call assert_equal(li, getline(1, '$'))
+ 
+   let &tw=tw_save
+   q!
+ endfunc
+ 
  " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.0.0126/src/version.c	2016-12-09 19:28:33.580993178 +0100
--- src/version.c	2016-12-09 19:35:41.894129823 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     127,
  /**/

-- 
From "know your smileys":
 8-O 	"Omigod!!" (done "rm -rf *" ?)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0128
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0128
Problem:    Display test fails on MS-Windows.
Solution:   Set 'isprint' to "@".
Files:      src/testdir/test_display.vim


*** ../vim-8.0.0127/src/testdir/test_display.vim	2016-12-09 19:28:33.580993178 +0100
--- src/testdir/test_display.vim	2016-12-09 19:50:18.456367330 +0100
***************
*** 18,23 ****
--- 18,25 ----
    new
    vnew
    vert resize 25
+   call assert_equal(25, winwidth(winnr()))
+   set isprint=@
  
    1put='e more noise blah blah more stuff here'
  
*** ../vim-8.0.0127/src/version.c	2016-12-09 19:36:52.357659077 +0100
--- src/version.c	2016-12-09 19:51:02.883983328 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     128,
  /**/

-- 
From "know your smileys":
 %-)	After staring at screen for 15 hours

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0129
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0129
Problem:    Parallel make still doesn't work. (Lewis Muir)
Solution:   Define OBJ_MAIN.
Files:      src/Makefile


*** ../vim-8.0.0128/src/Makefile	2016-12-09 19:28:33.580993178 +0100
--- src/Makefile	2016-12-09 19:16:20.617879697 +0100
***************
*** 1678,1689 ****
  	$(WSDEBUG_OBJ)
  
  # The files included by tests are not in OBJ_COMMON.
! OBJ = $(OBJ_COMMON) \
  	objects/json.o \
  	objects/main.o \
  	objects/memfile.o \
  	objects/message.o
  
  OBJ_JSON_TEST = \
  	objects/memfile.o \
  	objects/message.o \
--- 1678,1691 ----
  	$(WSDEBUG_OBJ)
  
  # The files included by tests are not in OBJ_COMMON.
! OBJ_MAIN = \
  	objects/json.o \
  	objects/main.o \
  	objects/memfile.o \
  	objects/message.o
  
+ OBJ = $(OBJ_COMMON) $(OBJ_MAIN)
+ 
  OBJ_JSON_TEST = \
  	objects/memfile.o \
  	objects/message.o \
***************
*** 1705,1711 ****
  
  MESSAGE_TEST_OBJ = $(OBJ_COMMON) $(OBJ_MESSAGE_TEST)
  
! ALL_OBJ = $(OBJ_COMMON) $(OBJ_JSON_TEST) $(OBJ_MEMFILE_TEST) $(OBJ_MESSAGE_TEST)
  
  
  PRO_AUTO = \
--- 1707,1717 ----
  
  MESSAGE_TEST_OBJ = $(OBJ_COMMON) $(OBJ_MESSAGE_TEST)
  
! ALL_OBJ = $(OBJ_COMMON) \
! 	  $(OBJ_MAIN) \
! 	  $(OBJ_JSON_TEST) \
! 	  $(OBJ_MEMFILE_TEST) \
! 	  $(OBJ_MESSAGE_TEST)
  
  
  PRO_AUTO = \
***************
*** 2863,2869 ****
  # commands understand putting object files in another directory, it must be
  # specified for each file separately.
  
! objects objects/.dirstamp:
  	mkdir -p objects
  	touch objects/.dirstamp
  
--- 2869,2877 ----
  # commands understand putting object files in another directory, it must be
  # specified for each file separately.
  
! objects: objects/.dirstamp
! 
! objects/.dirstamp:
  	mkdir -p objects
  	touch objects/.dirstamp
  
*** ../vim-8.0.0128/src/version.c	2016-12-09 19:51:45.715697789 +0100
--- src/version.c	2016-12-09 19:56:01.493992721 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     129,
  /**/

-- 
From "know your smileys":
 <>:-)	Bishop

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0130
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0130
Problem:    Configure uses "ushort" while the Vim code doesn't.
Solution:   Use "unsigned short" instead. (Fredrik Fornwall, closes #1314)
Files:      src/configure.ac, src/auto/configure


*** ../vim-8.0.0129/src/configure.ac	2016-12-01 17:25:16.791864646 +0100
--- src/configure.ac	2016-12-09 20:07:18.693451885 +0100
***************
*** 1995,2001 ****
  	/* Check bitfields */
  	struct nbbuf {
  	unsigned int  initDone:1;
! 	ushort signmaplen;
  	};
  	    ], [
  		/* Check creating a socket. */
--- 1995,2001 ----
  	/* Check bitfields */
  	struct nbbuf {
  	unsigned int  initDone:1;
! 	unsigned short signmaplen;
  	};
  	    ], [
  		/* Check creating a socket. */
*** ../vim-8.0.0129/src/auto/configure	2016-10-18 16:27:20.540756047 +0200
--- src/auto/configure	2016-12-09 20:08:17.497057901 +0100
***************
*** 7411,7417 ****
  	/* Check bitfields */
  	struct nbbuf {
  	unsigned int  initDone:1;
! 	ushort signmaplen;
  	};
  
  int
--- 7411,7417 ----
  	/* Check bitfields */
  	struct nbbuf {
  	unsigned int  initDone:1;
! 	unsigned short signmaplen;
  	};
  
  int
***************
*** 12000,12007 ****
  
  fi
  
! for ac_func in bcmp fchdir fchown fsync getcwd getpseudotty \
! 	getpwent getpwnam getpwuid getrlimit gettimeofday getwd lstat memcmp \
  	memset mkdtemp nanosleep opendir putenv qsort readlink select setenv \
  	setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction \
  	sigprocmask sigvec strcasecmp strerror strftime stricmp strncasecmp \
--- 12000,12007 ----
  
  fi
  
! for ac_func in fchdir fchown fsync getcwd getpseudotty \
! 	getpwent getpwnam getpwuid getrlimit gettimeofday getwd lstat \
  	memset mkdtemp nanosleep opendir putenv qsort readlink select setenv \
  	setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction \
  	sigprocmask sigvec strcasecmp strerror strftime stricmp strncasecmp \
*** ../vim-8.0.0129/src/version.c	2016-12-09 19:57:11.053525977 +0100
--- src/version.c	2016-12-09 20:08:14.549077651 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     130,
  /**/

-- 
From "know your smileys":
 +<(:-) The Pope

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0131
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0131
Problem:    Not enough test coverage for syntax commands.
Solution:   Add more tests. (Dominique Pelle)
Files:      src/testdir/test_syntax.vim


*** ../vim-8.0.0130/src/testdir/test_syntax.vim	2016-04-20 12:30:11.000000000 +0200
--- src/testdir/test_syntax.vim	2016-12-11 15:11:04.248529676 +0100
***************
*** 54,60 ****
    setlocal isk-=_
    call assert_equal('DLTD_BY', GetSyntaxItem('DLTD'))
    /\<D\k\+\>/:norm! ygn
!   let b2=@0
    call assert_equal('DLTD', @0)
  
    syn iskeyword clear
--- 54,60 ----
    setlocal isk-=_
    call assert_equal('DLTD_BY', GetSyntaxItem('DLTD'))
    /\<D\k\+\>/:norm! ygn
!   let b2 = @0
    call assert_equal('DLTD', @0)
  
    syn iskeyword clear
***************
*** 80,82 ****
--- 80,158 ----
    call assert_true(exists('g:gotit'))
    call delete('Xsomefile')
  endfunc
+ 
+ func Test_syntime()
+   if !has('profile')
+     finish
+   endif
+ 
+   syntax on
+   syntime on
+   let a = execute('syntime report')
+   call assert_equal("\nNo Syntax items defined for this buffer", a)
+ 
+   view ../memfile_test.c
+   setfiletype cpp
+   redraw
+   let a = execute('syntime report')
+   call assert_match('^  TOTAL *COUNT *MATCH *SLOWEST *AVERAGE *NAME *PATTERN', a)
+   call assert_match(' \d*\.\d* \+[^0]\d* .* cppRawString ', a)
+   call assert_match(' \d*\.\d* \+[^0]\d* .* cppNumber ', a)
+ 
+   syntime off
+   syntime clear
+   let a = execute('syntime report')
+   call assert_match('^  TOTAL *COUNT *MATCH *SLOWEST *AVERAGE *NAME *PATTERN', a)
+   call assert_notmatch('.* cppRawString *', a)
+   call assert_notmatch('.* cppNumber*', a)
+   call assert_notmatch('[1-9]', a)
+ 
+   call assert_fails('syntime abc', 'E475')
+ 
+   syntax clear
+   let a = execute('syntime report')
+   call assert_equal("\nNo Syntax items defined for this buffer", a)
+ 
+   bd
+ endfunc
+ 
+ func Test_syntax_list()
+   syntax on
+   let a = execute('syntax list')
+   call assert_equal("\nNo Syntax items defined for this buffer", a)
+ 
+   view ../memfile_test.c
+   setfiletype c
+ 
+   let a = execute('syntax list')
+   call assert_match('cInclude*', a)
+   call assert_match('cDefine', a)
+ 
+   let a = execute('syntax list cDefine')
+   call assert_notmatch('cInclude*', a)
+   call assert_match('cDefine', a)
+   call assert_match(' links to Macro$', a)
+ 
+   call assert_fails('syntax list ABCD', 'E28:')
+   call assert_fails('syntax list @ABCD', 'E392:')
+ 
+   syntax clear
+   let a = execute('syntax list')
+   call assert_equal("\nNo Syntax items defined for this buffer", a)
+ 
+   bd
+ endfunc
+ 
+ func Test_syntax_completion()
+   call feedkeys(":syn \<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"syn case clear cluster conceal enable include iskeyword keyword list manual match off on region reset spell sync', @:)
+ 
+   call feedkeys(":syn case \<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"syn case ignore match', @:)
+ 
+   call feedkeys(":syn list \<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_match('^"syn list Boolean Character ', @:)
+ 
+   call feedkeys(":syn match \<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_match('^"syn match Boolean Character ', @:)
+ endfunc
*** ../vim-8.0.0130/src/version.c	2016-12-09 20:11:22.371819553 +0100
--- src/version.c	2016-12-11 14:57:30.105830445 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     131,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
92. It takes you two hours to check all 14 of your mailboxes.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0132
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0132 (after 8.0.0131)
Problem:    Test fails because of using :finish.
Solution:   Change to return.
Files:      src/testdir/test_syntax.vim


*** ../vim-8.0.0131/src/testdir/test_syntax.vim	2016-12-11 15:11:13.912466773 +0100
--- src/testdir/test_syntax.vim	2016-12-11 15:23:38.987571387 +0100
***************
*** 83,89 ****
  
  func Test_syntime()
    if !has('profile')
!     finish
    endif
  
    syntax on
--- 83,89 ----
  
  func Test_syntime()
    if !has('profile')
!     return
    endif
  
    syntax on
*** ../vim-8.0.0131/src/version.c	2016-12-11 15:11:13.916466747 +0100
--- src/version.c	2016-12-11 15:24:31.851223061 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     132,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
93. New mail alarm on your palmtop annoys other churchgoers.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0133
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0133
Problem:    "2;'(" causes ml_get errors in an empty buffer.  (Dominique Pelle)
Solution:   Check the cursor line earlier.
Files:      src/ex_docmd.c, src/testdir/test_cmdline.vim


*** ../vim-8.0.0132/src/ex_docmd.c	2016-11-15 21:16:46.750453046 +0100
--- src/ex_docmd.c	2016-12-11 21:26:08.215361024 +0100
***************
*** 2277,2283 ****
--- 2277,2287 ----
  	if (*ea.cmd == ';')
  	{
  	    if (!ea.skip)
+ 	    {
  		curwin->w_cursor.lnum = ea.line2;
+ 		/* don't leave the cursor on an illegal line */
+ 		check_cursor_lnum();
+ 	    }
  	}
  	else if (*ea.cmd != ',')
  	    break;
***************
*** 2293,2301 ****
  	    ea.addr_count = 0;
      }
  
-     /* Don't leave the cursor on an illegal line (caused by ';') */
-     check_cursor_lnum();
- 
  /*
   * 5. Parse the command.
   */
--- 2297,2302 ----
*** ../vim-8.0.0132/src/testdir/test_cmdline.vim	2016-12-09 18:42:16.411395711 +0100
--- src/testdir/test_cmdline.vim	2016-12-11 21:23:04.124601674 +0100
***************
*** 234,236 ****
--- 234,243 ----
    call feedkeys(":abc def\<S-Left>\<C-U>\<C-B>\"\<CR>", 'tx')
    call assert_equal('"def', @:)
  endfunc
+ 
+ func Test_illegal_address()
+   new
+   2;'(
+   2;')
+   quit
+ endfunc
*** ../vim-8.0.0132/src/version.c	2016-12-11 15:24:45.015136329 +0100
--- src/version.c	2016-12-11 21:34:04.132159590 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     133,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
100. The most exciting sporting events you noticed during summer 1996
    was Netscape vs. Microsoft.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0134
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0134
Problem:    Null pointer access reported by UBsan.
Solution:   Check curwin->w_buffer is not NULL. (Yegappan Lakshmanan)
Files:      src/ex_cmds.c


*** ../vim-8.0.0133/src/ex_cmds.c	2016-11-10 18:16:30.077477227 +0100
--- src/ex_cmds.c	2016-12-14 21:40:47.757907072 +0100
***************
*** 3967,3973 ****
  		     * <VN> We could instead free the synblock
  		     * and re-attach to buffer, perhaps.
  		     */
! 		    if (curwin->w_s == &(curwin->w_buffer->b_s))
  			curwin->w_s = &(buf->b_s);
  #endif
  		    curwin->w_buffer = buf;
--- 3967,3974 ----
  		     * <VN> We could instead free the synblock
  		     * and re-attach to buffer, perhaps.
  		     */
! 		    if (curwin->w_buffer != NULL
! 			    && curwin->w_s == &(curwin->w_buffer->b_s))
  			curwin->w_s = &(buf->b_s);
  #endif
  		    curwin->w_buffer = buf;
*** ../vim-8.0.0133/src/version.c	2016-12-11 21:34:18.156065286 +0100
--- src/version.c	2016-12-14 21:40:08.170191045 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     134,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
117. You are more comfortable typing in html.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0135
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0135
Problem:    An address relative to the current line, ":.,+3y", does not work
            properly on a closed fold. (Efraim Yawitz)
Solution:   Correct for including the closed fold. (Christian Brabandt)
Files:      src/ex_docmd.c, src/testdir/test_fold.vim,
            src/testdir/Make_all.mak, src/Makefile


*** ../vim-8.0.0134/src/ex_docmd.c	2016-12-11 21:34:18.156065286 +0100
--- src/ex_docmd.c	2017-01-02 14:05:08.356404137 +0100
***************
*** 137,143 ****
  #endif
  
  static int	check_more(int, int);
! static linenr_T get_address(exarg_T *, char_u **, int addr_type, int skip, int to_other_file);
  static void	get_flags(exarg_T *eap);
  #if !defined(FEAT_PERL) \
  	|| !defined(FEAT_PYTHON) || !defined(FEAT_PYTHON3) \
--- 137,143 ----
  #endif
  
  static int	check_more(int, int);
! static linenr_T get_address(exarg_T *, char_u **, int addr_type, int skip, int to_other_file, int address_count);
  static void	get_flags(exarg_T *eap);
  #if !defined(FEAT_PERL) \
  	|| !defined(FEAT_PYTHON) || !defined(FEAT_PYTHON3) \
***************
*** 1791,1796 ****
--- 1791,1797 ----
      cmdmod_T		save_cmdmod;
      int			ni;			/* set when Not Implemented */
      char_u		*cmd;
+     int			address_count = 1;
  
      vim_memset(&ea, 0, sizeof(ea));
      ea.line1 = 1;
***************
*** 2015,2021 ****
  			{
  #ifdef FEAT_WINDOWS
  			    long tabnr = get_address(&ea, &ea.cmd, ADDR_TABS,
! 								ea.skip, FALSE);
  			    if (tabnr == MAXLNUM)
  				cmdmod.tab = tabpage_index(curtab) + 1;
  			    else
--- 2016,2022 ----
  			{
  #ifdef FEAT_WINDOWS
  			    long tabnr = get_address(&ea, &ea.cmd, ADDR_TABS,
! 							    ea.skip, FALSE, 1);
  			    if (tabnr == MAXLNUM)
  				cmdmod.tab = tabpage_index(curtab) + 1;
  			    else
***************
*** 2175,2181 ****
  	}
  	ea.cmd = skipwhite(ea.cmd);
  	lnum = get_address(&ea, &ea.cmd, ea.addr_type, ea.skip,
! 							  ea.addr_count == 0);
  	if (ea.cmd == NULL)		    /* error detected */
  	    goto doend;
  	if (lnum == MAXLNUM)
--- 2176,2182 ----
  	}
  	ea.cmd = skipwhite(ea.cmd);
  	lnum = get_address(&ea, &ea.cmd, ea.addr_type, ea.skip,
! 					  ea.addr_count == 0, address_count++);
  	if (ea.cmd == NULL)		    /* error detected */
  	    goto doend;
  	if (lnum == MAXLNUM)
***************
*** 4363,4369 ****
      char_u	**ptr,
      int		addr_type,  /* flag: one of ADDR_LINES, ... */
      int		skip,	    /* only skip the address, don't use it */
!     int		to_other_file)  /* flag: may jump to other file */
  {
      int		c;
      int		i;
--- 4364,4371 ----
      char_u	**ptr,
      int		addr_type,  /* flag: one of ADDR_LINES, ... */
      int		skip,	    /* only skip the address, don't use it */
!     int		to_other_file,  /* flag: may jump to other file */
!     int		address_count)	    /* 1 for first address, >1 after comma */
  {
      int		c;
      int		i;
***************
*** 4639,4648 ****
  		    || addr_type == ADDR_BUFFERS)
  		lnum = compute_buffer_local_count(
  				    addr_type, lnum, (i == '-') ? -1 * n : n);
- 	    else if (i == '-')
- 		lnum -= n;
  	    else
! 		lnum += n;
  	}
      } while (*cmd == '/' || *cmd == '?');
  
--- 4641,4660 ----
  		    || addr_type == ADDR_BUFFERS)
  		lnum = compute_buffer_local_count(
  				    addr_type, lnum, (i == '-') ? -1 * n : n);
  	    else
! 	    {
! #ifdef FEAT_FOLDING
! 		/* Relative line addressing, need to adjust for folded lines
! 		 * now, but only do it after the first address. */
! 		if (addr_type == ADDR_LINES && (i == '-' || i == '+')
! 			&& address_count >= 2)
! 		    (void)hasFolding(lnum, NULL, &lnum);
! #endif
! 		if (i == '-')
! 		    lnum -= n;
! 		else
! 		    lnum += n;
! 	    }
  	}
      } while (*cmd == '/' || *cmd == '?');
  
***************
*** 9301,9307 ****
  {
      long	n;
  
!     n = get_address(eap, &eap->arg, eap->addr_type, FALSE, FALSE);
      if (eap->arg == NULL)	    /* error detected */
      {
  	eap->nextcmd = NULL;
--- 9313,9319 ----
  {
      long	n;
  
!     n = get_address(eap, &eap->arg, eap->addr_type, FALSE, FALSE, 1);
      if (eap->arg == NULL)	    /* error detected */
      {
  	eap->nextcmd = NULL;
*** ../vim-8.0.0134/src/testdir/test_fold.vim	2017-01-02 14:24:48.152222060 +0100
--- src/testdir/test_fold.vim	2017-01-02 13:55:23.788475647 +0100
***************
*** 0 ****
--- 1,65 ----
+ " Test for folding
+ 
+ function! Test_address_fold()
+   new
+   call setline(1, ['int FuncName() {/*{{{*/', 1, 2, 3, 4, 5, '}/*}}}*/',
+ 	      \ 'after fold 1', 'after fold 2', 'after fold 3'])
+   setl fen fdm=marker
+   " The next ccommands should all copy the same part of the buffer,
+   " regardless of the adressing type, since the part to be copied
+   " is folded away
+   :1y
+   call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/'], getreg(0,1,1))
+   :.y
+   call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/'], getreg(0,1,1))
+   :.+y
+   call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/'], getreg(0,1,1))
+   :.,.y
+   call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/'], getreg(0,1,1))
+   :sil .1,.y
+   call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/'], getreg(0,1,1))
+   " use silent to make E493 go away
+   :sil .+,.y
+   call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/'], getreg(0,1,1))
+   :,y
+   call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/'], getreg(0,1,1))
+   :,+y
+   call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/','after fold 1'], getreg(0,1,1))
+   " using .+3 as second address should copy the whole folded line + the next 3
+   " lines
+   :.,+3y
+   call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/',
+ 	      \ 'after fold 1', 'after fold 2', 'after fold 3'], getreg(0,1,1))
+   :sil .,-2y
+   call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/'], getreg(0,1,1))
+ 
+   " now test again with folding disabled
+   set nofoldenable
+   :1y
+   call assert_equal(['int FuncName() {/*{{{*/'], getreg(0,1,1))
+   :.y
+   call assert_equal(['int FuncName() {/*{{{*/'], getreg(0,1,1))
+   :.+y
+   call assert_equal(['1'], getreg(0,1,1))
+   :.,.y
+   call assert_equal(['int FuncName() {/*{{{*/'], getreg(0,1,1))
+   " use silent to make E493 go away
+   :sil .1,.y
+   call assert_equal(['int FuncName() {/*{{{*/', '1'], getreg(0,1,1))
+   " use silent to make E493 go away
+   :sil .+,.y
+   call assert_equal(['int FuncName() {/*{{{*/', '1'], getreg(0,1,1))
+   :,y
+   call assert_equal(['int FuncName() {/*{{{*/'], getreg(0,1,1))
+   :,+y
+   call assert_equal(['int FuncName() {/*{{{*/', '1'], getreg(0,1,1))
+   " using .+3 as second address should copy the whole folded line + the next 3
+   " lines
+   :.,+3y
+   call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3'], getreg(0,1,1))
+   :7
+   :sil .,-2y
+   call assert_equal(['4', '5', '}/*}}}*/'], getreg(0,1,1))
+ 
+   quit!
+ endfunction
*** ../vim-8.0.0134/src/testdir/Make_all.mak	2016-12-09 19:28:33.576993205 +0100
--- src/testdir/Make_all.mak	2017-01-02 13:57:07.503752484 +0100
***************
*** 151,156 ****
--- 151,157 ----
  	    test_display.res \
  	    test_farsi.res \
  	    test_fnameescape.res \
+ 	    test_fold.res \
  	    test_gf.res \
  	    test_gn.res \
  	    test_gui.res \
*** ../vim-8.0.0134/src/Makefile	2016-12-09 19:57:11.053525977 +0100
--- src/Makefile	2017-01-02 13:56:31.336004626 +0100
***************
*** 2106,2111 ****
--- 2106,2112 ----
  	test_filter_map \
  	test_fnameescape \
  	test_fnamemodify \
+ 	test_fold \
  	test_glob2regpat \
  	test_gf \
  	test_gn \
*** ../vim-8.0.0134/src/version.c	2016-12-14 21:41:56.997414047 +0100
--- src/version.c	2017-01-02 14:24:57.888154655 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     135,
  /**/

-- 
        Very funny, Scotty.  Now beam down my clothes.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0136
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0136
Problem:    When using indent folding and changing indent the wrong fold is
            opened. (Jonathan Fudger)
Solution:   Open the fold under the cursor a bit later. (Christian Brabandt)
Files:      src/ops.c, src/testdir/test_fold.vim


*** ../vim-8.0.0135/src/ops.c	2016-09-04 14:59:01.000000000 +0200
--- src/ops.c	2017-01-02 14:32:20.473091162 +0100
***************
*** 259,269 ****
      }
  
      changed_lines(oap->start.lnum, 0, oap->end.lnum + 1, 0L);
- #ifdef FEAT_FOLDING
-     /* The cursor line is not in a closed fold */
-     foldOpenCursor();
- #endif
- 
      if (oap->block_mode)
      {
  	curwin->w_cursor.lnum = oap->start.lnum;
--- 259,264 ----
***************
*** 277,282 ****
--- 272,283 ----
      else
  	--curwin->w_cursor.lnum;	/* put cursor on last line, for ":>" */
  
+ #ifdef FEAT_FOLDING
+     /* The cursor line is not in a closed fold */
+     foldOpenCursor();
+ #endif
+ 
+ 
      if (oap->line_count > p_report)
      {
  	if (oap->op_type == OP_RSHIFT)
*** ../vim-8.0.0135/src/testdir/test_fold.vim	2017-01-02 14:27:15.619201170 +0100
--- src/testdir/test_fold.vim	2017-01-02 14:56:24.555093806 +0100
***************
*** 63,65 ****
--- 63,97 ----
  
    quit!
  endfunction
+ 
+ function! Test_indent_fold()
+     new
+     call setline(1, ['', 'a', '    b', '    c'])
+     setl fen fdm=indent
+     2
+     norm! >>
+     let a=map(range(1,4), 'foldclosed(v:val)')
+     call assert_equal([-1,-1,-1,-1], a)
+ endfu
+ 
+ function! Test_indent_fold()
+     new
+     call setline(1, ['', 'a', '    b', '    c'])
+     setl fen fdm=indent
+     2
+     norm! >>
+     let a=map(range(1,4), 'foldclosed(v:val)')
+     call assert_equal([-1,-1,-1,-1], a)
+     bw!
+ endfu
+ 
+ function! Test_indent_fold2()
+     new
+     call setline(1, ['', '{{{', '}}}', '{{{', '}}}'])
+     setl fen fdm=marker
+     2
+     norm! >>
+     let a=map(range(1,5), 'foldclosed(v:val)')
+     call assert_equal([-1,-1,-1,4,4], a)
+     bw!
+ endfu
*** ../vim-8.0.0135/src/version.c	2017-01-02 14:27:15.619201170 +0100
--- src/version.c	2017-01-02 14:34:18.560273981 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     136,
  /**/

-- 
Living in Hollywood is like living in a bowl of granola.  What ain't
fruits and nuts is flakes.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0137
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0137
Problem:    When 'maxfuncdepth' is set above 200 the nesting is limited to
            200. (Brett Stahlman)
Solution:   Allow for Ex command recursion depending on 'maxfuncdepth'.
Files:      src/ex_docmd.c, src/testdir/test_nested_function.vim


*** ../vim-8.0.0136/src/ex_docmd.c	2017-01-02 14:27:15.619201170 +0100
--- src/ex_docmd.c	2017-01-02 15:12:58.408210687 +0100
***************
*** 787,794 ****
  #endif
  
      /* It's possible to create an endless loop with ":execute", catch that
!      * here.  The value of 200 allows nested function calls, ":source", etc. */
!     if (call_depth == 200)
      {
  	EMSG(_("E169: Command too recursive"));
  #ifdef FEAT_EVAL
--- 787,795 ----
  #endif
  
      /* It's possible to create an endless loop with ":execute", catch that
!      * here.  The value of 200 allows nested function calls, ":source", etc.
!      * Allow 200 or 'maxfuncdepth', whatever is larger. */
!     if (call_depth >= 200 && call_depth >= p_mfd)
      {
  	EMSG(_("E169: Command too recursive"));
  #ifdef FEAT_EVAL
*** ../vim-8.0.0136/src/testdir/test_nested_function.vim	2016-11-14 21:49:57.080090226 +0100
--- src/testdir/test_nested_function.vim	2017-01-02 15:22:33.304211286 +0100
***************
*** 40,42 ****
--- 40,63 ----
    delfunc g:X
    unlet g:Y
  endfunc
+ 
+ func Recurse(count)
+   if a:count > 0
+     call Recurse(a:count - 1)
+   endif
+ endfunc
+ 
+ func Test_max_nesting()
+   let call_depth_here = 2
+   let ex_depth_here = 5
+   set mfd&
+ 
+   call Recurse(99 - call_depth_here)
+   call assert_fails('call Recurse(' . (100 - call_depth_here) . ')', 'E132:')
+ 
+   set mfd=210
+   call Recurse(209 - ex_depth_here)
+   call assert_fails('call Recurse(' . (210 - ex_depth_here) . ')', 'E169:')
+ 
+   set mfd&
+ endfunc
*** ../vim-8.0.0136/src/version.c	2017-01-02 14:57:05.494810156 +0100
--- src/version.c	2017-01-02 15:22:45.076129622 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     137,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
173. You keep tracking down the email addresses of all your friends
     (even childhood friends).

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0138
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0138 (after 8.0.0137)
Problem:    Small build fails.
Solution:   Add #ifdef.
Files:      src/ex_docmd.c


*** ../vim-8.0.0137/src/ex_docmd.c	2017-01-02 15:26:24.166610927 +0100
--- src/ex_docmd.c	2017-01-02 16:15:08.274273743 +0100
***************
*** 789,795 ****
      /* It's possible to create an endless loop with ":execute", catch that
       * here.  The value of 200 allows nested function calls, ":source", etc.
       * Allow 200 or 'maxfuncdepth', whatever is larger. */
!     if (call_depth >= 200 && call_depth >= p_mfd)
      {
  	EMSG(_("E169: Command too recursive"));
  #ifdef FEAT_EVAL
--- 789,799 ----
      /* It's possible to create an endless loop with ":execute", catch that
       * here.  The value of 200 allows nested function calls, ":source", etc.
       * Allow 200 or 'maxfuncdepth', whatever is larger. */
!     if (call_depth >= 200
! #ifdef FEAT_EVAL
! 	    && call_depth >= p_mfd
! #endif
! 	    )
      {
  	EMSG(_("E169: Command too recursive"));
  #ifdef FEAT_EVAL
*** ../vim-8.0.0137/src/version.c	2017-01-02 15:26:24.166610927 +0100
--- src/version.c	2017-01-02 16:16:04.445880810 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     138,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
174. You know what a listserv is.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0139
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0139 (after 8.0.0135)
Problem:    Warning for unused argument.
Solution:   Add UNUSED.
Files:      src/ex_docmd.c


*** ../vim-8.0.0138/src/ex_docmd.c	2017-01-02 16:16:35.865660797 +0100
--- src/ex_docmd.c	2017-01-02 16:51:14.171045011 +0100
***************
*** 4370,4376 ****
      int		addr_type,  /* flag: one of ADDR_LINES, ... */
      int		skip,	    /* only skip the address, don't use it */
      int		to_other_file,  /* flag: may jump to other file */
!     int		address_count)	    /* 1 for first address, >1 after comma */
  {
      int		c;
      int		i;
--- 4370,4376 ----
      int		addr_type,  /* flag: one of ADDR_LINES, ... */
      int		skip,	    /* only skip the address, don't use it */
      int		to_other_file,  /* flag: may jump to other file */
!     int		address_count UNUSED) /* 1 for first address, >1 after comma */
  {
      int		c;
      int		i;
***************
*** 7589,7595 ****
  #endif /* FEAT_WINDOWS */
  
      static void
! ex_hide(exarg_T *eap)
  {
      /* ":hide" or ":hide | cmd": hide current window */
  #ifdef FEAT_WINDOWS
--- 7589,7595 ----
  #endif /* FEAT_WINDOWS */
  
      static void
! ex_hide(exarg_T *eap UNUSED)
  {
      /* ":hide" or ":hide | cmd": hide current window */
  #ifdef FEAT_WINDOWS
*** ../vim-8.0.0138/src/version.c	2017-01-02 16:16:35.865660797 +0100
--- src/version.c	2017-01-02 16:19:38.236384032 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     139,
  /**/

-- 
If Microsoft would build a car...
... Occasionally, executing a maneuver such as a left turn
would cause your car to shut down and refuse to restart, in
which case you would have to reinstall the engine.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0140
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0140
Problem:    Pasting inserted text in Visual mode does not work properly.
            (Matthew Malcomson)
Solution:   Stop Visual mode before stuffing the inserted text. (Christian
            Brabandt, from neovim #5709)
Files:      src/ops.c, src/testdir/test_visual.vim


*** ../vim-8.0.0139/src/ops.c	2017-01-02 14:57:05.494810156 +0100
--- src/ops.c	2017-01-02 17:21:19.210310396 +0100
***************
*** 3351,3356 ****
--- 3351,3358 ----
       */
      if (regname == '.')
      {
+ 	if (VIsual_active)
+ 	    stuffcharReadbuff(VIsual_mode);
  	(void)stuff_inserted((dir == FORWARD ? (count == -1 ? 'o' : 'a') :
  				    (count == -1 ? 'O' : 'i')), count, FALSE);
  	/* Putting the text is done later, so can't really move the cursor to
*** ../vim-8.0.0139/src/testdir/test_visual.vim	2016-07-21 20:12:18.000000000 +0200
--- src/testdir/test_visual.vim	2017-01-02 17:19:00.191292898 +0100
***************
*** 1,13 ****
! " Tests for Visual mode.  Uses double-wide character.
! if !has('multi_byte')
!   finish
! endif
! 
  if !has('visual')
    finish
  endif
  
  func Test_block_shift_multibyte()
    split
    call setline(1, ['xxxx', 'xxx'])
    exe "normal 1G0l\<C-V>jl>"
--- 1,13 ----
! " Tests for various Visual mode.
  if !has('visual')
    finish
  endif
  
  func Test_block_shift_multibyte()
+   " Uses double-wide character.
+   if !has('multi_byte')
+     return
+   endif
    split
    call setline(1, ['xxxx', 'xxx'])
    exe "normal 1G0l\<C-V>jl>"
***************
*** 15,17 ****
--- 15,25 ----
    call assert_equal('	xxx', getline(2))
    q!
  endfunc
+ 
+ func Test_dotregister_paste()
+   new
+   exe "norm! ihello world\<esc>"
+   norm! 0ve".p
+   call assert_equal('hello world world', getline(1))
+   q!
+ endfunc
*** ../vim-8.0.0139/src/version.c	2017-01-02 17:25:54.860363256 +0100
--- src/version.c	2017-01-02 17:30:57.274211980 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     140,
  /**/

-- 
I'm so disorganized my keyboard isn't even in alphabetical order!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0141
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0141 (after 8.0.0137)
Problem:    Nested function test fails on AppVeyor.
Solution:   Disable the test on Windows for now.
Files:      src/testdir/test_nested_function.vim


*** ../vim-8.0.0140/src/testdir/test_nested_function.vim	2017-01-02 15:26:24.166610927 +0100
--- src/testdir/test_nested_function.vim	2017-01-02 18:31:19.288512190 +0100
***************
*** 48,53 ****
--- 48,57 ----
  endfunc
  
  func Test_max_nesting()
+   " TODO: why does this fail on Windows?  Runs out of stack perhaps?
+   if has('win32')
+     return
+   endif
    let call_depth_here = 2
    let ex_depth_here = 5
    set mfd&
*** ../vim-8.0.0140/src/version.c	2017-01-02 17:31:20.610046069 +0100
--- src/version.c	2017-01-02 18:31:04.472616841 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     141,
  /**/

-- 
If Microsoft would build a car...
... Occasionally your car would die on the freeway for no
reason. You would have to pull over to the side of the road,
close all of the car windows, shut it off, restart it, and
reopen the windows before you could continue. For some reason
you would simply accept this.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0142
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0142
Problem:    Normal colors are wrong with 'termguicolors'.
Solution:   Initialize to INVALCOLOR instead of zero. (Ben Jackson, closes
            #1344)
Files:      src/syntax.c


*** ../vim-8.0.0141/src/syntax.c	2016-08-29 22:42:20.000000000 +0200
--- src/syntax.c	2017-01-02 21:35:15.010798519 +0100
***************
*** 8765,8770 ****
--- 8765,8774 ----
  	else
  	{
  	    vim_memset(&new_en, 0, sizeof(new_en));
+ #ifdef FEAT_TERMGUICOLORS
+ 	    new_en.ae_u.cterm.bg_rgb = INVALCOLOR;
+ 	    new_en.ae_u.cterm.fg_rgb = INVALCOLOR;
+ #endif
  	    if (char_attr <= HL_ALL)
  		new_en.ae_attr = char_attr;
  	}
*** ../vim-8.0.0141/src/version.c	2017-01-02 18:32:36.655965763 +0100
--- src/version.c	2017-01-02 21:36:54.254100290 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     142,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
180. You maintain more than six e-mail addresses.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0143
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0143
Problem:    Line number of current buffer in getbufinfo() is wrong.
Solution:   For the current buffer use the current line number. (Ken Takata)
Files:      src/evalfunc.c


*** ../vim-8.0.0142/src/evalfunc.c	2016-12-04 13:37:38.421300745 +0100
--- src/evalfunc.c	2017-01-06 13:47:23.001211785 +0100
***************
*** 3973,3979 ****
      dict_add_nr_str(dict, "bufnr", buf->b_fnum, NULL);
      dict_add_nr_str(dict, "name", 0L,
  	    buf->b_ffname != NULL ? buf->b_ffname : (char_u *)"");
!     dict_add_nr_str(dict, "lnum", buflist_findlnum(buf), NULL);
      dict_add_nr_str(dict, "loaded", buf->b_ml.ml_mfp != NULL, NULL);
      dict_add_nr_str(dict, "listed", buf->b_p_bl, NULL);
      dict_add_nr_str(dict, "changed", bufIsChanged(buf), NULL);
--- 3973,3980 ----
      dict_add_nr_str(dict, "bufnr", buf->b_fnum, NULL);
      dict_add_nr_str(dict, "name", 0L,
  	    buf->b_ffname != NULL ? buf->b_ffname : (char_u *)"");
!     dict_add_nr_str(dict, "lnum", buf == curbuf ? curwin->w_cursor.lnum
! 						: buflist_findlnum(buf), NULL);
      dict_add_nr_str(dict, "loaded", buf->b_ml.ml_mfp != NULL, NULL);
      dict_add_nr_str(dict, "listed", buf->b_p_bl, NULL);
      dict_add_nr_str(dict, "changed", bufIsChanged(buf), NULL);
*** ../vim-8.0.0142/src/version.c	2017-01-02 21:37:38.033792277 +0100
--- src/version.c	2017-01-06 13:51:01.459726649 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     143,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
193. You ask your girlfriend to drive home so you can sit back with
     your PDA and download the information to your laptop

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0144
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0144
Problem:    When using MSVC the GvimExt directory is cleaned twice.
Solution:   Remove the lines. (Ken Takata)
Files:      src/Make_mvc.mak


*** ../vim-8.0.0143/src/Make_mvc.mak	2016-11-19 17:17:09.438428263 +0100
--- src/Make_mvc.mak	2017-01-06 14:53:11.034031512 +0100
***************
*** 1123,1131 ****
  	cd GvimExt
  	$(MAKE) /NOLOGO -f Makefile clean
  	cd ..
- 	cd GvimExt
- 	$(MAKE) /NOLOGO -f Makefile clean
- 	cd ..
  	- if exist testdir\*.out del testdir\*.out
  
  test:
--- 1123,1128 ----
*** ../vim-8.0.0143/src/version.c	2017-01-06 13:54:27.474326599 +0100
--- src/version.c	2017-01-06 14:54:25.733513495 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     144,
  /**/

-- 
Press any key to continue, press any other key to quit.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0145
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0145
Problem:    Running tests on MS-Windows is a little bit noisy.
Solution:   Redirect some output to "nul". (Ken Takata)
Files:      src/testdir/Make_dos.mak


*** ../vim-8.0.0144/src/testdir/Make_dos.mak	2016-08-06 20:34:31.000000000 +0200
--- src/testdir/Make_dos.mak	2017-01-06 17:56:52.992664368 +0100
***************
*** 44,55 ****
  # This moves test99.in to test99.in.bak temporarily.
  $(TEST_OUTFILES): $(DOSTMP)\$(*B).in
  	-@if exist test.out DEL test.out
! 	move $(*B).in $(*B).in.bak
! 	copy $(DOSTMP)\$(*B).in $(*B).in
! 	copy $(*B).ok test.ok
  	$(VIMPROG) -u dos.vim $(NO_PLUGIN) -s dotest.in $(*B).in
! 	-@if exist test.out MOVE /y test.out $(DOSTMP)\$(*B).out
! 	-@if exist $(*B).in.bak move /y $(*B).in.bak $(*B).in
  	-@if exist test.ok del test.ok
  	-@if exist Xdir1 rd /s /q Xdir1
  	-@if exist Xfind rd /s /q Xfind
--- 44,55 ----
  # This moves test99.in to test99.in.bak temporarily.
  $(TEST_OUTFILES): $(DOSTMP)\$(*B).in
  	-@if exist test.out DEL test.out
! 	move $(*B).in $(*B).in.bak > nul
! 	copy $(DOSTMP)\$(*B).in $(*B).in > nul
! 	copy $(*B).ok test.ok > nul
  	$(VIMPROG) -u dos.vim $(NO_PLUGIN) -s dotest.in $(*B).in
! 	-@if exist test.out MOVE /y test.out $(DOSTMP)\$(*B).out > nul
! 	-@if exist $(*B).in.bak move /y $(*B).in.bak $(*B).in > nul
  	-@if exist test.ok del test.ok
  	-@if exist Xdir1 rd /s /q Xdir1
  	-@if exist Xfind rd /s /q Xfind
***************
*** 58,67 ****
  	$(VIMPROG) -u dos.vim $(NO_PLUGIN) "+set ff=unix|f test.out|wq" \
  		$(DOSTMP)\$(*B).out
  	@diff test.out $*.ok & if errorlevel 1 \
! 		( move /y test.out $*.failed \
  		 & del $(DOSTMP)\$(*B).out \
  		 & echo $* FAILED >> test.log ) \
! 		else ( move /y test.out $*.out )
  
  # Must run test1 first to create small.vim.
  # This rule must come after the one that copies the input files to dostmp to
--- 58,67 ----
  	$(VIMPROG) -u dos.vim $(NO_PLUGIN) "+set ff=unix|f test.out|wq" \
  		$(DOSTMP)\$(*B).out
  	@diff test.out $*.ok & if errorlevel 1 \
! 		( move /y test.out $*.failed > nul \
  		 & del $(DOSTMP)\$(*B).out \
  		 & echo $* FAILED >> test.log ) \
! 		else ( move /y test.out $*.out > nul )
  
  # Must run test1 first to create small.vim.
  # This rule must come after the one that copies the input files to dostmp to
*** ../vim-8.0.0144/src/version.c	2017-01-06 14:55:17.125157197 +0100
--- src/version.c	2017-01-06 17:58:31.123973847 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     145,
  /**/

-- 
Some of the well known MS-Windows errors:
	EMULTI		Multitasking attempted, system confused
	EKEYBOARD	Keyboard locked, try getting out of this one!
	EXPLAIN		Unexplained error, please tell us what happened
	EFUTURE		Reserved for our future mistakes

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0146
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0146
Problem:    When using 'termguicolors' on MS-Windows the RGB definition causes
            the colors to be wrong.
Solution:   Undefined RGB and use our own. (Gabriel Barta)
Files:      src/term.c


*** ../vim-8.0.0145/src/term.c	2016-08-29 22:42:20.000000000 +0200
--- src/term.c	2017-01-06 18:12:36.362031160 +0100
***************
*** 6069,6076 ****
      guicolor_T
  gui_get_color_cmn(char_u *name)
  {
!     /* On MS-Windows an RGB macro is available and it's different from ours,
!      * but does what is needed. */
  # ifndef RGB
  #  define RGB(r, g, b)	((r<<16) | (g<<8) | (b))
  # endif
--- 6069,6080 ----
      guicolor_T
  gui_get_color_cmn(char_u *name)
  {
!     /* On MS-Windows an RGB macro is available and it produces 0x00bbggrr color
!      * values as used by the MS-Windows GDI api.  It should be used only for
!      * MS-Windows GDI builds. */
! # if defined(RGB) && defined(WIN32) && !defined(FEAT_GUI)
! #  undef RGB
! # endif
  # ifndef RGB
  #  define RGB(r, g, b)	((r<<16) | (g<<8) | (b))
  # endif
*** ../vim-8.0.0145/src/version.c	2017-01-06 17:59:54.739385570 +0100
--- src/version.c	2017-01-06 18:14:50.405089487 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     146,
  /**/

-- 
Some of the well known MS-Windows errors:
	ETIME		Wrong time, wait a little while
	ECRASH		Try again...
	EDETECT		Unable to detect errors
	EOVER		You lost!  Play another game?
	ENOCLUE		Eh, what did you want?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0147
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0147
Problem:    searchpair() does not work when 'magic' is off. (Chris Paul)
Solution:   Add \m in the pattern. (Christian Brabandt, closes #1341)
Files:      src/evalfunc.c, src/testdir/test_search.vim


*** ../vim-8.0.0146/src/evalfunc.c	2017-01-06 13:54:27.474326599 +0100
--- src/evalfunc.c	2017-01-06 19:59:18.872647757 +0100
***************
*** 9509,9523 ****
  
      /* Make two search patterns: start/end (pat2, for in nested pairs) and
       * start/middle/end (pat3, for the top pair). */
!     pat2 = alloc((unsigned)(STRLEN(spat) + STRLEN(epat) + 15));
!     pat3 = alloc((unsigned)(STRLEN(spat) + STRLEN(mpat) + STRLEN(epat) + 23));
      if (pat2 == NULL || pat3 == NULL)
  	goto theend;
!     sprintf((char *)pat2, "\\(%s\\m\\)\\|\\(%s\\m\\)", spat, epat);
      if (*mpat == NUL)
  	STRCPY(pat3, pat2);
      else
! 	sprintf((char *)pat3, "\\(%s\\m\\)\\|\\(%s\\m\\)\\|\\(%s\\m\\)",
  							    spat, epat, mpat);
      if (flags & SP_START)
  	options |= SEARCH_START;
--- 9509,9523 ----
  
      /* Make two search patterns: start/end (pat2, for in nested pairs) and
       * start/middle/end (pat3, for the top pair). */
!     pat2 = alloc((unsigned)(STRLEN(spat) + STRLEN(epat) + 17));
!     pat3 = alloc((unsigned)(STRLEN(spat) + STRLEN(mpat) + STRLEN(epat) + 25));
      if (pat2 == NULL || pat3 == NULL)
  	goto theend;
!     sprintf((char *)pat2, "\\m\\(%s\\m\\)\\|\\(%s\\m\\)", spat, epat);
      if (*mpat == NUL)
  	STRCPY(pat3, pat2);
      else
! 	sprintf((char *)pat3, "\\m\\(%s\\m\\)\\|\\(%s\\m\\)\\|\\(%s\\m\\)",
  							    spat, epat, mpat);
      if (flags & SP_START)
  	options |= SEARCH_START;
*** ../vim-8.0.0146/src/testdir/test_search.vim	2016-09-09 21:20:43.000000000 +0200
--- src/testdir/test_search.vim	2017-01-06 19:58:58.108795717 +0100
***************
*** 279,281 ****
--- 279,296 ----
    call X()
    bwipe!
  endfunc
+ 
+ func Test_searchpair()
+   new
+   call setline(1, ['other code here', '', '[', '" cursor here', ']'])
+   4
+   let a=searchpair('\[','',']','bW')
+   call assert_equal(3, a)
+   set nomagic
+   4
+   let a=searchpair('\[','',']','bW')
+   call assert_equal(3, a)
+   set magic
+   q!
+ endfunc
+ 
*** ../vim-8.0.0146/src/version.c	2017-01-06 18:16:15.632490849 +0100
--- src/version.c	2017-01-06 19:58:30.296993909 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     147,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
198. You read all the quotes at Netaholics Anonymous and keep thinking
     "What's wrong with that?"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0148
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0148
Problem:    When a C preprocessor statement has two line continuations the
            following line does not have the right indent. (Ken Takata)
Solution:   Add the indent of the previous continuation line. (Hirohito
            Higashi)
Files:      src/misc1.c, src/testdir/test3.in, src/testdir/test3.ok


*** ../vim-8.0.0147/src/misc1.c	2016-11-17 21:30:17.144445729 +0100
--- src/misc1.c	2017-01-07 14:09:00.601851661 +0100
***************
*** 5422,5428 ****
  static int	cin_first_id_amount(void);
  static int	cin_get_equal_amount(linenr_T lnum);
  static int	cin_ispreproc(char_u *);
- static int	cin_ispreproc_cont(char_u **pp, linenr_T *lnump);
  static int	cin_iscomment(char_u *);
  static int	cin_islinecomment(char_u *);
  static int	cin_isterminated(char_u *, int, int);
--- 5422,5427 ----
***************
*** 6002,6014 ****
   * Return TRUE if line "*pp" at "*lnump" is a preprocessor statement or a
   * continuation line of a preprocessor statement.  Decrease "*lnump" to the
   * start and return the line in "*pp".
   */
      static int
! cin_ispreproc_cont(char_u **pp, linenr_T *lnump)
  {
      char_u	*line = *pp;
      linenr_T	lnum = *lnump;
      int		retval = FALSE;
  
      for (;;)
      {
--- 6001,6018 ----
   * Return TRUE if line "*pp" at "*lnump" is a preprocessor statement or a
   * continuation line of a preprocessor statement.  Decrease "*lnump" to the
   * start and return the line in "*pp".
+  * Put the amount of indent in "*amount".
   */
      static int
! cin_ispreproc_cont(char_u **pp, linenr_T *lnump, int *amount)
  {
      char_u	*line = *pp;
      linenr_T	lnum = *lnump;
      int		retval = FALSE;
+     int		candidate_amount = *amount;
+ 
+     if (*line != NUL && line[STRLEN(line) - 1] == '\\')
+ 	candidate_amount = get_indent_lnum(lnum);
  
      for (;;)
      {
***************
*** 6027,6032 ****
--- 6031,6038 ----
  
      if (lnum != *lnump)
  	*pp = ml_get(*lnump);
+     if (retval)
+ 	*amount = candidate_amount;
      return retval;
  }
  
***************
*** 7390,7396 ****
  		l = skipwhite(ml_get(lnum));
  		if (cin_nocode(l))		/* skip comment lines */
  		    continue;
! 		if (cin_ispreproc_cont(&l, &lnum))
  		    continue;			/* ignore #define, #if, etc. */
  		curwin->w_cursor.lnum = lnum;
  
--- 7396,7402 ----
  		l = skipwhite(ml_get(lnum));
  		if (cin_nocode(l))		/* skip comment lines */
  		    continue;
! 		if (cin_ispreproc_cont(&l, &lnum, &amount))
  		    continue;			/* ignore #define, #if, etc. */
  		curwin->w_cursor.lnum = lnum;
  
***************
*** 7803,7812 ****
  		 */
  		if (curwin->w_cursor.lnum <= ourscope)
  		{
! 		    /* we reached end of scope:
! 		     * if looking for a enum or structure initialization
  		     * go further back:
! 		     * if it is an initializer (enum xxx or xxx =), then
  		     * don't add ind_continuation, otherwise it is a variable
  		     * declaration:
  		     * int x,
--- 7809,7818 ----
  		 */
  		if (curwin->w_cursor.lnum <= ourscope)
  		{
! 		    /* We reached end of scope:
! 		     * If looking for a enum or structure initialization
  		     * go further back:
! 		     * If it is an initializer (enum xxx or xxx =), then
  		     * don't add ind_continuation, otherwise it is a variable
  		     * declaration:
  		     * int x,
***************
*** 7845,7851 ****
  			/*
  			 * Skip preprocessor directives and blank lines.
  			 */
! 			if (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum))
  			    continue;
  
  			if (cin_nocode(l))
--- 7851,7858 ----
  			/*
  			 * Skip preprocessor directives and blank lines.
  			 */
! 			if (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum,
! 								    &amount))
  			    continue;
  
  			if (cin_nocode(l))
***************
*** 7962,7968 ****
  			    }
  
  			    /* Skip preprocessor directives and blank lines. */
! 			    if (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum))
  				continue;
  
  			    /* Finally the actual check for "namespace". */
--- 7969,7976 ----
  			    }
  
  			    /* Skip preprocessor directives and blank lines. */
! 			    if (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum,
! 								    &amount))
  				continue;
  
  			    /* Finally the actual check for "namespace". */
***************
*** 8138,8144 ****
  		 * unlocked it)
  		 */
  		l = ml_get_curline();
! 		if (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum)
  							     || cin_nocode(l))
  		    continue;
  
--- 8146,8152 ----
  		 * unlocked it)
  		 */
  		l = ml_get_curline();
! 		if (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum, &amount)
  							     || cin_nocode(l))
  		    continue;
  
***************
*** 8859,8865 ****
  	/*
  	 * Skip preprocessor directives and blank lines.
  	 */
! 	if (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum))
  	    continue;
  
  	if (cin_nocode(l))
--- 8867,8873 ----
  	/*
  	 * Skip preprocessor directives and blank lines.
  	 */
! 	if (cin_ispreproc_cont(&l, &curwin->w_cursor.lnum, &amount))
  	    continue;
  
  	if (cin_nocode(l))
***************
*** 8960,8966 ****
  	    {
  		look = ml_get(--curwin->w_cursor.lnum);
  		if (!(cin_nocode(look) || cin_ispreproc_cont(
! 				      &look, &curwin->w_cursor.lnum)))
  		    break;
  	    }
  	    if (curwin->w_cursor.lnum > 0
--- 8968,8974 ----
  	    {
  		look = ml_get(--curwin->w_cursor.lnum);
  		if (!(cin_nocode(look) || cin_ispreproc_cont(
! 				      &look, &curwin->w_cursor.lnum, &amount)))
  		    break;
  	    }
  	    if (curwin->w_cursor.lnum > 0
*** ../vim-8.0.0147/src/testdir/test3.in	2016-11-17 21:30:17.144445729 +0100
--- src/testdir/test3.in	2017-01-07 14:03:05.980471398 +0100
***************
*** 2318,2323 ****
--- 2318,2342 ----
  JSEND
  
  STARTTEST
+ :set cin cino&
+ /start of define
+ =/end of define
+ ENDTEST
+ 
+ /* start of define */
+ {
+ }
+ #define AAA \
+ BBB\
+ CCC
+ 
+ #define CNT \
+ 1 + \
+ 2 + \
+ 4
+ /* end of define */
+ 
+ STARTTEST
  :g/^STARTTEST/.,/^ENDTEST/d
  :1;/start of AUTO/,$wq! test.out
  ENDTEST
*** ../vim-8.0.0147/src/testdir/test3.ok	2016-11-17 21:30:17.144445729 +0100
--- src/testdir/test3.ok	2017-01-07 14:03:05.980471398 +0100
***************
*** 2080,2082 ****
--- 2080,2096 ----
  	i;
  JSEND
  
+ 
+ /* start of define */
+ {
+ }
+ #define AAA \
+ 	BBB\
+ 	CCC
+ 
+ #define CNT \
+ 	1 + \
+ 	2 + \
+ 	4
+ /* end of define */
+ 
*** ../vim-8.0.0147/src/version.c	2017-01-06 20:03:45.430748917 +0100
--- src/version.c	2017-01-07 14:02:42.520644763 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     148,
  /**/

-- 
Spam seems to be something useful to novices.  Later you realize that
it's a bunch of indigestable junk that only clogs your system.
Applies to both the food and the e-mail!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0149
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0149
Problem:    ":earlier" and ":later" do not work after startup or reading the
            undo file.
Solution:   Use absolute time stamps instead of relative to the Vim start
            time. (Christian Brabandt, Pavel Juhas, closes #1300, closes
            #1254)
Files:      src/testdir/test_undo.vim, src/undo.c


*** ../vim-8.0.0148/src/undo.c	2016-11-10 20:01:41.201582868 +0100
--- src/undo.c	2017-01-07 16:07:07.561481836 +0100
***************
*** 2298,2307 ****
      }
      else
      {
- 	/* When doing computations with time_t subtract starttime, because
- 	 * time_t converted to a long may result in a wrong number. */
  	if (dosec)
! 	    target = (long)(curbuf->b_u_time_cur - starttime) + step;
  	else if (dofile)
  	{
  	    if (step < 0)
--- 2298,2305 ----
      }
      else
      {
  	if (dosec)
! 	    target = (long)(curbuf->b_u_time_cur) + step;
  	else if (dofile)
  	{
  	    if (step < 0)
***************
*** 2350,2356 ****
  	else
  	{
  	    if (dosec)
! 		closest = (long)(vim_time() - starttime + 1);
  	    else if (dofile)
  		closest = curbuf->b_u_save_nr_last + 2;
  	    else
--- 2348,2354 ----
  	else
  	{
  	    if (dosec)
! 		closest = (long)(vim_time() + 1);
  	    else if (dofile)
  		closest = curbuf->b_u_save_nr_last + 2;
  	    else
***************
*** 2388,2394 ****
  	{
  	    uhp->uh_walk = mark;
  	    if (dosec)
! 		val = (long)(uhp->uh_time - starttime);
  	    else if (dofile)
  		val = uhp->uh_save_nr;
  	    else
--- 2386,2392 ----
  	{
  	    uhp->uh_walk = mark;
  	    if (dosec)
! 		val = (long)(uhp->uh_time);
  	    else if (dofile)
  		val = uhp->uh_save_nr;
  	    else
*** ../vim-8.0.0148/src/testdir/test_undo.vim	2016-08-31 20:30:21.000000000 +0200
--- src/testdir/test_undo.vim	2017-01-07 15:54:36.491066617 +0100
***************
*** 235,237 ****
--- 235,265 ----
  
    close!
  endfunc
+ 
+ func Test_undofile_earlier()
+   " Issue #1254
+   " create undofile with timestamps older than Vim startup time.
+   let t0 = localtime() - 43200
+   call test_settime(t0)
+   new Xfile
+   call feedkeys("ione\<Esc>", 'xt')
+   set ul=100
+   call test_settime(t0 + 1)
+   call feedkeys("otwo\<Esc>", 'xt')
+   set ul=100
+   call test_settime(t0 + 2)
+   call feedkeys("othree\<Esc>", 'xt')
+   set ul=100
+   w
+   wundo Xundofile
+   bwipe!
+   " restore normal timestamps.
+   call test_settime(0)
+   new Xfile
+   rundo Xundofile
+   earlier 1d
+   call assert_equal('', getline(1))
+   bwipe!
+   call delete('Xfile')
+   call delete('Xundofile')
+ endfunc
*** ../vim-8.0.0148/src/version.c	2017-01-07 15:39:36.401759496 +0100
--- src/version.c	2017-01-07 16:13:59.142424882 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     149,
  /**/

-- 
$ echo pizza > /dev/oven

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0150
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0150
Problem:    When the pattern of :filter does not have a separator then
            completion of the command fails.
Solution:   Skip over the pattern. (Ozaki Kiichi, clodes #1299)
Files:      src/ex_docmd.c, src/testdir/test_filter_cmd.vim


*** ../vim-8.0.0149/src/ex_docmd.c	2017-01-02 17:25:54.860363256 +0100
--- src/ex_docmd.c	2017-01-07 20:31:37.557787760 +0100
***************
*** 3871,3877 ****
  	case CMD_cfdo:
  	case CMD_confirm:
  	case CMD_debug:
- 	case CMD_filter:
  	case CMD_folddoclosed:
  	case CMD_folddoopen:
  	case CMD_hide:
--- 3871,3876 ----
***************
*** 3896,3901 ****
--- 3895,3910 ----
  	case CMD_windo:
  	    return arg;
  
+ 	case CMD_filter:
+ 	    if (*arg != NUL)
+ 		arg = skip_vimgrep_pat(arg, NULL, NULL);
+ 	    if (arg == NULL || *arg == NUL)
+ 	    {
+ 		xp->xp_context = EXPAND_NOTHING;
+ 		return NULL;
+ 	    }
+ 	    return skipwhite(arg);
+ 
  #ifdef FEAT_CMDL_COMPL
  # ifdef FEAT_SEARCH_EXTRA
  	case CMD_match:
*** ../vim-8.0.0149/src/testdir/test_filter_cmd.vim	2016-09-08 22:01:02.000000000 +0200
--- src/testdir/test_filter_cmd.vim	2017-01-07 20:31:37.561787729 +0100
***************
*** 52,54 ****
--- 52,76 ----
    call assert_fails('filter! /pat/', 'E476:')
    call assert_fails('filter! /pat/ asdf', 'E492:')
  endfunc
+ 
+ function s:complete_filter_cmd(filtcmd)
+   let keystroke = "\<TAB>\<C-R>=execute('let cmdline = getcmdline()')\<CR>\<C-C>"
+   let cmdline = ''
+   call feedkeys(':' . a:filtcmd . keystroke, 'ntx')
+   return cmdline
+ endfunction
+ 
+ func Test_filter_cmd_completion()
+   " Do not complete pattern
+   call assert_equal("filter \t", s:complete_filter_cmd('filter '))
+   call assert_equal("filter pat\t", s:complete_filter_cmd('filter pat'))
+   call assert_equal("filter /pat\t", s:complete_filter_cmd('filter /pat'))
+   call assert_equal("filter /pat/\t", s:complete_filter_cmd('filter /pat/'))
+ 
+   " Complete after string pattern
+   call assert_equal('filter pat print', s:complete_filter_cmd('filter pat pri'))
+ 
+   " Complete after regexp pattern
+   call assert_equal('filter /pat/ print', s:complete_filter_cmd('filter /pat/ pri'))
+   call assert_equal('filter #pat# print', s:complete_filter_cmd('filter #pat# pri'))
+ endfunc
*** ../vim-8.0.0149/src/version.c	2017-01-07 16:14:53.894018391 +0100
--- src/version.c	2017-01-07 20:34:08.628639702 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     150,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
211. Your husband leaves you...taking the computer with him and you
     call him crying, and beg him to bring the computer back.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0151
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0151
Problem:    To pass buffer content to system() and systemlist() one has to
            first create a string or list.
Solution:   Allow passing a buffer number. (LemonBoy, closes #1240)
Files:      runtime/doc/eval.txt, src/Makefile, src/evalfunc.c,
            src/testdir/Make_all.mak, src/testdir/test_system.vim


*** ../vim-8.0.0150/runtime/doc/eval.txt	2016-11-29 21:54:41.120260177 +0100
--- runtime/doc/eval.txt	2017-01-08 13:20:15.812784917 +0100
***************
*** 7551,7557 ****
  		If {input} is given and is a |List| it is written to the file
  		in a way |writefile()| does with {binary} set to "b" (i.e.
  		with a newline between each list item with newlines inside
! 		list items converted to NULs).  
  
  		Pipes are not used, the 'shelltemp' option is not used.
  
--- 7561,7571 ----
  		If {input} is given and is a |List| it is written to the file
  		in a way |writefile()| does with {binary} set to "b" (i.e.
  		with a newline between each list item with newlines inside
! 		list items converted to NULs).
! 		When {input} is given and is a number that is a valid id for
! 		an existing buffer then the content of the buffer is written
! 		to the file line by line, each line terminated by a NL and
! 		NULs characters where the text has a NL.
  
  		Pipes are not used, the 'shelltemp' option is not used.
  
*** ../vim-8.0.0150/src/Makefile	2017-01-02 14:27:15.619201170 +0100
--- src/Makefile	2017-01-08 13:10:08.673262414 +0100
***************
*** 2164,2169 ****
--- 2164,2170 ----
  	test_substitute \
  	test_syn_attr \
  	test_syntax \
+ 	test_system \
  	test_tabline \
  	test_tabpage \
  	test_tagcase \
*** ../vim-8.0.0150/src/evalfunc.c	2017-01-06 20:03:45.426748945 +0100
--- src/evalfunc.c	2017-01-08 13:14:11.223473098 +0100
***************
*** 11817,11823 ****
      char_u	*res = NULL;
      char_u	*p;
      char_u	*infile = NULL;
-     char_u	buf[NUMBUFLEN];
      int		err = FALSE;
      FILE	*fd;
      list_T	*list = NULL;
--- 11817,11822 ----
***************
*** 11831,11837 ****
      if (argvars[1].v_type != VAR_UNKNOWN)
      {
  	/*
! 	 * Write the string to a temp file, to be used for input of the shell
  	 * command.
  	 */
  	if ((infile = vim_tempname('i', TRUE)) == NULL)
--- 11830,11836 ----
      if (argvars[1].v_type != VAR_UNKNOWN)
      {
  	/*
! 	 * Write the text to a temp file, to be used for input of the shell
  	 * command.
  	 */
  	if ((infile = vim_tempname('i', TRUE)) == NULL)
***************
*** 11846,11859 ****
  	    EMSG2(_(e_notopen), infile);
  	    goto errret;
  	}
! 	if (argvars[1].v_type == VAR_LIST)
  	{
  	    if (write_list(fd, argvars[1].vval.v_list, TRUE) == FAIL)
  		err = TRUE;
  	}
  	else
  	{
! 	    size_t len;
  
  	    p = get_tv_string_buf_chk(&argvars[1], buf);
  	    if (p == NULL)
--- 11845,11886 ----
  	    EMSG2(_(e_notopen), infile);
  	    goto errret;
  	}
! 	if (argvars[1].v_type == VAR_NUMBER)
! 	{
! 	    linenr_T	lnum;
! 	    buf_T	*buf;
! 
! 	    buf = buflist_findnr(argvars[1].vval.v_number);
! 	    if (buf == NULL)
! 	    {
! 		EMSGN(_(e_nobufnr), argvars[1].vval.v_number);
! 		goto errret;
! 	    }
! 
! 	    for (lnum = 1; lnum <= buf->b_ml.ml_line_count; lnum++)
! 	    {
! 		for (p = ml_get_buf(buf, lnum, FALSE); *p != NUL; ++p)
! 		    if (putc(*p == '\n' ? NUL : *p, fd) == EOF)
! 		    {
! 			err = TRUE;
! 			break;
! 		    }
! 		if (putc(NL, fd) == EOF)
! 		{
! 		    err = TRUE;
! 		    break;
! 		}
! 	    }
! 	}
! 	else if (argvars[1].v_type == VAR_LIST)
  	{
  	    if (write_list(fd, argvars[1].vval.v_list, TRUE) == FAIL)
  		err = TRUE;
  	}
  	else
  	{
! 	    size_t	len;
! 	    char_u	buf[NUMBUFLEN];
  
  	    p = get_tv_string_buf_chk(&argvars[1], buf);
  	    if (p == NULL)
*** ../vim-8.0.0150/src/testdir/Make_all.mak	2017-01-02 14:27:15.619201170 +0100
--- src/testdir/Make_all.mak	2017-01-08 12:53:25.608672491 +0100
***************
*** 184,189 ****
--- 184,190 ----
  	    test_stat.res \
  	    test_substitute.res \
  	    test_syntax.res \
+ 	    test_system.res \
  	    test_textobjects.res \
  	    test_undo.res \
  	    test_usercommands.res \
*** ../vim-8.0.0150/src/testdir/test_system.vim	2017-01-08 13:23:40.599275697 +0100
--- src/testdir/test_system.vim	2017-01-08 13:18:48.137431212 +0100
***************
*** 0 ****
--- 1,20 ----
+ " Tests for system() and systemlist()
+ 
+ function! Test_System()
+   if !executable('echo') || !executable('cat') || !executable('wc')
+     return
+   endif
+   call assert_equal("123\n", system('echo 123'))
+   call assert_equal(['123'], systemlist('echo 123'))
+   call assert_equal('123',   system('cat', '123'))
+   call assert_equal(['123'], systemlist('cat', '123'))
+   call assert_equal(["as\<NL>df"], systemlist('cat', ["as\<NL>df"]))
+   new Xdummy
+   call setline(1, ['asdf', "pw\<NL>er", 'xxxx'])
+   call assert_equal("3\n",  system('wc -l', bufnr('%')))
+   call assert_equal(['3'],  systemlist('wc -l', bufnr('%')))
+   call assert_equal(['asdf', "pw\<NL>er", 'xxxx'],  systemlist('cat', bufnr('%')))
+   bwipe!
+ 
+   call assert_fails('call system("wc -l", 99999)', 'E86:')
+ endfunction
*** ../vim-8.0.0150/src/version.c	2017-01-07 20:39:49.970046560 +0100
--- src/version.c	2017-01-08 13:00:31.081527302 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     151,
  /**/

-- 
From the classified section of a city newspaper:
Dog for sale: eats anything and is fond of children.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0152
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0152
Problem:    Running the channel test creates channellog.
Solution:   Delete the debug line.
Files:      src/testdir/test_channel.vim


*** ../vim-8.0.0151/src/testdir/test_channel.vim	2016-12-03 14:29:01.636589998 +0100
--- src/testdir/test_channel.vim	2017-01-08 13:36:26.617590457 +0100
***************
*** 279,285 ****
  endfunc
  
  func Test_channel_handler()
- call ch_logfile('channellog', 'w')
    call ch_log('Test_channel_handler()')
    let g:Ch_reply = ""
    let s:chopt.callback = 'Ch_handler'
--- 279,284 ----
*** ../vim-8.0.0151/src/version.c	2017-01-08 13:25:47.626339783 +0100
--- src/version.c	2017-01-08 13:37:21.381183531 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     152,
  /**/

-- 
Don't be humble ... you're not that great.
                      -- Golda Meir

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0153
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0153 (after 8.0.0151)
Problem:    system() test fails on MS-Windows.
Solution:   Deal when extra space and CR.
Files:      src/testdir/test_system.vim


*** ../vim-8.0.0152/src/testdir/test_system.vim	2017-01-08 13:25:47.626339783 +0100
--- src/testdir/test_system.vim	2017-01-08 13:51:25.560513157 +0100
***************
*** 4,19 ****
    if !executable('echo') || !executable('cat') || !executable('wc')
      return
    endif
!   call assert_equal("123\n", system('echo 123'))
!   call assert_equal(['123'], systemlist('echo 123'))
    call assert_equal('123',   system('cat', '123'))
    call assert_equal(['123'], systemlist('cat', '123'))
    call assert_equal(["as\<NL>df"], systemlist('cat', ["as\<NL>df"]))
    new Xdummy
    call setline(1, ['asdf', "pw\<NL>er", 'xxxx'])
    call assert_equal("3\n",  system('wc -l', bufnr('%')))
!   call assert_equal(['3'],  systemlist('wc -l', bufnr('%')))
!   call assert_equal(['asdf', "pw\<NL>er", 'xxxx'],  systemlist('cat', bufnr('%')))
    bwipe!
  
    call assert_fails('call system("wc -l", 99999)', 'E86:')
--- 4,39 ----
    if !executable('echo') || !executable('cat') || !executable('wc')
      return
    endif
!   let out = system('echo 123')
!   " On Windows we may get a trailing space.
!   if out != "123 \n"
!     call assert_equal("123\n", out)
!   endif
! 
!   let out = systemlist('echo 123')
!   " On Windows we may get a trailing space and CR.
!   if out != ["123 \r"]
!     call assert_equal(['123'], out)
!   endif
! 
    call assert_equal('123',   system('cat', '123'))
    call assert_equal(['123'], systemlist('cat', '123'))
    call assert_equal(["as\<NL>df"], systemlist('cat', ["as\<NL>df"]))
    new Xdummy
    call setline(1, ['asdf', "pw\<NL>er", 'xxxx'])
    call assert_equal("3\n",  system('wc -l', bufnr('%')))
! 
!   let out = systemlist('wc -l', bufnr('%'))
!   " On Windows we may get a trailing CR.
!   if out != ["3\r"]
!     call assert_equal(['3'],  out)
!   endif
! 
!   let out = systemlist('cat', bufnr('%'))
!   " On Windows we may get a trailing CR.
!   if out != ["asdf\r", "pw\<NL>er\r", "xxxx\r"]
!     call assert_equal(['asdf', "pw\<NL>er", 'xxxx'],  out)
!   endif
    bwipe!
  
    call assert_fails('call system("wc -l", 99999)', 'E86:')
*** ../vim-8.0.0152/src/version.c	2017-01-08 13:38:53.028502710 +0100
--- src/version.c	2017-01-08 13:52:33.194418853 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     153,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
218. Your spouse hands you a gift wrapped magnet with your PC's name
     on it and you accuse him or her of genocide.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0154
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0154 (after 8.0.0151)
Problem:    system() test fails on OS/X.
Solution:   Deal with leading spaces.
Files:      src/testdir/test_system.vim


*** ../vim-8.0.0153/src/testdir/test_system.vim	2017-01-08 13:55:03.701304016 +0100
--- src/testdir/test_system.vim	2017-01-08 14:13:31.681061408 +0100
***************
*** 19,31 ****
    call assert_equal('123',   system('cat', '123'))
    call assert_equal(['123'], systemlist('cat', '123'))
    call assert_equal(["as\<NL>df"], systemlist('cat', ["as\<NL>df"]))
    new Xdummy
    call setline(1, ['asdf', "pw\<NL>er", 'xxxx'])
!   call assert_equal("3\n",  system('wc -l', bufnr('%')))
  
    let out = systemlist('wc -l', bufnr('%'))
    " On Windows we may get a trailing CR.
    if out != ["3\r"]
      call assert_equal(['3'],  out)
    endif
  
--- 19,39 ----
    call assert_equal('123',   system('cat', '123'))
    call assert_equal(['123'], systemlist('cat', '123'))
    call assert_equal(["as\<NL>df"], systemlist('cat', ["as\<NL>df"]))
+ 
    new Xdummy
    call setline(1, ['asdf', "pw\<NL>er", 'xxxx'])
!   let out = system('wc -l', bufnr('%'))
!   " On OS/X we get leading spaces
!   let out = substitute(out, '^ *', '', '')
!   call assert_equal("3\n", out)
  
    let out = systemlist('wc -l', bufnr('%'))
    " On Windows we may get a trailing CR.
    if out != ["3\r"]
+     " On OS/X we get leading spaces
+     if type(out) == v:t_list
+       let out[0] = substitute(out[0], '^ *', '', '')
+     endif
      call assert_equal(['3'],  out)
    endif
  
*** ../vim-8.0.0153/src/version.c	2017-01-08 13:55:03.701304016 +0100
--- src/version.c	2017-01-08 14:12:18.345607926 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     154,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
219. Your spouse has his or her lawyer deliver the divorce papers...
     via e-mail.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0155
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0155
Problem:    When sorting zero elements a NULL pointer is passed to qsort(),
            which ubsan warns for.
Solution:   Don't call qsort() if there are no elements. (Dominique Pelle)
Files:      src/syntax.c


*** ../vim-8.0.0154/src/syntax.c	2017-01-02 21:37:38.033792277 +0100
--- src/syntax.c	2017-01-08 17:45:30.101248846 +0100
***************
*** 6704,6711 ****
  	}
      }
  
!     /* sort on total time */
!     qsort(ga.ga_data, (size_t)ga.ga_len, sizeof(time_entry_T),
  							 syn_compare_syntime);
  
      MSG_PUTS_TITLE(_("  TOTAL      COUNT  MATCH   SLOWEST     AVERAGE   NAME               PATTERN"));
--- 6704,6713 ----
  	}
      }
  
!     /* Sort on total time. Skip if there are no items to avoid passing NULL
!      * pointer to qsort(). */
!     if (ga.ga_len > 1)
! 	qsort(ga.ga_data, (size_t)ga.ga_len, sizeof(time_entry_T),
  							 syn_compare_syntime);
  
      MSG_PUTS_TITLE(_("  TOTAL      COUNT  MATCH   SLOWEST     AVERAGE   NAME               PATTERN"));
*** ../vim-8.0.0154/src/version.c	2017-01-08 14:14:34.732591613 +0100
--- src/version.c	2017-01-08 17:36:21.825412583 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     155,
  /**/

-- 
If evolution theories are correct, humans will soon grow a third
hand for operating the mouse.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0156
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0156
Problem:    Several float functions are not covered by tests.
Solution:   Add float tests. (Dominique Pelle)
Files:      src/Makefile, src/testdir/test_alot.vim,
            src/testdir/test_float_func.vim


*** ../vim-8.0.0155/src/Makefile	2017-01-08 13:25:47.626339783 +0100
--- src/Makefile	2017-01-08 17:50:55.178781109 +0100
***************
*** 2104,2109 ****
--- 2104,2110 ----
  	test_fileformat \
  	test_filter_cmd \
  	test_filter_map \
+ 	test_float_func \
  	test_fnameescape \
  	test_fnamemodify \
  	test_fold \
*** ../vim-8.0.0155/src/testdir/test_alot.vim	2016-10-12 17:45:13.642857417 +0200
--- src/testdir/test_alot.vim	2017-01-08 17:51:02.170727964 +0100
***************
*** 16,21 ****
--- 16,22 ----
  source test_fileformat.vim
  source test_filter_cmd.vim
  source test_filter_map.vim
+ source test_float_func.vim
  source test_fnamemodify.vim
  source test_glob2regpat.vim
  source test_goto.vim
*** ../vim-8.0.0155/src/testdir/test_float_func.vim	2017-01-08 17:58:26.079355257 +0100
--- src/testdir/test_float_func.vim	2017-01-08 17:51:02.170727964 +0100
***************
*** 0 ****
--- 1,227 ----
+ " test float functions
+ 
+ if !has('float')
+   finish
+ end
+ 
+ func Test_abs()
+   call assert_equal(string(abs(1.23)), '1.23')
+   call assert_equal(string(abs(-1.23)), '1.23')
+   call assert_equal(string(abs(0.0)), '0.0')
+   call assert_equal(string(abs(1.0/(1.0/0.0))), '0.0')
+   call assert_equal(string(abs(-1.0/(1.0/0.0))), '0.0')
+   call assert_equal(string(abs(1.0/0.0)), 'inf')
+   call assert_equal(string(abs(-1.0/0.0)), 'inf')
+   call assert_equal(string(abs(0.0/0.0)), 'nan')
+ endfunc
+ 
+ func Test_sqrt()
+   call assert_equal(string(sqrt(0.0)), '0.0')
+   call assert_equal(string(sqrt(2.0)), '1.414214')
+   call assert_equal(string(sqrt(1.0/0.0)), 'inf')
+   call assert_equal(string(sqrt(-1.0)), 'nan')
+   call assert_equal(string(sqrt(0.0/0.0)), 'nan')
+ endfunc
+ 
+ func Test_log()
+   call assert_equal(string(log(1.0)), '0.0')
+   call assert_equal(string(log(0.5)), '-0.693147')
+   call assert_equal(string(log(0.0)), '-inf')
+   call assert_equal(string(log(-1.0)), 'nan')
+   call assert_equal(string(log(1.0/0.0)), 'inf')
+   call assert_equal(string(log(0.0/0.0)), 'nan')
+ endfunc
+ 
+ func Test_log10()
+   call assert_equal(string(log10(1.0)), '0.0')
+   call assert_equal(string(log10(100.0)), '2.0')
+   call assert_equal(string(log10(120.0)), '2.079181')
+   call assert_equal(string(log10(0.0)), '-inf')
+   call assert_equal(string(log10(-1.0)), 'nan')
+   call assert_equal(string(log10(1.0/0.0)), 'inf')
+   call assert_equal(string(log10(0.0/0.0)), 'nan')
+ endfunc
+ 
+ func Test_exp()
+   call assert_equal(string(exp(0.0)), '1.0')
+   call assert_equal(string(exp(2.0)), '7.389056')
+   call assert_equal(string(exp(-1.0)),'0.367879')
+   call assert_equal(string(exp(1.0/0.0)), 'inf')
+   call assert_equal(string(exp(-1.0/0.0)), '0.0')
+   call assert_equal(string(exp(0.0/0.0)), 'nan')
+ endfunc
+ 
+ func Test_sin()
+   call assert_equal(string(sin(0.0)), '0.0')
+   call assert_equal(string(sin(1.0)), '0.841471')
+   call assert_equal(string(sin(-0.5)), '-0.479426')
+   call assert_equal(string(sin(0.0/0.0)), 'nan')
+   call assert_equal(string(sin(1.0/0.0)), 'nan')
+   call assert_equal(string(sin(1.0/(1.0/0.0))), '0.0')
+   call assert_equal(string(sin(-1.0/(1.0/0.0))), '-0.0')
+ endfunc
+ 
+ func Test_asin()
+   call assert_equal(string(asin(0.0)), '0.0')
+   call assert_equal(string(asin(1.0)), '1.570796')
+   call assert_equal(string(asin(-0.5)), '-0.523599')
+   call assert_equal(string(asin(1.1)), 'nan')
+   call assert_equal(string(asin(1.0/0.0)), 'nan')
+   call assert_equal(string(asin(0.0/0.0)), 'nan')
+ endfunc
+ 
+ func Test_sinh()
+   call assert_equal(string(sinh(0.0)), '0.0')
+   call assert_equal(string(sinh(0.5)), '0.521095')
+   call assert_equal(string(sinh(-0.9)), '-1.026517')
+   call assert_equal(string(sinh(1.0/0.0)), 'inf')
+   call assert_equal(string(sinh(-1.0/0.0)), '-inf')
+   call assert_equal(string(sinh(0.0/0.0)), 'nan')
+ endfunc
+ 
+ func Test_cos()
+   call assert_equal(string(cos(0.0)), '1.0')
+   call assert_equal(string(cos(1.0)), '0.540302')
+   call assert_equal(string(cos(-0.5)), '0.877583')
+   call assert_equal(string(cos(0.0/0.0)), 'nan')
+   call assert_equal(string(cos(1.0/0.0)), 'nan')
+ endfunc
+ 
+ func Test_acos()
+   call assert_equal(string(acos(0.0)), '1.570796')
+   call assert_equal(string(acos(1.0)), '0.0')
+   call assert_equal(string(acos(-1.0)), '3.141593')
+   call assert_equal(string(acos(-0.5)), '2.094395')
+   call assert_equal(string(acos(1.1)), 'nan')
+   call assert_equal(string(acos(1.0/0.0)), 'nan')
+   call assert_equal(string(acos(0.0/0.0)), 'nan')
+ endfunc
+ 
+ func Test_cosh()
+   call assert_equal(string(cosh(0.0)), '1.0')
+   call assert_equal(string(cosh(0.5)), '1.127626')
+   call assert_equal(string(cosh(1.0/0.0)), 'inf')
+   call assert_equal(string(cosh(-1.0/0.0)), 'inf')
+   call assert_equal(string(cosh(0.0/0.0)), 'nan')
+ endfunc
+ 
+ func Test_tan()
+   call assert_equal(string(tan(0.0)), '0.0')
+   call assert_equal(string(tan(0.5)), '0.546302')
+   call assert_equal(string(tan(-0.5)), '-0.546302')
+   call assert_equal(string(tan(1.0/0.0)), 'nan')
+   call assert_equal(string(cos(0.0/0.0)), 'nan')
+   call assert_equal(string(tan(1.0/(1.0/0.0))), '0.0')
+   call assert_equal(string(tan(-1.0/(1.0/0.0))), '-0.0')
+ endfunc
+ 
+ func Test_atan()
+   call assert_equal(string(atan(0.0)), '0.0')
+   call assert_equal(string(atan(0.5)), '0.463648')
+   call assert_equal(string(atan(-1.0)), '-0.785398')
+   call assert_equal(string(atan(1.0/0.0)), '1.570796')
+   call assert_equal(string(atan(-1.0/0.0)), '-1.570796')
+   call assert_equal(string(atan(0.0/0.0)), 'nan')
+ endfunc
+ 
+ func Test_atan2()
+   call assert_equal(string(atan2(-1, -1)), '-2.356194')
+   call assert_equal(string(atan2(1, -1)), '2.356194')
+   call assert_equal(string(atan2(1.0, 1.0/0.0)), '0.0')
+   call assert_equal(string(atan2(1.0/0.0, 1.0)), '1.570796')
+   call assert_equal(string(atan2(0.0/0.0, 1.0)), 'nan')
+ endfunc
+ 
+ func Test_tanh()
+   call assert_equal(string(tanh(0.0)), '0.0')
+   call assert_equal(string(tanh(0.5)), '0.462117')
+   call assert_equal(string(tanh(-1.0)), '-0.761594')
+   call assert_equal(string(tanh(1.0/0.0)), '1.0')
+   call assert_equal(string(tanh(-1.0/0.0)), '-1.0')
+   call assert_equal(string(tanh(0.0/0.0)), 'nan')
+ endfunc
+ 
+ func Test_fmod()
+   call assert_equal(string(fmod(12.33, 1.22)), '0.13')
+   call assert_equal(string(fmod(-12.33, 1.22)), '-0.13')
+   call assert_equal(string(fmod(1.0/0.0, 1.0)), 'nan')
+   call assert_equal(string(fmod(1.0, 1.0/0.0)), '1.0')
+   call assert_equal(string(fmod(1.0, 0.0)), 'nan')
+ endfunc
+ 
+ func Test_pow()
+   call assert_equal(string(pow(0.0, 0.0)), '1.0')
+   call assert_equal(string(pow(2.0, 3.0)), '8.0')
+   call assert_equal(string(pow(2.0, 0.0/0.0)), 'nan')
+   call assert_equal(string(pow(0.0/0.0, 3.0)), 'nan')
+   call assert_equal(string(pow(0.0/0.0, 3.0)), 'nan')
+   call assert_equal(string(pow(2.0, 1.0/0.0)), 'inf')
+   call assert_equal(string(pow(1.0/0.0, 3.0)), 'inf')
+ endfunc
+ 
+ func Test_str2float()
+   call assert_equal(string(str2float('1')), '1.0')
+   call assert_equal(string(str2float('1.23')), '1.23')
+   call assert_equal(string(str2float('1.23abc')), '1.23')
+   call assert_equal(string(str2float('1e40')), '1.0e40')
+   call assert_equal(string(str2float('1e1000')), 'inf')
+   call assert_equal(string(str2float('inf')), 'inf')
+   call assert_equal(string(str2float('-inf')), '-inf')
+   call assert_equal(string(str2float('Inf')), 'inf')
+   call assert_equal(string(str2float('nan')), 'nan')
+   call assert_equal(string(str2float('NaN')), 'nan')
+ endfunc
+ 
+ func Test_floor()
+   call assert_equal(string(floor(2.0)), '2.0')
+   call assert_equal(string(floor(2.11)), '2.0')
+   call assert_equal(string(floor(2.99)), '2.0')
+   call assert_equal(string(floor(-2.11)), '-3.0')
+   call assert_equal(string(floor(-2.99)), '-3.0')
+   call assert_equal(string(floor(0.0/0.0)), 'nan')
+   call assert_equal(string(floor(1.0/0.0)), 'inf')
+   call assert_equal(string(floor(-1.0/0.0)), '-inf')
+ endfunc
+ 
+ func Test_ceil()
+   call assert_equal(string(ceil(2.0)), '2.0')
+   call assert_equal(string(ceil(2.11)), '3.0')
+   call assert_equal(string(ceil(2.99)), '3.0')
+   call assert_equal(string(ceil(-2.11)), '-2.0')
+   call assert_equal(string(ceil(-2.99)), '-2.0')
+   call assert_equal(string(ceil(0.0/0.0)), 'nan')
+   call assert_equal(string(ceil(1.0/0.0)), 'inf')
+   call assert_equal(string(ceil(-1.0/0.0)), '-inf')
+ endfunc
+ 
+ func Test_round()
+   call assert_equal(string(round(2.1)), '2.0')
+   call assert_equal(string(round(2.5)), '3.0')
+   call assert_equal(string(round(2.9)), '3.0')
+   call assert_equal(string(round(-2.1)), '-2.0')
+   call assert_equal(string(round(-2.5)), '-3.0')
+   call assert_equal(string(round(-2.9)), '-3.0')
+   call assert_equal(string(round(0.0/0.0)), 'nan')
+   call assert_equal(string(round(1.0/0.0)), 'inf')
+   call assert_equal(string(round(-1.0/0.0)), '-inf')
+ endfunc
+ 
+ func Test_trunc()
+   call assert_equal(string(trunc(2.1)), '2.0')
+   call assert_equal(string(trunc(2.5)), '2.0')
+   call assert_equal(string(trunc(2.9)), '2.0')
+   call assert_equal(string(trunc(-2.1)), '-2.0')
+   call assert_equal(string(trunc(-2.5)), '-2.0')
+   call assert_equal(string(trunc(-2.9)), '-2.0')
+   call assert_equal(string(trunc(0.0/0.0)), 'nan')
+   call assert_equal(string(trunc(1.0/0.0)), 'inf')
+   call assert_equal(string(trunc(-1.0/0.0)), '-inf')
+ endfunc
+ 
+ func Test_isnan()
+   call assert_equal(isnan(1.0), 0)
+   call assert_equal(isnan(0.0/0.0), 1)
+   call assert_equal(isnan(1.0/0.0), 0)
+   call assert_equal(isnan('a'), 0)
+   call assert_equal(isnan([]), 0)
+ endfunc
*** ../vim-8.0.0155/src/version.c	2017-01-08 17:46:16.016900321 +0100
--- src/version.c	2017-01-08 17:51:37.066462739 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     156,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
223. You set up a web-cam as your home's security system.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0157
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0157
Problem:    No command line completion for ":syntax spell" and ":syntax sync".
Solution:   Implement the completion. (Dominique Pelle)
Files:      src/syntax.c, src/testdir/test_syntax.vim


*** ../vim-8.0.0156/src/syntax.c	2017-01-08 17:46:16.016900321 +0100
--- src/syntax.c	2017-01-08 18:27:27.062154264 +0100
***************
*** 6383,6389 ****
  static enum
  {
      EXP_SUBCMD,	    /* expand ":syn" sub-commands */
!     EXP_CASE	    /* expand ":syn case" arguments */
  } expand_what;
  
  /*
--- 6383,6391 ----
  static enum
  {
      EXP_SUBCMD,	    /* expand ":syn" sub-commands */
!     EXP_CASE,	    /* expand ":syn case" arguments */
!     EXP_SPELL,	    /* expand ":syn spell" arguments */
!     EXP_SYNC	    /* expand ":syn sync" arguments */
  } expand_what;
  
  /*
***************
*** 6434,6439 ****
--- 6436,6445 ----
  		xp->xp_context = EXPAND_NOTHING;
  	    else if (STRNICMP(arg, "case", p - arg) == 0)
  		expand_what = EXP_CASE;
+ 	    else if (STRNICMP(arg, "spell", p - arg) == 0)
+ 		expand_what = EXP_SPELL;
+ 	    else if (STRNICMP(arg, "sync", p - arg) == 0)
+ 		expand_what = EXP_SYNC;
  	    else if (  STRNICMP(arg, "keyword", p - arg) == 0
  		    || STRNICMP(arg, "region", p - arg) == 0
  		    || STRNICMP(arg, "match", p - arg) == 0
***************
*** 6445,6452 ****
      }
  }
  
- static char *(case_args[]) = {"match", "ignore", NULL};
- 
  /*
   * Function given to ExpandGeneric() to obtain the list syntax names for
   * expansion.
--- 6451,6456 ----
***************
*** 6454,6462 ****
      char_u *
  get_syntax_name(expand_T *xp UNUSED, int idx)
  {
!     if (expand_what == EXP_SUBCMD)
! 	return (char_u *)subcommands[idx].name;
!     return (char_u *)case_args[idx];
  }
  
  #endif /* FEAT_CMDL_COMPL */
--- 6458,6488 ----
      char_u *
  get_syntax_name(expand_T *xp UNUSED, int idx)
  {
!     switch (expand_what)
!     {
! 	case EXP_SUBCMD:
! 	    return (char_u *)subcommands[idx].name;
! 	case EXP_CASE:
! 	{
! 	    static char *case_args[] = {"match", "ignore", NULL};
! 	    return (char_u *)case_args[idx];
! 	}
! 	case EXP_SPELL:
! 	{
! 	    static char *spell_args[] =
! 		{"toplevel", "notoplevel", "default", NULL};
! 	    return (char_u *)spell_args[idx];
! 	}
! 	case EXP_SYNC:
! 	{
! 	    static char *sync_args[] =
! 		{"ccomment", "clear", "fromstart",
! 		 "linebreaks=", "linecont", "lines=", "match",
! 		 "maxlines=", "minlines=", "region", NULL};
! 	    return (char_u *)sync_args[idx];
! 	}
!     }
!     return NULL;
  }
  
  #endif /* FEAT_CMDL_COMPL */
*** ../vim-8.0.0156/src/testdir/test_syntax.vim	2016-12-11 15:24:45.015136329 +0100
--- src/testdir/test_syntax.vim	2017-01-08 18:25:38.922970741 +0100
***************
*** 150,155 ****
--- 150,161 ----
    call feedkeys(":syn case \<C-A>\<C-B>\"\<CR>", 'tx')
    call assert_equal('"syn case ignore match', @:)
  
+   call feedkeys(":syn spell \<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"syn spell default notoplevel toplevel', @:)
+ 
+   call feedkeys(":syn sync \<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"syn sync ccomment clear fromstart linebreaks= linecont lines= match maxlines= minlines= region', @:)
+ 
    call feedkeys(":syn list \<C-A>\<C-B>\"\<CR>", 'tx')
    call assert_match('^"syn list Boolean Character ', @:)
  
*** ../vim-8.0.0156/src/version.c	2017-01-08 17:58:58.767107006 +0100
--- src/version.c	2017-01-08 18:26:14.842699536 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     157,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
228. You spend Saturday night making the counter on your home page
     pass that 2000 mark.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0158
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0158 (after 8.0.0156)
Problem:    On MS-Windows some float functions return a different value when
            passed unusual values.  strtod() doesn't work for "inf" and "nan".
Solution:   Accept both results.  Fix str2float() for MS-Windows.  Also
            reorder assert function arguments.
Files:      src/testdir/test_float_func.vim, src/eval.c


*** ../vim-8.0.0157/src/testdir/test_float_func.vim	2017-01-08 17:58:58.767107006 +0100
--- src/testdir/test_float_func.vim	2017-01-08 18:58:26.256142083 +0100
***************
*** 5,227 ****
  end
  
  func Test_abs()
!   call assert_equal(string(abs(1.23)), '1.23')
!   call assert_equal(string(abs(-1.23)), '1.23')
!   call assert_equal(string(abs(0.0)), '0.0')
!   call assert_equal(string(abs(1.0/(1.0/0.0))), '0.0')
!   call assert_equal(string(abs(-1.0/(1.0/0.0))), '0.0')
!   call assert_equal(string(abs(1.0/0.0)), 'inf')
!   call assert_equal(string(abs(-1.0/0.0)), 'inf')
!   call assert_equal(string(abs(0.0/0.0)), 'nan')
  endfunc
  
  func Test_sqrt()
!   call assert_equal(string(sqrt(0.0)), '0.0')
!   call assert_equal(string(sqrt(2.0)), '1.414214')
!   call assert_equal(string(sqrt(1.0/0.0)), 'inf')
!   call assert_equal(string(sqrt(-1.0)), 'nan')
!   call assert_equal(string(sqrt(0.0/0.0)), 'nan')
  endfunc
  
  func Test_log()
!   call assert_equal(string(log(1.0)), '0.0')
!   call assert_equal(string(log(0.5)), '-0.693147')
!   call assert_equal(string(log(0.0)), '-inf')
!   call assert_equal(string(log(-1.0)), 'nan')
!   call assert_equal(string(log(1.0/0.0)), 'inf')
!   call assert_equal(string(log(0.0/0.0)), 'nan')
  endfunc
  
  func Test_log10()
!   call assert_equal(string(log10(1.0)), '0.0')
!   call assert_equal(string(log10(100.0)), '2.0')
!   call assert_equal(string(log10(120.0)), '2.079181')
!   call assert_equal(string(log10(0.0)), '-inf')
!   call assert_equal(string(log10(-1.0)), 'nan')
!   call assert_equal(string(log10(1.0/0.0)), 'inf')
!   call assert_equal(string(log10(0.0/0.0)), 'nan')
  endfunc
  
  func Test_exp()
!   call assert_equal(string(exp(0.0)), '1.0')
!   call assert_equal(string(exp(2.0)), '7.389056')
!   call assert_equal(string(exp(-1.0)),'0.367879')
!   call assert_equal(string(exp(1.0/0.0)), 'inf')
!   call assert_equal(string(exp(-1.0/0.0)), '0.0')
!   call assert_equal(string(exp(0.0/0.0)), 'nan')
  endfunc
  
  func Test_sin()
!   call assert_equal(string(sin(0.0)), '0.0')
!   call assert_equal(string(sin(1.0)), '0.841471')
!   call assert_equal(string(sin(-0.5)), '-0.479426')
!   call assert_equal(string(sin(0.0/0.0)), 'nan')
!   call assert_equal(string(sin(1.0/0.0)), 'nan')
!   call assert_equal(string(sin(1.0/(1.0/0.0))), '0.0')
!   call assert_equal(string(sin(-1.0/(1.0/0.0))), '-0.0')
  endfunc
  
  func Test_asin()
!   call assert_equal(string(asin(0.0)), '0.0')
!   call assert_equal(string(asin(1.0)), '1.570796')
!   call assert_equal(string(asin(-0.5)), '-0.523599')
!   call assert_equal(string(asin(1.1)), 'nan')
!   call assert_equal(string(asin(1.0/0.0)), 'nan')
!   call assert_equal(string(asin(0.0/0.0)), 'nan')
  endfunc
  
  func Test_sinh()
!   call assert_equal(string(sinh(0.0)), '0.0')
!   call assert_equal(string(sinh(0.5)), '0.521095')
!   call assert_equal(string(sinh(-0.9)), '-1.026517')
!   call assert_equal(string(sinh(1.0/0.0)), 'inf')
!   call assert_equal(string(sinh(-1.0/0.0)), '-inf')
!   call assert_equal(string(sinh(0.0/0.0)), 'nan')
  endfunc
  
  func Test_cos()
!   call assert_equal(string(cos(0.0)), '1.0')
!   call assert_equal(string(cos(1.0)), '0.540302')
!   call assert_equal(string(cos(-0.5)), '0.877583')
!   call assert_equal(string(cos(0.0/0.0)), 'nan')
!   call assert_equal(string(cos(1.0/0.0)), 'nan')
  endfunc
  
  func Test_acos()
!   call assert_equal(string(acos(0.0)), '1.570796')
!   call assert_equal(string(acos(1.0)), '0.0')
!   call assert_equal(string(acos(-1.0)), '3.141593')
!   call assert_equal(string(acos(-0.5)), '2.094395')
!   call assert_equal(string(acos(1.1)), 'nan')
!   call assert_equal(string(acos(1.0/0.0)), 'nan')
!   call assert_equal(string(acos(0.0/0.0)), 'nan')
  endfunc
  
  func Test_cosh()
!   call assert_equal(string(cosh(0.0)), '1.0')
!   call assert_equal(string(cosh(0.5)), '1.127626')
!   call assert_equal(string(cosh(1.0/0.0)), 'inf')
!   call assert_equal(string(cosh(-1.0/0.0)), 'inf')
!   call assert_equal(string(cosh(0.0/0.0)), 'nan')
  endfunc
  
  func Test_tan()
!   call assert_equal(string(tan(0.0)), '0.0')
!   call assert_equal(string(tan(0.5)), '0.546302')
!   call assert_equal(string(tan(-0.5)), '-0.546302')
!   call assert_equal(string(tan(1.0/0.0)), 'nan')
!   call assert_equal(string(cos(0.0/0.0)), 'nan')
!   call assert_equal(string(tan(1.0/(1.0/0.0))), '0.0')
!   call assert_equal(string(tan(-1.0/(1.0/0.0))), '-0.0')
  endfunc
  
  func Test_atan()
!   call assert_equal(string(atan(0.0)), '0.0')
!   call assert_equal(string(atan(0.5)), '0.463648')
!   call assert_equal(string(atan(-1.0)), '-0.785398')
!   call assert_equal(string(atan(1.0/0.0)), '1.570796')
!   call assert_equal(string(atan(-1.0/0.0)), '-1.570796')
!   call assert_equal(string(atan(0.0/0.0)), 'nan')
  endfunc
  
  func Test_atan2()
!   call assert_equal(string(atan2(-1, -1)), '-2.356194')
!   call assert_equal(string(atan2(1, -1)), '2.356194')
!   call assert_equal(string(atan2(1.0, 1.0/0.0)), '0.0')
!   call assert_equal(string(atan2(1.0/0.0, 1.0)), '1.570796')
!   call assert_equal(string(atan2(0.0/0.0, 1.0)), 'nan')
  endfunc
  
  func Test_tanh()
!   call assert_equal(string(tanh(0.0)), '0.0')
!   call assert_equal(string(tanh(0.5)), '0.462117')
!   call assert_equal(string(tanh(-1.0)), '-0.761594')
!   call assert_equal(string(tanh(1.0/0.0)), '1.0')
!   call assert_equal(string(tanh(-1.0/0.0)), '-1.0')
!   call assert_equal(string(tanh(0.0/0.0)), 'nan')
  endfunc
  
  func Test_fmod()
!   call assert_equal(string(fmod(12.33, 1.22)), '0.13')
!   call assert_equal(string(fmod(-12.33, 1.22)), '-0.13')
!   call assert_equal(string(fmod(1.0/0.0, 1.0)), 'nan')
!   call assert_equal(string(fmod(1.0, 1.0/0.0)), '1.0')
!   call assert_equal(string(fmod(1.0, 0.0)), 'nan')
  endfunc
  
  func Test_pow()
!   call assert_equal(string(pow(0.0, 0.0)), '1.0')
!   call assert_equal(string(pow(2.0, 3.0)), '8.0')
!   call assert_equal(string(pow(2.0, 0.0/0.0)), 'nan')
!   call assert_equal(string(pow(0.0/0.0, 3.0)), 'nan')
!   call assert_equal(string(pow(0.0/0.0, 3.0)), 'nan')
!   call assert_equal(string(pow(2.0, 1.0/0.0)), 'inf')
!   call assert_equal(string(pow(1.0/0.0, 3.0)), 'inf')
  endfunc
  
  func Test_str2float()
!   call assert_equal(string(str2float('1')), '1.0')
!   call assert_equal(string(str2float('1.23')), '1.23')
!   call assert_equal(string(str2float('1.23abc')), '1.23')
!   call assert_equal(string(str2float('1e40')), '1.0e40')
!   call assert_equal(string(str2float('1e1000')), 'inf')
!   call assert_equal(string(str2float('inf')), 'inf')
!   call assert_equal(string(str2float('-inf')), '-inf')
!   call assert_equal(string(str2float('Inf')), 'inf')
!   call assert_equal(string(str2float('nan')), 'nan')
!   call assert_equal(string(str2float('NaN')), 'nan')
  endfunc
  
  func Test_floor()
!   call assert_equal(string(floor(2.0)), '2.0')
!   call assert_equal(string(floor(2.11)), '2.0')
!   call assert_equal(string(floor(2.99)), '2.0')
!   call assert_equal(string(floor(-2.11)), '-3.0')
!   call assert_equal(string(floor(-2.99)), '-3.0')
!   call assert_equal(string(floor(0.0/0.0)), 'nan')
!   call assert_equal(string(floor(1.0/0.0)), 'inf')
!   call assert_equal(string(floor(-1.0/0.0)), '-inf')
  endfunc
  
  func Test_ceil()
!   call assert_equal(string(ceil(2.0)), '2.0')
!   call assert_equal(string(ceil(2.11)), '3.0')
!   call assert_equal(string(ceil(2.99)), '3.0')
!   call assert_equal(string(ceil(-2.11)), '-2.0')
!   call assert_equal(string(ceil(-2.99)), '-2.0')
!   call assert_equal(string(ceil(0.0/0.0)), 'nan')
!   call assert_equal(string(ceil(1.0/0.0)), 'inf')
!   call assert_equal(string(ceil(-1.0/0.0)), '-inf')
  endfunc
  
  func Test_round()
!   call assert_equal(string(round(2.1)), '2.0')
!   call assert_equal(string(round(2.5)), '3.0')
!   call assert_equal(string(round(2.9)), '3.0')
!   call assert_equal(string(round(-2.1)), '-2.0')
!   call assert_equal(string(round(-2.5)), '-3.0')
!   call assert_equal(string(round(-2.9)), '-3.0')
!   call assert_equal(string(round(0.0/0.0)), 'nan')
!   call assert_equal(string(round(1.0/0.0)), 'inf')
!   call assert_equal(string(round(-1.0/0.0)), '-inf')
  endfunc
  
  func Test_trunc()
!   call assert_equal(string(trunc(2.1)), '2.0')
!   call assert_equal(string(trunc(2.5)), '2.0')
!   call assert_equal(string(trunc(2.9)), '2.0')
!   call assert_equal(string(trunc(-2.1)), '-2.0')
!   call assert_equal(string(trunc(-2.5)), '-2.0')
!   call assert_equal(string(trunc(-2.9)), '-2.0')
!   call assert_equal(string(trunc(0.0/0.0)), 'nan')
!   call assert_equal(string(trunc(1.0/0.0)), 'inf')
!   call assert_equal(string(trunc(-1.0/0.0)), '-inf')
  endfunc
  
  func Test_isnan()
!   call assert_equal(isnan(1.0), 0)
!   call assert_equal(isnan(0.0/0.0), 1)
!   call assert_equal(isnan(1.0/0.0), 0)
!   call assert_equal(isnan('a'), 0)
!   call assert_equal(isnan([]), 0)
  endfunc
--- 5,231 ----
  end
  
  func Test_abs()
!   call assert_equal('1.23', string(abs(1.23)))
!   call assert_equal('1.23', string(abs(-1.23)))
!   call assert_equal('0.0', string(abs(0.0)))
!   call assert_equal('0.0', string(abs(1.0/(1.0/0.0))))
!   call assert_equal('0.0', string(abs(-1.0/(1.0/0.0))))
!   call assert_equal('inf', string(abs(1.0/0.0)))
!   call assert_equal('inf', string(abs(-1.0/0.0)))
!   call assert_equal('nan', string(abs(0.0/0.0)))
  endfunc
  
  func Test_sqrt()
!   call assert_equal('0.0', string(sqrt(0.0)))
!   call assert_equal('1.414214', string(sqrt(2.0)))
!   call assert_equal('inf', string(sqrt(1.0/0.0)))
!   call assert_equal('nan', string(sqrt(-1.0)))
!   call assert_equal('nan', string(sqrt(0.0/0.0)))
  endfunc
  
  func Test_log()
!   call assert_equal('0.0', string(log(1.0)))
!   call assert_equal('-0.693147', string(log(0.5)))
!   call assert_equal('-inf', string(log(0.0)))
!   call assert_equal('nan', string(log(-1.0)))
!   call assert_equal('inf', string(log(1.0/0.0)))
!   call assert_equal('nan', string(log(0.0/0.0)))
  endfunc
  
  func Test_log10()
!   call assert_equal('0.0', string(log10(1.0)))
!   call assert_equal('2.0', string(log10(100.0)))
!   call assert_equal('2.079181', string(log10(120.0)))
!   call assert_equal('-inf', string(log10(0.0)))
!   call assert_equal('nan', string(log10(-1.0)))
!   call assert_equal('inf', string(log10(1.0/0.0)))
!   call assert_equal('nan', string(log10(0.0/0.0)))
  endfunc
  
  func Test_exp()
!   call assert_equal('1.0', string(exp(0.0)))
!   call assert_equal('7.389056', string(exp(2.0)))
!   call assert_equal('0.367879', string(exp(-1.0)))
!   call assert_equal('inf', string(exp(1.0/0.0)))
!   call assert_equal('0.0', string(exp(-1.0/0.0)))
!   call assert_equal('nan', string(exp(0.0/0.0)))
  endfunc
  
  func Test_sin()
!   call assert_equal('0.0', string(sin(0.0)))
!   call assert_equal('0.841471', string(sin(1.0)))
!   call assert_equal('-0.479426', string(sin(-0.5)))
!   call assert_equal('nan', string(sin(0.0/0.0)))
!   call assert_equal('nan', string(sin(1.0/0.0)))
!   call assert_equal('0.0', string(sin(1.0/(1.0/0.0))))
!   call assert_equal('-0.0', string(sin(-1.0/(1.0/0.0))))
  endfunc
  
  func Test_asin()
!   call assert_equal('0.0', string(asin(0.0)))
!   call assert_equal('1.570796', string(asin(1.0)))
!   call assert_equal('-0.523599', string(asin(-0.5)))
!   call assert_equal('nan', string(asin(1.1)))
!   call assert_equal('nan', string(asin(1.0/0.0)))
!   call assert_equal('nan', string(asin(0.0/0.0)))
  endfunc
  
  func Test_sinh()
!   call assert_equal('0.0', string(sinh(0.0)))
!   call assert_equal('0.521095', string(sinh(0.5)))
!   call assert_equal('-1.026517', string(sinh(-0.9)))
!   call assert_equal('inf', string(sinh(1.0/0.0)))
!   call assert_equal('-inf', string(sinh(-1.0/0.0)))
!   call assert_equal('nan', string(sinh(0.0/0.0)))
  endfunc
  
  func Test_cos()
!   call assert_equal('1.0', string(cos(0.0)))
!   call assert_equal('0.540302', string(cos(1.0)))
!   call assert_equal('0.877583', string(cos(-0.5)))
!   call assert_equal('nan', string(cos(0.0/0.0)))
!   call assert_equal('nan', string(cos(1.0/0.0)))
  endfunc
  
  func Test_acos()
!   call assert_equal('1.570796', string(acos(0.0)))
!   call assert_equal('0.0', string(acos(1.0)))
!   call assert_equal('3.141593', string(acos(-1.0)))
!   call assert_equal('2.094395', string(acos(-0.5)))
!   call assert_equal('nan', string(acos(1.1)))
!   call assert_equal('nan', string(acos(1.0/0.0)))
!   call assert_equal('nan', string(acos(0.0/0.0)))
  endfunc
  
  func Test_cosh()
!   call assert_equal('1.0', string(cosh(0.0)))
!   call assert_equal('1.127626', string(cosh(0.5)))
!   call assert_equal('inf', string(cosh(1.0/0.0)))
!   call assert_equal('inf', string(cosh(-1.0/0.0)))
!   call assert_equal('nan', string(cosh(0.0/0.0)))
  endfunc
  
  func Test_tan()
!   call assert_equal('0.0', string(tan(0.0)))
!   call assert_equal('0.546302', string(tan(0.5)))
!   call assert_equal('-0.546302', string(tan(-0.5)))
!   call assert_equal('nan', string(tan(1.0/0.0)))
!   call assert_equal('nan', string(cos(0.0/0.0)))
!   call assert_equal('0.0', string(tan(1.0/(1.0/0.0))))
!   call assert_equal('-0.0', string(tan(-1.0/(1.0/0.0))))
  endfunc
  
  func Test_atan()
!   call assert_equal('0.0', string(atan(0.0)))
!   call assert_equal('0.463648', string(atan(0.5)))
!   call assert_equal('-0.785398', string(atan(-1.0)))
!   call assert_equal('1.570796', string(atan(1.0/0.0)))
!   call assert_equal('-1.570796', string(atan(-1.0/0.0)))
!   call assert_equal('nan', string(atan(0.0/0.0)))
  endfunc
  
  func Test_atan2()
!   call assert_equal('-2.356194', string(atan2(-1, -1)))
!   call assert_equal('2.356194', string(atan2(1, -1)))
!   call assert_equal('0.0', string(atan2(1.0, 1.0/0.0)))
!   call assert_equal('1.570796', string(atan2(1.0/0.0, 1.0)))
!   call assert_equal('nan', string(atan2(0.0/0.0, 1.0)))
  endfunc
  
  func Test_tanh()
!   call assert_equal('0.0', string(tanh(0.0)))
!   call assert_equal('0.462117', string(tanh(0.5)))
!   call assert_equal('-0.761594', string(tanh(-1.0)))
!   call assert_equal('1.0', string(tanh(1.0/0.0)))
!   call assert_equal('-1.0', string(tanh(-1.0/0.0)))
!   call assert_equal('nan', string(tanh(0.0/0.0)))
  endfunc
  
  func Test_fmod()
!   call assert_equal('0.13', string(fmod(12.33, 1.22)))
!   call assert_equal('-0.13', string(fmod(-12.33, 1.22)))
!   call assert_equal('nan', string(fmod(1.0/0.0, 1.0)))
!   " On Windows we get "nan" instead of 1.0, accept both.
!   let res = string(fmod(1.0, 1.0/0.0))
!   if res != 'nan'
!     call assert_equal('1.0', res)
!   endif
!   call assert_equal('nan', string(fmod(1.0, 0.0)))
  endfunc
  
  func Test_pow()
!   call assert_equal('1.0', string(pow(0.0, 0.0)))
!   call assert_equal('8.0', string(pow(2.0, 3.0)))
!   call assert_equal('nan', string(pow(2.0, 0.0/0.0)))
!   call assert_equal('nan', string(pow(0.0/0.0, 3.0)))
!   call assert_equal('nan', string(pow(0.0/0.0, 3.0)))
!   call assert_equal('inf', string(pow(2.0, 1.0/0.0)))
!   call assert_equal('inf', string(pow(1.0/0.0, 3.0)))
  endfunc
  
  func Test_str2float()
!   call assert_equal('1.0', string(str2float('1')))
!   call assert_equal('1.23', string(str2float('1.23')))
!   call assert_equal('1.23', string(str2float('1.23abc')))
!   call assert_equal('1.0e40', string(str2float('1e40')))
!   call assert_equal('inf', string(str2float('1e1000')))
!   call assert_equal('inf', string(str2float('inf')))
!   call assert_equal('-inf', string(str2float('-inf')))
!   call assert_equal('inf', string(str2float('Inf')))
!   call assert_equal('nan', string(str2float('nan')))
!   call assert_equal('nan', string(str2float('NaN')))
  endfunc
  
  func Test_floor()
!   call assert_equal('2.0', string(floor(2.0)))
!   call assert_equal('2.0', string(floor(2.11)))
!   call assert_equal('2.0', string(floor(2.99)))
!   call assert_equal('-3.0', string(floor(-2.11)))
!   call assert_equal('-3.0', string(floor(-2.99)))
!   call assert_equal('nan', string(floor(0.0/0.0)))
!   call assert_equal('inf', string(floor(1.0/0.0)))
!   call assert_equal('-inf', string(floor(-1.0/0.0)))
  endfunc
  
  func Test_ceil()
!   call assert_equal('2.0', string(ceil(2.0)))
!   call assert_equal('3.0', string(ceil(2.11)))
!   call assert_equal('3.0', string(ceil(2.99)))
!   call assert_equal('-2.0', string(ceil(-2.11)))
!   call assert_equal('-2.0', string(ceil(-2.99)))
!   call assert_equal('nan', string(ceil(0.0/0.0)))
!   call assert_equal('inf', string(ceil(1.0/0.0)))
!   call assert_equal('-inf', string(ceil(-1.0/0.0)))
  endfunc
  
  func Test_round()
!   call assert_equal('2.0', string(round(2.1)))
!   call assert_equal('3.0', string(round(2.5)))
!   call assert_equal('3.0', string(round(2.9)))
!   call assert_equal('-2.0', string(round(-2.1)))
!   call assert_equal('-3.0', string(round(-2.5)))
!   call assert_equal('-3.0', string(round(-2.9)))
!   call assert_equal('nan', string(round(0.0/0.0)))
!   call assert_equal('inf', string(round(1.0/0.0)))
!   call assert_equal('-inf', string(round(-1.0/0.0)))
  endfunc
  
  func Test_trunc()
!   call assert_equal('2.0', string(trunc(2.1)))
!   call assert_equal('2.0', string(trunc(2.5)))
!   call assert_equal('2.0', string(trunc(2.9)))
!   call assert_equal('-2.0', string(trunc(-2.1)))
!   call assert_equal('-2.0', string(trunc(-2.5)))
!   call assert_equal('-2.0', string(trunc(-2.9)))
!   call assert_equal('nan', string(trunc(0.0/0.0)))
!   call assert_equal('inf', string(trunc(1.0/0.0)))
!   call assert_equal('-inf', string(trunc(-1.0/0.0)))
  endfunc
  
  func Test_isnan()
!   call assert_equal(0, isnan(1.0))
!   call assert_equal(1, isnan(0.0/0.0))
!   call assert_equal(0, isnan(1.0/0.0))
!   call assert_equal(0, isnan('a'))
!   call assert_equal(0, isnan([]))
  endfunc
*** ../vim-8.0.0157/src/eval.c	2016-11-17 17:25:28.208093136 +0100
--- src/eval.c	2017-01-08 18:55:13.837590334 +0100
***************
*** 5971,5976 ****
--- 5971,5992 ----
      char	*s = (char *)text;
      float_T	f;
  
+     /* MS-Windows does not deal with "inf" and "nan" properly. */
+     if (STRNICMP(text, "inf", 3) == 0)
+     {
+ 	*value = INFINITY;
+ 	return 3;
+     }
+     if (STRNICMP(text, "-inf", 3) == 0)
+     {
+ 	*value = -INFINITY;
+ 	return 4;
+     }
+     if (STRNICMP(text, "nan", 3) == 0)
+     {
+ 	*value = NAN;
+ 	return 3;
+     }
      f = strtod(s, &s);
      *value = f;
      return (int)((char_u *)s - text);
*** ../vim-8.0.0157/src/version.c	2017-01-08 18:28:18.965762385 +0100
--- src/version.c	2017-01-08 19:24:12.224515566 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     158,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
229. You spend so much time thinking what to add on this list.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0159
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0159
Problem:    Using a NULL pointer when using feedkeys() to trigger drawing a
            tabline.
Solution:   Skip drawing a tabline if TabPageIdxs is NULL. (Dominique Pelle)
            Also fix recursing into getcmdline() from the cmd window.
Files:      src/screen.c, src/ex_getln.c


*** ../vim-8.0.0158/src/screen.c	2016-12-09 19:28:33.576993205 +0100
--- src/screen.c	2017-01-08 19:53:03.803518585 +0100
***************
*** 3650,3656 ****
  		if (fdc > 0)
  		{
  		    /* Draw the 'foldcolumn'.  Allocate a buffer, "extra" may
! 		     * already be in used. */
  		    p_extra_free = alloc(12 + 1);
  
  		    if (p_extra_free != NULL)
--- 3650,3656 ----
  		if (fdc > 0)
  		{
  		    /* Draw the 'foldcolumn'.  Allocate a buffer, "extra" may
! 		     * already be in use. */
  		    p_extra_free = alloc(12 + 1);
  
  		    if (p_extra_free != NULL)
***************
*** 10344,10349 ****
--- 10344,10351 ----
  #endif
  					    );
  
+     if (ScreenLines == NULL)
+ 	return;
      redraw_tabline = FALSE;
  
  #ifdef FEAT_GUI_TABLINE
*** ../vim-8.0.0158/src/ex_getln.c	2016-10-15 15:39:34.685059653 +0200
--- src/ex_getln.c	2017-01-08 19:55:36.542378038 +0100
***************
*** 772,778 ****
--- 772,780 ----
  		/*
  		 * Open a window to edit the command line (and history).
  		 */
+ 		save_cmdline(&save_ccline);
  		c = ex_window();
+ 		restore_cmdline(&save_ccline);
  		some_key_typed = TRUE;
  	    }
  	}
*** ../vim-8.0.0158/src/version.c	2017-01-08 19:25:34.851896407 +0100
--- src/version.c	2017-01-08 19:38:41.461992894 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     159,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
231. You sprinkle Carpet Fresh on the rugs and put your vacuum cleaner
     in the front doorway permanently so it always looks like you are
     actually attempting to do something about that mess that has amassed
     since you discovered the Internet.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0160
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0160
Problem:    EMSG() is sometimes used for internal errors.
Solution:   Change them to IEMSG(). (Dominique Pelle)  And a few more.
Files:      src/regexp_nfa.c, src/channel.c, src/eval.c


*** ../vim-8.0.0159/src/regexp_nfa.c	2016-10-02 16:51:32.744592886 +0200
--- src/regexp_nfa.c	2017-01-08 20:46:14.703544056 +0100
***************
*** 1359,1365 ****
  		    rc_did_emsg = TRUE;
  		    return FAIL;
  		}
! 		EMSGN("INTERNAL: Unknown character class char: %ld", c);
  		return FAIL;
  	    }
  #ifdef FEAT_MBYTE
--- 1359,1365 ----
  		    rc_did_emsg = TRUE;
  		    return FAIL;
  		}
! 		IEMSGN("INTERNAL: Unknown character class char: %ld", c);
  		return FAIL;
  	    }
  #ifdef FEAT_MBYTE
***************
*** 4925,4931 ****
  
  	default:
  	    /* should not be here :P */
! 	    EMSGN(_(e_ill_char_class), class);
  	    return FAIL;
      }
      return FAIL;
--- 4925,4931 ----
  
  	default:
  	    /* should not be here :P */
! 	    IEMSGN(_(e_ill_char_class), class);
  	    return FAIL;
      }
      return FAIL;
***************
*** 6688,6694 ****
  
  #ifdef DEBUG
  		if (c < 0)
! 		    EMSGN("INTERNAL: Negative state char: %ld", c);
  #endif
  		result = (c == curc);
  
--- 6688,6694 ----
  
  #ifdef DEBUG
  		if (c < 0)
! 		    IEMSGN("INTERNAL: Negative state char: %ld", c);
  #endif
  		result = (c == curc);
  
***************
*** 7216,7222 ****
      {
  	/* TODO: only give this error for debugging? */
  	if (post_ptr >= post_end)
! 	    EMSGN("Internal error: estimated max number of states insufficient: %ld", post_end - post_start);
  	goto fail;	    /* Cascaded (syntax?) error */
      }
  
--- 7216,7222 ----
      {
  	/* TODO: only give this error for debugging? */
  	if (post_ptr >= post_end)
! 	    IEMSGN("Internal error: estimated max number of states insufficient: %ld", post_end - post_start);
  	goto fail;	    /* Cascaded (syntax?) error */
      }
  
*** ../vim-8.0.0159/src/channel.c	2016-12-01 15:34:04.083413947 +0100
--- src/channel.c	2017-01-08 20:45:24.291925178 +0100
***************
*** 1567,1573 ****
      int		dummy;
  
      if (safe_to_invoke_callback == 0)
! 	EMSG("INTERNAL: Invoking callback when it is not safe");
  
      argv[0].v_type = VAR_CHANNEL;
      argv[0].vval.v_channel = channel;
--- 1567,1573 ----
      int		dummy;
  
      if (safe_to_invoke_callback == 0)
! 	IEMSG("INTERNAL: Invoking callback when it is not safe");
  
      argv[0].v_type = VAR_CHANNEL;
      argv[0].vval.v_channel = channel;
*** ../vim-8.0.0159/src/eval.c	2017-01-08 19:25:34.851896407 +0100
--- src/eval.c	2017-01-08 20:45:31.043874131 +0100
***************
*** 270,276 ****
  	p = &vimvars[i];
  	if (STRLEN(p->vv_name) > 16)
  	{
! 	    EMSG("INTERNAL: name too long, increase size of dictitem16_T");
  	    getout(1);
  	}
  	STRCPY(p->vv_di.di_key, p->vv_name);
--- 270,276 ----
  	p = &vimvars[i];
  	if (STRLEN(p->vv_name) > 16)
  	{
! 	    IEMSG("INTERNAL: name too long, increase size of dictitem16_T");
  	    getout(1);
  	}
  	STRCPY(p->vv_di.di_key, p->vv_name);
*** ../vim-8.0.0159/src/version.c	2017-01-08 20:00:00.232408217 +0100
--- src/version.c	2017-01-08 20:46:30.347426020 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     160,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
232. You start conversations with, "Have you gotten an ISDN line?"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0161
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0161 (after 8.0.0159)
Problem:    Build fails when using small features.
Solution:   Update #ifdef for using save_ccline. (Hirohito Higashi)
Files:      src/ex_getln.c


*** ../vim-8.0.0160/src/ex_getln.c	2017-01-08 20:00:00.232408217 +0100
--- src/ex_getln.c	2017-01-09 12:56:12.284740825 +0100
***************
*** 212,218 ****
  #endif
      expand_T	xpc;
      long	*b_im_ptr = NULL;
! #if defined(FEAT_WILDMENU) || defined(FEAT_EVAL) || defined(FEAT_SEARCH_EXTRA)
      /* Everything that may work recursively should save and restore the
       * current command line in save_ccline.  That includes update_screen(), a
       * custom status line may invoke ":normal". */
--- 212,219 ----
  #endif
      expand_T	xpc;
      long	*b_im_ptr = NULL;
! #if defined(FEAT_WILDMENU) || defined(FEAT_EVAL) \
!     || defined(FEAT_SEARCH_EXTRA) || defined(FEAT_CMDWIN)
      /* Everything that may work recursively should save and restore the
       * current command line in save_ccline.  That includes update_screen(), a
       * custom status line may invoke ":normal". */
*** ../vim-8.0.0160/src/version.c	2017-01-08 20:50:47.433486722 +0100
--- src/version.c	2017-01-09 12:57:16.584293120 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     161,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
233. You start dreaming about web pages...in html.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0162
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0162
Problem:    Build error on Fedora 23 with small features and gnome2.
Solution:   Undefine ngettext(). (Hirohito Higashi)
Files:      src/gui_gtk.c, src/gui_gtk_x11.c


*** ../vim-8.0.0161/src/gui_gtk.c	2016-11-17 19:11:51.713378271 +0100
--- src/gui_gtk.c	2017-01-09 20:27:08.988196714 +0100
***************
*** 51,56 ****
--- 51,59 ----
  # ifdef _
  #  undef _
  # endif
+ # ifdef ngettext
+ #  undef ngettext
+ # endif
  # ifdef N_
  #  undef N_
  # endif
*** ../vim-8.0.0161/src/gui_gtk_x11.c	2016-11-21 20:55:54.458792774 +0100
--- src/gui_gtk_x11.c	2017-01-09 20:27:08.992196684 +0100
***************
*** 35,40 ****
--- 35,43 ----
  # ifdef _
  #  undef _
  # endif
+ # ifdef ngettext
+ #  undef ngettext
+ # endif
  # ifdef N_
  #  undef N_
  # endif
*** ../vim-8.0.0161/src/version.c	2017-01-09 12:58:05.639951514 +0100
--- src/version.c	2017-01-09 20:28:54.415395961 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     162,
  /**/

-- 
Google is kind of like Dr. Who's Tardis; it's weirder on the
inside than on the outside...

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0163
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0163
Problem:    Ruby 2.4 no longer supports rb_cFixnum.
Solution:   move rb_cFixnum into an #ifdef. (Kazuki Sakamoto, closes #1365)
Files:      src/if_ruby.c


*** ../vim-8.0.0162/src/if_ruby.c	2016-08-29 22:42:20.000000000 +0200
--- src/if_ruby.c	2017-01-09 21:08:18.425187068 +0100
***************
*** 514,522 ****
  {
      {"rb_assoc_new", (RUBY_PROC*)&dll_rb_assoc_new},
      {"rb_cFalseClass", (RUBY_PROC*)&dll_rb_cFalseClass},
-     {"rb_cFixnum", (RUBY_PROC*)&dll_rb_cFixnum},
  # if defined(USE_RUBY_INTEGER)
      {"rb_cInteger", (RUBY_PROC*)&dll_rb_cInteger},
  # endif
  # if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 20
      {"rb_cFloat", (RUBY_PROC*)&dll_rb_cFloat},
--- 514,523 ----
  {
      {"rb_assoc_new", (RUBY_PROC*)&dll_rb_assoc_new},
      {"rb_cFalseClass", (RUBY_PROC*)&dll_rb_cFalseClass},
  # if defined(USE_RUBY_INTEGER)
      {"rb_cInteger", (RUBY_PROC*)&dll_rb_cInteger},
+ # else
+     {"rb_cFixnum", (RUBY_PROC*)&dll_rb_cFixnum},
  # endif
  # if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 20
      {"rb_cFloat", (RUBY_PROC*)&dll_rb_cFloat},
*** ../vim-8.0.0162/src/version.c	2017-01-09 20:30:23.902717531 +0100
--- src/version.c	2017-01-09 21:09:41.572549830 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     163,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
237. You tattoo your email address on your forehead.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0164
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0164
Problem:    Outdated and misplaced comments.
Solution:   Fix the comments.
Files:      src/charset.c, src/getchar.c, src/list.c, src/misc2.c,
            src/testdir/README.txt


*** ../vim-8.0.0163/src/charset.c	2016-08-29 22:42:20.000000000 +0200
--- src/charset.c	2016-12-09 18:50:34.664105987 +0100
***************
*** 887,893 ****
  
  /*
   * return TRUE if 'c' is a keyword character: Letters and characters from
!  * 'iskeyword' option for current buffer.
   * For multi-byte characters mb_get_class() is used (builtin rules).
   */
      int
--- 887,893 ----
  
  /*
   * return TRUE if 'c' is a keyword character: Letters and characters from
!  * 'iskeyword' option for the current buffer.
   * For multi-byte characters mb_get_class() is used (builtin rules).
   */
      int
*** ../vim-8.0.0163/src/getchar.c	2016-11-10 20:01:41.189582944 +0100
--- src/getchar.c	2016-12-05 22:45:38.020621662 +0100
***************
*** 978,1000 ****
  
      addlen = (int)STRLEN(str);
  
-     /*
-      * Easy case: there is room in front of typebuf.tb_buf[typebuf.tb_off]
-      */
      if (offset == 0 && addlen <= typebuf.tb_off)
      {
  	typebuf.tb_off -= addlen;
  	mch_memmove(typebuf.tb_buf + typebuf.tb_off, str, (size_t)addlen);
      }
- 
-     /*
-      * Need to allocate a new buffer.
-      * In typebuf.tb_buf there must always be room for 3 * MAXMAPLEN + 4
-      * characters.  We add some extra room to avoid having to allocate too
-      * often.
-      */
      else
      {
  	newoff = MAXMAPLEN + 4;
  	newlen = typebuf.tb_len + addlen + newoff + 4 * (MAXMAPLEN + 4);
  	if (newlen < 0)		    /* string is getting too long */
--- 978,999 ----
  
      addlen = (int)STRLEN(str);
  
      if (offset == 0 && addlen <= typebuf.tb_off)
      {
+ 	/*
+ 	 * Easy case: there is room in front of typebuf.tb_buf[typebuf.tb_off]
+ 	 */
  	typebuf.tb_off -= addlen;
  	mch_memmove(typebuf.tb_buf + typebuf.tb_off, str, (size_t)addlen);
      }
      else
      {
+ 	/*
+ 	 * Need to allocate a new buffer.
+ 	 * In typebuf.tb_buf there must always be room for 3 * MAXMAPLEN + 4
+ 	 * characters.  We add some extra room to avoid having to allocate too
+ 	 * often.
+ 	 */
  	newoff = MAXMAPLEN + 4;
  	newlen = typebuf.tb_len + addlen + newoff + 4 * (MAXMAPLEN + 4);
  	if (newlen < 0)		    /* string is getting too long */
***************
*** 2009,2015 ****
  	    {
  		/* KeyTyped = FALSE;  When the command that stuffed something
  		 * was typed, behave like the stuffed command was typed.
! 		 * needed for CTRL-W CTRl-] to open a fold, for example. */
  		KeyStuffed = TRUE;
  	    }
  	    if (typebuf.tb_no_abbr_cnt == 0)
--- 2008,2014 ----
  	    {
  		/* KeyTyped = FALSE;  When the command that stuffed something
  		 * was typed, behave like the stuffed command was typed.
! 		 * needed for CTRL-W CTRL-] to open a fold, for example. */
  		KeyStuffed = TRUE;
  	    }
  	    if (typebuf.tb_no_abbr_cnt == 0)
*** ../vim-8.0.0163/src/list.c	2016-08-29 22:42:20.000000000 +0200
--- src/list.c	2017-01-08 13:03:51.304048264 +0100
***************
*** 885,891 ****
  }
  
  /*
!  * Write list of strings to file
   */
      int
  write_list(FILE *fd, list_T *list, int binary)
--- 885,891 ----
  }
  
  /*
!  * Write "list" of strings to file "fd".
   */
      int
  write_list(FILE *fd, list_T *list, int binary)
*** ../vim-8.0.0163/src/misc2.c	2016-12-01 23:03:24.516958281 +0100
--- src/misc2.c	2016-12-07 23:00:37.327201834 +0100
***************
*** 403,409 ****
      int
  dec_cursor(void)
  {
!  return dec(&curwin->w_cursor);
  }
  
      int
--- 403,409 ----
      int
  dec_cursor(void)
  {
!     return dec(&curwin->w_cursor);
  }
  
      int
*** ../vim-8.0.0163/src/testdir/README.txt	2016-09-03 22:32:37.000000000 +0200
--- src/testdir/README.txt	2016-11-30 22:06:57.762556025 +0100
***************
*** 14,23 ****
  TO ADD A NEW STYLE TEST:
  
  1) Create a test_<subject>.vim file.
! 2) Add test_<subject>.vim to NEW_TESTS in Make_all.mak in alphabetical order.
! 3) Use make test_<subject>.res to run a single test in src/testdir/.
     Use make test_<subject>  to run a single test in src/.
- 4) Also add an entry in src/Makefile.
  
  What you can use (see test_assert.vim for an example):
  - Call assert_equal(), assert_true(), assert_false(), etc.
--- 14,23 ----
  TO ADD A NEW STYLE TEST:
  
  1) Create a test_<subject>.vim file.
! 2) Add test_<subject>.res to NEW_TESTS in Make_all.mak in alphabetical order.
! 3) Also add an entry in src/Makefile.
! 4) Use make test_<subject>.res to run a single test in src/testdir/.
     Use make test_<subject>  to run a single test in src/.
  
  What you can use (see test_assert.vim for an example):
  - Call assert_equal(), assert_true(), assert_false(), etc.
*** ../vim-8.0.0163/src/version.c	2017-01-09 21:10:29.300184895 +0100
--- src/version.c	2017-01-10 13:49:52.691765462 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     164,
  /**/

-- 
"Women marry men hoping they will change. Men marry women hoping
they will not. So each is inevitably disappointed."
 - Einstein

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0165
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0165
Problem:    Ubsan warns for integer overflow.
Solution:   Swap two conditions. (Dominique Pelle)
Files:      src/regexp_nfa.c


*** ../vim-8.0.0164/src/regexp_nfa.c	2017-01-08 20:50:47.433486722 +0100
--- src/regexp_nfa.c	2017-01-10 13:53:01.154397567 +0100
***************
*** 50,56 ****
      NFA_CONCAT,			    /* concatenate two previous items (postfix
  				     * only) */
      NFA_OR,			    /* \| (postfix only) */
!     NFA_STAR,			    /* greedy * (posfix only) */
      NFA_STAR_NONGREEDY,		    /* non-greedy * (postfix only) */
      NFA_QUEST,			    /* greedy \? (postfix only) */
      NFA_QUEST_NONGREEDY,	    /* non-greedy \? (postfix only) */
--- 50,56 ----
      NFA_CONCAT,			    /* concatenate two previous items (postfix
  				     * only) */
      NFA_OR,			    /* \| (postfix only) */
!     NFA_STAR,			    /* greedy * (postfix only) */
      NFA_STAR_NONGREEDY,		    /* non-greedy * (postfix only) */
      NFA_QUEST,			    /* greedy \? (postfix only) */
      NFA_QUEST_NONGREEDY,	    /* non-greedy \? (postfix only) */
***************
*** 2169,2175 ****
  	     * maximum is much larger than the minimum and when the maximum is
  	     * large.  Bail out if we can use the other engine. */
  	    if ((nfa_re_flags & RE_AUTO)
! 				   && (maxval > minval + 200 || maxval > 500))
  		return FAIL;
  
  	    /* Ignore previous call to nfa_regatom() */
--- 2169,2175 ----
  	     * maximum is much larger than the minimum and when the maximum is
  	     * large.  Bail out if we can use the other engine. */
  	    if ((nfa_re_flags & RE_AUTO)
! 				   && (maxval > 500 || maxval > minval + 200))
  		return FAIL;
  
  	    /* Ignore previous call to nfa_regatom() */
*** ../vim-8.0.0164/src/version.c	2017-01-10 13:51:05.587236267 +0100
--- src/version.c	2017-01-10 13:54:22.873804709 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     165,
  /**/

-- 
"Marriage is a wonderful institution...
but who wants to live in an institution?"
 - Groucho Marx

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0166
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0166
Problem:    JSON with a duplicate key gives an internal error. (Lcd)
Solution:   Give a normal error.  Avoid an error when parsing JSON from a
            remote client fails.
Files:      src/evalfunc.c, src/json.c, src/channel.c,
            src/testdir/test_json.vim


*** ../vim-8.0.0165/src/evalfunc.c	2017-01-08 13:25:47.626339783 +0100
--- src/evalfunc.c	2017-01-10 14:19:11.339009907 +0100
***************
*** 6818,6825 ****
      reader.js_buf = get_tv_string(&argvars[0]);
      reader.js_fill = NULL;
      reader.js_used = 0;
!     if (json_decode_all(&reader, rettv, 0) != OK)
! 	EMSG(_(e_invarg));
  }
  
  /*
--- 6818,6824 ----
      reader.js_buf = get_tv_string(&argvars[0]);
      reader.js_fill = NULL;
      reader.js_used = 0;
!     json_decode_all(&reader, rettv, 0);
  }
  
  /*
*** ../vim-8.0.0165/src/json.c	2016-11-10 20:01:41.193582919 +0100
--- src/json.c	2017-01-10 14:25:22.032328415 +0100
***************
*** 428,433 ****
--- 428,434 ----
  	{
  	    if (*p == NUL)
  		return MAYBE;
+ 	    EMSG(_(e_invarg));
  	    return FAIL;
  	}
      }
***************
*** 488,493 ****
--- 489,495 ----
  		if (key == NULL || *key == NUL)
  		{
  		    clear_tv(&tvkey);
+ 		    EMSG(_(e_invarg));
  		    return FAIL;
  		}
  	    }
***************
*** 501,506 ****
--- 503,509 ----
  		clear_tv(&tvkey);
  	    if (*p == NUL)
  		return MAYBE;
+ 	    EMSG(_(e_invarg));
  	    return FAIL;
  	}
  	++reader->js_used;
***************
*** 514,519 ****
--- 517,530 ----
  	    return ret;
  	}
  
+ 	if (res != NULL && dict_find(res->vval.v_dict, key, -1) != NULL)
+ 	{
+ 	    EMSG2(_("E937: Duplicate key in JSON: \"%s\""), key);
+ 	    clear_tv(&tvkey);
+ 	    clear_tv(&item);
+ 	    return FAIL;
+ 	}
+ 
  	if (res != NULL)
  	{
  	    di = dictitem_alloc(key);
***************
*** 540,545 ****
--- 551,557 ----
  	{
  	    if (*p == NUL)
  		return MAYBE;
+ 	    EMSG(_(e_invarg));
  	    return FAIL;
  	}
      }
***************
*** 715,721 ****
   * Decode one item and put it in "res".  If "res" is NULL only advance.
   * Must already have skipped white space.
   *
!  * Return FAIL for a decoding error.
   * Return MAYBE for an incomplete message.
   */
      static int
--- 727,733 ----
   * Decode one item and put it in "res".  If "res" is NULL only advance.
   * Must already have skipped white space.
   *
!  * Return FAIL for a decoding error (and give an error).
   * Return MAYBE for an incomplete message.
   */
      static int
***************
*** 739,745 ****
--- 751,760 ----
  
  	case ',': /* comma: empty item */
  	    if ((options & JSON_JS) == 0)
+ 	    {
+ 		EMSG(_(e_invarg));
  		return FAIL;
+ 	    }
  	    /* FALLTHROUGH */
  	case NUL: /* empty */
  	    if (res != NULL)
***************
*** 761,767 ****
--- 776,785 ----
  		    if (*sp == NUL)
  			return MAYBE;
  		    if (!VIM_ISDIGIT(*sp))
+ 		    {
+ 			EMSG(_(e_invarg));
  			return FAIL;
+ 		    }
  		}
  		sp = skipdigits(sp);
  		if (*sp == '.' || *sp == 'e' || *sp == 'E')
***************
*** 866,871 ****
--- 884,890 ----
  	res->v_type = VAR_SPECIAL;
  	res->vval.v_number = VVAL_NONE;
      }
+     EMSG(_(e_invarg));
      return FAIL;
  }
  
***************
*** 884,893 ****
--- 903,919 ----
      json_skip_white(reader);
      ret = json_decode_item(reader, res, options);
      if (ret != OK)
+     {
+ 	if (ret == MAYBE)
+ 	    EMSG(_(e_invarg));
  	return FAIL;
+     }
      json_skip_white(reader);
      if (reader->js_buf[reader->js_used] != NUL)
+     {
+ 	EMSG(_(e_trailing));
  	return FAIL;
+     }
      return OK;
  }
  
*** ../vim-8.0.0165/src/channel.c	2017-01-08 20:50:47.433486722 +0100
--- src/channel.c	2017-01-10 14:51:11.216941142 +0100
***************
*** 1896,1904 ****
  
      /* When a message is incomplete we wait for a short while for more to
       * arrive.  After the delay drop the input, otherwise a truncated string
!      * or list will make us hang.  */
      status = json_decode(&reader, &listtv,
  				  chanpart->ch_mode == MODE_JS ? JSON_JS : 0);
      if (status == OK)
      {
  	/* Only accept the response when it is a list with at least two
--- 1896,1907 ----
  
      /* When a message is incomplete we wait for a short while for more to
       * arrive.  After the delay drop the input, otherwise a truncated string
!      * or list will make us hang.
!      * Do not generate error messages, they will be written in a channel log. */
!     ++emsg_silent;
      status = json_decode(&reader, &listtv,
  				  chanpart->ch_mode == MODE_JS ? JSON_JS : 0);
+     --emsg_silent;
      if (status == OK)
      {
  	/* Only accept the response when it is a list with at least two
*** ../vim-8.0.0165/src/testdir/test_json.vim	2016-07-21 20:10:29.000000000 +0200
--- src/testdir/test_json.vim	2017-01-10 14:26:22.407891917 +0100
***************
*** 148,155 ****
  
    call assert_fails('call json_decode("\"")', "E474:")
    call assert_fails('call json_decode("blah")', "E474:")
!   call assert_fails('call json_decode("true blah")', "E474:")
    call assert_fails('call json_decode("<foobar>")', "E474:")
  
    call assert_fails('call json_decode("{")', "E474:")
    call assert_fails('call json_decode("{foobar}")', "E474:")
--- 148,156 ----
  
    call assert_fails('call json_decode("\"")', "E474:")
    call assert_fails('call json_decode("blah")', "E474:")
!   call assert_fails('call json_decode("true blah")', "E488:")
    call assert_fails('call json_decode("<foobar>")', "E474:")
+   call assert_fails('call json_decode("{\"a\":1,\"a\":2}")', "E937:")
  
    call assert_fails('call json_decode("{")', "E474:")
    call assert_fails('call json_decode("{foobar}")', "E474:")
*** ../vim-8.0.0165/src/version.c	2017-01-10 13:55:11.373452931 +0100
--- src/version.c	2017-01-10 15:13:45.582924948 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     166,
  /**/

-- 
Marriage isn't a word.  It's a sentence.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0167
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0167
Problem:    str2nr() and str2float() do not always work with negative values.
Solution:   Be more flexible about handling signs. (LemonBoy, closes #1332)
            Add more tests.
Files:      src/evalfunc.c, src/testdir/test_float_func.vim,
            src/testdir/test_functions.vim, src/testdir/test_alot.vim,
            src/Makefile


*** ../vim-8.0.0166/src/evalfunc.c	2017-01-10 15:15:32.878134163 +0100
--- src/evalfunc.c	2017-01-10 15:48:27.495467137 +0100
***************
*** 11066,11075 ****
  f_str2float(typval_T *argvars, typval_T *rettv)
  {
      char_u *p = skipwhite(get_tv_string(&argvars[0]));
  
!     if (*p == '+')
  	p = skipwhite(p + 1);
      (void)string2float(p, &rettv->vval.v_float);
      rettv->v_type = VAR_FLOAT;
  }
  #endif
--- 11066,11078 ----
  f_str2float(typval_T *argvars, typval_T *rettv)
  {
      char_u *p = skipwhite(get_tv_string(&argvars[0]));
+     int     isneg = (*p == '-');
  
!     if (*p == '+' || *p == '-')
  	p = skipwhite(p + 1);
      (void)string2float(p, &rettv->vval.v_float);
+     if (isneg)
+ 	rettv->vval.v_float *= -1;
      rettv->v_type = VAR_FLOAT;
  }
  #endif
***************
*** 11084,11089 ****
--- 11087,11093 ----
      char_u	*p;
      varnumber_T	n;
      int		what;
+     int		isneg;
  
      if (argvars[1].v_type != VAR_UNKNOWN)
      {
***************
*** 11096,11102 ****
      }
  
      p = skipwhite(get_tv_string(&argvars[0]));
!     if (*p == '+')
  	p = skipwhite(p + 1);
      switch (base)
      {
--- 11100,11107 ----
      }
  
      p = skipwhite(get_tv_string(&argvars[0]));
!     isneg = (*p == '-');
!     if (*p == '+' || *p == '-')
  	p = skipwhite(p + 1);
      switch (base)
      {
***************
*** 11106,11112 ****
  	default: what = 0;
      }
      vim_str2nr(p, NULL, NULL, what, &n, NULL, 0);
!     rettv->vval.v_number = n;
  }
  
  #ifdef HAVE_STRFTIME
--- 11111,11121 ----
  	default: what = 0;
      }
      vim_str2nr(p, NULL, NULL, what, &n, NULL, 0);
!     if (isneg)
! 	rettv->vval.v_number = -n;
!     else
! 	rettv->vval.v_number = n;
! 
  }
  
  #ifdef HAVE_STRFTIME
*** ../vim-8.0.0166/src/testdir/test_float_func.vim	2017-01-08 19:25:34.847896437 +0100
--- src/testdir/test_float_func.vim	2017-01-10 15:56:40.363761421 +0100
***************
*** 165,173 ****
--- 165,186 ----
  
  func Test_str2float()
    call assert_equal('1.0', string(str2float('1')))
+   call assert_equal('1.0', string(str2float(' 1 ')))
+   call assert_equal('1.0', string(str2float(' 1.0 ')))
    call assert_equal('1.23', string(str2float('1.23')))
    call assert_equal('1.23', string(str2float('1.23abc')))
    call assert_equal('1.0e40', string(str2float('1e40')))
+ 
+   call assert_equal('1.0', string(str2float('+1')))
+   call assert_equal('1.0', string(str2float('+1')))
+   call assert_equal('1.0', string(str2float(' +1 ')))
+   call assert_equal('1.0', string(str2float(' + 1 ')))
+ 
+   call assert_equal('-1.0', string(str2float('-1')))
+   call assert_equal('-1.0', string(str2float('-1')))
+   call assert_equal('-1.0', string(str2float(' -1 ')))
+   call assert_equal('-1.0', string(str2float(' - 1 ')))
+ 
    call assert_equal('inf', string(str2float('1e1000')))
    call assert_equal('inf', string(str2float('inf')))
    call assert_equal('-inf', string(str2float('-inf')))
*** ../vim-8.0.0166/src/testdir/test_functions.vim	2017-01-10 16:11:14.477198393 +0100
--- src/testdir/test_functions.vim	2017-01-10 16:09:41.309900997 +0100
***************
*** 0 ****
--- 1,18 ----
+ " Tests for various functions.
+ 
+ func Test_str2nr()
+   call assert_equal(0, str2nr(''))
+   call assert_equal(1, str2nr('1'))
+   call assert_equal(1, str2nr(' 1 '))
+ 
+   call assert_equal(1, str2nr('+1'))
+   call assert_equal(1, str2nr('+ 1'))
+   call assert_equal(1, str2nr(' + 1 '))
+ 
+   call assert_equal(-1, str2nr('-1'))
+   call assert_equal(-1, str2nr('- 1'))
+   call assert_equal(-1, str2nr(' - 1 '))
+ 
+   call assert_equal(123456789, str2nr('123456789'))
+   call assert_equal(-123456789, str2nr('-123456789'))
+ endfunc
*** ../vim-8.0.0166/src/testdir/test_alot.vim	2017-01-08 17:58:58.767107006 +0100
--- src/testdir/test_alot.vim	2017-01-10 15:53:57.048992399 +0100
***************
*** 18,23 ****
--- 18,24 ----
  source test_filter_map.vim
  source test_float_func.vim
  source test_fnamemodify.vim
+ source test_functions.vim
  source test_glob2regpat.vim
  source test_goto.vim
  source test_help_tagjump.vim
*** ../vim-8.0.0166/src/Makefile	2017-01-08 17:58:58.767107006 +0100
--- src/Makefile	2017-01-10 15:53:12.933325401 +0100
***************
*** 2091,2096 ****
--- 2091,2097 ----
  	test_delete \
  	test_diffmode \
  	test_digraph \
+ 	test_functions \
  	test_display \
  	test_ex_undo \
  	test_execute_func \
*** ../vim-8.0.0166/src/version.c	2017-01-10 15:15:32.882134134 +0100
--- src/version.c	2017-01-10 16:11:22.005141661 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     167,
  /**/

-- 
"After a few years of marriage a man can look right at a woman
without seeing her and a woman can see right through a man
without looking at him."
 - Helen Rowland

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0168
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0168
Problem:    Still some float functionality is not covered by tests.
Solution:   Add more tests. (Dominique Pelle, closes #1364)
Files:      src/testdir/test_float_func.vim


*** ../vim-8.0.0167/src/testdir/test_float_func.vim	2017-01-10 16:12:11.732767042 +0100
--- src/testdir/test_float_func.vim	2017-01-10 16:19:06.413651860 +0100
***************
*** 13,18 ****
--- 13,22 ----
    call assert_equal('inf', string(abs(1.0/0.0)))
    call assert_equal('inf', string(abs(-1.0/0.0)))
    call assert_equal('nan', string(abs(0.0/0.0)))
+   call assert_equal('12', string(abs('-12abc')))
+   call assert_fails("call abs([])", 'E745:')
+   call assert_fails("call abs({})", 'E728:')
+   call assert_fails("call abs(function('string'))", 'E703:')
  endfunc
  
  func Test_sqrt()
***************
*** 21,26 ****
--- 25,31 ----
    call assert_equal('inf', string(sqrt(1.0/0.0)))
    call assert_equal('nan', string(sqrt(-1.0)))
    call assert_equal('nan', string(sqrt(0.0/0.0)))
+   call assert_fails('call sqrt("")', 'E808:')
  endfunc
  
  func Test_log()
***************
*** 30,35 ****
--- 35,41 ----
    call assert_equal('nan', string(log(-1.0)))
    call assert_equal('inf', string(log(1.0/0.0)))
    call assert_equal('nan', string(log(0.0/0.0)))
+   call assert_fails('call log("")', 'E808:')
  endfunc
  
  func Test_log10()
***************
*** 40,45 ****
--- 46,52 ----
    call assert_equal('nan', string(log10(-1.0)))
    call assert_equal('inf', string(log10(1.0/0.0)))
    call assert_equal('nan', string(log10(0.0/0.0)))
+   call assert_fails('call log10("")', 'E808:')
  endfunc
  
  func Test_exp()
***************
*** 49,54 ****
--- 56,62 ----
    call assert_equal('inf', string(exp(1.0/0.0)))
    call assert_equal('0.0', string(exp(-1.0/0.0)))
    call assert_equal('nan', string(exp(0.0/0.0)))
+   call assert_fails('call exp("")', 'E808:')
  endfunc
  
  func Test_sin()
***************
*** 59,64 ****
--- 67,73 ----
    call assert_equal('nan', string(sin(1.0/0.0)))
    call assert_equal('0.0', string(sin(1.0/(1.0/0.0))))
    call assert_equal('-0.0', string(sin(-1.0/(1.0/0.0))))
+   call assert_fails('call sin("")', 'E808:')
  endfunc
  
  func Test_asin()
***************
*** 68,73 ****
--- 77,83 ----
    call assert_equal('nan', string(asin(1.1)))
    call assert_equal('nan', string(asin(1.0/0.0)))
    call assert_equal('nan', string(asin(0.0/0.0)))
+   call assert_fails('call asin("")', 'E808:')
  endfunc
  
  func Test_sinh()
***************
*** 77,82 ****
--- 87,93 ----
    call assert_equal('inf', string(sinh(1.0/0.0)))
    call assert_equal('-inf', string(sinh(-1.0/0.0)))
    call assert_equal('nan', string(sinh(0.0/0.0)))
+   call assert_fails('call sinh("")', 'E808:')
  endfunc
  
  func Test_cos()
***************
*** 85,90 ****
--- 96,102 ----
    call assert_equal('0.877583', string(cos(-0.5)))
    call assert_equal('nan', string(cos(0.0/0.0)))
    call assert_equal('nan', string(cos(1.0/0.0)))
+   call assert_fails('call cos("")', 'E808:')
  endfunc
  
  func Test_acos()
***************
*** 95,100 ****
--- 107,113 ----
    call assert_equal('nan', string(acos(1.1)))
    call assert_equal('nan', string(acos(1.0/0.0)))
    call assert_equal('nan', string(acos(0.0/0.0)))
+   call assert_fails('call acos("")', 'E808:')
  endfunc
  
  func Test_cosh()
***************
*** 103,108 ****
--- 116,122 ----
    call assert_equal('inf', string(cosh(1.0/0.0)))
    call assert_equal('inf', string(cosh(-1.0/0.0)))
    call assert_equal('nan', string(cosh(0.0/0.0)))
+   call assert_fails('call cosh("")', 'E808:')
  endfunc
  
  func Test_tan()
***************
*** 113,118 ****
--- 127,133 ----
    call assert_equal('nan', string(cos(0.0/0.0)))
    call assert_equal('0.0', string(tan(1.0/(1.0/0.0))))
    call assert_equal('-0.0', string(tan(-1.0/(1.0/0.0))))
+   call assert_fails('call tan("")', 'E808:')
  endfunc
  
  func Test_atan()
***************
*** 122,127 ****
--- 137,143 ----
    call assert_equal('1.570796', string(atan(1.0/0.0)))
    call assert_equal('-1.570796', string(atan(-1.0/0.0)))
    call assert_equal('nan', string(atan(0.0/0.0)))
+   call assert_fails('call atan("")', 'E808:')
  endfunc
  
  func Test_atan2()
***************
*** 130,135 ****
--- 146,153 ----
    call assert_equal('0.0', string(atan2(1.0, 1.0/0.0)))
    call assert_equal('1.570796', string(atan2(1.0/0.0, 1.0)))
    call assert_equal('nan', string(atan2(0.0/0.0, 1.0)))
+   call assert_fails('call atan2("", -1)', 'E808:')
+   call assert_fails('call atan2(-1, "")', 'E808:')
  endfunc
  
  func Test_tanh()
***************
*** 139,144 ****
--- 157,163 ----
    call assert_equal('1.0', string(tanh(1.0/0.0)))
    call assert_equal('-1.0', string(tanh(-1.0/0.0)))
    call assert_equal('nan', string(tanh(0.0/0.0)))
+   call assert_fails('call tanh("")', 'E808:')
  endfunc
  
  func Test_fmod()
***************
*** 151,156 ****
--- 170,177 ----
      call assert_equal('1.0', res)
    endif
    call assert_equal('nan', string(fmod(1.0, 0.0)))
+   call assert_fails("call fmod('', 1.22)", 'E808:')
+   call assert_fails("call fmod(12.33, '')", 'E808:')
  endfunc
  
  func Test_pow()
***************
*** 161,166 ****
--- 182,189 ----
    call assert_equal('nan', string(pow(0.0/0.0, 3.0)))
    call assert_equal('inf', string(pow(2.0, 1.0/0.0)))
    call assert_equal('inf', string(pow(1.0/0.0, 3.0)))
+   call assert_fails("call pow('', 2.0)", 'E808:')
+   call assert_fails("call pow(2.0, '')", 'E808:')
  endfunc
  
  func Test_str2float()
***************
*** 170,175 ****
--- 193,200 ----
    call assert_equal('1.23', string(str2float('1.23')))
    call assert_equal('1.23', string(str2float('1.23abc')))
    call assert_equal('1.0e40', string(str2float('1e40')))
+   call assert_equal('-1.23', string(str2float('-1.23')))
+   call assert_equal('1.23', string(str2float(' + 1.23 ')))
  
    call assert_equal('1.0', string(str2float('+1')))
    call assert_equal('1.0', string(str2float('+1')))
***************
*** 181,192 ****
--- 206,227 ----
    call assert_equal('-1.0', string(str2float(' -1 ')))
    call assert_equal('-1.0', string(str2float(' - 1 ')))
  
+   call assert_equal('0.0', string(str2float('+0.0')))
+   call assert_equal('-0.0', string(str2float('-0.0')))
    call assert_equal('inf', string(str2float('1e1000')))
    call assert_equal('inf', string(str2float('inf')))
    call assert_equal('-inf', string(str2float('-inf')))
+   call assert_equal('inf', string(str2float('+inf')))
    call assert_equal('inf', string(str2float('Inf')))
+   call assert_equal('inf', string(str2float('  +inf  ')))
    call assert_equal('nan', string(str2float('nan')))
    call assert_equal('nan', string(str2float('NaN')))
+   call assert_equal('nan', string(str2float('  nan  ')))
+ 
+   call assert_fails("call str2float(1.2)", 'E806:')
+   call assert_fails("call str2float([])", 'E730:')
+   call assert_fails("call str2float({})", 'E731:')
+   call assert_fails("call str2float(function('string'))", 'E729:')
  endfunc
  
  func Test_floor()
***************
*** 198,203 ****
--- 233,239 ----
    call assert_equal('nan', string(floor(0.0/0.0)))
    call assert_equal('inf', string(floor(1.0/0.0)))
    call assert_equal('-inf', string(floor(-1.0/0.0)))
+   call assert_fails("call floor('')", 'E808:')
  endfunc
  
  func Test_ceil()
***************
*** 209,214 ****
--- 245,251 ----
    call assert_equal('nan', string(ceil(0.0/0.0)))
    call assert_equal('inf', string(ceil(1.0/0.0)))
    call assert_equal('-inf', string(ceil(-1.0/0.0)))
+   call assert_fails("call ceil('')", 'E808:')
  endfunc
  
  func Test_round()
***************
*** 221,226 ****
--- 258,264 ----
    call assert_equal('nan', string(round(0.0/0.0)))
    call assert_equal('inf', string(round(1.0/0.0)))
    call assert_equal('-inf', string(round(-1.0/0.0)))
+   call assert_fails("call round('')", 'E808:')
  endfunc
  
  func Test_trunc()
***************
*** 233,238 ****
--- 271,277 ----
    call assert_equal('nan', string(trunc(0.0/0.0)))
    call assert_equal('inf', string(trunc(1.0/0.0)))
    call assert_equal('-inf', string(trunc(-1.0/0.0)))
+   call assert_fails("call trunc('')", 'E808:')
  endfunc
  
  func Test_isnan()
***************
*** 241,244 ****
--- 280,284 ----
    call assert_equal(0, isnan(1.0/0.0))
    call assert_equal(0, isnan('a'))
    call assert_equal(0, isnan([]))
+   call assert_equal(0, isnan({}))
  endfunc
*** ../vim-8.0.0167/src/version.c	2017-01-10 16:12:11.736767011 +0100
--- src/version.c	2017-01-10 16:30:39.444474802 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     168,
  /**/

-- 
"Marriage is when a man and woman become as one; the trouble starts
when they try to decide which one"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0169
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0169
Problem:    For complicated string json_decode() may run out of stack space.
Solution:   Change the recursive solution into an iterative solution.
Files:      src/json.c


*** ../vim-8.0.0168/src/json.c	2017-01-10 15:15:32.878134163 +0100
--- src/json.c	2017-01-10 19:42:35.730763271 +0100
***************
*** 378,564 ****
  }
  
      static int
- json_decode_array(js_read_T *reader, typval_T *res, int options)
- {
-     char_u	*p;
-     typval_T	item;
-     listitem_T	*li;
-     int		ret;
- 
-     if (res != NULL && rettv_list_alloc(res) == FAIL)
-     {
- 	res->v_type = VAR_SPECIAL;
- 	res->vval.v_number = VVAL_NONE;
- 	return FAIL;
-     }
-     ++reader->js_used; /* consume the '[' */
- 
-     while (TRUE)
-     {
- 	json_skip_white(reader);
- 	p = reader->js_buf + reader->js_used;
- 	if (*p == NUL)
- 	    return MAYBE;
- 	if (*p == ']')
- 	{
- 	    ++reader->js_used; /* consume the ']' */
- 	    break;
- 	}
- 
- 	ret = json_decode_item(reader, res == NULL ? NULL : &item, options);
- 	if (ret != OK)
- 	    return ret;
- 	if (res != NULL)
- 	{
- 	    li = listitem_alloc();
- 	    if (li == NULL)
- 	    {
- 		clear_tv(&item);
- 		return FAIL;
- 	    }
- 	    li->li_tv = item;
- 	    list_append(res->vval.v_list, li);
- 	}
- 
- 	json_skip_white(reader);
- 	p = reader->js_buf + reader->js_used;
- 	if (*p == ',')
- 	    ++reader->js_used;
- 	else if (*p != ']')
- 	{
- 	    if (*p == NUL)
- 		return MAYBE;
- 	    EMSG(_(e_invarg));
- 	    return FAIL;
- 	}
-     }
-     return OK;
- }
- 
-     static int
- json_decode_object(js_read_T *reader, typval_T *res, int options)
- {
-     char_u	*p;
-     typval_T	tvkey;
-     typval_T	item;
-     dictitem_T	*di;
-     char_u	buf[NUMBUFLEN];
-     char_u	*key = NULL;
-     int		ret;
- 
-     if (res != NULL && rettv_dict_alloc(res) == FAIL)
-     {
- 	res->v_type = VAR_SPECIAL;
- 	res->vval.v_number = VVAL_NONE;
- 	return FAIL;
-     }
-     ++reader->js_used; /* consume the '{' */
- 
-     while (TRUE)
-     {
- 	json_skip_white(reader);
- 	p = reader->js_buf + reader->js_used;
- 	if (*p == NUL)
- 	    return MAYBE;
- 	if (*p == '}')
- 	{
- 	    ++reader->js_used; /* consume the '}' */
- 	    break;
- 	}
- 
- 	if ((options & JSON_JS) && reader->js_buf[reader->js_used] != '"')
- 	{
- 	    /* accept a key that is not in quotes */
- 	    key = p = reader->js_buf + reader->js_used;
- 	    while (*p != NUL && *p != ':' && *p > ' ')
- 		++p;
- 	    tvkey.v_type = VAR_STRING;
- 	    tvkey.vval.v_string = vim_strnsave(key, (int)(p - key));
- 	    reader->js_used += (int)(p - key);
- 	    key = tvkey.vval.v_string;
- 	}
- 	else
- 	{
- 	    ret = json_decode_item(reader, res == NULL ? NULL : &tvkey,
- 								     options);
- 	    if (ret != OK)
- 		return ret;
- 	    if (res != NULL)
- 	    {
- 		key = get_tv_string_buf_chk(&tvkey, buf);
- 		if (key == NULL || *key == NUL)
- 		{
- 		    clear_tv(&tvkey);
- 		    EMSG(_(e_invarg));
- 		    return FAIL;
- 		}
- 	    }
- 	}
- 
- 	json_skip_white(reader);
- 	p = reader->js_buf + reader->js_used;
- 	if (*p != ':')
- 	{
- 	    if (res != NULL)
- 		clear_tv(&tvkey);
- 	    if (*p == NUL)
- 		return MAYBE;
- 	    EMSG(_(e_invarg));
- 	    return FAIL;
- 	}
- 	++reader->js_used;
- 	json_skip_white(reader);
- 
- 	ret = json_decode_item(reader, res == NULL ? NULL : &item, options);
- 	if (ret != OK)
- 	{
- 	    if (res != NULL)
- 		clear_tv(&tvkey);
- 	    return ret;
- 	}
- 
- 	if (res != NULL && dict_find(res->vval.v_dict, key, -1) != NULL)
- 	{
- 	    EMSG2(_("E937: Duplicate key in JSON: \"%s\""), key);
- 	    clear_tv(&tvkey);
- 	    clear_tv(&item);
- 	    return FAIL;
- 	}
- 
- 	if (res != NULL)
- 	{
- 	    di = dictitem_alloc(key);
- 	    clear_tv(&tvkey);
- 	    if (di == NULL)
- 	    {
- 		clear_tv(&item);
- 		return FAIL;
- 	    }
- 	    di->di_tv = item;
- 	    di->di_tv.v_lock = 0;
- 	    if (dict_add(res->vval.v_dict, di) == FAIL)
- 	    {
- 		dictitem_free(di);
- 		return FAIL;
- 	    }
- 	}
- 
- 	json_skip_white(reader);
- 	p = reader->js_buf + reader->js_used;
- 	if (*p == ',')
- 	    ++reader->js_used;
- 	else if (*p != '}')
- 	{
- 	    if (*p == NUL)
- 		return MAYBE;
- 	    EMSG(_(e_invarg));
- 	    return FAIL;
- 	}
-     }
-     return OK;
- }
- 
-     static int
  json_decode_string(js_read_T *reader, typval_T *res)
  {
      garray_T    ga;
--- 378,383 ----
***************
*** 723,728 ****
--- 542,560 ----
      return MAYBE;
  }
  
+ typedef enum {
+     JSON_ARRAY,		/* parsing items in an array */
+     JSON_OBJECT_KEY,	/* parsing key of an object */
+     JSON_OBJECT		/* parsing item in an object, after the key */
+ } json_decode_T;
+ 
+ typedef struct {
+     json_decode_T jd_type;
+     typval_T	  jd_tv;	/* the list or dict */
+     typval_T	  jd_key_tv;
+     char_u	  *jd_key;
+ } json_dec_item_T;
+ 
  /*
   * Decode one item and put it in "res".  If "res" is NULL only advance.
   * Must already have skipped white space.
***************
*** 735,891 ****
  {
      char_u	*p;
      int		len;
  
      fill_numbuflen(reader);
      p = reader->js_buf + reader->js_used;
!     switch (*p)
      {
! 	case '[': /* array */
! 	    return json_decode_array(reader, res, options);
! 
! 	case '{': /* object */
! 	    return json_decode_object(reader, res, options);
! 
! 	case '"': /* string */
! 	    return json_decode_string(reader, res);
! 
! 	case ',': /* comma: empty item */
! 	    if ((options & JSON_JS) == 0)
! 	    {
! 		EMSG(_(e_invarg));
! 		return FAIL;
! 	    }
! 	    /* FALLTHROUGH */
! 	case NUL: /* empty */
! 	    if (res != NULL)
  	    {
! 		res->v_type = VAR_SPECIAL;
! 		res->vval.v_number = VVAL_NONE;
  	    }
! 	    return OK;
  
! 	default:
! 	    if (VIM_ISDIGIT(*p) || *p == '-')
  	    {
! #ifdef FEAT_FLOAT
! 		char_u  *sp = p;
  
! 		if (*sp == '-')
! 		{
! 		    ++sp;
! 		    if (*sp == NUL)
! 			return MAYBE;
! 		    if (!VIM_ISDIGIT(*sp))
  		    {
! 			EMSG(_(e_invarg));
! 			return FAIL;
  		    }
! 		}
! 		sp = skipdigits(sp);
! 		if (*sp == '.' || *sp == 'e' || *sp == 'E')
! 		{
! 		    if (res == NULL)
  		    {
! 			float_T f;
  
! 			len = string2float(p, &f);
  		    }
! 		    else
  		    {
! 			res->v_type = VAR_FLOAT;
! 			len = string2float(p, &res->vval.v_float);
  		    }
! 		}
! 		else
  #endif
! 		{
! 		    varnumber_T nr;
  
! 		    vim_str2nr(reader->js_buf + reader->js_used,
! 			    NULL, &len, 0, /* what */
! 			    &nr, NULL, 0);
! 		    if (res != NULL)
  		    {
! 			res->v_type = VAR_NUMBER;
! 			res->vval.v_number = nr;
  		    }
! 		}
! 		reader->js_used += len;
! 		return OK;
  	    }
! 	    if (STRNICMP((char *)p, "false", 5) == 0)
  	    {
! 		reader->js_used += 5;
! 		if (res != NULL)
  		{
! 		    res->v_type = VAR_SPECIAL;
! 		    res->vval.v_number = VVAL_FALSE;
  		}
- 		return OK;
  	    }
! 	    if (STRNICMP((char *)p, "true", 4) == 0)
! 	    {
! 		reader->js_used += 4;
  		if (res != NULL)
  		{
! 		    res->v_type = VAR_SPECIAL;
! 		    res->vval.v_number = VVAL_TRUE;
  		}
! 		return OK;
! 	    }
! 	    if (STRNICMP((char *)p, "null", 4) == 0)
! 	    {
! 		reader->js_used += 4;
! 		if (res != NULL)
  		{
! 		    res->v_type = VAR_SPECIAL;
! 		    res->vval.v_number = VVAL_NULL;
  		}
! 		return OK;
! 	    }
! #ifdef FEAT_FLOAT
! 	    if (STRNICMP((char *)p, "NaN", 3) == 0)
! 	    {
! 		reader->js_used += 3;
! 		if (res != NULL)
  		{
! 		    res->v_type = VAR_FLOAT;
! 		    res->vval.v_float = NAN;
  		}
! 		return OK;
! 	    }
! 	    if (STRNICMP((char *)p, "Infinity", 8) == 0)
! 	    {
! 		reader->js_used += 8;
! 		if (res != NULL)
  		{
! 		    res->v_type = VAR_FLOAT;
! 		    res->vval.v_float = INFINITY;
  		}
! 		return OK;
! 	    }
! #endif
! 	    /* check for truncated name */
! 	    len = (int)(reader->js_end - (reader->js_buf + reader->js_used));
! 	    if (
! 		    (len < 5 && STRNICMP((char *)p, "false", len) == 0)
! #ifdef FEAT_FLOAT
! 		    || (len < 8 && STRNICMP((char *)p, "Infinity", len) == 0)
! 		    || (len < 3 && STRNICMP((char *)p, "NaN", len) == 0)
! #endif
! 		    || (len < 4 && (STRNICMP((char *)p, "true", len) == 0
! 			       ||  STRNICMP((char *)p, "null", len) == 0)))
! 		return MAYBE;
! 	    break;
      }
  
      if (res != NULL)
      {
  	res->v_type = VAR_SPECIAL;
  	res->vval.v_number = VVAL_NONE;
      }
      EMSG(_(e_invarg));
!     return FAIL;
  }
  
  /*
--- 567,992 ----
  {
      char_u	*p;
      int		len;
+     int		retval;
+     garray_T	stack;
+     typval_T	item;
+     typval_T	*cur_item;
+     json_dec_item_T *top_item;
+     char_u	key_buf[NUMBUFLEN];
+ 
+     ga_init2(&stack, sizeof(json_dec_item_T), 100);
+     cur_item = res;
+     init_tv(&item);
  
      fill_numbuflen(reader);
      p = reader->js_buf + reader->js_used;
!     for (;;)
      {
! 	top_item = NULL;
! 	if (stack.ga_len > 0)
! 	{
! 	    top_item = ((json_dec_item_T *)stack.ga_data) + stack.ga_len - 1;
! 	    json_skip_white(reader);
! 	    p = reader->js_buf + reader->js_used;
! 	    if (*p == NUL)
  	    {
! 		retval = MAYBE;
! 		if (top_item->jd_type == JSON_OBJECT)
! 		    /* did get the key, clear it */
! 		    clear_tv(&top_item->jd_key_tv);
! 		goto theend;
! 	    }
! 	    if (top_item->jd_type == JSON_OBJECT_KEY
! 					    || top_item->jd_type == JSON_ARRAY)
! 	    {
! 		/* Check for end of object or array. */
! 		if (*p == (top_item->jd_type == JSON_ARRAY ? ']' : '}'))
! 		{
! 		    ++reader->js_used; /* consume the ']' or '}' */
! 		    --stack.ga_len;
! 		    if (stack.ga_len == 0)
! 		    {
! 			retval = OK;
! 			goto theend;
! 		    }
! 		    if (cur_item != NULL)
! 			cur_item = &top_item->jd_tv;
! 		    goto item_end;
! 		}
  	    }
! 	}
! 
! 	if (top_item != NULL && top_item->jd_type == JSON_OBJECT_KEY
! 		&& (options & JSON_JS)
! 		&& reader->js_buf[reader->js_used] != '"')
! 	{
! 	    char_u *key;
  
! 	    /* accept an object key that is not in quotes */
! 	    key = p = reader->js_buf + reader->js_used;
! 	    while (*p != NUL && *p != ':' && *p > ' ')
! 		++p;
! 	    cur_item->v_type = VAR_STRING;
! 	    cur_item->vval.v_string = vim_strnsave(key, (int)(p - key));
! 	    reader->js_used += (int)(p - key);
! 	    top_item->jd_key = cur_item->vval.v_string;
! 	}
! 	else
! 	{
! 	    switch (*p)
  	    {
! 		case '[': /* start of array */
! 		    if (ga_grow(&stack, 1) == FAIL)
! 		    {
! 			retval = FAIL;
! 			break;
! 		    }
! 		    if (cur_item != NULL && rettv_list_alloc(cur_item) == FAIL)
! 		    {
! 			cur_item->v_type = VAR_SPECIAL;
! 			cur_item->vval.v_number = VVAL_NONE;
! 			retval = FAIL;
! 			break;
! 		    }
  
! 		    ++reader->js_used; /* consume the '[' */
! 		    top_item = ((json_dec_item_T *)stack.ga_data)
! 								+ stack.ga_len;
! 		    top_item->jd_type = JSON_ARRAY;
! 		    ++stack.ga_len;
! 		    if (cur_item != NULL)
  		    {
! 			top_item->jd_tv = *cur_item;
! 			cur_item = &item;
  		    }
! 		    continue;
! 
! 		case '{': /* start of object */
! 		    if (ga_grow(&stack, 1) == FAIL)
  		    {
! 			retval = FAIL;
! 			break;
! 		    }
! 		    if (cur_item != NULL && rettv_dict_alloc(cur_item) == FAIL)
! 		    {
! 			cur_item->v_type = VAR_SPECIAL;
! 			cur_item->vval.v_number = VVAL_NONE;
! 			retval = FAIL;
! 			break;
! 		    }
  
! 		    ++reader->js_used; /* consume the '{' */
! 		    top_item = ((json_dec_item_T *)stack.ga_data)
! 								+ stack.ga_len;
! 		    top_item->jd_type = JSON_OBJECT_KEY;
! 		    ++stack.ga_len;
! 		    if (cur_item != NULL)
! 		    {
! 			top_item->jd_tv = *cur_item;
! 			cur_item = &top_item->jd_key_tv;
  		    }
! 		    continue;
! 
! 		case '"': /* string */
! 		    retval = json_decode_string(reader, cur_item);
! 		    break;
! 
! 		case ',': /* comma: empty item */
! 		    if ((options & JSON_JS) == 0)
  		    {
! 			EMSG(_(e_invarg));
! 			retval = FAIL;
! 			break;
  		    }
! 		    /* FALLTHROUGH */
! 		case NUL: /* empty */
! 		    if (cur_item != NULL)
! 		    {
! 			cur_item->v_type = VAR_SPECIAL;
! 			cur_item->vval.v_number = VVAL_NONE;
! 		    }
! 		    retval = OK;
! 		    break;
! 
! 		default:
! 		    if (VIM_ISDIGIT(*p) || *p == '-')
! 		    {
! #ifdef FEAT_FLOAT
! 			char_u  *sp = p;
! 
! 			if (*sp == '-')
! 			{
! 			    ++sp;
! 			    if (*sp == NUL)
! 			    {
! 				retval = MAYBE;
! 				break;
! 			    }
! 			    if (!VIM_ISDIGIT(*sp))
! 			    {
! 				EMSG(_(e_invarg));
! 				retval = FAIL;
! 				break;
! 			    }
! 			}
! 			sp = skipdigits(sp);
! 			if (*sp == '.' || *sp == 'e' || *sp == 'E')
! 			{
! 			    if (cur_item == NULL)
! 			    {
! 				float_T f;
! 
! 				len = string2float(p, &f);
! 			    }
! 			    else
! 			    {
! 				cur_item->v_type = VAR_FLOAT;
! 				len = string2float(p, &cur_item->vval.v_float);
! 			    }
! 			}
! 			else
  #endif
! 			{
! 			    varnumber_T nr;
  
! 			    vim_str2nr(reader->js_buf + reader->js_used,
! 				    NULL, &len, 0, /* what */
! 				    &nr, NULL, 0);
! 			    if (cur_item != NULL)
! 			    {
! 				cur_item->v_type = VAR_NUMBER;
! 				cur_item->vval.v_number = nr;
! 			    }
! 			}
! 			reader->js_used += len;
! 			retval = OK;
! 			break;
! 		    }
! 		    if (STRNICMP((char *)p, "false", 5) == 0)
  		    {
! 			reader->js_used += 5;
! 			if (cur_item != NULL)
! 			{
! 			    cur_item->v_type = VAR_SPECIAL;
! 			    cur_item->vval.v_number = VVAL_FALSE;
! 			}
! 			retval = OK;
! 			break;
  		    }
! 		    if (STRNICMP((char *)p, "true", 4) == 0)
! 		    {
! 			reader->js_used += 4;
! 			if (cur_item != NULL)
! 			{
! 			    cur_item->v_type = VAR_SPECIAL;
! 			    cur_item->vval.v_number = VVAL_TRUE;
! 			}
! 			retval = OK;
! 			break;
! 		    }
! 		    if (STRNICMP((char *)p, "null", 4) == 0)
! 		    {
! 			reader->js_used += 4;
! 			if (cur_item != NULL)
! 			{
! 			    cur_item->v_type = VAR_SPECIAL;
! 			    cur_item->vval.v_number = VVAL_NULL;
! 			}
! 			retval = OK;
! 			break;
! 		    }
! #ifdef FEAT_FLOAT
! 		    if (STRNICMP((char *)p, "NaN", 3) == 0)
! 		    {
! 			reader->js_used += 3;
! 			if (cur_item != NULL)
! 			{
! 			    cur_item->v_type = VAR_FLOAT;
! 			    cur_item->vval.v_float = NAN;
! 			}
! 			retval = OK;
! 			break;
! 		    }
! 		    if (STRNICMP((char *)p, "Infinity", 8) == 0)
! 		    {
! 			reader->js_used += 8;
! 			if (cur_item != NULL)
! 			{
! 			    cur_item->v_type = VAR_FLOAT;
! 			    cur_item->vval.v_float = INFINITY;
! 			}
! 			retval = OK;
! 			break;
! 		    }
! #endif
! 		    /* check for truncated name */
! 		    len = (int)(reader->js_end - (reader->js_buf + reader->js_used));
! 		    if (
! 			    (len < 5 && STRNICMP((char *)p, "false", len) == 0)
! #ifdef FEAT_FLOAT
! 			    || (len < 8 && STRNICMP((char *)p, "Infinity", len) == 0)
! 			    || (len < 3 && STRNICMP((char *)p, "NaN", len) == 0)
! #endif
! 			    || (len < 4 && (STRNICMP((char *)p, "true", len) == 0
! 				       ||  STRNICMP((char *)p, "null", len) == 0)))
! 
! 			retval = MAYBE;
! 		    else
! 			retval = FAIL;
! 		    break;
  	    }
! 
! 	    /* We are finished when retval is FAIL or MAYBE and when at the
! 	     * toplevel. */
! 	    if (retval == FAIL)
! 		break;
! 	    if (retval == MAYBE || stack.ga_len == 0)
! 		goto theend;
! 
! 	    if (top_item != NULL && top_item->jd_type == JSON_OBJECT_KEY
! 		    && cur_item != NULL)
  	    {
! 		top_item->jd_key = get_tv_string_buf_chk(cur_item, key_buf);
! 		if (top_item->jd_key == NULL || *top_item->jd_key == NUL)
  		{
! 		    clear_tv(cur_item);
! 		    EMSG(_(e_invarg));
! 		    retval = FAIL;
! 		    goto theend;
  		}
  	    }
! 	}
! 
! item_end:
! 	top_item = ((json_dec_item_T *)stack.ga_data) + stack.ga_len - 1;
! 	switch (top_item->jd_type)
! 	{
! 	    case JSON_ARRAY:
  		if (res != NULL)
  		{
! 		    listitem_T	*li = listitem_alloc();
! 
! 		    if (li == NULL)
! 		    {
! 			clear_tv(cur_item);
! 			retval = FAIL;
! 			goto theend;
! 		    }
! 		    li->li_tv = *cur_item;
! 		    list_append(top_item->jd_tv.vval.v_list, li);
  		}
! 		if (cur_item != NULL)
! 		    cur_item = &item;
! 
! 		json_skip_white(reader);
! 		p = reader->js_buf + reader->js_used;
! 		if (*p == ',')
! 		    ++reader->js_used;
! 		else if (*p != ']')
  		{
! 		    if (*p == NUL)
! 			retval = MAYBE;
! 		    else
! 		    {
! 			EMSG(_(e_invarg));
! 			retval = FAIL;
! 		    }
! 		    goto theend;
  		}
! 		break;
! 
! 	    case JSON_OBJECT_KEY:
! 		json_skip_white(reader);
! 		p = reader->js_buf + reader->js_used;
! 		if (*p != ':')
! 		{
! 		    if (cur_item != NULL)
! 			clear_tv(cur_item);
! 		    if (*p == NUL)
! 			retval = MAYBE;
! 		    else
! 		    {
! 			EMSG(_(e_invarg));
! 			retval = FAIL;
! 		    }
! 		    goto theend;
! 		}
! 		++reader->js_used;
! 		json_skip_white(reader);
! 		top_item->jd_type = JSON_OBJECT;
! 		if (cur_item != NULL)
! 		    cur_item = &item;
! 		break;
! 
! 	    case JSON_OBJECT:
! 		if (cur_item != NULL
! 			&& dict_find(top_item->jd_tv.vval.v_dict,
! 						 top_item->jd_key, -1) != NULL)
  		{
! 		    EMSG2(_("E937: Duplicate key in JSON: \"%s\""),
! 							     top_item->jd_key);
! 		    clear_tv(&top_item->jd_key_tv);
! 		    clear_tv(cur_item);
! 		    retval = FAIL;
! 		    goto theend;
  		}
! 
! 		if (cur_item != NULL)
! 		{
! 		    dictitem_T *di = dictitem_alloc(top_item->jd_key);
! 
! 		    clear_tv(&top_item->jd_key_tv);
! 		    if (di == NULL)
! 		    {
! 			clear_tv(cur_item);
! 			retval = FAIL;
! 			goto theend;
! 		    }
! 		    di->di_tv = *cur_item;
! 		    di->di_tv.v_lock = 0;
! 		    if (dict_add(top_item->jd_tv.vval.v_dict, di) == FAIL)
! 		    {
! 			dictitem_free(di);
! 			retval = FAIL;
! 			goto theend;
! 		    }
! 		}
! 
! 		json_skip_white(reader);
! 		p = reader->js_buf + reader->js_used;
! 		if (*p == ',')
! 		    ++reader->js_used;
! 		else if (*p != '}')
  		{
! 		    if (*p == NUL)
! 			retval = MAYBE;
! 		    else
! 		    {
! 			EMSG(_(e_invarg));
! 			retval = FAIL;
! 		    }
! 		    goto theend;
  		}
! 		top_item->jd_type = JSON_OBJECT_KEY;
! 		if (cur_item != NULL)
! 		    cur_item = &top_item->jd_key_tv;
! 		break;
! 	}
      }
  
+     /* Get here when parsing failed. */
      if (res != NULL)
      {
+ 	clear_tv(res);
  	res->v_type = VAR_SPECIAL;
  	res->vval.v_number = VVAL_NONE;
      }
      EMSG(_(e_invarg));
! 
! theend:
!     ga_clear(&stack);
!     clear_tv(&item);
!     return retval;
  }
  
  /*
*** ../vim-8.0.0168/src/version.c	2017-01-10 16:31:17.360192436 +0100
--- src/version.c	2017-01-10 19:43:29.018366492 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     169,
  /**/

-- 
"Marriage is the process of finding out what kind of man your wife
would have preferred"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0170
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0170 (after 8.0.0169)
Problem:    Channel test fails for using freed memory.
Solution:   Fix memory use in json_decode().
Files:      src/json.c


*** ../vim-8.0.0169/src/json.c	2017-01-10 19:44:14.594027155 +0100
--- src/json.c	2017-01-10 22:52:50.684942313 +0100
***************
*** 577,582 ****
--- 577,584 ----
      ga_init2(&stack, sizeof(json_dec_item_T), 100);
      cur_item = res;
      init_tv(&item);
+     if (res != NULL)
+     init_tv(res);
  
      fill_numbuflen(reader);
      p = reader->js_buf + reader->js_used;
***************
*** 985,991 ****
  
  theend:
      ga_clear(&stack);
-     clear_tv(&item);
      return retval;
  }
  
--- 987,992 ----
*** ../vim-8.0.0169/src/version.c	2017-01-10 19:44:14.594027155 +0100
--- src/version.c	2017-01-10 22:56:53.935190921 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     170,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
243. You unsuccessfully try to download a pizza from www.dominos.com.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0171
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0171
Problem:    JS style JSON does not support single quotes.
Solution:   Allow for single quotes. (Yasuhiro Matsumoto, closes #1371)
Files:      src/json.c, src/testdir/test_json.vim, src/json_test.c,
            runtime/doc/eval.txt


*** ../vim-8.0.0170/src/json.c	2017-01-10 22:57:27.126951746 +0100
--- src/json.c	2017-01-11 21:38:33.585878110 +0100
***************
*** 378,384 ****
  }
  
      static int
! json_decode_string(js_read_T *reader, typval_T *res)
  {
      garray_T    ga;
      int		len;
--- 378,384 ----
  }
  
      static int
! json_decode_string(js_read_T *reader, typval_T *res, int quote)
  {
      garray_T    ga;
      int		len;
***************
*** 389,396 ****
      if (res != NULL)
  	ga_init2(&ga, 1, 200);
  
!     p = reader->js_buf + reader->js_used + 1; /* skip over " */
!     while (*p != '"')
      {
  	/* The JSON is always expected to be utf-8, thus use utf functions
  	 * here. The string is converted below if needed. */
--- 389,396 ----
      if (res != NULL)
  	ga_init2(&ga, 1, 200);
  
!     p = reader->js_buf + reader->js_used + 1; /* skip over " or ' */
!     while (*p != quote)
      {
  	/* The JSON is always expected to be utf-8, thus use utf functions
  	 * here. The string is converted below if needed. */
***************
*** 504,510 ****
      }
  
      reader->js_used = (int)(p - reader->js_buf);
!     if (*p == '"')
      {
  	++reader->js_used;
  	if (res != NULL)
--- 504,510 ----
      }
  
      reader->js_used = (int)(p - reader->js_buf);
!     if (*p == quote)
      {
  	++reader->js_used;
  	if (res != NULL)
***************
*** 620,626 ****
  
  	if (top_item != NULL && top_item->jd_type == JSON_OBJECT_KEY
  		&& (options & JSON_JS)
! 		&& reader->js_buf[reader->js_used] != '"')
  	{
  	    char_u *key;
  
--- 620,627 ----
  
  	if (top_item != NULL && top_item->jd_type == JSON_OBJECT_KEY
  		&& (options & JSON_JS)
! 		&& reader->js_buf[reader->js_used] != '"'
! 		&& reader->js_buf[reader->js_used] != '\'')
  	{
  	    char_u *key;
  
***************
*** 690,696 ****
  		    continue;
  
  		case '"': /* string */
! 		    retval = json_decode_string(reader, cur_item);
  		    break;
  
  		case ',': /* comma: empty item */
--- 691,707 ----
  		    continue;
  
  		case '"': /* string */
! 		    retval = json_decode_string(reader, cur_item, *p);
! 		    break;
! 
! 		case '\'':
! 		    if (options & JSON_JS)
! 			retval = json_decode_string(reader, cur_item, *p);
! 		    else
! 		    {
! 			EMSG(_(e_invarg));
! 			retval = FAIL;
! 		    }
  		    break;
  
  		case ',': /* comma: empty item */
*** ../vim-8.0.0170/src/testdir/test_json.vim	2017-01-10 15:15:32.882134134 +0100
--- src/testdir/test_json.vim	2017-01-11 21:41:57.036343938 +0100
***************
*** 145,150 ****
--- 145,152 ----
    call assert_equal("", json_decode('""'))
  
    call assert_equal({'n': 1}, json_decode('{"n":1,}'))
+   call assert_fails("call json_decode(\"{'n':'1',}\")", 'E474:')
+   call assert_fails("call json_decode(\"'n'\")", 'E474:')
  
    call assert_fails('call json_decode("\"")', "E474:")
    call assert_fails('call json_decode("blah")', "E474:")
***************
*** 255,262 ****
--- 257,267 ----
    call assert_equal(v:none, js_decode(''))
    call assert_equal(type(v:none), type(js_decode('')))
    call assert_equal("", js_decode('""'))
+   call assert_equal("", js_decode("''"))
  
+   call assert_equal('n', js_decode("'n'"))
    call assert_equal({'n': 1}, js_decode('{"n":1,}'))
+   call assert_equal({'n': '1'}, js_decode("{'n':'1',}"))
  
    call assert_fails('call js_decode("\"")', "E474:")
    call assert_fails('call js_decode("blah")', "E474:")
*** ../vim-8.0.0170/src/json_test.c	2016-08-29 22:42:20.000000000 +0200
--- src/json_test.c	2017-01-11 21:45:07.614908800 +0100
***************
*** 181,187 ****
      reader.js_buf = (char_u *)" \"foo";
      reader.js_end = reader.js_buf + STRLEN(reader.js_buf);
      reader.js_cookie =        " \"foobar\"  ";
!     assert(json_decode_string(&reader, NULL) == OK);
  }
  #endif
  
--- 181,187 ----
      reader.js_buf = (char_u *)" \"foo";
      reader.js_end = reader.js_buf + STRLEN(reader.js_buf);
      reader.js_cookie =        " \"foobar\"  ";
!     assert(json_decode_string(&reader, NULL, '"') == OK);
  }
  #endif
  
*** ../vim-8.0.0170/runtime/doc/eval.txt	2017-01-08 13:25:47.622339813 +0100
--- runtime/doc/eval.txt	2017-01-11 21:42:55.763901507 +0100
***************
*** 5223,5228 ****
--- 5229,5235 ----
  js_decode({string})					*js_decode()*
  		This is similar to |json_decode()| with these differences:
  		- Object key names do not have to be in quotes.
+ 		- Strings can be in single quotes.
  		- Empty items in an array (between two commas) are allowed and
  		  result in v:none items.
  
*** ../vim-8.0.0170/src/version.c	2017-01-10 22:57:27.126951746 +0100
--- src/version.c	2017-01-11 21:37:21.842419713 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     171,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
248. You sign your letters with your e-mail address instead of your name.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0172
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0172 (after 8.0.0159)
Problem:    The command selected in the command line window is not executed.
            (Andrey Starodubtsev)
Solution:   Save and restore the command line at a lower level. (closes #1370)
Files:      src/ex_getln.c, src/testdir/test_history.vim


*** ../vim-8.0.0171/src/ex_getln.c	2017-01-09 12:58:05.639951514 +0100
--- src/ex_getln.c	2017-01-11 22:38:48.194527083 +0100
***************
*** 773,781 ****
  		/*
  		 * Open a window to edit the command line (and history).
  		 */
- 		save_cmdline(&save_ccline);
  		c = ex_window();
- 		restore_cmdline(&save_ccline);
  		some_key_typed = TRUE;
  	    }
  	}
--- 773,779 ----
***************
*** 6904,6912 ****
      redraw_later(SOME_VALID);
  
      /* Save the command line info, can be used recursively. */
!     save_ccline = ccline;
!     ccline.cmdbuff = NULL;
!     ccline.cmdprompt = NULL;
  
      /* No Ex mode here! */
      exmode_active = 0;
--- 6902,6908 ----
      redraw_later(SOME_VALID);
  
      /* Save the command line info, can be used recursively. */
!     save_cmdline(&save_ccline);
  
      /* No Ex mode here! */
      exmode_active = 0;
***************
*** 6953,6959 ****
  # endif
  
      /* Restore the command line info. */
!     ccline = save_ccline;
      cmdwin_type = 0;
  
      exmode_active = save_exmode;
--- 6949,6955 ----
  # endif
  
      /* Restore the command line info. */
!     restore_cmdline(&save_ccline);
      cmdwin_type = 0;
  
      exmode_active = save_exmode;
*** ../vim-8.0.0171/src/testdir/test_history.vim	2016-12-01 17:57:40.779167445 +0100
--- src/testdir/test_history.vim	2017-01-11 22:38:15.042776921 +0100
***************
*** 87,89 ****
--- 87,106 ----
    call assert_equal(-1, histnr('abc'))
    call assert_fails('call histnr([])', 'E730:')
  endfunction
+ 
+ function Test_Search_history_window()
+   new
+   call setline(1, ['a', 'b', 'a', 'b'])
+   1
+   call feedkeys("/a\<CR>", 'xt')
+   call assert_equal('a', getline('.'))
+   1
+   call feedkeys("/b\<CR>", 'xt')
+   call assert_equal('b', getline('.'))
+   1
+   " select the previous /a command
+   call feedkeys("q/kk\<CR>", 'x!')
+   call assert_equal('a', getline('.'))
+   call assert_equal('a', @/)
+   bwipe!
+ endfunc
*** ../vim-8.0.0171/src/version.c	2017-01-11 21:50:04.888673246 +0100
--- src/version.c	2017-01-11 22:34:18.800557984 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     172,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
251. You've never seen your closest friends who usually live WAY too far away.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0173
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0173
Problem:    When compiling with EBCDIC defined the build fails. (Yaroslav
            Kuzmin)
Solution:   Move sortFunctions() to the right file.  Avoid warning for
            redefining __SUSV3.
Files:      src/eval.c, src/evalfunc.c, src/os_unixx.h


*** ../vim-8.0.0172/src/eval.c	2017-01-08 20:50:47.433486722 +0100
--- src/eval.c	2017-01-12 20:01:14.091069684 +0100
***************
*** 242,255 ****
  static void list_one_var_a(char_u *prefix, char_u *name, int type, char_u *string, int *first);
  static char_u *find_option_end(char_u **arg, int *opt_flags);
  
- #ifdef EBCDIC
- static int compare_func_name(const void *s1, const void *s2);
- static void sortFunctions();
- #endif
- 
  /* for VIM_VERSION_ defines */
  #include "version.h"
  
  /*
   * Initialize the global and v: variables.
   */
--- 242,279 ----
  static void list_one_var_a(char_u *prefix, char_u *name, int type, char_u *string, int *first);
  static char_u *find_option_end(char_u **arg, int *opt_flags);
  
  /* for VIM_VERSION_ defines */
  #include "version.h"
  
+ 
+ #if defined(EBCDIC) || defined(PROTO)
+ /*
+  * Compare struct fst by function name.
+  */
+     static int
+ compare_func_name(const void *s1, const void *s2)
+ {
+     struct fst *p1 = (struct fst *)s1;
+     struct fst *p2 = (struct fst *)s2;
+ 
+     return STRCMP(p1->f_name, p2->f_name);
+ }
+ 
+ /*
+  * Sort the function table by function name.
+  * The sorting of the table above is ASCII dependant.
+  * On machines using EBCDIC we have to sort it.
+  */
+     static void
+ sortFunctions(void)
+ {
+     int		funcCnt = (int)(sizeof(functions) / sizeof(struct fst)) - 1;
+ 
+     qsort(functions, (size_t)funcCnt, sizeof(struct fst), compare_func_name);
+ }
+ #endif
+ 
+ 
  /*
   * Initialize the global and v: variables.
   */
*** ../vim-8.0.0172/src/evalfunc.c	2017-01-10 16:12:11.732767042 +0100
--- src/evalfunc.c	2017-01-12 20:00:30.007425122 +0100
***************
*** 923,956 ****
  
  #endif /* FEAT_CMDL_COMPL */
  
- #if defined(EBCDIC) || defined(PROTO)
- /*
-  * Compare struct fst by function name.
-  */
-     static int
- compare_func_name(const void *s1, const void *s2)
- {
-     struct fst *p1 = (struct fst *)s1;
-     struct fst *p2 = (struct fst *)s2;
- 
-     return STRCMP(p1->f_name, p2->f_name);
- }
- 
- /*
-  * Sort the function table by function name.
-  * The sorting of the table above is ASCII dependant.
-  * On machines using EBCDIC we have to sort it.
-  */
-     static void
- sortFunctions(void)
- {
-     int		funcCnt = (int)(sizeof(functions) / sizeof(struct fst)) - 1;
- 
-     qsort(functions, (size_t)funcCnt, sizeof(struct fst), compare_func_name);
- }
- #endif
- 
- 
  /*
   * Find internal function in table above.
   * Return index, or -1 if not found
--- 923,928 ----
*** ../vim-8.0.0172/src/os_unixx.h	2016-12-03 16:40:44.432532400 +0100
--- src/os_unixx.h	2017-01-12 20:04:26.285520714 +0100
***************
*** 113,119 ****
  
  /* shared library access */
  #if defined(HAVE_DLFCN_H) && defined(USE_DLOPEN)
! # ifdef __MVS__
      /* needed to define RTLD_LAZY (Anthony Giorgio) */
  #  define __SUSV3
  # endif
--- 113,119 ----
  
  /* shared library access */
  #if defined(HAVE_DLFCN_H) && defined(USE_DLOPEN)
! # if defined(__MVS__) && !defined (__SUSV3)
      /* needed to define RTLD_LAZY (Anthony Giorgio) */
  #  define __SUSV3
  # endif
*** ../vim-8.0.0172/src/version.c	2017-01-11 22:40:16.169863576 +0100
--- src/version.c	2017-01-12 20:05:47.480866643 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     173,
  /**/

-- 
Did you hear about the new 3 million dollar West Virginia State Lottery?
The winner gets 3 dollars a year for a million years.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0174
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0174
Problem:    For completion "locale -a" is executed on MS-Windows, even though
            it most likely won't work.
Solution:   Skip executing "locale -a" on MS-Windows. (Ken Takata)
Files:      src/ex_cmds2.c


*** ../vim-8.0.0173/src/ex_cmds2.c	2016-10-12 12:13:30.488344697 +0200
--- src/ex_cmds2.c	2017-01-12 20:24:17.196005566 +0100
***************
*** 5091,5113 ****
  # if defined(FEAT_CMDL_COMPL) || defined(PROTO)
  
  static char_u	**locales = NULL;	/* Array of all available locales */
- static int	did_init_locales = FALSE;
- 
- static void init_locales(void);
- static char_u **find_locales(void);
  
! /*
!  * Lazy initialization of all available locales.
!  */
!     static void
! init_locales(void)
! {
!     if (!did_init_locales)
!     {
! 	did_init_locales = TRUE;
! 	locales = find_locales();
!     }
! }
  
  /* Return an array of strings for all available locales + NULL for the
   * last element.  Return NULL in case of error. */
--- 5091,5099 ----
  # if defined(FEAT_CMDL_COMPL) || defined(PROTO)
  
  static char_u	**locales = NULL;	/* Array of all available locales */
  
! #  ifndef WIN32
! static int	did_init_locales = FALSE;
  
  /* Return an array of strings for all available locales + NULL for the
   * last element.  Return NULL in case of error. */
***************
*** 5149,5154 ****
--- 5135,5156 ----
      ((char_u **)locales_ga.ga_data)[locales_ga.ga_len] = NULL;
      return (char_u **)locales_ga.ga_data;
  }
+ #  endif
+ 
+ /*
+  * Lazy initialization of all available locales.
+  */
+     static void
+ init_locales(void)
+ {
+ #  ifndef WIN32
+     if (!did_init_locales)
+     {
+ 	did_init_locales = TRUE;
+ 	locales = find_locales();
+     }
+ #  endif
+ }
  
  #  if defined(EXITFREE) || defined(PROTO)
      void
*** ../vim-8.0.0173/src/version.c	2017-01-12 20:06:30.152522974 +0100
--- src/version.c	2017-01-12 20:25:42.227337459 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     174,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
256. You are able to write down over 250 symptoms of being an internet
     addict, even though they only asked for 101.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0175
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0175
Problem:    Setting language in gvim on MS-Windows does not work when
            libintl.dll is dynamically linked with msvcrt.dll.
Solution:   Use putenv() from libintl as well. (Ken Takata, closes #1082)
Files:      src/mbyte.c, src/misc1.c, src/os_win32.c, src/proto/os_win32.pro,
            src/vim.h


*** ../vim-8.0.0174/src/mbyte.c	2016-12-03 16:40:44.432532400 +0100
--- src/mbyte.c	2017-01-12 21:39:35.536587643 +0100
***************
*** 4584,4630 ****
  #   endif
  
  /*
-  * Get the address of 'funcname' which is imported by 'hInst' DLL.
-  */
-     static void *
- get_iconv_import_func(HINSTANCE hInst, const char *funcname)
- {
-     PBYTE			pImage = (PBYTE)hInst;
-     PIMAGE_DOS_HEADER		pDOS = (PIMAGE_DOS_HEADER)hInst;
-     PIMAGE_NT_HEADERS		pPE;
-     PIMAGE_IMPORT_DESCRIPTOR	pImpDesc;
-     PIMAGE_THUNK_DATA		pIAT;	    /* Import Address Table */
-     PIMAGE_THUNK_DATA		pINT;	    /* Import Name Table */
-     PIMAGE_IMPORT_BY_NAME	pImpName;
- 
-     if (pDOS->e_magic != IMAGE_DOS_SIGNATURE)
- 	return NULL;
-     pPE = (PIMAGE_NT_HEADERS)(pImage + pDOS->e_lfanew);
-     if (pPE->Signature != IMAGE_NT_SIGNATURE)
- 	return NULL;
-     pImpDesc = (PIMAGE_IMPORT_DESCRIPTOR)(pImage
- 	    + pPE->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]
- 							    .VirtualAddress);
-     for (; pImpDesc->FirstThunk; ++pImpDesc)
-     {
- 	if (!pImpDesc->OriginalFirstThunk)
- 	    continue;
- 	pIAT = (PIMAGE_THUNK_DATA)(pImage + pImpDesc->FirstThunk);
- 	pINT = (PIMAGE_THUNK_DATA)(pImage + pImpDesc->OriginalFirstThunk);
- 	for (; pIAT->u1.Function; ++pIAT, ++pINT)
- 	{
- 	    if (IMAGE_SNAP_BY_ORDINAL(pINT->u1.Ordinal))
- 		continue;
- 	    pImpName = (PIMAGE_IMPORT_BY_NAME)(pImage
- 					+ (UINT_PTR)(pINT->u1.AddressOfData));
- 	    if (strcmp((char *)pImpName->Name, funcname) == 0)
- 		return (void *)pIAT->u1.Function;
- 	}
-     }
-     return NULL;
- }
- 
- /*
   * Try opening the iconv.dll and return TRUE if iconv() can be used.
   */
      int
--- 4584,4589 ----
***************
*** 4671,4677 ****
      iconv_open	= (void *)GetProcAddress(hIconvDLL, "libiconv_open");
      iconv_close	= (void *)GetProcAddress(hIconvDLL, "libiconv_close");
      iconvctl	= (void *)GetProcAddress(hIconvDLL, "libiconvctl");
!     iconv_errno	= get_iconv_import_func(hIconvDLL, "_errno");
      if (iconv_errno == NULL)
  	iconv_errno = (void *)GetProcAddress(hMsvcrtDLL, "_errno");
      if (iconv == NULL || iconv_open == NULL || iconv_close == NULL
--- 4630,4636 ----
      iconv_open	= (void *)GetProcAddress(hIconvDLL, "libiconv_open");
      iconv_close	= (void *)GetProcAddress(hIconvDLL, "libiconv_close");
      iconvctl	= (void *)GetProcAddress(hIconvDLL, "libiconvctl");
!     iconv_errno	= get_dll_import_func(hIconvDLL, "_errno");
      if (iconv_errno == NULL)
  	iconv_errno = (void *)GetProcAddress(hMsvcrtDLL, "_errno");
      if (iconv == NULL || iconv_open == NULL || iconv_close == NULL
*** ../vim-8.0.0174/src/misc1.c	2017-01-07 15:39:36.397759526 +0100
--- src/misc1.c	2017-01-12 21:39:35.536587643 +0100
***************
*** 4455,4460 ****
--- 4455,4463 ----
      {
  	sprintf((char *)envbuf, "%s=%s", name, val);
  	putenv((char *)envbuf);
+ # ifdef libintl_putenv
+ 	libintl_putenv((char *)envbuf);
+ # endif
      }
  #endif
  #ifdef FEAT_GETTEXT
*** ../vim-8.0.0174/src/os_win32.c	2016-11-26 15:13:29.406218061 +0100
--- src/os_win32.c	2017-01-12 21:42:16.767329718 +0100
***************
*** 425,430 ****
--- 425,508 ----
      return dll;
  }
  
+ #if defined(DYNAMIC_ICONV) || defined(DYNAMIC_GETTEXT) || defined(PROTO)
+ /*
+  * Get related information about 'funcname' which is imported by 'hInst'.
+  * If 'info' is 0, return the function address.
+  * If 'info' is 1, return the module name which the function is imported from.
+  */
+     static void *
+ get_imported_func_info(HINSTANCE hInst, const char *funcname, int info)
+ {
+     PBYTE			pImage = (PBYTE)hInst;
+     PIMAGE_DOS_HEADER		pDOS = (PIMAGE_DOS_HEADER)hInst;
+     PIMAGE_NT_HEADERS		pPE;
+     PIMAGE_IMPORT_DESCRIPTOR	pImpDesc;
+     PIMAGE_THUNK_DATA		pIAT;	    /* Import Address Table */
+     PIMAGE_THUNK_DATA		pINT;	    /* Import Name Table */
+     PIMAGE_IMPORT_BY_NAME	pImpName;
+ 
+     if (pDOS->e_magic != IMAGE_DOS_SIGNATURE)
+ 	return NULL;
+     pPE = (PIMAGE_NT_HEADERS)(pImage + pDOS->e_lfanew);
+     if (pPE->Signature != IMAGE_NT_SIGNATURE)
+ 	return NULL;
+     pImpDesc = (PIMAGE_IMPORT_DESCRIPTOR)(pImage
+ 	    + pPE->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]
+ 							    .VirtualAddress);
+     for (; pImpDesc->FirstThunk; ++pImpDesc)
+     {
+ 	if (!pImpDesc->OriginalFirstThunk)
+ 	    continue;
+ 	pIAT = (PIMAGE_THUNK_DATA)(pImage + pImpDesc->FirstThunk);
+ 	pINT = (PIMAGE_THUNK_DATA)(pImage + pImpDesc->OriginalFirstThunk);
+ 	for (; pIAT->u1.Function; ++pIAT, ++pINT)
+ 	{
+ 	    if (IMAGE_SNAP_BY_ORDINAL(pINT->u1.Ordinal))
+ 		continue;
+ 	    pImpName = (PIMAGE_IMPORT_BY_NAME)(pImage
+ 					+ (UINT_PTR)(pINT->u1.AddressOfData));
+ 	    if (strcmp((char *)pImpName->Name, funcname) == 0)
+ 	    {
+ 		switch (info)
+ 		{
+ 		    case 0:
+ 			return (void *)pIAT->u1.Function;
+ 		    case 1:
+ 			return (void *)(pImage + pImpDesc->Name);
+ 		    default:
+ 			return NULL;
+ 		}
+ 	    }
+ 	}
+     }
+     return NULL;
+ }
+ 
+ /*
+  * Get the module handle which 'funcname' in 'hInst' is imported from.
+  */
+     HINSTANCE
+ find_imported_module_by_funcname(HINSTANCE hInst, const char *funcname)
+ {
+     char    *modulename;
+ 
+     modulename = (char *)get_imported_func_info(hInst, funcname, 1);
+     if (modulename != NULL)
+ 	return GetModuleHandleA(modulename);
+     return NULL;
+ }
+ 
+ /*
+  * Get the address of 'funcname' which is imported by 'hInst' DLL.
+  */
+     void *
+ get_dll_import_func(HINSTANCE hInst, const char *funcname)
+ {
+     return get_imported_func_info(hInst, funcname, 0);
+ }
+ #endif
+ 
  #if defined(DYNAMIC_GETTEXT) || defined(PROTO)
  # ifndef GETTEXT_DLL
  #  define GETTEXT_DLL "libintl.dll"
***************
*** 436,441 ****
--- 514,520 ----
  static char *null_libintl_textdomain(const char *);
  static char *null_libintl_bindtextdomain(const char *, const char *);
  static char *null_libintl_bind_textdomain_codeset(const char *, const char *);
+ static int null_libintl_putenv(const char *);
  
  static HINSTANCE hLibintlDLL = NULL;
  char *(*dyn_libintl_gettext)(const char *) = null_libintl_gettext;
***************
*** 446,451 ****
--- 525,531 ----
  						= null_libintl_bindtextdomain;
  char *(*dyn_libintl_bind_textdomain_codeset)(const char *, const char *)
  				       = null_libintl_bind_textdomain_codeset;
+ int (*dyn_libintl_putenv)(const char *) = null_libintl_putenv;
  
      int
  dyn_libintl_init(void)
***************
*** 463,468 ****
--- 543,549 ----
  	{"bindtextdomain", (FARPROC*)&dyn_libintl_bindtextdomain},
  	{NULL, NULL}
      };
+     HINSTANCE hmsvcrt;
  
      /* No need to initialize twice. */
      if (hLibintlDLL)
***************
*** 507,512 ****
--- 588,600 ----
  	dyn_libintl_bind_textdomain_codeset =
  					 null_libintl_bind_textdomain_codeset;
  
+     /* _putenv() function for the libintl.dll is optional. */
+     hmsvcrt = find_imported_module_by_funcname(hLibintlDLL, "getenv");
+     if (hmsvcrt != NULL)
+ 	dyn_libintl_putenv = (void *)GetProcAddress(hmsvcrt, "_putenv");
+     if (dyn_libintl_putenv == NULL || dyn_libintl_putenv == putenv)
+ 	dyn_libintl_putenv = null_libintl_putenv;
+ 
      return 1;
  }
  
***************
*** 521,526 ****
--- 609,615 ----
      dyn_libintl_textdomain	= null_libintl_textdomain;
      dyn_libintl_bindtextdomain	= null_libintl_bindtextdomain;
      dyn_libintl_bind_textdomain_codeset = null_libintl_bind_textdomain_codeset;
+     dyn_libintl_putenv		= null_libintl_putenv;
  }
  
  /*ARGSUSED*/
***************
*** 562,567 ****
--- 651,663 ----
      return NULL;
  }
  
+ /*ARGSUSED*/
+     int
+ null_libintl_putenv(const char *envstring)
+ {
+     return 0;
+ }
+ 
  #endif /* DYNAMIC_GETTEXT */
  
  /* This symbol is not defined in older versions of the SDK or Visual C++ */
***************
*** 4781,4812 ****
  #if defined(FEAT_JOB_CHANNEL) || defined(PROTO)
      static HANDLE
  job_io_file_open(
!         char_u *fname,
!         DWORD dwDesiredAccess,
!         DWORD dwShareMode,
!         LPSECURITY_ATTRIBUTES lpSecurityAttributes,
!         DWORD dwCreationDisposition,
!         DWORD dwFlagsAndAttributes)
  {
      HANDLE h;
  # ifdef FEAT_MBYTE
      WCHAR *wn = NULL;
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
!         wn = enc_to_utf16(fname, NULL);
!         if (wn != NULL)
!         {
!             h = CreateFileW(wn, dwDesiredAccess, dwShareMode,
!                      lpSecurityAttributes, dwCreationDisposition,
!                      dwFlagsAndAttributes, NULL);
!             vim_free(wn);
!         }
      }
      if (wn == NULL)
  # endif
!         h = CreateFile((LPCSTR)fname, dwDesiredAccess, dwShareMode,
!                      lpSecurityAttributes, dwCreationDisposition,
!                      dwFlagsAndAttributes, NULL);
      return h;
  }
  
--- 4877,4908 ----
  #if defined(FEAT_JOB_CHANNEL) || defined(PROTO)
      static HANDLE
  job_io_file_open(
! 	char_u *fname,
! 	DWORD dwDesiredAccess,
! 	DWORD dwShareMode,
! 	LPSECURITY_ATTRIBUTES lpSecurityAttributes,
! 	DWORD dwCreationDisposition,
! 	DWORD dwFlagsAndAttributes)
  {
      HANDLE h;
  # ifdef FEAT_MBYTE
      WCHAR *wn = NULL;
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
! 	wn = enc_to_utf16(fname, NULL);
! 	if (wn != NULL)
! 	{
! 	    h = CreateFileW(wn, dwDesiredAccess, dwShareMode,
! 		    lpSecurityAttributes, dwCreationDisposition,
! 		    dwFlagsAndAttributes, NULL);
! 	    vim_free(wn);
! 	}
      }
      if (wn == NULL)
  # endif
! 	h = CreateFile((LPCSTR)fname, dwDesiredAccess, dwShareMode,
! 		lpSecurityAttributes, dwCreationDisposition,
! 		dwFlagsAndAttributes, NULL);
      return h;
  }
  
*** ../vim-8.0.0174/src/proto/os_win32.pro	2016-10-15 18:36:45.353910276 +0200
--- src/proto/os_win32.pro	2017-01-12 21:39:35.540587611 +0100
***************
*** 1,5 ****
--- 1,7 ----
  /* os_win32.c */
  HINSTANCE vimLoadLib(char *name);
+ HINSTANCE find_imported_module_by_funcname(HINSTANCE hInst, const char *funcname);
+ void *get_dll_import_func(HINSTANCE hInst, const char *funcname);
  int dyn_libintl_init(void);
  void dyn_libintl_end(void);
  void PlatformId(void);
*** ../vim-8.0.0174/src/vim.h	2016-12-03 16:40:44.432532400 +0100
--- src/vim.h	2017-01-12 21:39:35.540587611 +0100
***************
*** 574,579 ****
--- 574,580 ----
  extern char *(*dyn_libintl_bindtextdomain)(const char *domainname, const char *dirname);
  extern char *(*dyn_libintl_bind_textdomain_codeset)(const char *domainname, const char *codeset);
  extern char *(*dyn_libintl_textdomain)(const char *domainname);
+ extern int (*dyn_libintl_putenv)(const char *envstring);
  #endif
  
  
***************
*** 592,597 ****
--- 593,599 ----
  #   define HAVE_BIND_TEXTDOMAIN_CODESET 1
  #  endif
  #  define textdomain(domain) (*dyn_libintl_textdomain)(domain)
+ #  define libintl_putenv(envstring) (*dyn_libintl_putenv)(envstring)
  # else
  #  include <libintl.h>
  #  define _(x) gettext((char *)(x))
*** ../vim-8.0.0174/src/version.c	2017-01-12 20:28:22.454078272 +0100
--- src/version.c	2017-01-12 21:39:20.840702285 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     175,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
257. Your "hundred-and-one" lists include well over 101 items, since you
     automatically interpret all numbers in hexadecimal notation.
     (hex 101 = decimal 257)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0176
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0176
Problem:    Using :change in between :function and :endfunction fails.
Solution:   Recognize :change inside a function. (ichizok, closes #1374)
Files:      src/userfunc.c, src/testdir/test_viml.vim


*** ../vim-8.0.0175/src/userfunc.c	2016-11-10 20:01:41.201582868 +0100
--- src/userfunc.c	2017-01-12 22:15:55.659667539 +0100
***************
*** 2085,2093 ****
  		}
  	    }
  
! 	    /* Check for ":append" or ":insert". */
  	    p = skip_range(p, NULL);
  	    if ((p[0] == 'a' && (!ASCII_ISALPHA(p[1]) || p[1] == 'p'))
  		    || (p[0] == 'i'
  			&& (!ASCII_ISALPHA(p[1]) || (p[1] == 'n'
  				&& (!ASCII_ISALPHA(p[2]) || (p[2] == 's'))))))
--- 2085,2098 ----
  		}
  	    }
  
! 	    /* Check for ":append", ":change", ":insert". */
  	    p = skip_range(p, NULL);
  	    if ((p[0] == 'a' && (!ASCII_ISALPHA(p[1]) || p[1] == 'p'))
+ 		    || (p[0] == 'c'
+ 			&& (!ASCII_ISALPHA(p[1]) || (p[1] == 'h'
+ 				&& (!ASCII_ISALPHA(p[2]) || (p[2] == 'a'
+ 					&& (STRNCMP(&p[3], "nge", 3) != 0
+ 					    || !ASCII_ISALPHA(p[6])))))))
  		    || (p[0] == 'i'
  			&& (!ASCII_ISALPHA(p[1]) || (p[1] == 'n'
  				&& (!ASCII_ISALPHA(p[2]) || (p[2] == 's'))))))
*** ../vim-8.0.0175/src/testdir/test_viml.vim	2016-07-19 17:11:58.000000000 +0200
--- src/testdir/test_viml.vim	2017-01-12 22:15:18.627955280 +0100
***************
*** 1239,1244 ****
--- 1239,1315 ----
  endfunc
  
  "-------------------------------------------------------------------------------
+ " Test 95:  lines of :append, :change, :insert			    {{{1
+ "-------------------------------------------------------------------------------
+ 
+ function! DefineFunction(name, body)
+     let func = join(['function! ' . a:name . '()'] + a:body + ['endfunction'], "\n")
+     exec func
+ endfunction
+ 
+ func Test_script_lines()
+     " :append
+     try
+         call DefineFunction('T_Append', [
+                     \ 'append',
+                     \ 'py <<EOS',
+                     \ '.',
+                     \ ])
+     catch
+         call assert_false(1, "Can't define function")
+     endtry
+     try
+         call DefineFunction('T_Append', [
+                     \ 'append',
+                     \ 'abc',
+                     \ ])
+         call assert_false(1, "Shouldn't be able to define function")
+     catch
+         call assert_exception('Vim(function):E126: Missing :endfunction')
+     endtry
+ 
+     " :change
+     try
+         call DefineFunction('T_Change', [
+                     \ 'change',
+                     \ 'py <<EOS',
+                     \ '.',
+                     \ ])
+     catch
+         call assert_false(1, "Can't define function")
+     endtry
+     try
+         call DefineFunction('T_Change', [
+                     \ 'change',
+                     \ 'abc',
+                     \ ])
+         call assert_false(1, "Shouldn't be able to define function")
+     catch
+         call assert_exception('Vim(function):E126: Missing :endfunction')
+     endtry
+ 
+     " :insert
+     try
+         call DefineFunction('T_Insert', [
+                     \ 'insert',
+                     \ 'py <<EOS',
+                     \ '.',
+                     \ ])
+     catch
+         call assert_false(1, "Can't define function")
+     endtry
+     try
+         call DefineFunction('T_Insert', [
+                     \ 'insert',
+                     \ 'abc',
+                     \ ])
+         call assert_false(1, "Shouldn't be able to define function")
+     catch
+         call assert_exception('Vim(function):E126: Missing :endfunction')
+     endtry
+ endfunc
+ 
+ "-------------------------------------------------------------------------------
  " Modelines								    {{{1
  " vim: ts=8 sw=4 tw=80 fdm=marker
  " vim: fdt=substitute(substitute(foldtext(),\ '\\%(^+--\\)\\@<=\\(\\s*\\)\\(.\\{-}\\)\:\ \\%(\"\ \\)\\=\\(Test\ \\d*\\)\:\\s*',\ '\\3\ (\\2)\:\ \\1',\ \"\"),\ '\\(Test\\s*\\)\\(\\d\\)\\D\\@=',\ '\\1\ \\2',\ "")
*** ../vim-8.0.0175/src/version.c	2017-01-12 21:44:45.146171805 +0100
--- src/version.c	2017-01-12 22:17:49.762780784 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     176,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
259. When you enter your name in the AltaVista search engine, the top ten
     matches do indeed refer to you.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0177
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0177
Problem:    When opening a buffer on a directory and inside a try/catch then
            the BufEnter event is not triggered.
Solution:   Return NOTDONE from readfile() for a directory and deal with the
            three possible return values. (Justin M. Keyes, closes #1375,
            closes #1353)
Files:      src/buffer.c, src/ex_cmds.c, src/ex_docmd.c, src/fileio.c,
            src/memline.c, src/testdir/test_autocmd.vim


*** ../vim-8.0.0176/src/buffer.c	2016-12-01 17:48:24.910803059 +0100
--- src/buffer.c	2017-01-13 21:51:38.871157464 +0100
***************
*** 113,128 ****
  	 * it can be changed there. */
  	if (!readonlymode && !bufempty())
  	    changed();
! 	else if (retval != FAIL)
  	    unchanged(curbuf, FALSE);
  
  #ifdef FEAT_AUTOCMD
  # ifdef FEAT_EVAL
! 	apply_autocmds_retval(EVENT_STDINREADPOST, NULL, NULL, FALSE,
  							curbuf, &retval);
  # else
! 	apply_autocmds(EVENT_STDINREADPOST, NULL, NULL, FALSE, curbuf);
  # endif
  #endif
      }
      return retval;
--- 113,131 ----
  	 * it can be changed there. */
  	if (!readonlymode && !bufempty())
  	    changed();
! 	else if (retval == OK)
  	    unchanged(curbuf, FALSE);
  
  #ifdef FEAT_AUTOCMD
+ 	if (retval == OK)
+ 	{
  # ifdef FEAT_EVAL
! 	    apply_autocmds_retval(EVENT_STDINREADPOST, NULL, NULL, FALSE,
  							curbuf, &retval);
  # else
! 	    apply_autocmds(EVENT_STDINREADPOST, NULL, NULL, FALSE, curbuf);
  # endif
+ 	}
  #endif
      }
      return retval;
***************
*** 294,300 ****
  #endif
         )
  	changed();
!     else if (retval != FAIL && !read_stdin && !read_fifo)
  	unchanged(curbuf, FALSE);
      save_file_ff(curbuf);		/* keep this fileformat */
  
--- 297,303 ----
  #endif
         )
  	changed();
!     else if (retval == OK && !read_stdin && !read_fifo)
  	unchanged(curbuf, FALSE);
      save_file_ff(curbuf);		/* keep this fileformat */
  
***************
*** 328,334 ****
  # endif
  #endif
  
!     if (retval != FAIL)
      {
  #ifdef FEAT_AUTOCMD
  	/*
--- 331,337 ----
  # endif
  #endif
  
!     if (retval == OK)
      {
  #ifdef FEAT_AUTOCMD
  	/*
*** ../vim-8.0.0176/src/ex_cmds.c	2016-12-14 21:41:56.997414047 +0100
--- src/ex_cmds.c	2017-01-13 21:51:38.875157432 +0100
***************
*** 1313,1319 ****
  	if (otmp != NULL)
  	{
  	    if (readfile(otmp, NULL, line2, (linenr_T)0, (linenr_T)MAXLNUM,
! 						    eap, READ_FILTER) == FAIL)
  	    {
  #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
  		if (!aborting())
--- 1313,1319 ----
  	if (otmp != NULL)
  	{
  	    if (readfile(otmp, NULL, line2, (linenr_T)0, (linenr_T)MAXLNUM,
! 						    eap, READ_FILTER) != OK)
  	    {
  #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
  		if (!aborting())
*** ../vim-8.0.0176/src/ex_docmd.c	2017-01-07 20:39:49.970046560 +0100
--- src/ex_docmd.c	2017-01-13 21:51:38.879157400 +0100
***************
*** 8857,8863 ****
  			  eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);
  
  	}
! 	if (i == FAIL)
  	{
  #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
  	    if (!aborting())
--- 8857,8863 ----
  			  eap->line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0);
  
  	}
! 	if (i != OK)
  	{
  #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
  	    if (!aborting())
*** ../vim-8.0.0176/src/fileio.c	2016-09-25 20:51:25.399154303 +0200
--- src/fileio.c	2017-01-13 21:59:36.599352568 +0100
***************
*** 210,216 ****
   * READ_KEEP_UNDO  don't clear undo info or read it from a file
   * READ_FIFO	read from fifo/socket instead of a file
   *
!  * return FAIL for failure, OK otherwise
   */
      int
  readfile(
--- 210,216 ----
   * READ_KEEP_UNDO  don't clear undo info or read it from a file
   * READ_FIFO	read from fifo/socket instead of a file
   *
!  * return FAIL for failure, NOTDONE for directory (failure), or OK
   */
      int
  readfile(
***************
*** 450,462 ****
  # endif
  						)
  	{
  	    if (S_ISDIR(perm))
  		filemess(curbuf, fname, (char_u *)_("is a directory"), 0);
  	    else
  		filemess(curbuf, fname, (char_u *)_("is not a file"), 0);
  	    msg_end();
  	    msg_scroll = msg_save;
! 	    return FAIL;
  	}
  #endif
  #if defined(MSWIN)
--- 450,467 ----
  # endif
  						)
  	{
+ 	    int retval = FAIL;
+ 
  	    if (S_ISDIR(perm))
+ 	    {
  		filemess(curbuf, fname, (char_u *)_("is a directory"), 0);
+ 		retval = NOTDONE;
+ 	    }
  	    else
  		filemess(curbuf, fname, (char_u *)_("is not a file"), 0);
  	    msg_end();
  	    msg_scroll = msg_save;
! 	    return retval;
  	}
  #endif
  #if defined(MSWIN)
***************
*** 7136,7142 ****
  #endif
  	    if (readfile(buf->b_ffname, buf->b_fname, (linenr_T)0,
  			(linenr_T)0,
! 			(linenr_T)MAXLNUM, &ea, flags) == FAIL)
  	    {
  #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
  		if (!aborting())
--- 7141,7147 ----
  #endif
  	    if (readfile(buf->b_ffname, buf->b_fname, (linenr_T)0,
  			(linenr_T)0,
! 			(linenr_T)MAXLNUM, &ea, flags) != OK)
  	    {
  #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
  		if (!aborting())
*** ../vim-8.0.0176/src/memline.c	2016-11-10 20:01:41.193582919 +0100
--- src/memline.c	2017-01-13 21:51:38.879157400 +0100
***************
*** 1519,1525 ****
  			    line_count = pp->pb_pointer[idx].pe_line_count;
  			    if (readfile(curbuf->b_ffname, NULL, lnum,
  					pp->pb_pointer[idx].pe_old_lnum - 1,
! 					line_count, NULL, 0) == FAIL)
  				cannot_open = TRUE;
  			    else
  				lnum += line_count;
--- 1519,1525 ----
  			    line_count = pp->pb_pointer[idx].pe_line_count;
  			    if (readfile(curbuf->b_ffname, NULL, lnum,
  					pp->pb_pointer[idx].pe_old_lnum - 1,
! 					line_count, NULL, 0) != OK)
  				cannot_open = TRUE;
  			    else
  				lnum += line_count;
*** ../vim-8.0.0176/src/testdir/test_autocmd.vim	2016-09-29 20:54:42.403110749 +0200
--- src/testdir/test_autocmd.vim	2017-01-13 21:49:20.140267347 +0100
***************
*** 322,324 ****
--- 322,343 ----
    call delete('Xtestje2')
    call delete('Xtestje3')
  endfunc
+ 
+ func Test_BufEnter()
+   au! BufEnter
+   au Bufenter * let val = val . '+'
+   let g:val = ''
+   split NewFile
+   call assert_equal('+', g:val)
+   bwipe!
+   call assert_equal('++', g:val)
+ 
+   " Also get BufEnter when editing a directory
+   call mkdir('Xdir')
+   split Xdir
+   call assert_equal('+++', g:val)
+   bwipe!
+ 
+   call delete('Xdir', 'd')
+   au! BufEnter
+ endfunc
*** ../vim-8.0.0176/src/version.c	2017-01-12 22:20:49.465383753 +0100
--- src/version.c	2017-01-13 21:43:33.859050957 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     177,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
267. You get an extra phone line so you can get phone calls.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0178
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0178
Problem:    test_command_count may fail when a previous test interferes, seen
            on MS-Windows.
Solution:   Run it separately.
Files:      src/testdir/test_alot.vim, src/testdir/Make_all.mak


*** ../vim-8.0.0177/src/testdir/test_alot.vim	2017-01-10 16:12:11.732767042 +0100
--- src/testdir/test_alot.vim	2017-01-13 22:23:01.568320362 +0100
***************
*** 3,9 ****
  
  source test_assign.vim
  source test_autocmd.vim
- source test_command_count.vim
  source test_cursor_func.vim
  source test_delete.vim
  source test_execute_func.vim
--- 3,8 ----
*** ../vim-8.0.0177/src/testdir/Make_all.mak	2017-01-08 13:25:47.626339783 +0100
--- src/testdir/Make_all.mak	2017-01-13 22:24:29.235638037 +0100
***************
*** 144,149 ****
--- 144,150 ----
  	    test_channel.res \
  	    test_charsearch.res \
  	    test_cmdline.res \
+ 	    test_command_count.res \
  	    test_crypt.res \
  	    test_cscope.res \
  	    test_diffmode.res \
*** ../vim-8.0.0177/src/version.c	2017-01-13 21:59:59.327172086 +0100
--- src/version.c	2017-01-13 22:28:46.097636259 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     178,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
268. You get up in the morning and go online before getting your coffee.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0179
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0179
Problem:    'formatprg' is a global option but the value may depend on the
            type of buffer. (Sung Pae)
Solution:   Make 'formatprg' global-local. (closes #1380)
Files:      src/structs.h, src/option.h, src/option.c, src/normal.c,
            runtime/doc/options.txt, src/testdir/test_normal.vim


*** ../vim-8.0.0178/src/structs.h	2016-12-01 15:34:04.083413947 +0100
--- src/structs.h	2017-01-14 13:17:26.843045672 +0100
***************
*** 2097,2102 ****
--- 2097,2103 ----
      long_u	b_p_inde_flags;	/* flags for 'indentexpr' */
      char_u	*b_p_indk;	/* 'indentkeys' */
  #endif
+     char_u	*b_p_fp;	/* 'formatprg' */
  #if defined(FEAT_EVAL)
      char_u	*b_p_fex;	/* 'formatexpr' */
      long_u	b_p_fex_flags;	/* flags for 'formatexpr' */
*** ../vim-8.0.0178/src/option.h	2016-08-29 22:42:20.000000000 +0200
--- src/option.h	2017-01-14 13:24:42.368328907 +0100
***************
*** 1029,1034 ****
--- 1029,1035 ----
      , BV_EP
      , BV_ET
      , BV_FENC
+     , BV_FP
  #ifdef FEAT_EVAL
      , BV_BEXPR
      , BV_FEX
*** ../vim-8.0.0178/src/option.c	2016-12-03 15:13:16.415147422 +0100
--- src/option.c	2017-01-14 13:46:43.788096973 +0100
***************
*** 107,112 ****
--- 107,113 ----
  #if defined(FEAT_BEVAL) && defined(FEAT_EVAL)
  # define PV_BEXPR	OPT_BOTH(OPT_BUF(BV_BEXPR))
  #endif
+ #define PV_FP		OPT_BOTH(OPT_BUF(BV_FP))
  #ifdef FEAT_EVAL
  # define PV_FEX		OPT_BUF(BV_FEX)
  #endif
***************
*** 1258,1264 ****
  			    {(char_u *)"^\\s*\\d\\+[\\]:.)}\\t ]\\s*",
  						 (char_u *)0L} SCRIPTID_INIT},
      {"formatprg",   "fp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
! 			    (char_u *)&p_fp, PV_NONE,
  			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"fsync",       "fs",   P_BOOL|P_SECURE|P_VI_DEF,
  #ifdef HAVE_FSYNC
--- 1259,1265 ----
  			    {(char_u *)"^\\s*\\d\\+[\\]:.)}\\t ]\\s*",
  						 (char_u *)0L} SCRIPTID_INIT},
      {"formatprg",   "fp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
! 			    (char_u *)&p_fp, PV_FP,
  			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"fsync",       "fs",   P_BOOL|P_SECURE|P_VI_DEF,
  #ifdef HAVE_FSYNC
***************
*** 5481,5486 ****
--- 5482,5488 ----
  #if defined(FEAT_CRYPT)
      check_string_option(&buf->b_p_cm);
  #endif
+     check_string_option(&buf->b_p_fp);
  #if defined(FEAT_EVAL)
      check_string_option(&buf->b_p_fex);
  #endif
***************
*** 10175,10180 ****
--- 10177,10185 ----
  	    clear_string_option(&buf->b_p_tsr);
  	    break;
  #endif
+ 	case PV_FP:
+ 	    clear_string_option(&buf->b_p_fp);
+ 	    break;
  #ifdef FEAT_QUICKFIX
  	case PV_EFM:
  	    clear_string_option(&buf->b_p_efm);
***************
*** 10228,10233 ****
--- 10233,10239 ----
      {
  	switch ((int)p->indir)
  	{
+ 	    case PV_FP:   return (char_u *)&(curbuf->b_p_fp);
  #ifdef FEAT_QUICKFIX
  	    case PV_EFM:  return (char_u *)&(curbuf->b_p_efm);
  	    case PV_GP:   return (char_u *)&(curbuf->b_p_gp);
***************
*** 10308,10313 ****
--- 10314,10321 ----
  	case PV_TSR:	return *curbuf->b_p_tsr != NUL
  				    ? (char_u *)&(curbuf->b_p_tsr) : p->var;
  #endif
+ 	case PV_FP:	return *curbuf->b_p_fp != NUL
+ 				    ? (char_u *)&(curbuf->b_p_fp) : p->var;
  #ifdef FEAT_QUICKFIX
  	case PV_EFM:	return *curbuf->b_p_efm != NUL
  				    ? (char_u *)&(curbuf->b_p_efm) : p->var;
***************
*** 10873,10878 ****
--- 10881,10887 ----
  	    buf->b_p_inde = vim_strsave(p_inde);
  	    buf->b_p_indk = vim_strsave(p_indk);
  #endif
+ 	    buf->b_p_fp = empty_option;
  #if defined(FEAT_EVAL)
  	    buf->b_p_fex = vim_strsave(p_fex);
  #endif
*** ../vim-8.0.0178/src/normal.c	2016-11-05 21:55:09.840208445 +0100
--- src/normal.c	2017-01-14 14:20:29.951540624 +0100
***************
*** 1984,1990 ****
  		op_formatexpr(oap);	/* use expression */
  	    else
  #endif
! 		if (*p_fp != NUL)
  		op_colon(oap);		/* use external command */
  	    else
  		op_format(oap, FALSE);	/* use internal function */
--- 1984,1990 ----
  		op_formatexpr(oap);	/* use expression */
  	    else
  #endif
! 		if (*p_fp != NUL || *curbuf->b_p_fp != NUL)
  		op_colon(oap);		/* use external command */
  	    else
  		op_format(oap, FALSE);	/* use internal function */
***************
*** 2197,2206 ****
      }
      else if (oap->op_type == OP_FORMAT)
      {
! 	if (*p_fp == NUL)
! 	    stuffReadbuff((char_u *)"fmt");
! 	else
  	    stuffReadbuff(p_fp);
  	stuffReadbuff((char_u *)"\n']");
      }
  
--- 2197,2208 ----
      }
      else if (oap->op_type == OP_FORMAT)
      {
! 	if (*curbuf->b_p_fp != NUL)
! 	    stuffReadbuff(curbuf->b_p_fp);
! 	else if (*p_fp != NUL)
  	    stuffReadbuff(p_fp);
+ 	else
+ 	    stuffReadbuff((char_u *)"fmt");
  	stuffReadbuff((char_u *)"\n']");
      }
  
*** ../vim-8.0.0178/runtime/doc/options.txt	2016-09-12 12:45:26.000000000 +0200
--- runtime/doc/options.txt	2017-01-14 13:18:53.102507432 +0100
***************
*** 3416,3422 ****
  
  						*'formatprg'* *'fp'*
  'formatprg' 'fp'	string (default "")
! 			global
  			{not in Vi}
  	The name of an external program that will be used to format the lines
  	selected with the |gq| operator.  The program must take the input on
--- 3417,3423 ----
  
  						*'formatprg'* *'fp'*
  'formatprg' 'fp'	string (default "")
! 			global or local to buffer |global-local|
  			{not in Vi}
  	The name of an external program that will be used to format the lines
  	selected with the |gq| operator.  The program must take the input on
*** ../vim-8.0.0178/src/testdir/test_normal.vim	2016-11-05 21:55:09.844208420 +0100
--- src/testdir/test_normal.vim	2017-01-14 14:19:36.127874117 +0100
***************
*** 224,244 ****
    " only test on non windows platform
    if has('win32')
      return
-   else
-     " uses sed to number non-empty lines
-     call writefile(['#!/bin/sh', 'sed ''/./=''|sed ''/./{', 'N', 's/\n/    /', '}'''], 'Xsed_format.sh')
-     call system('chmod +x ./Xsed_format.sh')
    endif
!   call Setup_NewWindow()
!   %d
!   call setline(1, ['a', '', 'c', '', ' ', 'd', 'e'])
    set formatprg=./Xsed_format.sh
    norm! gggqG
!   call assert_equal(['1    a', '', '3    c', '', '5     ', '6    d', '7    e'], getline(1, '$'))
    " clean up
    set formatprg=
    call delete('Xsed_format.sh')
-   bw!
  endfunc
  
  func! Test_normal07_internalfmt()
--- 224,256 ----
    " only test on non windows platform
    if has('win32')
      return
    endif
! 
!   " uses sed to number non-empty lines
!   call writefile(['#!/bin/sh', 'sed ''/./=''|sed ''/./{', 'N', 's/\n/    /', '}'''], 'Xsed_format.sh')
!   call system('chmod +x ./Xsed_format.sh')
!   let text = ['a', '', 'c', '', ' ', 'd', 'e']
!   let expected = ['1    a', '', '3    c', '', '5     ', '6    d', '7    e']
! 
!   10new
!   call setline(1, text)
    set formatprg=./Xsed_format.sh
    norm! gggqG
!   call assert_equal(expected, getline(1, '$'))
!   bw!
! 
!   10new
!   call setline(1, text)
!   set formatprg=donothing
!   setlocal formatprg=./Xsed_format.sh
!   norm! gggqG
!   call assert_equal(expected, getline(1, '$'))
!   bw!
! 
    " clean up
    set formatprg=
+   setlocal formatprg=
    call delete('Xsed_format.sh')
  endfunc
  
  func! Test_normal07_internalfmt()
***************
*** 251,257 ****
    norm! gggqG
    call assert_equal(['1    2    3', '4    5    6', '7    8    9', '10    11    '], getline(1, '$'))
    " clean up
!   set formatprg= tw=0
    bw!
  endfunc
  
--- 263,269 ----
    norm! gggqG
    call assert_equal(['1    2    3', '4    5    6', '7    8    9', '10    11    '], getline(1, '$'))
    " clean up
!   set tw=0
    bw!
  endfunc
  
*** ../vim-8.0.0178/src/version.c	2017-01-13 22:30:03.761030349 +0100
--- src/version.c	2017-01-14 14:24:26.326077820 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     179,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
270. You are subscribed to a mailing list for every piece of software
     you use.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0180
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0180
Problem:    Error E937 is used both for duplicate key in JSON and for trying
            to delete a buffer that is in use.
Solution:   Rename the JSON error to E938. (Norio Takagi, closes #1376)
Files:      src/json.c, src/testdir/test_json.vim


*** ../vim-8.0.0179/src/json.c	2017-01-11 21:50:04.884673277 +0100
--- src/json.c	2017-01-14 14:30:10.879950714 +0100
***************
*** 936,942 ****
  			&& dict_find(top_item->jd_tv.vval.v_dict,
  						 top_item->jd_key, -1) != NULL)
  		{
! 		    EMSG2(_("E937: Duplicate key in JSON: \"%s\""),
  							     top_item->jd_key);
  		    clear_tv(&top_item->jd_key_tv);
  		    clear_tv(cur_item);
--- 936,942 ----
  			&& dict_find(top_item->jd_tv.vval.v_dict,
  						 top_item->jd_key, -1) != NULL)
  		{
! 		    EMSG2(_("E938: Duplicate key in JSON: \"%s\""),
  							     top_item->jd_key);
  		    clear_tv(&top_item->jd_key_tv);
  		    clear_tv(cur_item);
*** ../vim-8.0.0179/src/testdir/test_json.vim	2017-01-11 21:50:04.884673277 +0100
--- src/testdir/test_json.vim	2017-01-14 14:30:10.879950714 +0100
***************
*** 152,158 ****
    call assert_fails('call json_decode("blah")', "E474:")
    call assert_fails('call json_decode("true blah")', "E488:")
    call assert_fails('call json_decode("<foobar>")', "E474:")
!   call assert_fails('call json_decode("{\"a\":1,\"a\":2}")', "E937:")
  
    call assert_fails('call json_decode("{")', "E474:")
    call assert_fails('call json_decode("{foobar}")', "E474:")
--- 152,158 ----
    call assert_fails('call json_decode("blah")', "E474:")
    call assert_fails('call json_decode("true blah")', "E488:")
    call assert_fails('call json_decode("<foobar>")', "E474:")
!   call assert_fails('call json_decode("{\"a\":1,\"a\":2}")', "E938:")
  
    call assert_fails('call json_decode("{")', "E474:")
    call assert_fails('call json_decode("{foobar}")', "E474:")
*** ../vim-8.0.0179/src/version.c	2017-01-14 14:28:26.964592279 +0100
--- src/version.c	2017-01-14 14:34:25.614377859 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     180,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
10E. You start counting in hex.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0181
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0181
Problem:    When 'cursorbind' and 'cursorcolumn' are both on, the column
            highlignt in non-current windows is wrong.
Solution:   Add validate_cursor(). (Masanori Misono, closes #1372)
Files:      src/move.c


*** ../vim-8.0.0180/src/move.c	2016-11-06 15:25:37.693627473 +0100
--- src/move.c	2017-01-12 22:32:01.408155308 +0100
***************
*** 2841,2846 ****
--- 2841,2850 ----
  	    restart_edit_save = restart_edit;
  	    restart_edit = TRUE;
  	    check_cursor();
+ # ifdef FEAT_SYN_HL
+ 	    if (curwin->w_p_cuc)
+ 		validate_cursor();
+ # endif
  	    restart_edit = restart_edit_save;
  # ifdef FEAT_MBYTE
  	    /* Correct cursor for multi-byte character. */
*** ../vim-8.0.0180/src/version.c	2017-01-14 14:36:03.229775080 +0100
--- src/version.c	2017-01-14 14:53:33.111310935 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     181,
  /**/

-- 
ARTHUR: This new learning amazes me, Sir Bedevere.  Explain again how sheep's
        bladders may be employed to prevent earthquakes.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0182
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0182
Problem:    When 'cursorbind' and 'cursorline' are set, but 'cursorcolumn' is
            not, then the cursor line highlighting is not updated. (Hirohito
            Higashi)
Solution:   Call redraw_later() with NOT_VALID.
Files:      src/move.c


*** ../vim-8.0.0181/src/move.c	2017-01-14 14:54:23.950998102 +0100
--- src/move.c	2017-01-14 15:47:51.319280794 +0100
***************
*** 2851,2857 ****
  	    if (has_mbyte)
  		mb_adjust_cursor();
  # endif
! 	    redraw_later(VALID);
  
  	    /* Only scroll when 'scrollbind' hasn't done this. */
  	    if (!curwin->w_p_scb)
--- 2851,2857 ----
  	    if (has_mbyte)
  		mb_adjust_cursor();
  # endif
! 	    redraw_later(curwin->w_p_cul ? NOT_VALID : VALID);
  
  	    /* Only scroll when 'scrollbind' hasn't done this. */
  	    if (!curwin->w_p_scb)
*** ../vim-8.0.0181/src/version.c	2017-01-14 14:54:23.950998102 +0100
--- src/version.c	2017-01-14 15:51:53.017795521 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     182,
  /**/

-- 
GALAHAD:   Camelot ...
LAUNCELOT: Camelot ...
GAWAIN:    It's only a model.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0183
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0183
Problem:    Ubsan warns for using a pointer that is not aligned.
Solution:   First copy the address. (Yegappan Lakshmanan)
Files:      src/channel.c


*** ../vim-8.0.0182/src/channel.c	2017-01-10 15:15:32.882134134 +0100
--- src/channel.c	2017-01-14 17:01:34.220082253 +0100
***************
*** 710,716 ****
  	channel_free(channel);
  	return NULL;
      }
!     memcpy((char *)&server.sin_addr, host->h_addr, host->h_length);
  
      /* On Mac and Solaris a zero timeout almost never works.  At least wait
       * one millisecond. Let's do it for all systems, because we don't know why
--- 710,723 ----
  	channel_free(channel);
  	return NULL;
      }
!     {
! 	char		*p;
! 
! 	/* When using host->h_addr directly ubsan warns for it to not be
! 	 * aligned.  First copy the pointer to aviod that. */
! 	memcpy(&p, &host->h_addr, sizeof(p));
! 	memcpy((char *)&server.sin_addr, p, host->h_length);
!     }
  
      /* On Mac and Solaris a zero timeout almost never works.  At least wait
       * one millisecond. Let's do it for all systems, because we don't know why
*** ../vim-8.0.0182/src/version.c	2017-01-14 15:52:42.889489220 +0100
--- src/version.c	2017-01-14 16:58:58.469042689 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     183,
  /**/

-- 
       We're knights of the round table
       We dance whene'er we're able
       We do routines and chorus scenes
       With footwork impeccable.
       We dine well here in Camelot
       We eat ham and jam and spam a lot.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0184
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0184
Problem:    When in Ex mode and an error is caught by try-catch, Vim still
            exits with a non-zero exit code.
Solution:   Don't set ex_exitval when inside a try-catch. (partly by Christian
            Brabandt)
Files:      src/message.c, src/testdir/test_system.vim


*** ../vim-8.0.0183/src/message.c	2016-12-01 15:34:04.087413921 +0100
--- src/message.c	2017-01-14 18:41:43.735026080 +0100
***************
*** 578,585 ****
  	return TRUE;
  
      called_emsg = TRUE;
-     if (emsg_silent == 0)
- 	ex_exitval = 1;
  
      /*
       * If "emsg_severe" is TRUE: When an error exception is to be thrown,
--- 578,583 ----
***************
*** 642,647 ****
--- 640,647 ----
  	    return TRUE;
  	}
  
+ 	ex_exitval = 1;
+ 
  	/* Reset msg_silent, an error causes messages to be switched back on. */
  	msg_silent = 0;
  	cmd_silent = FALSE;
*** ../vim-8.0.0183/src/testdir/test_system.vim	2017-01-08 14:14:34.732591613 +0100
--- src/testdir/test_system.vim	2017-01-14 19:15:58.686163819 +0100
***************
*** 46,48 ****
--- 46,85 ----
  
    call assert_fails('call system("wc -l", 99999)', 'E86:')
  endfunction
+ 
+ function! Test_system_exmode()
+   let cmd=" -es -u NONE -c 'source Xscript' +q; echo $?"
+   " Need to put this in a script, "catch" isn't found after an unknown
+   " function.
+   call writefile(['try', 'call doesnotexist()', 'catch', 'endtry'], 'Xscript')
+   let a = system(v:progpath . cmd)
+   call assert_equal('0', a[0])
+   call assert_equal(0, v:shell_error)
+ 
+   " Error before try does set error flag.
+   call writefile(['call nosuchfunction()', 'try', 'call doesnotexist()', 'catch', 'endtry'], 'Xscript')
+   let a = system(v:progpath . cmd)
+   call assert_notequal('0', a[0])
+ 
+   let cmd=" -es -u NONE -c 'source Xscript' +q"
+   let a = system(v:progpath . cmd)
+   call assert_notequal(0, v:shell_error)
+ 
+   let cmd=" -es -u NONE -c 'call doesnotexist()' +q; echo $?"
+   let a = system(v:progpath. cmd)
+   call assert_notequal(0, a[0])
+ 
+   let cmd=" -es -u NONE -c 'call doesnotexist()' +q"
+   let a = system(v:progpath. cmd)
+   call assert_notequal(0, v:shell_error)
+ 
+   let cmd=" -es -u NONE -c 'call doesnotexist()|let a=1' +q; echo $?"
+   let a = system(v:progpath. cmd)
+   call assert_notequal(0, a[0])
+ 
+   let cmd=" -es -u NONE -c 'call doesnotexist()|let a=1' +q"
+   let a = system(v:progpath. cmd)
+   call assert_notequal(0, v:shell_error)
+ 
+   call delete('Xscript')
+ endfunc
*** ../vim-8.0.0183/src/version.c	2017-01-14 17:04:33.950973940 +0100
--- src/version.c	2017-01-14 19:17:26.177613410 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     184,
  /**/

-- 
       We're knights of the Round Table
       Our shows are formidable
       But many times
       We're given rhymes
       That are quite unsingable
       We're opera mad in Camelot
       We sing from the diaphragm a lot.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0185
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0185 (after 8.0.0184)
Problem:    The system() test fails on MS-Windows.
Solution:   Skip the test on MS-Windows.
Files:      src/testdir/test_system.vim


*** ../vim-8.0.0184/src/testdir/test_system.vim	2017-01-14 19:24:48.654828136 +0100
--- src/testdir/test_system.vim	2017-01-14 19:37:00.270198712 +0100
***************
*** 48,53 ****
--- 48,57 ----
  endfunction
  
  function! Test_system_exmode()
+   if !has('unix')
+     return
+   endif
+ 
    let cmd=" -es -u NONE -c 'source Xscript' +q; echo $?"
    " Need to put this in a script, "catch" isn't found after an unknown
    " function.
*** ../vim-8.0.0184/src/version.c	2017-01-14 19:24:48.654828136 +0100
--- src/version.c	2017-01-14 19:37:57.389837923 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     185,
  /**/

-- 
       In war we're tough and able.
       Quite indefatigable
       Between our quests
       We sequin vests
       And impersonate Clark Gable
       It's a busy life in Camelot.
       I have to push the pram a lot.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0186
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0186
Problem:    The error message from assert_notequal() is confusing.
Solution:   Only mention the expected value.
Files:      src/eval.c, src/testdir/test_assert.vim


*** ../vim-8.0.0185/src/eval.c	2017-01-12 20:06:30.148523006 +0100
--- src/eval.c	2017-01-14 18:40:19.035549604 +0100
***************
*** 9256,9261 ****
--- 9256,9263 ----
      {
  	if (atype == ASSERT_MATCH || atype == ASSERT_NOTMATCH)
  	    ga_concat(gap, (char_u *)"Pattern ");
+ 	else if (atype == ASSERT_NOTEQUAL)
+ 	    ga_concat(gap, (char_u *)"Expected not equal to ");
  	else
  	    ga_concat(gap, (char_u *)"Expected ");
  	if (exp_str == NULL)
***************
*** 9265,9280 ****
  	}
  	else
  	    ga_concat_esc(gap, exp_str);
! 	if (atype == ASSERT_MATCH)
! 	    ga_concat(gap, (char_u *)" does not match ");
! 	else if (atype == ASSERT_NOTMATCH)
! 	    ga_concat(gap, (char_u *)" does match ");
! 	else if (atype == ASSERT_NOTEQUAL)
! 	    ga_concat(gap, (char_u *)" differs from ");
! 	else
! 	    ga_concat(gap, (char_u *)" but got ");
! 	ga_concat_esc(gap, tv2string(got_tv, &tofree, numbuf, 0));
! 	vim_free(tofree);
      }
  }
  
--- 9267,9283 ----
  	}
  	else
  	    ga_concat_esc(gap, exp_str);
! 	if (atype != ASSERT_NOTEQUAL)
! 	{
! 	    if (atype == ASSERT_MATCH)
! 		ga_concat(gap, (char_u *)" does not match ");
! 	    else if (atype == ASSERT_NOTMATCH)
! 		ga_concat(gap, (char_u *)" does match ");
! 	    else
! 		ga_concat(gap, (char_u *)" but got ");
! 	    ga_concat_esc(gap, tv2string(got_tv, &tofree, numbuf, 0));
! 	    vim_free(tofree);
! 	}
      }
  }
  
*** ../vim-8.0.0185/src/testdir/test_assert.vim	2016-12-04 13:37:38.425300719 +0100
--- src/testdir/test_assert.vim	2017-01-14 19:22:57.331531549 +0100
***************
*** 32,38 ****
    call assert_notequal([1, 2, 3], s)
  
    call assert_notequal('foo', s)
!   call assert_match("Expected 'foo' differs from 'foo'", v:errors[0])
    call remove(v:errors, 0)
  endfunc
  
--- 32,38 ----
    call assert_notequal([1, 2, 3], s)
  
    call assert_notequal('foo', s)
!   call assert_match("Expected not equal to 'foo'", v:errors[0])
    call remove(v:errors, 0)
  endfunc
  
*** ../vim-8.0.0185/src/version.c	2017-01-14 19:38:32.449616516 +0100
--- src/version.c	2017-01-14 20:05:13.187463800 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     186,
  /**/

-- 
GOD: That is your purpose Arthur ... the Quest for the Holy Grail ...
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0187
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0187
Problem:    Building with a new Ruby version fails.
Solution:   Use ruby_sysinit() instead of NtInitialize(). (Tomas Volf,
            closes #1382)
Files:      src/if_ruby.c


*** ../vim-8.0.0186/src/if_ruby.c	2017-01-09 21:10:29.300184895 +0100
--- src/if_ruby.c	2017-01-14 20:09:54.001642368 +0100
***************
*** 862,868 ****
--- 862,872 ----
  	    int argc = 1;
  	    char *argv[] = {"gvim.exe"};
  	    char **argvp = argv;
+ # ifdef RUBY19_OR_LATER
+ 	    ruby_sysinit(&argc, &argvp);
+ # else
  	    NtInitialize(&argc, &argvp);
+ # endif
  #endif
  	    {
  #if defined(RUBY19_OR_LATER) || defined(RUBY_INIT_STACK)
*** ../vim-8.0.0186/src/version.c	2017-01-14 20:06:11.127087707 +0100
--- src/version.c	2017-01-14 20:11:17.953098490 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     187,
  /**/

-- 
There is a fine line between courage and foolishness.
Unfortunately, it's not a fence.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0188
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0188 (after 8.0.0182)
Problem:    Using NOT_VALID for redraw_later() to update the cursor
            line/column highlighting is not efficient.
Solution:   Call validate_cursor() when 'cul' or 'cuc' is set.
Files:      src/move.c


*** ../vim-8.0.0187/src/move.c	2017-01-14 15:52:42.885489244 +0100
--- src/move.c	2017-01-15 13:46:37.008399578 +0100
***************
*** 2841,2857 ****
  	    restart_edit_save = restart_edit;
  	    restart_edit = TRUE;
  	    check_cursor();
! # ifdef FEAT_SYN_HL
! 	    if (curwin->w_p_cuc)
  		validate_cursor();
- # endif
  	    restart_edit = restart_edit_save;
  # ifdef FEAT_MBYTE
  	    /* Correct cursor for multi-byte character. */
  	    if (has_mbyte)
  		mb_adjust_cursor();
  # endif
! 	    redraw_later(curwin->w_p_cul ? NOT_VALID : VALID);
  
  	    /* Only scroll when 'scrollbind' hasn't done this. */
  	    if (!curwin->w_p_scb)
--- 2841,2855 ----
  	    restart_edit_save = restart_edit;
  	    restart_edit = TRUE;
  	    check_cursor();
! 	    if (curwin->w_p_cul || curwin->w_p_cuc)
  		validate_cursor();
  	    restart_edit = restart_edit_save;
  # ifdef FEAT_MBYTE
  	    /* Correct cursor for multi-byte character. */
  	    if (has_mbyte)
  		mb_adjust_cursor();
  # endif
! 	    redraw_later(VALID);
  
  	    /* Only scroll when 'scrollbind' hasn't done this. */
  	    if (!curwin->w_p_scb)
*** ../vim-8.0.0187/src/version.c	2017-01-14 20:11:57.656841373 +0100
--- src/version.c	2017-01-15 13:52:54.537967550 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     188,
  /**/

-- 
ARTHUR: Right! Knights! Forward!
   ARTHUR leads a charge toward the castle.  Various shots of them battling on,
   despite being hit by a variety of farm animals.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0189
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0189
Problem:    There are no tests for the :profile command.
Solution:   Add tests. (Dominique Pelle)
Files:      src/Makefile, src/testdir/Make_all.mak,
            src/testdir/test_profile.vim


*** ../vim-8.0.0188/src/Makefile	2017-01-10 16:12:11.736767011 +0100
--- src/Makefile	2017-01-15 15:07:50.940216456 +0100
***************
*** 2147,2152 ****
--- 2147,2153 ----
  	test_partial \
  	test_perl \
  	test_popup \
+ 	test_profile \
  	test_quickfix \
  	test_regexp_latin \
  	test_regexp_utf8 \
*** ../vim-8.0.0188/src/testdir/Make_all.mak	2017-01-13 22:30:03.761030349 +0100
--- src/testdir/Make_all.mak	2017-01-15 15:06:28.532766499 +0100
***************
*** 175,180 ****
--- 175,181 ----
  	    test_normal.res \
  	    test_packadd.res \
  	    test_perl.res \
+ 	    test_profile.res \
  	    test_quickfix.res \
  	    test_ruby.res \
  	    test_search.res \
*** ../vim-8.0.0188/src/testdir/test_profile.vim	2017-01-15 15:21:14.646863439 +0100
--- src/testdir/test_profile.vim	2017-01-15 15:17:49.308229678 +0100
***************
*** 0 ****
--- 1,135 ----
+ " Test Vim profiler
+ if !has('profile')
+   finish
+ endif
+ 
+ func Test_profile_func()
+   if !has('unix')
+     return
+   endif
+   let lines = [
+     \ "func! Foo1()",
+     \ "endfunc",
+     \ "func! Foo2()",
+     \ "  let count = 100",
+     \ "  while count > 0",
+     \ "    let count = count - 1",
+     \ "  endwhile",
+     \ "endfunc",
+     \ "func! Foo3()",
+     \ "endfunc",
+     \ "func! Bar()",
+     \ "endfunc",
+     \ "call Foo1()",
+     \ "call Foo1()",
+     \ "profile pause",
+     \ "call Foo1()",
+     \ "profile continue",
+     \ "call Foo2()",
+     \ "call Foo3()",
+     \ "call Bar()",
+     \ "if !v:profiling",
+     \ "  delfunc Foo2",
+     \ "endif",
+     \ "delfunc Foo3",
+     \ ]
+ 
+   call writefile(lines, 'Xprofile_func.vim')
+   let a = system(v:progpath
+     \ . " -u NONE -i NONE --noplugin"
+     \ . " -c 'profile start Xprofile_func.log'"
+     \ . " -c 'profile func Foo*'"
+     \ . " -c 'so Xprofile_func.vim'"
+     \ . " -c 'qall!'")
+   let lines = readfile('Xprofile_func.log')
+ 
+   call assert_equal(28, len(lines))
+ 
+   call assert_equal('FUNCTION  Foo1()', lines[0])
+   call assert_equal('Called 2 times',   lines[1])
+   call assert_equal('FUNCTION  Foo2()', lines[7])
+   call assert_equal('Called 1 time',    lines[8])
+ 
+   " - Foo1() is called 3 times but should be reported as called twice
+   "   since one call is in between "profile pause" .. "profile continue".
+   " - Foo2() should come before Foo1() since Foo1() does much more work.\
+   " - Foo3() is not reported because function is deleted.
+   " - Unlike Foo3(), Foo2() should not be deleted since there is a check
+   "   for v:profiling.
+   " - Bar() is not reported since it does not match "profile func Foo*".
+   call assert_equal('FUNCTIONS SORTED ON TOTAL TIME',        lines[18])
+   call assert_equal('count  total (s)   self (s)  function', lines[19])
+   call assert_match('^\s*1\s\+\d\+\.\d\+\s\+Foo2()$',        lines[20])
+   call assert_match('^\s*2\s\+\d\+\.\d\+\s\+Foo1()$',        lines[21])
+   call assert_equal('',                                      lines[22])
+   call assert_equal('FUNCTIONS SORTED ON SELF TIME',         lines[23])
+   call assert_equal('count  total (s)   self (s)  function', lines[24])
+   call assert_match('^\s*1\s\+\d\+\.\d\+\s\+Foo2()$',        lines[25])
+   call assert_match('^\s*2\s\+\d\+\.\d\+\s\+Foo1()$',        lines[26])
+   call assert_equal('',                                      lines[27])
+ 
+   call delete('Xprofile_func.vim')
+   call delete('Xprofile_func.log')
+ endfunc
+ 
+ func Test_profile_file()
+   if !has('unix')
+     return
+   endif
+   let lines = [
+     \ 'func! Foo()',
+     \ 'endfunc',
+     \ 'for i in range(10)',
+     \ '  " a comment',
+     \ '  call Foo()',
+     \ 'endfor',
+     \ 'call Foo()',
+     \ ]
+ 
+   call writefile(lines, 'Xprofile_file.vim')
+   let a = system(v:progpath
+     \ . " -u NONE -i NONE --noplugin"
+     \ . " -c 'profile start Xprofile_file.log'"
+     \ . " -c 'profile file Xprofile_file.vim'"
+     \ . " -c 'so Xprofile_file.vim'"
+     \ . " -c 'so Xprofile_file.vim'"
+     \ . " -c 'qall!'")
+ 
+   let lines = readfile('Xprofile_file.log')
+ 
+   call assert_equal(14, len(lines))
+ 
+   call assert_match('^SCRIPT .*Xprofile_file.vim$',                   lines[0])
+   call assert_equal('Sourced 2 times',                                lines[1])
+   call assert_match('^Total time:\s\+\d\+\.\d\+$',                    lines[2])
+   call assert_match('^ Self time:\s\+\d\+\.\d\+$',                    lines[3])
+   call assert_equal('',                                               lines[4])
+   call assert_equal('count  total (s)   self (s)',                    lines[5])
+   call assert_equal('                            func! Foo()',        lines[6])
+   call assert_equal('                            endfunc',            lines[7])
+   " Loop iterates 10 times. Since script runs twice, body executes 20 times.
+   " First line of loop executes one more time than body to detect end of loop.
+   call assert_match('^\s*22\s\+\d\+\.\d\+\s\+for i in range(10)$',    lines[8])
+   call assert_equal('                              " a comment',      lines[9])
+   call assert_match('^\s*20\s\+\d\+\.\d\+\s\+\d\+\.\d\+\s\+call Foo()$', lines[10])
+   call assert_match('^\s*20\s\+\d\+\.\d\+\s\+endfor$',                lines[11])
+   call assert_match('^\s*2\s\+\d\+\.\d\+\s\+\d\+\.\d\+\s\+call Foo()$', lines[12])
+   call assert_equal('',                                               lines[13])
+ 
+   call delete('Xprofile_file.vim')
+   call delete('Xprofile_file.log')
+ endfunc
+ 
+ func Test_profile_completion()
+   call feedkeys(":profile \<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"profile continue file func pause start', @:)
+ 
+   call feedkeys(":profile start test_prof\<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_match('^"profile start.* test_profile\.vim', @:)
+ endfunc
+ 
+ func Test_profile_errors()
+   call assert_fails("profile func Foo", 'E750:')
+   call assert_fails("profile pause", 'E750:')
+   call assert_fails("profile continue", 'E750:')
+ endfunc
*** ../vim-8.0.0188/src/version.c	2017-01-15 13:53:45.925629742 +0100
--- src/version.c	2017-01-15 15:07:24.180395041 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     189,
  /**/

-- 
Error:015 - Unable to exit Windows.  Try the door.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0190
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0190
Problem:    Detecting duplicate tags uses a slow linear search.
Solution:   Use a much faster hash table solution. (James McCoy, closes #1046)
            But don't add hi_keylen, it makes hash tables 50% bigger.
Files:      src/tag.c


*** ../vim-8.0.0189/src/tag.c	2016-12-01 21:32:28.678025257 +0100
--- src/tag.c	2017-01-15 16:47:11.816668598 +0100
***************
*** 35,43 ****
  } tagptrs_T;
  
  /*
!  * The matching tags are first stored in ga_match[].  In which one depends on
!  * the priority of the match.
!  * At the end, the matches from ga_match[] are concatenated, to make a list
   * sorted on priority.
   */
  #define MT_ST_CUR	0		/* static match in current file */
--- 35,43 ----
  } tagptrs_T;
  
  /*
!  * The matching tags are first stored in one of the ht_match[] hash tables.  In
!  * which one depends on the priority of the match.
!  * At the end, all the matches from ht_match[] are concatenated, to make a list
   * sorted on priority.
   */
  #define MT_ST_CUR	0		/* static match in current file */
***************
*** 1341,1352 ****
      int		is_etag;		/* current file is emaces style */
  #endif
  
!     struct match_found
!     {
! 	int	len;		/* nr of chars of match[] to be compared */
! 	char_u	match[1];	/* actually longer */
!     } *mfp, *mfp2;
!     garray_T	ga_match[MT_COUNT];
      int		match_count = 0;		/* number of matches found */
      char_u	**matches;
      int		mtt;
--- 1341,1349 ----
      int		is_etag;		/* current file is emaces style */
  #endif
  
!     char_u	*mfp;
!     hashtab_T	ht_match[MT_COUNT];
!     hash_T	hash = 0;
      int		match_count = 0;		/* number of matches found */
      char_u	**matches;
      int		mtt;
***************
*** 1402,1417 ****
      vimconv.vc_type = CONV_NONE;
  #endif
  
! /*
!  * Allocate memory for the buffers that are used
!  */
      lbuf = alloc(lbuf_size);
      tag_fname = alloc(MAXPATHL + 1);
  #ifdef FEAT_EMACS_TAGS
      ebuf = alloc(LSIZE);
  #endif
      for (mtt = 0; mtt < MT_COUNT; ++mtt)
! 	ga_init2(&ga_match[mtt], (int)sizeof(struct match_found *), 100);
  
      /* check for out of memory situation */
      if (lbuf == NULL || tag_fname == NULL
--- 1399,1414 ----
      vimconv.vc_type = CONV_NONE;
  #endif
  
!     /*
!      * Allocate memory for the buffers that are used
!      */
      lbuf = alloc(lbuf_size);
      tag_fname = alloc(MAXPATHL + 1);
  #ifdef FEAT_EMACS_TAGS
      ebuf = alloc(LSIZE);
  #endif
      for (mtt = 0; mtt < MT_COUNT; ++mtt)
! 	hash_init(&ht_match[mtt]);
  
      /* check for out of memory situation */
      if (lbuf == NULL || tag_fname == NULL
***************
*** 2206,2215 ****
  	    }
  
  	    /*
! 	     * If a match is found, add it to ga_match[].
  	     */
  	    if (match)
  	    {
  #ifdef FEAT_CSCOPE
  		if (use_cscope)
  		{
--- 2203,2214 ----
  	    }
  
  	    /*
! 	     * If a match is found, add it to ht_match[].
  	     */
  	    if (match)
  	    {
+ 		int len = 0;
+ 
  #ifdef FEAT_CSCOPE
  		if (use_cscope)
  		{
***************
*** 2262,2440 ****
  		}
  
  		/*
! 		 * Add the found match in ga_match[mtt], avoiding duplicates.
  		 * Store the info we need later, which depends on the kind of
  		 * tags we are dealing with.
  		 */
! 		if (ga_grow(&ga_match[mtt], 1) == OK)
  		{
- 		    int len;
- 		    int heuristic;
- 
- 		    if (help_only)
- 		    {
  #ifdef FEAT_MULTI_LANG
  # define ML_EXTRA 3
  #else
  # define ML_EXTRA 0
  #endif
! 			/*
! 			 * Append the help-heuristic number after the
! 			 * tagname, for sorting it later.
! 			 */
! 			*tagp.tagname_end = NUL;
! 			len = (int)(tagp.tagname_end - tagp.tagname);
! 			mfp = (struct match_found *)
! 				 alloc((int)sizeof(struct match_found) + len
! 							     + 10 + ML_EXTRA);
! 			if (mfp != NULL)
! 			{
! 			    /* "len" includes the language and the NUL, but
! 			     * not the priority. */
! 			    mfp->len = len + ML_EXTRA + 1;
! #define ML_HELP_LEN 6
! 			    p = mfp->match;
! 			    STRCPY(p, tagp.tagname);
  #ifdef FEAT_MULTI_LANG
! 			    p[len] = '@';
! 			    STRCPY(p + len + 1, help_lang);
  #endif
  
! 			    heuristic = help_heuristic(tagp.tagname,
! 					match_re ? matchoff : 0, !match_no_ic);
  #ifdef FEAT_MULTI_LANG
! 			    heuristic += help_pri;
  #endif
! 			    sprintf((char *)p + len + 1 + ML_EXTRA, "%06d",
! 								   heuristic);
! 			}
! 			*tagp.tagname_end = TAB;
  		    }
! 		    else if (name_only)
  		    {
! 			if (get_it_again)
! 			{
! 			    char_u *temp_end = tagp.command;
  
! 			    if (*temp_end == '/')
! 				while (*temp_end && *temp_end != '\r'
! 					&& *temp_end != '\n'
! 					&& *temp_end != '$')
! 				    temp_end++;
  
! 			    if (tagp.command + 2 < temp_end)
! 			    {
! 				len = (int)(temp_end - tagp.command - 2);
! 				mfp = (struct match_found *)alloc(
! 					(int)sizeof(struct match_found) + len);
! 				if (mfp != NULL)
! 				{
! 				    mfp->len = len + 1; /* include the NUL */
! 				    p = mfp->match;
! 				    vim_strncpy(p, tagp.command + 2, len);
! 				}
! 			    }
! 			    else
! 				mfp = NULL;
! 			    get_it_again = FALSE;
! 			}
! 			else
  			{
! 			    len = (int)(tagp.tagname_end - tagp.tagname);
! 			    mfp = (struct match_found *)alloc(
! 				       (int)sizeof(struct match_found) + len);
  			    if (mfp != NULL)
! 			    {
! 				mfp->len = len + 1; /* include the NUL */
! 				p = mfp->match;
! 				vim_strncpy(p, tagp.tagname, len);
! 			    }
! 
! 			    /* if wanted, re-read line to get long form too */
! 			    if (State & INSERT)
! 				get_it_again = p_sft;
  			}
  		    }
  		    else
  		    {
! 			/* Save the tag in a buffer.
! 			 * Emacs tag: <mtt><tag_fname><NUL><ebuf><NUL><lbuf>
! 			 * other tag: <mtt><tag_fname><NUL><NUL><lbuf>
! 			 * without Emacs tags: <mtt><tag_fname><NUL><lbuf>
! 			 */
! 			len = (int)STRLEN(tag_fname)
! 						 + (int)STRLEN(lbuf) + 3;
  #ifdef FEAT_EMACS_TAGS
! 			if (is_etag)
! 			    len += (int)STRLEN(ebuf) + 1;
! 			else
! 			    ++len;
  #endif
! 			mfp = (struct match_found *)alloc(
! 				       (int)sizeof(struct match_found) + len);
! 			if (mfp != NULL)
! 			{
! 			    mfp->len = len;
! 			    p = mfp->match;
! 			    p[0] = mtt;
! 			    STRCPY(p + 1, tag_fname);
  #ifdef BACKSLASH_IN_FILENAME
! 			    /* Ignore differences in slashes, avoid adding
! 			     * both path/file and path\file. */
! 			    slash_adjust(p + 1);
  #endif
! 			    s = p + 1 + STRLEN(tag_fname) + 1;
  #ifdef FEAT_EMACS_TAGS
! 			    if (is_etag)
! 			    {
! 				STRCPY(s, ebuf);
! 				s += STRLEN(ebuf) + 1;
! 			    }
! 			    else
! 				*s++ = NUL;
! #endif
! 			    STRCPY(s, lbuf);
  			}
  		    }
  
! 		    if (mfp != NULL)
! 		    {
! 			/*
! 			 * Don't add identical matches.
! 			 * This can take a lot of time when finding many
! 			 * matches, check for CTRL-C now and then.
! 			 * Add all cscope tags, because they are all listed.
! 			 */
  #ifdef FEAT_CSCOPE
! 			if (use_cscope)
! 			    i = -1;
! 			else
  #endif
! 			  for (i = ga_match[mtt].ga_len; --i >= 0 && !got_int; )
! 			  {
! 			      mfp2 = ((struct match_found **)
! 						  (ga_match[mtt].ga_data))[i];
! 			      if (mfp2->len == mfp->len
! 				      && memcmp(mfp2->match, mfp->match,
! 						       (size_t)mfp->len) == 0)
! 				  break;
! 			      fast_breakcheck();
! 			  }
! 			if (i < 0)
  			{
! 			    ((struct match_found **)(ga_match[mtt].ga_data))
! 					       [ga_match[mtt].ga_len++] = mfp;
! 			    ++match_count;
  			}
  			else
! 			    vim_free(mfp);
  		    }
! 		}
! 		else    /* Out of memory! Just forget about the rest. */
! 		{
! 		    retval = OK;
! 		    stop_searching = TRUE;
! 		    break;
  		}
  	    }
  #ifdef FEAT_CSCOPE
--- 2261,2429 ----
  		}
  
  		/*
! 		 * Add the found match in ht_match[mtt].
  		 * Store the info we need later, which depends on the kind of
  		 * tags we are dealing with.
  		 */
! 		if (help_only)
  		{
  #ifdef FEAT_MULTI_LANG
  # define ML_EXTRA 3
  #else
  # define ML_EXTRA 0
  #endif
! 		    /*
! 		     * Append the help-heuristic number after the tagname, for
! 		     * sorting it later.  The heuristic is ignored for
! 		     * detecting duplicates.
! 		     * The format is {tagname}@{lang}NUL{heuristic}NUL
! 		     */
! 		    *tagp.tagname_end = NUL;
! 		    len = (int)(tagp.tagname_end - tagp.tagname);
! 		    mfp = (char_u *)alloc((int)sizeof(char_u) + len + 10 + ML_EXTRA + 1);
! 		    if (mfp != NULL)
! 		    {
! 			int heuristic;
! 
! 			p = mfp;
! 			STRCPY(p, tagp.tagname);
  #ifdef FEAT_MULTI_LANG
! 			p[len] = '@';
! 			STRCPY(p + len + 1, help_lang);
  #endif
  
! 			heuristic = help_heuristic(tagp.tagname,
! 				    match_re ? matchoff : 0, !match_no_ic);
  #ifdef FEAT_MULTI_LANG
! 			heuristic += help_pri;
  #endif
! 			sprintf((char *)p + len + 1 + ML_EXTRA, "%06d",
! 							       heuristic);
  		    }
! 		    *tagp.tagname_end = TAB;
! 		}
! 		else if (name_only)
! 		{
! 		    if (get_it_again)
  		    {
! 			char_u *temp_end = tagp.command;
  
! 			if (*temp_end == '/')
! 			    while (*temp_end && *temp_end != '\r'
! 				    && *temp_end != '\n'
! 				    && *temp_end != '$')
! 				temp_end++;
  
! 			if (tagp.command + 2 < temp_end)
  			{
! 			    len = (int)(temp_end - tagp.command - 2);
! 			    mfp = (char_u *)alloc((int)sizeof(char_u) + len + 1);
  			    if (mfp != NULL)
! 				vim_strncpy(mfp, tagp.command + 2, len);
  			}
+ 			else
+ 			    mfp = NULL;
+ 			get_it_again = FALSE;
  		    }
  		    else
  		    {
! 			len = (int)(tagp.tagname_end - tagp.tagname);
! 			mfp = (char_u *)alloc((int)sizeof(char_u) + len + 1);
! 			if (mfp != NULL)
! 			    vim_strncpy(mfp, tagp.tagname, len);
! 
! 			/* if wanted, re-read line to get long form too */
! 			if (State & INSERT)
! 			    get_it_again = p_sft;
! 		    }
! 		}
! 		else
! 		{
! #define TAG_SEP 0x01
! 		    size_t tag_fname_len = STRLEN(tag_fname);
  #ifdef FEAT_EMACS_TAGS
! 		    size_t ebuf_len = 0;
  #endif
! 
! 		    /* Save the tag in a buffer.
! 		     * Use 0x01 to separate fields (Can't use NUL, because the
! 		     * hash key is terminated by NUL).
! 		     * Emacs tag: <mtt><tag_fname><0x01><ebuf><0x01><lbuf><NUL>
! 		     * other tag: <mtt><tag_fname><0x01><0x01><lbuf><NUL>
! 		     * without Emacs tags: <mtt><tag_fname><0x01><lbuf><NUL>
! 		     */
! 		    len = (int)tag_fname_len + (int)STRLEN(lbuf) + 3;
! #ifdef FEAT_EMACS_TAGS
! 		    if (is_etag)
! 		    {
! 			ebuf_len = STRLEN(ebuf);
! 			len += (int)ebuf_len + 1;
! 		    }
! 		    else
! 			++len;
! #endif
! 		    mfp = (char_u *)alloc((int)sizeof(char_u) + len + 1);
! 		    if (mfp != NULL)
! 		    {
! 			p = mfp;
! 			p[0] = mtt;
! 			STRCPY(p + 1, tag_fname);
  #ifdef BACKSLASH_IN_FILENAME
! 			/* Ignore differences in slashes, avoid adding
! 			 * both path/file and path\file. */
! 			slash_adjust(p + 1);
  #endif
! 			p[tag_fname_len + 1] = TAG_SEP;
! 			s = p + 1 + tag_fname_len + 1;
  #ifdef FEAT_EMACS_TAGS
! 			if (is_etag)
! 			{
! 			    STRCPY(s, ebuf);
! 			    s[ebuf_len] = TAG_SEP;
! 			    s += ebuf_len + 1;
  			}
+ 			else
+ 			    *s++ = TAG_SEP;
+ #endif
+ 			STRCPY(s, lbuf);
  		    }
+ 		}
  
! 		if (mfp != NULL)
! 		{
! 		    hashitem_T	*hi;
! 
! 		    /*
! 		     * Don't add identical matches.
! 		     * Add all cscope tags, because they are all listed.
! 		     * "mfp" is used as a hash key, there is a NUL byte to end
! 		     * the part matters for comparing, more bytes may follow
! 		     * after it.  E.g. help tags store the priority after the
! 		     * NUL.
! 		     */
  #ifdef FEAT_CSCOPE
! 		    if (use_cscope)
! 			hash++;
! 		    else
  #endif
! 			hash = hash_hash(mfp);
! 		    hi = hash_lookup(&ht_match[mtt], mfp, hash);
! 		    if (HASHITEM_EMPTY(hi))
! 		    {
! 			if (hash_add_item(&ht_match[mtt], hi, mfp, hash)
! 								       == FAIL)
  			{
! 			    /* Out of memory! Just forget about the rest. */
! 			    retval = OK;
! 			    stop_searching = TRUE;
! 			    break;
  			}
  			else
! 			    ++match_count;
  		    }
! 		    else
! 			/* duplicate tag, drop it */
! 			vim_free(mfp);
  		}
  	    }
  #ifdef FEAT_CSCOPE
***************
*** 2532,2538 ****
  #endif
  
      /*
!      * Move the matches from the ga_match[] arrays into one list of
       * matches.  When retval == FAIL, free the matches.
       */
      if (retval == FAIL)
--- 2521,2527 ----
  #endif
  
      /*
!      * Move the matches from the ht_match[] arrays into one list of
       * matches.  When retval == FAIL, free the matches.
       */
      if (retval == FAIL)
***************
*** 2546,2567 ****
      match_count = 0;
      for (mtt = 0; mtt < MT_COUNT; ++mtt)
      {
! 	for (i = 0; i < ga_match[mtt].ga_len; ++i)
  	{
! 	    mfp = ((struct match_found **)(ga_match[mtt].ga_data))[i];
! 	    if (matches == NULL)
! 		vim_free(mfp);
! 	    else
  	    {
! 		/* To avoid allocating memory again we turn the struct
! 		 * match_found into a string.  For help the priority was not
! 		 * included in the length. */
! 		mch_memmove(mfp, mfp->match,
! 			 (size_t)(mfp->len + (help_only ? ML_HELP_LEN : 0)));
! 		matches[match_count++] = (char_u *)mfp;
  	    }
  	}
! 	ga_clear(&ga_match[mtt]);
      }
  
      *matchesp = matches;
--- 2535,2563 ----
      match_count = 0;
      for (mtt = 0; mtt < MT_COUNT; ++mtt)
      {
! 	hashitem_T	*hi;
! 	long_u		todo;
! 
! 	todo = (long)ht_match[mtt].ht_used;
! 	for (hi = ht_match[mtt].ht_array; todo > 0; ++hi)
  	{
! 	    if (!HASHITEM_EMPTY(hi))
  	    {
! 		mfp = hi->hi_key;
! 		if (matches == NULL)
! 		    vim_free(mfp);
! 		else
! 		{
! 		    /* now change the TAG_SEP back to NUL */
! 		    for (p = mfp; *p != NUL; ++p)
! 			if (*p == TAG_SEP)
! 			    *p = NUL;
! 		    matches[match_count++] = (char_u *)mfp;
! 		}
! 		todo--;
  	    }
  	}
! 	hash_clear(&ht_match[mtt]);
      }
  
      *matchesp = matches;
*** ../vim-8.0.0189/src/version.c	2017-01-15 15:22:14.162467173 +0100
--- src/version.c	2017-01-15 15:51:01.027012795 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     190,
  /**/

-- 
This is an airconditioned room, do not open Windows.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0191
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0191 (after 8.0.0187)
Problem:    Some systems do not have ruby_sysinit(), causing the build to
            fail.
Solution:   Clean up how ruby_sysinit() and NtInitialize() are used. (Taro
            Muraoka)
Files:      src/if_ruby.c


*** ../vim-8.0.0190/src/if_ruby.c	2017-01-14 20:11:57.656841373 +0100
--- src/if_ruby.c	2017-01-15 16:58:20.360324838 +0100
***************
*** 303,308 ****
--- 303,309 ----
  # define ruby_init_loadpath		dll_ruby_init_loadpath
  # ifdef WIN3264
  #  define NtInitialize			dll_NtInitialize
+ #  define ruby_sysinit			dll_ruby_sysinit
  #  if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
  #   define rb_w32_snprintf		dll_rb_w32_snprintf
  #  endif
***************
*** 405,410 ****
--- 406,412 ----
  static void (*dll_ruby_init_loadpath) (void);
  # ifdef WIN3264
  static void (*dll_NtInitialize) (int*, char***);
+ static void (*dll_ruby_sysinit) (int*, char***);
  #  if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
  static int (*dll_rb_w32_snprintf)(char*, size_t, const char*, ...);
  #  endif
***************
*** 594,606 ****
      {"ruby_init", (RUBY_PROC*)&dll_ruby_init},
      {"ruby_init_loadpath", (RUBY_PROC*)&dll_ruby_init_loadpath},
  # ifdef WIN3264
-     {
  #  if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER < 19
!     "NtInitialize",
  #  else
!     "ruby_sysinit",
  #  endif
- 			(RUBY_PROC*)&dll_NtInitialize},
  #  if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
      {"rb_w32_snprintf", (RUBY_PROC*)&dll_rb_w32_snprintf},
  #  endif
--- 596,606 ----
      {"ruby_init", (RUBY_PROC*)&dll_ruby_init},
      {"ruby_init_loadpath", (RUBY_PROC*)&dll_ruby_init_loadpath},
  # ifdef WIN3264
  #  if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER < 19
!     {"NtInitialize", (RUBY_PROC*)&dll_NtInitialize},
  #  else
!     {"ruby_sysinit", (RUBY_PROC*)&dll_ruby_sysinit},
  #  endif
  #  if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
      {"rb_w32_snprintf", (RUBY_PROC*)&dll_rb_w32_snprintf},
  #  endif
*** ../vim-8.0.0190/src/version.c	2017-01-15 16:52:47.226488764 +0100
--- src/version.c	2017-01-15 16:57:29.060658203 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     191,
  /**/

-- 
The software said it requires Windows 95 or better, so I installed Linux.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0192
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0192 (after 8.0.0190)
Problem:    Build fails with tiny features.
Solution:   Change #ifdef for hash_clear().  Avoid warning for unused
            argument.
Files:      src/hashtab.c, src/if_cscope.c


*** ../vim-8.0.0191/src/hashtab.c	2016-11-10 20:01:41.193582919 +0100
--- src/hashtab.c	2017-01-15 17:16:08.469346807 +0100
***************
*** 70,76 ****
      ht->ht_mask = HT_INIT_SIZE - 1;
  }
  
- #if defined(FEAT_EVAL) || defined(FEAT_SYN_HL) || defined(PROTO)
  /*
   * Free the array of a hash table.  Does not free the items it contains!
   * If "ht" is not freed then you should call hash_init() next!
--- 70,75 ----
***************
*** 104,110 ****
      }
      hash_clear(ht);
  }
- #endif
  
  /*
   * Find "key" in hashtable "ht".  "key" must not be NULL.
--- 103,108 ----
*** ../vim-8.0.0191/src/if_cscope.c	2016-11-12 19:16:42.212999914 +0100
--- src/if_cscope.c	2017-01-15 17:15:36.341557334 +0100
***************
*** 207,213 ****
      static void
  do_cscope_general(
      exarg_T	*eap,
!     int		make_split) /* whether to split window */
  {
      cscmd_T *cmdp;
  
--- 207,213 ----
      static void
  do_cscope_general(
      exarg_T	*eap,
!     int		make_split UNUSED) /* whether to split window */
  {
      cscmd_T *cmdp;
  
*** ../vim-8.0.0191/src/version.c	2017-01-15 16:58:59.448070798 +0100
--- src/version.c	2017-01-15 17:18:23.808459896 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     192,
  /**/

-- 
       He was not in the least bit scared to be mashed into a pulp
       Or to have his eyes gouged out and his elbows broken;
       To have his kneecaps split and his body burned away
       And his limbs all hacked and mangled, brave Sir Robin.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0193
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0193 (after 8.0.0188)
Problem:    Accidentally removed #ifdef.
Solution:   Put it back. (Masanori Misono)
Files:      src/move.c


*** ../vim-8.0.0192/src/move.c	2017-01-15 13:53:45.925629742 +0100
--- src/move.c	2017-01-15 20:46:42.434846318 +0100
***************
*** 2841,2848 ****
--- 2841,2850 ----
  	    restart_edit_save = restart_edit;
  	    restart_edit = TRUE;
  	    check_cursor();
+ # ifdef FEAT_SYN_HL
  	    if (curwin->w_p_cul || curwin->w_p_cuc)
  		validate_cursor();
+ # endif
  	    restart_edit = restart_edit_save;
  # ifdef FEAT_MBYTE
  	    /* Correct cursor for multi-byte character. */
*** ../vim-8.0.0192/src/version.c	2017-01-15 17:18:52.684270653 +0100
--- src/version.c	2017-01-15 20:51:01.077174883 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     193,
  /**/

-- 
FIRST HEAD:  Oh! quick! get the sword out I want to cut his head off.
THIRD HEAD:  Oh, cut your own head off.
SECOND HEAD: Yes - do us all a favour.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0194
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0194 (after 8.0.0189)
Problem:    Profile tests fails if total and self time are equal.
Solution:   Make one time optional.
Files:      src/testdir/test_profile.vim


*** ../vim-8.0.0193/src/testdir/test_profile.vim	2017-01-15 15:22:14.162467173 +0100
--- src/testdir/test_profile.vim	2017-01-15 21:09:52.377847944 +0100
***************
*** 113,119 ****
    call assert_equal('                              " a comment',      lines[9])
    call assert_match('^\s*20\s\+\d\+\.\d\+\s\+\d\+\.\d\+\s\+call Foo()$', lines[10])
    call assert_match('^\s*20\s\+\d\+\.\d\+\s\+endfor$',                lines[11])
!   call assert_match('^\s*2\s\+\d\+\.\d\+\s\+\d\+\.\d\+\s\+call Foo()$', lines[12])
    call assert_equal('',                                               lines[13])
  
    call delete('Xprofile_file.vim')
--- 113,120 ----
    call assert_equal('                              " a comment',      lines[9])
    call assert_match('^\s*20\s\+\d\+\.\d\+\s\+\d\+\.\d\+\s\+call Foo()$', lines[10])
    call assert_match('^\s*20\s\+\d\+\.\d\+\s\+endfor$',                lines[11])
!   " if self and total are equal we only get one number
!   call assert_match('^\s*2\s\+\(\d\+\.\d\+\s\+\)\=\d\+\.\d\+\s\+call Foo()$', lines[12])
    call assert_equal('',                                               lines[13])
  
    call delete('Xprofile_file.vim')
*** ../vim-8.0.0193/src/version.c	2017-01-15 20:51:33.904962652 +0100
--- src/version.c	2017-01-15 21:11:04.745378587 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     194,
  /**/

-- 
Life would be so much easier if we could just look at the source code.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0195
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0195 (after 8.0.0190)
Problem:    Jumping to a tag that is a static item in the current file fails.
            (Kazunobu Kuriyama)
Solution:   Make sure the first byte of the tag key is not NUL. (Suggested by
            James McCoy, closes #1387)
Files:      src/tag.c, src/testdir/test_tagjump.vim


*** ../vim-8.0.0194/src/tag.c	2017-01-15 16:52:47.226488764 +0100
--- src/tag.c	2017-01-16 20:47:10.965107866 +0100
***************
*** 44,53 ****
  #define MT_GL_CUR	1		/* global match in current file */
  #define MT_GL_OTH	2		/* global match in other file */
  #define MT_ST_OTH	3		/* static match in other file */
- #define MT_IC_ST_CUR	4		/* icase static match in current file */
- #define MT_IC_GL_CUR	5		/* icase global match in current file */
- #define MT_IC_GL_OTH	6		/* icase global match in other file */
- #define MT_IC_ST_OTH	7		/* icase static match in other file */
  #define MT_IC_OFF	4		/* add for icase match */
  #define MT_RE_OFF	8		/* add for regexp match */
  #define MT_MASK		7		/* mask for printing priority */
--- 44,49 ----
***************
*** 2317,2323 ****
  			if (tagp.command + 2 < temp_end)
  			{
  			    len = (int)(temp_end - tagp.command - 2);
! 			    mfp = (char_u *)alloc((int)sizeof(char_u) + len + 1);
  			    if (mfp != NULL)
  				vim_strncpy(mfp, tagp.command + 2, len);
  			}
--- 2313,2319 ----
  			if (tagp.command + 2 < temp_end)
  			{
  			    len = (int)(temp_end - tagp.command - 2);
! 			    mfp = (char_u *)alloc(len + 2);
  			    if (mfp != NULL)
  				vim_strncpy(mfp, tagp.command + 2, len);
  			}
***************
*** 2351,2356 ****
--- 2347,2353 ----
  		     * Emacs tag: <mtt><tag_fname><0x01><ebuf><0x01><lbuf><NUL>
  		     * other tag: <mtt><tag_fname><0x01><0x01><lbuf><NUL>
  		     * without Emacs tags: <mtt><tag_fname><0x01><lbuf><NUL>
+ 		     * Here <mtt> is the "mtt" value plus 1 to avoid NUL.
  		     */
  		    len = (int)tag_fname_len + (int)STRLEN(lbuf) + 3;
  #ifdef FEAT_EMACS_TAGS
***************
*** 2366,2372 ****
  		    if (mfp != NULL)
  		    {
  			p = mfp;
! 			p[0] = mtt;
  			STRCPY(p + 1, tag_fname);
  #ifdef BACKSLASH_IN_FILENAME
  			/* Ignore differences in slashes, avoid adding
--- 2363,2369 ----
  		    if (mfp != NULL)
  		    {
  			p = mfp;
! 			p[0] = mtt + 1;
  			STRCPY(p + 1, tag_fname);
  #ifdef BACKSLASH_IN_FILENAME
  			/* Ignore differences in slashes, avoid adding
***************
*** 2548,2557 ****
  		    vim_free(mfp);
  		else
  		{
! 		    /* now change the TAG_SEP back to NUL */
! 		    for (p = mfp; *p != NUL; ++p)
! 			if (*p == TAG_SEP)
! 			    *p = NUL;
  		    matches[match_count++] = (char_u *)mfp;
  		}
  		todo--;
--- 2545,2560 ----
  		    vim_free(mfp);
  		else
  		{
! 		    if (!name_only)
! 		    {
! 			/* Change mtt back to zero-based. */
! 			*mfp = *mfp - 1;
! 
! 			/* change the TAG_SEP back to NUL */
! 			for (p = mfp + 1; *p != NUL; ++p)
! 			    if (*p == TAG_SEP)
! 				*p = NUL;
! 		    }
  		    matches[match_count++] = (char_u *)mfp;
  		}
  		todo--;
*** ../vim-8.0.0194/src/testdir/test_tagjump.vim	2016-09-07 20:37:01.000000000 +0200
--- src/testdir/test_tagjump.vim	2017-01-16 20:42:11.919082134 +0100
***************
*** 23,28 ****
--- 23,46 ----
    quit
  endfunc
  
+ func Test_static_tagjump()
+   set tags=Xtags
+   call writefile(["!_TAG_FILE_ENCODING\tutf-8\t//",
+         \ "one\tXfile1\t/^one/;\"\tf\tfile:\tsignature:(void)",
+         \ "word\tXfile2\tcmd2"],
+         \ 'Xtags')
+   new Xfile1
+   call setline(1, ['empty', 'one()', 'empty'])
+   write
+   tag one
+   call assert_equal(2, line('.'))
+ 
+   set tags&
+   call delete('Xtags')
+   call delete('Xfile1')
+   bwipe!
+ endfunc
+ 
  " Tests for [ CTRL-I and CTRL-W CTRL-I commands
  function Test_keyword_jump()
    call writefile(["#include Xinclude", "",
*** ../vim-8.0.0194/src/version.c	2017-01-15 21:12:44.604730821 +0100
--- src/version.c	2017-01-16 20:51:15.235496124 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     195,
  /**/

-- 
Facepalm statement #5: "Petrol getting more expensive?  Not for me, I'm always
tanking for 20 dollars"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0196
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0196 (after 8.0.0194)
Problem:    The test for :profile is slow and does not work on MS-Windows.
Solution:   Use the "-es" argument. (Dominique Pelle)  Swap single and double
            quotes for system()
Files:      src/testdir/test_profile.vim


*** ../vim-8.0.0195/src/testdir/test_profile.vim	2017-01-15 21:12:44.604730821 +0100
--- src/testdir/test_profile.vim	2017-01-16 22:35:52.559857823 +0100
***************
*** 4,19 ****
  endif
  
  func Test_profile_func()
-   if !has('unix')
-     return
-   endif
    let lines = [
      \ "func! Foo1()",
      \ "endfunc",
      \ "func! Foo2()",
!     \ "  let count = 100",
!     \ "  while count > 0",
!     \ "    let count = count - 1",
      \ "  endwhile",
      \ "endfunc",
      \ "func! Foo3()",
--- 4,16 ----
  endif
  
  func Test_profile_func()
    let lines = [
      \ "func! Foo1()",
      \ "endfunc",
      \ "func! Foo2()",
!     \ "  let l:count = 100",
!     \ "  while l:count > 0",
!     \ "    let l:count = l:count - 1",
      \ "  endwhile",
      \ "endfunc",
      \ "func! Foo3()",
***************
*** 35,81 ****
      \ ]
  
    call writefile(lines, 'Xprofile_func.vim')
!   let a = system(v:progpath
!     \ . " -u NONE -i NONE --noplugin"
!     \ . " -c 'profile start Xprofile_func.log'"
!     \ . " -c 'profile func Foo*'"
!     \ . " -c 'so Xprofile_func.vim'"
!     \ . " -c 'qall!'")
!   let lines = readfile('Xprofile_func.log')
! 
!   call assert_equal(28, len(lines))
  
!   call assert_equal('FUNCTION  Foo1()', lines[0])
!   call assert_equal('Called 2 times',   lines[1])
!   call assert_equal('FUNCTION  Foo2()', lines[7])
!   call assert_equal('Called 1 time',    lines[8])
  
    " - Foo1() is called 3 times but should be reported as called twice
    "   since one call is in between "profile pause" .. "profile continue".
!   " - Foo2() should come before Foo1() since Foo1() does much more work.\
    " - Foo3() is not reported because function is deleted.
    " - Unlike Foo3(), Foo2() should not be deleted since there is a check
    "   for v:profiling.
    " - Bar() is not reported since it does not match "profile func Foo*".
!   call assert_equal('FUNCTIONS SORTED ON TOTAL TIME',        lines[18])
!   call assert_equal('count  total (s)   self (s)  function', lines[19])
!   call assert_match('^\s*1\s\+\d\+\.\d\+\s\+Foo2()$',        lines[20])
!   call assert_match('^\s*2\s\+\d\+\.\d\+\s\+Foo1()$',        lines[21])
!   call assert_equal('',                                      lines[22])
!   call assert_equal('FUNCTIONS SORTED ON SELF TIME',         lines[23])
!   call assert_equal('count  total (s)   self (s)  function', lines[24])
!   call assert_match('^\s*1\s\+\d\+\.\d\+\s\+Foo2()$',        lines[25])
!   call assert_match('^\s*2\s\+\d\+\.\d\+\s\+Foo1()$',        lines[26])
!   call assert_equal('',                                      lines[27])
  
    call delete('Xprofile_func.vim')
    call delete('Xprofile_func.log')
  endfunc
  
  func Test_profile_file()
-   if !has('unix')
-     return
-   endif
    let lines = [
      \ 'func! Foo()',
      \ 'endfunc',
--- 32,90 ----
      \ ]
  
    call writefile(lines, 'Xprofile_func.vim')
!   call system(v:progpath
!     \ . ' -es -u NONE -U NONE -i NONE --noplugin'
!     \ . ' -c "profile start Xprofile_func.log"'
!     \ . ' -c "profile func Foo*"'
!     \ . ' -c "so Xprofile_func.vim"'
!     \ . ' -c "qall!"')
!   call assert_equal(0, v:shell_error)
  
!   let lines = readfile('Xprofile_func.log')
  
    " - Foo1() is called 3 times but should be reported as called twice
    "   since one call is in between "profile pause" .. "profile continue".
!   " - Foo2() should come before Foo1() since Foo1() does much more work.
    " - Foo3() is not reported because function is deleted.
    " - Unlike Foo3(), Foo2() should not be deleted since there is a check
    "   for v:profiling.
    " - Bar() is not reported since it does not match "profile func Foo*".
!   call assert_equal(28, len(lines))
! 
!   call assert_equal('FUNCTION  Foo1()',                            lines[0])
!   call assert_equal('Called 2 times',                              lines[1])
!   call assert_match('^Total time:\s\+\d\+\.\d\+$',                 lines[2])
!   call assert_match('^ Self time:\s\+\d\+\.\d\+$',                 lines[3])
!   call assert_equal('',                                            lines[4])
!   call assert_equal('count  total (s)   self (s)',                 lines[5])
!   call assert_equal('',                                            lines[6])
!   call assert_equal('FUNCTION  Foo2()',                            lines[7])
!   call assert_equal('Called 1 time',                               lines[8])
!   call assert_match('^Total time:\s\+\d\+\.\d\+$',                 lines[9])
!   call assert_match('^ Self time:\s\+\d\+\.\d\+$',                 lines[10])
!   call assert_equal('',                                            lines[11])
!   call assert_equal('count  total (s)   self (s)',                 lines[12])
!   call assert_match('^\s*1\s\+.*\slet l:count = 100$',             lines[13])
!   call assert_match('^\s*101\s\+.*\swhile l:count > 0$',           lines[14])
!   call assert_match('^\s*100\s\+.*\s  let l:count = l:count - 1$', lines[15])
!   call assert_match('^\s*100\s\+.*\sendwhile$',                    lines[16])
!   call assert_equal('',                                            lines[17])
!   call assert_equal('FUNCTIONS SORTED ON TOTAL TIME',              lines[18])
!   call assert_equal('count  total (s)   self (s)  function',       lines[19])
!   call assert_match('^\s*1\s\+\d\+\.\d\+\s\+Foo2()$',              lines[20])
!   call assert_match('^\s*2\s\+\d\+\.\d\+\s\+Foo1()$',              lines[21])
!   call assert_equal('',                                            lines[22])
!   call assert_equal('FUNCTIONS SORTED ON SELF TIME',               lines[23])
!   call assert_equal('count  total (s)   self (s)  function',       lines[24])
!   call assert_match('^\s*1\s\+\d\+\.\d\+\s\+Foo2()$',              lines[25])
!   call assert_match('^\s*2\s\+\d\+\.\d\+\s\+Foo1()$',              lines[26])
!   call assert_equal('',                                            lines[27])
  
    call delete('Xprofile_func.vim')
    call delete('Xprofile_func.log')
  endfunc
  
  func Test_profile_file()
    let lines = [
      \ 'func! Foo()',
      \ 'endfunc',
***************
*** 87,99 ****
      \ ]
  
    call writefile(lines, 'Xprofile_file.vim')
!   let a = system(v:progpath
!     \ . " -u NONE -i NONE --noplugin"
!     \ . " -c 'profile start Xprofile_file.log'"
!     \ . " -c 'profile file Xprofile_file.vim'"
!     \ . " -c 'so Xprofile_file.vim'"
!     \ . " -c 'so Xprofile_file.vim'"
!     \ . " -c 'qall!'")
  
    let lines = readfile('Xprofile_file.log')
  
--- 96,109 ----
      \ ]
  
    call writefile(lines, 'Xprofile_file.vim')
!   call system(v:progpath
!     \ . ' -es -u NONE -U NONE -i NONE --noplugin'
!     \ . ' -c "profile start Xprofile_file.log"'
!     \ . ' -c "profile file Xprofile_file.vim"'
!     \ . ' -c "so Xprofile_file.vim"'
!     \ . ' -c "so Xprofile_file.vim"'
!     \ . ' -c "qall!"')
!   call assert_equal(0, v:shell_error)
  
    let lines = readfile('Xprofile_file.log')
  
*** ../vim-8.0.0195/src/version.c	2017-01-16 20:53:31.154599637 +0100
--- src/version.c	2017-01-16 22:23:35.266650762 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     196,
  /**/

-- 
Facepalm statement #7: "Last week I almost got pregnant!"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0197
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0197
Problem:    On MS-Windows the system() test skips a few parts.
Solution:   Swap single and double quotes for the command.
Files:      src/testdir/test_system.vim


*** ../vim-8.0.0196/src/testdir/test_system.vim	2017-01-14 19:38:32.449616516 +0100
--- src/testdir/test_system.vim	2017-01-16 22:50:52.735935225 +0100
***************
*** 48,89 ****
  endfunction
  
  function! Test_system_exmode()
!   if !has('unix')
!     return
    endif
  
-   let cmd=" -es -u NONE -c 'source Xscript' +q; echo $?"
-   " Need to put this in a script, "catch" isn't found after an unknown
-   " function.
-   call writefile(['try', 'call doesnotexist()', 'catch', 'endtry'], 'Xscript')
-   let a = system(v:progpath . cmd)
-   call assert_equal('0', a[0])
-   call assert_equal(0, v:shell_error)
- 
    " Error before try does set error flag.
    call writefile(['call nosuchfunction()', 'try', 'call doesnotexist()', 'catch', 'endtry'], 'Xscript')
!   let a = system(v:progpath . cmd)
!   call assert_notequal('0', a[0])
  
!   let cmd=" -es -u NONE -c 'source Xscript' +q"
    let a = system(v:progpath . cmd)
    call assert_notequal(0, v:shell_error)
  
!   let cmd=" -es -u NONE -c 'call doesnotexist()' +q; echo $?"
!   let a = system(v:progpath. cmd)
!   call assert_notequal(0, a[0])
  
!   let cmd=" -es -u NONE -c 'call doesnotexist()' +q"
    let a = system(v:progpath. cmd)
    call assert_notequal(0, v:shell_error)
  
!   let cmd=" -es -u NONE -c 'call doesnotexist()|let a=1' +q; echo $?"
!   let a = system(v:progpath. cmd)
!   call assert_notequal(0, a[0])
  
!   let cmd=" -es -u NONE -c 'call doesnotexist()|let a=1' +q"
    let a = system(v:progpath. cmd)
    call assert_notequal(0, v:shell_error)
- 
-   call delete('Xscript')
  endfunc
--- 48,92 ----
  endfunction
  
  function! Test_system_exmode()
!   if has('unix') " echo $? only works on Unix
!     let cmd = ' -es -u NONE -c "source Xscript" +q; echo $?'
!     " Need to put this in a script, "catch" isn't found after an unknown
!     " function.
!     call writefile(['try', 'call doesnotexist()', 'catch', 'endtry'], 'Xscript')
!     let a = system(v:progpath . cmd)
!     call assert_equal('0', a[0])
!     call assert_equal(0, v:shell_error)
    endif
  
    " Error before try does set error flag.
    call writefile(['call nosuchfunction()', 'try', 'call doesnotexist()', 'catch', 'endtry'], 'Xscript')
!   if has('unix') " echo $? only works on Unix
!     let a = system(v:progpath . cmd)
!     call assert_notequal('0', a[0])
!   endif
  
!   let cmd = ' -es -u NONE -c "source Xscript" +q'
    let a = system(v:progpath . cmd)
    call assert_notequal(0, v:shell_error)
+   call delete('Xscript')
  
!   if has('unix') " echo $? only works on Unix
!     let cmd = ' -es -u NONE -c "call doesnotexist()" +q; echo $?'
!     let a = system(v:progpath. cmd)
!     call assert_notequal(0, a[0])
!   endif
  
!   let cmd = ' -es -u NONE -c "call doesnotexist()" +q'
    let a = system(v:progpath. cmd)
    call assert_notequal(0, v:shell_error)
  
!   if has('unix') " echo $? only works on Unix
!     let cmd = ' -es -u NONE -c "call doesnotexist()|let a=1" +q; echo $?'
!     let a = system(v:progpath. cmd)
!     call assert_notequal(0, a[0])
!   endif
  
!   let cmd = ' -es -u NONE -c "call doesnotexist()|let a=1" +q'
    let a = system(v:progpath. cmd)
    call assert_notequal(0, v:shell_error)
  endfunc
*** ../vim-8.0.0196/src/version.c	2017-01-16 22:37:39.520971858 +0100
--- src/version.c	2017-01-16 22:53:18.194680870 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     197,
  /**/

-- 
Facepalm statement #8: "Drive faster, the petrol is running out"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0198
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0198
Problem:    Some syntax arguments take effect even after "if 0". (Taylor
            Venable)
Solution:   Properly skip the syntax statements.  Make "syn case" and "syn
            conceal" report the current state.  Fix that "syn clear" didn't
            reset the conceal flag.  Add tests for :syntax skipping properly.
Files:      src/syntax.c, src/testdir/test_syntax.vim


*** ../vim-8.0.0197/src/syntax.c	2017-01-08 18:28:18.965762385 +0100
--- src/syntax.c	2017-01-17 16:08:22.248409802 +0100
***************
*** 462,468 ****
  static void clear_keywtab(hashtab_T *ht);
  static void add_keyword(char_u *name, int id, int flags, short *cont_in_list, short *next_list, int conceal_char);
  static char_u *get_group_name(char_u *arg, char_u **name_end);
! static char_u *get_syn_options(char_u *arg, syn_opt_arg_T *opt, int *conceal_char);
  static void syn_cmd_include(exarg_T *eap, int syncing);
  static void syn_cmd_iskeyword(exarg_T *eap, int syncing);
  static void syn_cmd_keyword(exarg_T *eap, int syncing);
--- 462,468 ----
  static void clear_keywtab(hashtab_T *ht);
  static void add_keyword(char_u *name, int id, int flags, short *cont_in_list, short *next_list, int conceal_char);
  static char_u *get_group_name(char_u *arg, char_u **name_end);
! static char_u *get_syn_options(char_u *arg, syn_opt_arg_T *opt, int *conceal_char, int skip);
  static void syn_cmd_include(exarg_T *eap, int syncing);
  static void syn_cmd_iskeyword(exarg_T *eap, int syncing);
  static void syn_cmd_keyword(exarg_T *eap, int syncing);
***************
*** 481,487 ****
  static void init_syn_patterns(void);
  static char_u *get_syn_pattern(char_u *arg, synpat_T *ci);
  static void syn_cmd_sync(exarg_T *eap, int syncing);
! static int get_id_list(char_u **arg, int keylen, short **list);
  static void syn_combine_list(short **clstr1, short **clstr2, int list_op);
  static void syn_incl_toplevel(int id, int *flagsp);
  
--- 481,487 ----
  static void init_syn_patterns(void);
  static char_u *get_syn_pattern(char_u *arg, synpat_T *ci);
  static void syn_cmd_sync(exarg_T *eap, int syncing);
! static int get_id_list(char_u **arg, int keylen, short **list, int skip);
  static void syn_combine_list(short **clstr1, short **clstr2, int list_op);
  static void syn_incl_toplevel(int id, int *flagsp);
  
***************
*** 3434,3440 ****
  	return;
  
      next = skiptowhite(arg);
!     if (STRNICMP(arg, "on", 2) == 0 && next - arg == 2)
  	curwin->w_s->b_syn_conceal = TRUE;
      else if (STRNICMP(arg, "off", 3) == 0 && next - arg == 3)
  	curwin->w_s->b_syn_conceal = FALSE;
--- 3434,3447 ----
  	return;
  
      next = skiptowhite(arg);
!     if (*arg == NUL)
!     {
! 	if (curwin->w_s->b_syn_conceal)
! 	    MSG(_("syn conceal on"));
! 	else
! 	    MSG(_("syn conceal off"));
!     }
!     else if (STRNICMP(arg, "on", 2) == 0 && next - arg == 2)
  	curwin->w_s->b_syn_conceal = TRUE;
      else if (STRNICMP(arg, "off", 3) == 0 && next - arg == 3)
  	curwin->w_s->b_syn_conceal = FALSE;
***************
*** 3457,3463 ****
  	return;
  
      next = skiptowhite(arg);
!     if (STRNICMP(arg, "match", 5) == 0 && next - arg == 5)
  	curwin->w_s->b_syn_ic = FALSE;
      else if (STRNICMP(arg, "ignore", 6) == 0 && next - arg == 6)
  	curwin->w_s->b_syn_ic = TRUE;
--- 3464,3477 ----
  	return;
  
      next = skiptowhite(arg);
!     if (*arg == NUL)
!     {
! 	if (curwin->w_s->b_syn_ic)
! 	    MSG(_("syntax case ignore"));
! 	else
! 	    MSG(_("syntax case match"));
!     }
!     else if (STRNICMP(arg, "match", 5) == 0 && next - arg == 5)
  	curwin->w_s->b_syn_ic = FALSE;
      else if (STRNICMP(arg, "ignore", 6) == 0 && next - arg == 6)
  	curwin->w_s->b_syn_ic = TRUE;
***************
*** 3479,3485 ****
  	return;
  
      next = skiptowhite(arg);
!     if (STRNICMP(arg, "toplevel", 8) == 0 && next - arg == 8)
  	curwin->w_s->b_syn_spell = SYNSPL_TOP;
      else if (STRNICMP(arg, "notoplevel", 10) == 0 && next - arg == 10)
  	curwin->w_s->b_syn_spell = SYNSPL_NOTOP;
--- 3493,3508 ----
  	return;
  
      next = skiptowhite(arg);
!     if (*arg == NUL)
!     {
! 	if (curwin->w_s->b_syn_spell == SYNSPL_TOP)
! 	    MSG(_("syntax spell toplevel"));
! 	else if (curwin->w_s->b_syn_spell == SYNSPL_NOTOP)
! 	    MSG(_("syntax spell notoplevel"));
! 	else
! 	    MSG(_("syntax spell default"));
!     }
!     else if (STRNICMP(arg, "toplevel", 8) == 0 && next - arg == 8)
  	curwin->w_s->b_syn_spell = SYNSPL_TOP;
      else if (STRNICMP(arg, "notoplevel", 10) == 0 && next - arg == 10)
  	curwin->w_s->b_syn_spell = SYNSPL_NOTOP;
***************
*** 3556,3561 ****
--- 3579,3587 ----
      block->b_syn_ic = FALSE;	    /* Use case, by default */
      block->b_syn_spell = SYNSPL_DEFAULT; /* default spell checking */
      block->b_syn_containedin = FALSE;
+ #ifdef FEAT_CONCEAL
+     block->b_syn_conceal = FALSE;
+ #endif
  
      /* free the keywords */
      clear_keywtab(&block->b_keywtab);
***************
*** 4543,4549 ****
  get_syn_options(
      char_u	    *arg,		/* next argument to be checked */
      syn_opt_arg_T   *opt,		/* various things */
!     int		    *conceal_char UNUSED)
  {
      char_u	*gname_start, *gname;
      int		syn_id;
--- 4569,4576 ----
  get_syn_options(
      char_u	    *arg,		/* next argument to be checked */
      syn_opt_arg_T   *opt,		/* various things */
!     int		    *conceal_char UNUSED,
!     int		    skip)		/* TRUE if skipping over command */
  {
      char_u	*gname_start, *gname;
      int		syn_id;
***************
*** 4626,4642 ****
  		EMSG(_("E395: contains argument not accepted here"));
  		return NULL;
  	    }
! 	    if (get_id_list(&arg, 8, &opt->cont_list) == FAIL)
  		return NULL;
  	}
  	else if (flagtab[fidx].argtype == 2)
  	{
! 	    if (get_id_list(&arg, 11, &opt->cont_in_list) == FAIL)
  		return NULL;
  	}
  	else if (flagtab[fidx].argtype == 3)
  	{
! 	    if (get_id_list(&arg, 9, &opt->next_list) == FAIL)
  		return NULL;
  	}
  	else if (flagtab[fidx].argtype == 11 && arg[5] == '=')
--- 4653,4669 ----
  		EMSG(_("E395: contains argument not accepted here"));
  		return NULL;
  	    }
! 	    if (get_id_list(&arg, 8, &opt->cont_list, skip) == FAIL)
  		return NULL;
  	}
  	else if (flagtab[fidx].argtype == 2)
  	{
! 	    if (get_id_list(&arg, 11, &opt->cont_in_list, skip) == FAIL)
  		return NULL;
  	}
  	else if (flagtab[fidx].argtype == 3)
  	{
! 	    if (get_id_list(&arg, 9, &opt->next_list, skip) == FAIL)
  		return NULL;
  	}
  	else if (flagtab[fidx].argtype == 11 && arg[5] == '=')
***************
*** 4846,4852 ****
  
      if (rest != NULL)
      {
! 	syn_id = syn_check_group(arg, (int)(group_name_end - arg));
  	if (syn_id != 0)
  	    /* allocate a buffer, for removing backslashes in the keyword */
  	    keyword_copy = alloc((unsigned)STRLEN(rest) + 1);
--- 4873,4882 ----
  
      if (rest != NULL)
      {
! 	if (eap->skip)
! 	    syn_id = -1;
! 	else
! 	    syn_id = syn_check_group(arg, (int)(group_name_end - arg));
  	if (syn_id != 0)
  	    /* allocate a buffer, for removing backslashes in the keyword */
  	    keyword_copy = alloc((unsigned)STRLEN(rest) + 1);
***************
*** 4868,4874 ****
  	    p = keyword_copy;
  	    for ( ; rest != NULL && !ends_excmd(*rest); rest = skipwhite(rest))
  	    {
! 		rest = get_syn_options(rest, &syn_opt_arg, &conceal_char);
  		if (rest == NULL || ends_excmd(*rest))
  		    break;
  		/* Copy the keyword, removing backslashes, and add a NUL. */
--- 4898,4905 ----
  	    p = keyword_copy;
  	    for ( ; rest != NULL && !ends_excmd(*rest); rest = skipwhite(rest))
  	    {
! 		rest = get_syn_options(rest, &syn_opt_arg, &conceal_char,
! 								    eap->skip);
  		if (rest == NULL || ends_excmd(*rest))
  		    break;
  		/* Copy the keyword, removing backslashes, and add a NUL. */
***************
*** 4981,4987 ****
      syn_opt_arg.cont_list = NULL;
      syn_opt_arg.cont_in_list = NULL;
      syn_opt_arg.next_list = NULL;
!     rest = get_syn_options(rest, &syn_opt_arg, &conceal_char);
  
      /* get the pattern. */
      init_syn_patterns();
--- 5012,5018 ----
      syn_opt_arg.cont_list = NULL;
      syn_opt_arg.cont_in_list = NULL;
      syn_opt_arg.next_list = NULL;
!     rest = get_syn_options(rest, &syn_opt_arg, &conceal_char, eap->skip);
  
      /* get the pattern. */
      init_syn_patterns();
***************
*** 4991,4997 ****
  	syn_opt_arg.flags |= HL_HAS_EOL;
  
      /* Get options after the pattern */
!     rest = get_syn_options(rest, &syn_opt_arg, &conceal_char);
  
      if (rest != NULL)		/* all arguments are valid */
      {
--- 5022,5028 ----
  	syn_opt_arg.flags |= HL_HAS_EOL;
  
      /* Get options after the pattern */
!     rest = get_syn_options(rest, &syn_opt_arg, &conceal_char, eap->skip);
  
      if (rest != NULL)		/* all arguments are valid */
      {
***************
*** 5117,5123 ****
      while (rest != NULL && !ends_excmd(*rest))
      {
  	/* Check for option arguments */
! 	rest = get_syn_options(rest, &syn_opt_arg, &conceal_char);
  	if (rest == NULL || ends_excmd(*rest))
  	    break;
  
--- 5148,5154 ----
      while (rest != NULL && !ends_excmd(*rest))
      {
  	/* Check for option arguments */
! 	rest = get_syn_options(rest, &syn_opt_arg, &conceal_char, eap->skip);
  	if (rest == NULL || ends_excmd(*rest))
  	    break;
  
***************
*** 5628,5639 ****
  		break;
  
  	    clstr_list = NULL;
! 	    if (get_id_list(&rest, opt_len, &clstr_list) == FAIL)
  	    {
  		EMSG2(_(e_invarg2), rest);
  		break;
  	    }
! 	    syn_combine_list(&SYN_CLSTR(curwin->w_s)[scl_id].scl_list,
  			     &clstr_list, list_op);
  	    got_clstr = TRUE;
  	}
--- 5659,5671 ----
  		break;
  
  	    clstr_list = NULL;
! 	    if (get_id_list(&rest, opt_len, &clstr_list, eap->skip) == FAIL)
  	    {
  		EMSG2(_(e_invarg2), rest);
  		break;
  	    }
! 	    if (scl_id >= 0)
! 		syn_combine_list(&SYN_CLSTR(curwin->w_s)[scl_id].scl_list,
  			     &clstr_list, list_op);
  	    got_clstr = TRUE;
  	}
***************
*** 5931,5938 ****
  get_id_list(
      char_u	**arg,
      int		keylen,		/* length of keyword */
!     short	**list)		/* where to store the resulting list, if not
  				   NULL, the list is silently skipped! */
  {
      char_u	*p = NULL;
      char_u	*end;
--- 5963,5971 ----
  get_id_list(
      char_u	**arg,
      int		keylen,		/* length of keyword */
!     short	**list,		/* where to store the resulting list, if not
  				   NULL, the list is silently skipped! */
+     int		skip)
  {
      char_u	*p = NULL;
      char_u	*end;
***************
*** 6015,6021 ****
  	    }
  	    else if (name[1] == '@')
  	    {
! 		id = syn_check_cluster(name + 2, (int)(end - p - 1));
  	    }
  	    else
  	    {
--- 6048,6055 ----
  	    }
  	    else if (name[1] == '@')
  	    {
! 		if (!skip)
! 		    id = syn_check_cluster(name + 2, (int)(end - p - 1));
  	    }
  	    else
  	    {
*** ../vim-8.0.0197/src/testdir/test_syntax.vim	2017-01-08 18:28:18.965762385 +0100
--- src/testdir/test_syntax.vim	2017-01-17 16:20:07.603838000 +0100
***************
*** 162,164 ****
--- 162,295 ----
    call feedkeys(":syn match \<C-A>\<C-B>\"\<CR>", 'tx')
    call assert_match('^"syn match Boolean Character ', @:)
  endfunc
+ 
+ func Test_syntax_arg_skipped()
+   syn clear
+   syntax case ignore
+   if 0
+     syntax case match
+   endif
+   call assert_match('case ignore', execute('syntax case'))
+ 
+   syn keyword Foo foo
+   call assert_match('Foo', execute('syntax'))
+   syn clear
+   call assert_match('case match', execute('syntax case'))
+   call assert_notmatch('Foo', execute('syntax'))
+ 
+   if has('conceal')
+     syn clear
+     syntax conceal on
+     if 0
+       syntax conceal off
+     endif
+     call assert_match('conceal on', execute('syntax conceal'))
+     syn clear
+     call assert_match('conceal off', execute('syntax conceal'))
+   endif
+ 
+   syntax region Tar start=/</ end=/>/
+   if 0
+     syntax region NotTest start=/</ end=/>/ contains=@Spell
+   endif
+   call assert_match('Tar', execute('syntax'))
+   call assert_notmatch('NotTest', execute('syntax'))
+   call assert_notmatch('Spell', execute('syntax'))
+ 
+   hi Foo ctermfg=blue
+   let a = execute('hi Foo')
+   if 0
+     syntax rest
+   endif
+   call assert_equal(a, execute('hi Foo'))
+ 
+   set ft=tags
+   syn off
+   if 0
+     syntax enable
+   endif
+   call assert_match('No Syntax items defined', execute('syntax'))
+   syntax enable
+   call assert_match('tagComment', execute('syntax'))
+   set ft=
+ 
+   syn clear
+   if 0
+     syntax include @Spell nothing
+   endif
+   call assert_notmatch('Spell', execute('syntax'))
+ 
+   syn clear
+   syn iskeyword 48-57,$,_
+   call assert_match('48-57,$,_', execute('syntax iskeyword'))
+   if 0
+     syn clear
+     syn iskeyword clear
+   endif
+   call assert_match('48-57,$,_', execute('syntax iskeyword'))
+   syn iskeyword clear
+   call assert_match('not set', execute('syntax iskeyword'))
+   syn iskeyword 48-57,$,_
+   syn clear
+   call assert_match('not set', execute('syntax iskeyword'))
+ 
+   syn clear
+   syn keyword Foo foo
+   if 0
+     syn keyword NotAdded bar
+   endif
+   call assert_match('Foo', execute('syntax'))
+   call assert_notmatch('NotAdded', execute('highlight'))
+ 
+   syn clear
+   syn keyword Foo foo
+   call assert_match('Foo', execute('syntax'))
+   call assert_match('Foo', execute('syntax list'))
+   call assert_notmatch('Foo', execute('if 0 | syntax | endif'))
+   call assert_notmatch('Foo', execute('if 0 | syntax list | endif'))
+ 
+   syn clear
+   syn match Fopi /asdf/
+   if 0
+     syn match Fopx /asdf/
+   endif
+   call assert_match('Fopi', execute('syntax'))
+   call assert_notmatch('Fopx', execute('syntax'))
+ 
+   syn clear
+   syn spell toplevel
+   call assert_match('spell toplevel', execute('syntax spell'))
+   if 0
+     syn spell notoplevel
+   endif
+   call assert_match('spell toplevel', execute('syntax spell'))
+   syn spell notoplevel
+   call assert_match('spell notoplevel', execute('syntax spell'))
+   syn spell default
+   call assert_match('spell default', execute('syntax spell'))
+ 
+   syn clear
+   if 0
+     syntax cluster Spell
+   endif
+   call assert_notmatch('Spell', execute('syntax'))
+ 
+   syn clear
+   syn keyword Foo foo
+   syn sync ccomment
+   syn sync maxlines=5
+   if 0
+     syn sync maxlines=11
+   endif
+   call assert_match('on C-style comments', execute('syntax sync'))
+   call assert_match('maximal 5 lines', execute('syntax sync'))
+   syn clear
+   syn keyword Foo foo
+   if 0
+     syn sync ccomment
+   endif
+   call assert_notmatch('on C-style comments', execute('syntax sync'))
+ 
+   syn clear
+ endfunc
+ 
*** ../vim-8.0.0197/src/version.c	2017-01-16 22:53:54.018441223 +0100
--- src/version.c	2017-01-17 13:51:35.186807534 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     198,
  /**/

-- 
Microsoft's definition of a boolean: TRUE, FALSE, MAYBE
"Embrace and extend"...?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0199
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0199
Problem:    Warning for an unused parameter when the libcall feature is
            disabled.  Warning for a function type cast when compiling with
            -pedantic.
Solution:   Add UNUSED.  Use a different type cast. (Damien Molinier)
Files:      src/evalfunc.c, src/os_unix.c


*** ../vim-8.0.0198/src/evalfunc.c	2017-01-12 20:06:30.152522974 +0100
--- src/evalfunc.c	2017-01-17 16:39:38.488220223 +0100
***************
*** 6859,6868 ****
      }
  }
  
- static void libcall_common(typval_T *argvars, typval_T *rettv, int type);
- 
      static void
! libcall_common(typval_T *argvars, typval_T *rettv, int type)
  {
  #ifdef FEAT_LIBCALL
      char_u		*string_in;
--- 6859,6866 ----
      }
  }
  
      static void
! libcall_common(typval_T *argvars UNUSED, typval_T *rettv, int type)
  {
  #ifdef FEAT_LIBCALL
      char_u		*string_in;
*** ../vim-8.0.0198/src/os_unix.c	2016-11-26 15:13:29.406218061 +0100
--- src/os_unix.c	2017-01-17 16:43:25.938736519 +0100
***************
*** 6918,6924 ****
  	    if (argstring != NULL)
  	    {
  # if defined(USE_DLOPEN)
! 		ProcAdd = (STRPROCSTR)dlsym(hinstLib, (const char *)funcname);
  		dlerr = (char *)dlerror();
  # else
  		if (shl_findsym(&hinstLib, (const char *)funcname,
--- 6918,6924 ----
  	    if (argstring != NULL)
  	    {
  # if defined(USE_DLOPEN)
! 		*(void **)(&ProcAdd) = dlsym(hinstLib, (const char *)funcname);
  		dlerr = (char *)dlerror();
  # else
  		if (shl_findsym(&hinstLib, (const char *)funcname,
***************
*** 6940,6946 ****
  	    else
  	    {
  # if defined(USE_DLOPEN)
! 		ProcAddI = (INTPROCSTR)dlsym(hinstLib, (const char *)funcname);
  		dlerr = (char *)dlerror();
  # else
  		if (shl_findsym(&hinstLib, (const char *)funcname,
--- 6940,6946 ----
  	    else
  	    {
  # if defined(USE_DLOPEN)
! 		*(void **)(&ProcAddI) = dlsym(hinstLib, (const char *)funcname);
  		dlerr = (char *)dlerror();
  # else
  		if (shl_findsym(&hinstLib, (const char *)funcname,
*** ../vim-8.0.0198/src/version.c	2017-01-17 16:27:01.617153072 +0100
--- src/version.c	2017-01-17 16:42:22.903147732 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     199,
  /**/

-- 
If I tell you "you have a beautiful body", would you hold it against me?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0200
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0200
Problem:    Some syntax arguments are not tested.
Solution:   Add more syntax command tests.
Files:      src/testdir/test_syntax.vim


*** ../vim-8.0.0199/src/testdir/test_syntax.vim	2017-01-17 16:27:01.617153072 +0100
--- src/testdir/test_syntax.vim	2017-01-17 17:17:04.089556288 +0100
***************
*** 186,191 ****
--- 186,195 ----
      call assert_match('conceal on', execute('syntax conceal'))
      syn clear
      call assert_match('conceal off', execute('syntax conceal'))
+ 
+     syntax conceal on
+     syntax conceal off
+     call assert_match('conceal off', execute('syntax conceal'))
    endif
  
    syntax region Tar start=/</ end=/>/
***************
*** 283,290 ****
    endif
    call assert_match('on C-style comments', execute('syntax sync'))
    call assert_match('maximal 5 lines', execute('syntax sync'))
!   syn clear
!   syn keyword Foo foo
    if 0
      syn sync ccomment
    endif
--- 287,293 ----
    endif
    call assert_match('on C-style comments', execute('syntax sync'))
    call assert_match('maximal 5 lines', execute('syntax sync'))
!   syn sync clear
    if 0
      syn sync ccomment
    endif
***************
*** 293,295 ****
--- 296,325 ----
    syn clear
  endfunc
  
+ func Test_invalid_arg()
+   call assert_fails('syntax case asdf', 'E390:')
+   call assert_fails('syntax conceal asdf', 'E390:')
+   call assert_fails('syntax spell asdf', 'E390:')
+ endfunc
+ 
+ func Test_syn_sync()
+   syntax region HereGroup start=/this/ end=/that/
+   syntax sync match SyncHere grouphere HereGroup "pattern"
+   call assert_match('SyncHere', execute('syntax sync'))
+   syn sync clear
+   call assert_notmatch('SyncHere', execute('syntax sync'))
+   syn clear
+ endfunc
+ 
+ func Test_syn_clear()
+   syntax keyword Foo foo
+   syntax keyword Tar tar
+   call assert_match('Foo', execute('syntax'))
+   call assert_match('Tar', execute('syntax'))
+   syn clear Foo
+   call assert_notmatch('Foo', execute('syntax'))
+   call assert_match('Tar', execute('syntax'))
+   syn clear Foo Tar
+   call assert_notmatch('Foo', execute('syntax'))
+   call assert_notmatch('Tar', execute('syntax'))
+ endfunc
*** ../vim-8.0.0199/src/version.c	2017-01-17 16:45:00.174121747 +0100
--- src/version.c	2017-01-17 17:03:49.794735182 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     200,
  /**/

-- 
       When danger reared its ugly head,
       He bravely turned his tail and fled
       Yes, Brave Sir Robin turned about
       And gallantly he chickened out
       Bravely taking to his feet
       He beat a very brave retreat
       Bravest of the brave Sir Robin
       Petrified of being dead
       Soiled his pants then brave Sir Robin
       Turned away and fled.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0201
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0201
Problem:    When completing a group name for a highlight or syntax command
            cleared groups are included.
Solution:   Skip groups that have been cleared.
Files:      src/syntax.c, src/testdir/test_syntax.vim


*** ../vim-8.0.0200/src/syntax.c	2017-01-17 16:27:01.617153072 +0100
--- src/syntax.c	2017-01-17 17:33:43.291038448 +0100
***************
*** 22,27 ****
--- 22,28 ----
  {
      char_u	*sg_name;	/* highlight group name */
      char_u	*sg_name_u;	/* uppercase of sg_name */
+     int		sg_cleared;	/* "hi clear" was used */
  /* for normal terminals */
      int		sg_term;	/* "term=" highlighting attributes */
      char_u	*sg_start;	/* terminal string for start highl */
***************
*** 7327,7332 ****
--- 7328,7334 ----
  #ifdef FEAT_EVAL
  		HL_TABLE()[from_id - 1].sg_scriptID = current_SID;
  #endif
+ 		HL_TABLE()[from_id - 1].sg_cleared = FALSE;
  		redraw_all_later(SOME_VALID);
  	    }
  	}
***************
*** 8034,8039 ****
--- 8036,8042 ----
  	    error = TRUE;
  	    break;
  	}
+ 	HL_TABLE()[idx].sg_cleared = FALSE;
  
  	/*
  	 * When highlighting has been given for a group, don't link it.
***************
*** 8171,8176 ****
--- 8174,8181 ----
      static void
  highlight_clear(int idx)
  {
+     HL_TABLE()[idx].sg_cleared = TRUE;
+ 
      HL_TABLE()[idx].sg_term = 0;
      vim_free(HL_TABLE()[idx].sg_start);
      HL_TABLE()[idx].sg_start = NULL;
***************
*** 9958,9964 ****
  							 && include_link != 0)
  	return (char_u *)"clear";
  #endif
!     if (idx < 0 || idx >= highlight_ga.ga_len)
  	return NULL;
      return HL_TABLE()[idx].sg_name;
  }
--- 9963,9975 ----
  							 && include_link != 0)
  	return (char_u *)"clear";
  #endif
!     if (idx < 0)
! 	return NULL;
!     /* Items are never removed from the table, skip the ones that were cleared.
!      */
!     while (idx < highlight_ga.ga_len && HL_TABLE()[idx].sg_cleared)
! 	++idx;
!     if (idx >= highlight_ga.ga_len)
  	return NULL;
      return HL_TABLE()[idx].sg_name;
  }
*** ../vim-8.0.0200/src/testdir/test_syntax.vim	2017-01-17 17:18:54.612835531 +0100
--- src/testdir/test_syntax.vim	2017-01-17 17:40:09.164519974 +0100
***************
*** 156,161 ****
--- 156,167 ----
    call feedkeys(":syn sync \<C-A>\<C-B>\"\<CR>", 'tx')
    call assert_equal('"syn sync ccomment clear fromstart linebreaks= linecont lines= match maxlines= minlines= region', @:)
  
+   " Check that clearing "Aap" avoids it showing up before Boolean.
+   hi Aap ctermfg=blue
+   call feedkeys(":syn list \<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_match('^"syn list Aap Boolean Character ', @:)
+   hi clear Aap
+ 
    call feedkeys(":syn list \<C-A>\<C-B>\"\<CR>", 'tx')
    call assert_match('^"syn list Boolean Character ', @:)
  
***************
*** 192,202 ****
      call assert_match('conceal off', execute('syntax conceal'))
    endif
  
!   syntax region Tar start=/</ end=/>/
    if 0
      syntax region NotTest start=/</ end=/>/ contains=@Spell
    endif
!   call assert_match('Tar', execute('syntax'))
    call assert_notmatch('NotTest', execute('syntax'))
    call assert_notmatch('Spell', execute('syntax'))
  
--- 198,208 ----
      call assert_match('conceal off', execute('syntax conceal'))
    endif
  
!   syntax region Bar start=/</ end=/>/
    if 0
      syntax region NotTest start=/</ end=/>/ contains=@Spell
    endif
!   call assert_match('Bar', execute('syntax'))
    call assert_notmatch('NotTest', execute('syntax'))
    call assert_notmatch('Spell', execute('syntax'))
  
***************
*** 206,211 ****
--- 212,219 ----
      syntax rest
    endif
    call assert_equal(a, execute('hi Foo'))
+   hi clear Bar
+   hi clear Foo
  
    set ft=tags
    syn off
***************
*** 298,304 ****
  
  func Test_invalid_arg()
    call assert_fails('syntax case asdf', 'E390:')
!   call assert_fails('syntax conceal asdf', 'E390:')
    call assert_fails('syntax spell asdf', 'E390:')
  endfunc
  
--- 306,314 ----
  
  func Test_invalid_arg()
    call assert_fails('syntax case asdf', 'E390:')
!   if has('conceal')
!     call assert_fails('syntax conceal asdf', 'E390:')
!   endif
    call assert_fails('syntax spell asdf', 'E390:')
  endfunc
  
***************
*** 313,325 ****
  
  func Test_syn_clear()
    syntax keyword Foo foo
!   syntax keyword Tar tar
    call assert_match('Foo', execute('syntax'))
!   call assert_match('Tar', execute('syntax'))
    syn clear Foo
    call assert_notmatch('Foo', execute('syntax'))
!   call assert_match('Tar', execute('syntax'))
!   syn clear Foo Tar
    call assert_notmatch('Foo', execute('syntax'))
!   call assert_notmatch('Tar', execute('syntax'))
  endfunc
--- 323,337 ----
  
  func Test_syn_clear()
    syntax keyword Foo foo
!   syntax keyword Bar tar
    call assert_match('Foo', execute('syntax'))
!   call assert_match('Bar', execute('syntax'))
    syn clear Foo
    call assert_notmatch('Foo', execute('syntax'))
!   call assert_match('Bar', execute('syntax'))
!   syn clear Foo Bar
    call assert_notmatch('Foo', execute('syntax'))
!   call assert_notmatch('Bar', execute('syntax'))
!   hi clear Foo
!   hi clear Bar
  endfunc
*** ../vim-8.0.0200/src/version.c	2017-01-17 17:18:54.612835531 +0100
--- src/version.c	2017-01-17 17:43:42.819123273 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     201,
  /**/

-- 
   GALAHAD turns back.  We see from his POV the lovely ZOOT standing by him
   smiling enchantingly and a number of equally delectable GIRLIES draped
   around in the seductively poulticed room.  They look at him smilingly and
   wave.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0202
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0202
Problem:    No test for invalid syntax group name.
Solution:   Add a test for group name error and warning.
Files:      src/testdir/test_syntax.vim


*** ../vim-8.0.0201/src/testdir/test_syntax.vim	2017-01-17 17:44:42.298734441 +0100
--- src/testdir/test_syntax.vim	2017-01-17 18:12:43.379686263 +0100
***************
*** 335,337 ****
--- 335,348 ----
    hi clear Foo
    hi clear Bar
  endfunc
+ 
+ func Test_invalid_name()
+   syn clear
+   syn keyword Nop yes
+   call assert_fails("syntax keyword Wr\x17ong bar", 'E669:')
+   syntax keyword @Wrong bar
+   call assert_match('W18:', execute('1messages'))
+   syn clear
+   hi clear Nop
+   hi clear @Wrong
+ endfunc
*** ../vim-8.0.0201/src/version.c	2017-01-17 17:44:42.298734441 +0100
--- src/version.c	2017-01-17 18:13:46.371270986 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     202,
  /**/

-- 
ZOOT:  I'm afraid our life must seem very dull and quiet compared to yours.
       We are but eightscore young blondes, all between sixteen and
       nineteen-and-a-half, cut off in this castle, with no one to protect us.
       Oooh.  It is a lonely life ... bathing ...  dressing ... undressing ...
       making exciting underwear....
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0203
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0203
Problem:    Order of complication flags is sometimes wrong.
Solution:   Put interface-specific flags before ALL_CFLAGS. (idea by Yousong
            Zhou, closes #1100)
Files:      src/Makefile


*** ../vim-8.0.0202/src/Makefile	2017-01-15 15:22:14.162467173 +0100
--- src/Makefile	2017-01-17 19:16:58.237698570 +0100
***************
*** 1877,1883 ****
  
  
  # The normal command to compile a .c file to its .o file.
! CCC = $(CC) -c -I$(srcdir) $(ALL_CFLAGS)
  
  
  # Link the target for normal use or debugging.
--- 1877,1885 ----
  
  
  # The normal command to compile a .c file to its .o file.
! # Without or with ALL_CFLAGS.
! CCC_NF = $(CC) -c -I$(srcdir)
! CCC = $(CCC_NF) $(ALL_CFLAGS)
  
  
  # Link the target for normal use or debugging.
***************
*** 2976,2982 ****
  	$(CCC) -o $@ gui_gtk_f.c
  
  objects/gui_gtk_gresources.o: auto/gui_gtk_gresources.c
! 	$(CCC) $(PERL_CFLAGS) -o $@ auto/gui_gtk_gresources.c
  
  objects/gui_gtk_x11.o: gui_gtk_x11.c
  	$(CCC) -o $@ gui_gtk_x11.c
--- 2978,2984 ----
  	$(CCC) -o $@ gui_gtk_f.c
  
  objects/gui_gtk_gresources.o: auto/gui_gtk_gresources.c
! 	$(CCC_NF) $(PERL_CFLAGS) $(ALL_CFLAGS) -o $@ auto/gui_gtk_gresources.c
  
  objects/gui_gtk_x11.o: gui_gtk_x11.c
  	$(CCC) -o $@ gui_gtk_x11.c
***************
*** 3009,3015 ****
  	$(CCC) -o $@ if_xcmdsrv.c
  
  objects/if_lua.o: if_lua.c
! 	$(CCC) $(LUA_CFLAGS) -o $@ if_lua.c
  
  objects/if_mzsch.o: if_mzsch.c $(MZSCHEME_EXTRA)
  	$(CCC) -o $@ $(MZSCHEME_CFLAGS_EXTRA) if_mzsch.c
--- 3011,3017 ----
  	$(CCC) -o $@ if_xcmdsrv.c
  
  objects/if_lua.o: if_lua.c
! 	$(CCC_NF) $(LUA_CFLAGS) $(ALL_CFLAGS) -o $@ if_lua.c
  
  objects/if_mzsch.o: if_mzsch.c $(MZSCHEME_EXTRA)
  	$(CCC) -o $@ $(MZSCHEME_CFLAGS_EXTRA) if_mzsch.c
***************
*** 3018,3044 ****
  	$(MZSCHEME_MZC) --c-mods mzscheme_base.c ++lib scheme/base
  
  objects/if_perl.o: auto/if_perl.c
! 	$(CCC) $(PERL_CFLAGS) -o $@ auto/if_perl.c
  
  objects/if_perlsfio.o: if_perlsfio.c
! 	$(CCC) $(PERL_CFLAGS) -o $@ if_perlsfio.c
  
  objects/py_getpath.o: $(PYTHON_CONFDIR)/getpath.c
! 	$(CCC) $(PYTHON_CFLAGS) -o $@ $(PYTHON_CONFDIR)/getpath.c \
  		-I$(PYTHON_CONFDIR) -DHAVE_CONFIG_H -DNO_MAIN \
  		$(PYTHON_GETPATH_CFLAGS)
  
  objects/if_python.o: if_python.c if_py_both.h
! 	$(CCC) $(PYTHON_CFLAGS) $(PYTHON_CFLAGS_EXTRA) -o $@ if_python.c
  
  objects/if_python3.o: if_python3.c if_py_both.h
! 	$(CCC) $(PYTHON3_CFLAGS) $(PYTHON3_CFLAGS_EXTRA) -o $@ if_python3.c
  
  objects/if_ruby.o: if_ruby.c
! 	$(CCC) $(RUBY_CFLAGS) -o $@ if_ruby.c
  
  objects/if_tcl.o: if_tcl.c
! 	$(CCC) $(TCL_CFLAGS) -o $@ if_tcl.c
  
  objects/integration.o: integration.c
  	$(CCC) -o $@ integration.c
--- 3020,3047 ----
  	$(MZSCHEME_MZC) --c-mods mzscheme_base.c ++lib scheme/base
  
  objects/if_perl.o: auto/if_perl.c
! 	$(CCC_NF) $(PERL_CFLAGS) $(ALL_CFLAGS) -o $@ auto/if_perl.c
  
  objects/if_perlsfio.o: if_perlsfio.c
! 	$(CCC_NF) $(PERL_CFLAGS) $(ALL_CFLAGS) -o $@ if_perlsfio.c
  
  objects/py_getpath.o: $(PYTHON_CONFDIR)/getpath.c
! 	$(CCC_NF) $(PYTHON_CFLAGS) $(ALL_CFLAGS) -o $@ \
! 		$(PYTHON_CONFDIR)/getpath.c \
  		-I$(PYTHON_CONFDIR) -DHAVE_CONFIG_H -DNO_MAIN \
  		$(PYTHON_GETPATH_CFLAGS)
  
  objects/if_python.o: if_python.c if_py_both.h
! 	$(CCC_NF) $(PYTHON_CFLAGS) $(PYTHON_CFLAGS_EXTRA) $(ALL_CFLAGS) -o $@ if_python.c
  
  objects/if_python3.o: if_python3.c if_py_both.h
! 	$(CCC_NF) $(PYTHON3_CFLAGS) $(PYTHON3_CFLAGS_EXTRA) $(ALL_CFLAGS) -o $@ if_python3.c
  
  objects/if_ruby.o: if_ruby.c
! 	$(CCC_NF) $(RUBY_CFLAGS) $(ALL_CFLAGS) -o $@ if_ruby.c
  
  objects/if_tcl.o: if_tcl.c
! 	$(CCC_NF) $(TCL_CFLAGS) $(ALL_CFLAGS) -o $@ if_tcl.c
  
  objects/integration.o: integration.c
  	$(CCC) -o $@ integration.c
***************
*** 3095,3101 ****
  	$(CCC) -o $@ ops.c
  
  objects/option.o: option.c
! 	$(CCC) $(LUA_CFLAGS) $(PERL_CFLAGS) $(PYTHON_CFLAGS) $(PYTHON3_CFLAGS) $(RUBY_CFLAGS) $(TCL_CFLAGS) -o $@ option.c
  
  objects/os_beos.o: os_beos.c
  	$(CCC) -o $@ os_beos.c
--- 3098,3104 ----
  	$(CCC) -o $@ ops.c
  
  objects/option.o: option.c
! 	$(CCC_NF) $(LUA_CFLAGS) $(PERL_CFLAGS) $(PYTHON_CFLAGS) $(PYTHON3_CFLAGS) $(RUBY_CFLAGS) $(TCL_CFLAGS) $(ALL_CFLAGS) -o $@ option.c
  
  objects/os_beos.o: os_beos.c
  	$(CCC) -o $@ os_beos.c
*** ../vim-8.0.0202/src/version.c	2017-01-17 18:14:50.670847138 +0100
--- src/version.c	2017-01-17 19:18:01.165262397 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     203,
  /**/

-- 
Linux is just like a wigwam: no Windows, no Gates and an Apache inside.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0204
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0204
Problem:    Compiler warns for uninitialized variable. (Tony Mechelynck)
Solution:   When skipping set "id" to -1.
Files:      src/syntax.c


*** ../vim-8.0.0203/src/syntax.c	2017-01-17 17:44:42.298734441 +0100
--- src/syntax.c	2017-01-17 19:46:25.721490343 +0100
***************
*** 6049,6055 ****
  	    }
  	    else if (name[1] == '@')
  	    {
! 		if (!skip)
  		    id = syn_check_cluster(name + 2, (int)(end - p - 1));
  	    }
  	    else
--- 6049,6057 ----
  	    }
  	    else if (name[1] == '@')
  	    {
! 		if (skip)
! 		    id = -1;
! 		else
  		    id = syn_check_cluster(name + 2, (int)(end - p - 1));
  	    }
  	    else
*** ../vim-8.0.0203/src/version.c	2017-01-17 19:20:10.324367712 +0100
--- src/version.c	2017-01-17 19:47:38.828987573 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     204,
  /**/

-- 
DINGO: Wicked wicked Zoot ... she is a bad person and she must pay the
       penalty.  And here in Castle Anthrax, we have but one punishment
       ... you must tie her down on a bed ... and spank her.  Come!
GIRLS: A spanking!  A spanking!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0205
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0205
Problem:    After :undojoin some commands don't work properly, such as :redo.
            (Matthew Malcomson)
Solution:   Don't set curbuf->b_u_curhead. (closes #1390)
Files:      src/undo.c, src/testdir/test_undo.vim


*** ../vim-8.0.0204/src/undo.c	2017-01-07 16:14:53.894018391 +0100
--- src/undo.c	2017-01-17 22:03:50.468649795 +0100
***************
*** 3136,3146 ****
      if (get_undolevel() < 0)
  	return;		    /* no entries, nothing to do */
      else
!     {
! 	/* Go back to the last entry */
! 	curbuf->b_u_curhead = curbuf->b_u_newhead;
! 	curbuf->b_u_synced = FALSE;  /* no entries, nothing to do */
!     }
  }
  
  /*
--- 3136,3143 ----
      if (get_undolevel() < 0)
  	return;		    /* no entries, nothing to do */
      else
! 	/* Append next change to the last entry */
! 	curbuf->b_u_synced = FALSE;
  }
  
  /*
*** ../vim-8.0.0204/src/testdir/test_undo.vim	2017-01-07 16:14:53.894018391 +0100
--- src/testdir/test_undo.vim	2017-01-17 22:02:50.441060228 +0100
***************
*** 176,182 ****
    call assert_equal(['aaaa', 'bbbb', 'cccc'], getline(2, '$'))
    call feedkeys("u", 'xt')
    call assert_equal(['aaaa'], getline(2, '$'))
!   close!
  endfunc
  
  func Test_undo_write()
--- 176,192 ----
    call assert_equal(['aaaa', 'bbbb', 'cccc'], getline(2, '$'))
    call feedkeys("u", 'xt')
    call assert_equal(['aaaa'], getline(2, '$'))
!   bwipe!
! endfunc
! 
! func Test_undojoin_redo()
!   new
!   call setline(1, ['first line', 'second line'])
!   call feedkeys("ixx\<Esc>", 'xt')
!   call feedkeys(":undojoin | redo\<CR>", 'xt')
!   call assert_equal('xxfirst line', getline(1))
!   call assert_equal('second line', getline(2))
!   bwipe!
  endfunc
  
  func Test_undo_write()
*** ../vim-8.0.0204/src/version.c	2017-01-17 19:48:48.132511120 +0100
--- src/version.c	2017-01-17 22:07:32.251134690 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     205,
  /**/

-- 
DINGO:   You must spank her well and after you have spanked her you
         may deal with her as you like and then ... spank me.
AMAZING: And spank me!
STUNNER: And me.
LOVELY:  And me.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0206
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0206
Problem:    Test coverage for :retab insufficient.
Solution:   Add test for :retab. (Dominique Pelle, closes #1391)
Files:      src/Makefile, src/testdir/Make_all.mak, src/testdir/test_retab.vim


*** ../vim-8.0.0205/src/Makefile	2017-01-17 19:20:10.324367712 +0100
--- src/Makefile	2017-01-17 22:14:18.036361852 +0100
***************
*** 2154,2159 ****
--- 2154,2160 ----
  	test_regexp_latin \
  	test_regexp_utf8 \
  	test_reltime \
+ 	test_retab \
  	test_ruby \
  	test_search \
  	test_searchpos \
*** ../vim-8.0.0205/src/testdir/Make_all.mak	2017-01-15 15:22:14.162467173 +0100
--- src/testdir/Make_all.mak	2017-01-17 22:12:37.317050177 +0100
***************
*** 177,182 ****
--- 177,183 ----
  	    test_perl.res \
  	    test_profile.res \
  	    test_quickfix.res \
+ 	    test_retab.res \
  	    test_ruby.res \
  	    test_search.res \
  	    test_signs.res \
*** ../vim-8.0.0205/src/testdir/test_retab.vim	2017-01-17 22:15:19.851939374 +0100
--- src/testdir/test_retab.vim	2017-01-17 22:12:37.317050177 +0100
***************
*** 0 ****
--- 1,77 ----
+ " Test :retab
+ func SetUp()
+   new
+   call setline(1, "\ta  \t    b        c    ")
+ endfunc
+ 
+ func TearDown()
+   bwipe!
+ endfunc
+ 
+ func Retab(bang, n)
+   let l:old_tabstop = &tabstop
+   let l:old_line = getline(1)
+   exe "retab" . a:bang . a:n
+   let l:line = getline(1)
+   call setline(1, l:old_line)
+   if a:n > 0
+     " :retab changes 'tabstop' to n with argument n > 0.
+     call assert_equal(a:n, &tabstop)
+     exe 'set tabstop=' . l:old_tabstop
+   else
+     " :retab does not change 'tabstop' with empty or n <= 0.
+     call assert_equal(l:old_tabstop, &tabstop)
+   endif
+   return l:line
+ endfunc
+ 
+ func Test_retab()
+   set tabstop=8 noexpandtab
+   call assert_equal("\ta\t    b        c    ",            Retab('',  ''))
+   call assert_equal("\ta\t    b        c    ",            Retab('',  0))
+   call assert_equal("\ta\t    b        c    ",            Retab('',  8))
+   call assert_equal("\ta\t    b\t     c\t  ",             Retab('!', ''))
+   call assert_equal("\ta\t    b\t     c\t  ",             Retab('!', 0))
+   call assert_equal("\ta\t    b\t     c\t  ",             Retab('!', 8))
+ 
+   call assert_equal("\t\ta\t\t\tb        c    ",          Retab('',  4))
+   call assert_equal("\t\ta\t\t\tb\t\t c\t  ",             Retab('!', 4))
+ 
+   call assert_equal("        a\t\tb        c    ",        Retab('',  10))
+   call assert_equal("        a\t\tb        c    ",        Retab('!', 10))
+ 
+   set tabstop=8 expandtab
+   call assert_equal("        a           b        c    ", Retab('',  ''))
+   call assert_equal("        a           b        c    ", Retab('',  0))
+   call assert_equal("        a           b        c    ", Retab('',  8))
+   call assert_equal("        a           b        c    ", Retab('!', ''))
+   call assert_equal("        a           b        c    ", Retab('!', 0))
+   call assert_equal("        a           b        c    ", Retab('!', 8))
+ 
+   call assert_equal("        a           b        c    ", Retab(' ', 4))
+   call assert_equal("        a           b        c    ", Retab('!', 4))
+ 
+   call assert_equal("        a           b        c    ", Retab(' ', 10))
+   call assert_equal("        a           b        c    ", Retab('!', 10))
+ 
+   set tabstop=4 noexpandtab
+   call assert_equal("\ta\t\tb        c    ",              Retab('',  ''))
+   call assert_equal("\ta\t\tb\t\t c\t  ",                 Retab('!', ''))
+   call assert_equal("\t a\t\t\tb        c    ",           Retab('',  3))
+   call assert_equal("\t a\t\t\tb\t\t\tc\t  ",             Retab('!', 3))
+   call assert_equal("    a\t  b        c    ",            Retab('',  5))
+   call assert_equal("    a\t  b\t\t c\t ",                Retab('!', 5))
+ 
+   set tabstop=4 expandtab
+   call assert_equal("    a       b        c    ",         Retab('',  ''))
+   call assert_equal("    a       b        c    ",         Retab('!', ''))
+   call assert_equal("    a       b        c    ",         Retab('',  3))
+   call assert_equal("    a       b        c    ",         Retab('!', 3))
+   call assert_equal("    a       b        c    ",         Retab('',  5))
+   call assert_equal("    a       b        c    ",         Retab('!', 5))
+ endfunc
+ 
+ func Test_retab_error()
+   call assert_fails('retab -1',  'E487:')
+   call assert_fails('retab! -1', 'E487:')
+ endfunc
*** ../vim-8.0.0205/src/version.c	2017-01-17 22:09:41.310252893 +0100
--- src/version.c	2017-01-17 22:13:47.000573959 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     206,
  /**/

-- 
DINGO:   And after the spanking ... the oral sex.
GALAHAD: Oh, dear! Well, I...
GIRLS:   The oral sex ...  The oral sex.
GALAHAD: Well, I suppose I could stay a BIT longer.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0207
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0207
Problem:    Leaking file descriptor when system() cannot find the buffer.
            (Coverity)
Solution:   Close the file descriptor.  (Dominique Pelle, closes #1398)
Files:      src/evalfunc.c


*** ../vim-8.0.0206/src/evalfunc.c	2017-01-17 16:45:00.170121773 +0100
--- src/evalfunc.c	2017-01-20 19:55:08.793298721 +0100
***************
*** 11832,11837 ****
--- 11832,11838 ----
  	    if (buf == NULL)
  	    {
  		EMSGN(_(e_nobufnr), argvars[1].vval.v_number);
+ 		fclose(fd);
  		goto errret;
  	    }
  
*** ../vim-8.0.0206/src/version.c	2017-01-17 22:15:42.451784910 +0100
--- src/version.c	2017-01-20 19:57:54.104162957 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     207,
  /**/

-- 
"My particular problem is with registry entries, which seem to just
accumulate like plastic coffee cups..."           -- Paul Moore

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0208
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0208
Problem:    Internally used commands for CTRL-Z and mouse click end up in
            history. (Matthew Malcomson)
Solution:   Use do_cmdline_cmd() instead of stuffing them in the readahead
            buffer. (James McCoy, closes #1395)
Files:      src/edit.c, src/normal.c


*** ../vim-8.0.0207/src/edit.c	2016-12-09 19:36:52.353659104 +0100
--- src/edit.c	2017-01-20 21:47:17.828507538 +0100
***************
*** 1025,1031 ****
  	case Ctrl_Z:	/* suspend when 'insertmode' set */
  	    if (!p_im)
  		goto normalchar;	/* insert CTRL-Z as normal char */
! 	    stuffReadbuff((char_u *)":st\r");
  	    c = Ctrl_O;
  	    /*FALLTHROUGH*/
  
--- 1025,1031 ----
  	case Ctrl_Z:	/* suspend when 'insertmode' set */
  	    if (!p_im)
  		goto normalchar;	/* insert CTRL-Z as normal char */
! 	    do_cmdline_cmd((char_u *)"stop");
  	    c = Ctrl_O;
  	    /*FALLTHROUGH*/
  
*** ../vim-8.0.0207/src/normal.c	2017-01-14 14:28:26.960592303 +0100
--- src/normal.c	2017-01-20 21:47:26.552449734 +0100
***************
*** 2982,2990 ****
  	if (State & INSERT)
  	    stuffcharReadbuff(Ctrl_O);
  	if (curwin->w_llist_ref == NULL)	/* quickfix window */
! 	    stuffReadbuff((char_u *)":.cc\n");
  	else					/* location list window */
! 	    stuffReadbuff((char_u *)":.ll\n");
  	got_click = FALSE;		/* ignore drag&release now */
      }
  #endif
--- 2982,2990 ----
  	if (State & INSERT)
  	    stuffcharReadbuff(Ctrl_O);
  	if (curwin->w_llist_ref == NULL)	/* quickfix window */
! 	    do_cmdline_cmd((char_u *)".cc");
  	else					/* location list window */
! 	    do_cmdline_cmd((char_u *)".ll");
  	got_click = FALSE;		/* ignore drag&release now */
      }
  #endif
*** ../vim-8.0.0207/src/version.c	2017-01-20 19:59:47.987380517 +0100
--- src/version.c	2017-01-20 21:46:04.992990057 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     208,
  /**/

-- 
Back up my hard drive?  I can't find the reverse switch!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0209
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0209
Problem:    When using :substitute with the "c" flag and 'cursorbind' is set
            the cursor is not updated in other windows.
Solution:   Call do_check_cursorbind(). (Masanori Misono)
Files:      src/ex_cmds.c


*** ../vim-8.0.0208/src/ex_cmds.c	2017-01-13 21:59:59.323172116 +0100
--- src/ex_cmds.c	2017-01-21 14:35:23.935159658 +0100
***************
*** 5263,5268 ****
--- 5263,5272 ----
  		    setmouse();		/* disable mouse in xterm */
  #endif
  		    curwin->w_cursor.col = regmatch.startpos[0].col;
+ #ifdef FEAT_CURSORBIND
+ 		    if (curwin->w_p_crb)
+ 			do_check_cursorbind();
+ #endif
  
  		    /* When 'cpoptions' contains "u" don't sync undo when
  		     * asking for confirmation. */
*** ../vim-8.0.0208/src/version.c	2017-01-20 21:51:46.130731009 +0100
--- src/version.c	2017-01-21 14:43:22.419970962 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     209,
  /**/

-- 
TALL KNIGHT: We shall say Ni! again to you if you do not appease us.
ARTHUR:      All right!  What do you want?
TALL KNIGHT: We want ... a shrubbery!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0210
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0210
Problem:    Vim does not support bracketed paste, as implemented by xterm and
            other terminals.
Solution:   Add t_BE, t_BD, t_PS and t_PE.
Files:      src/term.c, src/term.h, src/option.c, src/misc2.c, src/keymap.h,
            src/edit.c, src/normal.c, src/evalfunc.c, src/getchar.c,
	    src/vim.h, src/proto/edit.pro, runtime/doc/term.txt


*** ../vim-8.0.0209/src/term.c	2017-01-06 18:16:15.632490849 +0100
--- src/term.c	2017-01-21 20:00:45.628203646 +0100
***************
*** 857,862 ****
--- 857,864 ----
      {(int)KS_8F,	IF_EB("\033[38;2;%lu;%lu;%lum", ESC_STR "[38;2;%lu;%lu;%lum")},
      {(int)KS_8B,	IF_EB("\033[48;2;%lu;%lu;%lum", ESC_STR "[48;2;%lu;%lu;%lum")},
  #  endif
+     {(int)KS_CBE,	IF_EB("\033[?2004h", ESC_STR "[?2004h")},
+     {(int)KS_CBD,	IF_EB("\033[?2004l", ESC_STR "[?2004l")},
  
      {K_UP,		IF_EB("\033O*A", ESC_STR "O*A")},
      {K_DOWN,		IF_EB("\033O*B", ESC_STR "O*B")},
***************
*** 902,914 ****
      {K_ZEND,		IF_EB("\033[8;*~", ESC_STR "[8;*~")},
      {K_PAGEUP,		IF_EB("\033[5;*~", ESC_STR "[5;*~")},
      {K_PAGEDOWN,	IF_EB("\033[6;*~", ESC_STR "[6;*~")},
!     {K_KPLUS,		IF_EB("\033O*k", ESC_STR "O*k")},	/* keypad plus */
!     {K_KMINUS,		IF_EB("\033O*m", ESC_STR "O*m")},	/* keypad minus */
!     {K_KDIVIDE,		IF_EB("\033O*o", ESC_STR "O*o")},	/* keypad / */
!     {K_KMULTIPLY,	IF_EB("\033O*j", ESC_STR "O*j")},	/* keypad * */
!     {K_KENTER,		IF_EB("\033O*M", ESC_STR "O*M")},	/* keypad Enter */
!     {K_KPOINT,		IF_EB("\033O*n", ESC_STR "O*n")},	/* keypad . */
!     {K_KDEL,		IF_EB("\033[3;*~", ESC_STR "[3;*~")},	/* keypad Del */
  
      {BT_EXTRA_KEYS,   ""},
      {TERMCAP2KEY('k', '0'), IF_EB("\033[10;*~", ESC_STR "[10;*~")}, /* F0 */
--- 904,918 ----
      {K_ZEND,		IF_EB("\033[8;*~", ESC_STR "[8;*~")},
      {K_PAGEUP,		IF_EB("\033[5;*~", ESC_STR "[5;*~")},
      {K_PAGEDOWN,	IF_EB("\033[6;*~", ESC_STR "[6;*~")},
!     {K_KPLUS,		IF_EB("\033O*k", ESC_STR "O*k")},     /* keypad plus */
!     {K_KMINUS,		IF_EB("\033O*m", ESC_STR "O*m")},     /* keypad minus */
!     {K_KDIVIDE,		IF_EB("\033O*o", ESC_STR "O*o")},     /* keypad / */
!     {K_KMULTIPLY,	IF_EB("\033O*j", ESC_STR "O*j")},     /* keypad * */
!     {K_KENTER,		IF_EB("\033O*M", ESC_STR "O*M")},     /* keypad Enter */
!     {K_KPOINT,		IF_EB("\033O*n", ESC_STR "O*n")},     /* keypad . */
!     {K_KDEL,		IF_EB("\033[3;*~", ESC_STR "[3;*~")}, /* keypad Del */
!     {K_PS,		IF_EB("\033[200~", ESC_STR "[200~")}, /* paste start */
!     {K_PE,		IF_EB("\033[201~", ESC_STR "[201~")}, /* paste end */
  
      {BT_EXTRA_KEYS,   ""},
      {TERMCAP2KEY('k', '0'), IF_EB("\033[10;*~", ESC_STR "[10;*~")}, /* F0 */
***************
*** 1224,1229 ****
--- 1228,1235 ----
      {K_KMULTIPLY,	"[KMULTIPLY]"},
      {K_KENTER,		"[KENTER]"},
      {K_KPOINT,		"[KPOINT]"},
+     {K_PS,		"[PASTE-START]"},
+     {K_PE,		"[PASTE-END]"},
      {K_K0,		"[K0]"},
      {K_K1,		"[K1]"},
      {K_K2,		"[K2]"},
***************
*** 1538,1543 ****
--- 1544,1551 ----
  				{KS_CSI, "SI"}, {KS_CEI, "EI"},
  				{KS_U7, "u7"}, {KS_RBG, "RB"},
  				{KS_8F, "8f"}, {KS_8B, "8b"},
+ 				{KS_CBE, "BE"}, {KS_CBD, "BD"},
+ 				{KS_CPS, "PS"}, {KS_CPE, "PE"},
  				{(enum SpecialKey)0, NULL}
  			    };
  
***************
*** 3140,3145 ****
--- 3148,3154 ----
      {
  	out_str(T_TI);			/* start termcap mode */
  	out_str(T_KS);			/* start "keypad transmit" mode */
+ 	out_str(T_BE);			/* enable bracketed paste moe */
  	out_flush();
  	termcap_active = TRUE;
  	screen_start();			/* don't know where cursor is now */
***************
*** 3189,3194 ****
--- 3198,3204 ----
  	    check_for_codes_from_term();
  	}
  #endif
+ 	out_str(T_BD);			/* disable bracketed paste moe */
  	out_str(T_KE);			/* stop "keypad transmit" mode */
  	out_flush();
  	termcap_active = FALSE;
*** ../vim-8.0.0209/src/term.h	2016-08-29 22:42:20.000000000 +0200
--- src/term.h	2017-01-21 16:34:00.936095982 +0100
***************
*** 89,98 ****
      KS_OP,	/* original color pair */
      KS_U7,	/* request cursor position */
      KS_8F,	/* set foreground color (RGB) */
!     KS_8B	/* set background color (RGB) */
  };
  
! #define KS_LAST	    KS_8B
  
  /*
   * the terminal capabilities are stored in this array
--- 89,102 ----
      KS_OP,	/* original color pair */
      KS_U7,	/* request cursor position */
      KS_8F,	/* set foreground color (RGB) */
!     KS_8B,	/* set background color (RGB) */
!     KS_CBE,	/* enable bracketed paste mode */
!     KS_CBD,	/* disable bracketed paste mode */
!     KS_CPS,	/* start of brackted paste */
!     KS_CPE	/* end of brackted paste */
  };
  
! #define KS_LAST	    KS_CPE
  
  /*
   * the terminal capabilities are stored in this array
***************
*** 170,175 ****
--- 174,183 ----
  #define T_U7	(term_str(KS_U7))	/* request cursor position */
  #define T_8F	(term_str(KS_8F))	/* set foreground color (RGB) */
  #define T_8B	(term_str(KS_8B))	/* set background color (RGB) */
+ #define T_BE	(term_str(KS_CBE))	/* enable bracketed paste mode */
+ #define T_BD	(term_str(KS_CBD))	/* disable bracketed paste mode */
+ #define T_PS	(term_str(KS_CPS))	/* start of bracketed paste */
+ #define T_PE	(term_str(KS_CPE))	/* end of bracketed paste */
  
  #define TMODE_COOK  0	/* terminal mode for external cmds and Ex mode */
  #define TMODE_SLEEP 1	/* terminal mode for sleeping (cooked but no echo) */
*** ../vim-8.0.0209/src/option.c	2017-01-14 14:28:26.956592328 +0100
--- src/option.c	2017-01-21 15:34:59.567463663 +0100
***************
*** 3040,3045 ****
--- 3040,3047 ----
      p_term("t_ZR", T_CZR)
      p_term("t_8f", T_8F)
      p_term("t_8b", T_8B)
+     p_term("t_BE", T_BE)
+     p_term("t_BD", T_BD)
  
  /* terminal key codes are not in here */
  
*** ../vim-8.0.0209/src/misc2.c	2017-01-10 13:51:05.587236267 +0100
--- src/misc2.c	2017-01-21 15:43:20.460160465 +0100
***************
*** 2294,2299 ****
--- 2294,2301 ----
      {K_XDOWN,		(char_u *)"xDown"},
      {K_XLEFT,		(char_u *)"xLeft"},
      {K_XRIGHT,		(char_u *)"xRight"},
+     {K_PS,		(char_u *)"PasteStart"},
+     {K_PE,		(char_u *)"PasteEnd"},
  
      {K_F1,		(char_u *)"F1"},
      {K_F2,		(char_u *)"F2"},
*** ../vim-8.0.0209/src/keymap.h	2016-08-29 22:42:20.000000000 +0200
--- src/keymap.h	2017-01-21 15:45:55.467135851 +0100
***************
*** 391,396 ****
--- 391,398 ----
  #define K_KMULTIPLY	TERMCAP2KEY('K', '9')	/* keypad * */
  #define K_KENTER	TERMCAP2KEY('K', 'A')	/* keypad Enter */
  #define K_KPOINT	TERMCAP2KEY('K', 'B')	/* keypad . or ,*/
+ #define K_PS		TERMCAP2KEY('P', 'S')	/* paste start */
+ #define K_PE		TERMCAP2KEY('P', 'E')	/* paste end */
  
  #define K_K0		TERMCAP2KEY('K', 'C')	/* keypad 0 */
  #define K_K1		TERMCAP2KEY('K', 'D')	/* keypad 1 */
*** ../vim-8.0.0209/src/edit.c	2017-01-20 21:51:46.130731009 +0100
--- src/edit.c	2017-01-21 19:22:18.064013812 +0100
***************
*** 309,314 ****
--- 309,315 ----
   * "cmdchar" can be:
   * 'i'	normal insert command
   * 'a'	normal append command
+  * K_PS bracketed paste
   * 'R'	replace command
   * 'r'	"r<CR>" command: insert one <CR>.  Note: count can be > 1, for redo,
   *	but still only one <CR> is inserted.  The <Esc> is not used for redo.
***************
*** 782,791 ****
  	    dont_sync_undo = TRUE;
  	else
  	    dont_sync_undo = FALSE;
! 	do
! 	{
! 	    c = safe_vgetc();
! 	} while (c == K_IGNORE);
  
  #ifdef FEAT_AUTOCMD
  	/* Don't want K_CURSORHOLD for the second key, e.g., after CTRL-V. */
--- 783,796 ----
  	    dont_sync_undo = TRUE;
  	else
  	    dont_sync_undo = FALSE;
! 	if (cmdchar == K_PS)
! 	    /* Got here from normal mode when bracketed paste started. */
! 	    c = K_PS;
! 	else
! 	    do
! 	    {
! 		c = safe_vgetc();
! 	    } while (c == K_IGNORE);
  
  #ifdef FEAT_AUTOCMD
  	/* Don't want K_CURSORHOLD for the second key, e.g., after CTRL-V. */
***************
*** 1193,1198 ****
--- 1198,1213 ----
  	    ins_mousescroll(MSCR_RIGHT);
  	    break;
  #endif
+ 	case K_PS:
+ 	    bracketed_paste(PASTE_INSERT, FALSE, NULL);
+ 	    if (cmdchar == K_PS)
+ 		/* invoked from normal mode, bail out */
+ 		goto doESCkey;
+ 	    break;
+ 	case K_PE:
+ 	    /* Got K_PE without K_PS, ignore. */
+ 	    break;
+ 
  #ifdef FEAT_GUI_TABLINE
  	case K_TABLINE:
  	case K_TABMENU:
***************
*** 9424,9429 ****
--- 9439,9529 ----
  }
  #endif
  
+ /*
+  * Handle receiving P_PS: start paste mode.  Inserts the following text up to
+  * P_PE literally.
+  * When "drop" is TRUE then consume the text and drop it.
+  */
+     int
+ bracketed_paste(paste_mode_T mode, int drop, garray_T *gap)
+ {
+     int		c;
+     char_u	buf[NUMBUFLEN + MB_MAXBYTES];
+     int		idx = 0;
+     char_u	*end = find_termcode((char_u *)"PE");
+     int		ret_char = -1;
+     int		save_allow_keys = allow_keys;
+ 
+     /* If the end code is too long we can't detect it, read everything. */
+     if (STRLEN(end) >= NUMBUFLEN)
+ 	end = NULL;
+     ++no_mapping;
+     allow_keys = 0;
+     for (;;)
+     {
+ 	/* When the end is not defined read everything. */
+ 	if (end == NULL && vpeekc() == NUL)
+ 	    break;
+ 	c = plain_vgetc();
+ #ifdef FEAT_MBYTE
+ 	if (has_mbyte)
+ 	    idx += (*mb_char2bytes)(c, buf + idx);
+ 	else
+ #endif
+ 	    buf[idx++] = c;
+ 	buf[idx] = NUL;
+ 	if (end != NUL && STRNCMP(buf, end, idx) == 0)
+ 	{
+ 	    if (end[idx] == NUL)
+ 		break; /* Found the end of paste code. */
+ 	    continue;
+ 	}
+ 	if (!drop)
+ 	{
+ 	    switch (mode)
+ 	    {
+ 		case PASTE_CMDLINE:
+ 		    put_on_cmdline(buf, idx, TRUE);
+ 		    break;
+ 
+ 		case PASTE_EX:
+ 		    if (gap != NULL && ga_grow(gap, idx) == OK)
+ 		    {
+ 			mch_memmove((char *)gap->ga_data + gap->ga_len,
+ 							     buf, (size_t)idx);
+ 			gap->ga_len += idx;
+ 		    }
+ 		    break;
+ 
+ 		case PASTE_INSERT:
+ 		    if (stop_arrow() == OK)
+ 		    {
+ 			ins_char_bytes(buf, idx);
+ 			AppendToRedobuffLit(buf, idx);
+ 		    }
+ 		    break;
+ 
+ 		case PASTE_ONE_CHAR:
+ 		    if (ret_char == -1)
+ 		    {
+ #ifdef FEAT_MBYTE
+ 			if (has_mbyte)
+ 			    ret_char = (*mb_ptr2char)(buf);
+ 			else
+ #endif
+ 			    ret_char = buf[0];
+ 		    }
+ 		    break;
+ 	    }
+ 	}
+ 	idx = 0;
+     }
+     --no_mapping;
+     allow_keys = save_allow_keys;
+ 
+     return ret_char;
+ }
+ 
  #if defined(FEAT_GUI_TABLINE) || defined(PROTO)
      static void
  ins_tabline(int c)
*** ../vim-8.0.0209/src/normal.c	2017-01-20 21:51:46.130731009 +0100
--- src/normal.c	2017-01-21 19:29:47.988909502 +0100
***************
*** 426,431 ****
--- 426,432 ----
  #ifdef FEAT_AUTOCMD
      {K_CURSORHOLD, nv_cursorhold, NV_KEEPREG,		0},
  #endif
+     {K_PS,	nv_edit,	0,			0},
  };
  
  /* Number of commands in nv_cmds[]. */
***************
*** 3858,3864 ****
  	K_VER_SCROLLBAR, K_HOR_SCROLLBAR,
  	K_LEFTMOUSE_NM, K_LEFTRELEASE_NM,
  # endif
! 	K_IGNORE,
  	K_LEFTMOUSE, K_LEFTDRAG, K_LEFTRELEASE,
  	K_MIDDLEMOUSE, K_MIDDLEDRAG, K_MIDDLERELEASE,
  	K_RIGHTMOUSE, K_RIGHTDRAG, K_RIGHTRELEASE,
--- 3859,3865 ----
  	K_VER_SCROLLBAR, K_HOR_SCROLLBAR,
  	K_LEFTMOUSE_NM, K_LEFTRELEASE_NM,
  # endif
! 	K_IGNORE, K_PS,
  	K_LEFTMOUSE, K_LEFTDRAG, K_LEFTRELEASE,
  	K_MIDDLEMOUSE, K_MIDDLEDRAG, K_MIDDLERELEASE,
  	K_RIGHTMOUSE, K_RIGHTDRAG, K_RIGHTRELEASE,
***************
*** 9015,9020 ****
--- 9016,9022 ----
  
  /*
   * Handle "A", "a", "I", "i" and <Insert> commands.
+  * Also handle K_PS, start bracketed paste.
   */
      static void
  nv_edit(cmdarg_T *cap)
***************
*** 9042,9047 ****
--- 9044,9052 ----
  	/* Only give this error when 'insertmode' is off. */
  	EMSG(_(e_modifiable));
  	clearop(cap->oap);
+ 	if (cap->cmdchar == K_PS)
+ 	    /* drop the pasted text */
+ 	    bracketed_paste(PASTE_INSERT, TRUE, NULL);
      }
      else if (!checkclearopq(cap->oap))
      {
***************
*** 9073,9078 ****
--- 9078,9084 ----
  		break;
  
  	    case 'a':	/* "a"ppend is like "i"nsert on the next character. */
+ 	    case K_PS:	/* bracketed paste works like "a"ppend */
  #ifdef FEAT_VIRTUALEDIT
  		/* increment coladd when in virtual space, increment the
  		 * column otherwise, also to append after an unprintable char */
***************
*** 9103,9108 ****
--- 9109,9117 ----
  
  	invoke_edit(cap, FALSE, cap->cmdchar, FALSE);
      }
+     else if (cap->cmdchar == K_PS)
+ 	/* drop the pasted text */
+ 	bracketed_paste(PASTE_INSERT, TRUE, NULL);
  }
  
  /*
*** ../vim-8.0.0209/src/evalfunc.c	2017-01-20 19:59:47.983380544 +0100
--- src/evalfunc.c	2017-01-21 19:37:45.749632870 +0100
***************
*** 4231,4237 ****
      {
  	if (argvars[0].v_type == VAR_UNKNOWN)
  	    /* getchar(): blocking wait. */
! 	    n = safe_vgetc();
  	else if (get_tv_number_chk(&argvars[0], &error) == 1)
  	    /* getchar(1): only check if char avail */
  	    n = vpeekc_any();
--- 4231,4237 ----
      {
  	if (argvars[0].v_type == VAR_UNKNOWN)
  	    /* getchar(): blocking wait. */
! 	    n = plain_vgetc();
  	else if (get_tv_number_chk(&argvars[0], &error) == 1)
  	    /* getchar(1): only check if char avail */
  	    n = vpeekc_any();
***************
*** 4240,4246 ****
  	    n = 0;
  	else
  	    /* getchar(0) and char avail: return char */
! 	    n = safe_vgetc();
  
  	if (n == K_IGNORE)
  	    continue;
--- 4240,4246 ----
  	    n = 0;
  	else
  	    /* getchar(0) and char avail: return char */
! 	    n = plain_vgetc();
  
  	if (n == K_IGNORE)
  	    continue;
*** ../vim-8.0.0209/src/getchar.c	2017-01-10 13:51:05.583236296 +0100
--- src/getchar.c	2017-01-21 19:36:53.673989329 +0100
***************
*** 1817,1822 ****
--- 1817,1828 ----
      {
  	c = safe_vgetc();
      } while (c == K_IGNORE || c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR);
+ 
+     if (c == K_PS)
+ 	/* Only handle the first pasted character.  Drop the rest, since we
+ 	 * don't know what to do with it. */
+ 	c = bracketed_paste(PASTE_ONE_CHAR, FALSE, NULL);
+ 
      return c;
  }
  
***************
*** 1906,1912 ****
  }
  
  /*
!  * get a character:
   * 1. from the stuffbuffer
   *	This is used for abbreviated commands like "D" -> "d$".
   *	Also used to redo a command for ".".
--- 1912,1918 ----
  }
  
  /*
!  * Get a character:
   * 1. from the stuffbuffer
   *	This is used for abbreviated commands like "D" -> "d$".
   *	Also used to redo a command for ".".
*** ../vim-8.0.0209/src/vim.h	2017-01-12 21:44:45.146171805 +0100
--- src/vim.h	2017-01-21 19:05:15.035107243 +0100
***************
*** 2108,2113 ****
--- 2108,2121 ----
      ASSERT_OTHER
  } assert_type_T;
  
+ /* Mode for bracketed_paste(). */
+ typedef enum {
+     PASTE_INSERT,	/* insert mode */
+     PASTE_CMDLINE,	/* command line */
+     PASTE_EX,		/* ex mode line */
+     PASTE_ONE_CHAR	/* return first character */
+ } paste_mode_T;
+ 
  #include "ex_cmds.h"	    /* Ex command defines */
  #include "spell.h"	    /* spell checking stuff */
  
*** ../vim-8.0.0209/src/proto/edit.pro	2016-10-15 17:06:42.090912729 +0200
--- src/proto/edit.pro	2017-01-21 19:03:58.359641105 +0100
***************
*** 38,43 ****
--- 38,44 ----
  void fix_indent(void);
  int in_cinkeys(int keytyped, int when, int line_is_empty);
  int hkmap(int c);
+ int bracketed_paste(paste_mode_T mode, int drop, garray_T *gap);
  void ins_scroll(void);
  void ins_horscroll(void);
  int ins_copychar(linenr_T lnum);
*** ../vim-8.0.0209/runtime/doc/term.txt	2016-09-12 12:45:48.000000000 +0200
--- runtime/doc/term.txt	2017-01-21 19:58:23.397174277 +0100
***************
*** 89,94 ****
--- 89,106 ----
  for a moment.  This means that you can stop the output to the screen by
  hitting a printing key.  Output resumes when you hit <BS>.
  
+ 						*xterm-bracketed-paste*
+ When the 't_BE' option is set then 't_BE' will be sent to the
+ terminal when entering "raw" mode and 't_BD' when leaving "raw" mode.  The
+ terminal is then expected to put 't_PS' before pasted text and 't_PE' after
+ pasted text.  This way Vim can separate text that is pasted from characters
+ that are typed.  The pasted text is handled like when the middle mouse button
+ is used.
+ 
+ Note that in some situations Vim will not recognize the bracketed paste and
+ you will get the raw text.  In other situations Vim will only get the first
+ pasted character and drop the rest, e.g. when using the "r" command.
+ 
  							*cs7-problem*
  Note: If the terminal settings are changed after running Vim, you might have
  an illegal combination of settings.  This has been reported on Solaris 2.5
***************
*** 306,311 ****
--- 318,327 ----
  		|xterm-true-color|
  	t_8b	set background color (R, G, B)			*t_8b* *'t_8b'*
  		|xterm-true-color|
+ 	t_BE	enable bracketed paste mode			*t_BE* *'t_BE'*
+ 		|xterm-bracketed-paste|
+ 	t_BD	disable bracketed paste mode			*t_BD* *'t_BD'*
+ 		|xterm-bracketed-paste|
  
  KEY CODES
  Note: Use the <> form if possible
***************
*** 398,403 ****
--- 414,421 ----
  	t_KK	<k8>		keypad 8		 *<k8>*	*t_KK* *'t_KK'*
  	t_KL	<k9>		keypad 9		 *<k9>*	*t_KL* *'t_KL'*
  		<Mouse>		leader of mouse code		*<Mouse>*
+ 	t_PS	start of brackted paste |xterm-bracketed-paste|   *t_PS* 't_PS'
+ 	t_PE	end of bracketed paste |xterm-bracketed-paste|    *t_PE* 't_PE'
  
  Note about t_so and t_mr: When the termcap entry "so" is not present the
  entry for "mr" is used.  And vice versa.  The same is done for "se" and "me".
*** ../vim-8.0.0209/src/version.c	2017-01-21 14:44:32.531503504 +0100
--- src/version.c	2017-01-21 17:22:39.156736230 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     210,
  /**/

-- 
FATHER:       Make sure the Prince doesn't leave this room until I come and
              get him.
FIRST GUARD:  Not ... to leave the room ... even if you come and get him.
FATHER:       No.  Until I come and get him.
SECOND GUARD: Hic.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0211
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0211 (after 8.0.0210)
Problem:    Build fails if the multi-byte feature is disabled.
Solution:   Change #ifdef around ins_char_bytes.
Files:      src/misc1.c


*** ../vim-8.0.0210/src/misc1.c	2017-01-12 21:44:45.142171836 +0100
--- src/misc1.c	2017-01-21 21:47:16.948216111 +0100
***************
*** 2177,2192 ****
      void
  ins_char(int c)
  {
- #if defined(FEAT_MBYTE) || defined(PROTO)
      char_u	buf[MB_MAXBYTES + 1];
!     int		n;
  
      n = (*mb_char2bytes)(c, buf);
  
      /* When "c" is 0x100, 0x200, etc. we don't want to insert a NUL byte.
       * Happens for CTRL-Vu9900. */
      if (buf[0] == 0)
  	buf[0] = '\n';
  
      ins_char_bytes(buf, n);
  }
--- 2177,2195 ----
      void
  ins_char(int c)
  {
      char_u	buf[MB_MAXBYTES + 1];
!     int		n = 1;
  
+ #if defined(FEAT_MBYTE) || defined(PROTO)
      n = (*mb_char2bytes)(c, buf);
  
      /* When "c" is 0x100, 0x200, etc. we don't want to insert a NUL byte.
       * Happens for CTRL-Vu9900. */
      if (buf[0] == 0)
  	buf[0] = '\n';
+ #else
+     buf[0] = c;
+ #endif
  
      ins_char_bytes(buf, n);
  }
***************
*** 2195,2201 ****
  ins_char_bytes(char_u *buf, int charlen)
  {
      int		c = buf[0];
- #endif
      int		newlen;		/* nr of bytes inserted */
      int		oldlen;		/* nr of bytes deleted (0 when not replacing) */
      char_u	*p;
--- 2198,2203 ----
***************
*** 2218,2228 ****
  
      /* The lengths default to the values for when not replacing. */
      oldlen = 0;
- #ifdef FEAT_MBYTE
      newlen = charlen;
- #else
-     newlen = 1;
- #endif
  
      if (State & REPLACE_FLAG)
      {
--- 2220,2226 ----
*** ../vim-8.0.0210/src/version.c	2017-01-21 20:04:17.570757762 +0100
--- src/version.c	2017-01-21 22:49:46.558730896 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     211,
  /**/

-- 
Just think of all the things we haven't thought of yet.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0212
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0212
Problem:    The buffer used to store a key name theoreticaly could be too
            small. (Coverity)
Solution:   Count all possible modifier characters.  Add a check for the
            length just in case.
Files:      src/keymap.h, src/misc2.c


*** ../vim-8.0.0211/src/keymap.h	2017-01-21 20:04:17.562757816 +0100
--- src/keymap.h	2017-01-22 14:48:17.014376869 +0100
***************
*** 482,490 ****
  
  /*
   * The length of the longest special key name, including modifiers.
!  * Current longest is <M-C-S-T-4-MiddleRelease> (length includes '<' and '>').
   */
! #define MAX_KEY_NAME_LEN    25
  
  /* Maximum length of a special key event as tokens.  This includes modifiers.
   * The longest event is something like <M-C-S-T-4-LeftDrag> which would be the
--- 482,491 ----
  
  /*
   * The length of the longest special key name, including modifiers.
!  * Current longest is <M-C-S-T-D-A-4-ScrollWheelRight> (length includes '<' and
!  * '>').
   */
! #define MAX_KEY_NAME_LEN    32
  
  /* Maximum length of a special key event as tokens.  This includes modifiers.
   * The longest event is something like <M-C-S-T-4-LeftDrag> which would be the
*** ../vim-8.0.0211/src/misc2.c	2017-01-21 20:04:17.562757816 +0100
--- src/misc2.c	2017-01-22 15:05:01.588040025 +0100
***************
*** 2162,2167 ****
--- 2162,2168 ----
      /* 'A' must be the last one */
      {MOD_MASK_ALT,		MOD_MASK_ALT,		(char_u)'A'},
      {0, 0, NUL}
+     /* NOTE: when adding an entry, update MAX_KEY_NAME_LEN! */
  };
  
  /*
***************
*** 2431,2436 ****
--- 2432,2438 ----
      {K_PLUG,		(char_u *)"Plug"},
      {K_CURSORHOLD,	(char_u *)"CursorHold"},
      {0,			NULL}
+     /* NOTE: When adding a long name update MAX_KEY_NAME_LEN. */
  };
  
  #define KEY_NAMES_TABLE_LEN (sizeof(key_names_table) / sizeof(struct key_name_entry))
***************
*** 2659,2666 ****
      }
      else		/* use name of special key */
      {
! 	STRCPY(string + idx, key_names_table[table_idx].name);
! 	idx = (int)STRLEN(string);
      }
      string[idx++] = '>';
      string[idx] = NUL;
--- 2661,2673 ----
      }
      else		/* use name of special key */
      {
! 	size_t len = STRLEN(key_names_table[table_idx].name);
! 
! 	if (len + idx + 2 <= MAX_KEY_NAME_LEN)
! 	{
! 	    STRCPY(string + idx, key_names_table[table_idx].name);
! 	    idx += (int)len;
! 	}
      }
      string[idx++] = '>';
      string[idx] = NUL;
*** ../vim-8.0.0211/src/version.c	2017-01-21 22:49:56.142666237 +0100
--- src/version.c	2017-01-22 15:03:49.780492910 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     212,
  /**/

-- 
You had connectors?  Eeee, when I were a lad we 'ad to carry the
bits between the computer and the terminal with a spoon...

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0213
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0213
Problem:    The Netbeans "specialKeys" command does not check if the argument
            fits in the buffer. (Coverity)
Solution:   Add a length check.
Files:      src/netbeans.c


*** ../vim-8.0.0212/src/netbeans.c	2016-09-25 21:44:59.441600148 +0200
--- src/netbeans.c	2017-01-22 15:13:57.392651105 +0100
***************
*** 2332,2338 ****
      char *save_str = nb_unquote(args, NULL);
      char *tok = strtok(save_str, " ");
      char *sep;
!     char keybuf[64];
      char cmdbuf[256];
  
      while (tok != NULL)
--- 2332,2339 ----
      char *save_str = nb_unquote(args, NULL);
      char *tok = strtok(save_str, " ");
      char *sep;
! #define KEYBUFLEN 64
!     char keybuf[KEYBUFLEN];
      char cmdbuf[256];
  
      while (tok != NULL)
***************
*** 2359,2368 ****
  	    tok++;
  	}
  
! 	strcpy(&keybuf[i], tok);
! 	vim_snprintf(cmdbuf, sizeof(cmdbuf),
! 				"<silent><%s> :nbkey %s<CR>", keybuf, keybuf);
! 	do_map(0, (char_u *)cmdbuf, NORMAL, FALSE);
  	tok = strtok(NULL, " ");
      }
      vim_free(save_str);
--- 2360,2372 ----
  	    tok++;
  	}
  
! 	if (strlen(tok) + i < KEYBUFLEN)
! 	{
! 	    strcpy(&keybuf[i], tok);
! 	    vim_snprintf(cmdbuf, sizeof(cmdbuf),
! 				 "<silent><%s> :nbkey %s<CR>", keybuf, keybuf);
! 	    do_map(0, (char_u *)cmdbuf, NORMAL, FALSE);
! 	}
  	tok = strtok(NULL, " ");
      }
      vim_free(save_str);
*** ../vim-8.0.0212/src/version.c	2017-01-22 15:05:08.107998905 +0100
--- src/version.c	2017-01-22 15:15:21.020120297 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     213,
  /**/

-- 
You were lucky to have a LAKE! There were a hundred and sixty of
us living in a small shoebox in the middle of the road.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0214
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0214
Problem:    Leaking memory when syntax cluster id is unknown. (Coverity)
Solution:   Free the memory.
Files:      src/syntax.c


*** ../vim-8.0.0213/src/syntax.c	2017-01-17 19:48:48.132511120 +0100
--- src/syntax.c	2017-01-22 15:24:16.324723771 +0100
***************
*** 5668,5673 ****
--- 5668,5675 ----
  	    if (scl_id >= 0)
  		syn_combine_list(&SYN_CLSTR(curwin->w_s)[scl_id].scl_list,
  			     &clstr_list, list_op);
+ 	    else
+ 		vim_free(clstr_list);
  	    got_clstr = TRUE;
  	}
  
***************
*** 6034,6040 ****
  		}
  		if (count != 0)
  		{
! 		    EMSG2(_("E408: %s must be first in contains list"), name + 1);
  		    failed = TRUE;
  		    vim_free(name);
  		    break;
--- 6036,6043 ----
  		}
  		if (count != 0)
  		{
! 		    EMSG2(_("E408: %s must be first in contains list"),
! 								     name + 1);
  		    failed = TRUE;
  		    vim_free(name);
  		    break;
*** ../vim-8.0.0213/src/version.c	2017-01-22 15:19:16.814623922 +0100
--- src/version.c	2017-01-22 15:25:45.504158117 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     214,
  /**/

-- 
Yah, well, we had to carve our electrons out of driftwood we'd
find.  In the winter.  Uphill.  Both ways.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0215
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0215
Problem:    When a Cscope line contains CTRL-L a NULL pointer may be used.
            (Coverity)
Solution:   Don't check for an emacs tag in a cscope line.
Files:      src/tag.c


*** ../vim-8.0.0214/src/tag.c	2017-01-16 20:53:31.154599637 +0100
--- src/tag.c	2017-01-22 15:34:33.960810378 +0100
***************
*** 1752,1759 ****
  	    /*
  	     * Emacs tags line with CTRL-L: New file name on next line.
  	     * The file name is followed by a ','.
  	     */
! 	    if (*lbuf == Ctrl_L)	/* remember etag file name in ebuf */
  	    {
  		is_etag = 1;		/* in case at the start */
  		state = TS_LINEAR;
--- 1752,1760 ----
  	    /*
  	     * Emacs tags line with CTRL-L: New file name on next line.
  	     * The file name is followed by a ','.
+ 	     * Remember etag file name in ebuf.
  	     */
! 	    if (*lbuf == Ctrl_L && !use_cscope)
  	    {
  		is_etag = 1;		/* in case at the start */
  		state = TS_LINEAR;
*** ../vim-8.0.0214/src/version.c	2017-01-22 15:28:47.771002874 +0100
--- src/version.c	2017-01-22 15:35:33.932430614 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     215,
  /**/

-- 
You were lucky. We lived for three months in a brown paper bag in a 
septic tank. We used to have to get up at six o'clock in the morning, 
clean the bag, eat a crust of stale bread, go to work down mill for 
fourteen hours a day week in-week out. When we got home, our Dad
would thrash us to sleep with his belt!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0216
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0216
Problem:    When decoding JSON with a JS style object the JSON test may use a
            NULL pointer. (Coverity)
Solution:   Check for a NULL pointer.
Files:      src/json.c, src/json_test.c


*** ../vim-8.0.0215/src/json.c	2017-01-14 14:36:03.225775105 +0100
--- src/json.c	2017-01-22 15:52:55.897834553 +0100
***************
*** 629,638 ****
  	    key = p = reader->js_buf + reader->js_used;
  	    while (*p != NUL && *p != ':' && *p > ' ')
  		++p;
! 	    cur_item->v_type = VAR_STRING;
! 	    cur_item->vval.v_string = vim_strnsave(key, (int)(p - key));
  	    reader->js_used += (int)(p - key);
- 	    top_item->jd_key = cur_item->vval.v_string;
  	}
  	else
  	{
--- 629,641 ----
  	    key = p = reader->js_buf + reader->js_used;
  	    while (*p != NUL && *p != ':' && *p > ' ')
  		++p;
! 	    if (cur_item != NULL)
! 	    {
! 		cur_item->v_type = VAR_STRING;
! 		cur_item->vval.v_string = vim_strnsave(key, (int)(p - key));
! 		top_item->jd_key = cur_item->vval.v_string;
! 	    }
  	    reader->js_used += (int)(p - key);
  	}
  	else
  	{
***************
*** 1053,1059 ****
  
  /*
   * Decode the JSON from "reader" to find the end of the message.
!  * "options" can be JSON_JS or zero;
   * Return FAIL if the message has a decoding error.
   * Return MAYBE if the message is truncated, need to read more.
   * This only works reliable if the message contains an object, array or
--- 1056,1063 ----
  
  /*
   * Decode the JSON from "reader" to find the end of the message.
!  * "options" can be JSON_JS or zero.
!  * This is only used for testing.
   * Return FAIL if the message has a decoding error.
   * Return MAYBE if the message is truncated, need to read more.
   * This only works reliable if the message contains an object, array or
*** ../vim-8.0.0215/src/json_test.c	2017-01-11 21:50:04.884673277 +0100
--- src/json_test.c	2017-01-22 15:48:50.959384783 +0100
***************
*** 107,112 ****
--- 107,118 ----
      reader.js_buf = (char_u *)"  {   ";
      assert(json_find_end(&reader, 0) == MAYBE);
  
+     /* JS object with white space */
+     reader.js_buf = (char_u *)"  {  a  :  123  }  ";
+     assert(json_find_end(&reader, JSON_JS) == OK);
+     reader.js_buf = (char_u *)"  {  a  :   ";
+     assert(json_find_end(&reader, JSON_JS) == MAYBE);
+ 
      /* array without white space */
      reader.js_buf = (char_u *)"[\"a\",123]";
      assert(json_find_end(&reader, 0) == OK);
*** ../vim-8.0.0215/src/version.c	2017-01-22 15:39:57.170763849 +0100
--- src/version.c	2017-01-22 15:50:42.146681048 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     216,
  /**/

-- 
You got to work at a mill?  Lucky!  I got sent back to work in the
acid-mines for my daily crust of stale bread... which not even the
birds would eat.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0217
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0217 (after 8.0.0215)
Problem:    Build fails without the cscope feature.
Solution:   Add #ifdef.
Files:      src/tag.c


*** ../vim-8.0.0216/src/tag.c	2017-01-22 15:39:57.170763849 +0100
--- src/tag.c	2017-01-22 16:13:02.762181077 +0100
***************
*** 1754,1760 ****
  	     * The file name is followed by a ','.
  	     * Remember etag file name in ebuf.
  	     */
! 	    if (*lbuf == Ctrl_L && !use_cscope)
  	    {
  		is_etag = 1;		/* in case at the start */
  		state = TS_LINEAR;
--- 1754,1764 ----
  	     * The file name is followed by a ','.
  	     * Remember etag file name in ebuf.
  	     */
! 	    if (*lbuf == Ctrl_L
! # ifdef FEAT_CSCOPE
! 				&& !use_cscope
! # endif
! 				)
  	    {
  		is_etag = 1;		/* in case at the start */
  		state = TS_LINEAR;
*** ../vim-8.0.0216/src/version.c	2017-01-22 15:56:21.692532206 +0100
--- src/version.c	2017-01-22 16:11:51.294635029 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     217,
  /**/

-- 
Luxury. We used to have to get out of the lake at three o'clock in the 
morning, clean the lake, eat a handful of hot gravel, go to work at the 
mill every day for tuppence a month, come home, and Dad would beat us 
around the head and neck with a broken bottle, if we were LUCKY!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0218
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0218
Problem:    No command line completion for :cexpr, :cgetexpr, :caddexpr, etc.
Solution:   Make completion work. (Yegappan Lakshmanan)  Add a test.
Files:      src/ex_docmd.c, src/testdir/test_cmdline.vim


*** ../vim-8.0.0217/src/ex_docmd.c	2017-01-13 21:59:59.323172116 +0100
--- src/ex_docmd.c	2017-01-22 16:42:17.871029279 +0100
***************
*** 4109,4114 ****
--- 4109,4120 ----
  	case CMD_echoerr:
  	case CMD_call:
  	case CMD_return:
+ 	case CMD_cexpr:
+ 	case CMD_caddexpr:
+ 	case CMD_cgetexpr:
+ 	case CMD_lexpr:
+ 	case CMD_laddexpr:
+ 	case CMD_lgetexpr:
  	    set_context_for_expression(xp, arg, ea.cmdidx);
  	    break;
  
*** ../vim-8.0.0217/src/testdir/test_cmdline.vim	2016-12-11 21:34:18.156065286 +0100
--- src/testdir/test_cmdline.vim	2017-01-22 16:45:14.337903166 +0100
***************
*** 25,30 ****
--- 25,58 ----
    set nowildmenu
  endfunc
  
+ func Test_expr_completion()
+   if !(has('cmdline_compl') && has('eval'))
+     return
+   endif
+   for cmd in [
+ 	\ 'let a = ',
+ 	\ 'if',
+ 	\ 'elseif',
+ 	\ 'while',
+ 	\ 'for',
+ 	\ 'echo',
+ 	\ 'echon',
+ 	\ 'execute',
+ 	\ 'echomsg',
+ 	\ 'echoerr',
+ 	\ 'call',
+ 	\ 'return',
+ 	\ 'cexpr',
+ 	\ 'caddexpr',
+ 	\ 'cgetexpr',
+ 	\ 'lexpr',
+ 	\ 'laddexpr',
+ 	\ 'lgetexpr']
+     call feedkeys(":" . cmd . " getl\<Tab>\<Home>\"\<CR>", 'xt')
+     call assert_equal('"' . cmd . ' getline(', getreg(':'))
+   endfor
+ endfunc
+ 
  func Test_getcompletion()
    if !has('cmdline_compl')
      return
*** ../vim-8.0.0217/src/version.c	2017-01-22 16:13:30.534004680 +0100
--- src/version.c	2017-01-22 16:46:00.525608464 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     218,
  /**/

-- 
Not too long ago, unzipping in public was illegal...

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0219
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0219
Problem:    Ubsan reports errors for integer overflow.
Solution:   Define macros for minimum and maximum values.  Select an
            expression based on the value. (Mike Williams)
Files:      src/charset.c, src/eval.c, src/evalfunc.c, src/structs.h,
            src/testdir/test_viml.vim


*** ../vim-8.0.0218/src/charset.c	2017-01-10 13:51:05.583236296 +0100
--- src/charset.c	2017-01-22 18:23:56.676226532 +0100
***************
*** 1901,1907 ****
  	    n += 2;	    /* skip over "0b" */
  	while ('0' <= *ptr && *ptr <= '1')
  	{
! 	    un = 2 * un + (unsigned long)(*ptr - '0');
  	    ++ptr;
  	    if (n++ == maxlen)
  		break;
--- 1901,1911 ----
  	    n += 2;	    /* skip over "0b" */
  	while ('0' <= *ptr && *ptr <= '1')
  	{
! 	    /* avoid ubsan error for overflow */
! 	    if (un < UVARNUM_MAX / 2)
! 		un = 2 * un + (unsigned long)(*ptr - '0');
! 	    else
! 		un = UVARNUM_MAX;
  	    ++ptr;
  	    if (n++ == maxlen)
  		break;
***************
*** 1912,1918 ****
  	/* octal */
  	while ('0' <= *ptr && *ptr <= '7')
  	{
! 	    un = 8 * un + (uvarnumber_T)(*ptr - '0');
  	    ++ptr;
  	    if (n++ == maxlen)
  		break;
--- 1916,1926 ----
  	/* octal */
  	while ('0' <= *ptr && *ptr <= '7')
  	{
! 	    /* avoid ubsan error for overflow */
! 	    if (un < UVARNUM_MAX / 8)
! 		un = 8 * un + (uvarnumber_T)(*ptr - '0');
! 	    else
! 		un = UVARNUM_MAX;
  	    ++ptr;
  	    if (n++ == maxlen)
  		break;
***************
*** 1925,1931 ****
  	    n += 2;	    /* skip over "0x" */
  	while (vim_isxdigit(*ptr))
  	{
! 	    un = 16 * un + (uvarnumber_T)hex2nr(*ptr);
  	    ++ptr;
  	    if (n++ == maxlen)
  		break;
--- 1933,1943 ----
  	    n += 2;	    /* skip over "0x" */
  	while (vim_isxdigit(*ptr))
  	{
! 	    /* avoid ubsan error for overflow */
! 	    if (un < UVARNUM_MAX / 16)
! 		un = 16 * un + (uvarnumber_T)hex2nr(*ptr);
! 	    else
! 		un = UVARNUM_MAX;
  	    ++ptr;
  	    if (n++ == maxlen)
  		break;
***************
*** 1936,1942 ****
  	/* decimal */
  	while (VIM_ISDIGIT(*ptr))
  	{
! 	    un = 10 * un + (uvarnumber_T)(*ptr - '0');
  	    ++ptr;
  	    if (n++ == maxlen)
  		break;
--- 1948,1958 ----
  	/* decimal */
  	while (VIM_ISDIGIT(*ptr))
  	{
! 	    /* avoid ubsan error for overflow */
! 	    if (un < UVARNUM_MAX / 10)
! 		un = 10 * un + (uvarnumber_T)(*ptr - '0');
! 	    else
! 		un = UVARNUM_MAX;
  	    ++ptr;
  	    if (n++ == maxlen)
  		break;
***************
*** 1950,1958 ****
      if (nptr != NULL)
      {
  	if (negative)   /* account for leading '-' for decimal numbers */
! 	    *nptr = -(varnumber_T)un;
  	else
  	    *nptr = (varnumber_T)un;
      }
      if (unptr != NULL)
  	*unptr = un;
--- 1966,1984 ----
      if (nptr != NULL)
      {
  	if (negative)   /* account for leading '-' for decimal numbers */
! 	{
! 	    /* avoid ubsan error for overflow */
! 	    if (un > VARNUM_MAX)
! 		*nptr = VARNUM_MIN;
! 	    else
! 		*nptr = -(varnumber_T)un;
! 	}
  	else
+ 	{
+ 	    if (un > VARNUM_MAX)
+ 		un = VARNUM_MAX;
  	    *nptr = (varnumber_T)un;
+ 	}
      }
      if (unptr != NULL)
  	*unptr = un;
*** ../vim-8.0.0218/src/eval.c	2017-01-14 20:06:11.123087733 +0100
--- src/eval.c	2017-01-22 18:18:11.942429692 +0100
***************
*** 4109,4129 ****
  		{
  		    if (n2 == 0)	/* give an error message? */
  		    {
- #ifdef FEAT_NUM64
  			if (n1 == 0)
! 			    n1 = -0x7fffffffffffffffLL - 1; /* similar to NaN */
  			else if (n1 < 0)
! 			    n1 = -0x7fffffffffffffffLL;
  			else
! 			    n1 = 0x7fffffffffffffffLL;
! #else
! 			if (n1 == 0)
! 			    n1 = -0x7fffffffL - 1L;	/* similar to NaN */
! 			else if (n1 < 0)
! 			    n1 = -0x7fffffffL;
! 			else
! 			    n1 = 0x7fffffffL;
! #endif
  		    }
  		    else
  			n1 = n1 / n2;
--- 4109,4120 ----
  		{
  		    if (n2 == 0)	/* give an error message? */
  		    {
  			if (n1 == 0)
! 			    n1 = VARNUM_MIN; /* similar to NaN */
  			else if (n1 < 0)
! 			    n1 = -VARNUM_MAX;
  			else
! 			    n1 = VARNUM_MAX;
  		    }
  		    else
  			n1 = n1 / n2;
*** ../vim-8.0.0218/src/evalfunc.c	2017-01-21 20:04:17.566757789 +0100
--- src/evalfunc.c	2017-01-22 18:18:11.946429667 +0100
***************
*** 3304,3324 ****
  
      if (get_float_arg(argvars, &f) == OK)
      {
! # ifdef FEAT_NUM64
! 	if (f < -0x7fffffffffffffffLL)
! 	    rettv->vval.v_number = -0x7fffffffffffffffLL;
! 	else if (f > 0x7fffffffffffffffLL)
! 	    rettv->vval.v_number = 0x7fffffffffffffffLL;
  	else
  	    rettv->vval.v_number = (varnumber_T)f;
- # else
- 	if (f < -0x7fffffff)
- 	    rettv->vval.v_number = -0x7fffffff;
- 	else if (f > 0x7fffffff)
- 	    rettv->vval.v_number = 0x7fffffff;
- 	else
- 	    rettv->vval.v_number = (varnumber_T)f;
- # endif
      }
  }
  
--- 3304,3315 ----
  
      if (get_float_arg(argvars, &f) == OK)
      {
! 	if (f < -VARNUM_MAX)
! 	    rettv->vval.v_number = -VARNUM_MAX;
! 	else if (f > VARNUM_MAX)
! 	    rettv->vval.v_number = VARNUM_MAX;
  	else
  	    rettv->vval.v_number = (varnumber_T)f;
      }
  }
  
*** ../vim-8.0.0218/src/structs.h	2017-01-14 14:28:26.952592354 +0100
--- src/structs.h	2017-01-22 18:18:11.946429667 +0100
***************
*** 1133,1157 ****
--- 1133,1175 ----
  #  ifdef PROTO
  typedef long		    varnumber_T;
  typedef unsigned long	    uvarnumber_T;
+ #define VARNUM_MIN	    LONG_MIN
+ #define VARNUM_MAX	    LONG_MAX
+ #define UVARNUM_MAX	    ULONG_MAX
  #  else
  typedef __int64		    varnumber_T;
  typedef unsigned __int64    uvarnumber_T;
+ #define VARNUM_MIN	    _I64_MIN
+ #define VARNUM_MAX	    _I64_MAX
+ #define UVARNUM_MAX	    _UI64_MAX
  #  endif
  # elif defined(HAVE_STDINT_H)
  typedef int64_t		    varnumber_T;
  typedef uint64_t	    uvarnumber_T;
+ #define VARNUM_MIN	    INT64_MIN
+ #define VARNUM_MAX	    INT64_MAX
+ #define UVARNUM_MAX	    UINT64_MAX
  # else
  typedef long		    varnumber_T;
  typedef unsigned long	    uvarnumber_T;
+ #define VARNUM_MIN	    LONG_MIN
+ #define VARNUM_MAX	    LONG_MAX
+ #define UVARNUM_MAX	    ULONG_MAX
  # endif
  #else
  /* Use 32-bit Number. */
  # if VIM_SIZEOF_INT <= 3	/* use long if int is smaller than 32 bits */
  typedef long		    varnumber_T;
  typedef unsigned long	    uvarnumber_T;
+ #define VARNUM_MIN	    LONG_MIN
+ #define VARNUM_MAX	    LONG_MAX
+ #define UVARNUM_MAX	    ULONG_MAX
  # else
  typedef int		    varnumber_T;
  typedef unsigned int	    uvarnumber_T;
+ #define VARNUM_MIN	    INT_MIN
+ #define VARNUM_MAX	    INT_MAX
+ #define UVARNUM_MAX	    UINT_MAX
  # endif
  #endif
  
*** ../vim-8.0.0218/src/testdir/test_viml.vim	2017-01-12 22:20:49.461383785 +0100
--- src/testdir/test_viml.vim	2017-01-22 18:18:11.946429667 +0100
***************
*** 1226,1232 ****
  
      call assert_equal( 9223372036854775807,  1 / 0)
      call assert_equal(-9223372036854775807, -1 / 0)
!     call assert_equal(-9223372036854775808,  0 / 0)
  
      call assert_equal( 0x7FFFffffFFFFffff, float2nr( 1.0e150))
      call assert_equal(-0x7FFFffffFFFFffff, float2nr(-1.0e150))
--- 1226,1232 ----
  
      call assert_equal( 9223372036854775807,  1 / 0)
      call assert_equal(-9223372036854775807, -1 / 0)
!     call assert_equal(-9223372036854775807 - 1,  0 / 0)
  
      call assert_equal( 0x7FFFffffFFFFffff, float2nr( 1.0e150))
      call assert_equal(-0x7FFFffffFFFFffff, float2nr(-1.0e150))
*** ../vim-8.0.0218/src/version.c	2017-01-22 16:46:52.253278433 +0100
--- src/version.c	2017-01-22 18:33:21.376620042 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     219,
  /**/

-- 
Q:  Why do ducks have flat feet?
A:  To stamp out forest fires.

Q:  Why do elephants have flat feet?
A:  To stamp out flaming ducks.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0220
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0220
Problem:    Completion for :match does not show "none" and other missing
            highlight names.
Solution:   Skip over cleared entries before checking the index to be at the
            end.
Files:      src/syntax.c, src/testdir/test_cmdline.vim


*** ../vim-8.0.0219/src/syntax.c	2017-01-22 15:28:47.771002874 +0100
--- src/syntax.c	2017-01-22 19:15:52.880238502 +0100
***************
*** 9956,9961 ****
--- 9956,9968 ----
      char_u *
  get_highlight_name(expand_T *xp UNUSED, int idx)
  {
+     if (idx < 0)
+ 	return NULL;
+     /* Items are never removed from the table, skip the ones that were cleared.
+      */
+     while (idx < highlight_ga.ga_len && HL_TABLE()[idx].sg_cleared)
+ 	++idx;
+ 
  #ifdef FEAT_CMDL_COMPL
      if (idx == highlight_ga.ga_len && include_none != 0)
  	return (char_u *)"none";
***************
*** 9968,9979 ****
  							 && include_link != 0)
  	return (char_u *)"clear";
  #endif
-     if (idx < 0)
- 	return NULL;
-     /* Items are never removed from the table, skip the ones that were cleared.
-      */
-     while (idx < highlight_ga.ga_len && HL_TABLE()[idx].sg_cleared)
- 	++idx;
      if (idx >= highlight_ga.ga_len)
  	return NULL;
      return HL_TABLE()[idx].sg_name;
--- 9975,9980 ----
*** ../vim-8.0.0219/src/testdir/test_cmdline.vim	2017-01-22 16:46:52.253278433 +0100
--- src/testdir/test_cmdline.vim	2017-01-22 19:21:35.310030919 +0100
***************
*** 25,32 ****
    set nowildmenu
  endfunc
  
  func Test_expr_completion()
!   if !(has('cmdline_compl') && has('eval'))
      return
    endif
    for cmd in [
--- 25,58 ----
    set nowildmenu
  endfunc
  
+ func Test_match_completion()
+   if !has('cmdline_compl')
+     return
+   endif
+   hi Aardig ctermfg=green
+   call feedkeys(":match \<Tab>\<Home>\"\<CR>", 'xt')
+   call assert_equal('"match Aardig', getreg(':'))
+   call feedkeys(":match \<S-Tab>\<Home>\"\<CR>", 'xt')
+   call assert_equal('"match none', getreg(':'))
+ endfunc
+ 
+ func Test_highlight_completion()
+   if !has('cmdline_compl')
+     return
+   endif
+   hi Aardig ctermfg=green
+   call feedkeys(":hi \<Tab>\<Home>\"\<CR>", 'xt')
+   call assert_equal('"hi Aardig', getreg(':'))
+   call feedkeys(":hi li\<S-Tab>\<Home>\"\<CR>", 'xt')
+   call assert_equal('"hi link', getreg(':'))
+   call feedkeys(":hi d\<S-Tab>\<Home>\"\<CR>", 'xt')
+   call assert_equal('"hi default', getreg(':'))
+   call feedkeys(":hi c\<S-Tab>\<Home>\"\<CR>", 'xt')
+   call assert_equal('"hi clear', getreg(':'))
+ endfunc
+ 
  func Test_expr_completion()
!   if !has('cmdline_compl')
      return
    endif
    for cmd in [
*** ../vim-8.0.0219/src/version.c	2017-01-22 18:34:53.684030783 +0100
--- src/version.c	2017-01-22 19:19:10.810962193 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     220,
  /**/

-- 
Not too long ago, a program was something you watched on TV...

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0221
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0221
Problem:    Checking if PROTO is defined inside a function has no effect.
Solution:   Remove the check for PROTO. (Hirohito Higashi)
Files:      src/misc1.c


*** ../vim-8.0.0220/src/misc1.c	2017-01-21 22:49:56.142666237 +0100
--- src/misc1.c	2017-01-22 19:28:56.659188907 +0100
***************
*** 2180,2186 ****
      char_u	buf[MB_MAXBYTES + 1];
      int		n = 1;
  
! #if defined(FEAT_MBYTE) || defined(PROTO)
      n = (*mb_char2bytes)(c, buf);
  
      /* When "c" is 0x100, 0x200, etc. we don't want to insert a NUL byte.
--- 2180,2186 ----
      char_u	buf[MB_MAXBYTES + 1];
      int		n = 1;
  
! #ifdef FEAT_MBYTE
      n = (*mb_char2bytes)(c, buf);
  
      /* When "c" is 0x100, 0x200, etc. we don't want to insert a NUL byte.
*** ../vim-8.0.0220/src/version.c	2017-01-22 19:25:28.228530629 +0100
--- src/version.c	2017-01-22 19:29:41.518900232 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     221,
  /**/

-- 
What the word 'politics' means: 'Poli' in Latin meaning 'many' and 'tics'
meaning 'bloodsucking creatures'.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0222
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0222
Problem:    When a multi-byte character ends in a zero byte, putting blockwise
            text puts it before the character instead of after it.
Solution:   Use int instead of char for the character under the cursor.
            (Luchr, closes #1403)  Add a test.
Files:      src/ops.c, src/testdir/test_put.vim, src/Makefile,
            src/testdir/test_alot.vim


*** ../vim-8.0.0221/src/ops.c	2017-01-02 17:31:20.606046097 +0100
--- src/ops.c	2017-01-22 19:46:19.756372768 +0100
***************
*** 3550,3556 ****
       */
      if (y_type == MBLOCK)
      {
! 	char	c = gchar_cursor();
  	colnr_T	endcol2 = 0;
  
  	if (dir == FORWARD && c != NUL)
--- 3550,3556 ----
       */
      if (y_type == MBLOCK)
      {
! 	int	c = gchar_cursor();
  	colnr_T	endcol2 = 0;
  
  	if (dir == FORWARD && c != NUL)
*** ../vim-8.0.0221/src/testdir/test_put.vim	2017-01-22 19:50:58.966537022 +0100
--- src/testdir/test_put.vim	2017-01-22 19:46:03.612478400 +0100
***************
*** 0 ****
--- 1,12 ----
+ 
+ func Test_put_block()
+   if !has('multi_byte')
+     return
+   endif
+   new
+   call feedkeys("i\<C-V>u2500\<CR>x\<ESC>", 'x')
+   call feedkeys("\<C-V>y", 'x')
+   call feedkeys("gg0p", 'x')
+   call assert_equal("\u2500x", getline(1))
+   bwipe!
+ endfunc
*** ../vim-8.0.0221/src/Makefile	2017-01-17 22:15:42.451784910 +0100
--- src/Makefile	2017-01-22 19:42:12.029994462 +0100
***************
*** 2150,2155 ****
--- 2150,2156 ----
  	test_perl \
  	test_popup \
  	test_profile \
+ 	test_put \
  	test_quickfix \
  	test_regexp_latin \
  	test_regexp_utf8 \
*** ../vim-8.0.0221/src/testdir/test_alot.vim	2017-01-13 22:30:03.761030349 +0100
--- src/testdir/test_alot.vim	2017-01-22 19:45:15.424793742 +0100
***************
*** 31,36 ****
--- 31,37 ----
  source test_messages.vim
  source test_partial.vim
  source test_popup.vim
+ source test_put.vim
  source test_reltime.vim
  source test_searchpos.vim
  source test_set.vim
*** ../vim-8.0.0221/src/version.c	2017-01-22 19:49:07.983272435 +0100
--- src/version.c	2017-01-22 19:50:04.666897089 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     222,
  /**/

-- 
Not too long ago, compress was something you did to garbage...

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0223
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0223
Problem:    Coverity gets confused by the flags passed to find_tags() and
            warnts for an uninitialized variable.
Solution:   Disallow using cscope and help tags at the same time.
Files:      src/tag.c


*** ../vim-8.0.0222/src/tag.c	2017-01-22 16:13:30.530004705 +0100
--- src/tag.c	2017-01-23 20:38:29.060557457 +0100
***************
*** 1256,1261 ****
--- 1256,1262 ----
   * TAG_REGEXP	  use "pat" as a regexp
   * TAG_NOIC	  don't always ignore case
   * TAG_KEEP_LANG  keep language
+  * TAG_CSCOPE	  use cscope results for tags
   */
      int
  find_tags(
***************
*** 1423,1428 ****
--- 1424,1437 ----
       */
      if (help_only)				/* want tags from help file */
  	curbuf->b_help = TRUE;			/* will be restored later */
+ #ifdef FEAT_CSCOPE
+     else if (use_cscope)
+     {
+ 	/* Make sure we don't mix help and cscope, confuses Coverity. */
+ 	help_only = FALSE;
+ 	curbuf->b_help = FALSE;
+     }
+ #endif
  
      orgpat.len = (int)STRLEN(pat);
  #ifdef FEAT_MULTI_LANG
***************
*** 2281,2287 ****
  		     */
  		    *tagp.tagname_end = NUL;
  		    len = (int)(tagp.tagname_end - tagp.tagname);
! 		    mfp = (char_u *)alloc((int)sizeof(char_u) + len + 10 + ML_EXTRA + 1);
  		    if (mfp != NULL)
  		    {
  			int heuristic;
--- 2290,2297 ----
  		     */
  		    *tagp.tagname_end = NUL;
  		    len = (int)(tagp.tagname_end - tagp.tagname);
! 		    mfp = (char_u *)alloc((int)sizeof(char_u)
! 						    + len + 10 + ML_EXTRA + 1);
  		    if (mfp != NULL)
  		    {
  			int heuristic;
*** ../vim-8.0.0222/src/version.c	2017-01-22 20:04:36.493131648 +0100
--- src/version.c	2017-01-23 20:39:45.568045344 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     223,
  /**/

-- 
FATHER:    Who are you?
PRINCE:    I'm ... your son ...
FATHER:    Not you.
LAUNCELOT: I'm ... er ... Sir Launcelot, sir.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0224
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0224
Problem:    When 'fileformats' is changed in a BufReadPre auto command, it
            does not take effect in readfile(). (Gary Johnson)
Solution:   Check the value of 'fileformats' after executing auto commands.
            (Christian Brabandt)
Files:      src/fileio.c, src/testdir/test_fileformat.vim


*** ../vim-8.0.0223/src/fileio.c	2017-01-13 21:59:59.327172086 +0100
--- src/fileio.c	2017-01-23 21:24:28.482126938 +0100
***************
*** 274,282 ****
      int		msg_save = msg_scroll;
      linenr_T	read_no_eol_lnum = 0;   /* non-zero lnum when last line of
  					 * last read was missing the eol */
!     int		try_mac = (vim_strchr(p_ffs, 'm') != NULL);
!     int		try_dos = (vim_strchr(p_ffs, 'd') != NULL);
!     int		try_unix = (vim_strchr(p_ffs, 'x') != NULL);
      int		file_rewind = FALSE;
  #ifdef FEAT_MBYTE
      int		can_retry;
--- 274,282 ----
      int		msg_save = msg_scroll;
      linenr_T	read_no_eol_lnum = 0;   /* non-zero lnum when last line of
  					 * last read was missing the eol */
!     int		try_mac;
!     int		try_dos;
!     int		try_unix;
      int		file_rewind = FALSE;
  #ifdef FEAT_MBYTE
      int		can_retry;
***************
*** 738,743 ****
--- 738,747 ----
      curbuf->b_op_start.lnum = ((from == 0) ? 1 : from);
      curbuf->b_op_start.col = 0;
  
+     try_mac = (vim_strchr(p_ffs, 'm') != NULL);
+     try_dos = (vim_strchr(p_ffs, 'd') != NULL);
+     try_unix = (vim_strchr(p_ffs, 'x') != NULL);
+ 
  #ifdef FEAT_AUTOCMD
      if (!read_buffer)
      {
***************
*** 769,774 ****
--- 773,783 ----
  	else
  	    apply_autocmds_exarg(EVENT_FILEREADPRE, sfname, sfname,
  							    FALSE, NULL, eap);
+ 	/* autocommands may have changed it */
+ 	try_mac = (vim_strchr(p_ffs, 'm') != NULL);
+ 	try_dos = (vim_strchr(p_ffs, 'd') != NULL);
+ 	try_unix = (vim_strchr(p_ffs, 'x') != NULL);
+ 
  	if (msg_scrolled == n)
  	    msg_scroll = m;
  
*** ../vim-8.0.0223/src/testdir/test_fileformat.vim	2016-10-12 17:45:13.642857417 +0200
--- src/testdir/test_fileformat.vim	2017-01-23 21:24:08.074263064 +0100
***************
*** 15,17 ****
--- 15,31 ----
    call assert_equal(test_fileformats, &fileformat)
    set fileformats&
  endfunc
+ 
+ func Test_fileformat_autocommand()
+ 	let filecnt=['', 'foobar', 'eins', '', 'zwei', 'drei', 'vier', 'fnf', '']
+ 	let ffs=&ffs
+ 	call writefile(filecnt, 'Xfile', 'b')
+ 	au BufReadPre Xfile set ffs=dos ff=dos
+ 	new Xfile
+ 	call assert_equal('dos', &l:ff)
+ 	call assert_equal('dos', &ffs)
+ 	" cleanup
+ 	let &ffs=ffs
+ 	au! BufReadPre Xfile
+ 	bw!
+ endfunc
*** ../vim-8.0.0223/src/version.c	2017-01-23 20:47:09.037078522 +0100
--- src/version.c	2017-01-23 21:26:24.265354675 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     224,
  /**/

-- 
Overflow on /dev/null, please empty the bit bucket.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0225
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0225
Problem:    When a block is visually selected and put is used on the end of
            the selection only one line is changed.
Solution:   Check for the end properly. (Christian Brabandt, neovim issue
            5781)
Files:      src/ops.c, src/testdir/test_put.vim


*** ../vim-8.0.0224/src/ops.c	2017-01-22 20:04:36.493131648 +0100
--- src/ops.c	2017-01-23 21:47:10.069067619 +0100
***************
*** 3774,3779 ****
--- 3774,3784 ----
  	 */
  	if (y_type == MCHAR && y_size == 1)
  	{
+ 	    linenr_T end = curbuf->b_visual.vi_end.lnum;
+ 
+ 	    if (curbuf->b_visual.vi_end.lnum < curbuf->b_visual.vi_start.lnum)
+ 		end = curbuf->b_visual.vi_start.lnum;
+ 
  	    do {
  		totlen = count * yanklen;
  		if (totlen > 0)
***************
*** 3801,3807 ****
  		}
  		if (VIsual_active)
  		    lnum++;
! 	    } while (VIsual_active && lnum <= curbuf->b_visual.vi_end.lnum);
  
  	    if (VIsual_active) /* reset lnum to the last visual line */
  		lnum--;
--- 3806,3812 ----
  		}
  		if (VIsual_active)
  		    lnum++;
! 	    } while (VIsual_active && lnum <= end);
  
  	    if (VIsual_active) /* reset lnum to the last visual line */
  		lnum--;
*** ../vim-8.0.0224/src/testdir/test_put.vim	2017-01-22 20:04:36.493131648 +0100
--- src/testdir/test_put.vim	2017-01-23 21:44:39.102071382 +0100
***************
*** 10,12 ****
--- 10,23 ----
    call assert_equal("\u2500x", getline(1))
    bwipe!
  endfunc
+ 
+ func Test_put_char_block()
+   new
+   call setline(1, ['Line 1', 'Line 2'])
+   f Xfile_put
+   " visually select both lines and put the cursor at the top of the visual
+   " selection and then put the buffer name over it
+   exe "norm! G0\<c-v>ke\"%p"
+   call assert_equal(['Xfile_put 1', 'Xfile_put 2'], getline(1,2))
+   bw!
+ endfunc
*** ../vim-8.0.0224/src/version.c	2017-01-23 21:31:05.203482973 +0100
--- src/version.c	2017-01-23 21:46:57.653150171 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     225,
  /**/

-- 
FATHER:    Did you kill all those guards?
LAUNCELOT: Yes ...  I'm very sorry ...
FATHER:    They cost fifty pounds each!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0226
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0226
Problem:    The test for patch 8.0.0224 misses the CR characters and passes
            even without the fix. (Christian Brabandt)
Solution:   Use double quotes and \<CR>.
Files:      src/testidr/test_fileformat.vim


*** ../vim-8.0.0225/src/testdir/test_fileformat.vim	2017-01-23 21:31:05.203482973 +0100
--- src/testdir/test_fileformat.vim	2017-01-24 13:15:11.662900043 +0100
***************
*** 17,31 ****
  endfunc
  
  func Test_fileformat_autocommand()
! 	let filecnt=['', 'foobar', 'eins', '', 'zwei', 'drei', 'vier', 'fnf', '']
! 	let ffs=&ffs
! 	call writefile(filecnt, 'Xfile', 'b')
! 	au BufReadPre Xfile set ffs=dos ff=dos
! 	new Xfile
! 	call assert_equal('dos', &l:ff)
! 	call assert_equal('dos', &ffs)
! 	" cleanup
! 	let &ffs=ffs
! 	au! BufReadPre Xfile
! 	bw!
  endfunc
--- 17,33 ----
  endfunc
  
  func Test_fileformat_autocommand()
!   let filecnt = ["\<CR>", "foobar\<CR>", "eins\<CR>", "\<CR>", "zwei\<CR>", "drei", "vier", "fnf", ""]
!   let ffs = &ffs
!   call writefile(filecnt, 'Xfile', 'b')
!   au BufReadPre Xfile set ffs=dos ff=dos
!   new Xfile
!   call assert_equal('dos', &l:ff)
!   call assert_equal('dos', &ffs)
! 
!   " cleanup
!   call delete('Xfile')
!   let &ffs = ffs
!   au! BufReadPre Xfile
!   bw!
  endfunc
*** ../vim-8.0.0225/src/version.c	2017-01-23 21:53:48.578417996 +0100
--- src/version.c	2017-01-24 13:16:32.414374314 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     226,
  /**/

-- 
Nothing is impossible for the man who doesn't have to do it.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0227
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0227
Problem:    Crash when 'fileformat' is forced to "dos" and the first line in
            the file is empty and does not have a CR character.
Solution:   Don't check for CR before the start of the buffer.
Files:      src/fileio.c, src/testdir/test_fileformat.vim


*** ../vim-8.0.0226/src/fileio.c	2017-01-23 21:31:05.203482973 +0100
--- src/fileio.c	2017-01-24 15:38:41.034570560 +0100
***************
*** 2251,2258 ****
  			len = (colnr_T)(ptr - line_start + 1);
  			if (fileformat == EOL_DOS)
  			{
! 			    if (ptr[-1] == CAR)	/* remove CR */
  			    {
  				ptr[-1] = NUL;
  				--len;
  			    }
--- 2251,2259 ----
  			len = (colnr_T)(ptr - line_start + 1);
  			if (fileformat == EOL_DOS)
  			{
! 			    if (ptr > line_start && ptr[-1] == CAR)
  			    {
+ 				/* remove CR before NL */
  				ptr[-1] = NUL;
  				--len;
  			    }
*** ../vim-8.0.0226/src/testdir/test_fileformat.vim	2017-01-24 13:18:40.169542919 +0100
--- src/testdir/test_fileformat.vim	2017-01-24 15:36:35.475407490 +0100
***************
*** 17,23 ****
  endfunc
  
  func Test_fileformat_autocommand()
!   let filecnt = ["\<CR>", "foobar\<CR>", "eins\<CR>", "\<CR>", "zwei\<CR>", "drei", "vier", "fnf", ""]
    let ffs = &ffs
    call writefile(filecnt, 'Xfile', 'b')
    au BufReadPre Xfile set ffs=dos ff=dos
--- 17,23 ----
  endfunc
  
  func Test_fileformat_autocommand()
!   let filecnt = ["", "foobar\<CR>", "eins\<CR>", "\<CR>", "zwei\<CR>", "drei", "vier", "fnf", ""]
    let ffs = &ffs
    call writefile(filecnt, 'Xfile', 'b')
    au BufReadPre Xfile set ffs=dos ff=dos
*** ../vim-8.0.0226/src/version.c	2017-01-24 13:18:40.169542919 +0100
--- src/version.c	2017-01-24 15:41:00.093644191 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     227,
  /**/

-- 
Computers are not intelligent.  They only think they are.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0228
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0228 (after 8.0.0210)
Problem:    When pasting test in an xterm on the command line it is surrounded
            by <PasteStart> and <PasteEnd>. (Johannes Kaltenbach)
Solution:   Add missing changes.
Files:      src/ex_getln.c, src/term.c


*** ../vim-8.0.0227/src/ex_getln.c	2017-01-11 22:40:16.169863576 +0100
--- src/ex_getln.c	2017-01-21 19:13:20.999731138 +0100
***************
*** 1794,1799 ****
--- 1794,1803 ----
  		goto cmdline_not_changed;
  #endif
  
+ 	case K_PS:
+ 		bracketed_paste(PASTE_CMDLINE, FALSE, NULL);
+ 		goto cmdline_changed;
+ 
  	default:
  #ifdef UNIX
  		if (c == intr_char)
***************
*** 2366,2373 ****
  	if (ga_grow(&line_ga, 40) == FAIL)
  	    break;
  
! 	/* Get one character at a time.  Don't use inchar(), it can't handle
! 	 * special characters. */
  	prev_char = c1;
  	c1 = vgetc();
  
--- 2370,2376 ----
  	if (ga_grow(&line_ga, 40) == FAIL)
  	    break;
  
! 	/* Get one character at a time. */
  	prev_char = c1;
  	c1 = vgetc();
  
***************
*** 2382,2387 ****
--- 2385,2396 ----
  	    break;
  	}
  
+ 	if (c1 == K_PS)
+ 	{
+ 	    bracketed_paste(PASTE_EX, FALSE, &line_ga);
+ 	    goto redraw;
+ 	}
+ 
  	if (!escaped)
  	{
  	    /* CR typed means "enter", which is NL */
*** ../vim-8.0.0227/src/term.c	2017-01-21 20:04:17.554757871 +0100
--- src/term.c	2017-01-22 13:12:03.714875561 +0100
***************
*** 3148,3154 ****
      {
  	out_str(T_TI);			/* start termcap mode */
  	out_str(T_KS);			/* start "keypad transmit" mode */
! 	out_str(T_BE);			/* enable bracketed paste moe */
  	out_flush();
  	termcap_active = TRUE;
  	screen_start();			/* don't know where cursor is now */
--- 3148,3154 ----
      {
  	out_str(T_TI);			/* start termcap mode */
  	out_str(T_KS);			/* start "keypad transmit" mode */
! 	out_str(T_BE);			/* enable bracketed paste mode */
  	out_flush();
  	termcap_active = TRUE;
  	screen_start();			/* don't know where cursor is now */
***************
*** 3198,3204 ****
  	    check_for_codes_from_term();
  	}
  #endif
! 	out_str(T_BD);			/* disable bracketed paste moe */
  	out_str(T_KE);			/* stop "keypad transmit" mode */
  	out_flush();
  	termcap_active = FALSE;
--- 3198,3204 ----
  	    check_for_codes_from_term();
  	}
  #endif
! 	out_str(T_BD);			/* disable bracketed paste mode */
  	out_str(T_KE);			/* stop "keypad transmit" mode */
  	out_flush();
  	termcap_active = FALSE;
*** ../vim-8.0.0227/src/version.c	2017-01-24 15:46:43.875356367 +0100
--- src/version.c	2017-01-24 15:56:08.583604972 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     228,
  /**/

-- 
GUARD #2:  It could be carried by an African swallow!
GUARD #1:  Oh, yeah, an African swallow maybe, but not a European swallow,
           that's my point.
GUARD #2:  Oh, yeah, I agree with that...
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0229
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0229 (after 8.0.0179)
Problem:    When freeing a buffer the local value of the 'formatprg' option is
            not cleared.
Solution:   Add missing change.
Files:      src/buffer.c


*** ../vim-8.0.0228/src/buffer.c	2017-01-13 21:59:59.319172149 +0100
--- src/buffer.c	2017-01-14 13:35:23.604332374 +0100
***************
*** 2153,2158 ****
--- 2153,2159 ----
  #if defined(FEAT_CRYPT)
      clear_string_option(&buf->b_p_cm);
  #endif
+     clear_string_option(&buf->b_p_fp);
  #if defined(FEAT_EVAL)
      clear_string_option(&buf->b_p_fex);
  #endif
*** ../vim-8.0.0228/src/version.c	2017-01-24 15:57:51.494922147 +0100
--- src/version.c	2017-01-24 17:47:56.782913714 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     229,
  /**/

-- 
MORTICIAN:    What?
CUSTOMER:     Nothing -- here's your nine pence.
DEAD PERSON:  I'm not dead!
MORTICIAN:    Here -- he says he's not dead!
CUSTOMER:     Yes, he is.
DEAD PERSON:  I'm not!
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0230
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0230 (after 8.0.0210)
Problem:    When using bracketed paste line breaks are not respected.
Solution:   Turn CR characters into a line break if the text is being
            inserted. (closes #1404)
Files:      src/edit.c


*** ../vim-8.0.0229/src/edit.c	2017-01-21 20:04:17.562757816 +0100
--- src/edit.c	2017-01-24 17:16:08.243680946 +0100
***************
*** 9498,9504 ****
  		case PASTE_INSERT:
  		    if (stop_arrow() == OK)
  		    {
! 			ins_char_bytes(buf, idx);
  			AppendToRedobuffLit(buf, idx);
  		    }
  		    break;
--- 9498,9508 ----
  		case PASTE_INSERT:
  		    if (stop_arrow() == OK)
  		    {
! 			c = buf[0];
! 			if (idx == 1 && (c == CAR || c == K_KENTER || c == NL))
! 			    ins_eol(c);
! 			else
! 			    ins_char_bytes(buf, idx);
  			AppendToRedobuffLit(buf, idx);
  		    }
  		    break;
*** ../vim-8.0.0229/src/version.c	2017-01-24 17:48:32.466675400 +0100
--- src/version.c	2017-01-24 17:49:59.214096136 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     230,
  /**/

-- 
Shit makes the flowers grow and that's beautiful

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0231
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0231
Problem:    There are no tests for bracketed paste mode.
Solution:   Add a test.  Fix repeating with "normal .".
Files:      src/edit.c, src/testdir/test_paste.vim, src/Makefile,
            src/testdir/Make_all.mak


*** ../vim-8.0.0230/src/edit.c	2017-01-24 17:50:48.753765383 +0100
--- src/edit.c	2017-01-24 18:51:09.797365521 +0100
***************
*** 463,469 ****
  	else
  #endif
  	{
! 	    AppendCharToRedobuff(cmdchar);
  	    if (cmdchar == 'g')		    /* "gI" command */
  		AppendCharToRedobuff('I');
  	    else if (cmdchar == 'r')	    /* "r<CR>" command */
--- 463,472 ----
  	else
  #endif
  	{
! 	    if (cmdchar == K_PS)
! 		AppendCharToRedobuff('a');
! 	    else
! 		AppendCharToRedobuff(cmdchar);
  	    if (cmdchar == 'g')		    /* "gI" command */
  		AppendCharToRedobuff('I');
  	    else if (cmdchar == 'r')	    /* "r<CR>" command */
***************
*** 9502,9509 ****
  			if (idx == 1 && (c == CAR || c == K_KENTER || c == NL))
  			    ins_eol(c);
  			else
  			    ins_char_bytes(buf, idx);
! 			AppendToRedobuffLit(buf, idx);
  		    }
  		    break;
  
--- 9505,9514 ----
  			if (idx == 1 && (c == CAR || c == K_KENTER || c == NL))
  			    ins_eol(c);
  			else
+ 			{
  			    ins_char_bytes(buf, idx);
! 			    AppendToRedobuffLit(buf, idx);
! 			}
  		    }
  		    break;
  
*** ../vim-8.0.0230/src/testdir/test_paste.vim	2017-01-24 18:57:28.202819387 +0100
--- src/testdir/test_paste.vim	2017-01-24 18:55:26.559637737 +0100
***************
*** 0 ****
--- 1,41 ----
+ " Tests for bracketed paste.
+ 
+ " Bracketed paste only works with "xterm".
+ set term=xterm
+ 
+ func Test_paste_normal_mode()
+   new
+   call setline(1, ['a', 'b', 'c'])
+   2
+   call feedkeys("\<Esc>[200~foo\<CR>bar\<Esc>[201~", 'xt')
+   call assert_equal('bfoo', getline(2))
+   call assert_equal('bar', getline(3))
+   call assert_equal('c', getline(4))
+ 
+   normal .
+   call assert_equal('barfoo', getline(3))
+   call assert_equal('bar', getline(4))
+   call assert_equal('c', getline(5))
+   bwipe!
+ endfunc
+ 
+ func Test_paste_insert_mode()
+   new
+   call setline(1, ['a', 'b', 'c'])
+   2
+   call feedkeys("i\<Esc>[200~foo\<CR>bar\<Esc>[201~ done\<Esc>", 'xt')
+   call assert_equal('foo', getline(2))
+   call assert_equal('bar doneb', getline(3))
+   call assert_equal('c', getline(4))
+ 
+   normal .
+   call assert_equal('bar donfoo', getline(3))
+   call assert_equal('bar doneeb', getline(4))
+   call assert_equal('c', getline(5))
+   bwipe!
+ endfunc
+ 
+ func Test_paste_cmdline()
+   call feedkeys(":a\<Esc>[200~foo\<CR>bar\<Esc>[201~b\<Home>\"\<CR>", 'xt')
+   call assert_equal("\"afoo\<CR>barb", getreg(':'))
+ endfunc
*** ../vim-8.0.0230/src/Makefile	2017-01-22 20:04:36.493131648 +0100
--- src/Makefile	2017-01-24 18:06:10.631551093 +0100
***************
*** 2147,2152 ****
--- 2147,2153 ----
  	test_options \
  	test_packadd \
  	test_partial \
+ 	test_paste \
  	test_perl \
  	test_popup \
  	test_profile \
***************
*** 2161,2169 ****
  	test_searchpos \
  	test_set \
  	test_signs \
  	test_sort \
  	test_source_utf8 \
- 	test_smartindent \
  	test_startup \
  	test_startup_utf8 \
  	test_stat \
--- 2162,2170 ----
  	test_searchpos \
  	test_set \
  	test_signs \
+ 	test_smartindent \
  	test_sort \
  	test_source_utf8 \
  	test_startup \
  	test_startup_utf8 \
  	test_stat \
*** ../vim-8.0.0230/src/testdir/Make_all.mak	2017-01-17 22:15:42.451784910 +0100
--- src/testdir/Make_all.mak	2017-01-24 18:06:37.859367283 +0100
***************
*** 173,178 ****
--- 173,179 ----
  	    test_nested_function.res \
  	    test_netbeans.res \
  	    test_normal.res \
+ 	    test_paste.res \
  	    test_packadd.res \
  	    test_perl.res \
  	    test_profile.res \
*** ../vim-8.0.0230/src/version.c	2017-01-24 17:50:48.757765356 +0100
--- src/version.c	2017-01-24 18:56:32.047197157 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     231,
  /**/

-- 
DEAD PERSON:  I'm getting better!
CUSTOMER:     No, you're not -- you'll be stone dead in a moment.
MORTICIAN:    Oh, I can't take him like that -- it's against regulations.
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0232
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0232
Problem:    Pasting in Insert mode does not work when bracketed paste is used
            and 'esckeys' is off.
Solution:   When 'esckeys' is off disable bracketed paste in Insert mode.
Files:      src/edit.c


*** ../vim-8.0.0231/src/edit.c	2017-01-24 18:58:14.910505196 +0100
--- src/edit.c	2017-01-24 19:03:35.184351267 +0100
***************
*** 534,539 ****
--- 534,543 ----
      revins_legal = 0;
      revins_scol = -1;
  #endif
+     if (!p_ek)
+ 	/* Disable bracketed paste mode, we won't recognize the escape
+ 	 * sequences. */
+ 	out_str(T_BD);
  
      /*
       * Handle restarting Insert mode.
***************
*** 8623,8628 ****
--- 8627,8635 ----
  #ifdef CURSOR_SHAPE
      ui_cursor_shape();		/* may show different cursor shape */
  #endif
+     if (!p_ek)
+ 	/* Re-enable bracketed paste mode. */
+ 	out_str(T_BE);
  
      /*
       * When recording or for CTRL-O, need to display the new mode.
*** ../vim-8.0.0231/src/version.c	2017-01-24 18:58:14.914505169 +0100
--- src/version.c	2017-01-24 19:04:54.027821145 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     232,
  /**/

-- 
Have you heard about the new Barbie doll?  It's called Divorce
Barbie.  It comes with all of Ken's stuff.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0233
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0233 (after 8.0.0231)
Problem:    The paste test fails if the GUI is being used.
Solution:   Skip the test in the GUI.
Files:      src/testdir/test_paste.vim


*** ../vim-8.0.0232/src/testdir/test_paste.vim	2017-01-24 18:58:14.910505196 +0100
--- src/testdir/test_paste.vim	2017-01-24 19:16:26.951135970 +0100
***************
*** 1,6 ****
  " Tests for bracketed paste.
  
! " Bracketed paste only works with "xterm".
  set term=xterm
  
  func Test_paste_normal_mode()
--- 1,9 ----
  " Tests for bracketed paste.
  
! " Bracketed paste only works with "xterm".  Not in GUI.
! if has('gui_running')
!   finish
! endif
  set term=xterm
  
  func Test_paste_normal_mode()
*** ../vim-8.0.0232/src/version.c	2017-01-24 19:08:10.934489594 +0100
--- src/version.c	2017-01-24 19:17:29.622712421 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     233,
  /**/

-- 
You know you use Vim too much when you have this alias in your
~/.bashrc file: alias :e=/bin/vim             (Eljay Love-Jensen)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0234
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0234 (after 8.0.0225)
Problem:    When several lines are visually selected and one of them is short,
            using put may cause a crash. (Axel Bender)
Solution:   Check for a short line. (Christian Brabandt)
Files:      src/ops.c, src/testdir/test_put.vim


*** ../vim-8.0.0233/src/ops.c	2017-01-23 21:53:48.578417996 +0100
--- src/ops.c	2017-01-24 19:29:54.769672745 +0100
***************
*** 3774,3789 ****
  	 */
  	if (y_type == MCHAR && y_size == 1)
  	{
! 	    linenr_T end = curbuf->b_visual.vi_end.lnum;
  
! 	    if (curbuf->b_visual.vi_end.lnum < curbuf->b_visual.vi_start.lnum)
! 		end = curbuf->b_visual.vi_start.lnum;
  
  	    do {
  		totlen = count * yanklen;
  		if (totlen > 0)
  		{
  		    oldp = ml_get(lnum);
  		    newp = alloc_check((unsigned)(STRLEN(oldp) + totlen + 1));
  		    if (newp == NULL)
  			goto end;	/* alloc() gave an error message */
--- 3774,3798 ----
  	 */
  	if (y_type == MCHAR && y_size == 1)
  	{
! 	    linenr_T end;
  
! 	    if (VIsual_active)
! 	    {
! 		end = curbuf->b_visual.vi_end.lnum;
! 		if (end < curbuf->b_visual.vi_start.lnum)
! 		    end = curbuf->b_visual.vi_start.lnum;
! 	    }
  
  	    do {
  		totlen = count * yanklen;
  		if (totlen > 0)
  		{
  		    oldp = ml_get(lnum);
+ 		    if (VIsual_active && col > (int)STRLEN(oldp))
+ 		    {
+ 			lnum++;
+ 			continue;
+ 		    }
  		    newp = alloc_check((unsigned)(STRLEN(oldp) + totlen + 1));
  		    if (newp == NULL)
  			goto end;	/* alloc() gave an error message */
*** ../vim-8.0.0233/src/testdir/test_put.vim	2017-01-23 21:53:48.578417996 +0100
--- src/testdir/test_put.vim	2017-01-24 19:22:01.824873262 +0100
***************
*** 21,23 ****
--- 21,36 ----
    call assert_equal(['Xfile_put 1', 'Xfile_put 2'], getline(1,2))
    bw!
  endfunc
+ 
+ func Test_put_char_block2()
+   new
+   let a = [ getreg('a'), getregtype('a') ]
+   call setreg('a', ' one ', 'v')
+   call setline(1, ['Line 1', '', 'Line 3', ''])
+   " visually select the first 3 lines and put register a over it
+   exe "norm! ggl\<c-v>2j2l\"ap"
+   call assert_equal(['L one  1', '', 'L one  3', ''], getline(1,4))
+   " clean up
+   bw!
+   call setreg('a', a[0], a[1])
+ endfunc
*** ../vim-8.0.0233/src/version.c	2017-01-24 19:18:10.386436951 +0100
--- src/version.c	2017-01-24 19:33:17.348302563 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     234,
  /**/

-- 
CUSTOMER:     You're not fooling anyone y'know.  Look, isn't there something
              you can do?
DEAD PERSON:  I feel happy... I feel happy.
    [whop]
CUSTOMER:     Ah, thanks very much.
MORTICIAN:    Not at all.  See you on Thursday.
CUSTOMER:     Right.
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0235
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0235
Problem:    Memory leak detected when running tests for diff mode.
Solution:   Free p_extra_free.
Files:      src/screen.c


*** ../vim-8.0.0234/src/screen.c	2017-01-08 20:00:00.228408247 +0100
--- src/screen.c	2017-01-24 20:12:24.520395169 +0100
***************
*** 3651,3656 ****
--- 3651,3657 ----
  		{
  		    /* Draw the 'foldcolumn'.  Allocate a buffer, "extra" may
  		     * already be in use. */
+ 		    vim_free(p_extra_free);
  		    p_extra_free = alloc(12 + 1);
  
  		    if (p_extra_free != NULL)
***************
*** 4695,4700 ****
--- 4696,4702 ----
  			p = alloc((unsigned)(len + 1));
  			vim_memset(p, ' ', len);
  			p[len] = NUL;
+ 			vim_free(p_extra_free);
  			p_extra_free = p;
  			for (i = 0; i < tab_len; i++)
  			{
***************
*** 4857,4862 ****
--- 4859,4865 ----
  			vim_memset(p, ' ', n_extra);
  			STRNCPY(p, p_extra + 1, STRLEN(p_extra) - 1);
  			p[n_extra] = NUL;
+ 			vim_free(p_extra_free);
  			p_extra_free = p_extra = p;
  		    }
  		    else
***************
*** 5784,5789 ****
--- 5787,5793 ----
      }
  #endif
  
+     vim_free(p_extra_free);
      return row;
  }
  
*** ../vim-8.0.0234/src/version.c	2017-01-24 19:55:39.247204591 +0100
--- src/version.c	2017-01-24 20:13:52.735798232 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     235,
  /**/

-- 
    [clop clop]
MORTICIAN:  Who's that then?
CUSTOMER:   I don't know.
MORTICIAN:  Must be a king.
CUSTOMER:   Why?
MORTICIAN:  He hasn't got shit all over him.
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0236
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0236 (after 8.0.0234)
Problem:    Gcc complains that a variable may be used uninitialized. Confusion
            between variable and label name. (John Marriott)
Solution:   Initialize it.  Rename end to end_lnum.
Files:      src/ops.c


*** ../vim-8.0.0235/src/ops.c	2017-01-24 19:55:39.247204591 +0100
--- src/ops.c	2017-01-24 20:44:19.835493484 +0100
***************
*** 3774,3786 ****
  	 */
  	if (y_type == MCHAR && y_size == 1)
  	{
! 	    linenr_T end;
  
  	    if (VIsual_active)
  	    {
! 		end = curbuf->b_visual.vi_end.lnum;
! 		if (end < curbuf->b_visual.vi_start.lnum)
! 		    end = curbuf->b_visual.vi_start.lnum;
  	    }
  
  	    do {
--- 3774,3786 ----
  	 */
  	if (y_type == MCHAR && y_size == 1)
  	{
! 	    linenr_T end_lnum = 0; /* init for gcc */
  
  	    if (VIsual_active)
  	    {
! 		end_lnum = curbuf->b_visual.vi_end.lnum;
! 		if (end_lnum < curbuf->b_visual.vi_start.lnum)
! 		    end_lnum = curbuf->b_visual.vi_start.lnum;
  	    }
  
  	    do {
***************
*** 3815,3821 ****
  		}
  		if (VIsual_active)
  		    lnum++;
! 	    } while (VIsual_active && lnum <= end);
  
  	    if (VIsual_active) /* reset lnum to the last visual line */
  		lnum--;
--- 3815,3821 ----
  		}
  		if (VIsual_active)
  		    lnum++;
! 	    } while (VIsual_active && lnum <= end_lnum);
  
  	    if (VIsual_active) /* reset lnum to the last visual line */
  		lnum--;
*** ../vim-8.0.0235/src/version.c	2017-01-24 20:14:42.755459796 +0100
--- src/version.c	2017-01-24 20:46:07.678782565 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     236,
  /**/

-- 
ARTHUR:  Well, I can't just call you `Man'.
DENNIS:  Well, you could say `Dennis'.
ARTHUR:  Well, I didn't know you were called `Dennis.'
DENNIS:  Well, you didn't bother to find out, did you?
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0237
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0237
Problem:    When setting wildoptions=tagfile the completion context is not set
            correctly. (desjardins)
Solution:   Check for EXPAND_TAGS_LISTFILES. (Christian Brabandt, closes #1399)
Files:      src/ex_getln.c, src/testdir/test_cmdline.vim


*** ../vim-8.0.0236/src/ex_getln.c	2017-01-24 15:57:51.494922147 +0100
--- src/ex_getln.c	2017-01-24 21:14:16.067611736 +0100
***************
*** 4366,4372 ****
  		|| context == EXPAND_OWNSYNTAX
  		|| context == EXPAND_FILETYPE
  		|| context == EXPAND_PACKADD
! 		|| (context == EXPAND_TAGS && fname[0] == '/'))
  	    retval = vim_strnsave(fname, len);
  	else
  	{
--- 4366,4374 ----
  		|| context == EXPAND_OWNSYNTAX
  		|| context == EXPAND_FILETYPE
  		|| context == EXPAND_PACKADD
! 		|| ((context == EXPAND_TAGS_LISTFILES
! 			|| context == EXPAND_TAGS)
! 		    && fname[0] == '/'))
  	    retval = vim_strnsave(fname, len);
  	else
  	{
*** ../vim-8.0.0236/src/testdir/test_cmdline.vim	2017-01-22 19:25:28.228530629 +0100
--- src/testdir/test_cmdline.vim	2017-01-24 21:11:37.632659397 +0100
***************
*** 295,297 ****
--- 295,308 ----
    2;')
    quit
  endfunc
+ 
+ func Test_cmdline_complete_wildoptions()
+   help
+   call feedkeys(":tag /\<c-a>\<c-b>\"\<cr>", 'tx')
+   let a = join(sort(split(@:)),' ')
+   set wildoptions=tagfile
+   call feedkeys(":tag /\<c-a>\<c-b>\"\<cr>", 'tx')
+   let b = join(sort(split(@:)),' ')
+   call assert_equal(a, b)
+   bw!
+ endfunc
*** ../vim-8.0.0236/src/version.c	2017-01-24 20:47:46.350131696 +0100
--- src/version.c	2017-01-24 21:17:07.722476015 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     237,
  /**/

-- 
A mathematician is a device for turning coffee into theorems.
					Paul Erdos
A computer programmer is a device for turning coffee into bugs.
					Bram Moolenaar

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0238
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0238
Problem:    When using bracketed paste autoindent causes indent to be
            increased.
Solution:   Disable 'ai' and set 'paste' temporarily. (Ken Takata)
Files:      src/edit.c, src/testdir/test_paste.vim


*** ../vim-8.0.0237/src/edit.c	2017-01-24 19:08:10.934489594 +0100
--- src/edit.c	2017-01-25 21:32:16.244037908 +0100
***************
*** 9463,9474 ****
--- 9463,9479 ----
      char_u	*end = find_termcode((char_u *)"PE");
      int		ret_char = -1;
      int		save_allow_keys = allow_keys;
+     int		save_paste = p_paste;
+     int		save_ai = curbuf->b_p_ai;
  
      /* If the end code is too long we can't detect it, read everything. */
      if (STRLEN(end) >= NUMBUFLEN)
  	end = NULL;
      ++no_mapping;
      allow_keys = 0;
+     p_paste = TRUE;
+     curbuf->b_p_ai = FALSE;
+ 
      for (;;)
      {
  	/* When the end is not defined read everything. */
***************
*** 9534,9541 ****
--- 9539,9549 ----
  	}
  	idx = 0;
      }
+ 
      --no_mapping;
      allow_keys = save_allow_keys;
+     p_paste = save_paste;
+     curbuf->b_p_ai = save_ai;
  
      return ret_char;
  }
*** ../vim-8.0.0237/src/testdir/test_paste.vim	2017-01-24 19:18:10.386436951 +0100
--- src/testdir/test_paste.vim	2017-01-25 21:33:38.555490257 +0100
***************
*** 35,40 ****
--- 35,50 ----
    call assert_equal('bar donfoo', getline(3))
    call assert_equal('bar doneeb', getline(4))
    call assert_equal('c', getline(5))
+ 
+   set ai et tw=10
+   call setline(1, ['a', '    b', 'c'])
+   2
+   call feedkeys("A\<Esc>[200~foo\<CR> bar bar bar\<Esc>[201~\<Esc>", 'xt')
+   call assert_equal('    bfoo', getline(2))
+   call assert_equal(' bar bar bar', getline(3))
+   call assert_equal('c', getline(4))
+ 
+   set ai& et& tw=0
    bwipe!
  endfunc
  
*** ../vim-8.0.0237/src/version.c	2017-01-24 21:18:15.986024183 +0100
--- src/version.c	2017-01-25 21:35:39.002688840 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     238,
  /**/

-- 
WOMAN:   King of the who?
ARTHUR:  The Britons.
WOMAN:   Who are the Britons?
ARTHUR:  Well, we all are. we're all Britons and I am your king.
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0239
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0239
Problem:    The address sanitizer sometimes finds errors, but it needs to be
            run manually.
Solution:   Add an environment to Travis with clang and the address sanitizer.
            (Christian Brabandt)
Files:      .travis.yml


*** ../vim-8.0.0238/.travis.yml	2016-11-12 18:30:35.115712865 +0100
--- .travis.yml	2017-01-26 20:03:56.010251816 +0100
***************
*** 1,19 ****
  language: c
  
  compiler:
    - clang
    - gcc
  
  env:
!   - COVERAGE=yes CFLAGS=--coverage LDFLAGS=--coverage FEATURES=huge SHADOWOPT= SRCDIR=./src
      "CONFOPT='--enable-perlinterp --enable-pythoninterp --enable-python3interp --enable-rubyinterp --enable-luainterp'"
!     CHECK_AUTOCONF=yes
!   - COVERAGE=no FEATURES=normal CONFOPT= SHADOWOPT="-C src/shadow" SRCDIR=./src/shadow CHECK_AUTOCONF=no
!   - COVERAGE=no FEATURES=small CONFOPT= SHADOWOPT= SRCDIR=./src CHECK_AUTOCONF=no
!   - COVERAGE=no FEATURES=tiny  CONFOPT= SHADOWOPT= SRCDIR=./src CHECK_AUTOCONF=no
  
  sudo: false
  
  branches:
    except:
      - /^v[0-9]/
--- 1,63 ----
  language: c
  
+ os:
+   - osx
+   - linux
+ 
  compiler:
    - clang
    - gcc
  
  env:
!   - BUILD=yes TEST=scripttests COVERAGE=yes CFLAGS=--coverage LDFLAGS=--coverage FEATURES=huge SHADOWOPT= SRCDIR=./src CHECK_AUTOCONF=no
      "CONFOPT='--enable-perlinterp --enable-pythoninterp --enable-python3interp --enable-rubyinterp --enable-luainterp'"
!   - BUILD=no TEST=unittests COVERAGE=yes CFLAGS=--coverage LDFLAGS=--coverage FEATURES=huge SHADOWOPT= SRCDIR=./src CHECK_AUTOCONF=yes
!   - BUILD=yes TEST=test COVERAGE=no FEATURES=normal CONFOPT= SHADOWOPT="-C src/shadow" SRCDIR=./src/shadow CHECK_AUTOCONF=no
!   - BUILD=yes TEST=test COVERAGE=no FEATURES=small CONFOPT= SHADOWOPT= SRCDIR=./src CHECK_AUTOCONF=no
!   - BUILD=yes TEST=test COVERAGE=no FEATURES=tiny  CONFOPT= SHADOWOPT= SRCDIR=./src CHECK_AUTOCONF=no
!     # Mac OSX build
!   - BUILD=yes TEST=test COVERAGE=no FEATURES=huge SHADOWOPT= SRCDIR=./src CHECK_AUTOCONF=no
!     "CONFOPT='--enable-perlinterp --enable-pythoninterp --enable-rubyinterp --enable-luainterp'"
!     # ASAN build
!   - BUILD=yes TEST=test SANITIZER_CFLAGS="-g -O1 -fsanitize=address -fno-omit-frame-pointer" FEATURES=huge SRCDIR=./src CHECK_AUTOCONF=no
!     "CONFOPT='--enable-perlinterp --enable-pythoninterp --enable-rubyinterp --enable-luainterp'"
  
  sudo: false
  
+ git:
+   depth: 1
+ 
+ # instead of a 2*2*8 matrix (2*os + 2*compiler + 8*env),
+ # exclude some builds on mac os x and linux
+ # linux: 2*compiler + 5*env + mac: 2*compiler + 2*env
+ matrix:
+   exclude:
+     - os: osx
+       env: BUILD=yes TEST=test COVERAGE=no FEATURES=normal CONFOPT= SHADOWOPT="-C src/shadow" SRCDIR=./src/shadow CHECK_AUTOCONF=no
+     - os: osx
+       env: BUILD=no TEST=unittests COVERAGE=yes CFLAGS=--coverage LDFLAGS=--coverage FEATURES=huge SHADOWOPT= SRCDIR=./src CHECK_AUTOCONF=yes
+     - os: osx
+       env: BUILD=yes TEST=test COVERAGE=no FEATURES=small CONFOPT= SHADOWOPT= SRCDIR=./src CHECK_AUTOCONF=no
+     - os: osx
+       env: BUILD=yes TEST=scripttests COVERAGE=yes CFLAGS=--coverage LDFLAGS=--coverage FEATURES=huge SHADOWOPT= SRCDIR=./src CHECK_AUTOCONF=no
+             "CONFOPT='--enable-perlinterp --enable-pythoninterp --enable-python3interp --enable-rubyinterp --enable-luainterp'"
+     - os: osx
+       env: BUILD=yes TEST=test SANITIZER_CFLAGS="-g -O1 -fsanitize=address -fno-omit-frame-pointer" FEATURES=huge SRCDIR=./src CHECK_AUTOCONF=no
+             "CONFOPT='--enable-perlinterp --enable-pythoninterp --enable-rubyinterp --enable-luainterp'"
+     - os: linux
+       compiler: gcc
+       env: BUILD=yes TEST=test SANITIZER_CFLAGS="-g -O1 -fsanitize=address -fno-omit-frame-pointer" FEATURES=huge SRCDIR=./src CHECK_AUTOCONF=no
+             "CONFOPT='--enable-perlinterp --enable-pythoninterp --enable-rubyinterp --enable-luainterp'"
+     - os: linux
+       compiler: clang
+       env: BUILD=no TEST=unittests COVERAGE=yes CFLAGS=--coverage LDFLAGS=--coverage FEATURES=huge SHADOWOPT= SRCDIR=./src CHECK_AUTOCONF=yes
+     - os: linux
+       compiler: clang
+       env: BUILD=yes TEST=test COVERAGE=no FEATURES=small CONFOPT= SHADOWOPT= SRCDIR=./src CHECK_AUTOCONF=no
+     - os: linux
+       env: BUILD=yes TEST=test COVERAGE=no FEATURES=huge SHADOWOPT= SRCDIR=./src CHECK_AUTOCONF=no
+             "CONFOPT='--enable-perlinterp --enable-pythoninterp --enable-rubyinterp --enable-luainterp'"
+ 
  branches:
    except:
      - /^v[0-9]/
***************
*** 28,36 ****
--- 72,84 ----
        - python3-dev
        - liblua5.1-0-dev
        - lua5.1
+       - cscope
  
  before_install:
    - pip install --user cpp-coveralls
+   - pip install --user requests[security]
+     # Lua is not installed on Travis OSX
+   - if [ "$TRAVIS_OS_NAME" = "osx" ]; then brew install lua; export LUA_PREFIX=/usr/local; fi
  
  # Start virtual framebuffer to be able to test the GUI. Does not work on OS X.
  before_script:
***************
*** 39,49 ****
  script:
    - NPROC=$(getconf _NPROCESSORS_ONLN)
    - if [ "$CHECK_AUTOCONF" = "yes" -a "$CC" = "gcc" ]; then make -C src autoconf; fi
!   - if [ "x$SHADOWOPT" != x ]; then make -C src shadow; fi && (cd ${SRCDIR} && ./configure --with-features=$FEATURES $CONFOPT --enable-fail-if-missing && make -j$NPROC)
!   - ${SRCDIR}/vim --version
!   - make $SHADOWOPT test
  
  after_success:
!   - if [ x"$COVERAGE" = "xyes" ]; then ~/.local/bin/coveralls -b $SRCDIR -x .xs -e ${SRCDIR}/xxd -e ${SRCDIR}/if_perl.c --encodings utf-8 latin-1 EUC-KR; fi
  
  # vim:set sts=2 sw=2 tw=0 et:
--- 87,98 ----
  script:
    - NPROC=$(getconf _NPROCESSORS_ONLN)
    - if [ "$CHECK_AUTOCONF" = "yes" -a "$CC" = "gcc" ]; then make -C src autoconf; fi
!   - if [ "x$SHADOWOPT" != x ]; then make -C src shadow; fi
!   - (cd ${SRCDIR} && ./configure --with-features=$FEATURES $CONFOPT --enable-fail-if-missing && if [ "$BUILD" = "yes" ]; then make -j$NPROC; fi)
!   - if [ "$BUILD" = "yes" ]; then ${SRCDIR}/vim --version; fi
!   - make $SHADOWOPT $TEST
  
  after_success:
!   - if [ "$COVERAGE" = "yes" ]; then ~/.local/bin/coveralls -b $SRCDIR -x .xs -e ${SRCDIR}/xxd -e ${SRCDIR}/if_perl.c --encodings utf-8 latin-1 EUC-KR; fi
  
  # vim:set sts=2 sw=2 tw=0 et:
*** ../vim-8.0.0238/src/version.c	2017-01-25 21:36:11.626471765 +0100
--- src/version.c	2017-01-26 20:06:14.905366666 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     239,
  /**/

-- 
Individualists unite!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0240
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0240 (after 8.0.0239)
Problem:    The clang build on CI fails with one configuration.
Solution:   Redo a previous patch that was accidentally reverted.
Files:      .travis.yml


*** ../vim-8.0.0239/.travis.yml	2017-01-26 20:09:51.787983875 +0100
--- .travis.yml	2017-01-26 21:22:35.284086416 +0100
***************
*** 75,82 ****
        - cscope
  
  before_install:
!   - pip install --user cpp-coveralls
!   - pip install --user requests[security]
      # Lua is not installed on Travis OSX
    - if [ "$TRAVIS_OS_NAME" = "osx" ]; then brew install lua; export LUA_PREFIX=/usr/local; fi
  
--- 75,84 ----
        - cscope
  
  before_install:
!   - if [ "$COVERAGE" = "yes" ]; then pip install --user cpp-coveralls; fi
!     # needed for https support for coveralls
!     # building cffi only works with gcc, not with clang
!   - if [ "$COVERAGE" = "yes" ]; then CC=gcc pip install --user pyopenssl ndg-httpsclient pyasn1; fi
      # Lua is not installed on Travis OSX
    - if [ "$TRAVIS_OS_NAME" = "osx" ]; then brew install lua; export LUA_PREFIX=/usr/local; fi
  
*** ../vim-8.0.0239/src/version.c	2017-01-26 20:09:51.787983875 +0100
--- src/version.c	2017-01-26 21:20:34.028864601 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     240,
  /**/

-- 
A poem:                read aloud:

<> !*''#               Waka waka bang splat tick tick hash,
^"`$$-                 Caret quote back-tick dollar dollar dash,
!*=@$_                 Bang splat equal at dollar under-score,
%*<> ~#4               Percent splat waka waka tilde number four,
&[]../                 Ampersand bracket bracket dot dot slash,
|{,,SYSTEM HALTED      Vertical-bar curly-bracket comma comma CRASH.

Fred Bremmer and Steve Kroese (Calvin College & Seminary of Grand Rapids, MI.)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0241
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0241
Problem:    Vim defines a mch_memmove() function but it doesn't work, thus is
            always unused.
Solution:   Remove the mch_memmove implementation. (suggested by Dominique
            Pelle)
Files:      src/os_unix.h, src/misc2.c, src/vim.h



*** ../vim-8.0.0240/src/os_unix.h	2016-11-04 20:35:27.352945991 +0100
--- src/os_unix.h	2017-01-26 21:32:19.412337932 +0100
***************
*** 423,443 ****
  # endif
  #endif
  
! /* memmove is not present on all systems, use memmove, bcopy, memcpy or our
!  * own version */
! /* Some systems have (void *) arguments, some (char *). If we use (char *) it
   * works for all */
! #ifdef USEMEMMOVE
  # define mch_memmove(to, from, len) memmove((char *)(to), (char *)(from), len)
  #else
  # ifdef USEBCOPY
  #  define mch_memmove(to, from, len) bcopy((char *)(from), (char *)(to), len)
  # else
! #  ifdef USEMEMCPY
  #   define mch_memmove(to, from, len) memcpy((char *)(to), (char *)(from), len)
- #  else
- #   define VIM_MEMMOVE	    /* found in misc2.c */
- #  endif
  # endif
  #endif
  
--- 423,439 ----
  # endif
  #endif
  
! /* memmove() is not present on all systems, use memmove, bcopy or memcpy.
!  * Some systems have (void *) arguments, some (char *). If we use (char *) it
   * works for all */
! #if defined(USEMEMMOVE) || (!defined(USEBCOPY) && !defined(USEMEMCPY))
  # define mch_memmove(to, from, len) memmove((char *)(to), (char *)(from), len)
  #else
  # ifdef USEBCOPY
  #  define mch_memmove(to, from, len) bcopy((char *)(from), (char *)(to), len)
  # else
!     /* ifdef USEMEMCPY */
  #   define mch_memmove(to, from, len) memcpy((char *)(to), (char *)(from), len)
  # endif
  #endif
  
*** ../vim-8.0.0240/src/misc2.c	2017-01-22 15:05:08.107998905 +0100
--- src/misc2.c	2017-01-26 21:32:40.032205619 +0100
***************
*** 1740,1773 ****
  }
  #endif
  
- /* skipped when generating prototypes, the prototype is in vim.h */
- #ifdef VIM_MEMMOVE
- /*
-  * Version of memmove() that handles overlapping source and destination.
-  * For systems that don't have a function that is guaranteed to do that (SYSV).
-  */
-     void
- mch_memmove(void *src_arg, void *dst_arg, size_t len)
- {
-     /*
-      * A void doesn't have a size, we use char pointers.
-      */
-     char *dst = dst_arg, *src = src_arg;
- 
- 					/* overlap, copy backwards */
-     if (dst > src && dst < src + len)
-     {
- 	src += len;
- 	dst += len;
- 	while (len-- > 0)
- 	    *--dst = *--src;
-     }
-     else				/* copy forwards */
- 	while (len-- > 0)
- 	    *dst++ = *src++;
- }
- #endif
- 
  #if (!defined(HAVE_STRCASECMP) && !defined(HAVE_STRICMP)) || defined(PROTO)
  /*
   * Compare two strings, ignoring case, using current locale.
--- 1740,1745 ----
*** ../vim-8.0.0240/src/vim.h	2017-01-21 20:04:17.570757762 +0100
--- src/vim.h	2017-01-26 21:33:57.643707606 +0100
***************
*** 1714,1728 ****
  
  typedef void	    *vim_acl_T;		/* dummy to pass an ACL to a function */
  
! /*
!  * Include a prototype for mch_memmove(), it may not be in alloc.pro.
!  */
! #ifdef VIM_MEMMOVE
! void mch_memmove(void *, void *, size_t);
! #else
! # ifndef mch_memmove
! #  define mch_memmove(to, from, len) memmove(to, from, len)
! # endif
  #endif
  
  /*
--- 1714,1721 ----
  
  typedef void	    *vim_acl_T;		/* dummy to pass an ACL to a function */
  
! #ifndef mch_memmove
! # define mch_memmove(to, from, len) memmove((char*)(to), (char*)(from), (char*)(len))
  #endif
  
  /*
*** ../vim-8.0.0240/src/version.c	2017-01-26 21:23:44.583641679 +0100
--- src/version.c	2017-01-26 21:34:25.679527711 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     241,
  /**/

-- 
I'm sure that I asked CBuilder to do a "full" install.  Looks like I got
a "fool" install, instead.		Charles E Campbell, Jr, PhD


 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0242
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0242
Problem:    Completion of user defined functions is not covered by tests.
Solution:   Add tests.  Also test various errors of user-defined commands.
            (Dominique Pelle, closes #1413)
Files:      src/testdir/test_usercommands.vim


*** ../vim-8.0.0241/src/testdir/test_usercommands.vim	2016-07-30 19:35:38.000000000 +0200
--- src/testdir/test_usercommands.vim	2017-01-26 22:05:44.127512506 +0100
***************
*** 102,104 ****
--- 102,208 ----
    call assert_fails('Dothat', 'E492:')
    call assert_equal('yes', g:didnot)
  endfunc
+ 
+ func Test_CmdErrors()
+   call assert_fails('com! docmd :', 'E183:')
+   call assert_fails('com! \<Tab> :', 'E182:')
+   call assert_fails('com! _ :', 'E182:')
+   call assert_fails('com! X :', 'E841:')
+   call assert_fails('com! - DoCmd :', 'E175:')
+   call assert_fails('com! -xxx DoCmd :', 'E181:')
+   call assert_fails('com! -addr DoCmd :', 'E179:')
+   call assert_fails('com! -complete DoCmd :', 'E179:')
+   call assert_fails('com! -complete=xxx DoCmd :', 'E180:')
+   call assert_fails('com! -complete=custom DoCmd :', 'E467:')
+   call assert_fails('com! -complete=customlist DoCmd :', 'E467:')
+   call assert_fails('com! -complete=behave,CustomComplete DoCmd :', 'E468:')
+   call assert_fails('com! -nargs=x DoCmd :', 'E176:')
+   call assert_fails('com! -count=1 -count=2 DoCmd :', 'E177:')
+   call assert_fails('com! -count=x DoCmd :', 'E178:')
+   call assert_fails('com! -range=x DoCmd :', 'E178:')
+ 
+   com! -nargs=0 DoCmd :
+   call assert_fails('DoCmd x', 'E488:')
+ 
+   com! -nargs=1 DoCmd :
+   call assert_fails('DoCmd', 'E471:')
+ 
+   com! -nargs=+ DoCmd :
+   call assert_fails('DoCmd', 'E471:')
+ 
+   call assert_fails('com DoCmd :', 'E174:')
+   comclear
+   call assert_fails('delcom DoCmd', 'E184:')
+ endfunc
+ 
+ func CustomComplete(A, L, P)
+   return "January\nFebruary\nMars\n"
+ endfunc
+ 
+ func CustomCompleteList(A, L, P)
+   return [ "Monday", "Tuesday", "Wednesday" ]
+ endfunc
+ 
+ func Test_CmdCompletion()
+   call feedkeys(":com -\<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"com -addr bang bar buffer complete count nargs range register', @:)
+ 
+   call feedkeys(":com -nargs=0 -\<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"com -nargs=0 -addr bang bar buffer complete count nargs range register', @:)
+ 
+   call feedkeys(":com -nargs=\<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"com -nargs=* + 0 1 ?', @:)
+ 
+   call feedkeys(":com -addr=\<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"com -addr=arguments buffers lines loaded_buffers quickfix tabs windows', @:)
+ 
+   call feedkeys(":com -complete=co\<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"com -complete=color command compiler', @:)
+ 
+   command! DoCmd1 :
+   command! DoCmd2 :
+   call feedkeys(":com \<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"com DoCmd1 DoCmd2', @:)
+ 
+   call feedkeys(":DoC\<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"DoCmd1 DoCmd2', @:)
+ 
+   call feedkeys(":delcom DoC\<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"delcom DoCmd1 DoCmd2', @:)
+ 
+   delcom DoCmd1
+   call feedkeys(":delcom DoC\<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"delcom DoCmd2', @:)
+ 
+   call feedkeys(":com DoC\<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"com DoCmd2', @:)
+ 
+   delcom DoCmd2
+   call feedkeys(":delcom DoC\<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"delcom DoC', @:)
+ 
+   call feedkeys(":com DoC\<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"com DoC', @:)
+ 
+   com! -complete=behave DoCmd :
+   call feedkeys(":DoCmd \<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"DoCmd mswin xterm', @:)
+ 
+   " This does not work. Why?
+   "call feedkeys(":DoCmd x\<C-A>\<C-B>\"\<CR>", 'tx')
+   "call assert_equal('"DoCmd xterm', @:)
+ 
+   com! -complete=custom,CustomComplete DoCmd :
+   call feedkeys(":DoCmd \<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"DoCmd January February Mars', @:)
+ 
+   com! -complete=customlist,CustomCompleteList DoCmd :
+   call feedkeys(":DoCmd \<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"DoCmd Monday Tuesday Wednesday', @:)
+ 
+   com! -complete=custom,CustomCompleteList DoCmd :
+   call assert_fails("call feedkeys(':DoCmd \<C-D>', 'tx')", 'E730:')
+ 
+   com! -complete=customlist,CustomComp DoCmd :
+   call assert_fails("call feedkeys(':DoCmd \<C-D>', 'tx')", 'E117:')
+ endfunc
*** ../vim-8.0.0241/src/version.c	2017-01-26 21:36:29.610733183 +0100
--- src/version.c	2017-01-26 22:06:09.259351700 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     242,
  /**/

-- 
Q: How does a UNIX Guru pick up a girl?
A: look; grep; which; eval; nice; uname; talk; date;

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0243
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0243
Problem:    When making a character lower case with tolower() changes the byte
            cound, it is not made lower case.
Solution:   Add strlow_save(). (Dominique Pelle, closes #1406)
Files:      src/evalfunc.c, src/misc2.c, src/proto/misc2.pro,
            src/testdir/test_functions.vim


*** ../vim-8.0.0242/src/evalfunc.c	2017-01-22 18:34:53.680030808 +0100
--- src/evalfunc.c	2017-01-26 22:45:47.252202745 +0100
***************
*** 12503,12541 ****
      static void
  f_tolower(typval_T *argvars, typval_T *rettv)
  {
-     char_u	*p;
- 
-     p = vim_strsave(get_tv_string(&argvars[0]));
      rettv->v_type = VAR_STRING;
!     rettv->vval.v_string = p;
! 
!     if (p != NULL)
! 	while (*p != NUL)
! 	{
! #ifdef FEAT_MBYTE
! 	    int		l;
! 
! 	    if (enc_utf8)
! 	    {
! 		int c, lc;
! 
! 		c = utf_ptr2char(p);
! 		lc = utf_tolower(c);
! 		l = utf_ptr2len(p);
! 		/* TODO: reallocate string when byte count changes. */
! 		if (utf_char2len(lc) == l)
! 		    utf_char2bytes(lc, p);
! 		p += l;
! 	    }
! 	    else if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)
! 		p += l;		/* skip multi-byte character */
! 	    else
! #endif
! 	    {
! 		*p = TOLOWER_LOC(*p); /* note that tolower() can be a macro */
! 		++p;
! 	    }
! 	}
  }
  
  /*
--- 12503,12510 ----
      static void
  f_tolower(typval_T *argvars, typval_T *rettv)
  {
      rettv->v_type = VAR_STRING;
!     rettv->vval.v_string = strlow_save(get_tv_string(&argvars[0]));
  }
  
  /*
*** ../vim-8.0.0242/src/misc2.c	2017-01-26 21:36:29.606733209 +0100
--- src/misc2.c	2017-01-26 22:45:47.252202745 +0100
***************
*** 1602,1608 ****
  		{
  		    s = alloc((unsigned)STRLEN(res) + 1 + newl - l);
  		    if (s == NULL)
! 			break;
  		    mch_memmove(s, res, p - res);
  		    STRCPY(s + (p - res) + newl, p + l);
  		    p = s + (p - res);
--- 1602,1611 ----
  		{
  		    s = alloc((unsigned)STRLEN(res) + 1 + newl - l);
  		    if (s == NULL)
! 		    {
! 			vim_free(res);
! 			return NULL;
! 		    }
  		    mch_memmove(s, res, p - res);
  		    STRCPY(s + (p - res) + newl, p + l);
  		    p = s + (p - res);
***************
*** 1622,1627 ****
--- 1625,1693 ----
  		p++;
  	    }
  	}
+ 
+     return res;
+ }
+ 
+ /*
+  * Make string "s" all lower-case and return it in allocated memory.
+  * Handles multi-byte characters as well as possible.
+  * Returns NULL when out of memory.
+  */
+     char_u *
+ strlow_save(char_u *orig)
+ {
+     char_u	*p;
+     char_u	*res;
+ 
+     res = p = vim_strsave(orig);
+ 
+     if (res != NULL)
+ 	while (*p != NUL)
+ 	{
+ # ifdef FEAT_MBYTE
+ 	    int		l;
+ 
+ 	    if (enc_utf8)
+ 	    {
+ 		int	c, lc;
+ 		int	newl;
+ 		char_u	*s;
+ 
+ 		c = utf_ptr2char(p);
+ 		lc = utf_tolower(c);
+ 
+ 		/* Reallocate string when byte count changes.  This is rare,
+ 		 * thus it's OK to do another malloc()/free(). */
+ 		l = utf_ptr2len(p);
+ 		newl = utf_char2len(lc);
+ 		if (newl != l)
+ 		{
+ 		    s = alloc((unsigned)STRLEN(res) + 1 + newl - l);
+ 		    if (s == NULL)
+ 		    {
+ 			vim_free(res);
+ 			return NULL;
+ 		    }
+ 		    mch_memmove(s, res, p - res);
+ 		    STRCPY(s + (p - res) + newl, p + l);
+ 		    p = s + (p - res);
+ 		    vim_free(res);
+ 		    res = s;
+ 		}
+ 
+ 		utf_char2bytes(lc, p);
+ 		p += newl;
+ 	    }
+ 	    else if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)
+ 		p += l;		/* skip multi-byte character */
+ 	    else
+ # endif
+ 	    {
+ 		*p = TOLOWER_LOC(*p); /* note that tolower() can be a macro */
+ 		p++;
+ 	    }
+ 	}
  
      return res;
  }
*** ../vim-8.0.0242/src/proto/misc2.pro	2016-11-10 20:01:41.201582868 +0100
--- src/proto/misc2.pro	2017-01-26 22:45:47.252202745 +0100
***************
*** 40,45 ****
--- 40,46 ----
  char_u *vim_strnsave_up(char_u *string, int len);
  void vim_strup(char_u *p);
  char_u *strup_save(char_u *orig);
+ char_u *strlow_save(char_u *orig);
  void del_trailing_spaces(char_u *ptr);
  void vim_strncpy(char_u *to, char_u *from, size_t len);
  void vim_strcat(char_u *to, char_u *from, size_t tosize);
*** ../vim-8.0.0242/src/testdir/test_functions.vim	2017-01-10 16:12:11.732767042 +0100
--- src/testdir/test_functions.vim	2017-01-26 22:45:47.252202745 +0100
***************
*** 16,18 ****
--- 16,163 ----
    call assert_equal(123456789, str2nr('123456789'))
    call assert_equal(-123456789, str2nr('-123456789'))
  endfunc
+ 
+ func Test_tolower()
+   call assert_equal("", tolower(""))
+ 
+   " Test with all printable ASCII characters.
+   call assert_equal(' !"#$%&''()*+,-./0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[\]^_`abcdefghijklmnopqrstuvwxyz{|}~',
+           \ tolower(' !"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~'))
+ 
+   if !has('multi_byte')
+     return
+   endif
+ 
+   " Test with a few uppercase diacritics.
+   call assert_equal("a", tolower("A"))
+   call assert_equal("b", tolower("B"))
+   call assert_equal("c", tolower("C"))
+   call assert_equal("d", tolower("D"))
+   call assert_equal("e", tolower("E"))
+   call assert_equal("f ", tolower("F "))
+   call assert_equal("g", tolower("G"))
+   call assert_equal("h", tolower("H"))
+   call assert_equal("ii", tolower("I"))
+   call assert_equal("j", tolower("J"))
+   call assert_equal("k", tolower("K"))
+   call assert_equal("l", tolower("L"))
+   call assert_equal("m", tolower("M"))
+   call assert_equal("n", tolower("N"))
+   call assert_equal("o", tolower("O"))
+   call assert_equal("p", tolower("P"))
+   call assert_equal("q", tolower("Q"))
+   call assert_equal("r", tolower("R"))
+   call assert_equal("s", tolower("S"))
+   call assert_equal("t", tolower("T"))
+   call assert_equal("u", tolower("U"))
+   call assert_equal("v", tolower("V"))
+   call assert_equal("w", tolower("W"))
+   call assert_equal("x", tolower("X"))
+   call assert_equal("y", tolower("Y"))
+   call assert_equal("z", tolower("Z"))
+ 
+   " Test with a few lowercase diacritics, which should remain unchanged.
+   call assert_equal("a", tolower("a"))
+   call assert_equal("b", tolower("b"))
+   call assert_equal("c", tolower("c"))
+   call assert_equal("d", tolower("d"))
+   call assert_equal("e", tolower("e"))
+   call assert_equal("f", tolower("f"))
+   call assert_equal("g", tolower("g"))
+   call assert_equal("h", tolower("h"))
+   call assert_equal("i", tolower("i"))
+   call assert_equal("j", tolower("j"))
+   call assert_equal("k", tolower("k"))
+   call assert_equal("l", tolower("l"))
+   call assert_equal("m ", tolower("m "))
+   call assert_equal("n", tolower("n"))
+   call assert_equal("o", tolower("o"))
+   call assert_equal("p", tolower("p"))
+   call assert_equal("q", tolower("q"))
+   call assert_equal("r", tolower("r"))
+   call assert_equal("s", tolower("s"))
+   call assert_equal("t", tolower("t"))
+   call assert_equal("u", tolower("u"))
+   call assert_equal("v", tolower("v"))
+   call assert_equal("w", tolower("w"))
+   call assert_equal("", tolower(""))
+   call assert_equal("y", tolower("y"))
+   call assert_equal("z", tolower("z"))
+ 
+   " According to https://twitter.com/jifa/status/625776454479970304
+   "  (U+023A) and  (U+023E) are the *only* code points to increase
+   " in length (2 to 3 bytes) when lowercased. So let's test them.
+   call assert_equal(" ", tolower(" "))
+ endfunc
+ 
+ func Test_toupper()
+   call assert_equal("", toupper(""))
+ 
+   " Test with all printable ASCII characters.
+   call assert_equal(' !"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~',
+           \ toupper(' !"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~'))
+ 
+   if !has('multi_byte')
+     return
+   endif
+ 
+   " Test with a few lowercase diacritics.
+   call assert_equal("A", toupper("a"))
+   call assert_equal("B", toupper("b"))
+   call assert_equal("C", toupper("c"))
+   call assert_equal("D", toupper("d"))
+   call assert_equal("E", toupper("e"))
+   call assert_equal("F", toupper("f"))
+   call assert_equal("G", toupper("g"))
+   call assert_equal("H", toupper("h"))
+   call assert_equal("I", toupper("i"))
+   call assert_equal("J", toupper("j"))
+   call assert_equal("K", toupper("k"))
+   call assert_equal("L", toupper("l"))
+   call assert_equal("M ", toupper("m "))
+   call assert_equal("N", toupper("n"))
+   call assert_equal("O", toupper("o"))
+   call assert_equal("P", toupper("p"))
+   call assert_equal("Q", toupper("q"))
+   call assert_equal("R", toupper("r"))
+   call assert_equal("S", toupper("s"))
+   call assert_equal("T", toupper("t"))
+   call assert_equal("U", toupper("u"))
+   call assert_equal("V", toupper("v"))
+   call assert_equal("W", toupper("w"))
+   call assert_equal("", toupper(""))
+   call assert_equal("Y", toupper("y"))
+   call assert_equal("Z", toupper("z"))
+ 
+   " Test that uppercase diacritics, which should remain unchanged.
+   call assert_equal("A", toupper("A"))
+   call assert_equal("B", toupper("B"))
+   call assert_equal("C", toupper("C"))
+   call assert_equal("D", toupper("D"))
+   call assert_equal("E", toupper("E"))
+   call assert_equal("F ", toupper("F "))
+   call assert_equal("G", toupper("G"))
+   call assert_equal("H", toupper("H"))
+   call assert_equal("I", toupper("I"))
+   call assert_equal("J", toupper("J"))
+   call assert_equal("K", toupper("K"))
+   call assert_equal("L", toupper("L"))
+   call assert_equal("M", toupper("M"))
+   call assert_equal("N", toupper("N"))
+   call assert_equal("O", toupper("O"))
+   call assert_equal("P", toupper("P"))
+   call assert_equal("Q", toupper("Q"))
+   call assert_equal("R", toupper("R"))
+   call assert_equal("S", toupper("S"))
+   call assert_equal("T", toupper("T"))
+   call assert_equal("U", toupper("U"))
+   call assert_equal("V", toupper("V"))
+   call assert_equal("W", toupper("W"))
+   call assert_equal("X", toupper("X"))
+   call assert_equal("Y", toupper("Y"))
+   call assert_equal("Z", toupper("Z"))
+ 
+   call assert_equal(" ", tolower(" "))
+ endfunc
+ 
+ 
*** ../vim-8.0.0242/src/version.c	2017-01-26 22:07:28.518844549 +0100
--- src/version.c	2017-01-26 22:47:42.835465390 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     243,
  /**/

-- 
Courtroom Quote #19:
Q:  Doctor, how many autopsies have you performed on dead people?
A:  All my autopsies have been performed on dead people.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0244
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0244
Problem:    When the user sets t_BE empty after startup to disable bracketed
            paste, this has no direct effect.
Solution:   When t_BE is made empty write t_BD.  When t_BE is made non-empty
            write the new value.
Files:      src/option.c


*** ../vim-8.0.0243/src/option.c	2017-01-21 20:04:17.558757844 +0100
--- src/option.c	2017-01-27 19:43:08.258454798 +0100
***************
*** 6619,6624 ****
--- 6619,6633 ----
  	    mch_set_normal_colors();
  #endif
  	}
+ 	if (varp == &T_BE && termcap_active)
+ 	{
+ 	    if (*T_BE == NUL)
+ 		/* When clearing t_BE we assume the user no longer wants
+ 		 * bracketed paste, thus disable it by writing t_BD. */
+ 		out_str(T_BD);
+ 	    else
+ 		out_str(T_BE);
+ 	}
      }
  
  #ifdef FEAT_LINEBREAK
*** ../vim-8.0.0243/src/version.c	2017-01-26 22:51:51.997875762 +0100
--- src/version.c	2017-01-27 19:43:46.798201572 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     244,
  /**/

-- 
ARTHUR:  Be quiet!
DENNIS:  Well you can't expect to wield supreme executive power just 'cause
         some watery tart threw a sword at you!
ARTHUR:  Shut up!
DENNIS:  I mean, if I went around sayin' I was an empereror just because some
         moistened bint had lobbed a scimitar at me they'd put me away!
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0245
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0245
Problem:    The generated zh_CN.cp936.po message file is not encoded properly.
Solution:   Instead of using zh_CN.po as input, use zh_CN.UTF-8.po.
Files:      src/po/Makefile


*** ../vim-8.0.0244/src/po/Makefile	2014-06-12 17:45:19.000000000 +0200
--- src/po/Makefile	2017-01-27 19:58:38.136318803 +0100
***************
*** 232,243 ****
  	iconv -f iso-8859-2 -t cp1250 sk.po | \
  		sed -e 's/charset=ISO-8859-2/charset=cp1250/' -e 's/# Original translations/# Generated from sk.po, DO NOT EDIT/' > sk.cp1250.po
  
! # Convert zh_CN.po to create zh_CN.cp936.po.
! # set 'charset' to gbk to avoid that msfmt generates a warning
! zh_CN.cp936.po: zh_CN.po
  	rm -f zh_CN.cp936.po
! 	iconv -f gb2312 -t cp936 zh_CN.po | \
! 		sed -e 's/charset=gb2312/charset=gbk/' -e 's/# Original translations/# Generated from zh_CN.po, DO NOT EDIT/' > zh_CN.cp936.po
  
  # Convert ko.UTF-8.po to create ko.po.
  ko.po: ko.UTF-8.po
--- 232,244 ----
  	iconv -f iso-8859-2 -t cp1250 sk.po | \
  		sed -e 's/charset=ISO-8859-2/charset=cp1250/' -e 's/# Original translations/# Generated from sk.po, DO NOT EDIT/' > sk.cp1250.po
  
! # Convert zh_CN.UTF-8.po to create zh_CN.cp936.po.
! # Set 'charset' to gbk to avoid that msfmt generates a warning.
! # This used to convert from zh_CN.po, but that results in a conversion error.
! zh_CN.cp936.po: zh_CN.UTF-8.po
  	rm -f zh_CN.cp936.po
! 	iconv -f UTF-8 -t cp936 zh_CN.UTF-8.po | \
! 		sed -e 's/charset=utf-8/charset=gbk/' -e 's/# Original translations/# Generated from zh_CN.po, DO NOT EDIT/' > zh_CN.cp936.po
  
  # Convert ko.UTF-8.po to create ko.po.
  ko.po: ko.UTF-8.po
*** ../vim-8.0.0244/src/version.c	2017-01-27 20:03:13.466483257 +0100
--- src/version.c	2017-01-27 20:35:36.977554352 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     245,
  /**/

-- 
Q:   How many hardware engineers does it take to change a lightbulb?
A:   None.  We'll fix it in software.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0246
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0246
Problem:    Compiler warnings for int to pointer conversion.
Solution:   Fix macro for mch_memmove(). (John Marriott)
Files:      src/vim.h


*** ../vim-8.0.0245/src/vim.h	2017-01-26 21:36:29.610733183 +0100
--- src/vim.h	2017-01-27 21:17:49.904677081 +0100
***************
*** 1715,1721 ****
  typedef void	    *vim_acl_T;		/* dummy to pass an ACL to a function */
  
  #ifndef mch_memmove
! # define mch_memmove(to, from, len) memmove((char*)(to), (char*)(from), (char*)(len))
  #endif
  
  /*
--- 1715,1721 ----
  typedef void	    *vim_acl_T;		/* dummy to pass an ACL to a function */
  
  #ifndef mch_memmove
! # define mch_memmove(to, from, len) memmove((char*)(to), (char*)(from), (size_t)(len))
  #endif
  
  /*
*** ../vim-8.0.0245/src/version.c	2017-01-27 20:37:45.592698326 +0100
--- src/version.c	2017-01-27 21:19:13.616116793 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     246,
  /**/

-- 
ARTHUR:        What?
BLACK KNIGHT:  None shall pass.
ARTHUR:        I have no quarrel with you, good Sir knight, but I must cross
               this bridge.
BLACK KNIGHT:  Then you shall die.
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0247
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0247
Problem:    Under some circumstances, one needs to type Ctrl-N or Ctrl-P twice
            to have a menu entry selected. (Lifepillar)
Solution:   call ins_compl_free(). (Christian Brabandt, closes #1411)
Files:      src/edit.c, src/testdir/test_popup.vim


*** ../vim-8.0.0246/src/edit.c	2017-01-25 21:36:11.626471765 +0100
--- src/edit.c	2017-01-27 21:31:42.255069908 +0100
***************
*** 2821,2826 ****
--- 2821,2827 ----
      if (ctrl_x_mode != 0)
  	ins_compl_prep(' ');
      ins_compl_clear();
+     ins_compl_free();
  
      compl_direction = FORWARD;
      if (startcol > curwin->w_cursor.col)
*** ../vim-8.0.0246/src/testdir/test_popup.vim	2016-12-09 19:36:52.357659077 +0100
--- src/testdir/test_popup.vim	2017-01-27 21:31:14.839255051 +0100
***************
*** 7,16 ****
    if g:setting != ''
      exe ":set" g:setting
    endif
!   let mth=copy(g:months)
    let entered = strcharpart(getline('.'),0,col('.'))
    if !empty(entered)
!     let mth=filter(mth, 'v:val=~"^".entered')
    endif
    call complete(1, mth) 
    return ''
--- 7,16 ----
    if g:setting != ''
      exe ":set" g:setting
    endif
!   let mth = copy(g:months)
    let entered = strcharpart(getline('.'),0,col('.'))
    if !empty(entered)
!     let mth = filter(mth, 'v:val=~"^".entered')
    endif
    call complete(1, mth) 
    return ''
***************
*** 468,474 ****
  " auto-wrap text.
  func Test_completion_ctrl_e_without_autowrap()
    new
!   let tw_save=&tw
    set tw=78
    let li = [
          \ '"                                                        zzz',
--- 468,474 ----
  " auto-wrap text.
  func Test_completion_ctrl_e_without_autowrap()
    new
!   let tw_save = &tw
    set tw=78
    let li = [
          \ '"                                                        zzz',
***************
*** 478,485 ****
    call feedkeys("A\<C-X>\<C-N>\<C-E>\<Esc>", "tx")
    call assert_equal(li, getline(1, '$'))
  
!   let &tw=tw_save
    q!
  endfunc
  
  " vim: shiftwidth=2 sts=2 expandtab
--- 478,514 ----
    call feedkeys("A\<C-X>\<C-N>\<C-E>\<Esc>", "tx")
    call assert_equal(li, getline(1, '$'))
  
!   let &tw = tw_save
    q!
  endfunc
  
+ function! DummyCompleteSix()
+   call complete(1, ['Hello', 'World'])
+   return ''
+ endfunction
+ 
+ " complete() correctly clears the list of autocomplete candidates
+ " See #1411
+ func Test_completion_clear_candidate_list()
+   new
+   %d
+   " select first entry from the completion popup
+   call feedkeys("a    xxx\<C-N>\<C-R>=DummyCompleteSix()\<CR>", "tx")
+   call assert_equal('Hello', getline(1))
+   %d
+   " select second entry from the completion popup
+   call feedkeys("a    xxx\<C-N>\<C-R>=DummyCompleteSix()\<CR>\<C-N>", "tx")
+   call assert_equal('World', getline(1))
+   %d
+   " select original text
+   call feedkeys("a    xxx\<C-N>\<C-R>=DummyCompleteSix()\<CR>\<C-N>\<C-N>", "tx")
+   call assert_equal('    xxx', getline(1))
+   %d
+   " back at first entry from completion list
+   call feedkeys("a    xxx\<C-N>\<C-R>=DummyCompleteSix()\<CR>\<C-N>\<C-N>\<C-N>", "tx")
+   call assert_equal('Hello', getline(1))
+ 
+   bw!
+ endfunc
+ 
  " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.0.0246/src/version.c	2017-01-27 21:22:14.094909115 +0100
--- src/version.c	2017-01-27 21:34:36.785891735 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     247,
  /**/

-- 
    f y cn rd ths thn y cn hv grt jb n cmptr prgrmmng

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0248
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0248
Problem:    vim_strcat() cannot handle overlapping arguments.
Solution:   Use mch_memmove() instead of strcpy(). (Justin M Keyes,
            closes #1415)
Files:      src/misc2.c


*** ../vim-8.0.0247/src/misc2.c	2017-01-26 22:51:51.997875762 +0100
--- src/misc2.c	2017-01-27 21:51:16.059159881 +0100
***************
*** 1719,1725 ****
  
  /*
   * Like strcat(), but make sure the result fits in "tosize" bytes and is
!  * always NUL terminated.
   */
      void
  vim_strcat(char_u *to, char_u *from, size_t tosize)
--- 1719,1725 ----
  
  /*
   * Like strcat(), but make sure the result fits in "tosize" bytes and is
!  * always NUL terminated. "from" and "to" may overlap.
   */
      void
  vim_strcat(char_u *to, char_u *from, size_t tosize)
***************
*** 1733,1739 ****
  	to[tosize - 1] = NUL;
      }
      else
! 	STRCPY(to + tolen, from);
  }
  
  /*
--- 1733,1739 ----
  	to[tosize - 1] = NUL;
      }
      else
! 	mch_memmove(to + tolen, from, fromlen + 1);
  }
  
  /*
*** ../vim-8.0.0247/src/version.c	2017-01-27 21:48:46.960162956 +0100
--- src/version.c	2017-01-27 21:52:25.134695318 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     248,
  /**/

-- 
ARTHUR:        I command you as King of the Britons to stand aside!
BLACK KNIGHT:  I move for no man.
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0249
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0249
Problem:    When two submits happen quick after each other, the tests for the
            first one may error out.
Solution:   Use a git depth of 10 instead of 1. (Christian Brabandt)
Files:      .travis.yml


*** ../vim-8.0.0248/.travis.yml	2017-01-26 21:23:44.583641679 +0100
--- .travis.yml	2017-01-27 22:15:08.497514404 +0100
***************
*** 25,31 ****
  sudo: false
  
  git:
!   depth: 1
  
  # instead of a 2*2*8 matrix (2*os + 2*compiler + 8*env),
  # exclude some builds on mac os x and linux
--- 25,31 ----
  sudo: false
  
  git:
!   depth: 10
  
  # instead of a 2*2*8 matrix (2*os + 2*compiler + 8*env),
  # exclude some builds on mac os x and linux
*** ../vim-8.0.0248/src/version.c	2017-01-27 21:54:03.986030660 +0100
--- src/version.c	2017-01-27 22:04:34.949781713 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     249,
  /**/

-- 
ARTHUR:        A scratch?  Your arm's off!
BLACK KNIGHT:  No, it isn't.
ARTHUR:        Well, what's that then?
BLACK KNIGHT:  I've had worse.
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0250
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0250
Problem:    When virtcol() gets a column that is not the first byte of a
            multi-byte character the result is unpredictable. (Christian
            Ludwig)
Solution:   Correct the column to the first byte of a multi-byte character.
            Change the utf-8 test to new style.
Files:      src/charset.c, src/testdir/test_utf8.in, src/testdir/test_utf8.ok,
            src/testdir/test_utf8.vim, src/Makefile, src/testdir/Make_all.mak,
            src/testdir/test_alot_utf8.vim


*** ../vim-8.0.0249/src/charset.c	2017-01-22 18:34:53.680030808 +0100
--- src/charset.c	2017-01-28 13:09:08.113016078 +0100
***************
*** 1296,1302 ****
--- 1296,1309 ----
      if (pos->col == MAXCOL)
  	posptr = NULL;  /* continue until the NUL */
      else
+     {
  	posptr = ptr + pos->col;
+ #ifdef FEAT_MBYTE
+ 	if (has_mbyte)
+ 	    /* always start on the first byte */
+ 	    posptr -= (*mb_head_off)(line, posptr);
+ #endif
+     }
  
      /*
       * This function is used very often, do some speed optimizations.
*** ../vim-8.0.0249/src/testdir/test_utf8.in	2015-11-22 15:04:56.000000000 +0100
--- src/testdir/test_utf8.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,46 ****
- Tests for Unicode manipulations                vim: set ft=vim :
-  
- STARTTEST
- :so small.vim
- :set encoding=utf-8
- :"
- :" Visual block Insert adjusts for multi-byte char
- :new
- :call setline(1, ["aaa", "", "bbb"])
- :exe ":norm! gg0l\<C-V>jjIx\<Esc>"
- :let r = getline(1, '$')
- :"
- :bwipeout!
- :$put=r
- :"
- :" Test for built-in function strchars()
- :for str in ["a", "a", "A\u20dd", "A\u20dd\u20dd", "\u20dd"]
- :	$put=strchars(str)
- :	$put=strchars(str, 0)
- :	$put=strchars(str, 1)
- :endfor
- :"
- :" Test for customlist completion
- :function! CustomComplete1(lead, line, pos)
- :	return ['', '']
- :endfunction
- :command -nargs=1 -complete=customlist,CustomComplete1 Test1 echo
- :call feedkeys(":Test1 \<C-L>'\<C-B>$put='\<CR>", 'it')
- :"
- :function! CustomComplete2(lead, line, pos)
- :	return ['', '', '']
- :endfunction
- :command -nargs=1 -complete=customlist,CustomComplete2 Test2 echo
- :call feedkeys(":Test2 \<C-L>'\<C-B>$put='\<CR>", 'it')
- :"
- :function! CustomComplete3(lead, line, pos)
- :	return ['N', 'N', 'N']
- :endfunction
- :command -nargs=1 -complete=customlist,CustomComplete3 Test3 echo
- :call feedkeys(":Test3 \<C-L>'\<C-B>$put='\<CR>", 'it')
- :"
- :call garbagecollect(1)
- :/^start:/,$wq! test.out
- ENDTEST
-  
- start:
--- 0 ----
*** ../vim-8.0.0249/src/testdir/test_utf8.ok	2015-11-19 18:42:47.000000000 +0100
--- src/testdir/test_utf8.ok	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,22 ****
- start:
- axaa
- x
- bxbb
- 1
- 1
- 1
- 3
- 3
- 3
- 2
- 2
- 1
- 3
- 3
- 1
- 1
- 1
- 1
- Test1 
- Test2 
- Test3 N
--- 0 ----
*** ../vim-8.0.0249/src/testdir/test_utf8.vim	2017-01-28 13:46:00.323189782 +0100
--- src/testdir/test_utf8.vim	2017-01-28 13:36:55.086595457 +0100
***************
*** 0 ****
--- 1,65 ----
+ " Tests for Unicode manipulations
+ if !has('multi_byte')
+   finish
+ endif
+  
+ 
+ " Visual block Insert adjusts for multi-byte char
+ func Test_visual_block_insert()
+   new
+   call setline(1, ["aaa", "", "bbb"])
+   exe ":norm! gg0l\<C-V>jjIx\<Esc>"
+   call assert_equal(['axaa', 'x', 'bxbb'], getline(1, '$'))
+   bwipeout!
+ endfunc
+ 
+ " Test for built-in function strchars()
+ func Test_strchars()
+   let inp = ["a", "a", "A\u20dd", "A\u20dd\u20dd", "\u20dd"]
+   let exp = [[1, 1, 1], [3, 3, 3], [2, 2, 1], [3, 3, 1], [1, 1, 1]]
+   for i in range(len(inp))
+     call assert_equal(exp[i][0], strchars(inp[i]))
+     call assert_equal(exp[i][1], strchars(inp[i], 0))
+     call assert_equal(exp[i][2], strchars(inp[i], 1))
+   endfor
+ endfunc
+ 
+ " Test for customlist completion
+ function! CustomComplete1(lead, line, pos)
+ 	return ['', '']
+ endfunction
+ 
+ function! CustomComplete2(lead, line, pos)
+ 	return ['', '', '']
+ endfunction
+ 
+ function! CustomComplete3(lead, line, pos)
+ 	return ['N', 'N', 'N']
+ endfunction
+ 
+ func Test_customlist_completion()
+   command -nargs=1 -complete=customlist,CustomComplete1 Test1 echo
+   call feedkeys(":Test1 \<C-L>\<C-B>\"\<CR>", 'itx')
+   call assert_equal('"Test1 ', getreg(':'))
+ 
+   command -nargs=1 -complete=customlist,CustomComplete2 Test2 echo
+   call feedkeys(":Test2 \<C-L>\<C-B>\"\<CR>", 'itx')
+   call assert_equal('"Test2 ', getreg(':'))
+ 
+   command -nargs=1 -complete=customlist,CustomComplete3 Test3 echo
+   call feedkeys(":Test3 \<C-L>\<C-B>\"\<CR>", 'itx')
+   call assert_equal('"Test3 N', getreg(':'))
+ 
+   call garbagecollect(1)
+ endfunc
+ 
+ " Yank one 3 byte character and check the mark columns.
+ func Test_getvcol()
+   new
+   call setline(1, "x\u2500x")
+   normal 0lvy
+   call assert_equal(2, col("'["))
+   call assert_equal(4, col("']"))
+   call assert_equal(2, virtcol("'["))
+   call assert_equal(2, virtcol("']"))
+ endfunc
*** ../vim-8.0.0249/src/Makefile	2017-01-24 18:58:14.910505196 +0100
--- src/Makefile	2017-01-28 13:13:36.431338517 +0100
***************
*** 2058,2064 ****
  	test_listlbr \
  	test_listlbr_utf8 \
  	test_search_mbyte \
- 	test_utf8 \
  	test_wordcount \
  	test3 test4 test5 test6 test7 test8 test9 \
  	test11 test12 test14 test15 test17 test18 test19 \
--- 2058,2063 ----
***************
*** 2183,2188 ****
--- 2182,2188 ----
  	test_undo \
  	test_unlet \
  	test_usercommands \
+ 	test_utf8 \
  	test_viminfo \
  	test_viml \
  	test_visual \
*** ../vim-8.0.0249/src/testdir/Make_all.mak	2017-01-24 18:58:14.910505196 +0100
--- src/testdir/Make_all.mak	2017-01-28 13:13:49.311257953 +0100
***************
*** 84,90 ****
  	test_listchars.out \
  	test_listlbr.out \
  	test_search_mbyte.out \
- 	test_utf8.out \
  	test_wordcount.out
  
  
--- 84,89 ----
*** ../vim-8.0.0249/src/testdir/test_alot_utf8.vim	2016-08-17 21:29:14.000000000 +0200
--- src/testdir/test_alot_utf8.vim	2017-01-28 13:14:29.783004807 +0100
***************
*** 9,11 ****
--- 9,12 ----
  source test_matchadd_conceal_utf8.vim
  source test_regexp_utf8.vim
  source test_source_utf8.vim
+ source test_utf8.vim
*** ../vim-8.0.0249/src/version.c	2017-01-27 22:20:09.539496898 +0100
--- src/version.c	2017-01-28 13:45:18.595450378 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     250,
  /**/

-- 
MARTHA'S WAY: Don't throw out all that leftover wine. Freeze into ice cubes
              for future use in casseroles and sauces.
MY WAY:       What leftover wine?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0251
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0251
Problem:    It is not so easy to write a script that works with both Python 2
            and Python 3, even when the Python code works with both.
Solution:   Add 'pyxversion', :pyx, etc. (Marc Weber, Ken Takata)
Files:      Filelist, runtime/doc/eval.txt, runtime/doc/if_pyth.txt,
            runtime/doc/index.txt, runtime/doc/options.txt,
            runtime/optwin.vim, runtime/doc/quickref.txt,
            runtime/doc/usr_41.txt, src/Makefile, src/evalfunc.c,
            src/ex_cmds.h, src/ex_cmds2.c, src/ex_docmd.c, src/if_python.c,
            src/if_python3.c, src/option.c, src/option.h,
            src/proto/ex_cmds2.pro, src/testdir/Make_all.mak,
            src/testdir/pyxfile/py2_magic.py,
            src/testdir/pyxfile/py2_shebang.py,
            src/testdir/pyxfile/py3_magic.py,
            src/testdir/pyxfile/py3_shebang.py, src/testdir/pyxfile/pyx.py,
            src/testdir/test_pyx2.vim, src/testdir/test_pyx3.vim
            src/userfunc.c


*** ../vim-8.0.0250/Filelist	2016-11-12 21:12:48.534182259 +0100
--- Filelist	2017-01-28 15:08:23.499487990 +0100
***************
*** 122,127 ****
--- 122,128 ----
  		src/testdir/pythonx/topmodule/submodule/subsubmodule/subsubsubmodule.py \
  		src/testdir/python_after/*.py \
  		src/testdir/python_before/*.py \
+ 		src/testdir/pyxfile/*.py \
  		src/testdir/bench*.in \
  		src/testdir/bench*.vim \
  		src/testdir/samples/*.txt \
*** ../vim-8.0.0250/runtime/doc/eval.txt	2017-01-25 22:39:22.197329826 +0100
--- runtime/doc/eval.txt	2017-01-28 15:39:48.767447424 +0100
***************
*** 2239,2244 ****
--- 2239,2245 ----
  pumvisible()			Number	whether popup menu is visible
  pyeval({expr})			any	evaluate |Python| expression
  py3eval({expr})			any	evaluate |python3| expression
+ pyxeval({expr})			any	evaluate |python_x| expression
  range({expr} [, {max} [, {stride}]])
  				List	items from {expr} to {max}
  readfile({fname} [, {binary} [, {max}]])
***************
*** 6162,6167 ****
--- 6172,6185 ----
  		non-string keys result in error.
  		{only available when compiled with the |+python| feature}
  
+ pyxeval({expr})						*pyxeval()*
+ 		Evaluate Python expression {expr} and return its result
+ 		converted to Vim data structures.
+ 		Uses Python 2 or 3, see |python_x| and 'pyxversion'.
+ 		See also: |pyeval()|, |py3eval()|
+ 		{only available when compiled with the |+python| or the
+ 		|+python3| feature}
+ 
  							*E726* *E727*
  range({expr} [, {max} [, {stride}]])				*range()*
  		Returns a |List| with Numbers:
***************
*** 8400,8405 ****
--- 8419,8425 ----
  profile			Compiled with |:profile| support.
  python			Compiled with Python 2.x interface. |has-python|
  python3			Compiled with Python 3.x interface. |has-python|
+ pythonx			Compiled with |python_x| interface. |has-pythonx|
  qnx			QNX version of Vim.
  quickfix		Compiled with |quickfix| support.
  reltime			Compiled with |reltime()| support.
*** ../vim-8.0.0250/runtime/doc/if_pyth.txt	2016-09-12 12:45:25.000000000 +0200
--- runtime/doc/if_pyth.txt	2017-01-28 15:48:35.864083247 +0100
***************
*** 16,21 ****
--- 16,22 ----
  8. pyeval(), py3eval() Vim functions		|python-pyeval|
  9. Dynamic loading				|python-dynamic|
  10. Python 3					|python3|
+ 11. Python X					|python_x|
  
  {Vi does not have any of these commands}
  
***************
*** 711,716 ****
--- 712,718 ----
  
  To facilitate bi-directional interface, you can use |pyeval()| and |py3eval()| 
  functions to evaluate Python expressions and pass their values to VimL.
+ |pyxeval()| is also available.
  
  ==============================================================================
  9. Dynamic loading					*python-dynamic*
***************
*** 748,758 ****
  The `:py3` and `:python3` commands work similar to `:python`.  A simple check
  if the `:py3` command is working: >
  	:py3 print("Hello")
! <							*:py3file*
  To see what version of Python you have: >
  	:py3 import sys
  	:py3 print(sys.version)
! 
  The `:py3file` command works similar to `:pyfile`.
  							*:py3do*
  The `:py3do` command works similar to `:pydo`.
--- 750,760 ----
  The `:py3` and `:python3` commands work similar to `:python`.  A simple check
  if the `:py3` command is working: >
  	:py3 print("Hello")
! 
  To see what version of Python you have: >
  	:py3 import sys
  	:py3 print(sys.version)
! <							*:py3file*
  The `:py3file` command works similar to `:pyfile`.
  							*:py3do*
  The `:py3do` command works similar to `:pydo`.
***************
*** 812,815 ****
--- 814,881 ----
  the other one from being available.
  
  ==============================================================================
+ 11. Python X						*python_x* *pythonx*
+ 
+ Because most python code can be written so that it works with python 2.6+ and
+ python 3 the pyx* functions and commands have been writen.  They work exactly
+ the same as the Python 2 and 3 variants, but select the Python version using
+ the 'pyxversion' setting.
+ 
+ You should set 'pyxversion' in your |.vimrc| to prefer Python 2 or Python 3
+ for Python commands. If you change this setting at runtime you may risk that
+ state of plugins (such as initialization) may be lost.
+ 
+ If you want to use a module, you can put it in the {rtp}/pythonx directory.
+ See |pythonx-directory|.
+ 
+ 							*:pyx* *:pythonx*
+ The `:pyx` and `:pythonx` commands work similar to `:python`.  A simple check
+ if the `:pyx` command is working: >
+ 	:pyx print("Hello")
+ 
+ To see what version of Python is being used: >
+ 	:pyx import sys
+ 	:pyx print(sys.version)
+ <
+ 					*:pyxfile* *python_x-special-comments*
+ The `:pyxfile` command works similar to `:pyfile`.  However you can add one of
+ these comments to force Vim using `:pyfile` or `:py3file`: >
+   #!/any string/python2		" Shebang. Must be the first line of the file.
+   #!/any string/python3		" Shebang. Must be the first line of the file.
+   # requires python 2.x		" Maximum lines depend on 'modelines'.
+   # requires python 3.x		" Maximum lines depend on 'modelines'.
+ Unlike normal modelines, the bottom of the file is not checked.
+ If none of them are found, the 'pyxversion' setting is used.
+ 							*W20* *W21*
+ If Vim does not support the selected Python version a silent message will be
+ printed.  Use `:messages` to read them.
+ 
+ 							*:pyxdo*
+ The `:pyxdo` command works similar to `:pydo`.
+ 
+ 							*has-pythonx*
+ You can test if pyx* commands are available with: >
+ 	if has('pythonx')
+ 	  echo 'pyx* commands are available. (Python ' . &pyx . ')'
+ 	endif
+ 
+ When compiled with only one of |+python| or |+python3|, the has() returns 1.
+ When compiled with both |+python| and |+python3|, the test depends on the
+ 'pyxversion' setting.  If 'pyxversion' is 0, it tests Python 3 first, and if
+ it is not available then Python 2.  If 'pyxversion' is 2 or 3, it tests only
+ Python 2 or 3 respectively.
+ 
+ Note that for has('pythonx') to work it may try to dynamically load Python 3
+ or 2.  This may have side effects, especially when Vim can only load one of
+ the two.
+ 
+ If a user prefers Python 2 and want to fallback to Python 3, he needs to set
+ 'pyxversion' explicitly in his |.vimrc|.  E.g.: >
+ 	if has('python')
+ 	  set pyx=2
+ 	elseif has('python3')
+ 	  set pyx=3
+ 	endif
+ 
+ ==============================================================================
   vim:tw=78:ts=8:ft=help:norl:
*** ../vim-8.0.0250/runtime/doc/index.txt	2016-09-12 12:45:26.000000000 +0200
--- runtime/doc/index.txt	2017-01-28 15:08:23.503487964 +0100
***************
*** 1440,1445 ****
--- 1440,1449 ----
  |:python|	:py[thon]	execute Python command
  |:pydo|		:pyd[o]		execute Python command for each line
  |:pyfile|	:pyf[ile]	execute Python script file
+ |:pyx|		:pyx		execute |python_x| command
+ |:pythonx|	:pythonx	same as :pyx
+ |:pyxdo|	:pyxd[o]	execute |python_x| command for each line
+ |:pyxfile|	:pyxf[ile]	execute |python_x| script file
  |:quit|		:q[uit]		quit current window (when one window quit Vim)
  |:quitall|	:quita[ll]	quit Vim
  |:qall|		:qa[ll]		quit Vim
*** ../vim-8.0.0250/runtime/doc/options.txt	2017-01-14 14:28:26.964592279 +0100
--- runtime/doc/options.txt	2017-01-28 15:22:15.538173043 +0100
***************
*** 5782,5787 ****
--- 5789,5822 ----
  	This option cannot be set from a |modeline| or in the |sandbox|, for
  	security reasons.
  
+ 						*'pyxversion'* *'pyx'*
+ 'pyxversion' 'pyx'	number	(default depends on the build)
+ 			global
+ 			{not in Vi}
+ 			{only available when compiled with the |+python| or
+ 			the |+python3| feature}
+ 	Specifies the python version used for pyx* functions and commands
+ 	|python_x|.  The default value is as follows:
+ 
+ 		Compiled with		     Default ~
+ 		|+python| and |+python3|	0
+ 		only |+python|			2
+ 		only |+python3|			3
+ 
+ 	Available values are 0, 2 and 3.
+ 	If 'pyxversion' is 0, it is set to 2 or 3 after the first execution of
+ 	any python2/3 commands or functions.  E.g. `:py` sets to 2, and `:py3`
+ 	sets to 3. `:pyx` sets it to 3 if Python 3 is available, otherwise sets
+ 	to 2 if Python 2 is available.
+ 	See also: |has-pythonx|
+ 
+ 	If Vim is compiled with only |+python| or |+python3| setting
+ 	'pyxversion' has no effect.  The pyx* functions and commands are
+ 	always the same as the compiled version.
+ 
+ 	This option cannot be set from a |modeline| or in the |sandbox|, for
+ 	security reasons.
+ 
  						*'quoteescape'* *'qe'*
  'quoteescape' 'qe'	string	(default "\")
  			local to buffer
*** ../vim-8.0.0250/runtime/optwin.vim	2016-08-21 16:44:09.000000000 +0200
--- runtime/optwin.vim	2017-01-28 15:37:59.840143093 +0100
***************
*** 923,929 ****
    call append("$", "foldmarker\tmarkers used when 'foldmethod' is \"marker\"")
    call append("$", "\t(local to window)")
    call <SID>OptionL("fmr")
!   call append("$", "foldnestmax\tmaximum fold depth for when 'foldmethod is \"indent\" or \"syntax\"")
    call append("$", "\t(local to window)")
    call <SID>OptionL("fdn")
  endif
--- 923,929 ----
    call append("$", "foldmarker\tmarkers used when 'foldmethod' is \"marker\"")
    call append("$", "\t(local to window)")
    call <SID>OptionL("fmr")
!   call append("$", "foldnestmax\tmaximum fold depth for when 'foldmethod' is \"indent\" or \"syntax\"")
    call append("$", "\t(local to window)")
    call <SID>OptionL("fdn")
  endif
***************
*** 1324,1329 ****
--- 1324,1333 ----
    call append("$", "perldll\tname of the Perl dynamic library")
    call <SID>OptionG("perldll", &perldll)
  endif
+ if has('pythonx')
+   call append("$", "pyxversion\twhether to use Python 2 or 3")
+   call append("$", " \tset pyx=" . &wd)
+ endif
  if exists("&pythondll")
    call append("$", "pythondll\tname of the Python 2 dynamic library")
    call <SID>OptionG("pythondll", &pythondll)
*** ../vim-8.0.0250/runtime/doc/quickref.txt	2016-09-12 12:45:48.000000000 +0200
--- runtime/doc/quickref.txt	2017-01-28 15:08:23.507487939 +0100
***************
*** 835,840 ****
--- 835,841 ----
  'pumheight'	  'ph'	    maximum height of the popup menu
  'pythondll'		    name of the Python 2 dynamic library
  'pythonthreedll'	    name of the Python 3 dynamic library
+ 'pyxversion'	  'pyx'	    Python version used for pyx* commands
  'quoteescape'	  'qe'	    escape characters used in a string
  'readonly'	  'ro'	    disallow writing the buffer
  'redrawtime'	  'rdt'     timeout for 'hlsearch' and |:match| highlighting
***************
*** 1067,1072 ****
--- 1068,1075 ----
  |c_<Up>|	<Up>/<Down>	   recall older/newer command-line that starts
  				      with current command
  |c_<S-Up>|	<S-Up>/<S-Down>	   recall older/newer command-line from history
+ |c_CTRL-G|	CTRL-G		   next match when 'incsearch' is active
+ |c_CTRL-T|	CTRL-T		   previous match when 'incsearch' is active
  |:history|	:his[tory]	   show older command-lines
  
  Context-sensitive completion on the command-line:
*** ../vim-8.0.0250/runtime/doc/usr_41.txt	2016-09-12 12:45:49.000000000 +0200
--- runtime/doc/usr_41.txt	2017-01-28 15:08:23.507487939 +0100
***************
*** 930,935 ****
--- 930,936 ----
  	test_null_string()	return a null String
  
  Inter-process communication:		    *channel-functions*
+ 	ch_canread()		check if there is something to read
  	ch_open()		open a channel
  	ch_close()		close a channel
  	ch_close_in()		close the in part of a channel
***************
*** 999,1004 ****
--- 1000,1006 ----
  	perleval()		evaluate Perl expression (|+perl|)
  	py3eval()		evaluate Python expression (|+python3|)
  	pyeval()		evaluate Python expression (|+python|)
+ 	pyxeval()		evaluate |python_x| expression
  
  ==============================================================================
  *41.7*	Defining a function
*** ../vim-8.0.0250/src/Makefile	2017-01-28 13:47:48.514498621 +0100
--- src/Makefile	2017-01-28 15:08:23.511487912 +0100
***************
*** 2151,2156 ****
--- 2151,2158 ----
  	test_popup \
  	test_profile \
  	test_put \
+ 	test_pyx2 \
+ 	test_pyx3 \
  	test_quickfix \
  	test_regexp_latin \
  	test_regexp_utf8 \
***************
*** 2754,2759 ****
--- 2756,2762 ----
  				 ../../testdir/*.vim \
  				 ../../testdir/*.py \
  				 ../../testdir/python* \
+ 				 ../../testdir/pyxfile \
  				 ../../testdir/sautest \
  				 ../../testdir/samples \
  				 ../../testdir/test83-tags? \
*** ../vim-8.0.0250/src/evalfunc.c	2017-01-26 22:51:51.993875787 +0100
--- src/evalfunc.c	2017-01-28 15:51:08.875107284 +0100
***************
*** 289,294 ****
--- 289,297 ----
  #ifdef FEAT_PYTHON
  static void f_pyeval(typval_T *argvars, typval_T *rettv);
  #endif
+ #if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)
+ static void f_pyxeval(typval_T *argvars, typval_T *rettv);
+ #endif
  static void f_range(typval_T *argvars, typval_T *rettv);
  static void f_readfile(typval_T *argvars, typval_T *rettv);
  static void f_reltime(typval_T *argvars, typval_T *rettv);
***************
*** 716,721 ****
--- 719,727 ----
  #ifdef FEAT_PYTHON
      {"pyeval",		1, 1, f_pyeval},
  #endif
+ #if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)
+     {"pyxeval",		1, 1, f_pyxeval},
+ #endif
      {"range",		1, 3, f_range},
      {"readfile",	1, 3, f_readfile},
      {"reltime",		0, 2, f_reltime},
***************
*** 5734,5748 ****
  #ifdef FEAT_PERSISTENT_UNDO
  	"persistent_undo",
  #endif
! #ifdef FEAT_PYTHON
! #ifndef DYNAMIC_PYTHON
  	"python",
  #endif
! #endif
! #ifdef FEAT_PYTHON3
! #ifndef DYNAMIC_PYTHON3
  	"python3",
! #endif
  #endif
  #ifdef FEAT_POSTSCRIPT
  	"postscript",
--- 5740,5752 ----
  #ifdef FEAT_PERSISTENT_UNDO
  	"persistent_undo",
  #endif
! #if defined(FEAT_PYTHON) && !defined(DYNAMIC_PYTHON)
  	"python",
+ 	"pythonx",
  #endif
! #if defined(FEAT_PYTHON3) && !defined(DYNAMIC_PYTHON3)
  	"python3",
! 	"pythonx",
  #endif
  #ifdef FEAT_POSTSCRIPT
  	"postscript",
***************
*** 5972,5988 ****
  	else if (STRICMP(name, "ruby") == 0)
  	    n = ruby_enabled(FALSE);
  #endif
- #ifdef FEAT_PYTHON
  #ifdef DYNAMIC_PYTHON
  	else if (STRICMP(name, "python") == 0)
  	    n = python_enabled(FALSE);
  #endif
- #endif
- #ifdef FEAT_PYTHON3
  #ifdef DYNAMIC_PYTHON3
  	else if (STRICMP(name, "python3") == 0)
  	    n = python3_enabled(FALSE);
  #endif
  #endif
  #ifdef DYNAMIC_PERL
  	else if (STRICMP(name, "perl") == 0)
--- 5976,6005 ----
  	else if (STRICMP(name, "ruby") == 0)
  	    n = ruby_enabled(FALSE);
  #endif
  #ifdef DYNAMIC_PYTHON
  	else if (STRICMP(name, "python") == 0)
  	    n = python_enabled(FALSE);
  #endif
  #ifdef DYNAMIC_PYTHON3
  	else if (STRICMP(name, "python3") == 0)
  	    n = python3_enabled(FALSE);
  #endif
+ #if defined(DYNAMIC_PYTHON) || defined(DYNAMIC_PYTHON3)
+ 	else if (STRICMP(name, "pythonx") == 0)
+ 	{
+ # if defined(DYNAMIC_PYTHON) && defined(DYNAMIC_PYTHON3)
+ 	    if (p_pyx == 0)
+ 		n = python3_enabled(FALSE) || python_enabled(FALSE);
+ 	    else if (p_pyx == 3)
+ 		n = python3_enabled(FALSE);
+ 	    else if (p_pyx == 2)
+ 		n = python_enabled(FALSE);
+ # elif defined(DYNAMIC_PYTHON)
+ 	    n = python_enabled(FALSE);
+ # elif defined(DYNAMIC_PYTHON3)
+ 	    n = python3_enabled(FALSE);
+ # endif
+ 	}
  #endif
  #ifdef DYNAMIC_PERL
  	else if (STRICMP(name, "perl") == 0)
***************
*** 8007,8012 ****
--- 8024,8032 ----
      char_u	*str;
      char_u	buf[NUMBUFLEN];
  
+     if (p_pyx == 0)
+ 	p_pyx = 3;
+ 
      str = get_tv_string_buf(&argvars[0], buf);
      do_py3eval(str, rettv);
  }
***************
*** 8022,8032 ****
--- 8042,8076 ----
      char_u	*str;
      char_u	buf[NUMBUFLEN];
  
+     if (p_pyx == 0)
+ 	p_pyx = 2;
+ 
      str = get_tv_string_buf(&argvars[0], buf);
      do_pyeval(str, rettv);
  }
  #endif
  
+ #if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)
+ /*
+  * "pyxeval()" function
+  */
+     static void
+ f_pyxeval(typval_T *argvars, typval_T *rettv)
+ {
+ # if defined(FEAT_PYTHON) && defined(FEAT_PYTHON3)
+     init_pyxversion();
+     if (p_pyx == 2)
+ 	f_pyeval(argvars, rettv);
+     else
+ 	f_py3eval(argvars, rettv);
+ # elif defined(FEAT_PYTHON)
+     f_pyeval(argvars, rettv);
+ # elif defined(FEAT_PYTHON3)
+     f_py3eval(argvars, rettv);
+ # endif
+ }
+ #endif
+ 
  /*
   * "range()" function
   */
*** ../vim-8.0.0250/src/ex_cmds.h	2016-11-15 21:16:46.750453046 +0100
--- src/ex_cmds.h	2017-01-28 15:08:23.511487912 +0100
***************
*** 1132,1137 ****
--- 1132,1149 ----
  EX(CMD_py3file,		"py3file",	ex_py3file,
  			RANGE|FILE1|NEEDARG|CMDWIN,
  			ADDR_LINES),
+ EX(CMD_pyx,		"pyx",		ex_pyx,
+ 			RANGE|EXTRA|NEEDARG|CMDWIN,
+ 			ADDR_LINES),
+ EX(CMD_pyxdo,		"pyxdo",	ex_pyxdo,
+ 			RANGE|DFLALL|EXTRA|NEEDARG|CMDWIN,
+ 			ADDR_LINES),
+ EX(CMD_pythonx,		"pythonx",	ex_pyx,
+ 			RANGE|EXTRA|NEEDARG|CMDWIN,
+ 			ADDR_LINES),
+ EX(CMD_pyxfile,		"pyxfile",	ex_pyxfile,
+ 			RANGE|FILE1|NEEDARG|CMDWIN,
+ 			ADDR_LINES),
  EX(CMD_quit,		"quit",		ex_quit,
  			BANG|RANGE|COUNT|NOTADR|TRLBAR|CMDWIN,
  			ADDR_WINDOWS),
*** ../vim-8.0.0250/src/ex_cmds2.c	2017-01-12 20:28:22.454078272 +0100
--- src/ex_cmds2.c	2017-01-28 15:48:28.428130683 +0100
***************
*** 3675,3680 ****
--- 3675,3868 ----
  }
  #endif
  
+ #if defined(FEAT_PYTHON3) || defined(FEAT_PYTHON) || defined(PROTO)
+ 
+ # if (defined(FEAT_PYTHON) && defined(FEAT_PYTHON3)) || defined(PROTO)
+ /*
+  * Detect Python 3 or 2, and initialize 'pyxversion'.
+  */
+     void
+ init_pyxversion(void)
+ {
+     if (p_pyx == 0)
+     {
+ 	if (python3_enabled(FALSE))
+ 	    p_pyx = 3;
+ 	else if (python_enabled(FALSE))
+ 	    p_pyx = 2;
+     }
+ }
+ # endif
+ 
+ /*
+  * Does a file contain one of the following strings at the beginning of any
+  * line?
+  * "#!(any string)python2"  => returns 2
+  * "#!(any string)python3"  => returns 3
+  * "# requires python 2.x"  => returns 2
+  * "# requires python 3.x"  => returns 3
+  * otherwise return 0.
+  */
+     static int
+ requires_py_version(char_u *filename)
+ {
+     FILE    *file;
+     int	    requires_py_version = 0;
+     int	    i, lines;
+ 
+     lines = (int)p_mls;
+     if (lines < 0)
+ 	lines = 5;
+ 
+     file = mch_fopen((char *)filename, "r");
+     if (file != NULL)
+     {
+ 	for (i = 0; i < lines; i++)
+ 	{
+ 	    if (vim_fgets(IObuff, IOSIZE, file))
+ 		break;
+ 	    if (i == 0 && IObuff[0] == '#' && IObuff[1] == '!')
+ 	    {
+ 		/* Check shebang. */
+ 		if (strstr((char *)IObuff + 2, "python2") != NULL)
+ 		{
+ 		    requires_py_version = 2;
+ 		    break;
+ 		}
+ 		if (strstr((char *)IObuff + 2, "python3") != NULL)
+ 		{
+ 		    requires_py_version = 3;
+ 		    break;
+ 		}
+ 	    }
+ 	    IObuff[21] = '\0';
+ 	    if (STRCMP("# requires python 2.x", IObuff) == 0)
+ 	    {
+ 		requires_py_version = 2;
+ 		break;
+ 	    }
+ 	    if (STRCMP("# requires python 3.x", IObuff) == 0)
+ 	    {
+ 		requires_py_version = 3;
+ 		break;
+ 	    }
+ 	}
+ 	fclose(file);
+     }
+     return requires_py_version;
+ }
+ 
+ 
+ /*
+  * Source a python file using the requested python version.
+  */
+     static void
+ source_pyx_file(exarg_T *eap, char_u *fname)
+ {
+     exarg_T ex;
+     int	    v = requires_py_version(fname);
+ 
+ # if defined(FEAT_PYTHON) && defined(FEAT_PYTHON3)
+     init_pyxversion();
+ # endif
+     if (v == 0)
+     {
+ # if defined(FEAT_PYTHON) && defined(FEAT_PYTHON3)
+ 	/* user didn't choose a preference, 'pyx' is used */
+ 	v = p_pyx;
+ # elif defined(FEAT_PYTHON)
+ 	v = 2;
+ # elif defined(FEAT_PYTHON3)
+ 	v = 3;
+ # endif
+     }
+ 
+     /*
+      * now source, if required python version is not supported show
+      * unobtrusive message.
+      */
+     if (eap == NULL)
+ 	vim_memset(&ex, 0, sizeof(ex));
+     else
+ 	ex = *eap;
+     ex.arg = fname;
+     ex.cmd = (char_u *)(v == 2 ? "pyfile" : "pyfile3");
+ 
+     if (v == 2)
+     {
+ # ifdef FEAT_PYTHON
+ 	ex_pyfile(&ex);
+ # else
+ 	vim_snprintf((char *)IObuff, IOSIZE,
+ 		_("W20: Required python version 2.x not supported, ignoring file: %s"),
+ 		fname);
+ 	MSG(IObuff);
+ # endif
+ 	return;
+     }
+     else
+     {
+ # ifdef FEAT_PYTHON3
+ 	ex_py3file(&ex);
+ # else
+ 	vim_snprintf((char *)IObuff, IOSIZE,
+ 		_("W21: Required python version 3.x not supported, ignoring file: %s"),
+ 		fname);
+ 	MSG(IObuff);
+ # endif
+ 	return;
+     }
+ }
+ 
+ /*
+  * ":pyxfile {fname}"
+  */
+     void
+ ex_pyxfile(exarg_T *eap)
+ {
+     source_pyx_file(eap, eap->arg);
+ }
+ 
+ /*
+  * ":pyx"
+  */
+     void
+ ex_pyx(exarg_T *eap)
+ {
+ # if defined(FEAT_PYTHON) && defined(FEAT_PYTHON3)
+     init_pyxversion();
+     if (p_pyx == 2)
+ 	ex_python(eap);
+     else
+ 	ex_py3(eap);
+ # elif defined(FEAT_PYTHON)
+     ex_python(eap);
+ # elif defined(FEAT_PYTHON3)
+     ex_py3(eap);
+ # endif
+ }
+ 
+ /*
+  * ":pyxdo"
+  */
+     void
+ ex_pyxdo(exarg_T *eap)
+ {
+ # if defined(FEAT_PYTHON) && defined(FEAT_PYTHON3)
+     init_pyxversion();
+     if (p_pyx == 2)
+ 	ex_pydo(eap);
+     else
+ 	ex_py3do(eap);
+ # elif defined(FEAT_PYTHON)
+     ex_pydo(eap);
+ # elif defined(FEAT_PYTHON3)
+     ex_py3do(eap);
+ # endif
+ }
+ 
+ #endif
+ 
  /*
   * ":source {fname}"
   */
*** ../vim-8.0.0250/src/ex_docmd.c	2017-01-22 16:46:52.249278458 +0100
--- src/ex_docmd.c	2017-01-28 15:08:23.515487887 +0100
***************
*** 288,293 ****
--- 288,298 ----
  # define ex_py3do		ex_ni
  # define ex_py3file		ex_ni
  #endif
+ #if !defined(FEAT_PYTHON) && !defined(FEAT_PYTHON3)
+ # define ex_pyx			ex_script_ni
+ # define ex_pyxdo		ex_ni
+ # define ex_pyxfile		ex_ni
+ #endif
  #ifndef FEAT_TCL
  # define ex_tcl			ex_script_ni
  # define ex_tcldo		ex_ni
*** ../vim-8.0.0250/src/if_python.c	2016-04-21 19:52:10.000000000 +0200
--- src/if_python.c	2017-01-28 15:08:23.515487887 +0100
***************
*** 1114,1119 ****
--- 1114,1122 ----
  {
      char_u *script;
  
+     if (p_pyx == 0)
+ 	p_pyx = 2;
+ 
      script = script_get(eap, eap->arg);
      if (!eap->skip)
      {
***************
*** 1137,1142 ****
--- 1140,1148 ----
      const char *file = (char *)eap->arg;
      char *p;
  
+     if (p_pyx == 0)
+ 	p_pyx = 2;
+ 
      /* Have to do it like this. PyRun_SimpleFile requires you to pass a
       * stdio file pointer, but Vim and the Python DLL are compiled with
       * different options under Windows, meaning that stdio pointers aren't
***************
*** 1175,1180 ****
--- 1181,1189 ----
      void
  ex_pydo(exarg_T *eap)
  {
+     if (p_pyx == 0)
+ 	p_pyx = 2;
+ 
      DoPyCommand((char *)eap->arg,
  	    (rangeinitializer) init_range_cmd,
  	    (runner)run_do,
*** ../vim-8.0.0250/src/if_python3.c	2016-08-29 22:42:20.000000000 +0200
--- src/if_python3.c	2017-01-28 15:08:23.515487887 +0100
***************
*** 1004,1009 ****
--- 1004,1012 ----
  {
      char_u *script;
  
+     if (p_pyx == 0)
+ 	p_pyx = 3;
+ 
      script = script_get(eap, eap->arg);
      if (!eap->skip)
      {
***************
*** 1028,1033 ****
--- 1031,1039 ----
      char *p;
      int i;
  
+     if (p_pyx == 0)
+ 	p_pyx = 3;
+ 
      /* Have to do it like this. PyRun_SimpleFile requires you to pass a
       * stdio file pointer, but Vim and the Python DLL are compiled with
       * different options under Windows, meaning that stdio pointers aren't
***************
*** 1080,1085 ****
--- 1086,1094 ----
      void
  ex_py3do(exarg_T *eap)
  {
+     if (p_pyx == 0)
+ 	p_pyx = 3;
+ 
      DoPyCommand((char *)eap->arg,
  	    (rangeinitializer)init_range_cmd,
  	    (runner)run_do,
*** ../vim-8.0.0250/src/option.c	2017-01-27 20:03:13.466483257 +0100
--- src/option.c	2017-01-28 15:08:23.515487887 +0100
***************
*** 479,484 ****
--- 479,495 ----
  # define HIGHLIGHT_INIT "8:SpecialKey,@:NonText,d:Directory,e:ErrorMsg,i:IncSearch,l:Search,m:MoreMsg,M:ModeMsg,n:LineNr,N:CursorLineNr,r:Question,s:StatusLine,S:StatusLineNC,t:Title,v:Visual,w:WarningMsg,W:WildMenu,>:SignColumn,*:TabLine,#:TabLineSel,_:TabLineFill"
  #endif
  
+ /* Default python version for pyx* commands */
+ #if defined(FEAT_PYTHON) && defined(FEAT_PYTHON3)
+ # define DEFAULT_PYTHON_VER	0
+ #elif defined(FEAT_PYTHON3)
+ # define DEFAULT_PYTHON_VER	3
+ #elif defined(FEAT_PYTHON)
+ # define DEFAULT_PYTHON_VER	2
+ #else
+ # define DEFAULT_PYTHON_VER	0
+ #endif
+ 
  /*
   * options[] is initialized here.
   * The order of the options MUST be alphabetic for ":set all" and findoption().
***************
*** 2143,2148 ****
--- 2154,2167 ----
  			    {(char_u *)DYNAMIC_PYTHON_DLL, (char_u *)0L}
  			    SCRIPTID_INIT},
  #endif
+     {"pyxversion", "pyx",   P_NUM|P_VI_DEF|P_SECURE,
+ #if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)
+ 			    (char_u *)&p_pyx, PV_NONE,
+ #else
+ 			    (char_u *)NULL, PV_NONE,
+ #endif
+ 			    {(char_u *)DEFAULT_PYTHON_VER, (char_u *)0L}
+ 			    SCRIPTID_INIT},
      {"quoteescape", "qe",   P_STRING|P_ALLOCED|P_VI_DEF,
  #ifdef FEAT_TEXTOBJ
  			    (char_u *)&p_qe, PV_QE,
***************
*** 8826,8831 ****
--- 8845,8859 ----
  	mzvim_reset_timer();
  #endif
  
+ #if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)
+     /* 'pyxversion' */
+     else if (pp == &p_pyx)
+     {
+ 	if (p_pyx != 0 && p_pyx != 2 && p_pyx != 3)
+ 	    errmsg = e_invarg;
+     }
+ #endif
+ 
      /* sync undo before 'undolevels' changes */
      else if (pp == &p_ul)
      {
*** ../vim-8.0.0250/src/option.h	2017-01-14 14:28:26.956592328 +0100
--- src/option.h	2017-01-28 15:08:23.515487887 +0100
***************
*** 694,699 ****
--- 694,702 ----
  #if defined(DYNAMIC_PYTHON)
  EXTERN char_u	*p_pydll;	/* 'pythondll' */
  #endif
+ #if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)
+ EXTERN long	p_pyx;		/* 'pyxversion' */
+ #endif
  #ifdef FEAT_RELTIME
  EXTERN long	p_rdt;		/* 'redrawtime' */
  #endif
*** ../vim-8.0.0250/src/proto/ex_cmds2.pro	2016-09-12 13:04:02.000000000 +0200
--- src/proto/ex_cmds2.pro	2017-01-28 15:08:23.515487887 +0100
***************
*** 75,80 ****
--- 75,84 ----
  void ex_packloadall(exarg_T *eap);
  void ex_packadd(exarg_T *eap);
  void ex_options(exarg_T *eap);
+ void init_pyxversion(void);
+ void ex_pyxfile(exarg_T *eap);
+ void ex_pyx(exarg_T *eap);
+ void ex_pyxdo(exarg_T *eap);
  void ex_source(exarg_T *eap);
  linenr_T *source_breakpoint(void *cookie);
  int *source_dbg_tick(void *cookie);
*** ../vim-8.0.0250/src/testdir/Make_all.mak	2017-01-28 13:47:48.518498595 +0100
--- src/testdir/Make_all.mak	2017-01-28 15:08:23.515487887 +0100
***************
*** 176,181 ****
--- 176,183 ----
  	    test_packadd.res \
  	    test_perl.res \
  	    test_profile.res \
+ 	    test_pyx2.res \
+ 	    test_pyx3.res \
  	    test_quickfix.res \
  	    test_retab.res \
  	    test_ruby.res \
*** ../vim-8.0.0250/src/testdir/pyxfile/py2_magic.py	1970-01-01 01:00:00.000000000 +0100
--- src/testdir/pyxfile/py2_magic.py	2017-01-28 15:08:23.515487887 +0100
***************
*** 0 ****
--- 1,4 ----
+ # requires python 2.x
+ 
+ import sys
+ print(sys.version)
*** ../vim-8.0.0250/src/testdir/pyxfile/py2_shebang.py	1970-01-01 01:00:00.000000000 +0100
--- src/testdir/pyxfile/py2_shebang.py	2017-01-28 15:08:23.515487887 +0100
***************
*** 0 ****
--- 1,4 ----
+ #!/usr/bin/python2
+ 
+ import sys
+ print(sys.version)
*** ../vim-8.0.0250/src/testdir/pyxfile/py3_magic.py	1970-01-01 01:00:00.000000000 +0100
--- src/testdir/pyxfile/py3_magic.py	2017-01-28 15:08:23.515487887 +0100
***************
*** 0 ****
--- 1,4 ----
+ # requires python 3.x
+ 
+ import sys
+ print(sys.version)
*** ../vim-8.0.0250/src/testdir/pyxfile/py3_shebang.py	1970-01-01 01:00:00.000000000 +0100
--- src/testdir/pyxfile/py3_shebang.py	2017-01-28 15:08:23.515487887 +0100
***************
*** 0 ****
--- 1,4 ----
+ #!/usr/bin/python3
+ 
+ import sys
+ print(sys.version)
*** ../vim-8.0.0250/src/testdir/pyxfile/pyx.py	1970-01-01 01:00:00.000000000 +0100
--- src/testdir/pyxfile/pyx.py	2017-01-28 15:08:23.515487887 +0100
***************
*** 0 ****
--- 1,2 ----
+ import sys
+ print(sys.version)
*** ../vim-8.0.0250/src/testdir/test_pyx2.vim	2017-01-28 15:55:35.601406625 +0100
--- src/testdir/test_pyx2.vim	2017-01-28 15:36:57.604540636 +0100
***************
*** 0 ****
--- 1,74 ----
+ " Test for pyx* commands and functions with Python 2.
+ 
+ set pyx=2
+ if !has('python')
+   finish
+ endif
+ 
+ let s:py2pattern = '^2\.[0-7]\.\d\+'
+ let s:py3pattern = '^3\.\d\+\.\d\+'
+ 
+ 
+ func Test_has_pythonx()
+   call assert_true(has('pythonx'))
+ endfunc
+ 
+ 
+ func Test_pyx()
+   redir => var
+   pyx << EOF
+ import sys
+ print(sys.version)
+ EOF
+   redir END
+   call assert_match(s:py2pattern, split(var)[0])
+ endfunc
+ 
+ 
+ func Test_pyxdo()
+   pyx import sys
+   enew
+   pyxdo return sys.version.split("\n")[0]
+   call assert_match(s:py2pattern, split(getline('.'))[0])
+ endfunc
+ 
+ 
+ func Test_pyxeval()
+   pyx import sys
+   call assert_match(s:py2pattern, split(pyxeval('sys.version'))[0])
+ endfunc
+ 
+ 
+ func Test_pyxfile()
+   " No special comments nor shebangs
+   redir => var
+   pyxfile pyxfile/pyx.py
+   redir END
+   call assert_match(s:py2pattern, split(var)[0])
+ 
+   " Python 2 special comment
+   redir => var
+   pyxfile pyxfile/py2_magic.py
+   redir END
+   call assert_match(s:py2pattern, split(var)[0])
+ 
+   " Python 2 shebang
+   redir => var
+   pyxfile pyxfile/py2_shebang.py
+   redir END
+   call assert_match(s:py2pattern, split(var)[0])
+ 
+   if has('python3')
+     " Python 3 special comment
+     redir => var
+     pyxfile pyxfile/py3_magic.py
+     redir END
+     call assert_match(s:py3pattern, split(var)[0])
+ 
+     " Python 3 shebang
+     redir => var
+     pyxfile pyxfile/py3_shebang.py
+     redir END
+     call assert_match(s:py3pattern, split(var)[0])
+   endif
+ endfunc
*** ../vim-8.0.0250/src/testdir/test_pyx3.vim	2017-01-28 15:55:35.605406600 +0100
--- src/testdir/test_pyx3.vim	2017-01-28 15:36:41.764641826 +0100
***************
*** 0 ****
--- 1,74 ----
+ " Test for pyx* commands and functions with Python 3.
+ 
+ set pyx=3
+ if !has('python3')
+   finish
+ endif
+ 
+ let s:py2pattern = '^2\.[0-7]\.\d\+'
+ let s:py3pattern = '^3\.\d\+\.\d\+'
+ 
+ 
+ func Test_has_pythonx()
+   call assert_true(has('pythonx'))
+ endfunc
+ 
+ 
+ func Test_pyx()
+   redir => var
+   pyx << EOF
+ import sys
+ print(sys.version)
+ EOF
+   redir END
+   call assert_match(s:py3pattern, split(var)[0])
+ endfunc
+ 
+ 
+ func Test_pyxdo()
+   pyx import sys
+   enew
+   pyxdo return sys.version.split("\n")[0]
+   call assert_match(s:py3pattern, split(getline('.'))[0])
+ endfunc
+ 
+ 
+ func Test_pyxeval()
+   pyx import sys
+   call assert_match(s:py3pattern, split(pyxeval('sys.version'))[0])
+ endfunc
+ 
+ 
+ func Test_pyxfile()
+   " No special comments nor shebangs
+   redir => var
+   pyxfile pyxfile/pyx.py
+   redir END
+   call assert_match(s:py3pattern, split(var)[0])
+ 
+   " Python 3 special comment
+   redir => var
+   pyxfile pyxfile/py3_magic.py
+   redir END
+   call assert_match(s:py3pattern, split(var)[0])
+ 
+   " Python 3 shebang
+   redir => var
+   pyxfile pyxfile/py3_shebang.py
+   redir END
+   call assert_match(s:py3pattern, split(var)[0])
+ 
+   if has('python')
+     " Python 2 special comment
+     redir => var
+     pyxfile pyxfile/py2_magic.py
+     redir END
+     call assert_match(s:py2pattern, split(var)[0])
+ 
+     " Python 2 shebang
+     redir => var
+     pyxfile pyxfile/py2_shebang.py
+     redir END
+     call assert_match(s:py2pattern, split(var)[0])
+   endif
+ endfunc
*** ../vim-8.0.0250/src/userfunc.c	2017-01-12 22:20:49.461383785 +0100
--- src/userfunc.c	2017-01-28 15:08:23.519487862 +0100
***************
*** 2102,2108 ****
  	    arg = skipwhite(skiptowhite(p));
  	    if (arg[0] == '<' && arg[1] =='<'
  		    && ((p[0] == 'p' && p[1] == 'y'
! 				    && (!ASCII_ISALPHA(p[2]) || p[2] == 't'))
  			|| (p[0] == 'p' && p[1] == 'e'
  				    && (!ASCII_ISALPHA(p[2]) || p[2] == 'r'))
  			|| (p[0] == 't' && p[1] == 'c'
--- 2102,2110 ----
  	    arg = skipwhite(skiptowhite(p));
  	    if (arg[0] == '<' && arg[1] =='<'
  		    && ((p[0] == 'p' && p[1] == 'y'
! 				    && (!ASCII_ISALNUM(p[2]) || p[2] == 't'
! 					|| ((p[2] == '3' || p[2] == 'x')
! 						   && !ASCII_ISALPHA(p[3]))))
  			|| (p[0] == 'p' && p[1] == 'e'
  				    && (!ASCII_ISALPHA(p[2]) || p[2] == 'r'))
  			|| (p[0] == 't' && p[1] == 'c'
*** ../vim-8.0.0250/src/version.c	2017-01-28 13:47:48.518498595 +0100
--- src/version.c	2017-01-28 15:11:20.446357480 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     251,
  /**/

-- 
FATHER:    You killed eight wedding guests in all!
LAUNCELOT: Er, Well ... the thing is ... I thought your son was a lady.
FATHER:    I can understand that.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0252
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0252
Problem:    Characters below 256 that are not one byte are not always
            recognized as word characters.
Solution:   Make vim_iswordc() and vim_iswordp() work the same way. Add a test
            for this. (Ozaki Kiichi)
Files:      src/Makefile, src/charset.c, src/kword_test.c, src/mbyte.c,
            src/proto/mbyte.pro


*** ../vim-8.0.0251/src/Makefile	2017-01-28 15:58:45.340197300 +0100
--- src/Makefile	2017-01-28 16:25:02.926150460 +0100
***************
*** 1584,1597 ****
  # Unittest files
  JSON_TEST_SRC = json_test.c
  JSON_TEST_TARGET = json_test$(EXEEXT)
  MEMFILE_TEST_SRC = memfile_test.c
  MEMFILE_TEST_TARGET = memfile_test$(EXEEXT)
  MESSAGE_TEST_SRC = message_test.c
  MESSAGE_TEST_TARGET = message_test$(EXEEXT)
  
! UNITTEST_SRC = $(JSON_TEST_SRC) $(MEMFILE_TEST_SRC) $(MESSAGE_TEST_SRC)
! UNITTEST_TARGETS = $(JSON_TEST_TARGET) $(MEMFILE_TEST_TARGET) $(MESSAGE_TEST_TARGET)
! RUN_UNITTESTS = run_json_test run_memfile_test run_message_test
  
  # All sources, also the ones that are not configured
  ALL_SRC = $(BASIC_SRC) $(ALL_GUI_SRC) $(UNITTEST_SRC) $(EXTRA_SRC)
--- 1584,1599 ----
  # Unittest files
  JSON_TEST_SRC = json_test.c
  JSON_TEST_TARGET = json_test$(EXEEXT)
+ KWORD_TEST_SRC = kword_test.c
+ KWORD_TEST_TARGET = kword_test$(EXEEXT)
  MEMFILE_TEST_SRC = memfile_test.c
  MEMFILE_TEST_TARGET = memfile_test$(EXEEXT)
  MESSAGE_TEST_SRC = message_test.c
  MESSAGE_TEST_TARGET = message_test$(EXEEXT)
  
! UNITTEST_SRC = $(JSON_TEST_SRC) $(KWORD_TEST_SRC) $(MEMFILE_TEST_SRC) $(MESSAGE_TEST_SRC)
! UNITTEST_TARGETS = $(JSON_TEST_TARGET) $(KWORD_TEST_TARGET) $(MEMFILE_TEST_TARGET) $(MESSAGE_TEST_TARGET)
! RUN_UNITTESTS = run_json_test run_kword_test run_memfile_test run_message_test
  
  # All sources, also the ones that are not configured
  ALL_SRC = $(BASIC_SRC) $(ALL_GUI_SRC) $(UNITTEST_SRC) $(EXTRA_SRC)
***************
*** 1611,1617 ****
  	objects/arabic.o \
  	objects/buffer.o \
  	objects/blowfish.o \
- 	objects/charset.o \
  	objects/crypt.o \
  	objects/crypt_zip.o \
  	objects/dict.o \
--- 1613,1618 ----
***************
*** 1679,1684 ****
--- 1680,1686 ----
  
  # The files included by tests are not in OBJ_COMMON.
  OBJ_MAIN = \
+ 	objects/charset.o \
  	objects/json.o \
  	objects/main.o \
  	objects/memfile.o \
***************
*** 1687,1699 ****
--- 1689,1711 ----
  OBJ = $(OBJ_COMMON) $(OBJ_MAIN)
  
  OBJ_JSON_TEST = \
+ 	objects/charset.o \
  	objects/memfile.o \
  	objects/message.o \
  	objects/json_test.o
  
  JSON_TEST_OBJ = $(OBJ_COMMON) $(OBJ_JSON_TEST)
  
+ OBJ_KWORD_TEST = \
+ 	objects/json.o \
+ 	objects/memfile.o \
+ 	objects/message.o \
+ 	objects/kword_test.o
+ 
+ KWORD_TEST_OBJ = $(OBJ_COMMON) $(OBJ_KWORD_TEST)
+ 
  OBJ_MEMFILE_TEST = \
+ 	objects/charset.o \
  	objects/json.o \
  	objects/message.o \
  	objects/memfile_test.o
***************
*** 1701,1706 ****
--- 1713,1719 ----
  MEMFILE_TEST_OBJ = $(OBJ_COMMON) $(OBJ_MEMFILE_TEST)
  
  OBJ_MESSAGE_TEST = \
+ 	objects/charset.o \
  	objects/json.o \
  	objects/memfile.o \
  	objects/message_test.o
***************
*** 1710,1715 ****
--- 1723,1729 ----
  ALL_OBJ = $(OBJ_COMMON) \
  	  $(OBJ_MAIN) \
  	  $(OBJ_JSON_TEST) \
+ 	  $(OBJ_KWORD_TEST) \
  	  $(OBJ_MEMFILE_TEST) \
  	  $(OBJ_MESSAGE_TEST)
  
***************
*** 2036,2041 ****
--- 2050,2058 ----
  run_json_test: $(JSON_TEST_TARGET)
  	$(VALGRIND) ./$(JSON_TEST_TARGET) || exit 1; echo $* passed;
  
+ run_kword_test: $(KWORD_TEST_TARGET)
+ 	$(VALGRIND) ./$(KWORD_TEST_TARGET) || exit 1; echo $* passed;
+ 
  run_memfile_test: $(MEMFILE_TEST_TARGET)
  	$(VALGRIND) ./$(MEMFILE_TEST_TARGET) || exit 1; echo $* passed;
  
***************
*** 2222,2227 ****
--- 2239,2251 ----
  		MAKE="$(MAKE)" LINK_AS_NEEDED=$(LINK_AS_NEEDED) \
  		sh $(srcdir)/link.sh
  
+ $(KWORD_TEST_TARGET): auto/config.mk objects $(KWORD_TEST_OBJ)
+ 	$(CCC) version.c -o objects/version.o
+ 	@LINK="$(PURIFY) $(SHRPENV) $(CClink) $(ALL_LIB_DIRS) $(LDFLAGS) \
+ 		-o $(KWORD_TEST_TARGET) $(KWORD_TEST_OBJ) $(ALL_LIBS)" \
+ 		MAKE="$(MAKE)" LINK_AS_NEEDED=$(LINK_AS_NEEDED) \
+ 		sh $(srcdir)/link.sh
+ 
  $(MEMFILE_TEST_TARGET): auto/config.mk objects $(MEMFILE_TEST_OBJ)
  	$(CCC) version.c -o objects/version.o
  	@LINK="$(PURIFY) $(SHRPENV) $(CClink) $(ALL_LIB_DIRS) $(LDFLAGS) \
***************
*** 3058,3063 ****
--- 3082,3090 ----
  objects/json_test.o: json_test.c
  	$(CCC) -o $@ json_test.c
  
+ objects/kword_test.o: kword_test.c
+ 	$(CCC) -o $@ kword_test.c
+ 
  objects/list.o: list.c
  	$(CCC) -o $@ list.c
  
***************
*** 3597,3602 ****
--- 3624,3633 ----
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \
   regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \
   proto.h globals.h farsi.h arabic.h json.c
+ objects/kword_test.o: kword_test.c main.c vim.h auto/config.h feature.h os_unix.h \
+  auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \
+  regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \
+  proto.h globals.h farsi.h arabic.h charset.c mbyte.c
  objects/memfile_test.o: memfile_test.c main.c vim.h auto/config.h feature.h \
   os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h \
   structs.h regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h \
*** ../vim-8.0.0251/src/charset.c	2017-01-28 13:47:48.514498621 +0100
--- src/charset.c	2017-01-28 16:25:02.926150460 +0100
***************
*** 899,914 ****
      int
  vim_iswordc_buf(int c, buf_T *buf)
  {
- #ifdef FEAT_MBYTE
      if (c >= 0x100)
      {
  	if (enc_dbcs != 0)
  	    return dbcs_class((unsigned)c >> 8, (unsigned)(c & 0xff)) >= 2;
  	if (enc_utf8)
! 	    return utf_class(c) >= 2;
!     }
  #endif
!     return (c > 0 && c < 0x100 && GET_CHARTAB(buf, c) != 0);
  }
  
  /*
--- 899,915 ----
      int
  vim_iswordc_buf(int c, buf_T *buf)
  {
      if (c >= 0x100)
      {
+ #ifdef FEAT_MBYTE
  	if (enc_dbcs != 0)
  	    return dbcs_class((unsigned)c >> 8, (unsigned)(c & 0xff)) >= 2;
  	if (enc_utf8)
! 	    return utf_class_buf(c, buf) >= 2;
  #endif
! 	return FALSE;
!     }
!     return (c > 0 && GET_CHARTAB(buf, c) != 0);
  }
  
  /*
***************
*** 917,937 ****
      int
  vim_iswordp(char_u *p)
  {
! #ifdef FEAT_MBYTE
!     if (has_mbyte && MB_BYTE2LEN(*p) > 1)
! 	return mb_get_class(p) >= 2;
! #endif
!     return GET_CHARTAB(curbuf, *p) != 0;
  }
  
      int
  vim_iswordp_buf(char_u *p, buf_T *buf)
  {
  #ifdef FEAT_MBYTE
!     if (has_mbyte && MB_BYTE2LEN(*p) > 1)
! 	return mb_get_class(p) >= 2;
  #endif
!     return (GET_CHARTAB(buf, *p) != 0);
  }
  
  /*
--- 918,936 ----
      int
  vim_iswordp(char_u *p)
  {
!     return vim_iswordp_buf(p, curbuf);
  }
  
      int
  vim_iswordp_buf(char_u *p, buf_T *buf)
  {
+     int	c = *p;
+ 
  #ifdef FEAT_MBYTE
!     if (has_mbyte && MB_BYTE2LEN(c) > 1)
! 	c = (*mb_ptr2char)(p);
  #endif
!     return vim_iswordc_buf(c, buf);
  }
  
  /*
*** ../vim-8.0.0251/src/kword_test.c	2017-01-28 16:38:29.225031457 +0100
--- src/kword_test.c	2017-01-28 16:33:18.011007224 +0100
***************
*** 0 ****
--- 1,85 ----
+ /* vi:set ts=8 sts=4 sw=4 noet:
+  *
+  * VIM - Vi IMproved	by Bram Moolenaar
+  *
+  * Do ":help uganda"  in Vim to read copying and usage conditions.
+  * Do ":help credits" in Vim to see a list of people who contributed.
+  * See README.txt for an overview of the Vim source code.
+  */
+ 
+ /*
+  * kword_test.c: Unittests for vim_iswordc() and vim_iswordp().
+  */
+ 
+ #undef NDEBUG
+ #include <assert.h>
+ 
+ /* Must include main.c because it contains much more than just main() */
+ #define NO_VIM_MAIN
+ #include "main.c"
+ 
+ /* This file has to be included because the tested functions are static */
+ #include "charset.c"
+ 
+ #ifdef FEAT_MBYTE
+ /*
+  * Test the results of vim_iswordc() and vim_iswordp() are matched.
+  */
+     static void
+ test_isword_funcs_utf8(void)
+ {
+     buf_T buf;
+     int c;
+ 
+     vim_memset(&buf, 0, sizeof(buf));
+     p_enc = (char_u *)"utf-8";
+     p_isi = (char_u *)"";
+     p_isp = (char_u *)"";
+     p_isf = (char_u *)"";
+     buf.b_p_isk = (char_u *)"@,48-57,_,128-167,224-235";
+ 
+     curbuf = &buf;
+     mb_init(); /* calls init_chartab() */
+ 
+     for (c = 0; c < 0x10000; ++c)
+     {
+ 	char_u p[4] = {0};
+ 	int c1;
+ 	int retc;
+ 	int retp;
+ 
+ 	utf_char2bytes(c, p);
+ 	c1 = utf_ptr2char(p);
+ 	if (c != c1)
+ 	{
+ 	    fprintf(stderr, "Failed: ");
+ 	    fprintf(stderr,
+ 		    "[c = %#04x, p = {%#02x, %#02x, %#02x}] ",
+ 		    c, p[0], p[1], p[2]);
+ 	    fprintf(stderr, "c != utf_ptr2char(p) (=%#04x)\n", c1);
+ 	    abort();
+ 	}
+ 	retc = vim_iswordc_buf(c, &buf);
+ 	retp = vim_iswordp_buf(p, &buf);
+ 	if (retc != retp)
+ 	{
+ 	    fprintf(stderr, "Failed: ");
+ 	    fprintf(stderr,
+ 		    "[c = %#04x, p = {%#02x, %#02x, %#02x}] ",
+ 		    c, p[0], p[1], p[2]);
+ 	    fprintf(stderr, "vim_iswordc(c) (=%d) != vim_iswordp(p) (=%d)\n",
+ 		    retc, retp);
+ 	    abort();
+ 	}
+     }
+ }
+ #endif
+ 
+     int
+ main(void)
+ {
+ #ifdef FEAT_MBYTE
+     test_isword_funcs_utf8();
+ #endif
+     return 0;
+ }
*** ../vim-8.0.0251/src/mbyte.c	2017-01-12 21:44:45.138171868 +0100
--- src/mbyte.c	2017-01-28 16:25:02.930150435 +0100
***************
*** 895,901 ****
      if (enc_dbcs != 0 && p[0] != NUL && p[1] != NUL)
  	return dbcs_class(p[0], p[1]);
      if (enc_utf8)
! 	return utf_class(utf_ptr2char(p));
      return 0;
  }
  
--- 895,901 ----
      if (enc_dbcs != 0 && p[0] != NUL && p[1] != NUL)
  	return dbcs_class(p[0], p[1]);
      if (enc_utf8)
! 	return utf_class_buf(utf_ptr2char(p), buf);
      return 0;
  }
  
***************
*** 2694,2699 ****
--- 2694,2705 ----
      int
  utf_class(int c)
  {
+     return utf_class_buf(c, curbuf);
+ }
+ 
+     int
+ utf_class_buf(int c, buf_T *buf)
+ {
      /* sorted list of non-overlapping intervals */
      static struct clinterval
      {
***************
*** 2780,2786 ****
      {
  	if (c == ' ' || c == '\t' || c == NUL || c == 0xa0)
  	    return 0;	    /* blank */
! 	if (vim_iswordc(c))
  	    return 2;	    /* word character */
  	return 1;	    /* punctuation */
      }
--- 2786,2792 ----
      {
  	if (c == ' ' || c == '\t' || c == NUL || c == 0xa0)
  	    return 0;	    /* blank */
! 	if (vim_iswordc_buf(c, buf))
  	    return 2;	    /* word character */
  	return 1;	    /* punctuation */
      }
*** ../vim-8.0.0251/src/proto/mbyte.pro	2016-09-12 13:04:11.000000000 +0200
--- src/proto/mbyte.pro	2017-01-28 16:25:02.930150435 +0100
***************
*** 40,45 ****
--- 40,46 ----
  int utf_iscomposing(int c);
  int utf_printable(int c);
  int utf_class(int c);
+ int utf_class_buf(int c, buf_T *buf);
  int utf_ambiguous_width(int c);
  int utf_fold(int a);
  int utf_toupper(int a);
*** ../vim-8.0.0251/src/version.c	2017-01-28 15:58:45.352197224 +0100
--- src/version.c	2017-01-28 16:37:46.057305507 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     252,
  /**/

-- 
The early bird gets the worm. The second mouse gets the cheese.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0253
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0253
Problem:    When creating a session when winminheight is 2 or larger and
            loading that session gives an error.
Solution:   Also set winminheight before setting winheight to 1. (Rafael
            Bodill, neovim #5717)
Files:      src/ex_docmd.c, src/testdir/test_mksession.vim


*** ../vim-8.0.0252/src/ex_docmd.c	2017-01-28 15:58:45.348197250 +0100
--- src/ex_docmd.c	2017-01-28 17:06:39.426330240 +0100
***************
*** 11197,11204 ****
  	 * resized when moving between windows.
  	 * Do this before restoring the view, so that the topline and the
  	 * cursor can be set.  This is done again below.
  	 */
! 	if (put_line(fd, "set winheight=1 winwidth=1") == FAIL)
  	    return FAIL;
  	if (nr > 1 && ses_winsizes(fd, restore_size, tab_firstwin) == FAIL)
  	    return FAIL;
--- 11197,11206 ----
  	 * resized when moving between windows.
  	 * Do this before restoring the view, so that the topline and the
  	 * cursor can be set.  This is done again below.
+ 	 * winminheight and winminwidth need to be set to avoid an error if the
+ 	 * user has set winheight or winwidth.
  	 */
! 	if (put_line(fd, "set winminheight=1 winheight=1 winminwidth=1 winwidth=1") == FAIL)
  	    return FAIL;
  	if (nr > 1 && ses_winsizes(fd, restore_size, tab_firstwin) == FAIL)
  	    return FAIL;
***************
*** 11268,11273 ****
--- 11270,11279 ----
      if (fprintf(fd, "set winheight=%ld winwidth=%ld shortmess=%s",
  			       p_wh, p_wiw, p_shm) < 0 || put_eol(fd) == FAIL)
  	return FAIL;
+     /* Re-apply 'winminheight' and 'winminwidth'. */
+     if (fprintf(fd, "set winminheight=%ld winminwidth=%ld",
+ 				      p_wmh, p_wmw) < 0 || put_eol(fd) == FAIL)
+ 	return FAIL;
  
      /*
       * Lastly, execute the x.vim file if it exists.
*** ../vim-8.0.0252/src/testdir/test_mksession.vim	2016-12-01 18:47:06.595684409 +0100
--- src/testdir/test_mksession.vim	2017-01-28 17:02:24.403943278 +0100
***************
*** 101,104 ****
--- 101,113 ----
    let &wrap = wrap_save
  endfunc
  
+ func Test_mksession_winheight()
+   new
+   set winheight=10 winminheight=2
+   mksession! test_mks.out
+   source test_mks.out
+ 
+   " call delete('test_mks.out')
+ endfunc
+ 
  " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.0.0252/src/version.c	2017-01-28 16:39:15.876735290 +0100
--- src/version.c	2017-01-28 17:02:47.651796246 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     253,
  /**/

-- 
Advice to worms:  Sleep late.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0254
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0254
Problem:    When using an assert function one can either specify a message or
            get a message about what failed, not both.
Solution:   Concatenate the error with the message.
Files:      src/eval.c, src/testdir/test_assert.vim


*** ../vim-8.0.0253/src/eval.c	2017-01-22 18:34:53.680030808 +0100
--- src/eval.c	2017-01-28 18:07:02.491425259 +0100
***************
*** 9240,9274 ****
  
      if (opt_msg_tv->v_type != VAR_UNKNOWN)
      {
! 	ga_concat(gap, tv2string(opt_msg_tv, &tofree, numbuf, 0));
  	vim_free(tofree);
      }
      else
      {
! 	if (atype == ASSERT_MATCH || atype == ASSERT_NOTMATCH)
! 	    ga_concat(gap, (char_u *)"Pattern ");
! 	else if (atype == ASSERT_NOTEQUAL)
! 	    ga_concat(gap, (char_u *)"Expected not equal to ");
! 	else
! 	    ga_concat(gap, (char_u *)"Expected ");
! 	if (exp_str == NULL)
! 	{
! 	    ga_concat_esc(gap, tv2string(exp_tv, &tofree, numbuf, 0));
! 	    vim_free(tofree);
! 	}
  	else
! 	    ga_concat_esc(gap, exp_str);
! 	if (atype != ASSERT_NOTEQUAL)
! 	{
! 	    if (atype == ASSERT_MATCH)
! 		ga_concat(gap, (char_u *)" does not match ");
! 	    else if (atype == ASSERT_NOTMATCH)
! 		ga_concat(gap, (char_u *)" does match ");
! 	    else
! 		ga_concat(gap, (char_u *)" but got ");
! 	    ga_concat_esc(gap, tv2string(got_tv, &tofree, numbuf, 0));
! 	    vim_free(tofree);
! 	}
      }
  }
  
--- 9240,9273 ----
  
      if (opt_msg_tv->v_type != VAR_UNKNOWN)
      {
! 	ga_concat(gap, echo_string(opt_msg_tv, &tofree, numbuf, 0));
  	vim_free(tofree);
+ 	ga_concat(gap, (char_u *)": ");
      }
+ 
+     if (atype == ASSERT_MATCH || atype == ASSERT_NOTMATCH)
+ 	ga_concat(gap, (char_u *)"Pattern ");
+     else if (atype == ASSERT_NOTEQUAL)
+ 	ga_concat(gap, (char_u *)"Expected not equal to ");
      else
+ 	ga_concat(gap, (char_u *)"Expected ");
+     if (exp_str == NULL)
      {
! 	ga_concat_esc(gap, tv2string(exp_tv, &tofree, numbuf, 0));
! 	vim_free(tofree);
!     }
!     else
! 	ga_concat_esc(gap, exp_str);
!     if (atype != ASSERT_NOTEQUAL)
!     {
! 	if (atype == ASSERT_MATCH)
! 	    ga_concat(gap, (char_u *)" does not match ");
! 	else if (atype == ASSERT_NOTMATCH)
! 	    ga_concat(gap, (char_u *)" does match ");
  	else
! 	    ga_concat(gap, (char_u *)" but got ");
! 	ga_concat_esc(gap, tv2string(got_tv, &tofree, numbuf, 0));
! 	vim_free(tofree);
      }
  }
  
*** ../vim-8.0.0253/src/testdir/test_assert.vim	2017-01-14 20:06:11.123087733 +0100
--- src/testdir/test_assert.vim	2017-01-28 18:05:40.799941919 +0100
***************
*** 121,126 ****
--- 121,132 ----
    call assert_fails('call assert_inrange(1, 1)', 'E119:')
  endfunc
  
+ func Test_assert_with_msg()
+   call assert_equal('foo', 'bar', 'testing')
+   call assert_match("testing: Expected 'foo' but got 'bar'", v:errors[0])
+   call remove(v:errors, 0)
+ endfunc
+ 
  func Test_user_is_happy()
    smile
    sleep 300m
*** ../vim-8.0.0253/src/version.c	2017-01-28 17:11:09.724620245 +0100
--- src/version.c	2017-01-28 17:20:32.673057834 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     254,
  /**/

-- 
FATHER:    You only killed the bride's father - that's all -
LAUNCELOT: Oh dear, I didn't really mean to...
FATHER:    Didn't mean to?  You put your sword right through his head!
LAUNCELOT: Gosh - Is he all right?
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0255
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0255
Problem:    When calling setpos() with a buffer argument it often is ignored.
            (Matthew Malcomson)
Solution:   Make the buffer argument work for all marks local to a buffer.
            (neovim #5713)  Add more tests.
Files:      src/mark.c, src/testdir/test_marks.vim, runtime/doc/eval.txt


*** ../vim-8.0.0254/src/mark.c	2016-10-15 20:46:13.580656069 +0200
--- src/mark.c	2017-01-28 18:14:39.884526505 +0100
***************
*** 57,62 ****
--- 57,63 ----
  setmark_pos(int c, pos_T *pos, int fnum)
  {
      int		i;
+     buf_T	*buf;
  
      /* Check for a special key (may cause islower() to crash). */
      if (c < 0)
***************
*** 75,83 ****
  	return OK;
      }
  
      if (c == '"')
      {
! 	curbuf->b_last_cursor = *pos;
  	return OK;
      }
  
--- 76,88 ----
  	return OK;
      }
  
+     buf = buflist_findnr(fnum);
+     if (buf == NULL)
+ 	return FAIL;
+ 
      if (c == '"')
      {
! 	buf->b_last_cursor = *pos;
  	return OK;
      }
  
***************
*** 85,115 ****
       * file. */
      if (c == '[')
      {
! 	curbuf->b_op_start = *pos;
  	return OK;
      }
      if (c == ']')
      {
! 	curbuf->b_op_end = *pos;
  	return OK;
      }
  
      if (c == '<' || c == '>')
      {
  	if (c == '<')
! 	    curbuf->b_visual.vi_start = *pos;
  	else
! 	    curbuf->b_visual.vi_end = *pos;
! 	if (curbuf->b_visual.vi_mode == NUL)
  	    /* Visual_mode has not yet been set, use a sane default. */
! 	    curbuf->b_visual.vi_mode = 'v';
  	return OK;
      }
  
      if (ASCII_ISLOWER(c))
      {
  	i = c - 'a';
! 	curbuf->b_namedm[i] = *pos;
  	return OK;
      }
      if (ASCII_ISUPPER(c) || VIM_ISDIGIT(c))
--- 90,120 ----
       * file. */
      if (c == '[')
      {
! 	buf->b_op_start = *pos;
  	return OK;
      }
      if (c == ']')
      {
! 	buf->b_op_end = *pos;
  	return OK;
      }
  
      if (c == '<' || c == '>')
      {
  	if (c == '<')
! 	    buf->b_visual.vi_start = *pos;
  	else
! 	    buf->b_visual.vi_end = *pos;
! 	if (buf->b_visual.vi_mode == NUL)
  	    /* Visual_mode has not yet been set, use a sane default. */
! 	    buf->b_visual.vi_mode = 'v';
  	return OK;
      }
  
      if (ASCII_ISLOWER(c))
      {
  	i = c - 'a';
! 	buf->b_namedm[i] = *pos;
  	return OK;
      }
      if (ASCII_ISUPPER(c) || VIM_ISDIGIT(c))
***************
*** 396,402 ****
      {
  	startp = &buf->b_visual.vi_start;
  	endp = &buf->b_visual.vi_end;
! 	if ((c == '<') == lt(*startp, *endp))
  	    posp = startp;
  	else
  	    posp = endp;
--- 401,408 ----
      {
  	startp = &buf->b_visual.vi_start;
  	endp = &buf->b_visual.vi_end;
! 	if (((c == '<') == lt(*startp, *endp) || endp->lnum == 0)
! 							  && startp->lnum != 0)
  	    posp = startp;
  	else
  	    posp = endp;
*** ../vim-8.0.0254/src/testdir/test_marks.vim	2016-09-01 22:07:07.000000000 +0200
--- src/testdir/test_marks.vim	2017-01-28 17:56:37.099380247 +0100
***************
*** 24,26 ****
--- 24,70 ----
    call assert_equal("XXX 123 123", getline(3))
    enew!
  endfunction
+ 
+ func Test_setpos()
+   new one
+   let onebuf = bufnr('%')
+   let onewin = win_getid()
+   call setline(1, ['aaa', 'bbb', 'ccc'])
+   new two
+   let twobuf = bufnr('%')
+   let twowin = win_getid()
+   call setline(1, ['aaa', 'bbb', 'ccc'])
+ 
+   " for the cursor the buffer number is ignored
+   call setpos(".", [0, 2, 1, 0])
+   call assert_equal([0, 2, 1, 0], getpos("."))
+   call setpos(".", [onebuf, 3, 3, 0])
+   call assert_equal([0, 3, 3, 0], getpos("."))
+ 
+   call setpos("''", [0, 1, 3, 0])
+   call assert_equal([0, 1, 3, 0], getpos("''"))
+   call setpos("''", [onebuf, 2, 2, 0])
+   call assert_equal([0, 2, 2, 0], getpos("''"))
+ 
+   " buffer-local marks
+   for mark in ["'a", "'\"", "'[", "']", "'<", "'>"]
+     call win_gotoid(twowin)
+     call setpos(mark, [0, 2, 1, 0])
+     call assert_equal([0, 2, 1, 0], getpos(mark), "for mark " . mark)
+     call setpos(mark, [onebuf, 1, 3, 0])
+     call win_gotoid(onewin)
+     call assert_equal([0, 1, 3, 0], getpos(mark), "for mark " . mark)
+   endfor
+ 
+   " global marks
+   call win_gotoid(twowin)
+   call setpos("'N", [0, 2, 1, 0])
+   call assert_equal([twobuf, 2, 1, 0], getpos("'N"))
+   call setpos("'N", [onebuf, 1, 3, 0])
+   call assert_equal([onebuf, 1, 3, 0], getpos("'N"))
+ 
+   call win_gotoid(onewin)
+   bwipe!
+   call win_gotoid(twowin)
+   bwipe!
+ endfunc
*** ../vim-8.0.0254/runtime/doc/eval.txt	2017-01-28 15:58:45.336197327 +0100
--- runtime/doc/eval.txt	2017-01-28 17:52:00.605128498 +0100
***************
*** 6797,6806 ****
  		    [bufnum, lnum, col, off, curswant]
  
  		"bufnum" is the buffer number.  Zero can be used for the
! 		current buffer.  Setting the cursor is only possible for
! 		the current buffer.  To set a mark in another buffer you can
! 		use the |bufnr()| function to turn a file name into a buffer
! 		number.
  		Does not change the jumplist.
  
  		"lnum" and "col" are the position in the buffer.  The first
--- 6806,6817 ----
  		    [bufnum, lnum, col, off, curswant]
  
  		"bufnum" is the buffer number.  Zero can be used for the
! 		current buffer.  When setting an uppercase mark "bufnum" is
! 		used for the mark position.  For other marks it specifies the
! 		buffer to set the mark in.  You can use the |bufnr()| function
! 		to turn a file name into a buffer number.
! 		For setting the cursor and the ' mark "bufnum" is ignored,
! 		since these are associated with a window, not a buffer.
  		Does not change the jumplist.
  
  		"lnum" and "col" are the position in the buffer.  The first
*** ../vim-8.0.0254/src/version.c	2017-01-28 18:08:08.155009961 +0100
--- src/version.c	2017-01-28 18:22:31.973532336 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     255,
  /**/

-- 
LAUNCELOT: I am, sir. I am a Knight of King Arthur.
FATHER:    'Mm ... very nice castle, Camelot ... very good pig country....
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0256
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0256 (after 8.0.0255)
Problem:    Tests fail because some changes were not included.
Solution:   Add changes to evalfunc.c
Files:      src/evalfunc.c


*** ../vim-8.0.0255/src/evalfunc.c	2017-01-28 15:58:45.344197275 +0100
--- src/evalfunc.c	2017-01-28 17:38:36.058205469 +0100
***************
*** 10136,10155 ****
  		pos.col = 0;
  	    if (name[0] == '.' && name[1] == NUL)
  	    {
! 		/* set cursor */
! 		if (fnum == curbuf->b_fnum)
  		{
! 		    curwin->w_cursor = pos;
! 		    if (curswant >= 0)
! 		    {
! 			curwin->w_curswant = curswant - 1;
! 			curwin->w_set_curswant = FALSE;
! 		    }
! 		    check_cursor();
! 		    rettv->vval.v_number = 0;
  		}
! 		else
! 		    EMSG(_(e_invarg));
  	    }
  	    else if (name[0] == '\'' && name[1] != NUL && name[2] == NUL)
  	    {
--- 10136,10150 ----
  		pos.col = 0;
  	    if (name[0] == '.' && name[1] == NUL)
  	    {
! 		/* set cursor; "fnum" is ignored */
! 		curwin->w_cursor = pos;
! 		if (curswant >= 0)
  		{
! 		    curwin->w_curswant = curswant - 1;
! 		    curwin->w_set_curswant = FALSE;
  		}
! 		check_cursor();
! 		rettv->vval.v_number = 0;
  	    }
  	    else if (name[0] == '\'' && name[1] != NUL && name[2] == NUL)
  	    {
*** ../vim-8.0.0255/src/version.c	2017-01-28 18:23:49.725039260 +0100
--- src/version.c	2017-01-28 18:26:35.631987176 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     256,
  /**/

-- 
GUEST:        He's killed the best man!
SECOND GUEST: (holding a limp WOMAN) He's killed my auntie.
FATHER:       No, please!  This is supposed to be a happy occasion!  Let's
              not bicker and argue about who killed who ...
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0257
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0257 (after 8.0.0252)
Problem:    The keyword test file is not included in the archive.
Solution:   Update the list of files.
Files:      Filelist


*** ../vim-8.0.0256/Filelist	2017-01-28 15:58:45.332197352 +0100
--- Filelist	2017-01-28 18:33:34.757329601 +0100
***************
*** 45,50 ****
--- 45,51 ----
  		src/hashtab.c \
  		src/json.c \
  		src/json_test.c \
+ 		src/kword_test.c \
  		src/list.c \
  		src/keymap.h \
  		src/macros.h \
*** ../vim-8.0.0256/src/version.c	2017-01-28 18:31:36.690078200 +0100
--- src/version.c	2017-01-28 18:42:27.385952846 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     257,
  /**/

-- 
FATHER: We are here today to witness the union of two young people in the
        joyful bond of the holy wedlock.  Unfortunately, one of them, my son
        Herbert, has just fallen to his death.
   [Murmurs from CROWD;  the BRIDE smiles with relief, coughs.]
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0258
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0258 (after 8.0.0253)
Problem:    mksession test leaves file behind.
Solution:   Delete the file.  Rename files to start with "X".
Files:      src/testdir/test_mksession.vim


*** ../vim-8.0.0257/src/testdir/test_mksession.vim	2017-01-28 17:11:09.724620245 +0100
--- src/testdir/test_mksession.vim	2017-01-29 14:11:24.618846585 +0100
***************
*** 22,28 ****
      \   'a   two multiByte characters',
      \   'A  three mulTibyte characters'
      \ ])
!   let tmpfile = tempname()
    exec 'w! ' . tmpfile
    /^start:
    set wrap
--- 22,28 ----
      \   'a   two multiByte characters',
      \   'A  three mulTibyte characters'
      \ ])
!   let tmpfile = 'Xtemp'
    exec 'w! ' . tmpfile
    /^start:
    set wrap
***************
*** 63,70 ****
    norm! j016|3zl
    split
    call wincol()
!   mksession! test_mks.out
!   let li = filter(readfile('test_mks.out'), 'v:val =~# "\\(^ *normal! 0\\|^ *exe ''normal!\\)"')
    let expected = [
      \   'normal! 016|',
      \   'normal! 016|',
--- 63,70 ----
    norm! j016|3zl
    split
    call wincol()
!   mksession! Xtest_mks.out
!   let li = filter(readfile('Xtest_mks.out'), 'v:val =~# "\\(^ *normal! 0\\|^ *exe ''normal!\\)"')
    let expected = [
      \   'normal! 016|',
      \   'normal! 016|',
***************
*** 96,102 ****
    call assert_equal(expected, li)
    tabclose!
  
!   call delete('test_mks.out')
    call delete(tmpfile)
    let &wrap = wrap_save
  endfunc
--- 96,102 ----
    call assert_equal(expected, li)
    tabclose!
  
!   call delete('Xtest_mks.out')
    call delete(tmpfile)
    let &wrap = wrap_save
  endfunc
***************
*** 104,113 ****
  func Test_mksession_winheight()
    new
    set winheight=10 winminheight=2
!   mksession! test_mks.out
!   source test_mks.out
  
!   " call delete('test_mks.out')
  endfunc
  
  " vim: shiftwidth=2 sts=2 expandtab
--- 104,113 ----
  func Test_mksession_winheight()
    new
    set winheight=10 winminheight=2
!   mksession! Xtest_mks.out
!   source Xtest_mks.out
  
!   call delete('Xtest_mks.out')
  endfunc
  
  " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.0.0257/src/version.c	2017-01-28 18:42:52.809791676 +0100
--- src/version.c	2017-01-29 14:12:49.598290897 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     258,
  /**/

-- 
   [SIR LAUNCELOT runs back up the stairs, grabs a rope
   of the wall and swings out over the heads of the CROWD in a
   swashbuckling manner towards a large window.  He stops just short
   of the window and is left swing pathetically back and forth.]
LAUNCELOT: Excuse me ... could somebody give me a push ...
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0259
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0259
Problem:    Tab commands do not handle count correctly. (Ken Hamada)
Solution:   Add ADDR_TABS_RELATIVE. (Hirohito Higashi)
Files:      runtime/doc/tabpage.txt, src/ex_cmds.h, src/ex_docmd.c,
            src/testdir/test_tabpage.vim


*** ../vim-8.0.0258/runtime/doc/tabpage.txt	2016-09-12 12:45:48.000000000 +0200
--- runtime/doc/tabpage.txt	2017-01-29 14:26:29.892913581 +0100
***************
*** 58,63 ****
--- 58,65 ----
  In the GUI tab pages line you can use the right mouse button to open menu.
  |tabline-menu|.
  
+ For the related autocommands see |tabnew-autocmd|.
+ 
  :[count]tabe[dit]				*:tabe* *:tabedit* *:tabnew*
  :[count]tabnew
  		Open a new tab page with an empty window, after the current
***************
*** 137,142 ****
--- 139,148 ----
  		    :+tabclose	    " close the next tab page
  		    :1tabclose	    " close the first tab page
  		    :$tabclose	    " close the last tab page
+ 		    :tabclose -2    " close the two previous tab page
+ 		    :tabclose +	    " close the next tab page
+ 		    :tabclose 3	    " close the third tab page
+ 		    :tabclose $	    " close the last tab page
  <
  							*:tabo* *:tabonly*
  :tabo[nly][!]	Close all other tab pages.
***************
*** 151,163 ****
  				    " one
  
  :{count}tabo[nly][!]
! 		Close all tab pages except the {count}th one. >
  		    :.tabonly	    " as above
  		    :-tabonly	    " close all tab pages except the previous
  				    " one
  		    :+tabonly	    " close all tab pages except the next one
  		    :1tabonly	    " close all tab pages except the first one
  		    :$tabonly	    " close all tab pages except the last one
  
  
  SWITCHING TO ANOTHER TAB PAGE:
--- 157,176 ----
  				    " one
  
  :{count}tabo[nly][!]
! :tabo[nly][!] {count}
! 		Close all tab pages except {count} one. >
  		    :.tabonly	    " as above
  		    :-tabonly	    " close all tab pages except the previous
  				    " one
  		    :+tabonly	    " close all tab pages except the next one
  		    :1tabonly	    " close all tab pages except the first one
  		    :$tabonly	    " close all tab pages except the last one
+ 		    :tabonly -	    " close all tab pages except the previous
+ 				    " one
+ 		    :tabonly +2     " close all tab pages except the two next
+ 				    " one
+ 		    :tabonly 1	    " close all tab pages except the first one
+ 		    :tabonly $	    " close all tab pages except the last one
  
  
  SWITCHING TO ANOTHER TAB PAGE:
***************
*** 172,178 ****
--- 185,204 ----
  		Go to the next tab page.  Wraps around from the last to the
  		first one.
  
+ :{count}tabn[ext]
  :tabn[ext] {count}
+ 		Go to tab page {count}.  The first tab page has number one. >
+ 		    :-tabnext	" go to the previous tab page
+ 		    :+tabnext	" go to the next tab page
+ 		    :+2tabnext	" go to the two next tab page
+ 		    :1tabnext	" go to the first tab page
+ 		    :$tabnext	" go to the last tab page
+ 		    :tabnext $	" as above
+ 		    :tabnext -	" go to the previous tab page
+ 		    :tabnext -1	" as above
+ 		    :tabnext +	" go to the next tab page
+ 		    :tabnext +1	" as above
+ 
  {count}<C-PageDown>
  {count}gt	Go to tab page {count}.  The first tab page has number one.
  
***************
*** 287,292 ****
--- 313,319 ----
  
  Currently there is only one option local to a tab page: 'cmdheight'.
  
+ 						*tabnew-autocmd*
  The TabLeave and TabEnter autocommand events can be used to do something when
  switching from one tab page to another.  The exact order depends on what you
  are doing.  When creating a new tab page this works as if you create a new
*** ../vim-8.0.0258/src/ex_cmds.h	2017-01-28 15:58:45.344197275 +0100
--- src/ex_cmds.h	2017-01-29 14:26:29.892913581 +0100
***************
*** 65,71 ****
  #define ADDR_LOADED_BUFFERS	3
  #define ADDR_BUFFERS		4
  #define ADDR_TABS		5
! #define ADDR_QUICKFIX		6
  #define ADDR_OTHER		99
  
  #ifndef DO_DECLARE_EXCMD
--- 65,72 ----
  #define ADDR_LOADED_BUFFERS	3
  #define ADDR_BUFFERS		4
  #define ADDR_TABS		5
! #define ADDR_TABS_RELATIVE	6   /* Tab page that only relative */
! #define ADDR_QUICKFIX		7
  #define ADDR_OTHER		99
  
  #ifndef DO_DECLARE_EXCMD
***************
*** 1425,1433 ****
  			ADDR_LINES),
  EX(CMD_tab,		"tab",		ex_wrongmodifier,
  			NEEDARG|EXTRA|NOTRLCOM,
! 			ADDR_LINES),
  EX(CMD_tabclose,	"tabclose",	ex_tabclose,
! 			RANGE|NOTADR|COUNT|BANG|TRLBAR|CMDWIN,
  			ADDR_TABS),
  EX(CMD_tabdo,		"tabdo",	ex_listdo,
  			NEEDARG|EXTRA|NOTRLCOM|RANGE|NOTADR|DFLALL,
--- 1426,1434 ----
  			ADDR_LINES),
  EX(CMD_tab,		"tab",		ex_wrongmodifier,
  			NEEDARG|EXTRA|NOTRLCOM,
! 			ADDR_TABS),
  EX(CMD_tabclose,	"tabclose",	ex_tabclose,
! 			BANG|RANGE|NOTADR|ZEROR|EXTRA|NOSPC|TRLBAR|CMDWIN,
  			ADDR_TABS),
  EX(CMD_tabdo,		"tabdo",	ex_listdo,
  			NEEDARG|EXTRA|NOTRLCOM|RANGE|NOTADR|DFLALL,
***************
*** 1440,1473 ****
  			ADDR_TABS),
  EX(CMD_tabfirst,	"tabfirst",	ex_tabnext,
  			TRLBAR,
! 			ADDR_LINES),
  EX(CMD_tabmove,		"tabmove",	ex_tabmove,
  			RANGE|NOTADR|ZEROR|EXTRA|NOSPC|TRLBAR,
  			ADDR_TABS),
  EX(CMD_tablast,		"tablast",	ex_tabnext,
  			TRLBAR,
! 			ADDR_LINES),
  EX(CMD_tabnext,		"tabnext",	ex_tabnext,
! 			RANGE|NOTADR|COUNT|TRLBAR,
! 			ADDR_LINES),
  EX(CMD_tabnew,		"tabnew",	ex_splitview,
  			BANG|FILE1|RANGE|NOTADR|ZEROR|EDITCMD|ARGOPT|TRLBAR,
  			ADDR_TABS),
  EX(CMD_tabonly,		"tabonly",	ex_tabonly,
! 			BANG|RANGE|NOTADR|TRLBAR|CMDWIN,
  			ADDR_TABS),
  EX(CMD_tabprevious,	"tabprevious",	ex_tabnext,
! 			RANGE|NOTADR|COUNT|TRLBAR,
! 			ADDR_LINES),
  EX(CMD_tabNext,		"tabNext",	ex_tabnext,
! 			RANGE|NOTADR|COUNT|TRLBAR,
! 			ADDR_LINES),
  EX(CMD_tabrewind,	"tabrewind",	ex_tabnext,
  			TRLBAR,
! 			ADDR_LINES),
  EX(CMD_tabs,		"tabs",		ex_tabs,
  			TRLBAR|CMDWIN,
! 			ADDR_LINES),
  EX(CMD_tcl,		"tcl",		ex_tcl,
  			RANGE|EXTRA|NEEDARG|CMDWIN,
  			ADDR_LINES),
--- 1441,1474 ----
  			ADDR_TABS),
  EX(CMD_tabfirst,	"tabfirst",	ex_tabnext,
  			TRLBAR,
! 			ADDR_TABS),
  EX(CMD_tabmove,		"tabmove",	ex_tabmove,
  			RANGE|NOTADR|ZEROR|EXTRA|NOSPC|TRLBAR,
  			ADDR_TABS),
  EX(CMD_tablast,		"tablast",	ex_tabnext,
  			TRLBAR,
! 			ADDR_TABS),
  EX(CMD_tabnext,		"tabnext",	ex_tabnext,
! 			RANGE|NOTADR|ZEROR|EXTRA|NOSPC|TRLBAR,
! 			ADDR_TABS),
  EX(CMD_tabnew,		"tabnew",	ex_splitview,
  			BANG|FILE1|RANGE|NOTADR|ZEROR|EDITCMD|ARGOPT|TRLBAR,
  			ADDR_TABS),
  EX(CMD_tabonly,		"tabonly",	ex_tabonly,
! 			BANG|RANGE|NOTADR|ZEROR|EXTRA|NOSPC|TRLBAR|CMDWIN,
  			ADDR_TABS),
  EX(CMD_tabprevious,	"tabprevious",	ex_tabnext,
! 			RANGE|NOTADR|ZEROR|EXTRA|NOSPC|TRLBAR,
! 			ADDR_TABS_RELATIVE),
  EX(CMD_tabNext,		"tabNext",	ex_tabnext,
! 			RANGE|NOTADR|ZEROR|EXTRA|NOSPC|TRLBAR,
! 			ADDR_TABS_RELATIVE),
  EX(CMD_tabrewind,	"tabrewind",	ex_tabnext,
  			TRLBAR,
! 			ADDR_TABS),
  EX(CMD_tabs,		"tabs",		ex_tabs,
  			TRLBAR|CMDWIN,
! 			ADDR_TABS),
  EX(CMD_tcl,		"tcl",		ex_tcl,
  			RANGE|EXTRA|NEEDARG|CMDWIN,
  			ADDR_LINES),
*** ../vim-8.0.0258/src/ex_docmd.c	2017-01-28 17:11:09.724620245 +0100
--- src/ex_docmd.c	2017-01-29 14:44:57.129686401 +0100
***************
*** 2162,2169 ****
  		ea.line2 = curwin->w_cursor.lnum;
  		break;
  	    case ADDR_WINDOWS:
! 		lnum = CURRENT_WIN_NR;
! 		ea.line2 = lnum;
  		break;
  	    case ADDR_ARGUMENTS:
  		ea.line2 = curwin->w_arg_idx + 1;
--- 2162,2168 ----
  		ea.line2 = curwin->w_cursor.lnum;
  		break;
  	    case ADDR_WINDOWS:
! 		ea.line2 = CURRENT_WIN_NR;
  		break;
  	    case ADDR_ARGUMENTS:
  		ea.line2 = curwin->w_arg_idx + 1;
***************
*** 2175,2182 ****
  		ea.line2 = curbuf->b_fnum;
  		break;
  	    case ADDR_TABS:
! 		lnum = CURRENT_TAB_NR;
! 		ea.line2 = lnum;
  		break;
  #ifdef FEAT_QUICKFIX
  	    case ADDR_QUICKFIX:
--- 2174,2183 ----
  		ea.line2 = curbuf->b_fnum;
  		break;
  	    case ADDR_TABS:
! 		ea.line2 = CURRENT_TAB_NR;
! 		break;
! 	    case ADDR_TABS_RELATIVE:
! 		ea.line2 = 1;
  		break;
  #ifdef FEAT_QUICKFIX
  	    case ADDR_QUICKFIX:
***************
*** 2235,2240 ****
--- 2236,2245 ----
  			    goto doend;
  			}
  			break;
+ 		    case ADDR_TABS_RELATIVE:
+ 			errormsg = (char_u *)_(e_invrange);
+ 			goto doend;
+ 			break;
  		    case ADDR_ARGUMENTS:
  			if (ARGCOUNT == 0)
  			    ea.line1 = ea.line2 = 0;
***************
*** 2710,2715 ****
--- 2715,2723 ----
  	    case ADDR_TABS:
  		ea.line2 = LAST_TAB_NR;
  		break;
+ 	    case ADDR_TABS_RELATIVE:
+ 		ea.line2 = 1;
+ 		break;
  	    case ADDR_ARGUMENTS:
  		if (ARGCOUNT == 0)
  		    ea.line1 = ea.line2 = 0;
***************
*** 2786,2792 ****
  	    /*
  	     * Be vi compatible: no error message for out of range.
  	     */
! 	    if (ea.line2 > curbuf->b_ml.ml_line_count)
  		ea.line2 = curbuf->b_ml.ml_line_count;
  	}
      }
--- 2794,2801 ----
  	    /*
  	     * Be vi compatible: no error message for out of range.
  	     */
! 	    if (ea.addr_type == ADDR_LINES
! 		    && ea.line2 > curbuf->b_ml.ml_line_count)
  		ea.line2 = curbuf->b_ml.ml_line_count;
  	}
      }
***************
*** 4427,4432 ****
--- 4436,4446 ----
  		    case ADDR_TABS:
  			lnum = CURRENT_TAB_NR;
  			break;
+ 		    case ADDR_TABS_RELATIVE:
+ 			EMSG(_(e_invrange));
+ 			cmd = NULL;
+ 			goto error;
+ 			break;
  #ifdef FEAT_QUICKFIX
  		    case ADDR_QUICKFIX:
  			lnum = qf_get_cur_valid_idx(eap);
***************
*** 4464,4469 ****
--- 4478,4488 ----
  		    case ADDR_TABS:
  			lnum = LAST_TAB_NR;
  			break;
+ 		    case ADDR_TABS_RELATIVE:
+ 			EMSG(_(e_invrange));
+ 			cmd = NULL;
+ 			goto error;
+ 			break;
  #ifdef FEAT_QUICKFIX
  		    case ADDR_QUICKFIX:
  			lnum = qf_get_size(eap);
***************
*** 4646,4651 ****
--- 4665,4673 ----
  		    case ADDR_TABS:
  			lnum = CURRENT_TAB_NR;
  			break;
+ 		    case ADDR_TABS_RELATIVE:
+ 			lnum = 1;
+ 			break;
  #ifdef FEAT_QUICKFIX
  		    case ADDR_QUICKFIX:
  			lnum = qf_get_cur_valid_idx(eap);
***************
*** 4662,4668 ****
  		n = 1;
  	    else
  		n = getdigits(&cmd);
! 	    if (addr_type == ADDR_LOADED_BUFFERS
  		    || addr_type == ADDR_BUFFERS)
  		lnum = compute_buffer_local_count(
  				    addr_type, lnum, (i == '-') ? -1 * n : n);
--- 4684,4697 ----
  		n = 1;
  	    else
  		n = getdigits(&cmd);
! 
! 	    if (addr_type == ADDR_TABS_RELATIVE)
! 	    {
! 		EMSG(_(e_invrange));
! 		cmd = NULL;
! 		goto error;
! 	    }
! 	    else if (addr_type == ADDR_LOADED_BUFFERS
  		    || addr_type == ADDR_BUFFERS)
  		lnum = compute_buffer_local_count(
  				    addr_type, lnum, (i == '-') ? -1 * n : n);
***************
*** 4795,4800 ****
--- 4824,4832 ----
  		if (eap->line2 > LAST_TAB_NR)
  		    return (char_u *)_(e_invrange);
  		break;
+ 	    case ADDR_TABS_RELATIVE:
+ 		/* Do nothing */
+ 		break;
  #ifdef FEAT_QUICKFIX
  	    case ADDR_QUICKFIX:
  		if (eap->line2 != 1 && eap->line2 > qf_get_size(eap))
***************
*** 5453,5458 ****
--- 5485,5588 ----
  }
  
  /*
+  * Handle the argument for a tabpage related ex command.
+  * Returns a tabpage number.
+  * When an error is encountered then eap->errmsg is set.
+  */
+     static int
+ get_tabpage_arg(exarg_T *eap)
+ {
+     int tab_number;
+     int unaccept_arg0 = (eap->cmdidx == CMD_tabmove) ? 0 : 1;
+ 
+     if (eap->arg && *eap->arg != NUL)
+     {
+ 	char_u *p = eap->arg;
+ 	char_u *p_save;
+ 	int    relative = 0; /* argument +N/-N means: go to N places to the
+ 			      * right/left relative to the current position. */
+ 
+ 	if (*p == '-')
+ 	{
+ 	    relative = -1;
+ 	    p++;
+ 	}
+ 	else if (*p == '+')
+ 	{
+ 	    relative = 1;
+ 	    p++;
+ 	}
+ 
+ 	p_save = p;
+ 	tab_number = getdigits(&p);
+ 
+ 	if (relative == 0)
+ 	{
+ 	    if (STRCMP(p, "$") == 0)
+ 		tab_number = LAST_TAB_NR;
+ 	    else if (p == p_save || *p_save == '-' || *p != NUL
+ 		    || tab_number > LAST_TAB_NR)
+ 	    {
+ 		/* No numbers as argument. */
+ 		eap->errmsg = e_invarg;
+ 		goto theend;
+ 	    }
+ 	}
+ 	else
+ 	{
+ 	    if (*p_save == NUL)
+ 		tab_number = 1;
+ 	    else if (p == p_save || *p_save == '-' || *p != NUL
+ 		    || tab_number == 0)
+ 	    {
+ 		/* No numbers as argument. */
+ 		eap->errmsg = e_invarg;
+ 		goto theend;
+ 	    }
+ 	    tab_number = tab_number * relative + tabpage_index(curtab);
+ 	    if (!unaccept_arg0 && relative == -1)
+ 		--tab_number;
+ 	}
+ 	if (tab_number < unaccept_arg0 || tab_number > LAST_TAB_NR)
+ 	    eap->errmsg = e_invarg;
+     }
+     else if (eap->addr_count > 0)
+     {
+ 	if (unaccept_arg0 && eap->line2 == 0)
+ 	    eap->errmsg = e_invrange;
+ 	else
+ 	{
+ 	    tab_number = eap->line2;
+ 	    if (!unaccept_arg0 && **eap->cmdlinep == '-')
+ 	    {
+ 		--tab_number;
+ 		if (tab_number < unaccept_arg0)
+ 		    eap->errmsg = e_invarg;
+ 	    }
+ 	}
+     }
+     else
+     {
+ 	switch (eap->cmdidx)
+ 	{
+ 	case CMD_tabnext:
+ 	    tab_number = tabpage_index(curtab) + 1;
+ 	    if (tab_number > LAST_TAB_NR)
+ 		tab_number = 1;
+ 	    break;
+ 	case CMD_tabmove:
+ 	    tab_number = LAST_TAB_NR;
+ 	    break;
+ 	default:
+ 	    tab_number = tabpage_index(curtab);
+ 	}
+     }
+ 
+ theend:
+     return tab_number;
+ }
+ 
+ /*
   * ":abbreviate" and friends.
   */
      static void
***************
*** 7444,7449 ****
--- 7574,7580 ----
  ex_tabclose(exarg_T *eap)
  {
      tabpage_T	*tp;
+     int		tab_number;
  
  # ifdef FEAT_CMDWIN
      if (cmdwin_type != 0)
***************
*** 7454,7462 ****
  	    EMSG(_("E784: Cannot close last tab page"));
  	else
  	{
! 	    if (eap->addr_count > 0)
  	    {
! 		tp = find_tabpage((int)eap->line2);
  		if (tp == NULL)
  		{
  		    beep_flush();
--- 7585,7594 ----
  	    EMSG(_("E784: Cannot close last tab page"));
  	else
  	{
! 	    tab_number = get_tabpage_arg(eap);
! 	    if (eap->errmsg == NULL)
  	    {
! 		tp = find_tabpage(tab_number);
  		if (tp == NULL)
  		{
  		    beep_flush();
***************
*** 7467,7479 ****
  		    tabpage_close_other(tp, eap->forceit);
  		    return;
  		}
! 	    }
! 	    if (!text_locked()
  #ifdef FEAT_AUTOCMD
! 		    && !curbuf_locked()
  #endif
! 	       )
! 		tabpage_close(eap->forceit);
  	}
  }
  
--- 7599,7611 ----
  		    tabpage_close_other(tp, eap->forceit);
  		    return;
  		}
! 		else if (!text_locked()
  #ifdef FEAT_AUTOCMD
! 			&& !curbuf_locked()
  #endif
! 		)
! 		    tabpage_close(eap->forceit);
! 	    }
  	}
  }
  
***************
*** 7485,7490 ****
--- 7617,7623 ----
  {
      tabpage_T	*tp;
      int		done;
+     int		tab_number;
  
  # ifdef FEAT_CMDWIN
      if (cmdwin_type != 0)
***************
*** 7495,7518 ****
  	    MSG(_("Already only one tab page"));
  	else
  	{
! 	    if (eap->addr_count > 0)
! 		goto_tabpage(eap->line2);
! 	    /* Repeat this up to a 1000 times, because autocommands may mess
! 	     * up the lists. */
! 	    for (done = 0; done < 1000; ++done)
  	    {
! 		FOR_ALL_TABPAGES(tp)
! 		    if (tp->tp_topframe != topframe)
! 		    {
! 			tabpage_close_other(tp, eap->forceit);
! 			/* if we failed to close it quit */
! 			if (valid_tabpage(tp))
! 			    done = 1000;
! 			/* start over, "tp" is now invalid */
  			break;
! 		    }
! 		if (first_tabpage->tp_next == NULL)
! 		    break;
  	    }
  	}
  }
--- 7628,7654 ----
  	    MSG(_("Already only one tab page"));
  	else
  	{
! 	    tab_number = get_tabpage_arg(eap);
! 	    if (eap->errmsg == NULL)
  	    {
! 		goto_tabpage(tab_number);
! 		/* Repeat this up to a 1000 times, because autocommands may
! 		 * mess up the lists. */
! 		for (done = 0; done < 1000; ++done)
! 		{
! 		    FOR_ALL_TABPAGES(tp)
! 			if (tp->tp_topframe != topframe)
! 			{
! 			    tabpage_close_other(tp, eap->forceit);
! 			    /* if we failed to close it quit */
! 			    if (valid_tabpage(tp))
! 				done = 1000;
! 			    /* start over, "tp" is now invalid */
! 			    break;
! 			}
! 		    if (first_tabpage->tp_next == NULL)
  			break;
! 		}
  	    }
  	}
  }
***************
*** 8254,8259 ****
--- 8390,8397 ----
      static void
  ex_tabnext(exarg_T *eap)
  {
+     int tab_number;
+ 
      switch (eap->cmdidx)
      {
  	case CMD_tabfirst:
***************
*** 8265,8274 ****
  	    break;
  	case CMD_tabprevious:
  	case CMD_tabNext:
! 	    goto_tabpage(eap->addr_count == 0 ? -1 : -(int)eap->line2);
  	    break;
  	default: /* CMD_tabnext */
! 	    goto_tabpage(eap->addr_count == 0 ? 0 : (int)eap->line2);
  	    break;
      }
  }
--- 8403,8442 ----
  	    break;
  	case CMD_tabprevious:
  	case CMD_tabNext:
! 	    if (eap->arg && *eap->arg != NUL)
! 	    {
! 		char_u *p = eap->arg;
! 		char_u *p_save = p;
! 
! 		tab_number = getdigits(&p);
! 		if (p == p_save || *p_save == '-' || *p != NUL
! 			    || tab_number == 0)
! 		{
! 		    /* No numbers as argument. */
! 		    eap->errmsg = e_invarg;
! 		    return;
! 		}
! 	    }
! 	    else
! 	    {
! 		if (eap->addr_count == 0)
! 		    tab_number = 1;
! 		else
! 		{
! 		    tab_number = eap->line2;
! 		    if (tab_number < 1)
! 		    {
! 			eap->errmsg = e_invrange;
! 			return;
! 		    }
! 		}
! 	    }
! 	    goto_tabpage(-tab_number);
  	    break;
  	default: /* CMD_tabnext */
! 	    tab_number = get_tabpage_arg(eap);
! 	    if (eap->errmsg == NULL)
! 		goto_tabpage(tab_number);
  	    break;
      }
  }
***************
*** 8281,8339 ****
  {
      int tab_number;
  
!     if (eap->arg && *eap->arg != NUL)
!     {
! 	char_u *p = eap->arg;
! 	int    relative = 0; /* argument +N/-N means: move N places to the
! 			      * right/left relative to the current position. */
! 
! 	if (*eap->arg == '-')
! 	{
! 	    relative = -1;
! 	    p = eap->arg + 1;
! 	}
! 	else if (*eap->arg == '+')
! 	{
! 	    relative = 1;
! 	    p = eap->arg + 1;
! 	}
! 	else
! 	    p = eap->arg;
! 
! 	if (relative == 0)
! 	{
! 	    if (STRCMP(p, "$") == 0)
! 		tab_number = LAST_TAB_NR;
! 	    else if (p == skipdigits(p))
! 	    {
! 		/* No numbers as argument. */
! 		eap->errmsg = e_invarg;
! 		return;
! 	    }
! 	    else
! 		tab_number = getdigits(&p);
! 	}
! 	else
! 	{
! 	    if (*p != NUL)
! 		tab_number = getdigits(&p);
! 	    else
! 		tab_number = 1;
! 	    tab_number = tab_number * relative + tabpage_index(curtab);
! 	    if (relative == -1)
! 		--tab_number;
! 	}
!     }
!     else if (eap->addr_count != 0)
!     {
! 	tab_number = eap->line2;
! 	if (**eap->cmdlinep == '-')
! 	    --tab_number;
!     }
!     else
! 	tab_number = LAST_TAB_NR;
! 
!     tabpage_move(tab_number);
  }
  
  /*
--- 8449,8457 ----
  {
      int tab_number;
  
!     tab_number = get_tabpage_arg(eap);
!     if (eap->errmsg == NULL)
! 	tabpage_move(tab_number);
  }
  
  /*
*** ../vim-8.0.0258/src/testdir/test_tabpage.vim	2016-12-01 17:48:24.910803059 +0100
--- src/testdir/test_tabpage.vim	2017-01-29 14:26:29.900913529 +0100
***************
*** 94,103 ****
    call assert_equal(7, tabpagenr())
    tabmove
    call assert_equal(10, tabpagenr())
-   tabmove -20
-   call assert_equal(1, tabpagenr())
-   tabmove +20
-   call assert_equal(10, tabpagenr())
    0tabmove
    call assert_equal(1, tabpagenr())
    $tabmove
--- 94,99 ----
***************
*** 110,116 ****
--- 106,121 ----
    call assert_equal(4, tabpagenr())
    7tabmove 5
    call assert_equal(5, tabpagenr())
+   call assert_fails("99tabmove", 'E16:')
+   call assert_fails("+99tabmove", 'E16:')
+   call assert_fails("-99tabmove", 'E16:')
    call assert_fails("tabmove foo", 'E474:')
+   call assert_fails("tabmove 99", 'E474:')
+   call assert_fails("tabmove +99", 'E474:')
+   call assert_fails("tabmove -99", 'E474:')
+   call assert_fails("tabmove -3+", 'E474:')
+   call assert_fails("tabmove $3", 'E474:')
+   1tabonly!
  endfunc
  
  " Test autocommands
***************
*** 118,124 ****
    if !has('autocmd')
      return
    endif
-   tabonly!
    command -nargs=1 -bar C :call add(s:li, '=== ' . <q-args> . ' ===')|<args>
    augroup TestTabpageGroup
      au!
--- 123,128 ----
***************
*** 183,190 ****
  
    autocmd TabDestructive TabEnter * nested :C tabnext 2 | C tabclose 3
    let s:li = []
!   C tabnext 3
!   call assert_equal(['=== tabnext 3 ===', 'BufLeave', 'WinLeave', 'TabLeave', 'WinEnter', 'TabEnter', '=== tabnext 2 ===', 'BufLeave', 'WinLeave', 'TabLeave', 'WinEnter', 'TabEnter', '=== tabnext 2 ===', '=== tabclose 3 ===', 'BufEnter', '=== tabclose 3 ==='], s:li)
    call assert_equal(['2/2'], [tabpagenr().'/'.tabpagenr('$')])
  
    delcommand C
--- 187,196 ----
  
    autocmd TabDestructive TabEnter * nested :C tabnext 2 | C tabclose 3
    let s:li = []
!   call assert_equal(3, tabpagenr('$'))
!   C tabnext 2
!   call assert_equal(2, tabpagenr('$'))
!   call assert_equal(['=== tabnext 2 ===', 'WinLeave', 'TabLeave', 'WinEnter', 'TabEnter', '=== tabnext 2 ===', '=== tabclose 3 ==='], s:li)
    call assert_equal(['2/2'], [tabpagenr().'/'.tabpagenr('$')])
  
    delcommand C
***************
*** 192,199 ****
    augroup! TabDestructive
    autocmd! TestTabpageGroup
    augroup! TestTabpageGroup
!   tabonly!
!   bw!
  endfunction
  
  function Test_tabpage_with_tab_modifier()
--- 198,204 ----
    augroup! TabDestructive
    autocmd! TestTabpageGroup
    augroup! TestTabpageGroup
!   1tabonly!
  endfunction
  
  function Test_tabpage_with_tab_modifier()
***************
*** 224,231 ****
    call assert_fails('-99tab help', 'E16:')
  
    delfunction s:check_tab
!   tabonly!
!   bw!
  endfunction
  
  func Test_tabnext_on_buf_unload1()
--- 229,451 ----
    call assert_fails('-99tab help', 'E16:')
  
    delfunction s:check_tab
!   1tabonly!
! endfunction
! 
! function Check_tab_count(pre_nr, cmd, post_nr)
!   exec 'tabnext' a:pre_nr
!   normal! G
!   exec a:cmd
!   call assert_equal(a:post_nr, tabpagenr(), a:cmd)
! endfunc
! 
! " Test for [count] of tabnext
! function Test_tabpage_with_tabnext()
!   for n in range(4)
!     tabedit
!     call setline(1, ['', '', '3'])
!   endfor
! 
!   call Check_tab_count(1, 'tabnext', 2)
!   call Check_tab_count(1, '3tabnext', 3)
!   call Check_tab_count(1, '.tabnext', 1)
!   call Check_tab_count(1, '.+1tabnext', 2)
!   call Check_tab_count(2, '+tabnext', 3)
!   call Check_tab_count(2, '+2tabnext', 4)
!   call Check_tab_count(4, '-tabnext', 3)
!   call Check_tab_count(4, '-2tabnext', 2)
!   call Check_tab_count(3, '$tabnext', 5)
!   call assert_fails('0tabnext', 'E16:')
!   call assert_fails('99tabnext', 'E16:')
!   call assert_fails('+99tabnext', 'E16:')
!   call assert_fails('-99tabnext', 'E16:')
!   call Check_tab_count(1, 'tabnext 3', 3)
!   call Check_tab_count(2, 'tabnext +', 3)
!   call Check_tab_count(2, 'tabnext +2', 4)
!   call Check_tab_count(4, 'tabnext -', 3)
!   call Check_tab_count(4, 'tabnext -2', 2)
!   call Check_tab_count(3, 'tabnext $', 5)
!   call assert_fails('tabnext 0', 'E474:')
!   call assert_fails('tabnext .', 'E474:')
!   call assert_fails('tabnext -+', 'E474:')
!   call assert_fails('tabnext +2-', 'E474:')
!   call assert_fails('tabnext $3', 'E474:')
!   call assert_fails('tabnext 99', 'E474:')
!   call assert_fails('tabnext +99', 'E474:')
!   call assert_fails('tabnext -99', 'E474:')
! 
!   1tabonly!
! endfunction
! 
! " Test for [count] of tabprevious
! function Test_tabpage_with_tabprevious()
!   for n in range(5)
!     tabedit
!     call setline(1, ['', '', '3'])
!   endfor
! 
!   for cmd in ['tabNext', 'tabprevious']
!     call Check_tab_count(6, cmd, 5)
!     call Check_tab_count(6, '3' . cmd, 3)
!     call Check_tab_count(6, '8' . cmd, 4)
!     call Check_tab_count(6, cmd . ' 3', 3)
!     call Check_tab_count(6, cmd . ' 8', 4)
!     for n in range(2)
!       for c in ['0', '.+3', '+', '+2' , '-', '-2' , '$', '+99', '-99']
!         if n == 0 " pre count
!           let entire_cmd = c . cmd
!           let err_code = 'E16:'
!         else
!           let entire_cmd = cmd . ' ' . c
!           let err_code = 'E474:'
!         endif
!         call assert_fails(entire_cmd, err_code)
!       endfor
!     endfor
!   endfor
! 
!   1tabonly!
! endfunction
! 
! function s:reconstruct_tabpage_for_test(nr)
!   let n = (a:nr > 2) ? a:nr - 2 : 1
!   1tabonly!
!   0tabedit n0
!   for n in range(1, n)
!     exec '$tabedit n' . n
!     if n == 1
!       call setline(1, ['', '', '3'])
!     endif
!   endfor
! endfunc
! 
! " Test for [count] of tabclose
! function Test_tabpage_with_tabclose()
! 
!   " pre count
!   call s:reconstruct_tabpage_for_test(6)
!   call Check_tab_count(3, 'tabclose!', 3)
!   call Check_tab_count(1, '3tabclose', 1)
!   call Check_tab_count(4, '4tabclose', 3)
!   call Check_tab_count(3, '1tabclose', 2)
!   call Check_tab_count(2, 'tabclose', 1)
!   call assert_equal(1, tabpagenr('$'))
!   call assert_equal('', bufname(''))
! 
!   call s:reconstruct_tabpage_for_test(6)
!   call Check_tab_count(2, '$tabclose', 2)
!   call Check_tab_count(4, '.tabclose', 4)
!   call Check_tab_count(3, '.+tabclose', 3)
!   call Check_tab_count(3, '.-2tabclose', 2)
!   call Check_tab_count(1, '.+1tabclose!', 1)
!   call assert_equal(1, tabpagenr('$'))
!   call assert_equal('', bufname(''))
! 
!   " post count
!   call s:reconstruct_tabpage_for_test(6)
!   call Check_tab_count(3, 'tabclose!', 3)
!   call Check_tab_count(1, 'tabclose 3', 1)
!   call Check_tab_count(4, 'tabclose 4', 3)
!   call Check_tab_count(3, 'tabclose 1', 2)
!   call Check_tab_count(2, 'tabclose', 1)
!   call assert_equal(1, tabpagenr('$'))
!   call assert_equal('', bufname(''))
! 
!   call s:reconstruct_tabpage_for_test(6)
!   call Check_tab_count(2, 'tabclose $', 2)
!   call Check_tab_count(4, 'tabclose', 4)
!   call Check_tab_count(3, 'tabclose +', 3)
!   call Check_tab_count(3, 'tabclose -2', 2)
!   call Check_tab_count(1, 'tabclose! +1', 1)
!   call assert_equal(1, tabpagenr('$'))
!   call assert_equal('', bufname(''))
! 
!   call s:reconstruct_tabpage_for_test(6)
!   for n in range(2)
!     for c in ['0', '$3', '99', '+99', '-99']
!       if n == 0 " pre count
!         let entire_cmd = c . 'tabclose'
!         let err_code = 'E16:'
!       else
!         let entire_cmd = 'tabclose ' . c
!         let err_code = 'E474:'
!       endif
!       call assert_fails(entire_cmd, err_code)
!       call assert_equal(6, tabpagenr('$'))
!     endfor
!   endfor
! 
!   call assert_fails('3tabclose', 'E37:')
!   call assert_fails('tabclose 3', 'E37:')
!   call assert_fails('tabclose -+', 'E474:')
!   call assert_fails('tabclose +2-', 'E474:')
!   call assert_equal(6, tabpagenr('$'))
! 
!   1tabonly!
! endfunction
! 
! " Test for [count] of tabonly
! function Test_tabpage_with_tabonly()
! 
!   " Test for the normal behavior (pre count only)
!   let tc = [ [4, '.', '!'], [2, '.+', ''], [3, '.-2', '!'], [1, '.+1', '!'] ]
!   for c in tc
!     call s:reconstruct_tabpage_for_test(6)
!     let entire_cmd = c[1] . 'tabonly' . c[2]
!     call Check_tab_count(c[0], entire_cmd, 1)
!     call assert_equal(1, tabpagenr('$'))
!   endfor
! 
!   " Test for the normal behavior
!   let tc2 = [ [3, '', ''], [1, '3', ''], [4, '4', '!'], [3, '1', '!'],
!         \    [2, '', '!'],
!         \    [2, '$', '!'], [3, '+', '!'], [3, '-2', '!'], [3, '+1', '!']
!         \  ]
!   for n in range(2)
!     for c in tc2
!       call s:reconstruct_tabpage_for_test(6)
!       if n == 0 " pre count
!         let entire_cmd = c[1] . 'tabonly' . c[2]
!       else
!         let entire_cmd = 'tabonly' . c[2] . ' ' . c[1]
!       endif
!       call Check_tab_count(c[0], entire_cmd, 1)
!       call assert_equal(1, tabpagenr('$'))
!     endfor
!   endfor
! 
!   " Test for the error behavior
!   for n in range(2)
!     for c in ['0', '$3', '99', '+99', '-99']
!       call s:reconstruct_tabpage_for_test(6)
!       if n == 0 " pre count
!         let entire_cmd = c . 'tabonly'
!         let err_code = 'E16:'
!       else
!         let entire_cmd = 'tabonly ' . c
!         let err_code = 'E474:'
!       endif
!       call assert_fails(entire_cmd, err_code)
!       call assert_equal(6, tabpagenr('$'))
!     endfor
!   endfor
! 
!   " Test for the error behavior (post count only)
!   for c in tc
!     call s:reconstruct_tabpage_for_test(6)
!     let entire_cmd = 'tabonly' . c[2] . ' ' . c[1]
!     let err_code = 'E474:'
!     call assert_fails(entire_cmd, err_code)
!     call assert_equal(6, tabpagenr('$'))
!   endfor
! 
!   call assert_fails('tabonly -+', 'E474:')
!   call assert_fails('tabonly +2-', 'E474:')
!   call assert_equal(6, tabpagenr('$'))
! 
!   1tabonly!
!   new
!   only!
  endfunction
  
  func Test_tabnext_on_buf_unload1()
*** ../vim-8.0.0258/src/version.c	2017-01-29 14:14:04.549800163 +0100
--- src/version.c	2017-01-29 14:27:04.456687434 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     259,
  /**/

-- 
CRONE:  Who sent you?
ARTHUR: The Knights Who Say Ni!
CRONE:  Aaaagh!  (she looks around in rear) No!  We have no shrubberies here.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0260
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0260
Problem:    Build fails with tiny features.
Solution:   Move get_tabpage_arg() inside #ifdef.
Files:      src/ex_docmd.c


*** ../vim-8.0.0259/src/ex_docmd.c	2017-01-29 14:48:06.288454957 +0100
--- src/ex_docmd.c	2017-01-29 15:13:08.498451464 +0100
***************
*** 5485,5588 ****
  }
  
  /*
-  * Handle the argument for a tabpage related ex command.
-  * Returns a tabpage number.
-  * When an error is encountered then eap->errmsg is set.
-  */
-     static int
- get_tabpage_arg(exarg_T *eap)
- {
-     int tab_number;
-     int unaccept_arg0 = (eap->cmdidx == CMD_tabmove) ? 0 : 1;
- 
-     if (eap->arg && *eap->arg != NUL)
-     {
- 	char_u *p = eap->arg;
- 	char_u *p_save;
- 	int    relative = 0; /* argument +N/-N means: go to N places to the
- 			      * right/left relative to the current position. */
- 
- 	if (*p == '-')
- 	{
- 	    relative = -1;
- 	    p++;
- 	}
- 	else if (*p == '+')
- 	{
- 	    relative = 1;
- 	    p++;
- 	}
- 
- 	p_save = p;
- 	tab_number = getdigits(&p);
- 
- 	if (relative == 0)
- 	{
- 	    if (STRCMP(p, "$") == 0)
- 		tab_number = LAST_TAB_NR;
- 	    else if (p == p_save || *p_save == '-' || *p != NUL
- 		    || tab_number > LAST_TAB_NR)
- 	    {
- 		/* No numbers as argument. */
- 		eap->errmsg = e_invarg;
- 		goto theend;
- 	    }
- 	}
- 	else
- 	{
- 	    if (*p_save == NUL)
- 		tab_number = 1;
- 	    else if (p == p_save || *p_save == '-' || *p != NUL
- 		    || tab_number == 0)
- 	    {
- 		/* No numbers as argument. */
- 		eap->errmsg = e_invarg;
- 		goto theend;
- 	    }
- 	    tab_number = tab_number * relative + tabpage_index(curtab);
- 	    if (!unaccept_arg0 && relative == -1)
- 		--tab_number;
- 	}
- 	if (tab_number < unaccept_arg0 || tab_number > LAST_TAB_NR)
- 	    eap->errmsg = e_invarg;
-     }
-     else if (eap->addr_count > 0)
-     {
- 	if (unaccept_arg0 && eap->line2 == 0)
- 	    eap->errmsg = e_invrange;
- 	else
- 	{
- 	    tab_number = eap->line2;
- 	    if (!unaccept_arg0 && **eap->cmdlinep == '-')
- 	    {
- 		--tab_number;
- 		if (tab_number < unaccept_arg0)
- 		    eap->errmsg = e_invarg;
- 	    }
- 	}
-     }
-     else
-     {
- 	switch (eap->cmdidx)
- 	{
- 	case CMD_tabnext:
- 	    tab_number = tabpage_index(curtab) + 1;
- 	    if (tab_number > LAST_TAB_NR)
- 		tab_number = 1;
- 	    break;
- 	case CMD_tabmove:
- 	    tab_number = LAST_TAB_NR;
- 	    break;
- 	default:
- 	    tab_number = tabpage_index(curtab);
- 	}
-     }
- 
- theend:
-     return tab_number;
- }
- 
- /*
   * ":abbreviate" and friends.
   */
      static void
--- 5485,5490 ----
***************
*** 7567,7572 ****
--- 7469,7572 ----
  }
  
  /*
+  * Handle the argument for a tabpage related ex command.
+  * Returns a tabpage number.
+  * When an error is encountered then eap->errmsg is set.
+  */
+     static int
+ get_tabpage_arg(exarg_T *eap)
+ {
+     int tab_number;
+     int unaccept_arg0 = (eap->cmdidx == CMD_tabmove) ? 0 : 1;
+ 
+     if (eap->arg && *eap->arg != NUL)
+     {
+ 	char_u *p = eap->arg;
+ 	char_u *p_save;
+ 	int    relative = 0; /* argument +N/-N means: go to N places to the
+ 			      * right/left relative to the current position. */
+ 
+ 	if (*p == '-')
+ 	{
+ 	    relative = -1;
+ 	    p++;
+ 	}
+ 	else if (*p == '+')
+ 	{
+ 	    relative = 1;
+ 	    p++;
+ 	}
+ 
+ 	p_save = p;
+ 	tab_number = getdigits(&p);
+ 
+ 	if (relative == 0)
+ 	{
+ 	    if (STRCMP(p, "$") == 0)
+ 		tab_number = LAST_TAB_NR;
+ 	    else if (p == p_save || *p_save == '-' || *p != NUL
+ 		    || tab_number > LAST_TAB_NR)
+ 	    {
+ 		/* No numbers as argument. */
+ 		eap->errmsg = e_invarg;
+ 		goto theend;
+ 	    }
+ 	}
+ 	else
+ 	{
+ 	    if (*p_save == NUL)
+ 		tab_number = 1;
+ 	    else if (p == p_save || *p_save == '-' || *p != NUL
+ 		    || tab_number == 0)
+ 	    {
+ 		/* No numbers as argument. */
+ 		eap->errmsg = e_invarg;
+ 		goto theend;
+ 	    }
+ 	    tab_number = tab_number * relative + tabpage_index(curtab);
+ 	    if (!unaccept_arg0 && relative == -1)
+ 		--tab_number;
+ 	}
+ 	if (tab_number < unaccept_arg0 || tab_number > LAST_TAB_NR)
+ 	    eap->errmsg = e_invarg;
+     }
+     else if (eap->addr_count > 0)
+     {
+ 	if (unaccept_arg0 && eap->line2 == 0)
+ 	    eap->errmsg = e_invrange;
+ 	else
+ 	{
+ 	    tab_number = eap->line2;
+ 	    if (!unaccept_arg0 && **eap->cmdlinep == '-')
+ 	    {
+ 		--tab_number;
+ 		if (tab_number < unaccept_arg0)
+ 		    eap->errmsg = e_invarg;
+ 	    }
+ 	}
+     }
+     else
+     {
+ 	switch (eap->cmdidx)
+ 	{
+ 	case CMD_tabnext:
+ 	    tab_number = tabpage_index(curtab) + 1;
+ 	    if (tab_number > LAST_TAB_NR)
+ 		tab_number = 1;
+ 	    break;
+ 	case CMD_tabmove:
+ 	    tab_number = LAST_TAB_NR;
+ 	    break;
+ 	default:
+ 	    tab_number = tabpage_index(curtab);
+ 	}
+     }
+ 
+ theend:
+     return tab_number;
+ }
+ 
+ /*
   * ":tabclose": close current tab page, unless it is the last one.
   * ":tabclose N": close tab page N.
   */
*** ../vim-8.0.0259/src/version.c	2017-01-29 14:48:06.288454957 +0100
--- src/version.c	2017-01-29 15:17:59.796512728 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     260,
  /**/

-- 
Mental Floss prevents moral decay!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0261
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0261
Problem:    Not enough test coverage for eval functions.
Solution:   Add more tests. (Dominique Pelle, closes #1420)
Files:      src/testdir/test_functions.vim


*** ../vim-8.0.0260/src/testdir/test_functions.vim	2017-01-26 22:51:51.997875762 +0100
--- src/testdir/test_functions.vim	2017-01-29 15:41:49.319082669 +0100
***************
*** 1,5 ****
--- 1,78 ----
  " Tests for various functions.
  
+ func Test_empty()
+   call assert_equal(1, empty(''))
+   call assert_equal(0, empty('a'))
+ 
+   call assert_equal(1, empty(0))
+   call assert_equal(1, empty(-0))
+   call assert_equal(0, empty(1))
+   call assert_equal(0, empty(-1))
+ 
+   call assert_equal(1, empty(0.0))
+   call assert_equal(1, empty(-0.0))
+   call assert_equal(0, empty(1.0))
+   call assert_equal(0, empty(-1.0))
+   call assert_equal(0, empty(1.0/0.0))
+   call assert_equal(0, empty(0.0/0.0))
+ 
+   call assert_equal(1, empty([]))
+   call assert_equal(0, empty(['a']))
+ 
+   call assert_equal(1, empty({}))
+   call assert_equal(0, empty({'a':1}))
+ 
+   call assert_equal(1, empty(v:null))
+   call assert_equal(1, empty(v:none))
+   call assert_equal(1, empty(v:false))
+   call assert_equal(0, empty(v:true))
+ 
+   call assert_equal(0, empty(function('Test_empty')))
+ endfunc
+ 
+ func Test_len()
+   call assert_equal(1, len(0))
+   call assert_equal(2, len(12))
+ 
+   call assert_equal(0, len(''))
+   call assert_equal(2, len('ab'))
+ 
+   call assert_equal(0, len([]))
+   call assert_equal(2, len([2, 1]))
+ 
+   call assert_equal(0, len({}))
+   call assert_equal(2, len({'a': 1, 'b': 2}))
+ 
+   call assert_fails('call len(v:none)', 'E701:')
+   call assert_fails('call len({-> 0})', 'E701:')
+ endfunc
+ 
+ func Test_max()
+   call assert_equal(0, max([]))
+   call assert_equal(2, max([2]))
+   call assert_equal(2, max([1, 2]))
+   call assert_equal(2, max([1, 2, v:null]))
+ 
+   call assert_equal(0, max({}))
+   call assert_equal(2, max({'a':1, 'b':2}))
+ 
+   call assert_fails('call max(1)', 'E712:')
+   call assert_fails('call max(v:none)', 'E712:')
+ endfunc
+ 
+ func Test_min()
+   call assert_equal(0, min([]))
+   call assert_equal(2, min([2]))
+   call assert_equal(1, min([1, 2]))
+   call assert_equal(0, min([1, 2, v:null]))
+ 
+   call assert_equal(0, min({}))
+   call assert_equal(1, min({'a':1, 'b':2}))
+ 
+   call assert_fails('call min(1)', 'E712:')
+   call assert_fails('call min(v:none)', 'E712:')
+ endfunc
+ 
  func Test_str2nr()
    call assert_equal(0, str2nr(''))
    call assert_equal(1, str2nr('1'))
***************
*** 15,20 ****
--- 88,164 ----
  
    call assert_equal(123456789, str2nr('123456789'))
    call assert_equal(-123456789, str2nr('-123456789'))
+ 
+   call assert_equal(5, str2nr('101', 2))
+   call assert_equal(5, str2nr('0b101', 2))
+   call assert_equal(5, str2nr('0B101', 2))
+   call assert_equal(-5, str2nr('-101', 2))
+   call assert_equal(-5, str2nr('-0b101', 2))
+   call assert_equal(-5, str2nr('-0B101', 2))
+ 
+   call assert_equal(65, str2nr('101', 8))
+   call assert_equal(65, str2nr('0101', 8))
+   call assert_equal(-65, str2nr('-101', 8))
+   call assert_equal(-65, str2nr('-0101', 8))
+ 
+   call assert_equal(11259375, str2nr('abcdef', 16))
+   call assert_equal(11259375, str2nr('ABCDEF', 16))
+   call assert_equal(-11259375, str2nr('-ABCDEF', 16))
+   call assert_equal(11259375, str2nr('0xabcdef', 16))
+   call assert_equal(11259375, str2nr('0Xabcdef', 16))
+   call assert_equal(11259375, str2nr('0XABCDEF', 16))
+   call assert_equal(-11259375, str2nr('-0xABCDEF', 16))
+ 
+   call assert_equal(0, str2nr('0x10'))
+   call assert_equal(0, str2nr('0b10'))
+   call assert_equal(1, str2nr('12', 2))
+   call assert_equal(1, str2nr('18', 8))
+   call assert_equal(1, str2nr('1g', 16))
+ 
+   call assert_equal(0, str2nr(v:null))
+   call assert_equal(0, str2nr(v:none))
+ 
+   call assert_fails('call str2nr([])', 'E730:')
+   call assert_fails('call str2nr({->2})', 'E729:')
+   call assert_fails('call str2nr(1.2)', 'E806:')
+   call assert_fails('call str2nr(10, [])', 'E474:')
+ endfunc
+ 
+ func Test_strftime()
+   if !exists('*strftime')
+     return
+   endif
+   " Format of strftime() depends on system. We assume
+   " that basic formats tested here are available and
+   " identical on all systems which support strftime().
+   "
+   " The 2nd parameter of strftime() is a local time, so the output day
+   " of strftime() can be 17 or 18, depending on timezone.
+   call assert_match('^2017-01-1[78]$', strftime('%Y-%m-%d', 1484695512))
+   "
+   call assert_match('^\d\d\d\d-\(0\d\|1[012]\)-\([012]\d\|3[01]\) \([01]\d\|2[0-3]\):[0-5]\d:\([0-5]\d\|60\)$', strftime('%Y-%m-%d %H:%M:%S'))
+ 
+   call assert_fails('call strftime([])', 'E730:')
+   call assert_fails('call strftime("%Y", [])', 'E745:')
+ endfunc
+ 
+ func Test_simplify()
+   call assert_equal('',            simplify(''))
+   call assert_equal('/',           simplify('/'))
+   call assert_equal('/',           simplify('/.'))
+   call assert_equal('/',           simplify('/..'))
+   call assert_equal('/...',        simplify('/...'))
+   call assert_equal('./dir/file',  simplify('./dir/file'))
+   call assert_equal('./dir/file',  simplify('.///dir//file'))
+   call assert_equal('./dir/file',  simplify('./dir/./file'))
+   call assert_equal('./file',      simplify('./dir/../file'))
+   call assert_equal('../dir/file', simplify('dir/../../dir/file'))
+   call assert_equal('./file',      simplify('dir/.././file'))
+ 
+   call assert_fails('call simplify({->0})', 'E729:')
+   call assert_fails('call simplify([])', 'E730:')
+   call assert_fails('call simplify({})', 'E731:')
+   call assert_fails('call simplify(1.2)', 'E806:')
  endfunc
  
  func Test_tolower()
***************
*** 157,163 ****
    call assert_equal("Y", toupper("Y"))
    call assert_equal("Z", toupper("Z"))
  
!   call assert_equal(" ", tolower(" "))
  endfunc
  
  
--- 301,307 ----
    call assert_equal("Y", toupper("Y"))
    call assert_equal("Z", toupper("Z"))
  
!   call assert_equal(" ", toupper(" "))
  endfunc
  
  
*** ../vim-8.0.0260/src/version.c	2017-01-29 15:18:04.896478906 +0100
--- src/version.c	2017-01-29 15:43:16.922507354 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     261,
  /**/

-- 
Be nice to your kids...  they'll be the ones choosing your nursing home.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0262
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0262
Problem:    Farsi support is barely tested.
Solution:   Add more tests for Farsi.  Clean up the code.
Files:      src/edit.c, src/farsi.c, src/testdir/test_farsi.vim


*** ../vim-8.0.0261/src/edit.c	2017-01-27 21:48:46.960162956 +0100
--- src/edit.c	2017-01-29 17:06:40.557446744 +0100
***************
*** 6166,6171 ****
--- 6166,6174 ----
  		&& (!has_mbyte || MB_BYTE2LEN_CHECK(c) == 1)
  #endif
  		&& i < INPUT_BUFLEN
+ # ifdef FEAT_FKMAP
+ 		&& !(p_fkmap && KeyTyped) /* Farsi mode mapping moves cursor */
+ # endif
  		&& (textwidth == 0
  		    || (virtcol += byte2cells(buf[i - 1])) < (colnr_T)textwidth)
  		&& !(!no_abbr && !vim_iswordc(c) && vim_iswordc(buf[i - 1])))
***************
*** 6174,6183 ****
  	    c = vgetc();
  	    if (p_hkmap && KeyTyped)
  		c = hkmap(c);		    /* Hebrew mode mapping */
- # ifdef FEAT_FKMAP
- 	    if (p_fkmap && KeyTyped)
- 		c = fkmap(c);		    /* Farsi mode mapping */
- # endif
  	    buf[i++] = c;
  #else
  	    buf[i++] = vgetc();
--- 6177,6182 ----
*** ../vim-8.0.0261/src/farsi.c	2016-08-29 22:42:20.000000000 +0200
--- src/farsi.c	2017-01-29 17:41:50.791559899 +0100
***************
*** 15,44 ****
  
  #if defined(FEAT_FKMAP) || defined(PROTO)
  
- static int toF_Xor_X_(int c);
- static int F_is_TyE(int c);
- static int F_is_TyC_TyD(int c);
  static int F_is_TyB_TyC_TyD(int src, int offset);
- static int toF_TyB(int c);
- static void put_curr_and_l_to_X(int c);
- static void put_and_redo(int c);
- static void chg_c_toX_orX(void);
- static void chg_c_to_X_orX_(void);
- static void chg_c_to_X_or_X(void);
- static void chg_l_to_X_orX_(void);
- static void chg_l_toXor_X(void);
- static void chg_r_to_Xor_X_(void);
- static int toF_leading(int c);
- static int toF_Rjoin(int c);
- static int canF_Ljoin(int c);
- static int canF_Rjoin(int c);
- static int F_isterm(int c);
- static int toF_ending(int c);
- static void lrswapbuf(char_u *buf, int len);
  
  /*
   * Convert the given Farsi character into a _X or _X_ type
! */
      static int
  toF_Xor_X_(int c)
  {
--- 15,25 ----
  
  #if defined(FEAT_FKMAP) || defined(PROTO)
  
  static int F_is_TyB_TyC_TyD(int src, int offset);
  
  /*
   * Convert the given Farsi character into a _X or _X_ type
!  */
      static int
  toF_Xor_X_(int c)
  {
***************
*** 105,111 ****
  
  /*
   * Convert the given Farsi character into Farsi capital character.
! */
      static int
  toF_TyA(int c)
  {
--- 86,92 ----
  
  /*
   * Convert the given Farsi character into Farsi capital character.
!  */
      static int
  toF_TyA(int c)
  {
***************
*** 156,162 ****
   * Is the character under the cursor+offset in the given buffer a join type.
   * That is a character that is combined with the others.
   * Note: the offset is used only for command line buffer.
! */
      static int
  F_is_TyB_TyC_TyD(int src, int offset)
  {
--- 137,143 ----
   * Is the character under the cursor+offset in the given buffer a join type.
   * That is a character that is combined with the others.
   * Note: the offset is used only for command line buffer.
!  */
      static int
  F_is_TyB_TyC_TyD(int src, int offset)
  {
***************
*** 207,213 ****
  
  /*
   * Is the Farsi character one of the terminating only type.
! */
      static int
  F_is_TyE(int c)
  {
--- 188,194 ----
  
  /*
   * Is the Farsi character one of the terminating only type.
!  */
      static int
  F_is_TyE(int c)
  {
***************
*** 230,236 ****
  
  /*
   * Is the Farsi character one of the none leading type.
! */
      static int
  F_is_TyC_TyD(int c)
  {
--- 211,217 ----
  
  /*
   * Is the Farsi character one of the none leading type.
!  */
      static int
  F_is_TyC_TyD(int c)
  {
***************
*** 254,260 ****
  
  /*
   * Convert a none leading Farsi char into a leading type.
! */
      static int
  toF_TyB(int c)
  {
--- 235,241 ----
  
  /*
   * Convert a none leading Farsi char into a leading type.
!  */
      static int
  toF_TyB(int c)
  {
***************
*** 275,283 ****
      return c;
  }
  
  /*
   * Overwrite the current redo and cursor characters + left adjust.
! */
      static void
  put_curr_and_l_to_X(int c)
  {
--- 256,273 ----
      return c;
  }
  
+ 
+     static void
+ put_and_redo(int c)
+ {
+     pchar_cursor(c);
+     AppendCharToRedobuff(K_BS);
+     AppendCharToRedobuff(c);
+ }
+ 
  /*
   * Overwrite the current redo and cursor characters + left adjust.
!  */
      static void
  put_curr_and_l_to_X(int c)
  {
***************
*** 312,328 ****
      put_and_redo(c);
  }
  
-     static void
- put_and_redo(int c)
- {
-     pchar_cursor(c);
-     AppendCharToRedobuff(K_BS);
-     AppendCharToRedobuff(c);
- }
- 
  /*
   * Change the char. under the cursor to a X_ or X type
! */
      static void
  chg_c_toX_orX(void)
  {
--- 302,310 ----
      put_and_redo(c);
  }
  
  /*
   * Change the char. under the cursor to a X_ or X type
!  */
      static void
  chg_c_toX_orX(void)
  {
***************
*** 446,453 ****
  
  /*
   * Change the char. under the cursor to a _X_ or X_ type
! */
! 
      static void
  chg_c_to_X_orX_(void)
  {
--- 428,434 ----
  
  /*
   * Change the char. under the cursor to a _X_ or X_ type
!  */
      static void
  chg_c_to_X_orX_(void)
  {
***************
*** 498,506 ****
  
  /*
   * Change the char. under the cursor to a _X_ or _X type
! */
      static void
! chg_c_to_X_or_X (void)
  {
      int	tempc;
  
--- 479,487 ----
  
  /*
   * Change the char. under the cursor to a _X_ or _X type
!  */
      static void
! chg_c_to_X_or_X(void)
  {
      int	tempc;
  
***************
*** 529,535 ****
  
  /*
   * Change the character left to the cursor to a _X_ or X_ type
! */
      static void
  chg_l_to_X_orX_(void)
  {
--- 510,516 ----
  
  /*
   * Change the character left to the cursor to a _X_ or X_ type
!  */
      static void
  chg_l_to_X_orX_(void)
  {
***************
*** 597,606 ****
  
  /*
   * Change the character left to the cursor to a X or _X type
! */
! 
      static void
! chg_l_toXor_X (void)
  {
      int	tempc;
  
--- 578,586 ----
  
  /*
   * Change the character left to the cursor to a X or _X type
!  */
      static void
! chg_l_toXor_X(void)
  {
      int	tempc;
  
***************
*** 666,673 ****
  
  /*
   * Change the character right to the cursor to a _X or _X_ type
! */
! 
      static void
  chg_r_to_Xor_X_(void)
  {
--- 646,652 ----
  
  /*
   * Change the character right to the cursor to a _X or _X_ type
!  */
      static void
  chg_r_to_Xor_X_(void)
  {
***************
*** 691,738 ****
  
  /*
   * Map Farsi keyboard when in fkmap mode.
! */
! 
      int
  fkmap(int c)
  {
      int		tempc;
!     static int	revins;
  
      if (IS_SPECIAL(c))
  	return c;
  
!     if (VIM_ISDIGIT(c) || ((c == '.' || c == '+' || c == '-' ||
! 	c == '^' || c == '%' || c == '#' || c == '=')  && revins))
      {
! 	if (!revins)
  	{
! 	    if (curwin->w_cursor.col)
  	    {
! 		if (!p_ri)
! 		    dec_cursor();
  
! 		chg_c_toX_orX ();
! 		chg_l_toXor_X ();
  
! 		if (!p_ri)
! 		    inc_cursor();
  	    }
- 	}
  
! 	arrow_used = TRUE;
! 	(void)stop_arrow();
  
! 	if (!curwin->w_p_rl && revins)
! 	    inc_cursor();
  
! 	++revins;
! 	p_ri=1;
!     }
!     else
!     {
! 	if (revins)
  	{
  	    arrow_used = TRUE;
  	    (void)stop_arrow();
  
--- 670,719 ----
  
  /*
   * Map Farsi keyboard when in fkmap mode.
!  */
      int
  fkmap(int c)
  {
      int		tempc;
!     int		insert_mode = (State & INSERT);
!     static int	revins = 0;
  
      if (IS_SPECIAL(c))
  	return c;
  
!     if (insert_mode)
      {
! 	if (VIM_ISDIGIT(c) || ((c == '.' || c == '+' || c == '-' ||
! 	    c == '^' || c == '%' || c == '#' || c == '=') && revins))
  	{
! 	    /* Numbers are entered left-to-right. */
! 	    if (!revins)
  	    {
! 		if (curwin->w_cursor.col)
! 		{
! 		    if (!p_ri)
! 			dec_cursor();
  
! 		    chg_c_toX_orX ();
! 		    chg_l_toXor_X ();
  
! 		    if (!p_ri)
! 			inc_cursor();
! 		}
  	    }
  
! 	    arrow_used = TRUE;
! 	    (void)stop_arrow();
  
! 	    if (!curwin->w_p_rl && revins)
! 		inc_cursor();
  
! 	    ++revins;
! 	    p_ri = 1;
! 	}
! 	else if (revins)
  	{
+ 	    /* Stop entering number. */
  	    arrow_used = TRUE;
  	    (void)stop_arrow();
  
***************
*** 773,786 ****
      if (!revins)
      {
  	if (curwin->w_p_rl)
! 	    p_ri=0;
  	if (!curwin->w_p_rl)
! 	    p_ri=1;
      }
  
!     if ((c < 0x100) && (isalpha(c) || c == '&' ||   c == '^' ||	c == ';' ||
  			    c == '\''||	c == ',' || c == '[' ||
! 			    c == ']' ||	c == '{' || c == '}'	))
  	chg_r_to_Xor_X_();
  
      tempc = 0;
--- 754,767 ----
      if (!revins)
      {
  	if (curwin->w_p_rl)
! 	    p_ri = 0;
  	if (!curwin->w_p_rl)
! 	    p_ri = 1;
      }
  
!     if ((c < 0x100) && (isalpha(c) || c == '&' || c == '^' ||	c == ';' ||
  			    c == '\''||	c == ',' || c == '[' ||
! 			    c == ']' ||	c == '{' || c == '}'))
  	chg_r_to_Xor_X_();
  
      tempc = 0;
***************
*** 844,856 ****
  	case  NL:
  	case  TAB:
  
! 	    if (p_ri && c == NL && curwin->w_cursor.col)
  	    {
  		/*
  		 * If the char before the cursor is _X_ or X_ do not change
  		 * the one under the cursor with X type.
! 		*/
! 
  		dec_cursor();
  
  		if (F_isalpha(gchar_cursor()))
--- 825,836 ----
  	case  NL:
  	case  TAB:
  
! 	    if (p_ri && c == NL && curwin->w_cursor.col && insert_mode)
  	    {
  		/*
  		 * If the char before the cursor is _X_ or X_ do not change
  		 * the one under the cursor with X type.
! 		 */
  		dec_cursor();
  
  		if (F_isalpha(gchar_cursor()))
***************
*** 920,1134 ****
  		}
  		break;
  	    }
- 	    if (!p_ri)
- 		dec_cursor();
  
! 	    switch ((tempc = gchar_cursor()))
  	    {
! 		case _BE:
! 		case _PE:
! 		case _TE:
! 		case _SE:
! 		case _JIM:
! 		case _CHE:
! 		case _HE_J:
! 		case _XE:
! 		case _SIN:
! 		case _SHIN:
! 		case _SAD:
! 		case _ZAD:
! 		case _FE:
! 		case _GHAF:
! 		case _KAF:
! 		case _KAF_H:
! 		case _GAF:
! 		case _LAM:
! 		case _MIM:
! 		case _NOON:
! 		case _HE:
! 		case _HE_:
! 		case _TA:
! 		case _ZA:
! 			put_curr_and_l_to_X(toF_TyA(tempc));
! 			break;
! 		case _AYN:
! 		case _AYN_:
! 
! 			if (!p_ri)
! 			    if (!curwin->w_cursor.col)
! 			    {
! 				put_curr_and_l_to_X(AYN);
! 				break;
! 			    }
! 
! 			if (p_ri)
! 			    inc_cursor();
! 			else
! 			    dec_cursor();
! 
! 			if (F_is_TyB_TyC_TyD(SRC_EDT, AT_CURSOR))
! 			    tempc = AYN_;
! 			else
! 			    tempc = AYN;
! 
! 			if (p_ri)
! 			    dec_cursor();
! 			else
! 			    inc_cursor();
! 
! 			put_curr_and_l_to_X(tempc);
! 
! 			break;
! 		case _GHAYN:
! 		case _GHAYN_:
! 
! 			if (!p_ri)
! 			    if (!curwin->w_cursor.col)
! 			    {
! 				put_curr_and_l_to_X(GHAYN);
! 				break;
! 			    }
! 
! 			if (p_ri)
! 			    inc_cursor();
! 			else
! 			    dec_cursor();
! 
! 			if (F_is_TyB_TyC_TyD(SRC_EDT, AT_CURSOR))
! 			    tempc = GHAYN_;
! 			else
! 			    tempc = GHAYN;
! 
! 			if (p_ri)
! 			    dec_cursor();
! 			else
! 			    inc_cursor();
! 
! 			put_curr_and_l_to_X(tempc);
! 			break;
! 		case _YE:
! 		case _IE:
! 		case _YEE:
! 			if (!p_ri)
! 			    if (!curwin->w_cursor.col)
! 			    {
! 				put_curr_and_l_to_X((tempc == _YE ? YE :
! 					    (tempc == _IE ? IE : YEE)));
! 				break;
! 			    }
! 
! 			if (p_ri)
! 			    inc_cursor();
! 			else
! 			    dec_cursor();
! 
! 			if (F_is_TyB_TyC_TyD(SRC_EDT, AT_CURSOR))
! 				tempc = (tempc == _YE ? YE_ :
! 				    (tempc == _IE ? IE_ : YEE_));
! 			else
! 				tempc = (tempc == _YE ? YE :
! 				    (tempc == _IE ? IE : YEE));
  
! 			if (p_ri)
! 			    dec_cursor();
! 			else
! 			    inc_cursor();
  
! 			put_curr_and_l_to_X(tempc);
! 			break;
  		}
  
  		if (!p_ri)
  		    inc_cursor();
  
! 		tempc = 0;
  
! 		switch (c)
! 		{
! 		    case '0':	return FARSI_0;
! 		    case '1':	return FARSI_1;
! 		    case '2':	return FARSI_2;
! 		    case '3':	return FARSI_3;
! 		    case '4':	return FARSI_4;
! 		    case '5':	return FARSI_5;
! 		    case '6':	return FARSI_6;
! 		    case '7':	return FARSI_7;
! 		    case '8':	return FARSI_8;
! 		    case '9':	return FARSI_9;
! 		    case 'B':	return F_PSP;
! 		    case 'E':	return JAZR_N;
! 		    case 'F':	return ALEF_D_H;
! 		    case 'H':	return ALEF_A;
! 		    case 'I':	return TASH;
! 		    case 'K':	return F_LQUOT;
! 		    case 'L':	return F_RQUOT;
! 		    case 'M':	return HAMZE;
! 		    case 'O':	return '[';
! 		    case 'P':	return ']';
! 		    case 'Q':	return OO;
! 		    case 'R':	return MAD_N;
! 		    case 'T':	return OW;
! 		    case 'U':	return MAD;
! 		    case 'W':	return OW_OW;
! 		    case 'Y':	return JAZR;
! 		    case '`':	return F_PCN;
! 		    case '!':	return F_EXCL;
! 		    case '@':	return F_COMMA;
! 		    case '#':	return F_DIVIDE;
! 		    case '$':	return F_CURRENCY;
! 		    case '%':	return F_PERCENT;
! 		    case '^':	return F_MUL;
! 		    case '&':	return F_BCOMMA;
! 		    case '*':	return F_STAR;
! 		    case '(':	return F_LPARENT;
! 		    case ')':	return F_RPARENT;
! 		    case '-':	return F_MINUS;
! 		    case '_':	return F_UNDERLINE;
! 		    case '=':	return F_EQUALS;
! 		    case '+':	return F_PLUS;
! 		    case '\\':	return F_BSLASH;
! 		    case '|':	return F_PIPE;
! 		    case ':':	return F_DCOLON;
! 		    case '"':	return F_SEMICOLON;
! 		    case '.':	return F_PERIOD;
! 		    case '/':	return F_SLASH;
! 		    case '<':	return F_LESS;
! 		    case '>':	return F_GREATER;
! 		    case '?':	return F_QUESTION;
! 		    case ' ':	return F_BLANK;
! 		}
! 		break;
  
  	case 'a':
! 		tempc = _SHIN;
! 		break;
  	case 'A':
! 		tempc = WAW_H;
! 		break;
  	case 'b':
! 		tempc = ZAL;
! 		break;
  	case 'c':
! 		tempc = ZE;
! 		break;
  	case 'C':
! 		tempc = JE;
! 		break;
  	case 'd':
! 		tempc = _YE;
! 		break;
  	case 'D':
! 		tempc = _YEE;
! 		break;
  	case 'e':
! 		tempc = _SE;
! 		break;
  	case 'f':
! 		tempc = _BE;
! 		break;
  	case 'g':
! 		tempc = _LAM;
! 		break;
  	case 'G':
  	    if (!curwin->w_cursor.col  &&  STRLEN(ml_get_curline()))
  	    {
--- 900,1118 ----
  		}
  		break;
  	    }
  
! 	    if (insert_mode)
  	    {
! 		if (!p_ri)
! 		    dec_cursor();
  
! 		switch ((tempc = gchar_cursor()))
! 		{
! 		    case _BE:
! 		    case _PE:
! 		    case _TE:
! 		    case _SE:
! 		    case _JIM:
! 		    case _CHE:
! 		    case _HE_J:
! 		    case _XE:
! 		    case _SIN:
! 		    case _SHIN:
! 		    case _SAD:
! 		    case _ZAD:
! 		    case _FE:
! 		    case _GHAF:
! 		    case _KAF:
! 		    case _KAF_H:
! 		    case _GAF:
! 		    case _LAM:
! 		    case _MIM:
! 		    case _NOON:
! 		    case _HE:
! 		    case _HE_:
! 		    case _TA:
! 		    case _ZA:
! 			    put_curr_and_l_to_X(toF_TyA(tempc));
! 			    break;
! 		    case _AYN:
! 		    case _AYN_:
! 
! 			    if (!p_ri)
! 				if (!curwin->w_cursor.col)
! 				{
! 				    put_curr_and_l_to_X(AYN);
! 				    break;
! 				}
! 
! 			    if (p_ri)
! 				inc_cursor();
! 			    else
! 				dec_cursor();
! 
! 			    if (F_is_TyB_TyC_TyD(SRC_EDT, AT_CURSOR))
! 				tempc = AYN_;
! 			    else
! 				tempc = AYN;
! 
! 			    if (p_ri)
! 				dec_cursor();
! 			    else
! 				inc_cursor();
! 
! 			    put_curr_and_l_to_X(tempc);
! 
! 			    break;
! 		    case _GHAYN:
! 		    case _GHAYN_:
! 
! 			    if (!p_ri)
! 				if (!curwin->w_cursor.col)
! 				{
! 				    put_curr_and_l_to_X(GHAYN);
! 				    break;
! 				}
! 
! 			    if (p_ri)
! 				inc_cursor();
! 			    else
! 				dec_cursor();
! 
! 			    if (F_is_TyB_TyC_TyD(SRC_EDT, AT_CURSOR))
! 				tempc = GHAYN_;
! 			    else
! 				tempc = GHAYN;
! 
! 			    if (p_ri)
! 				dec_cursor();
! 			    else
! 				inc_cursor();
! 
! 			    put_curr_and_l_to_X(tempc);
! 			    break;
! 		    case _YE:
! 		    case _IE:
! 		    case _YEE:
! 			    if (!p_ri)
! 				if (!curwin->w_cursor.col)
! 				{
! 				    put_curr_and_l_to_X((tempc == _YE ? YE :
! 						(tempc == _IE ? IE : YEE)));
! 				    break;
! 				}
! 
! 			    if (p_ri)
! 				inc_cursor();
! 			    else
! 				dec_cursor();
! 
! 			    if (F_is_TyB_TyC_TyD(SRC_EDT, AT_CURSOR))
! 				    tempc = (tempc == _YE ? YE_ :
! 					(tempc == _IE ? IE_ : YEE_));
! 			    else
! 				    tempc = (tempc == _YE ? YE :
! 					(tempc == _IE ? IE : YEE));
! 
! 			    if (p_ri)
! 				dec_cursor();
! 			    else
! 				inc_cursor();
  
! 			    put_curr_and_l_to_X(tempc);
! 			    break;
  		}
  
  		if (!p_ri)
  		    inc_cursor();
+ 	    }
  
! 	    tempc = 0;
  
! 	    switch (c)
! 	    {
! 		case '0':	return FARSI_0;
! 		case '1':	return FARSI_1;
! 		case '2':	return FARSI_2;
! 		case '3':	return FARSI_3;
! 		case '4':	return FARSI_4;
! 		case '5':	return FARSI_5;
! 		case '6':	return FARSI_6;
! 		case '7':	return FARSI_7;
! 		case '8':	return FARSI_8;
! 		case '9':	return FARSI_9;
! 		case 'B':	return F_PSP;
! 		case 'E':	return JAZR_N;
! 		case 'F':	return ALEF_D_H;
! 		case 'H':	return ALEF_A;
! 		case 'I':	return TASH;
! 		case 'K':	return F_LQUOT;
! 		case 'L':	return F_RQUOT;
! 		case 'M':	return HAMZE;
! 		case 'O':	return '[';
! 		case 'P':	return ']';
! 		case 'Q':	return OO;
! 		case 'R':	return MAD_N;
! 		case 'T':	return OW;
! 		case 'U':	return MAD;
! 		case 'W':	return OW_OW;
! 		case 'Y':	return JAZR;
! 		case '`':	return F_PCN;
! 		case '!':	return F_EXCL;
! 		case '@':	return F_COMMA;
! 		case '#':	return F_DIVIDE;
! 		case '$':	return F_CURRENCY;
! 		case '%':	return F_PERCENT;
! 		case '^':	return F_MUL;
! 		case '&':	return F_BCOMMA;
! 		case '*':	return F_STAR;
! 		case '(':	return F_LPARENT;
! 		case ')':	return F_RPARENT;
! 		case '-':	return F_MINUS;
! 		case '_':	return F_UNDERLINE;
! 		case '=':	return F_EQUALS;
! 		case '+':	return F_PLUS;
! 		case '\\':	return F_BSLASH;
! 		case '|':	return F_PIPE;
! 		case ':':	return F_DCOLON;
! 		case '"':	return F_SEMICOLON;
! 		case '.':	return F_PERIOD;
! 		case '/':	return F_SLASH;
! 		case '<':	return F_LESS;
! 		case '>':	return F_GREATER;
! 		case '?':	return F_QUESTION;
! 		case ' ':	return F_BLANK;
! 	    }
! 	    break;
  
  	case 'a':
! 	    tempc = _SHIN;
! 	    break;
  	case 'A':
! 	    tempc = WAW_H;
! 	    break;
  	case 'b':
! 	    tempc = ZAL;
! 	    break;
  	case 'c':
! 	    tempc = ZE;
! 	    break;
  	case 'C':
! 	    tempc = JE;
! 	    break;
  	case 'd':
! 	    tempc = _YE;
! 	    break;
  	case 'D':
! 	    tempc = _YEE;
! 	    break;
  	case 'e':
! 	    tempc = _SE;
! 	    break;
  	case 'f':
! 	    tempc = _BE;
! 	    break;
  	case 'g':
! 	    tempc = _LAM;
! 	    break;
  	case 'G':
  	    if (!curwin->w_cursor.col  &&  STRLEN(ml_get_curline()))
  	    {
***************
*** 1230,1236 ****
  		inc_cursor();
  	    break;
  	case 'j':
! 		tempc = _TE;
  	    break;
  	case 'J':
  	    if (!curwin->w_cursor.col  &&  STRLEN(ml_get_curline()))
--- 1214,1220 ----
  		inc_cursor();
  	    break;
  	case 'j':
! 	    tempc = _TE;
  	    break;
  	case 'J':
  	    if (!curwin->w_cursor.col  &&  STRLEN(ml_get_curline()))
***************
*** 1260,1332 ****
  
  	    return tempc;
  	case 'k':
! 		tempc = _NOON;
  	    break;
  	case 'l':
! 		tempc = _MIM;
  	    break;
  	case 'm':
! 		tempc = _PE;
  	    break;
  	case 'n':
  	case 'N':
! 		tempc = DAL;
  	    break;
  	case 'o':
! 		tempc = _XE;
  	    break;
  	case 'p':
! 		tempc = _HE_J;
  	    break;
  	case 'q':
! 		tempc = _ZAD;
  	    break;
  	case 'r':
! 		tempc = _GHAF;
  	    break;
  	case 's':
! 		tempc = _SIN;
  	    break;
  	case 'S':
! 		tempc = _IE;
  	    break;
  	case 't':
! 		tempc = _FE;
  	    break;
  	case 'u':
! 		if (!curwin->w_cursor.col  &&  STRLEN(ml_get_curline()))
! 		{
! 		    if (!p_ri && !F_is_TyE(tempc))
! 			chg_c_to_X_orX_ ();
! 		    if (p_ri)
! 			chg_c_to_X_or_X ();
  
! 		}
  
! 		if (!p_ri && !curwin->w_cursor.col)
! 		    return _AYN;
  
! 		if (!p_ri)
! 		    dec_cursor();
  
! 		if (F_is_TyB_TyC_TyD(SRC_EDT, AT_CURSOR))
! 		    tempc = _AYN_;
! 		else
! 		    tempc = _AYN;
  
! 		if (!p_ri)
! 		    inc_cursor();
  	    break;
  	case 'v':
  	case 'V':
! 		tempc = RE;
  	    break;
  	case 'w':
! 		tempc = _SAD;
  	    break;
  	case 'x':
  	case 'X':
! 		tempc = _TA;
  	    break;
  	case 'y':
  	    if (!curwin->w_cursor.col  &&  STRLEN(ml_get_curline()))
--- 1244,1316 ----
  
  	    return tempc;
  	case 'k':
! 	    tempc = _NOON;
  	    break;
  	case 'l':
! 	    tempc = _MIM;
  	    break;
  	case 'm':
! 	    tempc = _PE;
  	    break;
  	case 'n':
  	case 'N':
! 	    tempc = DAL;
  	    break;
  	case 'o':
! 	    tempc = _XE;
  	    break;
  	case 'p':
! 	    tempc = _HE_J;
  	    break;
  	case 'q':
! 	    tempc = _ZAD;
  	    break;
  	case 'r':
! 	    tempc = _GHAF;
  	    break;
  	case 's':
! 	    tempc = _SIN;
  	    break;
  	case 'S':
! 	    tempc = _IE;
  	    break;
  	case 't':
! 	    tempc = _FE;
  	    break;
  	case 'u':
! 	    if (!curwin->w_cursor.col  &&  STRLEN(ml_get_curline()))
! 	    {
! 		if (!p_ri && !F_is_TyE(tempc))
! 		    chg_c_to_X_orX_ ();
! 		if (p_ri)
! 		    chg_c_to_X_or_X ();
  
! 	    }
  
! 	    if (!p_ri && !curwin->w_cursor.col)
! 		return _AYN;
  
! 	    if (!p_ri)
! 		dec_cursor();
  
! 	    if (F_is_TyB_TyC_TyD(SRC_EDT, AT_CURSOR))
! 		tempc = _AYN_;
! 	    else
! 		tempc = _AYN;
  
! 	    if (!p_ri)
! 		inc_cursor();
  	    break;
  	case 'v':
  	case 'V':
! 	    tempc = RE;
  	    break;
  	case 'w':
! 	    tempc = _SAD;
  	    break;
  	case 'x':
  	case 'X':
! 	    tempc = _TA;
  	    break;
  	case 'y':
  	    if (!curwin->w_cursor.col  &&  STRLEN(ml_get_curline()))
***************
*** 1354,1389 ****
  
  	    break;
  	case 'z':
! 		tempc = _ZA;
  	    break;
  	case 'Z':
! 		tempc = _KAF_H;
  	    break;
  	case ';':
! 		tempc = _KAF;
  	    break;
  	case '\'':
! 		tempc = _GAF;
  	    break;
  	case ',':
! 		tempc = WAW;
  	    break;
  	case '[':
! 		tempc = _JIM;
  	    break;
  	case ']':
! 		tempc = _CHE;
  	    break;
      }
  
!     if ((F_isalpha(tempc) || F_isdigit(tempc)))
      {
! 	if (!curwin->w_cursor.col  &&  STRLEN(ml_get_curline()))
  	{
  	    if (!p_ri && !F_is_TyE(tempc))
! 		chg_c_to_X_orX_ ();
  	    if (p_ri)
! 		chg_c_to_X_or_X ();
  	}
  
  	if (curwin->w_cursor.col)
--- 1338,1373 ----
  
  	    break;
  	case 'z':
! 	    tempc = _ZA;
  	    break;
  	case 'Z':
! 	    tempc = _KAF_H;
  	    break;
  	case ';':
! 	    tempc = _KAF;
  	    break;
  	case '\'':
! 	    tempc = _GAF;
  	    break;
  	case ',':
! 	    tempc = WAW;
  	    break;
  	case '[':
! 	    tempc = _JIM;
  	    break;
  	case ']':
! 	    tempc = _CHE;
  	    break;
      }
  
!     if (F_isalpha(tempc) || F_isdigit(tempc))
      {
! 	if (!curwin->w_cursor.col && STRLEN(ml_get_curline()))
  	{
  	    if (!p_ri && !F_is_TyE(tempc))
! 		chg_c_to_X_orX_();
  	    if (p_ri)
! 		chg_c_to_X_or_X();
  	}
  
  	if (curwin->w_cursor.col)
***************
*** 1392,1400 ****
  		dec_cursor();
  
  	    if (F_is_TyE(tempc))
! 		chg_l_toXor_X ();
  	    else
! 		chg_l_to_X_orX_ ();
  
  	    if (!p_ri)
  		inc_cursor();
--- 1376,1384 ----
  		dec_cursor();
  
  	    if (F_is_TyE(tempc))
! 		chg_l_toXor_X();
  	    else
! 		chg_l_to_X_orX_();
  
  	    if (!p_ri)
  		inc_cursor();
***************
*** 1407,1413 ****
  
  /*
   * Convert a none leading Farsi char into a leading type.
! */
      static int
  toF_leading(int c)
  {
--- 1391,1397 ----
  
  /*
   * Convert a none leading Farsi char into a leading type.
!  */
      static int
  toF_leading(int c)
  {
***************
*** 1461,1467 ****
  
  /*
   * Convert a given Farsi char into right joining type.
! */
      static int
  toF_Rjoin(int c)
  {
--- 1445,1451 ----
  
  /*
   * Convert a given Farsi char into right joining type.
!  */
      static int
  toF_Rjoin(int c)
  {
***************
*** 1517,1523 ****
  
  /*
   * Can a given Farsi character join via its left edj.
! */
      static int
  canF_Ljoin(int c)
  {
--- 1501,1507 ----
  
  /*
   * Can a given Farsi character join via its left edj.
!  */
      static int
  canF_Ljoin(int c)
  {
***************
*** 1591,1597 ****
  
  /*
   * Can a given Farsi character join via its right edj.
! */
      static int
  canF_Rjoin(int c)
  {
--- 1575,1581 ----
  
  /*
   * Can a given Farsi character join via its right edj.
!  */
      static int
  canF_Rjoin(int c)
  {
***************
*** 1619,1625 ****
  
  /*
   * is a given Farsi character a terminating type.
! */
      static int
  F_isterm(int c)
  {
--- 1603,1609 ----
  
  /*
   * is a given Farsi character a terminating type.
!  */
      static int
  F_isterm(int c)
  {
***************
*** 1646,1652 ****
  
  /*
   * Convert the given Farsi character into a ending type .
! */
      static int
  toF_ending(int c)
  {
--- 1630,1636 ----
  
  /*
   * Convert the given Farsi character into a ending type .
!  */
      static int
  toF_ending(int c)
  {
***************
*** 1691,1697 ****
  
  /*
   * Convert the Farsi 3342 standard into Farsi VIM.
! */
      static void
  conv_to_pvim(void)
  {
--- 1675,1681 ----
  
  /*
   * Convert the Farsi 3342 standard into Farsi VIM.
!  */
      static void
  conv_to_pvim(void)
  {
*** ../vim-8.0.0261/src/testdir/test_farsi.vim	2016-07-02 18:05:28.000000000 +0200
--- src/testdir/test_farsi.vim	2017-01-29 17:54:29.738586021 +0100
***************
*** 1,4 ****
--- 1,5 ----
  " Simplistic testing of Farsi mode.
+ " Note: must be edited with latin1 encoding.
  
  if !has('farsi')
    finish
***************
*** 82,84 ****
--- 83,103 ----
    set noaltkeymap
    bwipe!
  endfunc
+ 
+ func Test_input_farsi()
+   new
+   setlocal rightleft fkmap
+   " numbers switch input direction
+   call feedkeys("aabc0123456789.+-^%#=xyz\<Esc>", 'tx')
+   call assert_equal("\x8c\x93", getline('.'))
+ 
+   " all non-number special chars
+   call feedkeys("aB E F H I K L M O P Q R T U W Y ` !  @ # $ % ^ & * () - _ = + \\ | : \" .  / < > ? \<Esc>", 'tx')
+   call assert_equal("\x8c\x93[]", getline('.'))
+ 
+   " all letter chars
+   call feedkeys("aa A b c C d D e f g G h i j J k l m n N o p q r s S t u v V w x X y z Z ; \ , [ ] \<Esc>", 'tx')
+   call assert_equal("\x8c\x93[]", getline('.'))
+ 
+   bwipe!
+ endfunc
*** ../vim-8.0.0261/src/version.c	2017-01-29 15:45:07.161783704 +0100
--- src/version.c	2017-01-29 17:57:58.385225347 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     262,
  /**/

-- 
Proofread carefully to see if you any words out.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0263
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0263
Problem:    Farsi support is not tested enough.
Solution:   Add more tests for Farsi.  Clean up the code.
Files:      src/farsi.c, src/testdir/test_farsi.vim


*** ../vim-8.0.0262/src/farsi.c	2017-01-29 17:59:07.872772178 +0100
--- src/farsi.c	2017-01-29 18:18:48.621069472 +0100
***************
*** 1920,1975 ****
  	case  NL:
  	case  TAB:
  
! 	       switch ((tempc = cmd_gchar(AT_CURSOR)))
! 	       {
! 	    case _BE:
! 	    case _PE:
! 	    case _TE:
! 	    case _SE:
! 	    case _JIM:
! 	    case _CHE:
! 	    case _HE_J:
! 	    case _XE:
! 	    case _SIN:
! 	    case _SHIN:
! 	    case _SAD:
! 	    case _ZAD:
! 	    case _AYN:
! 	    case _GHAYN:
! 	    case _FE:
! 	    case _GHAF:
! 	    case _KAF:
! 	    case _GAF:
! 	    case _LAM:
! 	    case _MIM:
! 	    case _NOON:
! 	    case _HE:
! 	    case _HE_:
! 			cmd_pchar(toF_TyA(tempc), AT_CURSOR);
! 		break;
! 	    case _AYN_:
! 			cmd_pchar(AYN_, AT_CURSOR);
! 		break;
! 	    case _GHAYN_:
! 			cmd_pchar(GHAYN_, AT_CURSOR);
! 		break;
! 	    case _IE:
! 		if (F_is_TyB_TyC_TyD(SRC_CMD, AT_CURSOR+1))
! 			    cmd_pchar(IE_, AT_CURSOR);
! 		else
! 			    cmd_pchar(IE, AT_CURSOR);
! 		break;
! 	    case _YEE:
! 		if (F_is_TyB_TyC_TyD(SRC_CMD, AT_CURSOR+1))
! 			    cmd_pchar(YEE_, AT_CURSOR);
! 			else
! 			    cmd_pchar(YEE, AT_CURSOR);
! 		break;
! 	    case _YE:
! 		if (F_is_TyB_TyC_TyD(SRC_CMD, AT_CURSOR+1))
! 			    cmd_pchar(YE_, AT_CURSOR);
! 			else
! 			    cmd_pchar(YE, AT_CURSOR);
  	    }
  
  	    switch (c)
--- 1920,1975 ----
  	case  NL:
  	case  TAB:
  
! 	    switch ((tempc = cmd_gchar(AT_CURSOR)))
! 	    {
! 		case _BE:
! 		case _PE:
! 		case _TE:
! 		case _SE:
! 		case _JIM:
! 		case _CHE:
! 		case _HE_J:
! 		case _XE:
! 		case _SIN:
! 		case _SHIN:
! 		case _SAD:
! 		case _ZAD:
! 		case _AYN:
! 		case _GHAYN:
! 		case _FE:
! 		case _GHAF:
! 		case _KAF:
! 		case _GAF:
! 		case _LAM:
! 		case _MIM:
! 		case _NOON:
! 		case _HE:
! 		case _HE_:
! 		    cmd_pchar(toF_TyA(tempc), AT_CURSOR);
! 		    break;
! 		case _AYN_:
! 		    cmd_pchar(AYN_, AT_CURSOR);
! 		    break;
! 		case _GHAYN_:
! 		    cmd_pchar(GHAYN_, AT_CURSOR);
! 		    break;
! 		case _IE:
! 		    if (F_is_TyB_TyC_TyD(SRC_CMD, AT_CURSOR+1))
! 			cmd_pchar(IE_, AT_CURSOR);
! 		    else
! 			cmd_pchar(IE, AT_CURSOR);
! 		    break;
! 		case _YEE:
! 		    if (F_is_TyB_TyC_TyD(SRC_CMD, AT_CURSOR+1))
! 			cmd_pchar(YEE_, AT_CURSOR);
! 		    else
! 			cmd_pchar(YEE, AT_CURSOR);
! 		    break;
! 		case _YE:
! 		    if (F_is_TyB_TyC_TyD(SRC_CMD, AT_CURSOR+1))
! 			cmd_pchar(YE_, AT_CURSOR);
! 		    else
! 			cmd_pchar(YE, AT_CURSOR);
  	    }
  
  	    switch (c)
*** ../vim-8.0.0262/src/testdir/test_farsi.vim	2017-01-29 17:59:07.876772153 +0100
--- src/testdir/test_farsi.vim	2017-01-29 19:52:38.848115773 +0100
***************
*** 91,103 ****
    call feedkeys("aabc0123456789.+-^%#=xyz\<Esc>", 'tx')
    call assert_equal("\x8c\x93", getline('.'))
  
!   " all non-number special chars
!   call feedkeys("aB E F H I K L M O P Q R T U W Y ` !  @ # $ % ^ & * () - _ = + \\ | : \" .  / < > ? \<Esc>", 'tx')
!   call assert_equal("\x8c\x93[]", getline('.'))
! 
!   " all letter chars
!   call feedkeys("aa A b c C d D e f g G h i j J k l m n N o p q r s S t u v V w x X y z Z ; \ , [ ] \<Esc>", 'tx')
!   call assert_equal("\x8c\x93[]", getline('.'))
  
    bwipe!
  endfunc
--- 91,133 ----
    call feedkeys("aabc0123456789.+-^%#=xyz\<Esc>", 'tx')
    call assert_equal("\x8c\x93", getline('.'))
  
!   " all non-number special chars with spaces
!   call feedkeys("oB E F H I K L M O P Q R T U W Y ` !  @ # $ % ^ & * () - _ = + \\ | : \" .  / < > ? \<Esc>", 'tx')
!   call assert_equal("[]", getline('.'))
! 
!   " all non-number special chars without spaces
!   call feedkeys("oBEFHIKLMOPQRTUWY`!@#$%^&*()-_=+\\|:\"./<>?\<Esc>",'tx')
!   call assert_equal("[]", getline('.'))
! 
!   " all letter chars with spaces
!   call feedkeys("oa A b c C d D e f g G h i j J k l m n N o p q r s S t u v V w x X y z Z ; \ , [ ] \<Esc>", 'tx')
!   call assert_equal("", getline('.'))
! 
!   " all letter chars without spaces
!   call feedkeys("oaAbcCdDefgGhijJklmnNopqrsStuvVwxXyzZ;\,[]\<Esc>", 'tx')
!   call assert_equal("\x8c\x9f\x86\x83\x9d\x85\x80\x9c\x9b\x84\x8a\x89\x8e\x96\x8b\x95\x90\x8d\x93\x97\x87\x88", getline('.'))
  
    bwipe!
  endfunc
+ 
+ func Test_command_line_farsi()
+   set allowrevins altkeymap
+ 
+   " letter characters with spaces
+   call feedkeys(":\"\<C-_>a A b c C d D e f g G h i j J k l m n N o p q r s S t u v V w x X y z Z ; \\ , [ ]\<CR>", 'tx')
+   call assert_equal("\"\x88", getreg(':'))
+  
+   " letter characters without spaces
+   call feedkeys(":\"\<C-_>aAbcCdDefgGhijJklmnNopqrsStuvVwxXyzZ;\\,[]\<CR>", 'tx')
+   call assert_equal("\"\x88\x87\x93\x8d\x90\x95\x8b\x96\x8e\x89\x8a\x84\x9b\x9c\x80\x85\x9d\x83\x86\x9f\x8c", getreg(':'))
+  
+   " other characters with spaces
+   call feedkeys(":\"\<C-_>0 1 2 3 4 5 6 7 8 9 ` .  !  \" $ % ^ & / () = \\ ?  + - _ * : # ~ @ < > { } | B E F H I K L M O P Q R T U W Y\<CR>", 'tx')
+   call assert_equal("\"][}{~", getreg(':'))
+ 
+   " other characters without spaces
+   call feedkeys(":\"\<C-_>0123456789`.!\"$%^&/()=\\?+-_*:#~@<>{}|BEFHIKLMOPQRTUWY\<CR>", 'tx')
+   call assert_equal("\"][}{~", getreg(':'))
+ 
+   set noallowrevins noaltkeymap
+ endfunc
*** ../vim-8.0.0262/src/version.c	2017-01-29 17:59:07.876772153 +0100
--- src/version.c	2017-01-29 19:54:02.971552805 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     263,
  /**/

-- 
There can't be a crisis today, my schedule is already full.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0264
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0264
Problem:    Memory error reported by ubsan, probably for using the string
            returned by execute().
Solution:   NUL terminate the result of execute().
Files:      src/evalfunc.c


*** ../vim-8.0.0263/src/evalfunc.c	2017-01-28 18:31:36.690078200 +0100
--- src/evalfunc.c	2017-01-29 20:30:39.512880047 +0100
***************
*** 2819,2825 ****
  	--list->lv_refcount;
      }
  
!     rettv->vval.v_string = redir_execute_ga.ga_data;
      msg_silent = save_msg_silent;
      emsg_silent = save_emsg_silent;
      emsg_noredir = save_emsg_noredir;
--- 2819,2835 ----
  	--list->lv_refcount;
      }
  
!     /* Need to append a NUL to the result. */
!     if (ga_grow(&redir_execute_ga, 1) == OK)
!     {
! 	((char *)redir_execute_ga.ga_data)[redir_execute_ga.ga_len] = NUL;
! 	rettv->vval.v_string = redir_execute_ga.ga_data;
!     }
!     else
!     {
! 	ga_clear(&redir_execute_ga);
! 	rettv->vval.v_string = NULL;
!     }
      msg_silent = save_msg_silent;
      emsg_silent = save_emsg_silent;
      emsg_noredir = save_emsg_noredir;
*** ../vim-8.0.0263/src/version.c	2017-01-29 19:59:35.961322877 +0100
--- src/version.c	2017-01-29 20:29:47.989224106 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     264,
  /**/

-- 
Did you ever stop to think...  and forget to start again?
                                  -- Steven Wright

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0265
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0265
Problem:    May get ml_get error when :pydo deletes lines or switches to
            another buffer. (Nikolai Pavlov, issue #1421)
Solution:   Check the buffer and line every time.
Files:      src/if_py_both.h, src/testdir/test_python2.vim,
            src/testdir/test_python3.vim, src/Makefile,
            src/testdir/Make_all.mak


*** ../vim-8.0.0264/src/if_py_both.h	2016-08-26 16:32:10.000000000 +0200
--- src/if_py_both.h	2017-01-29 21:23:56.687392654 +0100
***************
*** 5619,5624 ****
--- 5619,5625 ----
      int		status;
      PyObject	*pyfunc, *pymain;
      PyObject	*run_ret;
+     buf_T	*was_curbuf = curbuf;
  
      if (u_save((linenr_T)RangeStart - 1, (linenr_T)RangeEnd + 1) != OK)
      {
***************
*** 5671,5677 ****
  #ifdef PY_CAN_RECURSE
  	*pygilstate = PyGILState_Ensure();
  #endif
! 	if (!(line = GetBufferLine(curbuf, lnum)))
  	    goto err;
  	if (!(linenr = PyInt_FromLong((long) lnum)))
  	{
--- 5672,5680 ----
  #ifdef PY_CAN_RECURSE
  	*pygilstate = PyGILState_Ensure();
  #endif
! 	/* Check the line number, the command my have deleted lines. */
! 	if (lnum > curbuf->b_ml.ml_line_count
! 		|| !(line = GetBufferLine(curbuf, lnum)))
  	    goto err;
  	if (!(linenr = PyInt_FromLong((long) lnum)))
  	{
***************
*** 5684,5692 ****
--- 5687,5705 ----
  	if (!ret)
  	    goto err;
  
+ 	/* Check that the command didn't switch to another buffer. */
+ 	if (curbuf != was_curbuf)
+ 	{
+ 	    Py_XDECREF(ret);
+ 	    goto err;
+ 	}
+ 
  	if (ret != Py_None)
  	    if (SetBufferLine(curbuf, lnum, ret, NULL) == FAIL)
+ 	    {
+ 		Py_XDECREF(ret);
  		goto err;
+ 	    }
  
  	Py_XDECREF(ret);
  	PythonIO_Flush();
*** ../vim-8.0.0264/src/testdir/test_python2.vim	2017-01-29 21:30:06.492908600 +0100
--- src/testdir/test_python2.vim	2017-01-29 21:20:44.248685873 +0100
***************
*** 0 ****
--- 1,24 ----
+ " Test for python 2 commands.
+ " TODO: move tests from test87.in here.
+ 
+ if !has('python')
+   finish
+ endif
+ 
+ func Test_pydo()
+   " Check deleting lines does not trigger ml_get error.
+   py import vim
+   new
+   call setline(1, ['one', 'two', 'three'])
+   pydo vim.command("%d_")
+   bwipe!
+ 
+   " Check switching to another buffer does not trigger ml_get error.
+   new
+   let wincount = winnr('$')
+   call setline(1, ['one', 'two', 'three'])
+   pydo vim.command("new")
+   call assert_equal(wincount + 1, winnr('$'))
+   bwipe!
+   bwipe!
+ endfunc
*** ../vim-8.0.0264/src/testdir/test_python3.vim	2017-01-29 21:30:06.500908546 +0100
--- src/testdir/test_python3.vim	2017-01-29 21:26:04.830531733 +0100
***************
*** 0 ****
--- 1,24 ----
+ " Test for python 2 commands.
+ " TODO: move tests from test88.in here.
+ 
+ if !has('python3')
+   finish
+ endif
+ 
+ func Test_py3do()
+   " Check deleting lines does not trigger an ml_get error.
+   py3 import vim
+   new
+   call setline(1, ['one', 'two', 'three'])
+   py3do vim.command("%d_")
+   bwipe!
+ 
+   " Check switching to another buffer does not trigger an ml_get error.
+   new
+   let wincount = winnr('$')
+   call setline(1, ['one', 'two', 'three'])
+   py3do vim.command("new")
+   call assert_equal(wincount + 1, winnr('$'))
+   bwipe!
+   bwipe!
+ endfunc
*** ../vim-8.0.0264/src/Makefile	2017-01-28 16:39:15.876735290 +0100
--- src/Makefile	2017-01-29 21:22:06.308134370 +0100
***************
*** 2168,2173 ****
--- 2168,2175 ----
  	test_popup \
  	test_profile \
  	test_put \
+ 	test_python2 \
+ 	test_python3 \
  	test_pyx2 \
  	test_pyx3 \
  	test_quickfix \
*** ../vim-8.0.0264/src/testdir/Make_all.mak	2017-01-28 15:58:45.352197224 +0100
--- src/testdir/Make_all.mak	2017-01-29 21:25:27.866780054 +0100
***************
*** 176,181 ****
--- 176,183 ----
  	    test_packadd.res \
  	    test_perl.res \
  	    test_profile.res \
+ 	    test_python2.res \
+ 	    test_python3.res \
  	    test_pyx2.res \
  	    test_pyx3.res \
  	    test_quickfix.res \
*** ../vim-8.0.0264/src/version.c	2017-01-29 20:31:17.872621591 +0100
--- src/version.c	2017-01-29 21:30:15.168850338 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     265,
  /**/

-- 
It's not hard to meet expenses, they're everywhere.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0266
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0266
Problem:    Compiler warning for using uninitialized variable.
Solution:   Set tab_number also when there is an error.
Files:      src/ex_docmd.c


*** ../vim-8.0.0265/src/ex_docmd.c	2017-01-29 15:18:04.896478906 +0100
--- src/ex_docmd.c	2017-01-29 21:40:06.796879123 +0100
***************
*** 7533,7539 ****
--- 7533,7542 ----
      else if (eap->addr_count > 0)
      {
  	if (unaccept_arg0 && eap->line2 == 0)
+ 	{
  	    eap->errmsg = e_invrange;
+ 	    tab_number = 0;
+ 	}
  	else
  	{
  	    tab_number = eap->line2;
*** ../vim-8.0.0265/src/version.c	2017-01-29 21:30:48.332627641 +0100
--- src/version.c	2017-01-29 21:41:16.176415658 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     266,
  /**/

-- 
Life is a gift, living is an art.		(Bram Moolenaar)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0267
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0267
Problem:    A channel test sometimes fails on Mac.
Solution:   Add the test to the list of flaky tests.
Files:      src/testdir/runtest.vim


*** ../vim-8.0.0266/src/testdir/runtest.vim	2016-11-17 17:56:10.103449001 +0100
--- src/testdir/runtest.vim	2017-01-29 21:47:50.801779575 +0100
***************
*** 156,161 ****
--- 156,162 ----
        \ 'Test_reltime()',
        \ 'Test_nb_basic()',
        \ 'Test_communicate()',
+       \ 'Test_close_and_exit_cb()',
        \ 'Test_pipe_through_sort_all()',
        \ 'Test_pipe_through_sort_some()'
        \ ]
*** ../vim-8.0.0266/src/version.c	2017-01-29 21:42:16.072015550 +0100
--- src/version.c	2017-01-29 21:49:09.673252729 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     267,
  /**/

-- 
Q: What do you call a fish without an eye?
A: fsh!
Q: What do you call a deer with no eyes?
A: no eye deer.
Q: What do you call a deer with no eyes and no legs?
A: still no eye deer.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0268
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0268
Problem:    May get ml_get error when :luado deletes lines or switches to
            another buffer. (Nikolai Pavlov, issue #1421)
Solution:   Check the buffer and line every time.
Files:      src/if_lua.c, src/testdir/test_lua.vim, src/Makefile,
            src/testdir/Make_all.mak


*** ../vim-8.0.0267/src/if_lua.c	2016-08-28 18:08:52.000000000 +0200
--- src/if_lua.c	2017-01-29 22:43:46.955461526 +0100
***************
*** 1716,1721 ****
--- 1716,1723 ----
      const char *s = (const char *) eap->arg;
      luaL_Buffer b;
      size_t len;
+     buf_T *was_curbuf = curbuf;
+ 
      if (lua_init() == FAIL) return;
      if (u_save(eap->line1 - 1, eap->line2 + 1) == FAIL)
      {
***************
*** 1739,1744 ****
--- 1741,1750 ----
      lua_replace(L, -2); /* function -> body */
      for (l = eap->line1; l <= eap->line2; l++)
      {
+ 	/* Check the line number, the command my have deleted lines. */
+ 	if (l > curbuf->b_ml.ml_line_count)
+ 	    break;
+ 
  	lua_pushvalue(L, -1); /* function */
  	luaV_pushline(L, curbuf, l); /* current line as arg */
  	lua_pushinteger(L, l); /* current line number as arg */
***************
*** 1747,1752 ****
--- 1753,1761 ----
  	    luaV_emsg(L);
  	    break;
  	}
+ 	/* Catch the command switching to another buffer. */
+ 	if (curbuf != was_curbuf)
+ 	    break;
  	if (lua_isstring(L, -1)) /* update line? */
  	{
  #ifdef HAVE_SANDBOX
*** ../vim-8.0.0267/src/testdir/test_lua.vim	2017-01-29 22:47:41.069920545 +0100
--- src/testdir/test_lua.vim	2017-01-29 22:39:50.273018239 +0100
***************
*** 0 ****
--- 1,22 ----
+ " Tests for Lua.
+ " TODO: move tests from test85.in here.
+ 
+ if !has('lua')
+   finish
+ endif
+ 
+ func Test_luado()
+   new
+   call setline(1, ['one', 'two', 'three'])
+   luado vim.command("%d_")
+   bwipe!
+ 
+   " Check switching to another buffer does not trigger ml_get error.
+   new
+   let wincount = winnr('$')
+   call setline(1, ['one', 'two', 'three'])
+   luado vim.command("new")
+   call assert_equal(wincount + 1, winnr('$'))
+   bwipe!
+   bwipe!
+ endfunc
*** ../vim-8.0.0267/src/Makefile	2017-01-29 21:30:48.332627641 +0100
--- src/Makefile	2017-01-29 22:41:27.012382108 +0100
***************
*** 2147,2152 ****
--- 2147,2153 ----
  	test_langmap \
  	test_largefile \
  	test_lispwords \
+ 	test_lua \
  	test_man \
  	test_mapping \
  	test_marks \
*** ../vim-8.0.0267/src/testdir/Make_all.mak	2017-01-29 21:30:48.332627641 +0100
--- src/testdir/Make_all.mak	2017-01-29 22:41:41.152289112 +0100
***************
*** 164,169 ****
--- 164,170 ----
  	    test_job_fails.res \
  	    test_json.res \
  	    test_langmap.res \
+ 	    test_lua.res \
  	    test_man.res \
  	    test_marks.res \
  	    test_matchadd_conceal.res \
***************
*** 172,179 ****
  	    test_nested_function.res \
  	    test_netbeans.res \
  	    test_normal.res \
- 	    test_paste.res \
  	    test_packadd.res \
  	    test_perl.res \
  	    test_profile.res \
  	    test_python2.res \
--- 173,180 ----
  	    test_nested_function.res \
  	    test_netbeans.res \
  	    test_normal.res \
  	    test_packadd.res \
+ 	    test_paste.res \
  	    test_perl.res \
  	    test_profile.res \
  	    test_python2.res \
*** ../vim-8.0.0267/src/version.c	2017-01-29 21:49:45.673012259 +0100
--- src/version.c	2017-01-29 22:41:07.388511166 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     268,
  /**/

-- 
Time flies like an arrow.
Fruit flies like a banana.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0269
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0269
Problem:    May get ml_get error when :perldo deletes lines or switches to
            another buffer. (Nikolai Pavlov, issue #1421)
Solution:   Check the buffer and line every time.
Files:      src/if_perl.xs, src/testdir/test_perl.vim


*** ../vim-8.0.0268/src/if_perl.xs	2016-08-29 22:42:20.000000000 +0200
--- src/if_perl.xs	2017-01-29 22:57:17.286108890 +0100
***************
*** 1286,1291 ****
--- 1286,1292 ----
      SV		*sv;
      char	*str;
      linenr_T	i;
+     buf_T	*was_curbuf = curbuf;
  
      if (bufempty())
  	return;
***************
*** 1321,1331 ****
      SAVETMPS;
      for (i = eap->line1; i <= eap->line2; i++)
      {
  	sv_setpv(GvSV(PL_defgv), (char *)ml_get(i));
  	PUSHMARK(sp);
  	perl_call_pv("VIM::perldo", G_SCALAR | G_EVAL);
  	str = SvPV(GvSV(PL_errgv), length);
! 	if (length)
  	    break;
  	SPAGAIN;
  	if (SvTRUEx(POPs))
--- 1322,1335 ----
      SAVETMPS;
      for (i = eap->line1; i <= eap->line2; i++)
      {
+ 	/* Check the line number, the command my have deleted lines. */
+ 	if (i > curbuf->b_ml.ml_line_count)
+ 	    break;
  	sv_setpv(GvSV(PL_defgv), (char *)ml_get(i));
  	PUSHMARK(sp);
  	perl_call_pv("VIM::perldo", G_SCALAR | G_EVAL);
  	str = SvPV(GvSV(PL_errgv), length);
! 	if (length || curbuf != was_curbuf)
  	    break;
  	SPAGAIN;
  	if (SvTRUEx(POPs))
*** ../vim-8.0.0268/src/testdir/test_perl.vim	2016-04-15 21:16:00.000000000 +0200
--- src/testdir/test_perl.vim	2017-01-29 22:52:45.871907395 +0100
***************
*** 82,87 ****
--- 82,102 ----
    1
    call assert_false(search('\Cperl'))
    bw!
+ 
+   " Check deleting lines does not trigger ml_get error.
+   new
+   call setline(1, ['one', 'two', 'three'])
+   perldo VIM::DoCommand("%d_")
+   bwipe!
+ 
+   " Check switching to another buffer does not trigger ml_get error.
+   new
+   let wincount = winnr('$')
+   call setline(1, ['one', 'two', 'three'])
+   perldo VIM::DoCommand("new")
+   call assert_equal(wincount + 1, winnr('$'))
+   bwipe!
+   bwipe!
  endfunc
  
  function Test_VIM_package()
*** ../vim-8.0.0268/src/version.c	2017-01-29 22:48:26.401622036 +0100
--- src/version.c	2017-01-29 22:58:25.081659542 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     269,
  /**/

-- 
When I look deep into your eyes, I see JPEG artifacts.
I can tell by the pixels that we're wrong for each other.  (xkcd)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0270
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0270
Problem:    May get ml_get error when :rubydo deletes lines or switches to
            another buffer. (Nikolai Pavlov, issue #1421)
Solution:   Check the buffer and line every time.
Files:      src/if_ruby.c, src/testdir/test_ruby.vim


*** ../vim-8.0.0269/src/if_ruby.c	2017-01-15 16:58:59.448070798 +0100
--- src/if_ruby.c	2017-01-29 23:09:35.653212880 +0100
***************
*** 783,788 ****
--- 783,789 ----
  {
      int state;
      linenr_T i;
+     buf_T   *was_curbuf = curbuf;
  
      if (ensure_ruby_initialized())
      {
***************
*** 792,797 ****
--- 793,800 ----
  	{
  	    VALUE line;
  
+ 	    if (i > curbuf->b_ml.ml_line_count)
+ 		break;
  	    line = vim_str2rb_enc_str((char *)ml_get(i));
  	    rb_lastline_set(line);
  	    eval_enc_string_protect((char *) eap->arg, &state);
***************
*** 800,805 ****
--- 803,810 ----
  		error_print(state);
  		break;
  	    }
+ 	    if (was_curbuf != curbuf)
+ 		break;
  	    line = rb_lastline_get();
  	    if (!NIL_P(line))
  	    {
*** ../vim-8.0.0269/src/testdir/test_ruby.vim	2016-06-21 22:46:47.000000000 +0200
--- src/testdir/test_ruby.vim	2017-01-29 23:08:10.821775612 +0100
***************
*** 32,34 ****
--- 32,51 ----
    redir END
    call assert_equal(['{"a"=>"foo", "b"=>123}'], split(l:out, "\n"))
  endfunc
+ 
+ func Test_rubydo()
+   " Check deleting lines does not trigger ml_get error.
+   new
+   call setline(1, ['one', 'two', 'three'])
+   rubydo Vim.command("%d_")
+   bwipe!
+ 
+   " Check switching to another buffer does not trigger ml_get error.
+   new
+   let wincount = winnr('$')
+   call setline(1, ['one', 'two', 'three'])
+   rubydo Vim.command("new")
+   call assert_equal(wincount + 1, winnr('$'))
+   bwipe!
+   bwipe!
+ endfunc
*** ../vim-8.0.0269/src/version.c	2017-01-29 22:59:08.253373379 +0100
--- src/version.c	2017-01-29 23:10:21.992905463 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     270,
  /**/

-- 
Two cows are standing together in a field.  One asks the other:
"So what do you think about this Mad Cow Disease?"
The other replies: "That doesn't concern me. I'm a helicopter."

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0271
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0271
Problem:    May get ml_get error when :tcldo deletes lines or switches to
            another buffer. (Nikolai Pavlov, closes #1421)
Solution:   Check the buffer and line every time.
Files:      src/if_tcl.c, src/testdir/test_tcl.vim, src/Makefile,
            src/testdir/Make_all.mak


*** ../vim-8.0.0270/src/if_tcl.c	2016-08-29 22:42:20.000000000 +0200
--- src/if_tcl.c	2017-01-29 23:21:43.316383771 +0100
***************
*** 1958,1963 ****
--- 1958,1964 ----
      char	var_line[VARNAME_SIZE];
      linenr_T	first_line = 0;
      linenr_T	last_line = 0;
+     buf_T	*was_curbuf = curbuf;
  
      rs = eap->line1;
      re = eap->line2;
***************
*** 1979,1984 ****
--- 1980,1987 ----
      }
      while (err == TCL_OK  &&  rs <= re)
      {
+ 	if ((linenr_T)rs > curbuf->b_ml.ml_line_count)
+ 	    break;
  	line = (char *)ml_get_buf(curbuf, (linenr_T)rs, FALSE);
  	if (!line)
  	{
***************
*** 1994,2000 ****
  #if (TCL_MAJOR_VERSION == 8 && TCL_MINOR_VERSION >= 5) || TCL_MAJOR_VERSION > 8
  	    || Tcl_LimitExceeded(tclinfo.interp)
  #endif
! 	   )
  	    break;
  	line = (char *)Tcl_GetVar(tclinfo.interp, var_line, 0);
  	if (line)
--- 1997,2003 ----
  #if (TCL_MAJOR_VERSION == 8 && TCL_MINOR_VERSION >= 5) || TCL_MAJOR_VERSION > 8
  	    || Tcl_LimitExceeded(tclinfo.interp)
  #endif
! 	    || curbuf != was_curbuf)
  	    break;
  	line = (char *)Tcl_GetVar(tclinfo.interp, var_line, 0);
  	if (line)
*** ../vim-8.0.0270/src/testdir/test_tcl.vim	2017-01-29 23:25:37.694827578 +0100
--- src/testdir/test_tcl.vim	2017-01-29 23:18:53.717509633 +0100
***************
*** 0 ****
--- 1,23 ----
+ " Tests for the Tcl interface.
+ 
+ if !has('tcl')
+   finish
+ end
+ 
+ function Test_tcldo()
+   " Check deleting lines does not trigger ml_get error.
+   new
+   call setline(1, ['one', 'two', 'three'])
+   tcldo ::vim::command %d_
+   bwipe!
+ 
+   " Check switching to another buffer does not trigger ml_get error.
+   new
+   let wincount = winnr('$')
+   call setline(1, ['one', 'two', 'three'])
+   tcldo ::vim::command new
+   call assert_equal(wincount + 1, winnr('$'))
+   bwipe!
+   bwipe!
+ endfunc
+ 
*** ../vim-8.0.0270/src/Makefile	2017-01-29 22:48:26.401622036 +0100
--- src/Makefile	2017-01-29 23:17:06.830219093 +0100
***************
*** 2198,2203 ****
--- 2198,2204 ----
  	test_tabpage \
  	test_tagcase \
  	test_tagjump \
+ 	test_tcl \
  	test_textobjects \
  	test_timers \
  	test_true_false \
*** ../vim-8.0.0270/src/testdir/Make_all.mak	2017-01-29 22:48:26.401622036 +0100
--- src/testdir/Make_all.mak	2017-01-29 23:17:27.982078705 +0100
***************
*** 193,198 ****
--- 193,199 ----
  	    test_substitute.res \
  	    test_syntax.res \
  	    test_system.res \
+ 	    test_tcl.res \
  	    test_textobjects.res \
  	    test_undo.res \
  	    test_usercommands.res \
*** ../vim-8.0.0270/src/version.c	2017-01-29 23:11:21.176512814 +0100
--- src/version.c	2017-01-29 23:18:07.213818309 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     271,
  /**/

-- 
ARTHUR:   Ni!
BEDEVERE: Nu!
ARTHUR:   No.  Ni!  More like this. "Ni"!
BEDEVERE: Ni, ni, ni!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0272
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0272
Problem:    Crash on exit is not detected when running tests.
Solution:   Remove the dash before the command. (Dominique Pelle, closes
            #1425)
Files:      src/testdir/Makefile


*** ../vim-8.0.0271/src/testdir/Makefile	2016-09-11 14:36:25.000000000 +0200
--- src/testdir/Makefile	2017-01-30 21:58:00.162197112 +0100
***************
*** 78,84 ****
  	# 200 msec is sufficient, but only modern sleep supports a fraction of
  	# a second, fall back to a second if it fails.
  	@-/bin/sh -c "sleep .2 > /dev/null 2>&1 || sleep 1"
! 	-$(RUN_VIM) $*.in
  
  	# For flaky tests retry one time.  No tests at the moment.
  	#@/bin/sh -c "if test -f test.out -a $* = test61; then \
--- 78,84 ----
  	# 200 msec is sufficient, but only modern sleep supports a fraction of
  	# a second, fall back to a second if it fails.
  	@-/bin/sh -c "sleep .2 > /dev/null 2>&1 || sleep 1"
! 	$(RUN_VIM) $*.in
  
  	# For flaky tests retry one time.  No tests at the moment.
  	#@/bin/sh -c "if test -f test.out -a $* = test61; then \
***************
*** 108,114 ****
  	# 200 msec is sufficient, but only modern sleep supports a fraction of
  	# a second, fall back to a second if it fails.
  	@-/bin/sh -c "sleep .2 > /dev/null 2>&1 || sleep 1"
! 	-$(RUN_VIM) $*.in
  	@/bin/sh -c "if test -f benchmark.out; then cat benchmark.out; fi"
  
  nolog:
--- 108,114 ----
  	# 200 msec is sufficient, but only modern sleep supports a fraction of
  	# a second, fall back to a second if it fails.
  	@-/bin/sh -c "sleep .2 > /dev/null 2>&1 || sleep 1"
! 	$(RUN_VIM) $*.in
  	@/bin/sh -c "if test -f benchmark.out; then cat benchmark.out; fi"
  
  nolog:
*** ../vim-8.0.0271/src/version.c	2017-01-29 23:26:12.926595799 +0100
--- src/version.c	2017-01-30 21:59:15.401698767 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     272,
  /**/

-- 
Vi beats Emacs to death, and then again!
			http://linuxtoday.com/stories/5764.html

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0273
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0273
Problem:    Dead code detected by Coverity when not using gnome.
Solution:   Rearrange the #ifdefs to avoid dead code.
Files:      src/gui_gtk_x11.c


*** ../vim-8.0.0272/src/gui_gtk_x11.c	2017-01-09 20:30:23.898717562 +0100
--- src/gui_gtk_x11.c	2017-01-30 22:45:03.999637769 +0100
***************
*** 3171,3179 ****
      static int
  get_item_dimensions(GtkWidget *widget, GtkOrientation orientation)
  {
      GtkOrientation item_orientation = GTK_ORIENTATION_HORIZONTAL;
  
- # ifdef FEAT_GUI_GNOME
      if (using_gnome && widget != NULL)
      {
  	GtkWidget *parent;
--- 3171,3179 ----
      static int
  get_item_dimensions(GtkWidget *widget, GtkOrientation orientation)
  {
+ # ifdef FEAT_GUI_GNOME
      GtkOrientation item_orientation = GTK_ORIENTATION_HORIZONTAL;
  
      if (using_gnome && widget != NULL)
      {
  	GtkWidget *parent;
***************
*** 3192,3198 ****
--- 3192,3201 ----
  	    item_orientation = bonobo_dock_item_get_orientation(dockitem);
  	}
      }
+ # else
+ #  define item_orientation GTK_ORIENTATION_HORIZONTAL
  # endif
+ 
  # if GTK_CHECK_VERSION(3,0,0)
      if (widget != NULL
  	    && item_orientation == orientation
***************
*** 3210,3224 ****
--- 3213,3235 ----
  
  	gtk_widget_get_allocation(widget, &allocation);
  
+ #  ifdef FEAT_GUI_GNOME
  	if (orientation == GTK_ORIENTATION_HORIZONTAL)
  	    return allocation.height;
  	else
  	    return allocation.width;
+ #  else
+ 	return allocation.height;
+ #endif
  # else
+ #  ifdef FEAT_GUI_GNOME
  	if (orientation == GTK_ORIENTATION_HORIZONTAL)
  	    return widget->allocation.height;
  	else
  	    return widget->allocation.width;
+ #  else
+ 	return widget->allocation.height;
+ #  endif
  # endif
      }
      return 0;
*** ../vim-8.0.0272/src/version.c	2017-01-30 22:00:56.625028477 +0100
--- src/version.c	2017-01-30 22:56:11.995257184 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     273,
  /**/

-- 
       [Autumn changed into Winter ... Winter changed into Spring ...  Spring
       changed back into Autumn and Autumn gave Winter and Spring a miss and
       went straight on into Summer ...  Until one day ...]
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0274
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0274
Problem:    When update_single_line() is called recursively, or another screen
            update happens while it is busy, errors may occur.
Solution:   Check and update updating_screen. (Christian Brabandt)
Files:      src/screen.c


*** ../vim-8.0.0273/src/screen.c	2017-01-24 20:14:42.751459823 +0100
--- src/screen.c	2017-01-31 21:52:36.357539834 +0100
***************
*** 824,831 ****
      int		j;
  
      /* Don't do anything if the screen structures are (not yet) valid. */
!     if (!screen_valid(TRUE))
  	return;
  
      if (lnum >= wp->w_topline && lnum < wp->w_botline
  				 && foldedCount(wp, lnum, &win_foldinfo) == 0)
--- 824,832 ----
      int		j;
  
      /* Don't do anything if the screen structures are (not yet) valid. */
!     if (!screen_valid(TRUE) || updating_screen)
  	return;
+     updating_screen = TRUE;
  
      if (lnum >= wp->w_topline && lnum < wp->w_botline
  				 && foldedCount(wp, lnum, &win_foldinfo) == 0)
***************
*** 865,877 ****
  # endif
      }
      need_cursor_line_redraw = FALSE;
  }
  #endif
  
  #if defined(FEAT_SIGNS) || defined(FEAT_GUI)
- static void update_prepare(void);
- static void update_finish(void);
- 
  /*
   * Prepare for updating one or more windows.
   * Caller must check for "updating_screen" already set to avoid recursiveness.
--- 866,876 ----
  # endif
      }
      need_cursor_line_redraw = FALSE;
+     updating_screen = FALSE;
  }
  #endif
  
  #if defined(FEAT_SIGNS) || defined(FEAT_GUI)
  /*
   * Prepare for updating one or more windows.
   * Caller must check for "updating_screen" already set to avoid recursiveness.
*** ../vim-8.0.0273/src/version.c	2017-01-30 22:56:43.151052887 +0100
--- src/version.c	2017-01-31 21:51:37.545926448 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     274,
  /**/

-- 
TIM: But follow only if you are men of valour.  For the entrance to this cave
     is guarded by a monster, a creature so foul and cruel that no man yet has
     fought with it and lived.  Bones of full fifty men lie strewn about its
     lair ...
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0275
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0275
Problem:    When checking for CTRL-C typed the GUI may detect a screen resize
            and redraw the screen, causing trouble.
Solution:   Set updating_screen in ui_breakcheck().
Files:      src/ui.c


*** ../vim-8.0.0274/src/ui.c	2016-09-29 15:18:51.351768068 +0200
--- src/ui.c	2017-01-31 22:05:10.684588423 +0100
***************
*** 363,374 ****
--- 363,381 ----
      void
  ui_breakcheck_force(int force)
  {
+     int save_us = updating_screen;
+ 
+     /* We do not want gui_resize_shell() to redraw the screen here. */
+     ++updating_screen;
+ 
  #ifdef FEAT_GUI
      if (gui.in_use)
  	gui_mch_update();
      else
  #endif
  	mch_breakcheck(force);
+ 
+     updating_screen = save_us;
  }
  
  /*****************************************************************************
*** ../vim-8.0.0274/src/version.c	2017-01-31 21:53:35.045154104 +0100
--- src/version.c	2017-01-31 22:06:35.724031905 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     275,
  /**/

-- 
TIM:    Too late.
ARTHUR: What?
TIM:    There he is!
   [They all turn, and see a large white RABBIT lollop a few yards out of the
   cave.  Accompanied by terrifying chord and jarring metallic monster noise.]
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0276
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0276
Problem:    Checking for FEAT_GUI_GNOME inside GTK 3 code is unnecessary.
Solution:   Remove the #ifdef. (Kazunobu Kuriyama)
Files:      src/gui_gtk_x11.c


*** ../vim-8.0.0275/src/gui_gtk_x11.c	2017-01-30 22:56:43.151052887 +0100
--- src/gui_gtk_x11.c	2017-02-01 11:39:12.114333786 +0100
***************
*** 3212,3226 ****
  	GtkAllocation allocation;
  
  	gtk_widget_get_allocation(widget, &allocation);
- 
- #  ifdef FEAT_GUI_GNOME
- 	if (orientation == GTK_ORIENTATION_HORIZONTAL)
- 	    return allocation.height;
- 	else
- 	    return allocation.width;
- #  else
  	return allocation.height;
- #endif
  # else
  #  ifdef FEAT_GUI_GNOME
  	if (orientation == GTK_ORIENTATION_HORIZONTAL)
--- 3212,3218 ----
*** ../vim-8.0.0275/src/version.c	2017-01-31 22:07:37.907625018 +0100
--- src/version.c	2017-02-01 11:42:08.549233912 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     276,
  /**/

-- 
If "R" is Reverse, how come "D" is FORWARD?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0277
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0277
Problem:    The GUI test may trigger fontconfig and take a long time.
Solution:   Set $XDG_CACHE_HOME. (Kazunobu Kuriyama)
Files:      src/testdir/unix.vim, src/testdir/test_gui.vim


*** ../vim-8.0.0276/src/testdir/unix.vim	2016-07-12 22:45:28.000000000 +0200
--- src/testdir/unix.vim	2017-02-01 12:02:52.397419237 +0100
***************
*** 2,5 ****
--- 2,10 ----
  " Always use "sh", don't use the value of "$SHELL".
  set shell=sh
  
+ " While some tests overwrite $HOME to prevent them from polluting user files,
+ " we need to remember the original value so that we can tell external systems
+ " where to ask about their own user settings.
+ let g:tester_HOME = $HOME
+ 
  source setup.vim
*** ../vim-8.0.0276/src/testdir/test_gui.vim	2016-08-09 22:52:49.000000000 +0200
--- src/testdir/test_gui.vim	2017-02-01 12:02:52.397419237 +0100
***************
*** 10,16 ****
      set guifont=Courier\ 10\ Pitch/8/-1/5/50/0/0/0/0/0
    endif
  
!   " Gnome insists on creating $HOME/.gnome2/..
    call mkdir('Xhome')
    let $HOME = fnamemodify('Xhome', ':p')
  endfunc
--- 10,20 ----
      set guifont=Courier\ 10\ Pitch/8/-1/5/50/0/0/0/0/0
    endif
  
!   " Gnome insists on creating $HOME/.gnome2/, and we're going to abide by
!   " that, taking care to have the font cache work normally.
!   if $XDG_CACHE_HOME == ''
!     let $XDG_CACHE_HOME = g:tester_HOME . '/.cache'
!   endif
    call mkdir('Xhome')
    let $HOME = fnamemodify('Xhome', ':p')
  endfunc
*** ../vim-8.0.0276/src/version.c	2017-02-01 11:50:04.350267980 +0100
--- src/version.c	2017-02-01 12:04:28.140815126 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     277,
  /**/

-- 
If cars evolved at the same rate as computers have, they'd cost five euro, 
run for a year on a couple of liters of petrol, and explode once a day.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0278
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0278 (after 8.0.0277)
Problem:    GUI test fails on MS-Windows.
Solution:   Check that tester_HOME exists.
Files:      src/testdir/test_gui.vim


*** ../vim-8.0.0277/src/testdir/test_gui.vim	2017-02-01 12:08:43.939201642 +0100
--- src/testdir/test_gui.vim	2017-02-01 12:31:19.742629385 +0100
***************
*** 10,18 ****
      set guifont=Courier\ 10\ Pitch/8/-1/5/50/0/0/0/0/0
    endif
  
!   " Gnome insists on creating $HOME/.gnome2/, and we're going to abide by
!   " that, taking care to have the font cache work normally.
!   if $XDG_CACHE_HOME == ''
      let $XDG_CACHE_HOME = g:tester_HOME . '/.cache'
    endif
    call mkdir('Xhome')
--- 10,19 ----
      set guifont=Courier\ 10\ Pitch/8/-1/5/50/0/0/0/0/0
    endif
  
!   " Gnome insists on creating $HOME/.gnome2/, set $HOME to avoid changing the
!   " actual home directory.  But avoid triggering fontconfig by setting the
!   " cache directory.  Only needed for Unix.
!   if $XDG_CACHE_HOME == '' && exists('g:tester_HOME')
      let $XDG_CACHE_HOME = g:tester_HOME . '/.cache'
    endif
    call mkdir('Xhome')
*** ../vim-8.0.0277/src/version.c	2017-02-01 12:08:43.943201617 +0100
--- src/version.c	2017-02-01 12:32:18.734251887 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     278,
  /**/

-- 
TIM:   That is not an ordinary rabbit ... 'tis the most foul cruel and
       bad-tempered thing you ever set eyes on.
ROBIN: You tit.  I soiled my armour I was so scared!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0279
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0279
Problem:    With MSVC 2015 the dll name is vcruntime140.dll.
Solution:   Check the MSVC version and use the right dll name. (Ken Takata)
Files:      src/Make_mvc.mak


*** ../vim-8.0.0278/src/Make_mvc.mak	2017-01-06 14:55:17.125157197 +0100
--- src/Make_mvc.mak	2017-02-01 12:59:47.275729522 +0100
***************
*** 285,292 ****
  # Base name of the msvcrXX.dll
  !if $(MSVCRT_VER) <= 60
  MSVCRT_NAME = msvcrt
! !else
  MSVCRT_NAME = msvcr$(MSVCRT_VER)
  !endif
  
  !if $(MSVC_MAJOR) == 6
--- 285,294 ----
  # Base name of the msvcrXX.dll
  !if $(MSVCRT_VER) <= 60
  MSVCRT_NAME = msvcrt
! !elseif $(MSVCRT_VER) <= 130
  MSVCRT_NAME = msvcr$(MSVCRT_VER)
+ !else
+ MSVCRT_NAME = vcruntime$(MSVCRT_VER)
  !endif
  
  !if $(MSVC_MAJOR) == 6
*** ../vim-8.0.0278/src/version.c	2017-02-01 12:32:54.422023552 +0100
--- src/version.c	2017-02-01 13:01:07.567218183 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     279,
  /**/

-- 
ARTHUR: Charge!
   [They all charge with swords drawn towards the RABBIT.  A tremendous twenty
   second fight with Peckinpahish shots and borrowing heavily also on the
   Kung Fu and karate-type films ensues, in which some four KNIGHTS are
   comprehensively killed.]
ARTHUR: Run away!  Run away!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0280
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0280
Problem:    On MS-Windows setting an environment variable with multi-byte
            strings does not work well.
Solution:   Use wputenv when possible. (Taro Muraoka, Ken Takata)
Files:      src/misc1.c, src/os_win32.c, src/os_win32.h,
            src/proto/os_win32.pro, src/vim.h


*** ../vim-8.0.0279/src/misc1.c	2017-01-22 19:49:07.983272435 +0100
--- src/misc1.c	2017-02-01 13:08:19.128442600 +0100
***************
*** 4453,4461 ****
      {
  	sprintf((char *)envbuf, "%s=%s", name, val);
  	putenv((char *)envbuf);
- # ifdef libintl_putenv
- 	libintl_putenv((char *)envbuf);
- # endif
      }
  #endif
  #ifdef FEAT_GETTEXT
--- 4453,4458 ----
*** ../vim-8.0.0279/src/os_win32.c	2017-01-12 21:44:45.142171836 +0100
--- src/os_win32.c	2017-02-01 13:08:19.132442574 +0100
***************
*** 515,520 ****
--- 515,521 ----
  static char *null_libintl_bindtextdomain(const char *, const char *);
  static char *null_libintl_bind_textdomain_codeset(const char *, const char *);
  static int null_libintl_putenv(const char *);
+ static int null_libintl_wputenv(const wchar_t *);
  
  static HINSTANCE hLibintlDLL = NULL;
  char *(*dyn_libintl_gettext)(const char *) = null_libintl_gettext;
***************
*** 526,531 ****
--- 527,533 ----
  char *(*dyn_libintl_bind_textdomain_codeset)(const char *, const char *)
  				       = null_libintl_bind_textdomain_codeset;
  int (*dyn_libintl_putenv)(const char *) = null_libintl_putenv;
+ int (*dyn_libintl_wputenv)(const wchar_t *) = null_libintl_wputenv;
  
      int
  dyn_libintl_init(void)
***************
*** 591,599 ****
      /* _putenv() function for the libintl.dll is optional. */
      hmsvcrt = find_imported_module_by_funcname(hLibintlDLL, "getenv");
      if (hmsvcrt != NULL)
  	dyn_libintl_putenv = (void *)GetProcAddress(hmsvcrt, "_putenv");
!     if (dyn_libintl_putenv == NULL || dyn_libintl_putenv == putenv)
  	dyn_libintl_putenv = null_libintl_putenv;
  
      return 1;
  }
--- 593,606 ----
      /* _putenv() function for the libintl.dll is optional. */
      hmsvcrt = find_imported_module_by_funcname(hLibintlDLL, "getenv");
      if (hmsvcrt != NULL)
+     {
  	dyn_libintl_putenv = (void *)GetProcAddress(hmsvcrt, "_putenv");
! 	dyn_libintl_wputenv = (void *)GetProcAddress(hmsvcrt, "_wputenv");
!     }
!     if (dyn_libintl_putenv == NULL || dyn_libintl_putenv == _putenv)
  	dyn_libintl_putenv = null_libintl_putenv;
+     if (dyn_libintl_wputenv == NULL || dyn_libintl_wputenv == _wputenv)
+ 	dyn_libintl_wputenv = null_libintl_wputenv;
  
      return 1;
  }
***************
*** 610,615 ****
--- 617,623 ----
      dyn_libintl_bindtextdomain	= null_libintl_bindtextdomain;
      dyn_libintl_bind_textdomain_codeset = null_libintl_bind_textdomain_codeset;
      dyn_libintl_putenv		= null_libintl_putenv;
+     dyn_libintl_wputenv		= null_libintl_wputenv;
  }
  
  /*ARGSUSED*/
***************
*** 658,663 ****
--- 666,678 ----
      return 0;
  }
  
+ /*ARGSUSED*/
+     int
+ null_libintl_wputenv(const wchar_t *envstring)
+ {
+     return 0;
+ }
+ 
  #endif /* DYNAMIC_GETTEXT */
  
  /* This symbol is not defined in older versions of the SDK or Visual C++ */
***************
*** 6985,6987 ****
--- 7000,7042 ----
      set_alist_count();
  }
  #endif
+ 
+     int
+ mch_setenv(char *var, char *value, int x)
+ {
+     char_u	*envbuf;
+ 
+     envbuf = alloc((unsigned)(STRLEN(var) + STRLEN(value) + 2));
+     if (envbuf == NULL)
+ 	return -1;
+ 
+     sprintf((char *)envbuf, "%s=%s", var, value);
+ 
+ #ifdef FEAT_MBYTE
+     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
+     {
+ 	WCHAR	    *p = enc_to_utf16(envbuf, NULL);
+ 
+ 	vim_free(envbuf);
+ 	if (p == NULL)
+ 	    return -1;
+ 	_wputenv(p);
+ # ifdef libintl_wputenv
+ 	libintl_wputenv(p);
+ # endif
+ 	/* Unlike Un*x systems, we can free the string for _wputenv(). */
+ 	vim_free(p);
+     }
+     else
+ #endif
+     {
+ 	_putenv((char *)envbuf);
+ # ifdef libintl_putenv
+ 	libintl_putenv((char *)envbuf);
+ # endif
+ 	/* Unlike Un*x systems, we can free the string for _putenv(). */
+ 	vim_free(envbuf);
+     }
+ 
+     return 0;
+ }
*** ../vim-8.0.0279/src/os_win32.h	2016-10-12 14:19:55.754357695 +0200
--- src/os_win32.h	2017-02-01 13:08:19.132442574 +0100
***************
*** 202,208 ****
  #define ASSERT_NULL_OR_POINTER(p, type) \
      ASSERT(((p) == NULL)  ||  IsValidAddress((p), sizeof(type), FALSE))
  
! #define mch_setenv(name, val, x) setenv(name, val, x)
  #define mch_getenv(x) (char_u *)getenv((char *)(x))
  #ifdef __BORLANDC__
  # define vim_mkdir(x, y) mkdir(x)
--- 202,210 ----
  #define ASSERT_NULL_OR_POINTER(p, type) \
      ASSERT(((p) == NULL)  ||  IsValidAddress((p), sizeof(type), FALSE))
  
! #ifndef HAVE_SETENV
! # define HAVE_SETENV
! #endif
  #define mch_getenv(x) (char_u *)getenv((char *)(x))
  #ifdef __BORLANDC__
  # define vim_mkdir(x, y) mkdir(x)
*** ../vim-8.0.0279/src/proto/os_win32.pro	2017-01-12 21:44:45.142171836 +0100
--- src/proto/os_win32.pro	2017-02-01 13:08:19.132442574 +0100
***************
*** 65,68 ****
--- 65,69 ----
  void used_file_arg(char *name, int literal, int full_path, int diff_mode);
  void set_alist_count(void);
  void fix_arg_enc(void);
+ int mch_setenv(char *var, char *value, int x);
  /* vim: set ft=c : */
*** ../vim-8.0.0279/src/vim.h	2017-01-27 21:22:14.094909115 +0100
--- src/vim.h	2017-02-01 13:08:19.132442574 +0100
***************
*** 594,599 ****
--- 594,600 ----
  #  endif
  #  define textdomain(domain) (*dyn_libintl_textdomain)(domain)
  #  define libintl_putenv(envstring) (*dyn_libintl_putenv)(envstring)
+ #  define libintl_wputenv(envstring) (*dyn_libintl_wputenv)(envstring)
  # else
  #  include <libintl.h>
  #  define _(x) gettext((char *)(x))
*** ../vim-8.0.0279/src/version.c	2017-02-01 13:02:43.794603926 +0100
--- src/version.c	2017-02-01 13:10:42.215521081 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     280,
  /**/

-- 
An indication you must be a manager:
You feel sorry for Dilbert's boss.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0281
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0281
Problem:    MS-Windows files are still using ARGSUSED while most other files
            have UNUSED.
Solution:   Change ARGSUSED to UNUSED or delete it.
Files:      src/os_win32.c, src/gui_w32.c, src/os_mswin.c, src/os_w32exe.c,
            src/winclip.c


*** ../vim-8.0.0280/src/os_win32.c	2017-02-01 13:14:11.026177020 +0100
--- src/os_win32.c	2017-02-01 13:41:37.369970759 +0100
***************
*** 620,633 ****
      dyn_libintl_wputenv		= null_libintl_wputenv;
  }
  
- /*ARGSUSED*/
      static char *
  null_libintl_gettext(const char *msgid)
  {
      return (char*)msgid;
  }
  
- /*ARGSUSED*/
      static char *
  null_libintl_ngettext(
  	const char *msgid,
--- 620,631 ----
***************
*** 637,674 ****
      return (char *)(n == 1 ? msgid : msgid_plural);
  }
  
- /*ARGSUSED*/
      static char *
! null_libintl_bindtextdomain(const char *domainname, const char *dirname)
  {
      return NULL;
  }
  
- /*ARGSUSED*/
      static char *
! null_libintl_bind_textdomain_codeset(const char *domainname,
! 							  const char *codeset)
  {
      return NULL;
  }
  
- /*ARGSUSED*/
      static char *
! null_libintl_textdomain(const char *domainname)
  {
      return NULL;
  }
  
- /*ARGSUSED*/
      int
! null_libintl_putenv(const char *envstring)
  {
      return 0;
  }
  
- /*ARGSUSED*/
      int
! null_libintl_wputenv(const wchar_t *envstring)
  {
      return 0;
  }
--- 635,670 ----
      return (char *)(n == 1 ? msgid : msgid_plural);
  }
  
      static char *
! null_libintl_bindtextdomain(
! 	const char *domainname UNUSED,
! 	const char *dirname UNUSED)
  {
      return NULL;
  }
  
      static char *
! null_libintl_bind_textdomain_codeset(
! 	const char *domainname UNUSED,
! 	const char *codeset UNUSED)
  {
      return NULL;
  }
  
      static char *
! null_libintl_textdomain(const char *domainname UNUSED)
  {
      return NULL;
  }
  
      int
! null_libintl_putenv(const char *envstring UNUSED)
  {
      return 0;
  }
  
      int
! null_libintl_wputenv(const wchar_t *envstring UNUSED)
  {
      return 0;
  }
***************
*** 1060,1068 ****
   * For the GUI the mouse handling is in gui_w32.c.
   */
  # ifdef FEAT_GUI_W32
- /*ARGSUSED*/
      void
! mch_setmouse(int on)
  {
  }
  # else
--- 1056,1063 ----
   * For the GUI the mouse handling is in gui_w32.c.
   */
  # ifdef FEAT_GUI_W32
      void
! mch_setmouse(int on UNUSED)
  {
  }
  # else
***************
*** 1658,1670 ****
   * If time == -1, wait forever for characters.
   * Returns the number of characters read into buf.
   */
- /*ARGSUSED*/
      int
  mch_inchar(
!     char_u	*buf,
!     int		maxlen,
!     long	time,
!     int		tb_change_cnt)
  {
  #ifndef FEAT_GUI_W32	    /* this isn't used for the GUI */
  
--- 1653,1664 ----
   * If time == -1, wait forever for characters.
   * Returns the number of characters read into buf.
   */
      int
  mch_inchar(
!     char_u	*buf UNUSED,
!     int		maxlen UNUSED,
!     long	time UNUSED,
!     int		tb_change_cnt UNUSED)
  {
  #ifndef FEAT_GUI_W32	    /* this isn't used for the GUI */
  
***************
*** 2592,2602 ****
  /*
   * Do we have an interactive window?
   */
- /*ARGSUSED*/
      int
  mch_check_win(
!     int argc,
!     char **argv)
  {
      get_exe_name();
  
--- 2586,2595 ----
  /*
   * Do we have an interactive window?
   */
      int
  mch_check_win(
!     int argc UNUSED,
!     char **argv UNUSED)
  {
      get_exe_name();
  
***************
*** 5348,5358 ****
  
  
  #ifdef FEAT_GUI_W32
- /*ARGSUSED*/
      void
  mch_write(
!     char_u  *s,
!     int	    len)
  {
      /* never used */
  }
--- 5341,5350 ----
  
  
  #ifdef FEAT_GUI_W32
      void
  mch_write(
!     char_u  *s UNUSED,
!     int	    len UNUSED)
  {
      /* never used */
  }
***************
*** 6050,6060 ****
  /*
   * Delay for "msec" milliseconds.
   */
- /*ARGSUSED*/
      void
  mch_delay(
      long    msec,
!     int	    ignoreinput)
  {
  #ifdef FEAT_GUI_W32
      Sleep((int)msec);	    /* never wait for input */
--- 6042,6051 ----
  /*
   * Delay for "msec" milliseconds.
   */
      void
  mch_delay(
      long    msec,
!     int	    ignoreinput UNUSED)
  {
  #ifdef FEAT_GUI_W32
      Sleep((int)msec);	    /* never wait for input */
***************
*** 6143,6151 ****
  /*
   * How much main memory in KiB that can be used by VIM.
   */
- /*ARGSUSED*/
      long_u
! mch_total_mem(int special)
  {
      MEMORYSTATUSEX  ms;
  
--- 6134,6141 ----
  /*
   * How much main memory in KiB that can be used by VIM.
   */
      long_u
! mch_total_mem(int special UNUSED)
  {
      MEMORYSTATUSEX  ms;
  
*** ../vim-8.0.0280/src/gui_w32.c	2016-12-01 20:32:23.958023740 +0100
--- src/gui_w32.c	2017-02-01 13:41:54.784829904 +0100
***************
*** 558,570 ****
      blink_offtime = off;
  }
  
- /* ARGSUSED */
      static VOID CALLBACK
  _OnBlinkTimer(
      HWND hwnd,
!     UINT uMsg,
      UINT idEvent,
!     DWORD dwTime)
  {
      MSG msg;
  
--- 558,569 ----
      blink_offtime = off;
  }
  
      static VOID CALLBACK
  _OnBlinkTimer(
      HWND hwnd,
!     UINT uMsg UNUSED,
      UINT idEvent,
!     DWORD dwTime UNUSED)
  {
      MSG msg;
  
***************
*** 590,596 ****
  	gui_update_cursor(TRUE, FALSE);
  	blink_state = BLINK_ON;
  	blink_timer = (UINT) SetTimer(NULL, 0, (UINT)blink_ontime,
! 							 (TIMERPROC)_OnBlinkTimer);
      }
  }
  
--- 589,595 ----
  	gui_update_cursor(TRUE, FALSE);
  	blink_state = BLINK_ON;
  	blink_timer = (UINT) SetTimer(NULL, 0, (UINT)blink_ontime,
! 						    (TIMERPROC)_OnBlinkTimer);
      }
  }
  
***************
*** 644,656 ****
   * Call-back routines.
   */
  
- /*ARGSUSED*/
      static VOID CALLBACK
  _OnTimer(
      HWND hwnd,
!     UINT uMsg,
      UINT idEvent,
!     DWORD dwTime)
  {
      MSG msg;
  
--- 643,654 ----
   * Call-back routines.
   */
  
      static VOID CALLBACK
  _OnTimer(
      HWND hwnd,
!     UINT uMsg UNUSED,
      UINT idEvent,
!     DWORD dwTime UNUSED)
  {
      MSG msg;
  
***************
*** 667,678 ****
  	s_wait_timer = 0;
  }
  
- /*ARGSUSED*/
      static void
  _OnDeadChar(
!     HWND hwnd,
!     UINT ch,
!     int cRepeat)
  {
      dead_key = 1;
  }
--- 665,675 ----
  	s_wait_timer = 0;
  }
  
      static void
  _OnDeadChar(
!     HWND hwnd UNUSED,
!     UINT ch UNUSED,
!     int cRepeat UNUSED)
  {
      dead_key = 1;
  }
***************
*** 752,763 ****
  /*
   * Key hit, add it to the input buffer.
   */
- /*ARGSUSED*/
      static void
  _OnChar(
!     HWND hwnd,
      UINT ch,
!     int cRepeat)
  {
      char_u	string[40];
      int		len = 0;
--- 749,759 ----
  /*
   * Key hit, add it to the input buffer.
   */
      static void
  _OnChar(
!     HWND hwnd UNUSED,
      UINT ch,
!     int cRepeat UNUSED)
  {
      char_u	string[40];
      int		len = 0;
***************
*** 777,788 ****
  /*
   * Alt-Key hit, add it to the input buffer.
   */
- /*ARGSUSED*/
      static void
  _OnSysChar(
!     HWND hwnd,
      UINT cch,
!     int cRepeat)
  {
      char_u	string[40]; /* Enough for multibyte character */
      int		len;
--- 773,783 ----
  /*
   * Alt-Key hit, add it to the input buffer.
   */
      static void
  _OnSysChar(
!     HWND hwnd UNUSED,
      UINT cch,
!     int cRepeat UNUSED)
  {
      char_u	string[40]; /* Enough for multibyte character */
      int		len;
***************
*** 861,871 ****
      gui_send_mouse_event(button, x, y, repeated_click, vim_modifiers);
  }
  
- /*ARGSUSED*/
      static void
  _OnMouseButtonDown(
!     HWND hwnd,
!     BOOL fDoubleClick,
      int x,
      int y,
      UINT keyFlags)
--- 856,865 ----
      gui_send_mouse_event(button, x, y, repeated_click, vim_modifiers);
  }
  
      static void
  _OnMouseButtonDown(
!     HWND hwnd UNUSED,
!     BOOL fDoubleClick UNUSED,
      int x,
      int y,
      UINT keyFlags)
***************
*** 960,969 ****
      }
  }
  
- /*ARGSUSED*/
      static void
  _OnMouseMoveOrRelease(
!     HWND hwnd,
      int x,
      int y,
      UINT keyFlags)
--- 954,962 ----
      }
  }
  
      static void
  _OnMouseMoveOrRelease(
!     HWND hwnd UNUSED,
      int x,
      int y,
      UINT keyFlags)
***************
*** 1038,1050 ****
      return pMenu;
  }
  
- /*ARGSUSED*/
      static void
  _OnMenu(
!     HWND	hwnd,
      int		id,
!     HWND	hwndCtl,
!     UINT	codeNotify)
  {
      vimmenu_T	*pMenu;
  
--- 1031,1042 ----
      return pMenu;
  }
  
      static void
  _OnMenu(
!     HWND	hwnd UNUSED,
      int		id,
!     HWND	hwndCtl UNUSED,
!     UINT	codeNotify UNUSED)
  {
      vimmenu_T	*pMenu;
  
***************
*** 1527,1535 ****
   * Return the name of font "font" in allocated memory.
   * Don't know how to get the actual name, thus use the provided name.
   */
- /*ARGSUSED*/
      char_u *
! gui_mch_get_fontname(GuiFont font, char_u *name)
  {
      if (name == NULL)
  	return NULL;
--- 1519,1526 ----
   * Return the name of font "font" in allocated memory.
   * Don't know how to get the actual name, thus use the provided name.
   */
      char_u *
! gui_mch_get_fontname(GuiFont font UNUSED, char_u *name)
  {
      if (name == NULL)
  	return NULL;
***************
*** 2175,2187 ****
  #endif
  }
  
- /*ARGSUSED*/
      void
  gui_mch_set_menu_pos(
!     int	    x,
!     int	    y,
!     int	    w,
!     int	    h)
  {
      /* It will be in the right place anyway */
  }
--- 2166,2177 ----
  #endif
  }
  
      void
  gui_mch_set_menu_pos(
!     int	    x UNUSED,
!     int	    y UNUSED,
!     int	    w UNUSED,
!     int	    h UNUSED)
  {
      /* It will be in the right place anyway */
  }
***************
*** 2817,2826 ****
   * Get this message when the user clicks on the cross in the top right corner
   * of a Windows95 window.
   */
- /*ARGSUSED*/
      static void
! _OnClose(
!     HWND hwnd)
  {
      gui_shell_closed();
  }
--- 2807,2814 ----
   * Get this message when the user clicks on the cross in the top right corner
   * of a Windows95 window.
   */
      static void
! _OnClose(HWND hwnd UNUSED)
  {
      gui_shell_closed();
  }
***************
*** 2829,2836 ****
   * Get a message when the window is being destroyed.
   */
      static void
! _OnDestroy(
!     HWND hwnd)
  {
      if (!destroying)
  	_OnClose(hwnd);
--- 2817,2823 ----
   * Get a message when the window is being destroyed.
   */
      static void
! _OnDestroy(HWND hwnd)
  {
      if (!destroying)
  	_OnClose(hwnd);
***************
*** 2883,2893 ****
      }
  }
  
- /*ARGSUSED*/
      static void
  _OnSize(
      HWND hwnd,
!     UINT state,
      int cx,
      int cy)
  {
--- 2870,2879 ----
      }
  }
  
      static void
  _OnSize(
      HWND hwnd,
!     UINT state UNUSED,
      int cx,
      int cy)
  {
***************
*** 3124,3132 ****
  }
  
  
- /*ARGSUSED*/
      void
! gui_mch_exit(int rc)
  {
  #if defined(FEAT_DIRECTX)
      DWriteContext_Close(s_dwc);
--- 3110,3117 ----
  }
  
  
      void
! gui_mch_exit(int rc UNUSED)
  {
  #if defined(FEAT_DIRECTX)
      DWriteContext_Close(s_dwc);
***************
*** 3285,3293 ****
   * Initialise vim to use the font with the given name.
   * Return FAIL if the font could not be loaded, OK otherwise.
   */
- /*ARGSUSED*/
      int
! gui_mch_init_font(char_u *font_name, int fontset)
  {
      LOGFONT	lf;
      GuiFont	font = NOFONT;
--- 3270,3277 ----
   * Initialise vim to use the font with the given name.
   * Return FAIL if the font could not be loaded, OK otherwise.
   */
      int
! gui_mch_init_font(char_u *font_name, int fontset UNUSED)
  {
      LOGFONT	lf;
      GuiFont	font = NOFONT;
***************
*** 3416,3426 ****
  /*
   * Set the window title
   */
- /*ARGSUSED*/
      void
  gui_mch_settitle(
      char_u  *title,
!     char_u  *icon)
  {
      set_window_title(s_hwnd, (title == NULL ? "VIM" : (char *)title));
  }
--- 3400,3409 ----
  /*
   * Set the window title
   */
      void
  gui_mch_settitle(
      char_u  *title,
!     char_u  *icon UNUSED)
  {
      set_window_title(s_hwnd, (title == NULL ? "VIM" : (char *)title));
  }
***************
*** 3772,3781 ****
  }
  #endif /* FEAT_BROWSE */
  
- /*ARGSUSED*/
      static void
  _OnDropFiles(
!     HWND hwnd,
      HDROP hDrop)
  {
  #ifdef FEAT_WINDOWS
--- 3755,3763 ----
  }
  #endif /* FEAT_BROWSE */
  
      static void
  _OnDropFiles(
!     HWND hwnd UNUSED,
      HDROP hDrop)
  {
  #ifdef FEAT_WINDOWS
***************
*** 3833,3842 ****
  #endif
  }
  
- /*ARGSUSED*/
      static int
  _OnScroll(
!     HWND hwnd,
      HWND hwndCtl,
      UINT code,
      int pos)
--- 3815,3823 ----
  #endif
  }
  
      static int
  _OnScroll(
!     HWND hwnd UNUSED,
      HWND hwndCtl,
      UINT code,
      int pos)
***************
*** 3954,3960 ****
   * Return pointer to buffer in "tofree".
   * Returns zero when out of memory.
   */
- /*ARGSUSED*/
      int
  get_cmd_args(char *prog, char *cmdline, char ***argvp, char **tofree)
  {
--- 3935,3940 ----
***************
*** 5588,5597 ****
  /*
   * Set the size of the window to the given width and height in pixels.
   */
- /*ARGSUSED*/
      void
! gui_mch_set_shellsize(int width, int height,
! 	int min_width, int min_height, int base_width, int base_height,
  	int direction)
  {
      RECT	workarea_rect;
--- 5568,5581 ----
  /*
   * Set the size of the window to the given width and height in pixels.
   */
      void
! gui_mch_set_shellsize(
! 	int width,
! 	int height,
! 	int min_width UNUSED,
! 	int min_height UNUSED,
! 	int base_width UNUSED,
! 	int base_height UNUSED,
  	int direction)
  {
      RECT	workarea_rect;
***************
*** 5752,5760 ****
  /*
   * handle WM_IME_NOTIFY message
   */
- /*ARGSUSED*/
      static LRESULT
! _OnImeNotify(HWND hWnd, DWORD dwCommand, DWORD dwData)
  {
      LRESULT lResult = 0;
      HIMC hImc;
--- 5736,5743 ----
  /*
   * handle WM_IME_NOTIFY message
   */
      static LRESULT
! _OnImeNotify(HWND hWnd, DWORD dwCommand, DWORD dwData UNUSED)
  {
      LRESULT lResult = 0;
      HIMC hImc;
***************
*** 5802,5810 ****
      return lResult;
  }
  
- /*ARGSUSED*/
      static LRESULT
! _OnImeComposition(HWND hwnd, WPARAM dbcs, LPARAM param)
  {
      char_u	*ret;
      int		len;
--- 5785,5792 ----
      return lResult;
  }
  
      static LRESULT
! _OnImeComposition(HWND hwnd, WPARAM dbcs UNUSED, LPARAM param)
  {
      char_u	*ret;
      int		len;
***************
*** 6844,6856 ****
   * pressed, return that button's ID - IDCANCEL (2), which is the button's
   * number.
   */
- /*ARGSUSED*/
      static LRESULT CALLBACK
  dialog_callback(
      HWND hwnd,
      UINT message,
      WPARAM wParam,
!     LPARAM lParam)
  {
      if (message == WM_INITDIALOG)
      {
--- 6826,6837 ----
   * pressed, return that button's ID - IDCANCEL (2), which is the button's
   * number.
   */
      static LRESULT CALLBACK
  dialog_callback(
      HWND hwnd,
      UINT message,
      WPARAM wParam,
!     LPARAM lParam UNUSED)
  {
      if (message == WM_INITDIALOG)
      {
***************
*** 8536,8548 ****
      PostMessage(beval->balloon, WM_CLOSE, 0, 0);
  }
  
- /*ARGSUSED*/
      static VOID CALLBACK
  BevalTimerProc(
!     HWND    hwnd,
!     UINT    uMsg,
!     UINT_PTR    idEvent,
!     DWORD   dwTime)
  {
      POINT	pt;
      RECT	rect;
--- 8517,8528 ----
      PostMessage(beval->balloon, WM_CLOSE, 0, 0);
  }
  
      static VOID CALLBACK
  BevalTimerProc(
!     HWND	hwnd UNUSED,
!     UINT	uMsg UNUSED,
!     UINT_PTR    idEvent UNUSED,
!     DWORD	dwTime)
  {
      POINT	pt;
      RECT	rect;
***************
*** 8578,8593 ****
      }
  }
  
- /*ARGSUSED*/
      void
! gui_mch_disable_beval_area(BalloonEval *beval)
  {
      // TRACE0("gui_mch_disable_beval_area {{{");
      KillTimer(s_textArea, BevalTimerId);
      // TRACE0("gui_mch_disable_beval_area }}}");
  }
  
- /*ARGSUSED*/
      void
  gui_mch_enable_beval_area(BalloonEval *beval)
  {
--- 8558,8571 ----
      }
  }
  
      void
! gui_mch_disable_beval_area(BalloonEval *beval UNUSED)
  {
      // TRACE0("gui_mch_disable_beval_area {{{");
      KillTimer(s_textArea, BevalTimerId);
      // TRACE0("gui_mch_disable_beval_area }}}");
  }
  
      void
  gui_mch_enable_beval_area(BalloonEval *beval)
  {
***************
*** 8619,8625 ****
      // TRACE0("gui_mch_post_balloon }}}");
  }
  
- /*ARGSUSED*/
      BalloonEval *
  gui_mch_create_beval_area(
      void	*target,	/* ignored, always use s_textArea */
--- 8597,8602 ----
***************
*** 8659,8667 ****
      return beval;
  }
  
- /*ARGSUSED*/
      static void
! Handle_WM_Notify(HWND hwnd, LPNMHDR pnmh)
  {
      if (pnmh->idFrom != ID_BEVAL_TOOLTIP) /* it is not our tooltip */
  	return;
--- 8636,8643 ----
      return beval;
  }
  
      static void
! Handle_WM_Notify(HWND hwnd UNUSED, LPNMHDR pnmh)
  {
      if (pnmh->idFrom != ID_BEVAL_TOOLTIP) /* it is not our tooltip */
  	return;
*** ../vim-8.0.0280/src/os_mswin.c	2016-12-01 20:32:23.958023740 +0100
--- src/os_mswin.c	2017-02-01 13:42:07.536151245 +0100
***************
*** 306,315 ****
   *  2: Just restore icon (which we don't have)
   *  3: Restore title and icon (which we don't have)
   */
- /*ARGSUSED*/
      void
! mch_restore_title(
!     int which)
  {
  #ifndef FEAT_GUI_MSWIN
      SetConsoleTitle(g_szOrigTitle);
--- 306,313 ----
   *  2: Just restore icon (which we don't have)
   *  3: Restore title and icon (which we don't have)
   */
      void
! mch_restore_title(int which UNUSED)
  {
  #ifndef FEAT_GUI_MSWIN
      SetConsoleTitle(g_szOrigTitle);
***************
*** 345,357 ****
   * When 'shellslash' set do it the other way around.
   * Return OK or FAIL.
   */
- /*ARGSUSED*/
      int
  mch_FullName(
      char_u	*fname,
      char_u	*buf,
      int		len,
!     int		force)
  {
      int		nResult = FAIL;
  
--- 343,354 ----
   * When 'shellslash' set do it the other way around.
   * Return OK or FAIL.
   */
      int
  mch_FullName(
      char_u	*fname,
      char_u	*buf,
      int		len,
!     int		force UNUSED)
  {
      int		nResult = FAIL;
  
***************
*** 636,644 ****
  }
  
  #if defined(FEAT_GUI_MSWIN) || defined(PROTO)
- /*ARGSUSED*/
      void
! mch_settmode(int tmode)
  {
      /* nothing to do */
  }
--- 633,640 ----
  }
  
  #if defined(FEAT_GUI_MSWIN) || defined(PROTO)
      void
! mch_settmode(int tmode UNUSED)
  {
      /* nothing to do */
  }
***************
*** 817,826 ****
  /*
   * set screen mode, always fails.
   */
- /*ARGSUSED*/
      int
! mch_screenmode(
!     char_u *arg)
  {
      EMSG(_(e_screenmode));
      return FAIL;
--- 813,820 ----
  /*
   * set screen mode, always fails.
   */
      int
! mch_screenmode(char_u *arg UNUSED)
  {
      EMSG(_(e_screenmode));
      return FAIL;
***************
*** 996,1005 ****
  /*
   * Debugging helper: expose the MCH_WRITE_DUMP stuff to other modules
   */
- /*ARGSUSED*/
      void
! DumpPutS(
!     const char *psz)
  {
  # ifdef MCH_WRITE_DUMP
      if (fdDump)
--- 990,997 ----
  /*
   * Debugging helper: expose the MCH_WRITE_DUMP stuff to other modules
   */
      void
! DumpPutS(const char *psz UNUSED)
  {
  # ifdef MCH_WRITE_DUMP
      if (fdDump)
***************
*** 1173,1181 ****
  # define PDP_RETVAL INT_PTR
  #endif
  
- /*ARGSUSED*/
      static PDP_RETVAL CALLBACK
! PrintDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
  {
  #ifdef FEAT_GETTEXT
      NONCLIENTMETRICS nm;
--- 1165,1176 ----
  # define PDP_RETVAL INT_PTR
  #endif
  
      static PDP_RETVAL CALLBACK
! PrintDlgProc(
! 	HWND hDlg,
! 	UINT message,
! 	WPARAM wParam UNUSED,
! 	LPARAM lParam UNUSED)
  {
  #ifdef FEAT_GETTEXT
      NONCLIENTMETRICS nm;
***************
*** 1236,1244 ****
      return FALSE;
  }
  
- /*ARGSUSED*/
      static BOOL CALLBACK
! AbortProc(HDC hdcPrn, int iCode)
  {
      MSG msg;
  
--- 1231,1238 ----
      return FALSE;
  }
  
      static BOOL CALLBACK
! AbortProc(HDC hdcPrn UNUSED, int iCode UNUSED)
  {
      MSG msg;
  
***************
*** 1683,1691 ****
      return (ret > 0);
  }
  
- /*ARGSUSED*/
      void
! mch_print_end(prt_settings_T *psettings)
  {
      EndDoc(prt_dlg.hDC);
      if (!*bUserAbort)
--- 1677,1684 ----
      return (ret > 0);
  }
  
      void
! mch_print_end(prt_settings_T *psettings UNUSED)
  {
      EndDoc(prt_dlg.hDC);
      if (!*bUserAbort)
***************
*** 2764,2775 ****
      return pixels;
  }
  
- /*ARGSUSED*/
      static int CALLBACK
  font_enumproc(
      ENUMLOGFONT	    *elf,
!     NEWTEXTMETRIC   *ntm,
!     int		    type,
      LPARAM	    lparam)
  {
      /* Return value:
--- 2757,2767 ----
      return pixels;
  }
  
      static int CALLBACK
  font_enumproc(
      ENUMLOGFONT	    *elf,
!     NEWTEXTMETRIC   *ntm UNUSED,
!     int		    type UNUSED,
      LPARAM	    lparam)
  {
      /* Return value:
*** ../vim-8.0.0280/src/os_w32exe.c	2016-08-29 22:42:20.000000000 +0200
--- src/os_w32exe.c	2017-02-01 13:42:23.632839303 +0100
***************
*** 38,50 ****
  static void (_cdecl *pSaveInst)(HINSTANCE);
  #endif
  
- /*ARGSUSED*/
      int WINAPI
  WinMain(
!     HINSTANCE	hInstance,
!     HINSTANCE	hPrevInst,
      LPSTR	lpszCmdLine,
!     int		nCmdShow)
  {
      int		argc = 0;
      char	**argv;
--- 38,49 ----
  static void (_cdecl *pSaveInst)(HINSTANCE);
  #endif
  
      int WINAPI
  WinMain(
!     HINSTANCE	hInstance UNUSED,
!     HINSTANCE	hPrevInst UNUSED,
      LPSTR	lpszCmdLine,
!     int		nCmdShow UNUSED)
  {
      int		argc = 0;
      char	**argv;
*** ../vim-8.0.0280/src/winclip.c	2016-08-29 22:42:21.000000000 +0200
--- src/winclip.c	2017-02-01 13:42:34.778139655 +0100
***************
*** 10,16 ****
  /*
   * winclip.c
   *
!  * Routines common to both Win16 and Win32 for clipboard handling.
   * Also used by Cygwin, using os_unix.c.
   */
  
--- 10,16 ----
  /*
   * winclip.c
   *
!  * Routines for Win32 clipboard handling.
   * Also used by Cygwin, using os_unix.c.
   */
  
***************
*** 214,222 ****
  /*
   * Make vim the owner of the current selection.  Return OK upon success.
   */
- /*ARGSUSED*/
      int
! clip_mch_own_selection(VimClipboard *cbd)
  {
      /*
       * Never actually own the clipboard.  If another application sets the
--- 214,221 ----
  /*
   * Make vim the owner of the current selection.  Return OK upon success.
   */
      int
! clip_mch_own_selection(VimClipboard *cbd UNUSED)
  {
      /*
       * Never actually own the clipboard.  If another application sets the
***************
*** 228,236 ****
  /*
   * Make vim NOT the owner of the current selection.
   */
- /*ARGSUSED*/
      void
! clip_mch_lose_selection(VimClipboard *cbd)
  {
      /* Nothing needs to be done here */
  }
--- 227,234 ----
  /*
   * Make vim NOT the owner of the current selection.
   */
      void
! clip_mch_lose_selection(VimClipboard *cbd UNUSED)
  {
      /* Nothing needs to be done here */
  }
*** ../vim-8.0.0280/src/version.c	2017-02-01 13:14:11.026177020 +0100
--- src/version.c	2017-02-01 13:42:50.871112496 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     281,
  /**/

-- 
An indication you must be a manager:
You can explain to somebody the difference between "re-engineering",
"down-sizing", "right-sizing", and "firing people's asses".

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0282
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0282
Problem:    When doing a Visual selection and using "I" to go to insert mode,
            CTRL-O needs to be used twice to go to Normal mode. (Coacher)
Solution:   Check for the return value of edit(). (Christian Brabandt,
            closes #1290)
Files:      src/normal.c, src/ops.c


*** ../vim-8.0.0281/src/normal.c	2017-01-21 20:04:17.566757789 +0100
--- src/normal.c	2017-02-01 14:56:34.658488222 +0100
***************
*** 2041,2046 ****
--- 2041,2048 ----
  
  		if (restart_edit == 0)
  		    restart_edit = restart_edit_save;
+ 		else
+ 		    cap->retval |= CA_COMMAND_BUSY;
  	    }
  #else
  	    vim_beep(BO_OPER);
*** ../vim-8.0.0281/src/ops.c	2017-01-24 20:47:46.346131723 +0100
--- src/ops.c	2017-02-01 14:57:21.914183700 +0100
***************
*** 2571,2577 ****
      }
  
      t1 = oap->start;
!     edit(NUL, FALSE, (linenr_T)count1);
  
      /* When a tab was inserted, and the characters in front of the tab
       * have been converted to a tab as well, the column of the cursor
--- 2571,2578 ----
      }
  
      t1 = oap->start;
!     if (edit(NUL, FALSE, (linenr_T)count1))
! 	return;
  
      /* When a tab was inserted, and the characters in front of the tab
       * have been converted to a tab as well, the column of the cursor
*** ../vim-8.0.0281/src/version.c	2017-02-01 13:43:32.534844945 +0100
--- src/version.c	2017-02-01 15:00:27.776986153 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     282,
  /**/

-- 
I just planted an Algebra tree. It has square roots.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0283
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0283
Problem:    The return value of mode() does not indicate that completion is
            active in Replace and Insert mode. (Zhen-Huan (Kenny) Hu)
Solution:   Add "c" or "x" for two kinds of completion. (Yegappan Lakshmanan,
            closes #1397)  Test some more modes.
Files:      runtime/doc/eval.txt, src/evalfunc.c,
            src/testdir/test_functions.vim, src/testdir/test_mapping.vim


*** ../vim-8.0.0282/runtime/doc/eval.txt	2017-01-28 18:23:49.725039260 +0100
--- runtime/doc/eval.txt	2017-02-01 16:16:52.343450573 +0100
***************
*** 5839,5847 ****
  			S	Select by line
  			CTRL-S	Select blockwise
  			i	Insert
  			R	Replace |R|
  			Rv	Virtual Replace |gR|
! 			c	Command-line
  			cv	Vim Ex mode |gQ|
  			ce	Normal Ex mode |Q|
  			r	Hit-enter prompt
--- 5848,5860 ----
  			S	Select by line
  			CTRL-S	Select blockwise
  			i	Insert
+ 			ic	Insert mode completion |compl-generic|
+ 			ix	Insert mode |i_CTRL-X| completion
  			R	Replace |R|
+ 			Rc	Replace mode completion |compl-generic|
  			Rv	Virtual Replace |gR|
! 			Rx	Replace mode |i_CTRL-X| completion
! 			c	Command-line editing
  			cv	Vim Ex mode |gQ|
  			ce	Normal Ex mode |Q|
  			r	Hit-enter prompt
*** ../vim-8.0.0282/src/evalfunc.c	2017-01-29 20:31:17.872621591 +0100
--- src/evalfunc.c	2017-02-01 16:42:06.749685417 +0100
***************
*** 7783,7803 ****
  	}
  	else
  #endif
! 	if (State & REPLACE_FLAG)
! 	    buf[0] = 'R';
! 	else
! 	    buf[0] = 'i';
      }
!     else if (State & CMDLINE)
      {
  	buf[0] = 'c';
! 	if (exmode_active)
  	    buf[1] = 'v';
!     }
!     else if (exmode_active)
!     {
! 	buf[0] = 'c';
! 	buf[1] = 'e';
      }
      else
      {
--- 7783,7808 ----
  	}
  	else
  #endif
! 	{
! 	    if (State & REPLACE_FLAG)
! 		buf[0] = 'R';
! 	    else
! 		buf[0] = 'i';
! #ifdef FEAT_INS_EXPAND
! 	    if (ins_compl_active())
! 		buf[1] = 'c';
! 	    else if (ctrl_x_mode == 1)
! 		buf[1] = 'x';
! #endif
! 	}
      }
!     else if ((State & CMDLINE) || exmode_active)
      {
  	buf[0] = 'c';
! 	if (exmode_active == EXMODE_VIM)
  	    buf[1] = 'v';
! 	else if (exmode_active == EXMODE_NORMAL)
! 	    buf[1] = 'e';
      }
      else
      {
*** ../vim-8.0.0282/src/testdir/test_functions.vim	2017-01-29 15:45:07.161783704 +0100
--- src/testdir/test_functions.vim	2017-02-01 17:15:06.872947192 +0100
***************
*** 304,307 ****
--- 304,392 ----
    call assert_equal(" ", toupper(" "))
  endfunc
  
+ " Tests for the mode() function
+ let current_modes = ''
+ func! Save_mode()
+   let g:current_modes = mode(0) . '-' . mode(1)
+   return ''
+ endfunc
+ 
+ func! Test_mode()
+   new
+   call append(0, ["Blue Ball Black", "Brown Band Bowl", ""])
+ 
+   inoremap <F2> <C-R>=Save_mode()<CR>
+ 
+   normal! 3G
+   exe "normal i\<F2>\<Esc>"
+   call assert_equal('i-i', g:current_modes)
+   exe "normal i\<C-G>uBa\<C-P>\<F2>\<Esc>u"
+   call assert_equal('i-ic', g:current_modes)
+   exe "normal iBro\<C-P>\<F2>\<Esc>u"
+   call assert_equal('i-ic', g:current_modes)
+   exe "normal iBa\<C-X>\<F2>\<Esc>u"
+   call assert_equal('i-ix', g:current_modes)
+   exe "normal iBa\<C-X>\<C-P>\<F2>\<Esc>u"
+   call assert_equal('i-ic', g:current_modes)
+   exe "normal iBro\<C-X>\<C-P>\<F2>\<Esc>u"
+   call assert_equal('i-ic', g:current_modes)
+   exe "normal iBro\<C-X>\<C-P>\<C-P>\<F2>\<Esc>u"
+   call assert_equal('i-ic', g:current_modes)
+   exe "normal iCom\<C-P>\<F2>\<Esc>u"
+   call assert_equal('i-ic', g:current_modes)
+   exe "normal iCom\<C-X>\<C-P>\<F2>\<Esc>u"
+   call assert_equal('i-ic', g:current_modes)
+ 
+   exe "normal RBa\<C-P>\<F2>\<Esc>u"
+   call assert_equal('R-Rc', g:current_modes)
+   exe "normal RBro\<C-P>\<F2>\<Esc>u"
+   call assert_equal('R-Rc', g:current_modes)
+   exe "normal RBa\<C-X>\<F2>\<Esc>u"
+   call assert_equal('R-Rx', g:current_modes)
+   exe "normal RBa\<C-X>\<C-P>\<F2>\<Esc>u"
+   call assert_equal('R-Rc', g:current_modes)
+   exe "normal RBro\<C-X>\<C-P>\<F2>\<Esc>u"
+   call assert_equal('R-Rc', g:current_modes)
+   exe "normal RBro\<C-X>\<C-P>\<C-P>\<F2>\<Esc>u"
+   call assert_equal('R-Rc', g:current_modes)
+   exe "normal RCom\<C-P>\<F2>\<Esc>u"
+   call assert_equal('R-Rc', g:current_modes)
+   exe "normal RCom\<C-X>\<C-P>\<F2>\<Esc>u"
+   call assert_equal('R-Rc', g:current_modes)
+ 
+   call assert_equal('n', mode(0))
+   call assert_equal('n', mode(1))
  
+   " How to test operator-pending mode?
+ 
+   call feedkeys("v", 'xt')
+   call assert_equal('v', mode())
+   call assert_equal('v', mode(1))
+   call feedkeys("\<Esc>V", 'xt')
+   call assert_equal('V', mode())
+   call assert_equal('V', mode(1))
+   call feedkeys("\<Esc>\<C-V>", 'xt')
+   call assert_equal("\<C-V>", mode())
+   call assert_equal("\<C-V>", mode(1))
+   call feedkeys("\<Esc>", 'xt')
+ 
+   call feedkeys("gh", 'xt')
+   call assert_equal('s', mode())
+   call assert_equal('s', mode(1))
+   call feedkeys("\<Esc>gH", 'xt')
+   call assert_equal('S', mode())
+   call assert_equal('S', mode(1))
+   call feedkeys("\<Esc>g\<C-H>", 'xt')
+   call assert_equal("\<C-S>", mode())
+   call assert_equal("\<C-S>", mode(1))
+   call feedkeys("\<Esc>", 'xt')
+ 
+   call feedkeys(":echo \<C-R>=Save_mode()\<C-U>\<CR>", 'xt')
+   call assert_equal('c-c', g:current_modes)
+   call feedkeys("gQecho \<C-R>=Save_mode()\<CR>\<CR>vi\<CR>", 'xt')
+   call assert_equal('c-cv', g:current_modes)
+   " How to test Ex mode?
+ 
+   bwipe!
+   iunmap <F2>
+ endfunc
*** ../vim-8.0.0282/src/testdir/test_mapping.vim	2016-09-08 21:39:00.000000000 +0200
--- src/testdir/test_mapping.vim	2017-02-01 17:20:05.863024601 +0100
***************
*** 110,115 ****
--- 110,117 ----
    call feedkeys(":call append(line('$'), '+')\<CR>", "xt")
    call assert_equal('+', getline('$'))
  
+   iunmap a
+   iunmap c
    set nomodified
  endfunc
  
***************
*** 120,126 ****
    $-1
    call feedkeys("0qqdw.ifoo\<Esc>qj0@q\<Esc>", "xt")
    call assert_equal(['fooc d', 'fooc d'], getline(line('$') - 1, line('$')))
!   unmap .
    set nomodified
  endfunc
  
--- 122,128 ----
    $-1
    call feedkeys("0qqdw.ifoo\<Esc>qj0@q\<Esc>", "xt")
    call assert_equal(['fooc d', 'fooc d'], getline(line('$') - 1, line('$')))
!   nunmap .
    set nomodified
  endfunc
  
*** ../vim-8.0.0282/src/version.c	2017-02-01 15:03:25.679840157 +0100
--- src/version.c	2017-02-01 17:07:10.796008356 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     283,
  /**/

-- 
I wonder, do vegetarians eat fruit bats?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0284
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0284
Problem:    The Test_collapse_buffers() test failed once, looks like it is
            flaky.
Solution:   Add it to the list of flaky tests.
Files:      src/testdir/runtest.vim


*** ../vim-8.0.0283/src/testdir/runtest.vim	2017-01-29 21:49:45.669012286 +0100
--- src/testdir/runtest.vim	2017-02-01 17:58:27.064187626 +0100
***************
*** 153,164 ****
  
  " Names of flaky tests.
  let s:flaky = [
-       \ 'Test_reltime()',
-       \ 'Test_nb_basic()',
-       \ 'Test_communicate()',
        \ 'Test_close_and_exit_cb()',
        \ 'Test_pipe_through_sort_all()',
        \ 'Test_pipe_through_sort_some()'
        \ ]
  
  " Locate Test_ functions and execute them.
--- 153,165 ----
  
  " Names of flaky tests.
  let s:flaky = [
        \ 'Test_close_and_exit_cb()',
+       \ 'Test_collapse_buffers()',
+       \ 'Test_communicate()',
+       \ 'Test_nb_basic()',
        \ 'Test_pipe_through_sort_all()',
        \ 'Test_pipe_through_sort_some()'
+       \ 'Test_reltime()',
        \ ]
  
  " Locate Test_ functions and execute them.
*** ../vim-8.0.0283/src/version.c	2017-02-01 17:24:29.681328124 +0100
--- src/version.c	2017-02-01 17:59:25.151813061 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     284,
  /**/

-- 
Veni, Vidi, VW -- I came, I saw, I drove around in a little car.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0285
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0285 (after 8.0.0277)
Problem:    Tests fail with tiny build on Unix.
Solution:   Only set g:tester_HOME when build with the +eval feature.
Files:      src/testdir/unix.vim


*** ../vim-8.0.0284/src/testdir/unix.vim	2017-02-01 12:08:43.939201642 +0100
--- src/testdir/unix.vim	2017-02-01 18:04:10.117964780 +0100
***************
*** 2,10 ****
  " Always use "sh", don't use the value of "$SHELL".
  set shell=sh
  
! " While some tests overwrite $HOME to prevent them from polluting user files,
! " we need to remember the original value so that we can tell external systems
! " where to ask about their own user settings.
! let g:tester_HOME = $HOME
  
  source setup.vim
--- 2,13 ----
  " Always use "sh", don't use the value of "$SHELL".
  set shell=sh
  
! " Only when the +eval feature is present. 
! if 1
!   " While some tests overwrite $HOME to prevent them from polluting user files,
!   " we need to remember the original value so that we can tell external systems
!   " where to ask about their own user settings.
!   let g:tester_HOME = $HOME
! endif
  
  source setup.vim
*** ../vim-8.0.0284/src/version.c	2017-02-01 18:00:08.123535971 +0100
--- src/version.c	2017-02-01 18:05:40.133378639 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     285,
  /**/

-- 
ARTHUR:          But if he was dying, he wouldn't bother to carve
                 "Aaaaarrrrrrggghhh".  He'd just say it.
BROTHER MAYNARD: It's down there carved in stone.
GALAHAD:         Perhaps he was dictating.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0286
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0286
Problem:    When concealing is active and the screen is resized in the GUI it
            is not immediately redrawn.
Solution:   Use update_prepare() and update_finish() from
            update_single_line().
Files:      src/screen.c


*** ../vim-8.0.0285/src/screen.c	2017-01-31 21:53:35.045154104 +0100
--- src/screen.c	2017-02-01 18:33:41.922442269 +0100
***************
*** 777,782 ****
--- 777,833 ----
  #endif
  }
  
+ #if defined(FEAT_SIGNS) || defined(FEAT_GUI) || defined(FEAT_CONCEAL)
+ /*
+  * Prepare for updating one or more windows.
+  * Caller must check for "updating_screen" already set to avoid recursiveness.
+  */
+     static void
+ update_prepare(void)
+ {
+     cursor_off();
+     updating_screen = TRUE;
+ #ifdef FEAT_GUI
+     /* Remove the cursor before starting to do anything, because scrolling may
+      * make it difficult to redraw the text under it. */
+     if (gui.in_use)
+ 	gui_undraw_cursor();
+ #endif
+ #ifdef FEAT_SEARCH_EXTRA
+     start_search_hl();
+ #endif
+ }
+ 
+ /*
+  * Finish updating one or more windows.
+  */
+     static void
+ update_finish(void)
+ {
+     if (redraw_cmdline)
+ 	showmode();
+ 
+ # ifdef FEAT_SEARCH_EXTRA
+     end_search_hl();
+ # endif
+ 
+     updating_screen = FALSE;
+ 
+ # ifdef FEAT_GUI
+     gui_may_resize_shell();
+ 
+     /* Redraw the cursor and update the scrollbars when all screen updating is
+      * done. */
+     if (gui.in_use)
+     {
+ 	out_flush();	/* required before updating the cursor */
+ 	gui_update_cursor(FALSE, FALSE);
+ 	gui_update_scrollbars(FALSE);
+     }
+ # endif
+ }
+ #endif
+ 
  #if defined(FEAT_CONCEAL) || defined(PROTO)
  /*
   * Return TRUE if the cursor line in window "wp" may be concealed, according
***************
*** 826,842 ****
      /* Don't do anything if the screen structures are (not yet) valid. */
      if (!screen_valid(TRUE) || updating_screen)
  	return;
-     updating_screen = TRUE;
  
      if (lnum >= wp->w_topline && lnum < wp->w_botline
  				 && foldedCount(wp, lnum, &win_foldinfo) == 0)
      {
! # ifdef FEAT_GUI
! 	/* Remove the cursor before starting to do anything, because scrolling
! 	 * may make it difficult to redraw the text under it. */
! 	if (gui.in_use)
! 	    gui_undraw_cursor();
! # endif
  	row = 0;
  	for (j = 0; j < wp->w_lines_valid; ++j)
  	{
--- 877,888 ----
      /* Don't do anything if the screen structures are (not yet) valid. */
      if (!screen_valid(TRUE) || updating_screen)
  	return;
  
      if (lnum >= wp->w_topline && lnum < wp->w_botline
  				 && foldedCount(wp, lnum, &win_foldinfo) == 0)
      {
! 	update_prepare();
! 
  	row = 0;
  	for (j = 0; j < wp->w_lines_valid; ++j)
  	{
***************
*** 856,923 ****
  	    }
  	    row += wp->w_lines[j].wl_size;
  	}
- # ifdef FEAT_GUI
- 	/* Redraw the cursor */
- 	if (gui.in_use)
- 	{
- 	    out_flush();	/* required before updating the cursor */
- 	    gui_update_cursor(FALSE, FALSE);
- 	}
- # endif
-     }
-     need_cursor_line_redraw = FALSE;
-     updating_screen = FALSE;
- }
- #endif
- 
- #if defined(FEAT_SIGNS) || defined(FEAT_GUI)
- /*
-  * Prepare for updating one or more windows.
-  * Caller must check for "updating_screen" already set to avoid recursiveness.
-  */
-     static void
- update_prepare(void)
- {
-     cursor_off();
-     updating_screen = TRUE;
- #ifdef FEAT_GUI
-     /* Remove the cursor before starting to do anything, because scrolling may
-      * make it difficult to redraw the text under it. */
-     if (gui.in_use)
- 	gui_undraw_cursor();
- #endif
- #ifdef FEAT_SEARCH_EXTRA
-     start_search_hl();
- #endif
- }
  
! /*
!  * Finish updating one or more windows.
!  */
!     static void
! update_finish(void)
! {
!     if (redraw_cmdline)
! 	showmode();
! 
! # ifdef FEAT_SEARCH_EXTRA
!     end_search_hl();
! # endif
! 
!     updating_screen = FALSE;
! 
! # ifdef FEAT_GUI
!     gui_may_resize_shell();
! 
!     /* Redraw the cursor and update the scrollbars when all screen updating is
!      * done. */
!     if (gui.in_use)
!     {
! 	out_flush();	/* required before updating the cursor */
! 	gui_update_cursor(FALSE, FALSE);
! 	gui_update_scrollbars(FALSE);
      }
! # endif
  }
  #endif
  
--- 902,911 ----
  	    }
  	    row += wp->w_lines[j].wl_size;
  	}
  
! 	update_finish();
      }
!     need_cursor_line_redraw = FALSE;
  }
  #endif
  
*** ../vim-8.0.0285/src/version.c	2017-02-01 18:07:33.060643434 +0100
--- src/version.c	2017-02-01 18:35:14.009844134 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     286,
  /**/

-- 
BEDEVERE:  Oooooh!
LAUNCELOT: No "Aaaaarrrrrrggghhh ... " at the back of the throat.
BEDEVERE:  No!  "Oooooh!" in surprise and alarm!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0287
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0287
Problem:    Cannot access the arguments of the current function in debug mode.
            (Luc Hermitte)
Solution:   use get_funccal(). (Lemonboy, closes #1432, closes #1352)
Files:      src/userfunc.c


*** ../vim-8.0.0286/src/userfunc.c	2017-01-28 15:58:45.352197224 +0100
--- src/userfunc.c	2017-02-01 20:07:52.561131400 +0100
***************
*** 3556,3562 ****
  {
      if (current_funccal == NULL)
  	return NULL;
!     return &current_funccal->l_avars_var;
  }
  
  /*
--- 3556,3562 ----
  {
      if (current_funccal == NULL)
  	return NULL;
!     return &get_funccal()->l_avars_var;
  }
  
  /*
*** ../vim-8.0.0286/src/version.c	2017-02-01 18:37:08.817093810 +0100
--- src/version.c	2017-02-01 20:09:59.436292198 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     287,
  /**/

-- 
Shaw's Principle: Build a system that even a fool can use, and
only a fool will want to use it.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0288
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0288 (after 8.0.0284)
Problem:    Errors reported while running tests.
Solution:   Put comma in the right place.
Files:      src/testdir/runtest.vim


*** ../vim-8.0.0287/src/testdir/runtest.vim	2017-02-01 18:00:08.123535971 +0100
--- src/testdir/runtest.vim	2017-02-01 20:44:49.378472939 +0100
***************
*** 158,164 ****
        \ 'Test_communicate()',
        \ 'Test_nb_basic()',
        \ 'Test_pipe_through_sort_all()',
!       \ 'Test_pipe_through_sort_some()'
        \ 'Test_reltime()',
        \ ]
  
--- 158,164 ----
        \ 'Test_communicate()',
        \ 'Test_nb_basic()',
        \ 'Test_pipe_through_sort_all()',
!       \ 'Test_pipe_through_sort_some()',
        \ 'Test_reltime()',
        \ ]
  
*** ../vim-8.0.0287/src/version.c	2017-02-01 20:26:45.773640471 +0100
--- src/version.c	2017-02-01 20:41:59.567600545 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     288,
  /**/

-- 
"When I die, I want a tombstone that says "GAME OVER" - Ton Richters

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0289
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0289
Problem:    No test for "ga" and :ascii.
Solution:   Add a test. (Dominique Pelle, closes #1429)
Files:      src/Makefile, src/testdir/test_alot.vim, src/testdir/test_ga.vim


*** ../vim-8.0.0288/src/Makefile	2017-01-29 23:26:12.926595799 +0100
--- src/Makefile	2017-02-01 20:40:56.888016831 +0100
***************
*** 2127,2134 ****
  	test_fnameescape \
  	test_fnamemodify \
  	test_fold \
! 	test_glob2regpat \
  	test_gf \
  	test_gn \
  	test_goto \
  	test_gui \
--- 2127,2135 ----
  	test_fnameescape \
  	test_fnamemodify \
  	test_fold \
! 	test_ga \
  	test_gf \
+ 	test_glob2regpat \
  	test_gn \
  	test_goto \
  	test_gui \
*** ../vim-8.0.0288/src/testdir/test_alot.vim	2017-01-22 20:04:36.493131648 +0100
--- src/testdir/test_alot.vim	2017-02-01 20:40:28.088208119 +0100
***************
*** 19,24 ****
--- 19,25 ----
  source test_fnamemodify.vim
  source test_functions.vim
  source test_glob2regpat.vim
+ source test_ga.vim
  source test_goto.vim
  source test_help_tagjump.vim
  source test_join.vim
*** ../vim-8.0.0288/src/testdir/test_ga.vim	2017-02-01 20:51:57.035634336 +0100
--- src/testdir/test_ga.vim	2017-02-01 20:40:28.088208119 +0100
***************
*** 0 ****
--- 1,37 ----
+ " Test ga normal command, and :ascii Ex command.
+ func Do_ga(c)
+   call setline(1, a:c)
+   let l:a = execute("norm 1goga")
+   let l:b = execute("ascii")
+   call assert_equal(l:a, l:b)
+   return l:a
+ endfunc
+ 
+ func Test_ga_command()
+   new
+   set display=uhex
+   call assert_equal("\nNUL",                            Do_ga(''))
+   call assert_equal("\n<<01>>  1,  Hex 01,  Octal 001", Do_ga("\x01"))
+   call assert_equal("\n<<09>>  9,  Hex 09,  Octal 011", Do_ga("\t"))
+ 
+   set display=
+   call assert_equal("\nNUL",                             Do_ga(''))
+   call assert_equal("\n<^A>  1,  Hex 01,  Octal 001",    Do_ga("\x01"))
+   call assert_equal("\n<^I>  9,  Hex 09,  Octal 011",    Do_ga("\t"))
+ 
+   call assert_equal("\n<e>  101,  Hex 65,  Octal 145",   Do_ga('e'))
+ 
+   if !has('multi_byte')
+     return
+   endif
+ 
+   " Test a few multi-bytes characters.
+   call assert_equal("\n<> 233, Hex 00e9, Octal 351",    Do_ga(''))
+   call assert_equal("\n<> 7867, Hex 1ebb, Octal 17273", Do_ga(''))
+ 
+   " Test with combining characters.
+   call assert_equal("\n<e>  101,  Hex 65,  Octal 145 < > 769, Hex 0301, Octal 1401", Do_ga("e\u0301"))
+   call assert_equal("\n<e>  101,  Hex 65,  Octal 145 < > 769, Hex 0301, Octal 1401 < > 817, Hex 0331, Octal 1461", Do_ga("e\u0301\u0331"))
+   call assert_equal("\n<e>  101,  Hex 65,  Octal 145 < > 769, Hex 0301, Octal 1401 < > 817, Hex 0331, Octal 1461 < > 824, Hex 0338, Octal 1470", Do_ga("e\u0301\u0331\u0338"))
+   bwipe!
+ endfunc
*** ../vim-8.0.0288/src/version.c	2017-02-01 20:48:09.037147485 +0100
--- src/version.c	2017-02-01 20:52:04.967581702 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     289,
  /**/

-- 
   [Another hideous roar.]
BEDEVERE: That's it!
ARTHUR:   What?
BEDEVERE: It's The Legendary Black Beast of Aaaaarrrrrrggghhh!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0290
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0290
Problem:    If a wide character doesn't fit at the end of the screen line, and
            the line doesn't fit on the screen, then the cursor position may
            be wrong. (anliting)
Solution:   Don't skip over wide character. (Christian Brabandt, closes #1408)
Files:      src/screen.c


*** ../vim-8.0.0289/src/screen.c	2017-02-01 18:37:08.817093810 +0100
--- src/screen.c	2017-02-01 21:17:52.625323188 +0100
***************
*** 2903,2909 ****
      int		endrow,
      int		nochange UNUSED)	/* not updating for changed text */
  {
!     int		col;			/* visual column on screen */
      unsigned	off;			/* offset in ScreenLines/ScreenAttrs */
      int		c = 0;			/* init for GCC */
      long	vcol = 0;		/* virtual column (for tabs) */
--- 2903,2909 ----
      int		endrow,
      int		nochange UNUSED)	/* not updating for changed text */
  {
!     int		col = 0;		/* visual column on screen */
      unsigned	off;			/* offset in ScreenLines/ScreenAttrs */
      int		c = 0;			/* init for GCC */
      long	vcol = 0;		/* virtual column (for tabs) */
***************
*** 3429,3435 ****
  #else
  	    --ptr;
  #endif
! 	    n_skip = v - vcol;
  	}
  
  	/*
--- 3429,3439 ----
  #else
  	    --ptr;
  #endif
! #ifdef FEAT_MBYTE
!            /* character fits on the screen, don't need to skip it */
!            if ((*mb_ptr2cells)(ptr) >= c && col == 0)
! #endif
! 	       n_skip = v - vcol;
  	}
  
  	/*
*** ../vim-8.0.0289/src/version.c	2017-02-01 20:53:18.659092738 +0100
--- src/version.c	2017-02-01 21:21:35.671846143 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     290,
  /**/

-- 
I bought a book on hair loss, but the pages kept falling out.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0291
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0291 (after 8.0.0282)
Problem:    Visual block insertion does not insert in all lines.
Solution:   Don't bail out of insert too early. Add a test. (Christian
            Brabandt, closes #1290)
Files:      src/ops.c, src/testdir/test_visual.vim


*** ../vim-8.0.0290/src/ops.c	2017-02-01 15:03:25.679840157 +0100
--- src/ops.c	2017-02-01 21:46:49.837832763 +0100
***************
*** 2571,2578 ****
      }
  
      t1 = oap->start;
!     if (edit(NUL, FALSE, (linenr_T)count1))
! 	return;
  
      /* When a tab was inserted, and the characters in front of the tab
       * have been converted to a tab as well, the column of the cursor
--- 2571,2577 ----
      }
  
      t1 = oap->start;
!     (void)edit(NUL, FALSE, (linenr_T)count1);
  
      /* When a tab was inserted, and the characters in front of the tab
       * have been converted to a tab as well, the column of the cursor
*** ../vim-8.0.0290/src/testdir/test_visual.vim	2017-01-02 17:31:20.610046069 +0100
--- src/testdir/test_visual.vim	2017-02-01 21:43:16.231244062 +0100
***************
*** 23,25 ****
--- 23,38 ----
    call assert_equal('hello world world', getline(1))
    q!
  endfunc
+ 
+ func Test_Visual_ctrl_o()
+   new
+   call setline(1, ['one', 'two', 'three'])
+   call cursor(1,2)
+   set noshowmode
+   set tw=0
+   call feedkeys("\<c-v>jjlIa\<c-\>\<c-o>:set tw=88\<cr>\<esc>", 'tx')
+   call assert_equal(['oane', 'tawo', 'tahree'], getline(1, 3))
+   call assert_equal(88, &tw)
+   set tw&
+   bw!
+ endfu
*** ../vim-8.0.0290/src/version.c	2017-02-01 21:23:05.559250966 +0100
--- src/version.c	2017-02-01 21:49:00.180971616 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     291,
  /**/

-- 
To the optimist, the glass is half full.
To the pessimist, the glass is half empty.
To the engineer, the glass is twice as big as it needs to be.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0292
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0292
Problem:    The stat test is a bit slow.
Solution:   Remove a couple of sleep comments and reduce another.
Files:      src/testdir/test_stat.vim


*** ../vim-8.0.0291/src/testdir/test_stat.vim	2016-07-01 17:04:48.000000000 +0200
--- src/testdir/test_stat.vim	2017-02-01 22:03:36.215184398 +0100
***************
*** 1,24 ****
  " Tests for stat functions and checktime
  
  func Test_existent_file()
!   let fname='Xtest.tmp'
  
!   let ts=localtime()
!   sleep 1
!   let fl=['Hello World!']
    call writefile(fl, fname)
!   let tf=getftime(fname)
!   sleep 1
!   let te=localtime()
  
    call assert_true(ts <= tf && tf <= te)
    call assert_equal(strlen(fl[0] . "\n"), getfsize(fname))
    call assert_equal('file', getftype(fname))
    call assert_equal('rw-', getfperm(fname)[0:2])
  endfunc
  
  func Test_existent_directory()
!   let dname='.'
  
    call assert_equal(0, getfsize(dname))
    call assert_equal('dir', getftype(dname))
--- 1,24 ----
  " Tests for stat functions and checktime
  
  func Test_existent_file()
!   let fname = 'Xtest.tmp'
  
!   let ts = localtime()
!   let fl = ['Hello World!']
    call writefile(fl, fname)
!   let tf = getftime(fname)
!   let te = localtime()
  
    call assert_true(ts <= tf && tf <= te)
    call assert_equal(strlen(fl[0] . "\n"), getfsize(fname))
    call assert_equal('file', getftype(fname))
    call assert_equal('rw-', getfperm(fname)[0:2])
+ 
+   call delete(fname)
  endfunc
  
  func Test_existent_directory()
!   let dname = '.'
  
    call assert_equal(0, getfsize(dname))
    call assert_equal('dir', getftype(dname))
***************
*** 26,47 ****
  endfunc
  
  func Test_checktime()
!   let fname='Xtest.tmp'
  
!   let fl=['Hello World!']
    call writefile(fl, fname)
    set autoread
    exec 'e' fname
!   sleep 2
!   let fl=readfile(fname)
    let fl[0] .= ' - checktime'
    call writefile(fl, fname)
    checktime
    call assert_equal(fl[0], getline(1))
  endfunc
  
  func Test_nonexistent_file()
!   let fname='Xtest.tmp'
  
    call delete(fname)
    call assert_equal(-1, getftime(fname))
--- 26,54 ----
  endfunc
  
  func Test_checktime()
!   let fname = 'Xtest.tmp'
  
!   let fl = ['Hello World!']
    call writefile(fl, fname)
    set autoread
    exec 'e' fname
!   " FAT has a granularity of 2 seconds, otherwise it's usually 1 second
!   if has('win32')
!     sleep 2
!   else
!     sleep 1
!   endif
!   let fl = readfile(fname)
    let fl[0] .= ' - checktime'
    call writefile(fl, fname)
    checktime
    call assert_equal(fl[0], getline(1))
+ 
+   call delete(fname)
  endfunc
  
  func Test_nonexistent_file()
!   let fname = 'Xtest.tmp'
  
    call delete(fname)
    call assert_equal(-1, getftime(fname))
***************
*** 55,61 ****
    " So we use an existing symlink for this test.
    if has('win32')
      " Check if 'C:\Users\All Users' is a symlink to a directory.
!     let res=system('dir C:\Users /a')
      if match(res, '\C<SYMLINKD> *All Users') >= 0
        " Get the filetype of the symlink.
        call assert_equal('dir', getftype('C:\Users\All Users'))
--- 62,68 ----
    " So we use an existing symlink for this test.
    if has('win32')
      " Check if 'C:\Users\All Users' is a symlink to a directory.
!     let res = system('dir C:\Users /a')
      if match(res, '\C<SYMLINKD> *All Users') >= 0
        " Get the filetype of the symlink.
        call assert_equal('dir', getftype('C:\Users\All Users'))
*** ../vim-8.0.0291/src/version.c	2017-02-01 21:50:16.740465816 +0100
--- src/version.c	2017-02-01 22:04:27.674844474 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     292,
  /**/


-- 
Sorry, no fortune today.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0293
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0293
Problem:    Some tests have a one or three second wait.
Solution:   Reset the 'showmode' option.  Use a test time of one to disable
            sleep after an error or warning message.
Files:      src/misc1.c, src/testdir/runtest.vim, src/testdir/test_normal.vim


*** ../vim-8.0.0292/src/misc1.c	2017-02-01 13:14:11.022177046 +0100
--- src/misc1.c	2017-02-01 22:25:36.886478288 +0100
***************
*** 3264,3270 ****
  #endif
  	msg_clr_eos();
  	(void)msg_end();
! 	if (msg_silent == 0 && !silent_mode)
  	{
  	    out_flush();
  	    ui_delay(1000L, TRUE); /* give the user time to think about it */
--- 3264,3274 ----
  #endif
  	msg_clr_eos();
  	(void)msg_end();
! 	if (msg_silent == 0 && !silent_mode
! #ifdef FEAT_EVAL
! 		&& time_for_testing != 1
! #endif
! 		)
  	{
  	    out_flush();
  	    ui_delay(1000L, TRUE); /* give the user time to think about it */
*** ../vim-8.0.0292/src/testdir/runtest.vim	2017-02-01 20:48:09.037147485 +0100
--- src/testdir/runtest.vim	2017-02-01 22:12:36.159622270 +0100
***************
*** 57,65 ****
    set encoding=latin1
  endif
  
- " Avoid stopping at the "hit enter" prompt
- set nomore
- 
  " Output all messages in English.
  lang mess C
  
--- 57,62 ----
***************
*** 88,93 ****
--- 85,98 ----
  
  function RunTheTest(test)
    echo 'Executing ' . a:test
+ 
+   " Avoid stopping at the "hit enter" prompt
+   set nomore
+ 
+   " Avoid a three second wait when a message is about to be overwritten by the
+   " mode message.
+   set noshowmode
+ 
    if exists("*SetUp")
      try
        call SetUp()
*** ../vim-8.0.0292/src/testdir/test_normal.vim	2017-01-14 14:28:26.964592279 +0100
--- src/testdir/test_normal.vim	2017-02-01 22:24:52.238772490 +0100
***************
*** 2193,2198 ****
--- 2193,2200 ----
    if !has("autocmd")
      return
    endif
+   " Don't sleep after the warning message.
+   call test_settime(1)
    call writefile(['foo'], 'Xreadonly.log')
    new Xreadonly.log
    setl ro
***************
*** 2202,2207 ****
--- 2204,2210 ----
    call assert_equal('Xreadonly.log', bufname(''))
  
    " cleanup
+   call test_settime(0)
    bw!
    call delete("Xreadonly.log")
  endfunc
*** ../vim-8.0.0292/src/version.c	2017-02-01 22:05:22.598481671 +0100
--- src/version.c	2017-02-01 22:13:47.923149491 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     293,
  /**/

-- 
ARTHUR:  No, hang on!  Just answer the five questions ...
GALAHAD: Three questions ...
ARTHUR:  Three questions ...  And we shall watch ... and pray.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0294
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0294
Problem:    Argument list is not stored correctly in a session file.
            (lgpasquale)
Solution:   Use "$argadd" instead of "argadd". (closes #1434)
Files:      src/ex_docmd.c, src/testdir/test_mksession.vim


*** ../vim-8.0.0293/src/ex_docmd.c	2017-01-29 21:42:16.072015550 +0100
--- src/ex_docmd.c	2017-02-01 22:48:36.981387560 +0100
***************
*** 11790,11796 ****
  		    s = buf;
  		}
  	    }
! 	    if (fputs("argadd ", fd) < 0
  		    || ses_put_fname(fd, s, flagp) == FAIL
  		    || put_eol(fd) == FAIL)
  	    {
--- 11790,11796 ----
  		    s = buf;
  		}
  	    }
! 	    if (fputs("$argadd ", fd) < 0
  		    || ses_put_fname(fd, s, flagp) == FAIL
  		    || put_eol(fd) == FAIL)
  	    {
*** ../vim-8.0.0293/src/testdir/test_mksession.vim	2017-01-29 14:14:04.545800189 +0100
--- src/testdir/test_mksession.vim	2017-02-01 22:46:52.654074082 +0100
***************
*** 110,113 ****
--- 110,125 ----
    call delete('Xtest_mks.out')
  endfunc
  
+ func Test_mksession_arglist()
+   argdel *
+   next file1 file2 file3 file4
+   mksession! Xtest_mks.out
+   source Xtest_mks.out
+   call assert_equal(['file1', 'file2', 'file3', 'file4'], argv())
+ 
+   call delete('Xtest_mks.out')
+   argdel *
+ endfunc
+ 
+ 
  " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.0.0293/src/version.c	2017-02-01 22:31:45.112052371 +0100
--- src/version.c	2017-02-01 22:52:11.715974378 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     294,
  /**/

-- 
Permission is granted to read this message out aloud on Kings Cross Road,
London, under the condition that the orator is properly dressed.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0295
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0295 (after 8.0.0293)
Problem:    test_viml hangs.
Solution:   Put resetting 'more' before sourcing the script.
Files:      src/testdir/runtest.vim


*** ../vim-8.0.0294/src/testdir/runtest.vim	2017-02-01 22:31:45.112052371 +0100
--- src/testdir/runtest.vim	2017-02-01 23:15:31.614761181 +0100
***************
*** 57,62 ****
--- 57,65 ----
    set encoding=latin1
  endif
  
+ " Avoid stopping at the "hit enter" prompt
+ set nomore
+ 
  " Output all messages in English.
  lang mess C
  
***************
*** 168,174 ****
        \ ]
  
  " Locate Test_ functions and execute them.
- set nomore
  redir @q
  silent function /^Test_
  redir END
--- 171,176 ----
*** ../vim-8.0.0294/src/version.c	2017-02-01 22:52:38.747796468 +0100
--- src/version.c	2017-02-01 23:16:41.322302355 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     295,
  /**/

-- 
BRIDGEKEEPER: What is your favorite colour?
GAWAIN:       Blue ...  No yelloooooww!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0296
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0296
Problem:    Bracketed paste can only append, not insert.
Solution:   When the cursor is in the first column insert the text.
Files:      src/normal.c, src/testdir/test_paste.vim,  runtime/doc/term.txt


*** ../vim-8.0.0295/src/normal.c	2017-02-01 15:03:25.679840157 +0100
--- src/normal.c	2017-02-02 22:07:18.421078322 +0100
***************
*** 9079,9086 ****
  		    beginline(BL_WHITE|BL_FIX);
  		break;
  
  	    case 'a':	/* "a"ppend is like "i"nsert on the next character. */
- 	    case K_PS:	/* bracketed paste works like "a"ppend */
  #ifdef FEAT_VIRTUALEDIT
  		/* increment coladd when in virtual space, increment the
  		 * column otherwise, also to append after an unprintable char */
--- 9079,9091 ----
  		    beginline(BL_WHITE|BL_FIX);
  		break;
  
+ 	    case K_PS:	/* Bracketed paste works like "a"ppend, unless the
+ 			   cursor is in the first column, then it inserts. */
+ 		if (curwin->w_cursor.col == 0)
+ 		    break;
+ 		/*FALLTHROUGH*/
+ 
  	    case 'a':	/* "a"ppend is like "i"nsert on the next character. */
  #ifdef FEAT_VIRTUALEDIT
  		/* increment coladd when in virtual space, increment the
  		 * column otherwise, also to append after an unprintable char */
*** ../vim-8.0.0295/src/testdir/test_paste.vim	2017-01-25 21:36:11.626471765 +0100
--- src/testdir/test_paste.vim	2017-02-02 22:19:29.839954877 +0100
***************
*** 8,25 ****
  
  func Test_paste_normal_mode()
    new
    call setline(1, ['a', 'b', 'c'])
!   2
    call feedkeys("\<Esc>[200~foo\<CR>bar\<Esc>[201~", 'xt')
!   call assert_equal('bfoo', getline(2))
!   call assert_equal('bar', getline(3))
    call assert_equal('c', getline(4))
  
    normal .
    call assert_equal('barfoo', getline(3))
!   call assert_equal('bar', getline(4))
    call assert_equal('c', getline(5))
    bwipe!
  endfunc
  
  func Test_paste_insert_mode()
--- 8,43 ----
  
  func Test_paste_normal_mode()
    new
+   " In first column text is inserted
    call setline(1, ['a', 'b', 'c'])
!   call cursor(2, 1)
    call feedkeys("\<Esc>[200~foo\<CR>bar\<Esc>[201~", 'xt')
!   call assert_equal('foo', getline(2))
!   call assert_equal('barb', getline(3))
    call assert_equal('c', getline(4))
  
+   " When repeating text is appended
    normal .
    call assert_equal('barfoo', getline(3))
!   call assert_equal('barb', getline(4))
    call assert_equal('c', getline(5))
    bwipe!
+ 
+   " In second column text is appended
+   call setline(1, ['a', 'bbb', 'c'])
+   call cursor(2, 2)
+   call feedkeys("\<Esc>[200~foo\<CR>bar\<Esc>[201~", 'xt')
+   call assert_equal('bbfoo', getline(2))
+   call assert_equal('barb', getline(3))
+   call assert_equal('c', getline(4))
+ 
+   " In last column text is appended
+   call setline(1, ['a', 'bbb', 'c'])
+   call cursor(2, 3)
+   call feedkeys("\<Esc>[200~foo\<CR>bar\<Esc>[201~", 'xt')
+   call assert_equal('bbbfoo', getline(2))
+   call assert_equal('bar', getline(3))
+   call assert_equal('c', getline(4))
  endfunc
  
  func Test_paste_insert_mode()
*** ../vim-8.0.0295/runtime/doc/term.txt	2017-01-21 20:04:17.570757762 +0100
--- runtime/doc/term.txt	2017-02-02 22:10:44.115650386 +0100
***************
*** 95,105 ****
  terminal is then expected to put 't_PS' before pasted text and 't_PE' after
  pasted text.  This way Vim can separate text that is pasted from characters
  that are typed.  The pasted text is handled like when the middle mouse button
! is used.
  
  Note that in some situations Vim will not recognize the bracketed paste and
  you will get the raw text.  In other situations Vim will only get the first
! pasted character and drop the rest, e.g. when using the "r" command.
  
  							*cs7-problem*
  Note: If the terminal settings are changed after running Vim, you might have
--- 95,115 ----
  terminal is then expected to put 't_PS' before pasted text and 't_PE' after
  pasted text.  This way Vim can separate text that is pasted from characters
  that are typed.  The pasted text is handled like when the middle mouse button
! is used, it is inserted literally and not interpreted as commands.
! 
! When the cursor is in the first column, the pasted text will be inserted
! before it.  Otherwise the pasted text is appended after the cursor position.
! This means one cannot paste after the first column.  Unfortunately Vim does
! not have a way to tell where the mouse pointer was.
  
  Note that in some situations Vim will not recognize the bracketed paste and
  you will get the raw text.  In other situations Vim will only get the first
! pasted character and drop the rest, e.g. when using the "r" command.  If you
! have a problem with this, disable bracketed paste by putting this in your
! .vimrc: >
! 	set t_BE=
! If this is done while Vim is running the 't_BD' will be sent to the terminal
! to disable bracketed paste.
  
  							*cs7-problem*
  Note: If the terminal settings are changed after running Vim, you might have
***************
*** 414,420 ****
  	t_KK	<k8>		keypad 8		 *<k8>*	*t_KK* *'t_KK'*
  	t_KL	<k9>		keypad 9		 *<k9>*	*t_KL* *'t_KL'*
  		<Mouse>		leader of mouse code		*<Mouse>*
! 	t_PS	start of brackted paste |xterm-bracketed-paste|   *t_PS* 't_PS'
  	t_PE	end of bracketed paste |xterm-bracketed-paste|    *t_PE* 't_PE'
  
  Note about t_so and t_mr: When the termcap entry "so" is not present the
--- 424,430 ----
  	t_KK	<k8>		keypad 8		 *<k8>*	*t_KK* *'t_KK'*
  	t_KL	<k9>		keypad 9		 *<k9>*	*t_KL* *'t_KL'*
  		<Mouse>		leader of mouse code		*<Mouse>*
! 	t_PS	start of bracketed paste |xterm-bracketed-paste|  *t_PS* 't_PS'
  	t_PE	end of bracketed paste |xterm-bracketed-paste|    *t_PE* 't_PE'
  
  Note about t_so and t_mr: When the termcap entry "so" is not present the
*** ../vim-8.0.0295/src/version.c	2017-02-01 23:17:30.909975952 +0100
--- src/version.c	2017-02-02 22:12:14.879011783 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     296,
  /**/

-- 
Every person is responsible for the choices he makes.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0297
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0297
Problem:    Double free on exit when using a closure. (James McCoy)
Solution:   Split free_al_functions in two parts. (closes #1428)
Files:      src/userfunc.c, src/structs.h


*** ../vim-8.0.0296/src/userfunc.c	2017-02-01 20:26:45.769640496 +0100
--- src/userfunc.c	2017-02-02 22:56:09.536572550 +0100
***************
*** 1075,1086 ****
  }
  
  /*
!  * Free a function and remove it from the list of functions.
   * When "force" is TRUE we are exiting.
   */
      static void
! func_free(ufunc_T *fp, int force)
  {
      /* clear this function */
      ga_clear_strings(&(fp->uf_args));
      ga_clear_strings(&(fp->uf_lines));
--- 1075,1091 ----
  }
  
  /*
!  * Free all things that a function contains.  Does not free the function
!  * itself, use func_free() for that.
   * When "force" is TRUE we are exiting.
   */
      static void
! func_clear(ufunc_T *fp, int force)
  {
+     if (fp->uf_cleared)
+ 	return;
+     fp->uf_cleared = TRUE;
+ 
      /* clear this function */
      ga_clear_strings(&(fp->uf_args));
      ga_clear_strings(&(fp->uf_lines));
***************
*** 1089,1105 ****
      vim_free(fp->uf_tml_total);
      vim_free(fp->uf_tml_self);
  #endif
      /* only remove it when not done already, otherwise we would remove a newer
       * version of the function */
      if ((fp->uf_flags & (FC_DELETED | FC_REMOVED)) == 0)
  	func_remove(fp);
  
-     funccal_unref(fp->uf_scoped, fp, force);
- 
      vim_free(fp);
  }
  
  /*
   * There are two kinds of function names:
   * 1. ordinary names, function defined with :function
   * 2. numbered functions and lambdas
--- 1094,1129 ----
      vim_free(fp->uf_tml_total);
      vim_free(fp->uf_tml_self);
  #endif
+     funccal_unref(fp->uf_scoped, fp, force);
+ }
+ 
+ /*
+  * Free a function and remove it from the list of functions.  Does not free
+  * what a function contains, call func_clear() first.
+  */
+     static void
+ func_free(ufunc_T *fp)
+ {
      /* only remove it when not done already, otherwise we would remove a newer
       * version of the function */
      if ((fp->uf_flags & (FC_DELETED | FC_REMOVED)) == 0)
  	func_remove(fp);
  
      vim_free(fp);
  }
  
  /*
+  * Free all things that a function contains and free the function itself.
+  * When "force" is TRUE we are exiting.
+  */
+     static void
+ func_clear_free(ufunc_T *fp, int force)
+ {
+     func_clear(fp, force);
+     func_free(fp);
+ }
+ 
+ /*
   * There are two kinds of function names:
   * 1. ordinary names, function defined with :function
   * 2. numbered functions and lambdas
***************
*** 1120,1129 ****
      hashitem_T	*hi;
      ufunc_T	*fp;
      long_u	skipped = 0;
!     long_u	todo;
  
!     /* Need to start all over every time, because func_free() may change the
!      * hash table. */
      while (func_hashtab.ht_used > skipped)
      {
  	todo = func_hashtab.ht_used;
--- 1144,1183 ----
      hashitem_T	*hi;
      ufunc_T	*fp;
      long_u	skipped = 0;
!     long_u	todo = 1;
!     long_u	used;
! 
!     /* First clear what the functions contain.  Since this may lower the
!      * reference count of a function, it may also free a function and change
!      * the hash table. Restart if that happens. */
!     while (todo > 0)
!     {
! 	todo = func_hashtab.ht_used;
! 	for (hi = func_hashtab.ht_array; todo > 0; ++hi)
! 	    if (!HASHITEM_EMPTY(hi))
! 	    {
! 		/* Only free functions that are not refcounted, those are
! 		 * supposed to be freed when no longer referenced. */
! 		fp = HI2UF(hi);
! 		if (func_name_refcount(fp->uf_name))
! 		    ++skipped;
! 		else
! 		{
! 		    used = func_hashtab.ht_used;
! 		    func_clear(fp, TRUE);
! 		    if (used != func_hashtab.ht_used)
! 		    {
! 			skipped = 0;
! 			break;
! 		    }
! 		}
! 		--todo;
! 	    }
!     }
  
!     /* Now actually free the functions.  Need to start all over every time,
!      * because func_free() may change the hash table. */
!     skipped = 0;
      while (func_hashtab.ht_used > skipped)
      {
  	todo = func_hashtab.ht_used;
***************
*** 1138,1144 ****
  		    ++skipped;
  		else
  		{
! 		    func_free(fp, TRUE);
  		    skipped = 0;
  		    break;
  		}
--- 1192,1198 ----
  		    ++skipped;
  		else
  		{
! 		    func_free(fp);
  		    skipped = 0;
  		    break;
  		}
***************
*** 1356,1362 ****
  		    if (--fp->uf_calls <= 0 && fp->uf_refcount <= 0)
  			/* Function was unreferenced while being used, free it
  			 * now. */
! 			func_free(fp, FALSE);
  		    if (did_save_redo)
  			restoreRedobuff();
  		    restore_search_patterns();
--- 1410,1416 ----
  		    if (--fp->uf_calls <= 0 && fp->uf_refcount <= 0)
  			/* Function was unreferenced while being used, free it
  			 * now. */
! 			func_clear_free(fp, FALSE);
  		    if (did_save_redo)
  			restoreRedobuff();
  		    restore_search_patterns();
***************
*** 2756,2762 ****
  		fp->uf_flags |= FC_DELETED;
  	    }
  	    else
! 		func_free(fp, FALSE);
  	}
      }
  }
--- 2810,2816 ----
  		fp->uf_flags |= FC_DELETED;
  	    }
  	    else
! 		func_clear_free(fp, FALSE);
  	}
      }
  }
***************
*** 2785,2791 ****
  	/* Only delete it when it's not being used.  Otherwise it's done
  	 * when "uf_calls" becomes zero. */
  	if (fp->uf_calls == 0)
! 	    func_free(fp, FALSE);
      }
  }
  
--- 2839,2845 ----
  	/* Only delete it when it's not being used.  Otherwise it's done
  	 * when "uf_calls" becomes zero. */
  	if (fp->uf_calls == 0)
! 	    func_clear_free(fp, FALSE);
      }
  }
  
***************
*** 2801,2807 ****
  	/* Only delete it when it's not being used.  Otherwise it's done
  	 * when "uf_calls" becomes zero. */
  	if (fp->uf_calls == 0)
! 	    func_free(fp, FALSE);
      }
  }
  
--- 2855,2861 ----
  	/* Only delete it when it's not being used.  Otherwise it's done
  	 * when "uf_calls" becomes zero. */
  	if (fp->uf_calls == 0)
! 	    func_clear_free(fp, FALSE);
      }
  }
  
*** ../vim-8.0.0296/src/structs.h	2017-01-22 18:34:53.684030783 +0100
--- src/structs.h	2017-02-02 22:44:38.069397093 +0100
***************
*** 1337,1342 ****
--- 1337,1343 ----
      int		uf_varargs;	/* variable nr of arguments */
      int		uf_flags;
      int		uf_calls;	/* nr of active calls */
+     int		uf_cleared;	/* func_clear() was already called */
      garray_T	uf_args;	/* arguments */
      garray_T	uf_lines;	/* function lines */
  #ifdef FEAT_PROFILE
*** ../vim-8.0.0296/src/version.c	2017-02-02 22:20:49.279397163 +0100
--- src/version.c	2017-02-02 22:44:52.229298214 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     297,
  /**/

-- 
There is no right or wrong, there is only your personal opinion.
                 (Bram Moolenaar)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0298
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0298
Problem:    Ex command range with repeated search does not work. (Bruce
            DeVisser)
Solution:   Skip over \/, \? and \&.
Files:      src/ex_docmd.c, src/testdir/test_cmdline.vim


*** ../vim-8.0.0297/src/ex_docmd.c	2017-02-01 22:52:38.743796496 +0100
--- src/ex_docmd.c	2017-02-03 20:50:12.715505051 +0100
***************
*** 4357,4365 ****
  {
      unsigned	delim;
  
!     while (vim_strchr((char_u *)" \t0123456789.$%'/?-+,;", *cmd) != NULL)
      {
! 	if (*cmd == '\'')
  	{
  	    if (*++cmd == NUL && ctx != NULL)
  		*ctx = EXPAND_NOTHING;
--- 4357,4372 ----
  {
      unsigned	delim;
  
!     while (vim_strchr((char_u *)" \t0123456789.$%'/?-+,;\\", *cmd) != NULL)
      {
! 	if (*cmd == '\\')
! 	{
! 	    if (cmd[1] == '?' || cmd[1] == '/' || cmd[1] == '&')
! 		++cmd;
! 	    else
! 		break;
! 	}
! 	else if (*cmd == '\'')
  	{
  	    if (*++cmd == NUL && ctx != NULL)
  		*ctx = EXPAND_NOTHING;
*** ../vim-8.0.0297/src/testdir/test_cmdline.vim	2017-01-24 21:18:15.986024183 +0100
--- src/testdir/test_cmdline.vim	2017-02-03 20:57:23.740313582 +0100
***************
*** 306,308 ****
--- 306,333 ----
    call assert_equal(a, b)
    bw!
  endfunc
+ 
+ " using a leading backslash here
+ set cpo+=C
+ 
+ func Test_cmdline_search_range()
+   new
+   call setline(1, ['a', 'b', 'c', 'd'])
+   /d
+   1,\/s/b/B/
+   call assert_equal('B', getline(2))
+ 
+   /a
+   $
+   \?,4s/c/C/
+   call assert_equal('C', getline(3))
+ 
+   call setline(1, ['a', 'b', 'c', 'd'])
+   %s/c/c/
+   1,\&s/b/B/
+   call assert_equal('B', getline(2))
+ 
+   bwipe!
+ endfunc
+ 
+ set cpo&
*** ../vim-8.0.0297/src/version.c	2017-02-02 22:59:22.583226973 +0100
--- src/version.c	2017-02-03 20:39:38.840058102 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     298,
  /**/

-- 
The Law, in its majestic equality, forbids the rich, as well as the
poor, to sleep under the bridges, to beg in the streets, and to steal
bread.                       -- Anatole France

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0299
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0299
Problem:    When the GUI window is resized Vim does not always take over the
            new size. (Luchr)
Solution:   Reset new_p_guifont in gui_resize_shell().  Call
            gui_may_resize_shell() in the main loop.
Files:      src/main.c, src/gui.c


*** ../vim-8.0.0298/src/main.c	2016-11-24 15:09:03.405856662 +0100
--- src/main.c	2017-02-03 21:54:32.793578542 +0100
***************
*** 1118,1123 ****
--- 1118,1127 ----
  	    skip_redraw = FALSE;
  	else if (do_redraw || stuff_empty())
  	{
+ # ifdef FEAT_GUI
+ 	    /* If ui_breakcheck() was used a resize may have been postponed. */
+ 	    gui_may_resize_shell();
+ # endif
  #if defined(FEAT_AUTOCMD) || defined(FEAT_CONCEAL)
  	    /* Trigger CursorMoved if the cursor moved. */
  	    if (!finish_op && (
*** ../vim-8.0.0298/src/gui.c	2016-08-29 22:42:20.000000000 +0200
--- src/gui.c	2017-02-03 21:41:15.659646605 +0100
***************
*** 1459,1464 ****
--- 1459,1466 ----
      }
  
  again:
+     new_pixel_width = 0;
+     new_pixel_height = 0;
      busy = TRUE;
  
      /* Flush pending output before redrawing */
***************
*** 1468,1475 ****
      gui.num_rows = (pixel_height - gui_get_base_height()) / gui.char_height;
  
      gui_position_components(pixel_width);
- 
      gui_reset_scroll_region();
      /*
       * At the "more" and ":confirm" prompt there is no redraw, put the cursor
       * at the last line here (why does it have to be one row too low?).
--- 1470,1477 ----
      gui.num_rows = (pixel_height - gui_get_base_height()) / gui.char_height;
  
      gui_position_components(pixel_width);
      gui_reset_scroll_region();
+ 
      /*
       * At the "more" and ":confirm" prompt there is no redraw, put the cursor
       * at the last line here (why does it have to be one row too low?).
***************
*** 1491,1507 ****
  
      busy = FALSE;
  
!     /*
!      * We could have been called again while redrawing the screen.
!      * Need to do it all again with the latest size then.
!      */
      if (new_pixel_height)
      {
! 	pixel_width = new_pixel_width;
! 	pixel_height = new_pixel_height;
! 	new_pixel_width = 0;
! 	new_pixel_height = 0;
! 	goto again;
      }
  }
  
--- 1493,1514 ----
  
      busy = FALSE;
  
!     /* We may have been called again while redrawing the screen.
!      * Need to do it all again with the latest size then.  But only if the size
!      * actually changed. */
      if (new_pixel_height)
      {
! 	if (pixel_width == new_pixel_width && pixel_height == new_pixel_height)
! 	{
! 	    new_pixel_width = 0;
! 	    new_pixel_height = 0;
! 	}
! 	else
! 	{
! 	    pixel_width = new_pixel_width;
! 	    pixel_height = new_pixel_height;
! 	    goto again;
! 	}
      }
  }
  
***************
*** 1511,1528 ****
      void
  gui_may_resize_shell(void)
  {
-     int		h, w;
- 
      if (new_pixel_height)
-     {
  	/* careful: gui_resize_shell() may postpone the resize again if we
  	 * were called indirectly by it */
! 	w = new_pixel_width;
! 	h = new_pixel_height;
! 	new_pixel_width = 0;
! 	new_pixel_height = 0;
! 	gui_resize_shell(w, h);
!     }
  }
  
      int
--- 1518,1527 ----
      void
  gui_may_resize_shell(void)
  {
      if (new_pixel_height)
  	/* careful: gui_resize_shell() may postpone the resize again if we
  	 * were called indirectly by it */
! 	gui_resize_shell(new_pixel_width, new_pixel_height);
  }
  
      int
*** ../vim-8.0.0298/src/version.c	2017-02-03 21:19:00.289942006 +0100
--- src/version.c	2017-02-03 21:56:01.788913106 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     299,
  /**/

-- 
Citizens are not allowed to attend a movie house or theater nor ride in a
public streetcar within at least four hours after eating garlic.
		[real standing law in Indiana, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0300
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0300
Problem:    Cannot stop diffing hidden buffers. (Daniel Hahler)
Solution:   When using :diffoff! make the whole list if diffed buffers empty.
            (closes #736)
Files:      src/diff.c, src/testdir/test_diffmode.vim


*** ../vim-8.0.0299/src/diff.c	2016-10-18 14:50:14.731694041 +0200
--- src/diff.c	2017-02-03 22:53:01.787689761 +0100
***************
*** 139,144 ****
--- 139,161 ----
  }
  
  /*
+  * Remove all buffers to make diffs for.
+  */
+     static void
+ diff_buf_clear(void)
+ {
+     int		i;
+ 
+     for (i = 0; i < DB_COUNT; ++i)
+ 	if (curtab->tp_diffbuf[i] != NULL)
+ 	{
+ 	    curtab->tp_diffbuf[i] = NULL;
+ 	    curtab->tp_diff_invalid = TRUE;
+ 	    diff_redraw(TRUE);
+ 	}
+ }
+ 
+ /*
   * Find buffer "buf" in the list of diff buffers for the current tab page.
   * Return its index or DB_COUNT if not found.
   */
***************
*** 1257,1262 ****
--- 1274,1283 ----
  #endif
      }
  
+     /* Also remove hidden buffers from the list. */
+     if (eap->forceit)
+ 	diff_buf_clear();
+ 
  #ifdef FEAT_SCROLLBIND
      /* Remove "hor" from from 'scrollopt' if there are no diff windows left. */
      if (!diffwin && vim_strchr(p_sbo, 'h') != NULL)
*** ../vim-8.0.0299/src/testdir/test_diffmode.vim	2016-10-18 14:50:14.731694041 +0200
--- src/testdir/test_diffmode.vim	2017-02-03 23:14:15.230019873 +0100
***************
*** 212,217 ****
--- 212,218 ----
    call setline(1, ['One', '', 'Two', 'Three'])
    diffthis
    redraw
+   call assert_notequal(normattr, screenattr(1, 1))
    diffoff!
    redraw
    call assert_equal(normattr, screenattr(1, 1))
***************
*** 219,224 ****
--- 220,261 ----
    bwipe!
  endfunc
  
+ func Test_diffoff_hidden()
+   set diffopt=filler,foldcolumn:0
+   e! one
+   call setline(1, ['Two', 'Three'])
+   let normattr = screenattr(1, 1)
+   diffthis
+   botright vert new two
+   call setline(1, ['One', 'Four'])
+   diffthis
+   redraw
+   call assert_notequal(normattr, screenattr(1, 1))
+   set hidden
+   close
+   redraw
+   " diffing with hidden buffer two
+   call assert_notequal(normattr, screenattr(1, 1))
+   diffoff
+   redraw
+   call assert_equal(normattr, screenattr(1, 1))
+   diffthis
+   redraw
+   " still diffing with hidden buffer two
+   call assert_notequal(normattr, screenattr(1, 1))
+   diffoff!
+   redraw
+   call assert_equal(normattr, screenattr(1, 1))
+   diffthis
+   redraw
+   " no longer diffing with hidden buffer two
+   call assert_equal(normattr, screenattr(1, 1))
+ 
+   bwipe!
+   bwipe!
+   set hidden& diffopt&
+ endfunc
+ 
  func Test_setting_cursor()
    new Xtest1
    put =range(1,90)
*** ../vim-8.0.0299/src/version.c	2017-02-03 22:01:43.938349448 +0100
--- src/version.c	2017-02-03 23:15:47.253321836 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     300,
  /**/

-- 
Sometimes I think the surest sign that intelligent life exists elsewhere
in the universe is that none of it has tried to contact us.     (Calvin)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0301
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0301
Problem:    No tests for ":set completion" and various errors of the :set
            command.
Solution:   Add more :set tests. (Dominique Pelle, closes #1440)
Files:      src/testdir/test_options.vim


*** ../vim-8.0.0300/src/testdir/test_options.vim	2016-11-26 17:45:50.040909819 +0100
--- src/testdir/test_options.vim	2017-02-04 15:50:22.601111282 +0100
***************
*** 128,131 ****
--- 128,222 ----
  
  func Test_thesaurus()
    call Check_dir_option('thesaurus')
+ endfun
+ 
+ func Test_set_completion()
+   call feedkeys(":set di\<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"set dictionary diff diffexpr diffopt digraph directory display', @:)
+ 
+   " Expand boolan options. When doing :set no<Tab>
+   " vim displays the options names without "no" but completion uses "no...".
+   call feedkeys(":set nodi\<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"set nodiff digraph', @:)
+ 
+   call feedkeys(":set invdi\<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"set invdiff digraph', @:)
+ 
+   " Expand abbreviation of options.
+   call feedkeys(":set ts\<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"set tabstop thesaurus ttyscroll', @:)
+ 
+   " Expand current value
+   call feedkeys(":set fileencodings=\<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"set fileencodings=ucs-bom,utf-8,default,latin1', @:)
+ 
+   call feedkeys(":set fileencodings:\<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"set fileencodings:ucs-bom,utf-8,default,latin1', @:)
+ 
+   " Expand key codes.
+   call feedkeys(":set <H\<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"set <Help> <Home>', @:)
+ 
+   " Expand terminal options.
+   call feedkeys(":set t_A\<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"set t_AB t_AF t_AL', @:)
+ 
+   " Expand directories.
+   call feedkeys(":set cdpath=./\<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_match(' ./samples/ ', @:)
+   call assert_notmatch(' ./small.vim ', @:)
+ 
+   " Expand files and directories.
+   call feedkeys(":set tags=./\<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_match(' ./samples/.* ./small.vim', @:)
+ 
+   call feedkeys(":set tags=./\\\\ dif\<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"set tags=./\\ diff diffexpr diffopt', @:)
+ endfunc
+ 
+ func Test_set_errors()
+   call assert_fails('set scroll=-1', 'E49:')
+   call assert_fails('set backupcopy=', 'E474:')
+   call assert_fails('set regexpengine=3', 'E474:')
+   call assert_fails('set history=10001', 'E474:')
+   call assert_fails('set numberwidth=11', 'E474:')
+   call assert_fails('set colorcolumn=-a')
+   call assert_fails('set colorcolumn=a')
+   call assert_fails('set colorcolumn=1,')
+   call assert_fails('set cmdheight=-1', 'E487:')
+   call assert_fails('set cmdwinheight=-1', 'E487:')
+   if has('conceal')
+     call assert_fails('set conceallevel=-1', 'E487:')
+     call assert_fails('set conceallevel=4', 'E474:')
+   endif
+   call assert_fails('set helpheight=-1', 'E487:')
+   call assert_fails('set history=-1', 'E487:')
+   call assert_fails('set report=-1', 'E487:')
+   call assert_fails('set shiftwidth=-1', 'E487:')
+   call assert_fails('set sidescroll=-1', 'E487:')
+   call assert_fails('set tabstop=-1', 'E487:')
+   call assert_fails('set textwidth=-1', 'E487:')
+   call assert_fails('set timeoutlen=-1', 'E487:')
+   call assert_fails('set updatecount=-1', 'E487:')
+   call assert_fails('set updatetime=-1', 'E487:')
+   call assert_fails('set winheight=-1', 'E487:')
+   call assert_fails('set tabstop!', 'E488:')
+   call assert_fails('set xxx', 'E518:')
+   call assert_fails('set beautify?', 'E519:')
+   call assert_fails('set undolevels=x', 'E521:')
+   call assert_fails('set tabstop=', 'E521:')
+   call assert_fails('set comments=-', 'E524:')
+   call assert_fails('set comments=a', 'E525:')
+   call assert_fails('set foldmarker=x', 'E536:')
+   call assert_fails('set commentstring=x', 'E537:')
+   call assert_fails('set complete=x', 'E539:')
+   call assert_fails('set statusline=%{', 'E540:')
+   call assert_fails('set statusline=' . repeat("%p", 81), 'E541:')
+   call assert_fails('set statusline=%(', 'E542:')
+   call assert_fails('set guicursor=x', 'E545:')
+   call assert_fails('set backupext=~ patchmode=~', 'E589:')
+   call assert_fails('set winminheight=10 winheight=9', 'E591:')
+   call assert_fails('set winminwidth=10 winwidth=9', 'E592:')
+   call assert_fails("set showbreak=\x01", 'E595:')
+   call assert_fails('set t_foo=', 'E846:')
  endfunc
*** ../vim-8.0.0300/src/version.c	2017-02-03 23:16:24.349040487 +0100
--- src/version.c	2017-02-04 15:51:53.564452810 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     301,
  /**/

-- 
Kisses may last for as much as, but no more than, five minutes.
		[real standing law in Iowa, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0302
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0302
Problem:    Cannot set terminal key codes with :let.
Solution:   Make it work.
Files:      src/option.c, src/testdir/test_assign.vim


*** ../vim-8.0.0301/src/option.c	2017-01-28 15:58:45.348197250 +0100
--- src/option.c	2017-02-04 19:29:50.097068632 +0100
***************
*** 9197,9203 ****
--- 9197,9231 ----
  
      opt_idx = findoption(name);
      if (opt_idx < 0)		    /* unknown option */
+     {
+ 	int key;
+ 
+ 	if (STRLEN(name) == 4 && name[0] == 't' && name[1] == '_'
+ 		&& (key = find_key_option(name)) != 0)
+ 	{
+ 	    char_u key_name[2];
+ 	    char_u *p;
+ 
+ 	    if (key < 0)
+ 	    {
+ 		key_name[0] = KEY2TERMCAP0(key);
+ 		key_name[1] = KEY2TERMCAP1(key);
+ 	    }
+ 	    else
+ 	    {
+ 		key_name[0] = KS_KEY;
+ 		key_name[1] = (key & 0xff);
+ 	    }
+ 	    p = find_termcode(key_name);
+ 	    if (p != NULL)
+ 	    {
+ 		if (stringval != NULL)
+ 		    *stringval = vim_strsave(p);
+ 		return 0;
+ 	    }
+ 	}
  	return -3;
+     }
  
      varp = get_varp_scope(&(options[opt_idx]), opt_flags);
  
***************
*** 9455,9461 ****
--- 9483,9515 ----
  
      opt_idx = findoption(name);
      if (opt_idx < 0)
+     {
+ 	int key;
+ 
+ 	if (STRLEN(name) == 4 && name[0] == 't' && name[1] == '_'
+ 		&& (key = find_key_option(name)) != 0)
+ 	{
+ 	    char_u key_name[2];
+ 
+ 	    if (key < 0)
+ 	    {
+ 		key_name[0] = KEY2TERMCAP0(key);
+ 		key_name[1] = KEY2TERMCAP1(key);
+ 	    }
+ 	    else
+ 	    {
+ 		key_name[0] = KS_KEY;
+ 		key_name[1] = (key & 0xff);
+ 	    }
+ 	    add_termcode(key_name, string, FALSE);
+ 	    if (full_screen)
+ 		ttest(FALSE);
+ 	    redraw_all_later(CLEAR);
+ 	    return NULL;
+ 	}
+ 
  	EMSG2(_("E355: Unknown option: %s"), name);
+     }
      else
      {
  	flags = options[opt_idx].flags;
*** ../vim-8.0.0301/src/testdir/test_assign.vim	2016-03-12 18:59:21.000000000 +0100
--- src/testdir/test_assign.vim	2017-02-04 19:32:17.739978777 +0100
***************
*** 7,9 ****
--- 7,29 ----
    let v = 3.4
    let v = 'hello'
  endfunc
+ 
+ func Test_let_termcap()
+   " Terminal code
+   let old_t_te = &t_te
+   let &t_te = "\<Esc>[yes;"
+   call assert_match('t_te.*^[[yes;', execute("set termcap"))
+   let &t_te = old_t_te
+ 
+   " Key code
+   let old_t_k1 = &t_k1
+   let &t_k1 = "that"
+   call assert_match('t_k1.*that', execute("set termcap"))
+   let &t_k1 = old_t_k1
+ 
+   call assert_fails('let x = &t_xx', 'E15')
+   let &t_xx = "yes"
+   call assert_equal("yes", &t_xx)
+   let &t_xx = ""
+   call assert_fails('let x = &t_xx', 'E15')
+ endfunc
*** ../vim-8.0.0301/src/version.c	2017-02-04 15:53:27.759771102 +0100
--- src/version.c	2017-02-04 19:21:39.624690924 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     302,
  /**/

-- 
Biting someone with your natural teeth is "simple assault," while biting
someone with your false teeth is "aggravated assault."
		[real standing law in Louisana, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0303
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0303
Problem:    Bracketed paste does not work in Visual mode.
Solution:   Delete the text before pasting
Files:      src/normal.c, src/ops.c, src/proto/ops.pro,
            src/testdir/test_paste.vim


*** ../vim-8.0.0302/src/normal.c	2017-02-02 22:20:49.279397163 +0100
--- src/normal.c	2017-02-04 21:34:10.217657460 +0100
***************
*** 9050,9055 ****
--- 9050,9083 ----
  	    /* drop the pasted text */
  	    bracketed_paste(PASTE_INSERT, TRUE, NULL);
      }
+     else if (cap->cmdchar == K_PS && VIsual_active)
+     {
+ 	pos_T old_pos = curwin->w_cursor;
+ 	pos_T old_visual = VIsual;
+ 
+ 	/* In Visual mode the selected text is deleted. */
+ 	if (VIsual_mode == 'V' || curwin->w_cursor.lnum != VIsual.lnum)
+ 	{
+ 	    shift_delete_registers();
+ 	    cap->oap->regname = '1';
+ 	}
+ 	else
+ 	    cap->oap->regname = '-';
+ 	cap->cmdchar = 'd';
+ 	cap->nchar = NUL;
+ 	nv_operator(cap);
+ 	do_pending_operator(cap, 0, FALSE);
+ 	cap->cmdchar = K_PS;
+ 
+ 	/* When the last char in the line was deleted then append. Detect this
+ 	 * by checking if the cursor moved to before the Visual area. */
+ 	if (*ml_get_cursor() != NUL && lt(curwin->w_cursor, old_pos)
+ 					   && lt(curwin->w_cursor, old_visual))
+ 	    inc_cursor();
+ 
+ 	/* Insert to replace the deleted text with the pasted text. */
+ 	invoke_edit(cap, FALSE, cap->cmdchar, FALSE);
+     }
      else if (!checkclearopq(cap->oap))
      {
  	switch (cap->cmdchar)
***************
*** 9079,9086 ****
  		    beginline(BL_WHITE|BL_FIX);
  		break;
  
! 	    case K_PS:	/* Bracketed paste works like "a"ppend, unless the
! 			   cursor is in the first column, then it inserts. */
  		if (curwin->w_cursor.col == 0)
  		    break;
  		/*FALLTHROUGH*/
--- 9107,9115 ----
  		    beginline(BL_WHITE|BL_FIX);
  		break;
  
! 	    case K_PS:
! 		/* Bracketed paste works like "a"ppend, unless the cursor is in
! 		 * the first column, then it inserts. */
  		if (curwin->w_cursor.col == 0)
  		    break;
  		/*FALLTHROUGH*/
*** ../vim-8.0.0302/src/ops.c	2017-02-01 21:50:16.740465816 +0100
--- src/ops.c	2017-02-04 21:25:35.429506524 +0100
***************
*** 1628,1633 ****
--- 1628,1649 ----
  #endif
  
  /*
+  * Shift the delete registers: "9 is cleared, "8 becomes "9, etc.
+  */
+     void
+ shift_delete_registers()
+ {
+     int		n;
+ 
+     y_current = &y_regs[9];
+     free_yank_all();			/* free register nine */
+     for (n = 9; n > 1; --n)
+ 	y_regs[n] = y_regs[n - 1];
+     y_previous = y_current = &y_regs[1];
+     y_regs[1].y_array = NULL;		/* set register one to empty */
+ }
+ 
+ /*
   * Handle a delete operation.
   *
   * Return FAIL if undo failed, OK otherwise.
***************
*** 1739,1750 ****
  	if (orig_regname != 0 || oap->motion_type == MLINE
  				   || oap->line_count > 1 || oap->use_reg_one)
  	{
! 	    y_current = &y_regs[9];
! 	    free_yank_all();			/* free register nine */
! 	    for (n = 9; n > 1; --n)
! 		y_regs[n] = y_regs[n - 1];
! 	    y_previous = y_current = &y_regs[1];
! 	    y_regs[1].y_array = NULL;		/* set register one to empty */
  	    if (op_yank(oap, TRUE, FALSE) == OK)
  		did_yank = TRUE;
  	}
--- 1755,1761 ----
  	if (orig_regname != 0 || oap->motion_type == MLINE
  				   || oap->line_count > 1 || oap->use_reg_one)
  	{
! 	    shift_delete_registers();
  	    if (op_yank(oap, TRUE, FALSE) == OK)
  		did_yank = TRUE;
  	}
*** ../vim-8.0.0302/src/proto/ops.pro	2016-09-12 13:04:14.000000000 +0200
--- src/proto/ops.pro	2017-02-04 21:22:36.134848374 +0100
***************
*** 23,28 ****
--- 23,29 ----
  int get_spec_reg(int regname, char_u **argp, int *allocated, int errmsg);
  int cmdline_paste_reg(int regname, int literally, int remcr);
  void adjust_clip_reg(int *rp);
+ void shift_delete_registers(void);
  int op_delete(oparg_T *oap);
  int op_replace(oparg_T *oap, int c);
  void op_tilde(oparg_T *oap);
*** ../vim-8.0.0302/src/testdir/test_paste.vim	2017-02-02 22:20:49.279397163 +0100
--- src/testdir/test_paste.vim	2017-02-04 21:28:07.952365566 +0100
***************
*** 70,72 ****
--- 70,99 ----
    call feedkeys(":a\<Esc>[200~foo\<CR>bar\<Esc>[201~b\<Home>\"\<CR>", 'xt')
    call assert_equal("\"afoo\<CR>barb", getreg(':'))
  endfunc
+ 
+ func Test_paste_visual_mode()
+   new
+   call setline(1, 'here are some words')
+   call feedkeys("0fsve\<Esc>[200~more\<Esc>[201~", 'xt')
+   call assert_equal('here are more words', getline(1))
+   call assert_equal('some', getreg('-'))
+ 
+   " include last char in the line
+   call feedkeys("0fwve\<Esc>[200~noises\<Esc>[201~", 'xt')
+   call assert_equal('here are more noises', getline(1))
+   call assert_equal('words', getreg('-'))
+ 
+   " exclude last char in the line
+   call setline(1, 'some words!')
+   call feedkeys("0fwve\<Esc>[200~noises\<Esc>[201~", 'xt')
+   call assert_equal('some noises!', getline(1))
+   call assert_equal('words', getreg('-'))
+ 
+   " multi-line selection
+   call setline(1, ['some words', 'and more'])
+   call feedkeys("0fwvj0fd\<Esc>[200~letters\<Esc>[201~", 'xt')
+   call assert_equal('some letters more', getline(1))
+   call assert_equal("words\nand", getreg('1'))
+ 
+   bwipe!
+ endfunc
*** ../vim-8.0.0302/src/version.c	2017-02-04 19:49:10.940502929 +0100
--- src/version.c	2017-02-04 21:33:07.130128890 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     303,
  /**/

-- 
Why don't cannibals eat clowns?
Because they taste funny.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0304
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0304 (after 8.0.0302)
Problem:    Assign test fails in the GUI.
Solution:   Skip the test for setting t_k1.
Files:      src/testdir/test_assign.vim


*** ../vim-8.0.0303/src/testdir/test_assign.vim	2017-02-04 19:49:10.940502929 +0100
--- src/testdir/test_assign.vim	2017-02-04 21:47:00.863904307 +0100
***************
*** 15,25 ****
    call assert_match('t_te.*^[[yes;', execute("set termcap"))
    let &t_te = old_t_te
  
!   " Key code
!   let old_t_k1 = &t_k1
!   let &t_k1 = "that"
!   call assert_match('t_k1.*that', execute("set termcap"))
!   let &t_k1 = old_t_k1
  
    call assert_fails('let x = &t_xx', 'E15')
    let &t_xx = "yes"
--- 15,27 ----
    call assert_match('t_te.*^[[yes;', execute("set termcap"))
    let &t_te = old_t_te
  
!   if !has('gui_running')
!     " Key code
!     let old_t_k1 = &t_k1
!     let &t_k1 = "that"
!     call assert_match('t_k1.*that', execute("set termcap"))
!     let &t_k1 = old_t_k1
!   endif
  
    call assert_fails('let x = &t_xx', 'E15')
    let &t_xx = "yes"
*** ../vim-8.0.0303/src/version.c	2017-02-04 21:34:27.293529871 +0100
--- src/version.c	2017-02-04 21:49:32.422773989 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     304,
  /**/

-- 
bashian roulette:
$ ((RANDOM%6)) || rm -rf ~

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0305
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0305
Problem:    Invalid memory access when option has duplicate flag.
Solution:   Correct pointer computation. (Dominique Pelle, closes #1442)
Files:      src/option.c, src/testdir/test_options.vim


*** ../vim-8.0.0304/src/option.c	2017-02-04 19:49:10.940502929 +0100
--- src/option.c	2017-02-05 14:06:56.098695241 +0100
***************
*** 4954,4960 ****
  			    if (flags & P_FLAGLIST)
  			    {
  				/* Remove flags that appear twice. */
! 				for (s = newval; *s; ++s)
  				{
  				    /* if options have P_FLAGLIST and
  				     * P_ONECOMMA such as 'whichwrap' */
--- 4954,4960 ----
  			    if (flags & P_FLAGLIST)
  			    {
  				/* Remove flags that appear twice. */
! 				for (s = newval; *s;)
  				{
  				    /* if options have P_FLAGLIST and
  				     * P_ONECOMMA such as 'whichwrap' */
***************
*** 4966,4972 ****
  					    /* Remove the duplicated value and
  					     * the next comma. */
  					    STRMOVE(s, s + 2);
! 					    s -= 2;
  					}
  				    }
  				    else
--- 4966,4972 ----
  					    /* Remove the duplicated value and
  					     * the next comma. */
  					    STRMOVE(s, s + 2);
! 					    continue;
  					}
  				    }
  				    else
***************
*** 4975,4983 ****
  					      && vim_strchr(s + 1, *s) != NULL)
  					{
  					    STRMOVE(s, s + 1);
! 					    --s;
  					}
  				    }
  				}
  			    }
  
--- 4975,4984 ----
  					      && vim_strchr(s + 1, *s) != NULL)
  					{
  					    STRMOVE(s, s + 1);
! 					    continue;
  					}
  				    }
+ 				    ++s;
  				}
  			    }
  
*** ../vim-8.0.0304/src/testdir/test_options.vim	2017-02-04 15:53:27.755771131 +0100
--- src/testdir/test_options.vim	2017-02-05 14:06:56.098695241 +0100
***************
*** 13,18 ****
--- 13,24 ----
    set whichwrap+=h,l
    call assert_equal('b,s,h,l', &whichwrap)
  
+   set whichwrap=h,h
+   call assert_equal('h', &whichwrap)
+ 
+   set whichwrap=h,h,h
+   call assert_equal('h', &whichwrap)
+ 
    set whichwrap&
  endfunction
  
*** ../vim-8.0.0304/src/version.c	2017-02-04 21:50:14.226462278 +0100
--- src/version.c	2017-02-05 13:36:08.883777002 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     305,
  /**/

-- 
Yesterday, all my deadlines seemed so far away
now it looks as though it's freeze in four days
oh I believe in cvs..
    [ CVS log "Beatles style" for FreeBSD ports/INDEX, Satoshi Asami ]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0306
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0306
Problem:    mode() not sufficiently tested.
Solution:   Add more tests. (Yegappan Lakshmanan)
Files:      src/testdir/test_functions.vim


*** ../vim-8.0.0305/src/testdir/test_functions.vim	2017-02-01 17:24:29.681328124 +0100
--- src/testdir/test_functions.vim	2017-02-05 13:46:26.547402404 +0100
***************
*** 320,358 ****
--- 320,392 ----
    normal! 3G
    exe "normal i\<F2>\<Esc>"
    call assert_equal('i-i', g:current_modes)
+   " i_CTRL-P: Multiple matches
    exe "normal i\<C-G>uBa\<C-P>\<F2>\<Esc>u"
    call assert_equal('i-ic', g:current_modes)
+   " i_CTRL-P: Single match
    exe "normal iBro\<C-P>\<F2>\<Esc>u"
    call assert_equal('i-ic', g:current_modes)
+   " i_CTRL-X
    exe "normal iBa\<C-X>\<F2>\<Esc>u"
    call assert_equal('i-ix', g:current_modes)
+   " i_CTRL-X CTRL-P: Multiple matches
    exe "normal iBa\<C-X>\<C-P>\<F2>\<Esc>u"
    call assert_equal('i-ic', g:current_modes)
+   " i_CTRL-X CTRL-P: Single match
    exe "normal iBro\<C-X>\<C-P>\<F2>\<Esc>u"
    call assert_equal('i-ic', g:current_modes)
+   " i_CTRL-X CTRL-P + CTRL-P: Single match
    exe "normal iBro\<C-X>\<C-P>\<C-P>\<F2>\<Esc>u"
    call assert_equal('i-ic', g:current_modes)
+   " i_CTRL-X CTRL-L: Multiple matches
+   exe "normal i\<C-X>\<C-L>\<F2>\<Esc>u"
+   call assert_equal('i-ic', g:current_modes)
+   " i_CTRL-X CTRL-L: Single match
+   exe "normal iBlu\<C-X>\<C-L>\<F2>\<Esc>u"
+   call assert_equal('i-ic', g:current_modes)
+   " i_CTRL-P: No match
    exe "normal iCom\<C-P>\<F2>\<Esc>u"
    call assert_equal('i-ic', g:current_modes)
+   " i_CTRL-X CTRL-P: No match
    exe "normal iCom\<C-X>\<C-P>\<F2>\<Esc>u"
    call assert_equal('i-ic', g:current_modes)
+   " i_CTRL-X CTRL-L: No match
+   exe "normal iabc\<C-X>\<C-L>\<F2>\<Esc>u"
+   call assert_equal('i-ic', g:current_modes)
  
+   " R_CTRL-P: Multiple matches
    exe "normal RBa\<C-P>\<F2>\<Esc>u"
    call assert_equal('R-Rc', g:current_modes)
+   " R_CTRL-P: Single match
    exe "normal RBro\<C-P>\<F2>\<Esc>u"
    call assert_equal('R-Rc', g:current_modes)
+   " R_CTRL-X
    exe "normal RBa\<C-X>\<F2>\<Esc>u"
    call assert_equal('R-Rx', g:current_modes)
+   " R_CTRL-X CTRL-P: Multiple matches
    exe "normal RBa\<C-X>\<C-P>\<F2>\<Esc>u"
    call assert_equal('R-Rc', g:current_modes)
+   " R_CTRL-X CTRL-P: Single match
    exe "normal RBro\<C-X>\<C-P>\<F2>\<Esc>u"
    call assert_equal('R-Rc', g:current_modes)
+   " R_CTRL-X CTRL-P + CTRL-P: Single match
    exe "normal RBro\<C-X>\<C-P>\<C-P>\<F2>\<Esc>u"
    call assert_equal('R-Rc', g:current_modes)
+   " R_CTRL-X CTRL-L: Multiple matches
+   exe "normal R\<C-X>\<C-L>\<F2>\<Esc>u"
+   call assert_equal('R-Rc', g:current_modes)
+   " R_CTRL-X CTRL-L: Single match
+   exe "normal RBlu\<C-X>\<C-L>\<F2>\<Esc>u"
+   call assert_equal('R-Rc', g:current_modes)
+   " R_CTRL-P: No match
    exe "normal RCom\<C-P>\<F2>\<Esc>u"
    call assert_equal('R-Rc', g:current_modes)
+   " R_CTRL-X CTRL-P: No match
    exe "normal RCom\<C-X>\<C-P>\<F2>\<Esc>u"
    call assert_equal('R-Rc', g:current_modes)
+   " R_CTRL-X CTRL-L: No match
+   exe "normal Rabc\<C-X>\<C-L>\<F2>\<Esc>u"
+   call assert_equal('R-Rc', g:current_modes)
  
    call assert_equal('n', mode(0))
    call assert_equal('n', mode(1))
*** ../vim-8.0.0305/src/version.c	2017-02-05 14:13:12.152033013 +0100
--- src/version.c	2017-02-05 14:14:03.375670407 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     306,
  /**/

-- 
There are only two hard things in programming: Cache invalidation,
naming things and off-by-one errors.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0307
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0307
Problem:    Asan detects a memory error when EXITFREE is defined. (Dominique
            Pelle)
Solution:   In getvcol() check for ml_get_buf() returning an empty string.
            Also skip adjusting the scroll position.  Set "exiting" in
            mch_exit() for all systems.
Files:      src/charset.c, src/window.c, src/os_mswin.c, src/os_win32.c,
            src/os_amiga.c


*** ../vim-8.0.0306/src/charset.c	2017-01-28 16:39:15.876735290 +0100
--- src/charset.c	2017-02-05 15:04:12.194299674 +0100
***************
*** 1296,1301 ****
--- 1296,1305 ----
  	posptr = NULL;  /* continue until the NUL */
      else
      {
+ 	/* Special check for an empty line, which can happen on exit, when
+ 	 * ml_get_buf() always returns an empty string. */
+ 	if (*ptr == NUL)
+ 	    pos->col = 0;
  	posptr = ptr + pos->col;
  #ifdef FEAT_MBYTE
  	if (has_mbyte)
*** ../vim-8.0.0306/src/window.c	2016-11-13 14:31:36.691499383 +0100
--- src/window.c	2017-02-05 14:38:05.893459335 +0100
***************
*** 5708,5714 ****
      wp->w_height = height;
      wp->w_skipcol = 0;
  
!     scroll_to_fraction(wp, prev_height);
  }
  
      void
--- 5708,5717 ----
      wp->w_height = height;
      wp->w_skipcol = 0;
  
!     /* There is no point in adjusting the scroll position when exiting.  Some
!      * values might be invalid. */
!     if (!exiting)
! 	scroll_to_fraction(wp, prev_height);
  }
  
      void
*** ../vim-8.0.0306/src/os_mswin.c	2017-02-01 13:43:32.534844945 +0100
--- src/os_mswin.c	2017-02-05 14:42:20.799648341 +0100
***************
*** 201,206 ****
--- 201,208 ----
      void
  mch_exit(int r)
  {
+     exiting = TRUE;
+ 
      display_errors();
  
      ml_close_all(TRUE);		/* remove all memfiles */
*** ../vim-8.0.0306/src/os_win32.c	2017-02-01 13:43:32.530844971 +0100
--- src/os_win32.c	2017-02-05 14:44:19.470801368 +0100
***************
*** 2538,2545 ****
      void
  mch_exit(int r)
  {
!     stoptermcap();
  
      if (g_fWindInitCalled)
  	settmode(TMODE_COOK);
  
--- 2538,2546 ----
      void
  mch_exit(int r)
  {
!     exiting = TRUE;
  
+     stoptermcap();
      if (g_fWindInitCalled)
  	settmode(TMODE_COOK);
  
*** ../vim-8.0.0306/src/os_amiga.c	2016-09-29 15:18:51.355768041 +0200
--- src/os_amiga.c	2017-02-05 14:44:41.490644233 +0100
***************
*** 889,894 ****
--- 889,896 ----
      void
  mch_exit(int r)
  {
+     exiting = TRUE;
+ 
      if (raw_in)			    /* put terminal in 'normal' mode */
      {
  	settmode(TMODE_COOK);
*** ../vim-8.0.0306/src/version.c	2017-02-05 14:15:24.587095534 +0100
--- src/version.c	2017-02-05 14:44:57.906527094 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     307,
  /**/

-- 
What do you get when you cross a joke with a rehtorical question?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0308
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0308
Problem:    When using a symbolic link, the package path will not be inserted
            at the right position in 'runtimepath'. (Dugan Chen, Norio Takagi)
Solution:   Resolve symbolic links when finding the right position in
            'runtimepath'. (Hirohito Higashi)
Files:      src/ex_cmds2.c, src/testdir/test_packadd.vim


*** ../vim-8.0.0307/src/ex_cmds2.c	2017-01-28 15:58:45.344197275 +0100
--- src/ex_cmds2.c	2017-02-05 15:51:53.705843565 +0100
***************
*** 3509,3514 ****
--- 3509,3517 ----
      size_t  afterlen = 0;
      char_u  *ffname = fix_fname(fname);
      size_t  fname_len;
+     char_u  *buf = NULL;
+     char_u  *rtp_ffname;
+     int	    match;
  
      if (ffname == NULL)
  	return;
***************
*** 3533,3558 ****
  	/* Find "ffname" in "p_rtp", ignoring '/' vs '\' differences. */
  	fname_len = STRLEN(ffname);
  	insp = p_rtp;
! 	for (;;)
  	{
! 	    if (vim_fnamencmp(insp, ffname, fname_len) == 0)
! 		break;
! 	    insp = vim_strchr(insp, ',');
! 	    if (insp == NULL)
  		break;
- 	    ++insp;
  	}
  
! 	if (insp == NULL)
  	    /* not found, append at the end */
  	    insp = p_rtp + STRLEN(p_rtp);
  	else
- 	{
  	    /* append after the matching directory. */
! 	    insp += STRLEN(ffname);
! 	    while (*insp != NUL && *insp != ',')
! 		++insp;
! 	}
  	*p4 = c;
  
  	/* check if rtp/pack/name/start/name/after exists */
--- 3536,3563 ----
  	/* Find "ffname" in "p_rtp", ignoring '/' vs '\' differences. */
  	fname_len = STRLEN(ffname);
  	insp = p_rtp;
! 	buf = alloc(MAXPATHL);
! 	if (buf == NULL)
! 	    goto theend;
! 	while (*insp != NUL)
  	{
! 	    copy_option_part(&insp, buf, MAXPATHL, ",");
! 	    add_pathsep(buf);
! 	    rtp_ffname = fix_fname(buf);
! 	    if (rtp_ffname == NULL)
! 		goto theend;
! 	    match = vim_fnamencmp(rtp_ffname, ffname, fname_len) == 0;
! 	    vim_free(rtp_ffname);
! 	    if (match)
  		break;
  	}
  
! 	if (*insp == NUL)
  	    /* not found, append at the end */
  	    insp = p_rtp + STRLEN(p_rtp);
  	else
  	    /* append after the matching directory. */
! 	    --insp;
  	*p4 = c;
  
  	/* check if rtp/pack/name/start/name/after exists */
***************
*** 3562,3568 ****
  
  	oldlen = STRLEN(p_rtp);
  	addlen = STRLEN(ffname) + 1; /* add one for comma */
! 	new_rtp = alloc((int)(oldlen + addlen + afterlen + 1)); /* add one for NUL */
  	if (new_rtp == NULL)
  	    goto theend;
  	keep = (int)(insp - p_rtp);
--- 3567,3574 ----
  
  	oldlen = STRLEN(p_rtp);
  	addlen = STRLEN(ffname) + 1; /* add one for comma */
! 	new_rtp = alloc((int)(oldlen + addlen + afterlen + 1));
! 							  /* add one for NUL */
  	if (new_rtp == NULL)
  	    goto theend;
  	keep = (int)(insp - p_rtp);
***************
*** 3616,3621 ****
--- 3622,3628 ----
      }
  
  theend:
+     vim_free(buf);
      vim_free(ffname);
  }
  
*** ../vim-8.0.0307/src/testdir/test_packadd.vim	2016-05-24 19:30:39.000000000 +0200
--- src/testdir/test_packadd.vim	2017-02-05 16:00:10.802317583 +0100
***************
*** 67,72 ****
--- 67,105 ----
    call assert_equal(new_rtp, &rtp)
  endfunc
  
+ func Test_packadd_symlink_dir()
+   if !has('unix')
+ 	  return
+   endif
+   let top2_dir = s:topdir . '/Xdir2'
+   let real_dir = s:topdir . '/Xsym'
+   silent !ln -s real_dir top2_dir
+   let &rtp = top2_dir . ',' . top2_dir . '/after'
+   let &packpath = &rtp
+ 
+   let s:plugdir = top2_dir . '/pack/mine/opt/mytest'
+   call mkdir(s:plugdir . '/plugin', 'p')
+ 
+   exe 'split ' . s:plugdir . '/plugin/test.vim'
+   call setline(1, 'let g:plugin_works = 44')
+   wq
+   let g:plugin_works = 0
+ 
+   packadd mytest
+ 
+   " Must have been inserted in the middle, not at the end
+   call assert_true(&rtp =~ '/pack/mine/opt/mytest,')
+   call assert_equal(44, g:plugin_works)
+ 
+   " No change when doing it again.
+   let rtp_before = &rtp
+   packadd mytest
+   call assert_equal(rtp_before, &rtp)
+ 
+   set rtp&
+   let rtp = &rtp
+ endfunc
+ 
  " Check command-line completion for 'packadd'
  func Test_packadd_completion()
    let optdir1 = &packpath . '/pack/mine/opt'
*** ../vim-8.0.0307/src/version.c	2017-02-05 15:10:47.747484014 +0100
--- src/version.c	2017-02-05 15:41:48.494171300 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     308,
  /**/

-- 
Zen Microsystems: we're the om in .commmmmmmmm

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0309
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0309
Problem:    Cannot use an empty key in json.
Solution:   Allow for using an empty key.
Files:      src/json.c, src/testdir/test_json.vim


*** ../vim-8.0.0308/src/json.c	2017-01-22 15:56:21.692532206 +0100
--- src/json.c	2017-02-05 16:30:19.049590182 +0100
***************
*** 863,869 ****
  		    && cur_item != NULL)
  	    {
  		top_item->jd_key = get_tv_string_buf_chk(cur_item, key_buf);
! 		if (top_item->jd_key == NULL || *top_item->jd_key == NUL)
  		{
  		    clear_tv(cur_item);
  		    EMSG(_(e_invarg));
--- 863,869 ----
  		    && cur_item != NULL)
  	    {
  		top_item->jd_key = get_tv_string_buf_chk(cur_item, key_buf);
! 		if (top_item->jd_key == NULL)
  		{
  		    clear_tv(cur_item);
  		    EMSG(_(e_invarg));
*** ../vim-8.0.0308/src/testdir/test_json.vim	2017-01-14 14:36:03.229775080 +0100
--- src/testdir/test_json.vim	2017-02-05 16:30:42.945421728 +0100
***************
*** 144,149 ****
--- 144,154 ----
    call assert_equal(type(v:none), type(json_decode('')))
    call assert_equal("", json_decode('""'))
  
+   " empty key is OK
+   call assert_equal({'': 'ok'}, json_decode('{"": "ok"}'))
+   " but not twice
+   call assert_fails("call json_decode('{\"\": \"ok\", \"\": \"bad\"}')", 'E938:')
+ 
    call assert_equal({'n': 1}, json_decode('{"n":1,}'))
    call assert_fails("call json_decode(\"{'n':'1',}\")", 'E474:')
    call assert_fails("call json_decode(\"'n'\")", 'E474:')
*** ../vim-8.0.0308/src/version.c	2017-02-05 16:07:50.291087646 +0100
--- src/version.c	2017-02-05 16:34:19.755896838 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     309,
  /**/

-- 
Beer & pretzels can't be served at the same time in any bar or restaurant.
		[real standing law in North Dakota, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0310
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0310
Problem:    Not enough testing for GUI functionality.
Solution:   Add tests for v:windowid and getwinpos[xy](). (Kazunobu Kuriyama)
Files:      src/testdir/test_gui.vim


*** ../vim-8.0.0309/src/testdir/test_gui.vim	2017-02-01 12:32:54.422023552 +0100
--- src/testdir/test_gui.vim	2017-02-05 20:45:33.749109561 +0100
***************
*** 4,9 ****
--- 4,12 ----
    finish
  endif
  
+ let s:x11_based_gui = has('gui_athena') || has('gui_motif')
+ 	\ || has('gui_gtk2') || has('gui_gnome') || has('gui_gtk3')
+ 
  " For KDE set a font, empty 'guifont' may cause a hang.
  func SetUp()
    if has("gui_kde")
***************
*** 32,41 ****
    call assert_equal(1, has('gui_running'))
  endfunc
  
  func Test_shell_command()
    new
    r !echo hello
    call assert_equal('hello', substitute(getline(2), '\W', '', 'g'))
    bwipe!
-   call assert_true(1, match(execute('winpos'), 'Window position: X \d\+, Y \d\+') >= 0)
  endfunc
--- 35,57 ----
    call assert_equal(1, has('gui_running'))
  endfunc
  
+ func Test_getwinpos()
+   call assert_match('Window position: X \d\+, Y \d\+', execute('winpos'))
+   call assert_true(getwinposx() >= 0)
+   call assert_true(getwinposy() >= 0)
+ endfunction
+ 
  func Test_shell_command()
    new
    r !echo hello
    call assert_equal('hello', substitute(getline(2), '\W', '', 'g'))
    bwipe!
  endfunc
+ 
+ func Test_windowid_variable()
+   if s:x11_based_gui || has('win32')
+     call assert_true(v:windowid > 0)
+   else
+     call assert_equal(0, v:windowid)
+   endif
+ endfunction
*** ../vim-8.0.0309/src/version.c	2017-02-05 16:34:39.263759703 +0100
--- src/version.c	2017-02-05 20:46:26.636674746 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     310,
  /**/

-- 
Dogs must have a permit signed by the mayor in order to congregate in groups
of three or more on private property.
		[real standing law in Oklahoma, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0311
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0311
Problem:    Linebreak tests are old style.
Solution:   Turn the tests into new style. Share utility functions. (Ozaki
            Kiichi, closes #1444)
Files:      src/Makefile, src/testdir/Make_all.mak,
            src/testdir/test_breakindent.vim, src/testdir/test_listlbr.in,
            src/testdir/test_listlbr.ok, src/testdir/test_listlbr.vim,
            src/testdir/test_listlbr_utf8.in,
            src/testdir/test_listlbr_utf8.ok,
            src/testdir/test_listlbr_utf8.vim, src/testdir/view_util.vim


*** ../vim-8.0.0310/src/Makefile	2017-02-01 20:53:18.659092738 +0100
--- src/Makefile	2017-02-05 20:59:31.158395013 +0100
***************
*** 2072,2079 ****
  	test_getcwd \
  	test_insertcount \
  	test_listchars \
- 	test_listlbr \
- 	test_listlbr_utf8 \
  	test_search_mbyte \
  	test_wordcount \
  	test3 test4 test5 test6 test7 test8 test9 \
--- 2072,2077 ----
***************
*** 2148,2153 ****
--- 2146,2153 ----
  	test_langmap \
  	test_largefile \
  	test_lispwords \
+ 	test_listlbr \
+ 	test_listlbr_utf8 \
  	test_lua \
  	test_man \
  	test_mapping \
*** ../vim-8.0.0310/src/testdir/Make_all.mak	2017-01-29 23:26:12.926595799 +0100
--- src/testdir/Make_all.mak	2017-02-05 20:59:31.158395013 +0100
***************
*** 82,88 ****
  	test_getcwd.out \
  	test_insertcount.out \
  	test_listchars.out \
- 	test_listlbr.out \
  	test_search_mbyte.out \
  	test_wordcount.out
  
--- 82,87 ----
***************
*** 101,108 ****
  	test12.out \
  	test25.out \
  	test49.out \
! 	test97.out \
! 	test_listlbr_utf8.out
  
  
  # Tests that run on most systems, but not MingW and Cygwin.
--- 100,106 ----
  	test12.out \
  	test25.out \
  	test49.out \
! 	test97.out
  
  
  # Tests that run on most systems, but not MingW and Cygwin.
***************
*** 164,169 ****
--- 162,169 ----
  	    test_job_fails.res \
  	    test_json.res \
  	    test_langmap.res \
+ 	    test_listlbr.res \
+ 	    test_listlbr_utf8.res \
  	    test_lua.res \
  	    test_man.res \
  	    test_marks.res \
*** ../vim-8.0.0310/src/testdir/test_breakindent.vim	2016-11-17 19:32:17.897024245 +0100
--- src/testdir/test_breakindent.vim	2017-02-05 21:10:11.053368573 +0100
***************
*** 2,172 ****
  "
  " Note: if you get strange failures when adding new tests, it might be that
  " while the test is run, the breakindent cacheing gets in its way.
! " It helps to change the tabastop setting and force a redraw (e.g. see
  " Test_breakindent08())
  if !exists('+breakindent')
    finish
  endif
  
  let s:input ="\tabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOP"
  
! function s:screenline(lnum, width) abort
!   " always get 4 screen lines
!   redraw!
!   let line = []
!   for j in range(3)
!     for c in range(1, a:width)
!   call add(line, nr2char(screenchar(a:lnum+j, c)))
!     endfor
!     call add(line, "\n")
!   endfor
!   return join(line, '')
  endfunction
  
! function s:testwindows(...)
!   10new
!   vsp
!   vert resize 20
!   setl ts=4 sw=4 sts=4 breakindent 
    put =s:input
!   if a:0
!     exe a:1
!   endif
  endfunction
  
  function s:close_windows(...)
!   bw!
!   if a:0
!     exe a:1
!   endif
!   unlet! g:line g:expect
  endfunction
  
  function Test_breakindent01()
    " simple breakindent test
!   call s:testwindows('setl briopt=min:0')
!   let g:line=s:screenline(line('.'),8)
!   let g:expect="    abcd\n    qrst\n    GHIJ\n"
!   call assert_equal(g:expect, g:line)
    call s:close_windows()
  endfunction
  
  function Test_breakindent02()
    " simple breakindent test with showbreak set
!   call s:testwindows('setl briopt=min:0 sbr=>>')
!   let g:line=s:screenline(line('.'),8)
!   let g:expect="    abcd\n    >>qr\n    >>EF\n"
!   call assert_equal(g:expect, g:line)
    call s:close_windows('set sbr=')
  endfunction
  
  function Test_breakindent03()
    " simple breakindent test with showbreak set and briopt including sbr
!   call s:testwindows('setl briopt=sbr,min:0 sbr=++')
!   let g:line=s:screenline(line('.'),8)
!   let g:expect="    abcd\n++  qrst\n++  GHIJ\n"
!   call assert_equal(g:expect, g:line)
    " clean up
    call s:close_windows('set sbr=')
  endfunction
  
  function Test_breakindent04()
    " breakindent set with min width 18
!   call s:testwindows('setl sbr= briopt=min:18')
!   let g:line=s:screenline(line('.'),8)
!   let g:expect="    abcd\n  qrstuv\n  IJKLMN\n"
!   call assert_equal(g:expect, g:line)
    " clean up
    call s:close_windows('set sbr=')
  endfunction
  
  function Test_breakindent05()
    " breakindent set and shift by 2
!   call s:testwindows('setl briopt=shift:2,min:0')
!   let g:line=s:screenline(line('.'),8)
!   let g:expect="    abcd\n      qr\n      EF\n"
!   call assert_equal(g:expect, g:line)
    call s:close_windows()
  endfunction
  
  function Test_breakindent06()
    " breakindent set and shift by -1
!   call s:testwindows('setl briopt=shift:-1,min:0')
!   let g:line=s:screenline(line('.'),8)
!   let g:expect="    abcd\n   qrstu\n   HIJKL\n"
!   call assert_equal(g:expect, g:line)
    call s:close_windows()
  endfunction
  
  function Test_breakindent07()
    " breakindent set and shift by 1, Number  set sbr=? and briopt:sbr
!   call s:testwindows('setl briopt=shift:1,sbr,min:0 nu sbr=? nuw=4 cpo+=n')
!   let g:line=s:screenline(line('.'),10)
!   let g:expect="  2     ab\n?        m\n?        x\n"
!   call assert_equal(g:expect, g:line)
    " clean up
    call s:close_windows('set sbr= cpo-=n')
  endfunction
  
  function Test_breakindent07a()
    " breakindent set and shift by 1, Number  set sbr=? and briopt:sbr
!   call s:testwindows('setl briopt=shift:1,sbr,min:0 nu sbr=? nuw=4')
!   let g:line=s:screenline(line('.'),10)
!   let g:expect="  2     ab\n    ?    m\n    ?    x\n"
!   call assert_equal(g:expect, g:line)
    " clean up
    call s:close_windows('set sbr=')
  endfunction
  
  function Test_breakindent08()
    " breakindent set and shift by 1, Number and list set sbr=# and briopt:sbr
!   call s:testwindows('setl briopt=shift:1,sbr,min:0 nu nuw=4 sbr=# list cpo+=n ts=4')
    " make sure, cache is invalidated!
    set ts=8
    redraw!
    set ts=4
    redraw!
!   let g:line=s:screenline(line('.'),10)
!   let g:expect="  2 ^Iabcd\n#      opq\n#      BCD\n"
!   call assert_equal(g:expect, g:line)
    call s:close_windows('set sbr= cpo-=n')
  endfunction
  
  function Test_breakindent08a()
    " breakindent set and shift by 1, Number and list set sbr=# and briopt:sbr
!   call s:testwindows('setl briopt=shift:1,sbr,min:0 nu nuw=4 sbr=# list')
!   let g:line=s:screenline(line('.'),10)
!   let g:expect="  2 ^Iabcd\n    #  opq\n    #  BCD\n"
!   call assert_equal(g:expect, g:line)
    call s:close_windows('set sbr=')
  endfunction
  
  function Test_breakindent09()
    " breakindent set and shift by 1, Number and list set sbr=#
!   call s:testwindows('setl briopt=shift:1,min:0 nu nuw=4 sbr=# list')
!   let g:line=s:screenline(line('.'),10)
!   let g:expect="  2 ^Iabcd\n       #op\n       #AB\n"
!   call assert_equal(g:expect, g:line)
    call s:close_windows('set sbr=')
  endfunction
  
  function Test_breakindent10()
    " breakindent set, Number set sbr=~
!   call s:testwindows('setl cpo+=n sbr=~ nu nuw=4 nolist briopt=sbr,min:0')
    " make sure, cache is invalidated!
    set ts=8
    redraw!
    set ts=4
    redraw!
!   let g:line=s:screenline(line('.'),10)
!   let g:expect="  2     ab\n~       mn\n~       yz\n"
!   call assert_equal(g:expect, g:line)
    call s:close_windows('set sbr= cpo-=n')
  endfunction
  
  function Test_breakindent11()
    " test strdisplaywidth()
!   call s:testwindows('setl cpo-=n sbr=>> nu nuw=4 nolist briopt= ts=4')
    let text=getline(2)
    let width = strlen(text[1:])+indent(2)+strlen(&sbr)*3 " text wraps 3 times
    call assert_equal(width, strdisplaywidth(text))
--- 2,210 ----
  "
  " Note: if you get strange failures when adding new tests, it might be that
  " while the test is run, the breakindent cacheing gets in its way.
! " It helps to change the tabstop setting and force a redraw (e.g. see
  " Test_breakindent08())
  if !exists('+breakindent')
    finish
  endif
  
+ source view_util.vim
+ 
  let s:input ="\tabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOP"
  
! function s:screen_lines(lnum, width) abort
!   return ScreenLines([a:lnum, a:lnum + 2], a:width)
  endfunction
  
! function! s:compare_lines(expect, actual)
!   call assert_equal(join(a:expect, "\n"), join(a:actual, "\n"))
! endfunction
! 
! function s:test_windows(...)
!   call NewWindow(10, 20)
!   setl ts=4 sw=4 sts=4 breakindent
    put =s:input
!   exe get(a:000, 0, '')
  endfunction
  
  function s:close_windows(...)
!   call CloseWindow()
!   exe get(a:000, 0, '')
  endfunction
  
  function Test_breakindent01()
    " simple breakindent test
!   call s:test_windows('setl briopt=min:0')
!   let lines=s:screen_lines(line('.'),8)
!   let expect=[
! \ "    abcd",
! \ "    qrst",
! \ "    GHIJ",
! \ ]
!   call s:compare_lines(expect, lines)
    call s:close_windows()
  endfunction
  
  function Test_breakindent02()
    " simple breakindent test with showbreak set
!   call s:test_windows('setl briopt=min:0 sbr=>>')
!   let lines=s:screen_lines(line('.'),8)
!   let expect=[
! \ "    abcd",
! \ "    >>qr",
! \ "    >>EF",
! \ ]
!   call s:compare_lines(expect, lines)
    call s:close_windows('set sbr=')
  endfunction
  
  function Test_breakindent03()
    " simple breakindent test with showbreak set and briopt including sbr
!   call s:test_windows('setl briopt=sbr,min:0 sbr=++')
!   let lines=s:screen_lines(line('.'),8)
!   let expect=[
! \ "    abcd",
! \ "++  qrst",
! \ "++  GHIJ",
! \ ]
!   call s:compare_lines(expect, lines)
    " clean up
    call s:close_windows('set sbr=')
  endfunction
  
  function Test_breakindent04()
    " breakindent set with min width 18
!   call s:test_windows('setl sbr= briopt=min:18')
!   let lines=s:screen_lines(line('.'),8)
!   let expect=[
! \ "    abcd",
! \ "  qrstuv",
! \ "  IJKLMN",
! \ ]
!   call s:compare_lines(expect, lines)
    " clean up
    call s:close_windows('set sbr=')
  endfunction
  
  function Test_breakindent05()
    " breakindent set and shift by 2
!   call s:test_windows('setl briopt=shift:2,min:0')
!   let lines=s:screen_lines(line('.'),8)
!   let expect=[
! \ "    abcd",
! \ "      qr",
! \ "      EF",
! \ ]
!   call s:compare_lines(expect, lines)
    call s:close_windows()
  endfunction
  
  function Test_breakindent06()
    " breakindent set and shift by -1
!   call s:test_windows('setl briopt=shift:-1,min:0')
!   let lines=s:screen_lines(line('.'),8)
!   let expect=[
! \ "    abcd",
! \ "   qrstu",
! \ "   HIJKL",
! \ ]
!   call s:compare_lines(expect, lines)
    call s:close_windows()
  endfunction
  
  function Test_breakindent07()
    " breakindent set and shift by 1, Number  set sbr=? and briopt:sbr
!   call s:test_windows('setl briopt=shift:1,sbr,min:0 nu sbr=? nuw=4 cpo+=n')
!   let lines=s:screen_lines(line('.'),10)
!   let expect=[
! \ "  2     ab",
! \ "?        m",
! \ "?        x",
! \ ]
!   call s:compare_lines(expect, lines)
    " clean up
    call s:close_windows('set sbr= cpo-=n')
  endfunction
  
  function Test_breakindent07a()
    " breakindent set and shift by 1, Number  set sbr=? and briopt:sbr
!   call s:test_windows('setl briopt=shift:1,sbr,min:0 nu sbr=? nuw=4')
!   let lines=s:screen_lines(line('.'),10)
!   let expect=[
! \ "  2     ab",
! \ "    ?    m",
! \ "    ?    x",
! \ ]
!   call s:compare_lines(expect, lines)
    " clean up
    call s:close_windows('set sbr=')
  endfunction
  
  function Test_breakindent08()
    " breakindent set and shift by 1, Number and list set sbr=# and briopt:sbr
!   call s:test_windows('setl briopt=shift:1,sbr,min:0 nu nuw=4 sbr=# list cpo+=n ts=4')
    " make sure, cache is invalidated!
    set ts=8
    redraw!
    set ts=4
    redraw!
!   let lines=s:screen_lines(line('.'),10)
!   let expect=[
! \ "  2 ^Iabcd",
! \ "#      opq",
! \ "#      BCD",
! \ ]
!   call s:compare_lines(expect, lines)
    call s:close_windows('set sbr= cpo-=n')
  endfunction
  
  function Test_breakindent08a()
    " breakindent set and shift by 1, Number and list set sbr=# and briopt:sbr
!   call s:test_windows('setl briopt=shift:1,sbr,min:0 nu nuw=4 sbr=# list')
!   let lines=s:screen_lines(line('.'),10)
!   let expect=[
! \ "  2 ^Iabcd",
! \ "    #  opq",
! \ "    #  BCD",
! \ ]
!   call s:compare_lines(expect, lines)
    call s:close_windows('set sbr=')
  endfunction
  
  function Test_breakindent09()
    " breakindent set and shift by 1, Number and list set sbr=#
!   call s:test_windows('setl briopt=shift:1,min:0 nu nuw=4 sbr=# list')
!   let lines=s:screen_lines(line('.'),10)
!   let expect=[
! \ "  2 ^Iabcd",
! \ "       #op",
! \ "       #AB",
! \ ]
!   call s:compare_lines(expect, lines)
    call s:close_windows('set sbr=')
  endfunction
  
  function Test_breakindent10()
    " breakindent set, Number set sbr=~
!   call s:test_windows('setl cpo+=n sbr=~ nu nuw=4 nolist briopt=sbr,min:0')
    " make sure, cache is invalidated!
    set ts=8
    redraw!
    set ts=4
    redraw!
!   let lines=s:screen_lines(line('.'),10)
!   let expect=[
! \ "  2     ab",
! \ "~       mn",
! \ "~       yz",
! \ ]
!   call s:compare_lines(expect, lines)
    call s:close_windows('set sbr= cpo-=n')
  endfunction
  
  function Test_breakindent11()
    " test strdisplaywidth()
!   call s:test_windows('setl cpo-=n sbr=>> nu nuw=4 nolist briopt= ts=4')
    let text=getline(2)
    let width = strlen(text[1:])+indent(2)+strlen(&sbr)*3 " text wraps 3 times
    call assert_equal(width, strdisplaywidth(text))
***************
*** 176,191 ****
  function Test_breakindent12()
    " test breakindent with long indent
    let s:input="\t\t\t\t\t{"
!   call s:testwindows('setl breakindent linebreak briopt=min:10 nu numberwidth=3 ts=4 list listchars=tab:>-')
!   let g:line=s:screenline(2,16)
!   let g:expect=" 2 >--->--->--->\n          ---{  \n~               \n"
!   call assert_equal(g:expect, g:line)
    call s:close_windows('set nuw=4 listchars=')
  endfunction
  
  function Test_breakindent13()
    let s:input=""
!   call s:testwindows('setl breakindent briopt=min:10 ts=8')
    vert resize 20
    call setline(1, ["    a\tb\tc\td\te", "    z   y       x       w       v"])
    1
--- 214,233 ----
  function Test_breakindent12()
    " test breakindent with long indent
    let s:input="\t\t\t\t\t{"
!   call s:test_windows('setl breakindent linebreak briopt=min:10 nu numberwidth=3 ts=4 list listchars=tab:>-')
!   let lines=s:screen_lines(2,16)
!   let expect=[
! \ " 2 >--->--->--->",
! \ "          ---{  ",
! \ "~               ",
! \ ]
!   call s:compare_lines(expect, lines)
    call s:close_windows('set nuw=4 listchars=')
  endfunction
  
  function Test_breakindent13()
    let s:input=""
!   call s:test_windows('setl breakindent briopt=min:10 ts=8')
    vert resize 20
    call setline(1, ["    a\tb\tc\td\te", "    z   y       x       w       v"])
    1
***************
*** 199,224 ****
  
  function Test_breakindent14()
    let s:input=""
!   call s:testwindows('setl breakindent briopt= ts=8')
    vert resize 30
    norm! 3a1234567890
    norm! a    abcde
    exec "norm! 0\<C-V>tex"
!   let g:line=s:screenline(line('.'),8)
!   let g:expect="e       \n~       \n~       \n"
!   call assert_equal(g:expect, g:line)
    call s:close_windows()
  endfunction
  
  function Test_breakindent15()
    let s:input=""
!   call s:testwindows('setl breakindent briopt= ts=8 sw=8')
    vert resize 30
    norm! 4a1234567890
    exe "normal! >>\<C-V>3f0x"
!   let g:line=s:screenline(line('.'),20)
!   let g:expect="        1234567890  \n~                   \n~                   \n"
!   call assert_equal(g:expect, g:line)
    call s:close_windows()
  endfunction
  
--- 241,274 ----
  
  function Test_breakindent14()
    let s:input=""
!   call s:test_windows('setl breakindent briopt= ts=8')
    vert resize 30
    norm! 3a1234567890
    norm! a    abcde
    exec "norm! 0\<C-V>tex"
!   let lines=s:screen_lines(line('.'),8)
!   let expect=[
! \ "e       ",
! \ "~       ",
! \ "~       ",
! \ ]
!   call s:compare_lines(expect, lines)
    call s:close_windows()
  endfunction
  
  function Test_breakindent15()
    let s:input=""
!   call s:test_windows('setl breakindent briopt= ts=8 sw=8')
    vert resize 30
    norm! 4a1234567890
    exe "normal! >>\<C-V>3f0x"
!   let lines=s:screen_lines(line('.'),20)
!   let expect=[
! \ "        1234567890  ",
! \ "~                   ",
! \ "~                   ",
! \ ]
!   call s:compare_lines(expect, lines)
    call s:close_windows()
  endfunction
  
***************
*** 226,241 ****
    " Check that overlong lines are indented correctly.
    " TODO: currently it does not fail even when the bug is not fixed.
    let s:input=""
!   call s:testwindows('setl breakindent briopt=min:0 ts=4')
    call setline(1, "\t".repeat("1234567890", 10))
    resize 6
    norm! 1gg$
    redraw!
!   let g:line=s:screenline(1,10)
!   let g:expect="    123456\n    789012\n    345678\n"
!   call assert_equal(g:expect, g:line)
!   let g:line=s:screenline(4,10)
!   let g:expect="    901234\n    567890\n    123456\n"
!   call assert_equal(g:expect, g:line)
    call s:close_windows()
  endfunction
--- 276,299 ----
    " Check that overlong lines are indented correctly.
    " TODO: currently it does not fail even when the bug is not fixed.
    let s:input=""
!   call s:test_windows('setl breakindent briopt=min:0 ts=4')
    call setline(1, "\t".repeat("1234567890", 10))
    resize 6
    norm! 1gg$
    redraw!
!   let lines=s:screen_lines(1,10)
!   let expect=[
! \ "    123456",
! \ "    789012",
! \ "    345678",
! \ ]
!   call s:compare_lines(expect, lines)
!   let lines=s:screen_lines(4,10)
!   let expect=[
! \ "    901234",
! \ "    567890",
! \ "    123456",
! \ ]
!   call s:compare_lines(expect, lines)
    call s:close_windows()
  endfunction
*** ../vim-8.0.0310/src/testdir/test_listlbr.in	2015-12-17 21:04:04.000000000 +0100
--- src/testdir/test_listlbr.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,119 ****
- Test for linebreak and list option (non-utf8)
- 
- STARTTEST
- :so small.vim
- :if !exists("+linebreak") || !has("conceal") | e! test.ok | w! test.out | qa! | endif
- :10new|:vsp|:vert resize 20
- :put =\"\tabcdef hijklmn\tpqrstuvwxyz_1060ABCDEFGHIJKLMNOP \"
- :norm! zt
- :set ts=4 sw=4 sts=4 linebreak sbr=+ wrap
- :fu! ScreenChar(width)
- :	let c=''
- :	for j in range(1,4)
- :	    for i in range(1,a:width)
- :	    	let c.=nr2char(screenchar(j, i))
- :	    endfor
- :           let c.="\n"
- :	endfor
- :	return c
- :endfu
- :fu! DoRecordScreen()
- :	wincmd l
- :	$put =printf(\"\n%s\", g:test)
- :	$put =g:line
- :	wincmd p
- :endfu
- :"
- :let g:test="Test 1: set linebreak"
- :redraw!
- :let line=ScreenChar(winwidth(0))
- :call DoRecordScreen()
- :"
- :let g:test="Test 2: set linebreak + set list"
- :set linebreak list listchars=
- :redraw!
- :let line=ScreenChar(winwidth(0))
- :call DoRecordScreen()
- :"
- :let g:test ="Test 3: set linebreak nolist"
- :set nolist linebreak
- :redraw!
- :let line=ScreenChar(winwidth(0))
- :call DoRecordScreen()
- :"
- :let g:test ="Test 4: set linebreak with tab and 1 line as long as screen: should break!"
- :set nolist linebreak ts=8
- :let line="1\t".repeat('a', winwidth(0)-2)
- :$put =line
- :$
- :norm! zt
- :redraw!
- :let line=ScreenChar(winwidth(0))
- :call DoRecordScreen()
- :let line="_S_\t bla"
- :$put =line
- :$
- :norm! zt
- :"
- :let g:test ="Test 5: set linebreak with conceal and set list and tab displayed by different char (line may not be truncated)"
- :set cpo&vim list linebreak conceallevel=2 concealcursor=nv listchars=tab:ab
- :syn match ConcealVar contained /_/ conceal
- :syn match All /.*/ contains=ConcealVar
- :let line=ScreenChar(winwidth(0))
- :call DoRecordScreen()
- :set cpo&vim linebreak
- :"
- :let g:test ="Test 6: set linebreak with visual block mode"
- :let line="REMOVE: this not"
- :$put =g:test
- :$put =line
- :let line="REMOVE: aaaaaaaaaaaaa"
- :$put =line
- :1/^REMOVE:
- 0jf x:$put
- :set cpo&vim linebreak
- :"
- :let g:test ="Test 7: set linebreak with visual block mode and v_b_A"
- :$put =g:test
- Golong line: 40afoobar aTARGET at end
- :exe "norm! $3B\<C-v>eAx\<Esc>"
- :set cpo&vim linebreak sbr=
- :"
- :let g:test ="Test 8: set linebreak with visual char mode and changing block"
- :$put =g:test
- Go1111-1111-1111-11-1111-1111-11110f-lv3lc2222bgj.
- :"
- :let g:test ="Test 9: using redo after block visual mode"
- :$put =g:test
- Go
- aaa
- aaa
- a2k2j~e.
- :"
- :let g:test ="Test 10: using normal commands after block-visual"
- :$put =g:test
- :set linebreak
- Go
- abcd{ef
- ghijklm
- no}pqrs2k0f{c%
- :"
- :let g:test ="Test 11: using block replace mode after wrapping"
- :$put =g:test
- :set linebreak wrap
- Go150aayypk147|jr0
- :"
- :let g:test ="Test 12: set linebreak list listchars=space:_,tab:>-,tail:-,eol:$"
- :set list listchars=space:_,trail:-,tab:>-,eol:$
- :$put =g:test
- :let line="a aaaaaaaaaaaaaaaaaaaaaa\ta "
- :$put =line
- :$
- :norm! zt
- :redraw!
- :let line=ScreenChar(winwidth(0))
- :call DoRecordScreen()
- :%w! test.out
- :qa!
- ENDTEST
- dummy text
--- 0 ----
*** ../vim-8.0.0310/src/testdir/test_listlbr.ok	2015-12-17 21:04:04.000000000 +0100
--- src/testdir/test_listlbr.ok	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,62 ****
- 
- 	abcdef hijklmn	pqrstuvwxyz_1060ABCDEFGHIJKLMNOP 
- 
- Test 1: set linebreak
-     abcdef          
- +hijklmn            
- +pqrstuvwxyz_1060ABC
- +DEFGHIJKLMNOP      
- 
- Test 2: set linebreak + set list
- ^Iabcdef hijklmn^I  
- +pqrstuvwxyz_1060ABC
- +DEFGHIJKLMNOP      
-                     
- 
- Test 3: set linebreak nolist
-     abcdef          
- +hijklmn            
- +pqrstuvwxyz_1060ABC
- +DEFGHIJKLMNOP      
- 1	aaaaaaaaaaaaaaaaaa
- 
- Test 4: set linebreak with tab and 1 line as long as screen: should break!
- 1                   
- +aaaaaaaaaaaaaaaaaa 
- ~                   
- ~                   
- _S_	 bla
- 
- Test 5: set linebreak with conceal and set list and tab displayed by different char (line may not be truncated)
- Sabbbbbb bla        
- ~                   
- ~                   
- ~                   
- Test 6: set linebreak with visual block mode
- this not
- aaaaaaaaaaaaa
- REMOVE: 
- REMOVE: 
- Test 7: set linebreak with visual block mode and v_b_A
- long line: foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar TARGETx at end
- Test 8: set linebreak with visual char mode and changing block
- 1111-2222-1111-11-1111-2222-1111
- Test 9: using redo after block visual mode
- 
- AaA
- AaA
- A
- Test 10: using normal commands after block-visual
- 
- abcdpqrs
- Test 11: using block replace mode after wrapping
- aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa0aaa
- aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa0aaa
- Test 12: set linebreak list listchars=space:_,tab:>-,tail:-,eol:$
- a aaaaaaaaaaaaaaaaaaaaaa	a 
- 
- Test 12: set linebreak list listchars=space:_,tab:>-,tail:-,eol:$
- a_                  
- aaaaaaaaaaaaaaaaaaaa
- aa>-----a-$         
- ~                   
--- 0 ----
*** ../vim-8.0.0310/src/testdir/test_listlbr.vim	2017-02-05 21:14:00.419562659 +0100
--- src/testdir/test_listlbr.vim	2017-02-05 20:59:31.158395013 +0100
***************
*** 0 ****
--- 1,219 ----
+ " Test for linebreak and list option (non-utf8)
+ 
+ set encoding=latin1
+ scriptencoding latin1
+ 
+ if !exists("+linebreak") || !has("conceal")
+   finish
+ endif
+ 
+ source view_util.vim
+ 
+ function s:screen_lines(lnum, width) abort
+   return ScreenLines(a:lnum, a:width)
+ endfunction
+ 
+ function! s:compare_lines(expect, actual)
+   call assert_equal(join(a:expect, "\n"), join(a:actual, "\n"))
+ endfunction
+ 
+ function s:test_windows(...)
+   call NewWindow(10, 20)
+   setl ts=8 sw=4 sts=4 linebreak sbr= wrap
+   exe get(a:000, 0, '')
+ endfunction
+ 
+ function s:close_windows(...)
+   call CloseWindow()
+   exe get(a:000, 0, '')
+ endfunction
+ 
+ func Test_set_linebreak()
+   call s:test_windows('setl ts=4 sbr=+')
+   call setline(1, "\tabcdef hijklmn\tpqrstuvwxyz_1060ABCDEFGHIJKLMNOP ")
+   let lines = s:screen_lines([1, 4], winwidth(0))
+   let expect = [
+ \ "    abcdef          ",
+ \ "+hijklmn            ",
+ \ "+pqrstuvwxyz_1060ABC",
+ \ "+DEFGHIJKLMNOP      ",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows()
+ endfunc
+ 
+ func Test_linebreak_with_list()
+   call s:test_windows('setl ts=4 sbr=+ list listchars=')
+   call setline(1, "\tabcdef hijklmn\tpqrstuvwxyz_1060ABCDEFGHIJKLMNOP ")
+   let lines = s:screen_lines([1, 4], winwidth(0))
+   let expect = [
+ \ "^Iabcdef hijklmn^I  ",
+ \ "+pqrstuvwxyz_1060ABC",
+ \ "+DEFGHIJKLMNOP      ",
+ \ "~                   ",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows()
+ endfunc
+ 
+ func Test_linebreak_with_nolist()
+   call s:test_windows('setl ts=4 sbr=+ nolist')
+   call setline(1, "\tabcdef hijklmn\tpqrstuvwxyz_1060ABCDEFGHIJKLMNOP ")
+   let lines = s:screen_lines([1, 4], winwidth(0))
+   let expect = [
+ \ "    abcdef          ",
+ \ "+hijklmn            ",
+ \ "+pqrstuvwxyz_1060ABC",
+ \ "+DEFGHIJKLMNOP      ",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows()
+ endfunc
+ 
+ func Test_should_break()
+   call s:test_windows('setl sbr=+ nolist')
+   call setline(1, "1\t" . repeat('a', winwidth(0)-2))
+   let lines = s:screen_lines([1, 4], winwidth(0))
+   let expect = [
+ \ "1                   ",
+ \ "+aaaaaaaaaaaaaaaaaa ",
+ \ "~                   ",
+ \ "~                   ",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows()
+ endfunc
+ 
+ func Test_linebreak_with_conceal()
+   call s:test_windows('setl cpo&vim sbr=+ list conceallevel=2 concealcursor=nv listchars=tab:ab')
+   call setline(1, "_S_\t bla")
+   syn match ConcealVar contained /_/ conceal
+   syn match All /.*/ contains=ConcealVar
+   let lines = s:screen_lines([1, 4], winwidth(0))
+   let expect = [
+ \ "Sabbbbbb bla        ",
+ \ "~                   ",
+ \ "~                   ",
+ \ "~                   ",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows()
+ endfunc
+ 
+ func Test_virtual_block()
+   call s:test_windows('setl sbr=+')
+   call setline(1, [
+ \ "REMOVE: this not",
+ \ "REMOVE: aaaaaaaaaaaaa",
+ \ ])
+   exe "norm! 1/^REMOVE:"
+   exe "norm! 0\<C-V>jf x"
+   $put
+   let lines = s:screen_lines([1, 4], winwidth(0))
+   let expect = [
+ \ "this not            ",
+ \ "aaaaaaaaaaaaa       ",
+ \ "REMOVE:             ",
+ \ "REMOVE:             ",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows()
+ endfunc
+ 
+ func Test_virtual_block_and_vbA()
+   call s:test_windows()
+   call setline(1, "long line: " . repeat("foobar ", 40) . "TARGET at end")
+   exe "norm! $3B\<C-v>eAx\<Esc>"
+   let lines = s:screen_lines([1, 10], winwidth(0))
+   let expect = [
+ \ "foobar foobar       ",
+ \ "foobar foobar       ",
+ \ "foobar foobar       ",
+ \ "foobar foobar       ",
+ \ "foobar foobar       ",
+ \ "foobar foobar       ",
+ \ "foobar foobar       ",
+ \ "foobar foobar       ",
+ \ "foobar foobar       ",
+ \ "foobar TARGETx at   ",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows()
+ endfunc
+ 
+ func Test_virtual_char_and_block()
+   call s:test_windows()
+   call setline(1, "1111-1111-1111-11-1111-1111-1111")
+   exe "norm! 0f-lv3lc2222\<Esc>bgj."
+   let lines = s:screen_lines([1, 2], winwidth(0))
+   let expect = [
+ \ "1111-2222-1111-11-  ",
+ \ "1111-2222-1111      ",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows()
+ endfunc
+ 
+ func Test_undo_after_block_visual()
+   call s:test_windows()
+   call setline(1, ["aaa", "aaa", "a"])
+   exe "norm! gg\<C-V>2j~e."
+   let lines = s:screen_lines([1, 3], winwidth(0))
+   let expect = [
+ \ "AaA                 ",
+ \ "AaA                 ",
+ \ "A                   ",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows()
+ endfunc
+ 
+ func Test_norm_after_block_visual()
+   call s:test_windows()
+   call setline(1, ["abcd{ef", "ghijklm", "no}pgrs"])
+   exe "norm! ggf{\<C-V>\<C-V>c%"
+   let lines = s:screen_lines([1, 3], winwidth(0))
+   let expect = [
+ \ "abcdpgrs            ",
+ \ "~                   ",
+ \ "~                   ",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows()
+ endfunc
+ 
+ func Test_block_replace_after_wrapping()
+   call s:test_windows()
+   call setline(1, repeat("a", 150))
+   exe "norm! 0yypk147|\<C-V>jr0"
+   call assert_equal(repeat("a", 146) . "0aaa", getline(1))
+   call assert_equal(repeat("a", 146) . "0aaa", getline(2))
+   let lines = s:screen_lines([1, 10], winwidth(0))
+   let expect = [
+ \ "aaaaaaaaaaaaaaaaaaaa",
+ \ "aaaaaaaaaaaaaaaaaaaa",
+ \ "aaaaaaaaaaaaaaaaaaaa",
+ \ "aaaaaaaaaaaaaaaaaaaa",
+ \ "aaaaaaaaaaaaaaaaaaaa",
+ \ "aaaaaaaaaaaaaaaaaaaa",
+ \ "aaaaaaaaaaaaaaaaaaaa",
+ \ "aaaaaa0aaa          ",
+ \ "@                   ",
+ \ "@                   ",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows()
+ endfunc
+ 
+ func Test_list_with_listchars()
+   call s:test_windows('setl list listchars=space:_,trail:-,tab:>-,eol:$')
+   call setline(1, "a aaaaaaaaaaaaaaaaaaaaaa\ta ")
+   let lines = s:screen_lines([1, 3], winwidth(0))
+   let expect = [
+ \ "a_                  ",
+ \ "aaaaaaaaaaaaaaaaaaaa",
+ \ "aa>-----a-$         ",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows()
+ endfunc
*** ../vim-8.0.0310/src/testdir/test_listlbr_utf8.in	2015-12-06 14:43:55.000000000 +0100
--- src/testdir/test_listlbr_utf8.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,134 ****
- Test for linebreak and list option in utf-8 mode
- 
- STARTTEST
- :so small.vim
- :if !exists("+linebreak") || !has("conceal") || !has("signs") | e! test.ok | w! test.out | qa! | endif
- :so mbyte.vim
- :set encoding=utf8
- :if &enc !=? 'utf-8'|:e! test.ok|:w! test.out|qa!|endif
- :10new|:vsp|:vert resize 20
- :put =\"\tabcdef hijklmn\tpqrstuvwxyz\u00a01060ABCDEFGHIJKLMNOP \"
- :norm! zt
- :set ts=4 sw=4 sts=4 linebreak sbr=+ wrap
- :fu! ScreenChar(width, lines)
- :	let c=''
- :	for j in range(1,a:lines)
- :	    for i in range(1,a:width)
- :	    	let c.=nr2char(screenchar(j, i))
- :	    endfor
- :           let c.="\n"
- :	endfor
- :	return c
- :endfu
- :fu! DoRecordScreen()
- :	wincmd l
- :	$put =printf(\"\n%s\", g:test)
- :	$put =g:line
- :	wincmd p
- :endfu
- :"
- :let g:test ="Test 1: set linebreak + set list + fancy listchars"
- :exe "set linebreak list listchars=nbsp:\u2423,tab:\u2595\u2014,trail:\u02d1,eol:\ub6"
- :redraw!
- :let line=ScreenChar(winwidth(0),4)
- :call DoRecordScreen()
- :"
- :let g:test ="Test 2: set nolinebreak list"
- :set list nolinebreak
- :redraw!
- :let line=ScreenChar(winwidth(0),4)
- :call DoRecordScreen()
- :"
- :let g:test ="Test 3: set linebreak nolist"
- :$put =\"\t*mask = nil;\"
- :$
- :norm! zt
- :set nolist linebreak
- :redraw!
- :let line=ScreenChar(winwidth(0),4)
- :call DoRecordScreen()
- :"
- :let g:test ="Test 4: set linebreak list listchars and concealing"
- :let c_defines=['#define ABCDE		1','#define ABCDEF		1','#define ABCDEFG		1','#define ABCDEFGH	1', '#define MSG_MODE_FILE			1','#define MSG_MODE_CONSOLE		2','#define MSG_MODE_FILE_AND_CONSOLE	3','#define MSG_MODE_FILE_THEN_CONSOLE	4']
- :call append('$', c_defines)
- :vert resize 40
- :$-7
- :norm! zt
- :set list linebreak listchars=tab:>- cole=1
- :syn match Conceal conceal cchar=>'AB\|MSG_MODE'
- :redraw!
- :let line=ScreenChar(winwidth(0),7)
- :call DoRecordScreen()
- :"
- :let g:test ="Test 5: set linebreak list listchars and concealing part2"
- :let c_defines=['bbeeeeee		;	some text']
- :call append('$', c_defines)
- :$
- :norm! zt
- :set nowrap ts=2 list linebreak listchars=tab:>- cole=2 concealcursor=n
- :syn clear
- :syn match meaning    /;\s*\zs.*/
- :syn match hasword    /^\x\{8}/    contains=word
- :syn match word       /\<\x\{8}\>/ contains=beginword,endword contained
- :syn match beginword  /\<\x\x/     contained conceal
- :syn match endword    /\x\{6}\>/   contained
- :hi meaning   guibg=blue
- :hi beginword guibg=green
- :hi endword   guibg=red
- :redraw!
- :let line=ScreenChar(winwidth(0),1)
- :call DoRecordScreen()
- :"
- :let g:test ="Test 6: Screenattributes for comment"
- :$put =g:test
- :call append('$', ' /*		 and some more */')
- :exe "set ft=c ts=7 linebreak list listchars=nbsp:\u2423,tab:\u2595\u2014,trail:\u02d1,eol:\ub6"
- :syntax on
- :hi SpecialKey term=underline ctermfg=red guifg=red
- :let attr=[]
- :nnoremap <expr> GG ":let attr += ['".screenattr(screenrow(),screencol())."']\n"
- :$
- :norm! zt0
- GGlGGlGGlGGlGGlGGlGGlGGlGGlGGl
- :call append('$', ['ScreenAttributes for test6:'])
- :if attr[0] != attr[1] && attr[1] != attr[3] && attr[3] != attr[5]
- :   call append('$', "Attribut 0 and 1 and 3 and 5 are different!")
- :else
- :   call append('$', "Not all attributes are different")
- :endif
- :set cpo&vim linebreak selection=exclusive
- :"
- :let g:test ="Test 8: set linebreak with visual block mode and v_b_A and selection=exclusive and multibyte char"
- :$put =g:test
- Golong line: 40afoobar aTARGET' at end
- :exe "norm! $3B\<C-v>eAx\<Esc>"
- :"
- :let g:test ="Test 9: a multibyte sign and colorcolumn"
- :let attr=[]
- :let attr2=[]
- :$put =''
- :$put ='a b c'
- :$put ='a b c'
- :set list nolinebreak cc=3
- :sign define foo text=uff0b
- :sign place 1 name=foo line=50 buffer=2
- :norm! 2kztj
- :let line1=line('.')
- 0GGlGGlGGlGGl
- :let line2=line('.')
- :let attr2=attr
- :let attr=[]
- 0GGlGGlGGlGGl
- :redraw!
- :let line=ScreenChar(winwidth(0),3)
- :call DoRecordScreen()
- :" expected: attr[2] is different because of colorcolumn
- :if attr[0] != attr2[0] || attr[1] != attr2[1] || attr[2] != attr2[2]
- :   call append('$', "Screen attributes are different!")
- :else
- :   call append('$', "Screen attributes are the same!")
- :endif
- :%w! test.out
- :qa!
- ENDTEST
- dummy text
--- 0 ----
*** ../vim-8.0.0310/src/testdir/test_listlbr_utf8.ok	2015-12-06 14:43:55.000000000 +0100
--- src/testdir/test_listlbr_utf8.ok	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,57 ****
- 
- 	abcdef hijklmn	pqrstuvwxyz1060ABCDEFGHIJKLMNOP 
- 
- Test 1: set linebreak + set list + fancy listchars
- abcdef          
- +hijklmn        
- +pqrstuvwxyz1060ABC
- +DEFGHIJKLMNOP    
- 
- Test 2: set nolinebreak list
- abcdef hijklmn
- +pqrstuvwxyz1060ABC
- +DEFGHIJKLMNOP    
-                    
- 	*mask = nil;
- 
- Test 3: set linebreak nolist
-     *mask = nil;    
- ~                   
- ~                   
- ~                   
- #define ABCDE		1
- #define ABCDEF		1
- #define ABCDEFG		1
- #define ABCDEFGH	1
- #define MSG_MODE_FILE			1
- #define MSG_MODE_CONSOLE		2
- #define MSG_MODE_FILE_AND_CONSOLE	3
- #define MSG_MODE_FILE_THEN_CONSOLE	4
- 
- Test 4: set linebreak list listchars and concealing
- #define ABCDE>-->---1                   
- #define >CDEF>-->---1                   
- #define >CDEFG>->---1                   
- #define >CDEFGH>----1                   
- #define >_FILE>--------->--->---1       
- #define >_CONSOLE>---------->---2       
- #define >_FILE_AND_CONSOLE>---------3   
- bbeeeeee		;	some text
- 
- Test 5: set linebreak list listchars and concealing part2
- eeeeee>--->-;>some text                 
- Test 6: Screenattributes for comment
-  /*		 and some more */
- ScreenAttributes for test6:
- Attribut 0 and 1 and 3 and 5 are different!
- Test 8: set linebreak with visual block mode and v_b_A and selection=exclusive and multibyte char
- long line: foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar foobar TARGETx' at end
- 
- a b c
- a b c
- 
- Test 9: a multibyte sign and colorcolumn
-                                        
- a b c                                
-   a b c                                
- Screen attributes are the same!
--- 0 ----
*** ../vim-8.0.0310/src/testdir/test_listlbr_utf8.vim	2017-02-05 21:14:00.431562566 +0100
--- src/testdir/test_listlbr_utf8.vim	2017-02-05 20:59:31.158395013 +0100
***************
*** 0 ****
--- 1,195 ----
+ " Test for linebreak and list option in utf-8 mode
+ 
+ set encoding=utf-8
+ scriptencoding utf-8
+ 
+ if !exists("+linebreak") || !has("conceal") || !has("signs")
+   finish
+ endif
+ 
+ source view_util.vim
+ 
+ function s:screen_lines(lnum, width) abort
+   return ScreenLines(a:lnum, a:width)
+ endfunction
+ 
+ function! s:compare_lines(expect, actual)
+   call assert_equal(a:expect, a:actual)
+ endfunction
+ 
+ function s:screen_attr(lnum, chars, ...) abort
+   let line = getline(a:lnum)
+   let attr = []
+   let prefix = get(a:000, 0, 0)
+   for i in range(a:chars[0], a:chars[1])
+     let scol = strdisplaywidth(strcharpart(line, 0, i-1)) + 1
+     let attr += [screenattr(a:lnum, scol + prefix)]
+   endfor
+   return attr
+ endfunction
+ 
+ function s:test_windows(...)
+   call NewWindow(10, 20)
+   setl ts=4 sw=4 sts=4 linebreak sbr=+ wrap
+   exe get(a:000, 0, '')
+ endfunction
+ 
+ function s:close_windows(...)
+   call CloseWindow()
+   exe get(a:000, 0, '')
+ endfunction
+ 
+ func Test_linebreak_with_fancy_listchars()
+   call s:test_windows("setl list listchars=nbsp:\u2423,tab:\u2595\u2014,trail:\u02d1,eol:\ub6")
+   call setline(1, "\tabcdef hijklmn\tpqrstuvwxyz\u00a01060ABCDEFGHIJKLMNOP ")
+   redraw!
+   let lines = s:screen_lines([1, 4], winwidth(0))
+   let expect = [
+ \ "abcdef          ",
+ \ "+hijklmn        ",
+ \ "+pqrstuvwxyz1060ABC",
+ \ "+DEFGHIJKLMNOP    ",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows()
+ endfunc
+ 
+ func Test_nolinebreak_with_list()
+   call s:test_windows("setl nolinebreak list listchars=nbsp:\u2423,tab:\u2595\u2014,trail:\u02d1,eol:\ub6")
+   call setline(1, "\tabcdef hijklmn\tpqrstuvwxyz\u00a01060ABCDEFGHIJKLMNOP ")
+   redraw!
+   let lines = s:screen_lines([1, 4], winwidth(0))
+   let expect = [
+ \ "abcdef hijklmn",
+ \ "+pqrstuvwxyz1060ABC",
+ \ "+DEFGHIJKLMNOP    ",
+ \ "~                   ",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows()
+ endfunc
+ 
+ func Test_linebreak_with_nolist()
+   call s:test_windows('setl nolist')
+   call setline(1, "\t*mask = nil;")
+   redraw!
+   let lines = s:screen_lines([1, 4], winwidth(0))
+   let expect = [
+ \ "    *mask = nil;    ",
+ \ "~                   ",
+ \ "~                   ",
+ \ "~                   ",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows()
+ endfunc
+ 
+ func Test_list_and_concealing1()
+   call s:test_windows('setl list listchars=tab:>- cole=1')
+   call setline(1, [
+ \ "#define ABCDE\t\t1",
+ \ "#define ABCDEF\t\t1",
+ \ "#define ABCDEFG\t\t1",
+ \ "#define ABCDEFGH\t1",
+ \ "#define MSG_MODE_FILE\t\t\t1",
+ \ "#define MSG_MODE_CONSOLE\t\t2",
+ \ "#define MSG_MODE_FILE_AND_CONSOLE\t3",
+ \ "#define MSG_MODE_FILE_THEN_CONSOLE\t4",
+ \ ])
+   vert resize 40
+   syn match Conceal conceal cchar=>'AB\|MSG_MODE'
+   redraw!
+   let lines = s:screen_lines([1, 7], winwidth(0))
+   let expect = [
+ \ "#define ABCDE>-->---1                   ",
+ \ "#define >CDEF>-->---1                   ",
+ \ "#define >CDEFG>->---1                   ",
+ \ "#define >CDEFGH>----1                   ",
+ \ "#define >_FILE>--------->--->---1       ",
+ \ "#define >_CONSOLE>---------->---2       ",
+ \ "#define >_FILE_AND_CONSOLE>---------3   ",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows()
+ endfunc
+ 
+ func Test_list_and_concealing2()
+   call s:test_windows('setl nowrap ts=2 list listchars=tab:>- cole=2 concealcursor=n')
+   call setline(1, "bbeeeeee\t\t;\tsome text")
+   vert resize 40
+   syn clear
+   syn match meaning    /;\s*\zs.*/
+   syn match hasword    /^\x\{8}/    contains=word
+   syn match word       /\<\x\{8}\>/ contains=beginword,endword contained
+   syn match beginword  /\<\x\x/     contained conceal
+   syn match endword    /\x\{6}\>/   contained
+   hi meaning   guibg=blue
+   hi beginword guibg=green
+   hi endword   guibg=red
+   redraw!
+   let lines = s:screen_lines([1, 1], winwidth(0))
+   let expect = [
+ \ "eeeeee>--->-;>some text                 ",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows()
+ endfunc
+ 
+ func Test_screenattr_for_comment()
+   call s:test_windows("setl ft=c ts=7 list listchars=nbsp:\u2423,tab:\u2595\u2014,trail:\u02d1,eol:\ub6")
+   call setline(1, " /*\t\t and some more */")
+   norm! gg0
+   syntax on
+   hi SpecialKey term=underline ctermfg=red guifg=red
+   redraw!
+   let line = getline(1)
+   let attr = s:screen_attr(1, [1, 6])
+   call assert_notequal(attr[0], attr[1])
+   call assert_notequal(attr[1], attr[3])
+   call assert_notequal(attr[3], attr[5])
+   call s:close_windows()
+ endfunc
+ 
+ func Test_visual_block_and_selection_exclusive()
+   call s:test_windows('setl selection=exclusive')
+   call setline(1, "long line: " . repeat("foobar ", 40) . "TARGET' at end")
+   exe "norm! $3B\<C-v>eAx\<Esc>"
+   let lines = s:screen_lines([1, 10], winwidth(0))
+   let expect = [
+ \ "+foobar foobar      ",
+ \ "+foobar foobar      ",
+ \ "+foobar foobar      ",
+ \ "+foobar foobar      ",
+ \ "+foobar foobar      ",
+ \ "+foobar foobar      ",
+ \ "+foobar foobar      ",
+ \ "+foobar foobar      ",
+ \ "+foobar foobar      ",
+ \ "+foobar TARGETx'   ",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows()
+ endfunc
+ 
+ func Test_multibyte_sign_and_colorcolumn()
+   call s:test_windows("setl nolinebreak cc=3 list listchars=nbsp:\u2423,tab:\u2595\u2014,trail:\u02d1,eol:\ub6")
+   call setline(1, ["", "a b c", "a b c"])
+   exe "sign define foo text=\uff0b"
+   exe "sign place 1 name=foo line=2 buffer=" . bufnr('%')
+   redraw!
+   norm! ggj0
+   let signwidth = strdisplaywidth("\uff0b")
+   let attr1 = s:screen_attr(2, [1, 3], signwidth)
+   let attr2 = s:screen_attr(3, [1, 3], signwidth)
+   call assert_equal(attr1[0], attr2[0])
+   call assert_equal(attr1[1], attr2[1])
+   call assert_equal(attr1[2], attr2[2])
+   let lines = s:screen_lines([1, 3], winwidth(0))
+   let expect = [
+ \ "                   ",
+ \ "a b c            ",
+ \ "  a b c            ",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows()
+ endfunc
*** ../vim-8.0.0310/src/testdir/view_util.vim	2017-02-05 21:14:00.435562534 +0100
--- src/testdir/view_util.vim	2017-02-05 20:59:31.162394981 +0100
***************
*** 0 ****
--- 1,30 ----
+ " Functions about view shared by several tests
+ 
+ " ScreenLines(lnum, width) or
+ " ScreenLines([start, end], width)
+ function! ScreenLines(lnum, width) abort
+   redraw!
+   if type(a:lnum) == v:t_list
+     let start = a:lnum[0]
+     let end = a:lnum[1]
+   else
+     let start = a:lnum
+     let end = a:lnum
+   endif
+   let lines = []
+   for l in range(start, end)
+     let lines += [join(map(range(1, a:width), 'nr2char(screenchar(l, v:val))'), '')]
+   endfor
+   return lines
+ endfunction
+ 
+ function! NewWindow(height, width) abort
+   exe a:height . 'new'
+   exe a:width . 'vsp'
+   redraw!
+ endfunction
+ 
+ function! CloseWindow() abort
+   bw!
+   redraw!
+ endfunction
*** ../vim-8.0.0310/src/version.c	2017-02-05 20:54:21.772818426 +0100
--- src/version.c	2017-02-05 21:01:11.789605766 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     311,
  /**/

-- 
A special cleaning ordinance bans housewives from hiding dirt and dust under a
rug in a dwelling.
		[real standing law in Pennsylvania, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0312
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0312
Problem:    When a json message arrives in pieces, the start is dropped and
            the decoding fails.
Solution:   Do not drop the start when it is still needed. (Kay Zheng)  Add a
            test.  Reset the timeout when something is received.
Files:      src/channel.c, src/testdir/test_channel.vim, src/structs.h,
            src/testdir/test_channel_pipe.py


*** ../vim-8.0.0311/src/channel.c	2017-01-14 17:04:33.950973940 +0100
--- src/channel.c	2017-02-06 21:52:01.086150732 +0100
***************
*** 1840,1878 ****
      return OK;
  }
  
      static int
  channel_fill(js_read_T *reader)
  {
      channel_T	*channel = (channel_T *)reader->js_cookie;
      ch_part_T	part = reader->js_cookie_arg;
      char_u	*next = channel_get(channel, part);
!     int		unused;
!     int		len;
      char_u	*p;
  
      if (next == NULL)
  	return FALSE;
  
!     unused = reader->js_end - reader->js_buf - reader->js_used;
!     if (unused > 0)
      {
  	/* Prepend unused text. */
! 	len = (int)STRLEN(next);
! 	p = alloc(unused + len + 1);
  	if (p == NULL)
  	{
  	    vim_free(next);
  	    return FALSE;
  	}
! 	mch_memmove(p, reader->js_buf + reader->js_used, unused);
! 	mch_memmove(p + unused, next, len + 1);
  	vim_free(next);
  	next = p;
      }
  
      vim_free(reader->js_buf);
      reader->js_buf = next;
-     reader->js_used = 0;
      return TRUE;
  }
  
--- 1840,1881 ----
      return OK;
  }
  
+ /*
+  * Try to fill the buffer of "reader".
+  * Returns FALSE when nothing was added.
+  */
      static int
  channel_fill(js_read_T *reader)
  {
      channel_T	*channel = (channel_T *)reader->js_cookie;
      ch_part_T	part = reader->js_cookie_arg;
      char_u	*next = channel_get(channel, part);
!     int		keeplen;
!     int		addlen;
      char_u	*p;
  
      if (next == NULL)
  	return FALSE;
  
!     keeplen = reader->js_end - reader->js_buf;
!     if (keeplen > 0)
      {
  	/* Prepend unused text. */
! 	addlen = (int)STRLEN(next);
! 	p = alloc(keeplen + addlen + 1);
  	if (p == NULL)
  	{
  	    vim_free(next);
  	    return FALSE;
  	}
! 	mch_memmove(p, reader->js_buf, keeplen);
! 	mch_memmove(p + keeplen, next, addlen + 1);
  	vim_free(next);
  	next = p;
      }
  
      vim_free(reader->js_buf);
      reader->js_buf = next;
      return TRUE;
  }
  
***************
*** 1952,1967 ****
      }
  
      if (status == OK)
! 	chanpart->ch_waiting = FALSE;
      else if (status == MAYBE)
      {
! 	if (!chanpart->ch_waiting)
  	{
! 	    /* First time encountering incomplete message, set a deadline of
! 	     * 100 msec. */
! 	    ch_log(channel, "Incomplete message - wait for more");
  	    reader.js_used = 0;
! 	    chanpart->ch_waiting = TRUE;
  #ifdef WIN32
  	    chanpart->ch_deadline = GetTickCount() + 100L;
  #else
--- 1955,1974 ----
      }
  
      if (status == OK)
! 	chanpart->ch_wait_len = 0;
      else if (status == MAYBE)
      {
! 	size_t buflen = STRLEN(reader.js_buf);
! 
! 	if (chanpart->ch_wait_len < buflen)
  	{
! 	    /* First time encountering incomplete message or after receiving
! 	     * more (but still incomplete): set a deadline of 100 msec. */
! 	    ch_logn(channel,
! 		    "Incomplete message (%d bytes) - wait 100 msec for more",
! 		    buflen);
  	    reader.js_used = 0;
! 	    chanpart->ch_wait_len = buflen;
  #ifdef WIN32
  	    chanpart->ch_deadline = GetTickCount() + 100L;
  #else
***************
*** 1992,1998 ****
  	    if (timeout)
  	    {
  		status = FAIL;
! 		chanpart->ch_waiting = FALSE;
  	    }
  	    else
  	    {
--- 1999,2006 ----
  	    if (timeout)
  	    {
  		status = FAIL;
! 		chanpart->ch_wait_len = 0;
! 		ch_log(channel, "timed out");
  	    }
  	    else
  	    {
***************
*** 2006,2012 ****
      {
  	ch_error(channel, "Decoding failed - discarding input");
  	ret = FALSE;
! 	chanpart->ch_waiting = FALSE;
      }
      else if (reader.js_buf[reader.js_used] != NUL)
      {
--- 2014,2020 ----
      {
  	ch_error(channel, "Decoding failed - discarding input");
  	ret = FALSE;
! 	chanpart->ch_wait_len = 0;
      }
      else if (reader.js_buf[reader.js_used] != NUL)
      {
***************
*** 3369,3375 ****
  	    /* Wait for up to the timeout.  If there was an incomplete message
  	     * use the deadline for that. */
  	    timeout = timeout_arg;
! 	    if (chanpart->ch_waiting)
  	    {
  #ifdef WIN32
  		timeout = chanpart->ch_deadline - GetTickCount() + 1;
--- 3377,3383 ----
  	    /* Wait for up to the timeout.  If there was an incomplete message
  	     * use the deadline for that. */
  	    timeout = timeout_arg;
! 	    if (chanpart->ch_wait_len > 0)
  	    {
  #ifdef WIN32
  		timeout = chanpart->ch_deadline - GetTickCount() + 1;
***************
*** 3389,3395 ****
  		{
  		    /* Something went wrong, channel_parse_json() didn't
  		     * discard message.  Cancel waiting. */
! 		    chanpart->ch_waiting = FALSE;
  		    timeout = timeout_arg;
  		}
  		else if (timeout > timeout_arg)
--- 3397,3403 ----
  		{
  		    /* Something went wrong, channel_parse_json() didn't
  		     * discard message.  Cancel waiting. */
! 		    chanpart->ch_wait_len = 0;
  		    timeout = timeout_arg;
  		}
  		else if (timeout > timeout_arg)
*** ../vim-8.0.0311/src/testdir/test_channel.vim	2017-01-08 13:38:53.028502710 +0100
--- src/testdir/test_channel.vim	2017-02-06 21:55:37.572539457 +0100
***************
*** 1141,1147 ****
  
    let dict = {'thisis': 'dict: '}
    func dict.outHandler(chan, msg) dict
!     let g:Ch_outmsg = self.thisis . a:msg
    endfunc
    func dict.errHandler(chan, msg) dict
      let g:Ch_errmsg = self.thisis . a:msg
--- 1141,1151 ----
  
    let dict = {'thisis': 'dict: '}
    func dict.outHandler(chan, msg) dict
!     if type(a:msg) == v:t_string
!       let g:Ch_outmsg = self.thisis . a:msg
!     else
!       let g:Ch_outobj = a:msg
!     endif
    endfunc
    func dict.errHandler(chan, msg) dict
      let g:Ch_errmsg = self.thisis . a:msg
***************
*** 1161,1166 ****
--- 1165,1176 ----
      call assert_equal("dict: hello", g:Ch_outmsg)
      call WaitFor('g:Ch_errmsg != ""')
      call assert_equal("dict: there", g:Ch_errmsg)
+ 
+     " Receive a json object split in pieces
+     unlet! g:Ch_outobj
+     call ch_sendraw(job, "echosplit [0, {\"one\": 1,| \"tw|o\": 2, \"three\": 3|}]\n")
+     call WaitFor('exists("g:Ch_outobj")')
+     call assert_equal({'one': 1, 'two': 2, 'three': 3}, g:Ch_outobj)
    finally
      call job_stop(job)
    endtry
*** ../vim-8.0.0311/src/structs.h	2017-02-02 22:59:22.583226973 +0100
--- src/structs.h	2017-02-06 21:47:04.116363189 +0100
***************
*** 1563,1571 ****
      jsonq_T	ch_json_head;	/* header for circular json read queue */
      int		ch_block_id;	/* ID that channel_read_json_block() is
  				   waiting for */
!     /* When ch_waiting is TRUE use ch_deadline to wait for incomplete message
!      * to be complete. */
!     int		ch_waiting;
  #ifdef WIN32
      DWORD	ch_deadline;
  #else
--- 1563,1573 ----
      jsonq_T	ch_json_head;	/* header for circular json read queue */
      int		ch_block_id;	/* ID that channel_read_json_block() is
  				   waiting for */
!     /* When ch_wait_len is non-zero use ch_deadline to wait for incomplete
!      * message to be complete. The value is the length of the incomplete
!      * message when the deadline was set.  If it gets longer (something was
!      * received) the deadline is reset. */
!     size_t	ch_wait_len;
  #ifdef WIN32
      DWORD	ch_deadline;
  #else
*** ../vim-8.0.0311/src/testdir/test_channel_pipe.py	2016-06-05 16:01:21.000000000 +0200
--- src/testdir/test_channel_pipe.py	2017-02-06 21:12:08.116049258 +0100
***************
*** 29,34 ****
--- 29,39 ----
          if typed.startswith("echo "):
              print(typed[5:-1])
              sys.stdout.flush()
+         if typed.startswith("echosplit "):
+             for part in typed[10:-1].split('|'):
+                 sys.stdout.write(part)
+                 sys.stdout.flush()
+                 time.sleep(0.05)
          if typed.startswith("double "):
              print(typed[7:-1] + "\nAND " + typed[7:-1])
              sys.stdout.flush()
*** ../vim-8.0.0311/src/version.c	2017-02-05 21:14:26.743355267 +0100
--- src/version.c	2017-02-06 21:14:41.890894810 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     312,
  /**/

-- 
If you only have a hammer, you tend to see every problem as a nail.
If you only have MS-Windows, you tend to solve every problem by rebooting.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0313
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0313 (after 8.0.0310)
Problem:    Not enough testing for GUI functionality.
Solution:   Add tests for the GUI font. (Kazunobu Kuriyama)
Files:      src/testdir/test_gui.vim


*** ../vim-8.0.0312/src/testdir/test_gui.vim	2017-02-05 20:54:21.772818426 +0100
--- src/testdir/test_gui.vim	2017-02-06 22:09:58.858106622 +0100
***************
*** 35,45 ****
    call assert_equal(1, has('gui_running'))
  endfunc
  
  func Test_getwinpos()
    call assert_match('Window position: X \d\+, Y \d\+', execute('winpos'))
    call assert_true(getwinposx() >= 0)
    call assert_true(getwinposy() >= 0)
! endfunction
  
  func Test_shell_command()
    new
--- 35,82 ----
    call assert_equal(1, has('gui_running'))
  endfunc
  
+ func Test_getfontname_with_arg()
+   if has('gui_athena') || has('gui_motif')
+     " Invalid font name. The result should be an empty string.
+     call assert_equal('', getfontname('notexist'))
+ 
+     " Valid font name. This is usually the real name of 7x13 by default.
+     let l:fname = '-Misc-Fixed-Medium-R-Normal--13-120-75-75-C-70-ISO10646-1'
+     call assert_equal(l:fname, getfontname(l:fname))
+ 
+   elseif has('gui_gtk2') || has('gui_gnome') || has('gui_gtk3')
+     " Invalid font name. The result should be the name plus the default size.
+     call assert_equal('notexist 10', getfontname('notexist'))
+ 
+     " Valid font name. This is usually the real name of Monospace by default.
+     let l:fname = 'Bitstream Vera Sans Mono 12'
+     call assert_equal(l:fname, getfontname(l:fname))
+   else
+     throw "Skipped: Matched font name unpredictable to test on this GUI"
+   endif
+ endfunc
+ 
+ func Test_getfontname_without_arg()
+   let l:fname = getfontname()
+   if has('gui_kde')
+     " 'expected' is the value specified by SetUp() above.
+     call assert_equal('Courier 10 Pitch/8/-1/5/50/0/0/0/0/0', l:fname)
+   elseif has('gui_athena') || has('gui_motif')
+     " 'expected' is DFLT_FONT of gui_x11.c.
+     call assert_equal('7x13', l:fname)
+   elseif has('gui_gtk2') || has('gui_gnome') || has('gui_gtk3')
+     " 'expected' is DEFAULT_FONT of gui_gtk_x11.c.
+     call assert_equal('Monospace 10', l:fname)
+   else
+     throw "Skipped: Default font name unpredictable to test on this GUI"
+   endif
+ endfunc
+ 
  func Test_getwinpos()
    call assert_match('Window position: X \d\+, Y \d\+', execute('winpos'))
    call assert_true(getwinposx() >= 0)
    call assert_true(getwinposy() >= 0)
! endfunc
  
  func Test_shell_command()
    new
***************
*** 54,57 ****
    else
      call assert_equal(0, v:windowid)
    endif
! endfunction
--- 91,94 ----
    else
      call assert_equal(0, v:windowid)
    endif
! endfunc
*** ../vim-8.0.0312/src/version.c	2017-02-06 21:56:05.000335406 +0100
--- src/version.c	2017-02-06 22:10:42.261779449 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     313,
  /**/

-- 
No children may attend school with their breath smelling of "wild onions."
		[real standing law in West Virginia, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0314
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0314
Problem:    getcmdtype(), getcmdpos() and getcmdline() are not tested.
Solution:   Add tests. (Yegappan Lakshmanan)
Files:      src/testdir/test_cmdline.vim


*** ../vim-8.0.0313/src/testdir/test_cmdline.vim	2017-02-03 21:19:00.289942006 +0100
--- src/testdir/test_cmdline.vim	2017-02-06 22:19:28.337818597 +0100
***************
*** 330,333 ****
--- 330,365 ----
    bwipe!
  endfunc
  
+ " Tests for getcmdline(), getcmdpos() and getcmdtype()
+ func Check_cmdline(cmdtype)
+   call assert_equal('MyCmd a', getcmdline())
+   call assert_equal(8, getcmdpos())
+   call assert_equal(a:cmdtype, getcmdtype())
+   return ''
+ endfunc
+ 
+ func Test_getcmdtype()
+   call feedkeys(":MyCmd a\<C-R>=Check_cmdline(':')\<CR>\<Esc>", "xt")
+ 
+   let cmdtype = ''
+   debuggreedy
+   call feedkeys(":debug echo 'test'\<CR>", "t")
+   call feedkeys("let cmdtype = \<C-R>=string(getcmdtype())\<CR>\<CR>", "t")
+   call feedkeys("cont\<CR>", "xt")
+   0debuggreedy
+   call assert_equal('>', cmdtype)
+ 
+   call feedkeys("/MyCmd a\<C-R>=Check_cmdline('/')\<CR>\<Esc>", "xt")
+   call feedkeys("?MyCmd a\<C-R>=Check_cmdline('?')\<CR>\<Esc>", "xt")
+ 
+   call feedkeys(":call input('Answer?')\<CR>", "t")
+   call feedkeys("MyCmd a\<C-R>=Check_cmdline('@')\<CR>\<Esc>", "xt")
+ 
+   call feedkeys(":insert\<CR>MyCmd a\<C-R>=Check_cmdline('-')\<CR>\<Esc>", "xt")
+ 
+   cnoremap <expr> <F6> Check_cmdline('=')
+   call feedkeys("a\<C-R>=MyCmd a\<F6>\<Esc>\<Esc>", "xt")
+   cunmap <F6>
+ endfunc
+ 
  set cpo&
*** ../vim-8.0.0313/src/version.c	2017-02-06 22:11:50.577264620 +0100
--- src/version.c	2017-02-06 22:21:13.629026829 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     314,
  /**/

-- 
ARTHUR: If you do not open these doors, we will take this castle by force ...
   [A bucket of slops land on ARTHUR.  He tries to retain his dignity.]
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0315
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0315
Problem:    ":help :[range]" does not work. (Tony Mechelynck)
Solution:   Translate to insert a backslash.
Files:      src/ex_cmds.c


*** ../vim-8.0.0314/src/ex_cmds.c	2017-01-21 14:44:32.531503504 +0100
--- src/ex_cmds.c	2017-02-08 23:08:02.088083355 +0100
***************
*** 6505,6511 ****
  			       "cpo-*", "/\\(\\)", "/\\%(\\)",
  			       "?", ":?", "?<CR>", "g?", "g?g?", "g??", "z?",
  			       "/\\?", "/\\z(\\)", "\\=", ":s\\=",
! 			       "[count]", "[quotex]", "[range]",
  			       "[pattern]", "\\|", "\\%$",
  			       "s/\\~", "s/\\U", "s/\\L",
  			       "s/\\1", "s/\\2", "s/\\3", "s/\\9"};
--- 6505,6512 ----
  			       "cpo-*", "/\\(\\)", "/\\%(\\)",
  			       "?", ":?", "?<CR>", "g?", "g?g?", "g??", "z?",
  			       "/\\?", "/\\z(\\)", "\\=", ":s\\=",
! 			       "[count]", "[quotex]",
! 			       "[range]", ":[range]",
  			       "[pattern]", "\\|", "\\%$",
  			       "s/\\~", "s/\\U", "s/\\L",
  			       "s/\\1", "s/\\2", "s/\\3", "s/\\9"};
***************
*** 6514,6520 ****
  			       "cpo-star", "/\\\\(\\\\)", "/\\\\%(\\\\)",
  			       "?", ":?", "?<CR>", "g?", "g?g?", "g??", "z?",
  			       "/\\\\?", "/\\\\z(\\\\)", "\\\\=", ":s\\\\=",
! 			       "\\[count]", "\\[quotex]", "\\[range]",
  			       "\\[pattern]", "\\\\bar", "/\\\\%\\$",
  			       "s/\\\\\\~", "s/\\\\U", "s/\\\\L",
  			       "s/\\\\1", "s/\\\\2", "s/\\\\3", "s/\\\\9"};
--- 6515,6522 ----
  			       "cpo-star", "/\\\\(\\\\)", "/\\\\%(\\\\)",
  			       "?", ":?", "?<CR>", "g?", "g?g?", "g??", "z?",
  			       "/\\\\?", "/\\\\z(\\\\)", "\\\\=", ":s\\\\=",
! 			       "\\[count]", "\\[quotex]",
! 			       "\\[range]", ":\\[range]",
  			       "\\[pattern]", "\\\\bar", "/\\\\%\\$",
  			       "s/\\\\\\~", "s/\\\\U", "s/\\\\L",
  			       "s/\\\\1", "s/\\\\2", "s/\\\\3", "s/\\\\9"};
*** ../vim-8.0.0314/src/version.c	2017-02-06 22:22:12.896581284 +0100
--- src/version.c	2017-02-08 23:10:35.870892733 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     315,
  /**/

-- 
Communication is one of the most compli..., eh, well, it's hard.
You know what I mean.  Not?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0316
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0316
Problem:    ":help z?" does not work. (Pavol Juhas)
Solution:   Remove exception for z?.
Files:      src/ex_cmds.c


*** ../vim-8.0.0315/src/ex_cmds.c	2017-02-08 23:11:27.358494190 +0100
--- src/ex_cmds.c	2017-02-09 11:50:34.184573146 +0100
***************
*** 6503,6509 ****
      static char *(mtable[]) = {"*", "g*", "[*", "]*", ":*",
  			       "/*", "/\\*", "\"*", "**",
  			       "cpo-*", "/\\(\\)", "/\\%(\\)",
! 			       "?", ":?", "?<CR>", "g?", "g?g?", "g??", "z?",
  			       "/\\?", "/\\z(\\)", "\\=", ":s\\=",
  			       "[count]", "[quotex]",
  			       "[range]", ":[range]",
--- 6503,6509 ----
      static char *(mtable[]) = {"*", "g*", "[*", "]*", ":*",
  			       "/*", "/\\*", "\"*", "**",
  			       "cpo-*", "/\\(\\)", "/\\%(\\)",
! 			       "?", ":?", "?<CR>", "g?", "g?g?", "g??",
  			       "/\\?", "/\\z(\\)", "\\=", ":s\\=",
  			       "[count]", "[quotex]",
  			       "[range]", ":[range]",
***************
*** 6513,6519 ****
      static char *(rtable[]) = {"star", "gstar", "[star", "]star", ":star",
  			       "/star", "/\\\\star", "quotestar", "starstar",
  			       "cpo-star", "/\\\\(\\\\)", "/\\\\%(\\\\)",
! 			       "?", ":?", "?<CR>", "g?", "g?g?", "g??", "z?",
  			       "/\\\\?", "/\\\\z(\\\\)", "\\\\=", ":s\\\\=",
  			       "\\[count]", "\\[quotex]",
  			       "\\[range]", ":\\[range]",
--- 6513,6519 ----
      static char *(rtable[]) = {"star", "gstar", "[star", "]star", ":star",
  			       "/star", "/\\\\star", "quotestar", "starstar",
  			       "cpo-star", "/\\\\(\\\\)", "/\\\\%(\\\\)",
! 			       "?", ":?", "?<CR>", "g?", "g?g?", "g??",
  			       "/\\\\?", "/\\\\z(\\\\)", "\\\\=", ":s\\\\=",
  			       "\\[count]", "\\[quotex]",
  			       "\\[range]", ":\\[range]",
*** ../vim-8.0.0315/src/version.c	2017-02-08 23:11:27.358494190 +0100
--- src/version.c	2017-02-09 11:52:00.811947077 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     316,
  /**/

-- 
A disclaimer for the disclaimer:
"and before I get a huge amount of complaints , I have no control over the
disclaimer at the end of this mail :-)" (Timothy Aldrich)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0317
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0317
Problem:    No test for setting 'guifont'.
Solution:   Add a test for X11 GUIs. (Kazunobu Kuriyama)
Files:      src/testdir/test_gui.vim


*** ../vim-8.0.0316/src/testdir/test_gui.vim	2017-02-06 22:11:50.577264620 +0100
--- src/testdir/test_gui.vim	2017-02-09 16:04:15.214813050 +0100
***************
*** 72,77 ****
--- 72,136 ----
    endif
  endfunc
  
+ func Test_set_guifont()
+   let l:guifont_saved = &guifont
+   if has('xfontset')
+     " Prevent 'guifontset' from canceling 'guifont'.
+     let l:guifontset_saved = &guifontset
+     set guifontset=
+   endif
+ 
+   let skipped = 0
+   if has('gui_athena') || has('gui_motif')
+     " Non-empty font list with invalid font names.
+     "
+     " This test is twofold: (1) It checks if the command fails as expected
+     " when there are no loadable fonts found in the list. (2) It checks if
+     " 'guifont' remains the same after the command loads none of the fonts
+     " listed.
+     let l:flist = &guifont
+     call assert_fails('set guifont=-notexist1-*,-notexist2-*')
+     call assert_equal(l:flist, &guifont)
+ 
+     " Non-empty font list with a valid font name.  Should pick up the first
+     " valid font.
+     set guifont=-notexist1-*,fixed,-notexist2-*
+     call assert_equal('fixed', getfontname())
+ 
+     " Empty list. Should fallback to the built-in default.
+     set guifont=
+     call assert_equal('7x13', getfontname())
+ 
+   elseif has('gui_gtk2') || has('gui_gnome') || has('gui_gtk3')
+     " For GTK, what we refer to as 'font names' in our manual are actually
+     " 'initial font patterns'.  A valid font which matches the 'canonical font
+     " pattern' constructed from a given 'initial pattern' is to be looked up
+     " and loaded.  That explains why the GTK GUIs appear to accept 'invalid
+     " font names'.
+     "
+     " Non-empty list.  Should always pick up the first element, no matter how
+     " strange it is, as explained above.
+     set guifont=()\ 12,Courier\ 12
+     call assert_equal('() 12', getfontname())
+ 
+     " Empty list. Should fallback to the built-in default.
+     set guifont=
+     call assert_equal('Monospace 10', getfontname())
+ 
+   else
+     let skipped = 1
+   endif
+ 
+   if has('xfontset')
+     let &guifontset = l:guifontset_saved
+   endif
+   let &guifont = l:guifont_saved
+ 
+   if skipped
+     throw "Skipped: Test not implemented yet for this GUI"
+   endif
+ endfunc
+ 
  func Test_getwinpos()
    call assert_match('Window position: X \d\+, Y \d\+', execute('winpos'))
    call assert_true(getwinposx() >= 0)
*** ../vim-8.0.0316/src/version.c	2017-02-09 11:54:46.742748026 +0100
--- src/version.c	2017-02-09 16:05:22.774318435 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     317,
  /**/

-- 
A year spent in artificial intelligence is enough to make one
believe in God.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0318
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0318
Problem:    Small mistake in 7x13 font name.
Solution:   Use ISO 8859-1 name instead of 10646-1. (Kazunobu Kuriyama)
Files:      src/testdir/test_gui.vim


*** ../vim-8.0.0317/src/testdir/test_gui.vim	2017-02-09 16:06:13.189949387 +0100
--- src/testdir/test_gui.vim	2017-02-09 16:11:39.151561861 +0100
***************
*** 41,47 ****
      call assert_equal('', getfontname('notexist'))
  
      " Valid font name. This is usually the real name of 7x13 by default.
!     let l:fname = '-Misc-Fixed-Medium-R-Normal--13-120-75-75-C-70-ISO10646-1'
      call assert_equal(l:fname, getfontname(l:fname))
  
    elseif has('gui_gtk2') || has('gui_gnome') || has('gui_gtk3')
--- 41,47 ----
      call assert_equal('', getfontname('notexist'))
  
      " Valid font name. This is usually the real name of 7x13 by default.
!     let l:fname = '-misc-fixed-medium-r-normal--13-120-75-75-c-70-iso8859-1'
      call assert_equal(l:fname, getfontname(l:fname))
  
    elseif has('gui_gtk2') || has('gui_gnome') || has('gui_gtk3')
*** ../vim-8.0.0317/src/version.c	2017-02-09 16:06:13.189949387 +0100
--- src/version.c	2017-02-09 16:12:41.123107996 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     318,
  /**/

-- 
A fool must search for a greater fool to find admiration.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0319
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0319
Problem:    Insert mode completion does not respect "start" in 'backspace'.
Solution:   Check whether backspace can go before where insert started.
            (Hirohito Higashi)
Files:      src/edit.c, src/testdir/test_popup.vim


*** ../vim-8.0.0318/src/edit.c	2017-01-29 17:59:07.872772178 +0100
--- src/edit.c	2017-02-09 17:36:09.266007633 +0100
***************
*** 3467,3476 ****
      mb_ptr_back(line, p);
  
      /* Stop completion when the whole word was deleted.  For Omni completion
!      * allow the word to be deleted, we won't match everything. */
      if ((int)(p - line) - (int)compl_col < 0
  	    || ((int)(p - line) - (int)compl_col == 0
! 		&& ctrl_x_mode != CTRL_X_OMNI) || ctrl_x_mode == CTRL_X_EVAL)
  	return K_BS;
  
      /* Deleted more than what was used to find matches or didn't finish
--- 3467,3479 ----
      mb_ptr_back(line, p);
  
      /* Stop completion when the whole word was deleted.  For Omni completion
!      * allow the word to be deleted, we won't match everything.
!      * Respect the 'backspace' option. */
      if ((int)(p - line) - (int)compl_col < 0
  	    || ((int)(p - line) - (int)compl_col == 0
! 		&& ctrl_x_mode != CTRL_X_OMNI) || ctrl_x_mode == CTRL_X_EVAL
! 	    || (!can_bs(BS_START) && (int)(p - line) - (int)compl_col
! 							- compl_length < 0))
  	return K_BS;
  
      /* Deleted more than what was used to find matches or didn't finish
*** ../vim-8.0.0318/src/testdir/test_popup.vim	2017-01-27 21:48:46.960162956 +0100
--- src/testdir/test_popup.vim	2017-02-09 17:32:34.783629818 +0100
***************
*** 511,514 ****
--- 511,534 ----
    bw!
  endfunc
  
+ func Test_completion_respect_bs_option()
+   new
+   let li = ["aaa", "aaa12345", "aaaabcdef", "aaaABC"]
+ 
+   set bs=indent,eol
+   call setline(1, li)
+   1
+   call feedkeys("A\<C-X>\<C-N>\<C-P>\<BS>\<BS>\<BS>\<Esc>", "tx")
+   call assert_equal('aaa', getline(1))
+ 
+   %d
+   set bs=indent,eol,start
+   call setline(1, li)
+   1
+   call feedkeys("A\<C-X>\<C-N>\<C-P>\<BS>\<BS>\<BS>\<Esc>", "tx")
+   call assert_equal('', getline(1))
+ 
+   bw!
+ endfunc
+ 
  " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.0.0318/src/version.c	2017-02-09 16:14:47.890179799 +0100
--- src/version.c	2017-02-09 17:34:27.162779654 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     319,
  /**/

-- 
The most powerful force in the universe is gossip.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0320
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0320
Problem:    Warning for unused variable with small build.
Solution:   Change #ifdef to exclude FEAT_CMDWIN. (Kazunobu Kuriyama)
Files:      src/ex_getln.c


*** ../vim-8.0.0319/src/ex_getln.c	2017-01-24 21:18:15.986024183 +0100
--- src/ex_getln.c	2017-02-09 18:22:48.156897192 +0100
***************
*** 212,219 ****
  #endif
      expand_T	xpc;
      long	*b_im_ptr = NULL;
! #if defined(FEAT_WILDMENU) || defined(FEAT_EVAL) \
!     || defined(FEAT_SEARCH_EXTRA) || defined(FEAT_CMDWIN)
      /* Everything that may work recursively should save and restore the
       * current command line in save_ccline.  That includes update_screen(), a
       * custom status line may invoke ":normal". */
--- 212,218 ----
  #endif
      expand_T	xpc;
      long	*b_im_ptr = NULL;
! #if defined(FEAT_WILDMENU) || defined(FEAT_EVAL) || defined(FEAT_SEARCH_EXTRA)
      /* Everything that may work recursively should save and restore the
       * current command line in save_ccline.  That includes update_screen(), a
       * custom status line may invoke ":normal". */
*** ../vim-8.0.0319/src/version.c	2017-02-09 17:36:59.293629503 +0100
--- src/version.c	2017-02-09 18:23:52.712412507 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     320,
  /**/

-- 
Mushrooms always grow in damp places and so they look like umbrellas.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0321
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0321
Problem:    When using the tiny version trying to load the matchit plugin
            gives an error. On MS-Windows some default mappings fail.
Solution:   Add a check if the command used is available. (Christian Brabandt)
Files:      runtime/mswin.vim, runtime/macros/matchit.vim


*** ../vim-8.0.0320/runtime/mswin.vim	2012-07-25 13:07:31.000000000 +0200
--- runtime/mswin.vim	2017-02-09 20:21:22.710235591 +0100
***************
*** 1,7 ****
  " Set options and add mapping such that Vim behaves a lot like MS-Windows
  "
  " Maintainer:	Bram Moolenaar <Bram@vim.org>
! " Last change:	2012 Jul 25
  
  " bail out if this isn't wanted (mrsvim.vim uses this).
  if exists("g:skip_loading_mswin") && g:skip_loading_mswin
--- 1,7 ----
  " Set options and add mapping such that Vim behaves a lot like MS-Windows
  "
  " Maintainer:	Bram Moolenaar <Bram@vim.org>
! " Last change:	2017 Feb 09
  
  " bail out if this isn't wanted (mrsvim.vim uses this).
  if exists("g:skip_loading_mswin") && g:skip_loading_mswin
***************
*** 23,42 ****
  " backspace in Visual mode deletes selection
  vnoremap <BS> d
  
! " CTRL-X and SHIFT-Del are Cut
! vnoremap <C-X> "+x
! vnoremap <S-Del> "+x
! 
! " CTRL-C and CTRL-Insert are Copy
! vnoremap <C-C> "+y
! vnoremap <C-Insert> "+y
! 
! " CTRL-V and SHIFT-Insert are Paste
! map <C-V>		"+gP
! map <S-Insert>		"+gP
  
! cmap <C-V>		<C-R>+
! cmap <S-Insert>		<C-R>+
  
  " Pasting blockwise and linewise selections is not possible in Insert and
  " Visual mode without the +virtualedit feature.  They are pasted as if they
--- 23,44 ----
  " backspace in Visual mode deletes selection
  vnoremap <BS> d
  
! if has("clipboard")
!     " CTRL-X and SHIFT-Del are Cut
!     vnoremap <C-X> "+x
!     vnoremap <S-Del> "+x
! 
!     " CTRL-C and CTRL-Insert are Copy
!     vnoremap <C-C> "+y
!     vnoremap <C-Insert> "+y
! 
!     " CTRL-V and SHIFT-Insert are Paste
!     map <C-V>		"+gP
!     map <S-Insert>		"+gP
  
!     cmap <C-V>		<C-R>+
!     cmap <S-Insert>		<C-R>+
! endif
  
  " Pasting blockwise and linewise selections is not possible in Insert and
  " Visual mode without the +virtualedit feature.  They are pasted as if they
***************
*** 44,51 ****
  " Uses the paste.vim autoload script.
  " Use CTRL-G u to have CTRL-Z only undo the paste.
  
! exe 'inoremap <script> <C-V> <C-G>u' . paste#paste_cmd['i']
! exe 'vnoremap <script> <C-V> ' . paste#paste_cmd['v']
  
  imap <S-Insert>		<C-V>
  vmap <S-Insert>		<C-V>
--- 46,55 ----
  " Uses the paste.vim autoload script.
  " Use CTRL-G u to have CTRL-Z only undo the paste.
  
! if 1
!     exe 'inoremap <script> <C-V> <C-G>u' . paste#paste_cmd['i']
!     exe 'vnoremap <script> <C-V> ' . paste#paste_cmd['v']
! endif
  
  imap <S-Insert>		<C-V>
  vmap <S-Insert>		<C-V>
***************
*** 99,104 ****
--- 103,120 ----
  cnoremap <C-F4> <C-C><C-W>c
  onoremap <C-F4> <C-C><C-W>c
  
+ if has("gui")
+   " CTRL-F is the search dialog
+   noremap <C-F> :promptfind<CR>
+   inoremap <C-F> <C-\><C-O>:promptfind<CR>
+   cnoremap <C-F> <C-\><C-C>:promptfind<CR>
+ 
+   " CTRL-H is the replace dialog
+   noremap <C-H> :promptrepl<CR>
+   inoremap <C-H> <C-\><C-O>:promptrepl<CR>
+   cnoremap <C-H> <C-\><C-C>:promptrepl<CR>
+ endif
+ 
  " restore 'cpoptions'
  set cpo&
  if 1
*** ../vim-8.0.0320/runtime/macros/matchit.vim	2016-03-25 18:31:26.000000000 +0100
--- runtime/macros/matchit.vim	2017-02-09 20:16:14.216659979 +0100
***************
*** 1,3 ****
  " Load the matchit package.
  " For those users who were loading the matchit plugin from here.
! packadd matchit
--- 1,5 ----
  " Load the matchit package.
  " For those users who were loading the matchit plugin from here.
! if 1
!     packadd matchit
! endif
*** ../vim-8.0.0320/src/version.c	2017-02-09 18:25:09.151838714 +0100
--- src/version.c	2017-02-09 20:18:58.739366457 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     321,
  /**/

-- 
We apologise again for the fault in the subtitles.  Those responsible for
sacking the people who have just been sacked have been sacked.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0322
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0322
Problem:    Possible overflow with spell file where the tree length is
            corrupted.
Solution:   Check for an invalid length (suggested by shqking)
Files:      src/spellfile.c


*** ../vim-8.0.0321/src/spellfile.c	2016-08-29 22:42:20.000000000 +0200
--- src/spellfile.c	2017-02-09 20:54:32.818677322 +0100
***************
*** 1595,1600 ****
--- 1595,1603 ----
      len = get4c(fd);
      if (len < 0)
  	return SP_TRUNCERROR;
+     if (len >= 0x3ffffff)
+ 	/* Invalid length, multiply with sizeof(int) would overflow. */
+ 	return SP_FORMERROR;
      if (len > 0)
      {
  	/* Allocate the byte array. */
*** ../vim-8.0.0321/src/version.c	2017-02-09 20:22:25.997738785 +0100
--- src/version.c	2017-02-09 21:06:28.109105811 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     322,
  /**/

-- 
System administrators are just like women: You can't live with them and you
can't live without them.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0323
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0323
Problem:    When running the command line tests there is a one second wait.
Solution:   Change an Esc to Ctrl-C. (Yegappan Lakshmanan)
Files:      src/testdir/test_cmdline.vim


*** ../vim-8.0.0322/src/testdir/test_cmdline.vim	2017-02-06 22:22:12.896581284 +0100
--- src/testdir/test_cmdline.vim	2017-02-09 21:40:49.756979222 +0100
***************
*** 353,359 ****
    call feedkeys("?MyCmd a\<C-R>=Check_cmdline('?')\<CR>\<Esc>", "xt")
  
    call feedkeys(":call input('Answer?')\<CR>", "t")
!   call feedkeys("MyCmd a\<C-R>=Check_cmdline('@')\<CR>\<Esc>", "xt")
  
    call feedkeys(":insert\<CR>MyCmd a\<C-R>=Check_cmdline('-')\<CR>\<Esc>", "xt")
  
--- 353,359 ----
    call feedkeys("?MyCmd a\<C-R>=Check_cmdline('?')\<CR>\<Esc>", "xt")
  
    call feedkeys(":call input('Answer?')\<CR>", "t")
!   call feedkeys("MyCmd a\<C-R>=Check_cmdline('@')\<CR>\<C-C>", "xt")
  
    call feedkeys(":insert\<CR>MyCmd a\<C-R>=Check_cmdline('-')\<CR>\<Esc>", "xt")
  
*** ../vim-8.0.0322/src/version.c	2017-02-09 21:07:07.040797650 +0100
--- src/version.c	2017-02-09 21:43:01.559976085 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     323,
  /**/

-- 
The problem with political jokes is that they get elected.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0324
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0324
Problem:    Illegal memory access with "1;y".
Solution:   Call check_cursor() instead of check_cursor_lnum(). (Dominique
            Pelle, closes #1455)
Files:      src/ex_docmd.c, src/testdir/test_cmdline.vim


*** ../vim-8.0.0323/src/ex_docmd.c	2017-02-03 21:19:00.289942006 +0100
--- src/ex_docmd.c	2017-02-09 22:23:51.624952936 +0100
***************
*** 2295,2302 ****
  	    if (!ea.skip)
  	    {
  		curwin->w_cursor.lnum = ea.line2;
! 		/* don't leave the cursor on an illegal line */
! 		check_cursor_lnum();
  	    }
  	}
  	else if (*ea.cmd != ',')
--- 2295,2302 ----
  	    if (!ea.skip)
  	    {
  		curwin->w_cursor.lnum = ea.line2;
! 		/* don't leave the cursor on an illegal line or column */
! 		check_cursor();
  	    }
  	}
  	else if (*ea.cmd != ',')
*** ../vim-8.0.0323/src/testdir/test_cmdline.vim	2017-02-09 21:43:59.167536390 +0100
--- src/testdir/test_cmdline.vim	2017-02-09 22:22:22.245648699 +0100
***************
*** 289,301 ****
    call assert_equal('"def', @:)
  endfunc
  
! func Test_illegal_address()
    new
    2;'(
    2;')
    quit
  endfunc
  
  func Test_cmdline_complete_wildoptions()
    help
    call feedkeys(":tag /\<c-a>\<c-b>\"\<cr>", 'tx')
--- 289,312 ----
    call assert_equal('"def', @:)
  endfunc
  
! func Test_illegal_address1()
    new
    2;'(
    2;')
    quit
  endfunc
  
+ func Test_illegal_address2()
+   call writefile(['c', 'x', '  x', '.', '1;y'], 'Xtest.vim')
+   new
+   source Xtest.vim
+   " Trigger calling validate_cursor()
+   diffsp Xtest.vim
+   quit!
+   bwipe!
+   call delete('Xtest.vim')
+ endfunc
+ 
  func Test_cmdline_complete_wildoptions()
    help
    call feedkeys(":tag /\<c-a>\<c-b>\"\<cr>", 'tx')
*** ../vim-8.0.0323/src/version.c	2017-02-09 21:43:59.171536358 +0100
--- src/version.c	2017-02-09 22:27:11.787395030 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     324,
  /**/

-- 
SOLDIER: What?  Ridden on a horse?
ARTHUR:  Yes!
SOLDIER: You're using coconuts!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0325
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0325
Problem:    Packadd test does not clean up symlink.
Solution:   Delete the link. (Hirohito Higashi)
Files:      src/testdir/test_packadd.vim


*** ../vim-8.0.0324/src/testdir/test_packadd.vim	2017-02-05 16:07:50.291087646 +0100
--- src/testdir/test_packadd.vim	2017-02-11 11:32:27.880899001 +0100
***************
*** 98,103 ****
--- 98,104 ----
  
    set rtp&
    let rtp = &rtp
+   silent !rm top2_dir
  endfunc
  
  " Check command-line completion for 'packadd'
*** ../vim-8.0.0324/src/version.c	2017-02-09 22:28:11.354931464 +0100
--- src/version.c	2017-02-11 11:34:13.340127348 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     325,
  /**/

-- 
./configure
Checking whether build environment is sane ...
build environment is grinning and holding a spatula.  Guess not.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0326
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0326 (after 8.0.0325)
Problem:    Packadd test uses wrong directory name.
Solution:   Use the variable name value. (Hirohito Higashi)
Files:      src/testdir/test_packadd.vim


*** ../vim-8.0.0325/src/testdir/test_packadd.vim	2017-02-11 11:34:55.363822971 +0100
--- src/testdir/test_packadd.vim	2017-02-11 22:56:08.619619275 +0100
***************
*** 73,79 ****
    endif
    let top2_dir = s:topdir . '/Xdir2'
    let real_dir = s:topdir . '/Xsym'
!   silent !ln -s real_dir top2_dir
    let &rtp = top2_dir . ',' . top2_dir . '/after'
    let &packpath = &rtp
  
--- 73,79 ----
    endif
    let top2_dir = s:topdir . '/Xdir2'
    let real_dir = s:topdir . '/Xsym'
!   exec "silent !ln -s" real_dir top2_dir
    let &rtp = top2_dir . ',' . top2_dir . '/after'
    let &packpath = &rtp
  
***************
*** 98,104 ****
  
    set rtp&
    let rtp = &rtp
!   silent !rm top2_dir
  endfunc
  
  " Check command-line completion for 'packadd'
--- 98,104 ----
  
    set rtp&
    let rtp = &rtp
!   exec "silent !rm" top2_dir
  endfunc
  
  " Check command-line completion for 'packadd'
*** ../vim-8.0.0325/src/version.c	2017-02-11 11:34:55.363822971 +0100
--- src/version.c	2017-02-11 22:58:27.762642537 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     326,
  /**/

-- 
BODY:        I'm not dead!
CART DRIVER: 'Ere.  He says he's not dead.
LARGE MAN:   Yes he is.
BODY:        I'm not!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0327
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0327
Problem:    The E11 error message in the command line window is not
            translated.
Solution:   use _(). (Hirohito Higashi)
Files:      src/ex_docmd.c


*** ../vim-8.0.0326/src/ex_docmd.c	2017-02-09 22:28:11.350931496 +0100
--- src/ex_docmd.c	2017-02-12 18:31:01.371334307 +0100
***************
*** 2490,2496 ****
  		&& !IS_USER_CMDIDX(ea.cmdidx))
  	{
  	    /* Command not allowed when editing the command line. */
! 	    errormsg = get_text_locked_msg();
  	    goto doend;
  	}
  #ifdef FEAT_AUTOCMD
--- 2490,2496 ----
  		&& !IS_USER_CMDIDX(ea.cmdidx))
  	{
  	    /* Command not allowed when editing the command line. */
! 	    errormsg = (char_u *)_(get_text_locked_msg());
  	    goto doend;
  	}
  #ifdef FEAT_AUTOCMD
*** ../vim-8.0.0326/src/version.c	2017-02-11 23:00:31.409774572 +0100
--- src/version.c	2017-02-12 18:32:06.466868166 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     327,
  /**/

-- 
ARTHUR: I've said I'm sorry about the old woman, but from the behind you
        looked ...
DENNIS: What I object to is that you automatically treat me like an inferior...
ARTHUR: Well ... I AM king.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0328
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0328
Problem:    The "zero count" error doesn't have a number. (Hirohito Higashi)
Solution:   Give it a number and be more specific about the error.
Files:      src/globals.h


*** ../vim-8.0.0327/src/globals.h	2016-11-24 15:09:03.405856662 +0100
--- src/globals.h	2017-02-12 18:41:05.479020061 +0100
***************
*** 1581,1587 ****
  EXTERN char_u e_winwidth[]	INIT(= N_("E592: 'winwidth' cannot be smaller than 'winminwidth'"));
  #endif
  EXTERN char_u e_write[]		INIT(= N_("E80: Error while writing"));
! EXTERN char_u e_zerocount[]	INIT(= N_("Zero count"));
  #ifdef FEAT_EVAL
  EXTERN char_u e_usingsid[]	INIT(= N_("E81: Using <SID> not in a script context"));
  #endif
--- 1581,1587 ----
  EXTERN char_u e_winwidth[]	INIT(= N_("E592: 'winwidth' cannot be smaller than 'winminwidth'"));
  #endif
  EXTERN char_u e_write[]		INIT(= N_("E80: Error while writing"));
! EXTERN char_u e_zerocount[]	INIT(= N_("E939: Positive count required"));
  #ifdef FEAT_EVAL
  EXTERN char_u e_usingsid[]	INIT(= N_("E81: Using <SID> not in a script context"));
  #endif
*** ../vim-8.0.0327/src/version.c	2017-02-12 18:34:00.898048918 +0100
--- src/version.c	2017-02-12 18:42:46.870296794 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     328,
  /**/

-- 
ARTHUR:    ... and I am your king ....
OLD WOMAN: Ooooh!  I didn't know we had a king.  I thought we were an
           autonomous collective ...
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0329
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0329
Problem:    Xfontset and guifontwide are not tested.
Solution:   Add tests. (Kazunobu Kuriyama)
Files:      src/testdir/test_gui.vim


*** ../vim-8.0.0328/src/testdir/test_gui.vim	2017-02-09 16:14:47.890179799 +0100
--- src/testdir/test_gui.vim	2017-02-12 19:53:47.124065730 +0100
***************
*** 131,136 ****
--- 131,278 ----
    endif
  endfunc
  
+ func Test_set_guifontset()
+   let skipped = 0
+ 
+   if has('xfontset')
+     let l:ctype_saved = v:ctype
+ 
+     " For UTF-8 locales, XCreateFontSet(3) is likely to fail in constructing a
+     " fontset automatically from one or two simple XLFDs because it requires
+     " the host system to have a fairly comprehensive collection of fixed-width
+     " fonts with various sizes and registries/encodings in order to get the
+     " job done.  To make the test meaningful for a wide variety of hosts, we
+     " confine ourselves to the following locale for which X11 historically has
+     " the fonts to use with.
+     language ctype ja_JP.eucJP
+ 
+     " Since XCreateFontSet(3) is very sensitive to locale, fonts must be
+     " chosen meticulously.
+     let l:font_head = '-misc-fixed-medium-r-normal--14'
+ 
+     let l:font_aw70 = l:font_head . '-130-75-75-c-70'
+     let l:font_aw140 = l:font_head . '-130-75-75-c-140'
+ 
+     let l:font_jisx0201 = l:font_aw70 . '-jisx0201.1976-0'
+     let l:font_jisx0208 = l:font_aw140 . '-jisx0208.1983-0'
+ 
+     " Full XLFDs
+     let l:fontset_name = join([ l:font_jisx0208, l:font_jisx0201 ], ',')
+     exec 'set guifontset=' . l:fontset_name
+     call assert_equal(l:fontset_name, &guifontset)
+ 
+     " XLFDs w/o CharSetRegistry and CharSetEncoding
+     let l:fontset_name = join([ l:font_aw140, l:font_aw70 ], ',')
+     exec 'set guifontset=' . l:fontset_name
+     call assert_equal(l:fontset_name, &guifontset)
+ 
+     " Singleton
+     let l:fontset_name = l:font_head . '-*'
+     exec 'set guifontset=' . l:fontset_name
+     call assert_equal(l:fontset_name, &guifontset)
+ 
+     " Aliases
+     let l:fontset_name = 'k14,r14'
+     exec 'set guifontset=' . l:fontset_name
+     call assert_equal(l:fontset_name, &guifontset)
+ 
+     exec 'language ctype' l:ctype_saved
+ 
+   else
+     let skipped = 1
+   endif
+ 
+   if skipped
+     throw "Skipped: Not supported by this GUI"
+   endif
+ endfunc
+ 
+ func Test_set_guifontwide()
+   let skipped = 0
+ 
+   if has('gui_gtk')
+     let l:guifont_saved = &guifont
+     let l:guifontwide_saved = &guifontwide
+ 
+     let l:fc_match = exepath('fc-match')
+     if l:fc_match != ''
+       let &guifont = system('fc-match -f "%{family[0]} %{size}" monospace:size=10')
+       let l:wide = system('fc-match -f "%{family[0]} %{size}" monospace:size=10:lang=ja')
+       exec 'set guifontwide=' . fnameescape(l:wide)
+       call assert_equal(l:wide, &guifontwide)
+     else
+       let skipped = 3
+     endif
+ 
+     let &guifontwide = l:guifontwide_saved
+     let &guifont = l:guifont_saved
+ 
+   elseif has('gui_athena') || has('gui_motif')
+     " guifontwide is premised upon the xfontset feature.
+     if has('xfontset')
+       let l:encoding_saved = &encoding
+       let l:guifont_saved = &guifont
+       let l:guifontset_saved = &guifontset
+       let l:guifontwide_saved = &guifontwide
+ 
+       let l:nfont = '-misc-fixed-medium-r-normal-*-18-120-100-100-c-90-iso10646-1'
+       let l:wfont = '-misc-fixed-medium-r-normal-*-18-120-100-100-c-180-iso10646-1'
+ 
+       set encoding=utf-8
+ 
+       " Case 1: guifontset is empty
+       set guifontset=
+ 
+       " Case 1-1: Automatic selection
+       set guifontwide=
+       exec 'set guifont=' . l:nfont
+       call assert_equal(l:wfont, &guifontwide)
+ 
+       " Case 1-2: Manual selection
+       exec 'set guifontwide=' . l:wfont
+       exec 'set guifont=' . l:nfont
+       call assert_equal(l:wfont, &guifontwide)
+ 
+       " Case 2: guifontset is invalid
+       try
+         set guifontset=-*-notexist-*
+         call assert_false(1, "'set guifontset=notexist' should have failed")
+       catch
+         call assert_exception('E598')
+       endtry
+       " Set it to an invalid value brutally for preparation.
+       let &guifontset = '-*-notexist-*'
+ 
+       " Case 2-1: Automatic selection
+       set guifontwide=
+       exec 'set guifont=' . l:nfont
+       call assert_equal(l:wfont, &guifontwide)
+ 
+       " Case 2-2: Manual selection
+       exec 'set guifontwide=' . l:wfont
+       exec 'set guifont=' . l:nfont
+       call assert_equal(l:wfont, &guifontwide)
+ 
+       let &guifontwide = l:guifontwide_saved
+       let &guifontset = l:guifontset_saved
+       let &guifont = l:guifont_saved
+       let &encoding = l:encoding_saved
+     else
+       let skipped = 2
+     endif
+   else
+     let skipped = 1
+   endif
+ 
+   if skipped == 1
+     throw "Skipped: Test not implemented yet for this GUI"
+   elseif skipped == 2
+     throw "Skipped: Not supported by this GUI"
+   elseif skipped == 3
+     throw "Skipped: Test not supported by the environment"
+   endif
+ endfunc
+ 
  func Test_getwinpos()
    call assert_match('Window position: X \d\+, Y \d\+', execute('winpos'))
    call assert_true(getwinposx() >= 0)
*** ../vim-8.0.0328/src/version.c	2017-02-12 18:45:19.281209607 +0100
--- src/version.c	2017-02-12 19:56:14.067031026 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     329,
  /**/

-- 
ARTHUR:    Be quiet!  I order you to shut up.
OLD WOMAN: Order, eh -- who does he think he is?
ARTHUR:    I am your king!
OLD WOMAN: Well, I didn't vote for you.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0330
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0330
Problem:    Illegal memory access after "vapo". (Dominique Pelle)
Solution:   Fix the cursor column.
Files:      src/search.c, src/testdir/test_visual.vim


*** ../vim-8.0.0329/src/search.c	2016-12-01 17:25:16.795864620 +0100
--- src/search.c	2017-02-17 11:36:12.916156355 +0100
***************
*** 4241,4247 ****
  	 * line, we get stuck there.  Trap this here. */
  	if (VIsual_mode == 'V' && start_lnum == curwin->w_cursor.lnum)
  	    goto extend;
! 	VIsual.lnum = start_lnum;
  	VIsual_mode = 'V';
  	redraw_curbuf_later(INVERTED);	/* update the inversion */
  	showmode();
--- 4241,4251 ----
  	 * line, we get stuck there.  Trap this here. */
  	if (VIsual_mode == 'V' && start_lnum == curwin->w_cursor.lnum)
  	    goto extend;
! 	if (VIsual.lnum != start_lnum)
! 	{
! 	    VIsual.lnum = start_lnum;
! 	    VIsual.col = 0;
! 	}
  	VIsual_mode = 'V';
  	redraw_curbuf_later(INVERTED);	/* update the inversion */
  	showmode();
*** ../vim-8.0.0329/src/testdir/test_visual.vim	2017-02-01 21:50:16.740465816 +0100
--- src/testdir/test_visual.vim	2017-02-17 11:28:10.619652646 +0100
***************
*** 36,38 ****
--- 36,45 ----
    set tw&
    bw!
  endfu
+ 
+ func Test_Visual_vapo()
+   new
+   normal oxx
+   normal vapo
+   bwipe!
+ endfunc
*** ../vim-8.0.0329/src/version.c	2017-02-12 19:59:02.941841612 +0100
--- src/version.c	2017-02-17 11:39:06.214901022 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     330,
  /**/

-- 
Eye have a spelling checker, it came with my PC;
It plainly marks four my revue mistakes I cannot sea.
I've run this poem threw it, I'm sure your please to no,
It's letter perfect in it's weigh, my checker tolled me sew!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0331
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0331
Problem:    Restoring help snapshot accesses freed memory. (Dominique Pelle)
Solution:   Don't restore a snapshot when the window closes.
Files:      src/window.c, src/Makefile, src/testdir/Make_all.mak,
            src/testdir/test_help.vim


*** ../vim-8.0.0330/src/window.c	2017-02-05 15:10:47.743484042 +0100
--- src/window.c	2017-02-17 12:01:00.677367540 +0100
***************
*** 6551,6557 ****
  
  /*
   * Check if frames "sn" and "fr" have the same layout, same following frames
!  * and same children.
   */
      static int
  check_snapshot_rec(frame_T *sn, frame_T *fr)
--- 6551,6557 ----
  
  /*
   * Check if frames "sn" and "fr" have the same layout, same following frames
!  * and same children.  And the window pointer is valid.
   */
      static int
  check_snapshot_rec(frame_T *sn, frame_T *fr)
***************
*** 6562,6568 ****
  	    || (sn->fr_next != NULL
  		&& check_snapshot_rec(sn->fr_next, fr->fr_next) == FAIL)
  	    || (sn->fr_child != NULL
! 		&& check_snapshot_rec(sn->fr_child, fr->fr_child) == FAIL))
  	return FAIL;
      return OK;
  }
--- 6562,6569 ----
  	    || (sn->fr_next != NULL
  		&& check_snapshot_rec(sn->fr_next, fr->fr_next) == FAIL)
  	    || (sn->fr_child != NULL
! 		&& check_snapshot_rec(sn->fr_child, fr->fr_child) == FAIL)
! 	    || !win_valid(sn->fr_win))
  	return FAIL;
      return OK;
  }
*** ../vim-8.0.0330/src/Makefile	2017-02-05 21:14:26.743355267 +0100
--- src/Makefile	2017-02-17 11:51:41.121426165 +0100
***************
*** 2132,2137 ****
--- 2132,2138 ----
  	test_goto \
  	test_gui \
  	test_hardcopy \
+ 	test_help \
  	test_help_tagjump \
  	test_hide \
  	test_history \
*** ../vim-8.0.0330/src/testdir/Make_all.mak	2017-02-05 21:14:26.743355267 +0100
--- src/testdir/Make_all.mak	2017-02-17 11:51:59.109295603 +0100
***************
*** 154,159 ****
--- 154,160 ----
  	    test_gn.res \
  	    test_gui.res \
  	    test_hardcopy.res \
+ 	    test_help.res \
  	    test_hide.res \
  	    test_history.res \
  	    test_hlsearch.res \
*** ../vim-8.0.0330/src/testdir/test_help.vim	2017-02-17 12:04:13.075973270 +0100
--- src/testdir/test_help.vim	2017-02-17 11:49:54.030203593 +0100
***************
*** 0 ****
--- 1,10 ----
+ " Tests for :help
+ 
+ func Test_help_restore_snapshot()
+   help
+   set buftype=
+   help
+   edit x
+   help
+   helpclose
+ endfunc
*** ../vim-8.0.0330/src/version.c	2017-02-17 11:39:54.994547761 +0100
--- src/version.c	2017-02-17 12:02:59.864503746 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     331,
  /**/

-- 
Westheimer's Discovery:
        A couple of months in the laboratory can
        frequently save a couple of hours in the library.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0332
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0332
Problem:    GUI test fails on some systems.
Solution:   Try different language settings. (Kazunobu Kuriyama)
Files:      src/testdir/test_gui.vim


*** ../vim-8.0.0331/src/testdir/test_gui.vim	2017-02-12 19:59:02.937841640 +0100
--- src/testdir/test_gui.vim	2017-02-17 13:35:24.103505472 +0100
***************
*** 7,12 ****
--- 7,17 ----
  let s:x11_based_gui = has('gui_athena') || has('gui_motif')
  	\ || has('gui_gtk2') || has('gui_gnome') || has('gui_gtk3')
  
+ " Reasons for 'skipped'.
+ let s:not_supported   = "Skipped: Feature/Option not supported by this GUI: "
+ let s:not_implemented = "Skipped: Test not implemented yet for this GUI"
+ let s:not_hosted      = "Skipped: Test not hosted by the system/environment"
+ 
  " For KDE set a font, empty 'guifont' may cause a hang.
  func SetUp()
    if has("gui_kde")
***************
*** 36,96 ****
  endfunc
  
  func Test_getfontname_with_arg()
!   if has('gui_athena') || has('gui_motif')
      " Invalid font name. The result should be an empty string.
      call assert_equal('', getfontname('notexist'))
  
      " Valid font name. This is usually the real name of 7x13 by default.
!     let l:fname = '-misc-fixed-medium-r-normal--13-120-75-75-c-70-iso8859-1'
!     call assert_equal(l:fname, getfontname(l:fname))
  
    elseif has('gui_gtk2') || has('gui_gnome') || has('gui_gtk3')
      " Invalid font name. The result should be the name plus the default size.
      call assert_equal('notexist 10', getfontname('notexist'))
  
      " Valid font name. This is usually the real name of Monospace by default.
!     let l:fname = 'Bitstream Vera Sans Mono 12'
!     call assert_equal(l:fname, getfontname(l:fname))
!   else
!     throw "Skipped: Matched font name unpredictable to test on this GUI"
    endif
  endfunc
  
  func Test_getfontname_without_arg()
!   let l:fname = getfontname()
!   if has('gui_kde')
      " 'expected' is the value specified by SetUp() above.
!     call assert_equal('Courier 10 Pitch/8/-1/5/50/0/0/0/0/0', l:fname)
    elseif has('gui_athena') || has('gui_motif')
      " 'expected' is DFLT_FONT of gui_x11.c.
!     call assert_equal('7x13', l:fname)
    elseif has('gui_gtk2') || has('gui_gnome') || has('gui_gtk3')
      " 'expected' is DEFAULT_FONT of gui_gtk_x11.c.
!     call assert_equal('Monospace 10', l:fname)
!   else
!     throw "Skipped: Default font name unpredictable to test on this GUI"
    endif
  endfunc
  
  func Test_set_guifont()
!   let l:guifont_saved = &guifont
    if has('xfontset')
      " Prevent 'guifontset' from canceling 'guifont'.
!     let l:guifontset_saved = &guifontset
      set guifontset=
    endif
  
!   let skipped = 0
!   if has('gui_athena') || has('gui_motif')
      " Non-empty font list with invalid font names.
      "
      " This test is twofold: (1) It checks if the command fails as expected
      " when there are no loadable fonts found in the list. (2) It checks if
      " 'guifont' remains the same after the command loads none of the fonts
      " listed.
!     let l:flist = &guifont
      call assert_fails('set guifont=-notexist1-*,-notexist2-*')
!     call assert_equal(l:flist, &guifont)
  
      " Non-empty font list with a valid font name.  Should pick up the first
      " valid font.
--- 41,117 ----
  endfunc
  
  func Test_getfontname_with_arg()
!   let skipped = ''
! 
!   if !s:x11_based_gui
!     let skipped = s:not_implemented
!   elseif has('gui_athena') || has('gui_motif')
      " Invalid font name. The result should be an empty string.
      call assert_equal('', getfontname('notexist'))
  
      " Valid font name. This is usually the real name of 7x13 by default.
!     let fname = '-misc-fixed-medium-r-normal--13-120-75-75-c-70-iso8859-1'
!     call assert_equal(fname, getfontname(fname))
  
    elseif has('gui_gtk2') || has('gui_gnome') || has('gui_gtk3')
      " Invalid font name. The result should be the name plus the default size.
      call assert_equal('notexist 10', getfontname('notexist'))
  
      " Valid font name. This is usually the real name of Monospace by default.
!     let fname = 'Bitstream Vera Sans Mono 12'
!     call assert_equal(fname, getfontname(fname))
!   endif
! 
!   if !empty(skipped)
!     throw skipped
    endif
  endfunc
  
  func Test_getfontname_without_arg()
!   let skipped = ''
! 
!   let fname = getfontname()
! 
!   if !s:x11_based_gui
!     let skipped = s:not_implemented
!   elseif has('gui_kde')
      " 'expected' is the value specified by SetUp() above.
!     call assert_equal('Courier 10 Pitch/8/-1/5/50/0/0/0/0/0', fname)
    elseif has('gui_athena') || has('gui_motif')
      " 'expected' is DFLT_FONT of gui_x11.c.
!     call assert_equal('7x13', fname)
    elseif has('gui_gtk2') || has('gui_gnome') || has('gui_gtk3')
      " 'expected' is DEFAULT_FONT of gui_gtk_x11.c.
!     call assert_equal('Monospace 10', fname)
!   endif
! 
!   if !empty(skipped)
!     throw skipped
    endif
  endfunc
  
  func Test_set_guifont()
!   let skipped = ''
! 
!   let guifont_saved = &guifont
    if has('xfontset')
      " Prevent 'guifontset' from canceling 'guifont'.
!     let guifontset_saved = &guifontset
      set guifontset=
    endif
  
!   if !s:x11_based_gui
!     let skipped = s:not_implemented
!   elseif has('gui_athena') || has('gui_motif')
      " Non-empty font list with invalid font names.
      "
      " This test is twofold: (1) It checks if the command fails as expected
      " when there are no loadable fonts found in the list. (2) It checks if
      " 'guifont' remains the same after the command loads none of the fonts
      " listed.
!     let flist = &guifont
      call assert_fails('set guifont=-notexist1-*,-notexist2-*')
!     call assert_equal(flist, &guifont)
  
      " Non-empty font list with a valid font name.  Should pick up the first
      " valid font.
***************
*** 116,222 ****
      " Empty list. Should fallback to the built-in default.
      set guifont=
      call assert_equal('Monospace 10', getfontname())
- 
-   else
-     let skipped = 1
    endif
  
    if has('xfontset')
!     let &guifontset = l:guifontset_saved
    endif
!   let &guifont = l:guifont_saved
  
!   if skipped
!     throw "Skipped: Test not implemented yet for this GUI"
    endif
  endfunc
  
  func Test_set_guifontset()
!   let skipped = 0
  
!   if has('xfontset')
!     let l:ctype_saved = v:ctype
  
!     " For UTF-8 locales, XCreateFontSet(3) is likely to fail in constructing a
!     " fontset automatically from one or two simple XLFDs because it requires
!     " the host system to have a fairly comprehensive collection of fixed-width
!     " fonts with various sizes and registries/encodings in order to get the
!     " job done.  To make the test meaningful for a wide variety of hosts, we
!     " confine ourselves to the following locale for which X11 historically has
!     " the fonts to use with.
!     language ctype ja_JP.eucJP
! 
!     " Since XCreateFontSet(3) is very sensitive to locale, fonts must be
!     " chosen meticulously.
!     let l:font_head = '-misc-fixed-medium-r-normal--14'
! 
!     let l:font_aw70 = l:font_head . '-130-75-75-c-70'
!     let l:font_aw140 = l:font_head . '-130-75-75-c-140'
! 
!     let l:font_jisx0201 = l:font_aw70 . '-jisx0201.1976-0'
!     let l:font_jisx0208 = l:font_aw140 . '-jisx0208.1983-0'
! 
!     " Full XLFDs
!     let l:fontset_name = join([ l:font_jisx0208, l:font_jisx0201 ], ',')
!     exec 'set guifontset=' . l:fontset_name
!     call assert_equal(l:fontset_name, &guifontset)
! 
!     " XLFDs w/o CharSetRegistry and CharSetEncoding
!     let l:fontset_name = join([ l:font_aw140, l:font_aw70 ], ',')
!     exec 'set guifontset=' . l:fontset_name
!     call assert_equal(l:fontset_name, &guifontset)
! 
!     " Singleton
!     let l:fontset_name = l:font_head . '-*'
!     exec 'set guifontset=' . l:fontset_name
!     call assert_equal(l:fontset_name, &guifontset)
! 
!     " Aliases
!     let l:fontset_name = 'k14,r14'
!     exec 'set guifontset=' . l:fontset_name
!     call assert_equal(l:fontset_name, &guifontset)
  
!     exec 'language ctype' l:ctype_saved
  
!   else
!     let skipped = 1
    endif
  
!   if skipped
!     throw "Skipped: Not supported by this GUI"
    endif
  endfunc
  
  func Test_set_guifontwide()
!   let skipped = 0
  
!   if has('gui_gtk')
!     let l:guifont_saved = &guifont
!     let l:guifontwide_saved = &guifontwide
! 
!     let l:fc_match = exepath('fc-match')
!     if l:fc_match != ''
!       let &guifont = system('fc-match -f "%{family[0]} %{size}" monospace:size=10')
!       let l:wide = system('fc-match -f "%{family[0]} %{size}" monospace:size=10:lang=ja')
!       exec 'set guifontwide=' . fnameescape(l:wide)
!       call assert_equal(l:wide, &guifontwide)
      else
!       let skipped = 3
      endif
  
!     let &guifontwide = l:guifontwide_saved
!     let &guifont = l:guifont_saved
  
    elseif has('gui_athena') || has('gui_motif')
      " guifontwide is premised upon the xfontset feature.
!     if has('xfontset')
!       let l:encoding_saved = &encoding
!       let l:guifont_saved = &guifont
!       let l:guifontset_saved = &guifontset
!       let l:guifontwide_saved = &guifontwide
  
!       let l:nfont = '-misc-fixed-medium-r-normal-*-18-120-100-100-c-90-iso10646-1'
!       let l:wfont = '-misc-fixed-medium-r-normal-*-18-120-100-100-c-180-iso10646-1'
  
        set encoding=utf-8
  
--- 137,260 ----
      " Empty list. Should fallback to the built-in default.
      set guifont=
      call assert_equal('Monospace 10', getfontname())
    endif
  
    if has('xfontset')
!     let &guifontset = guifontset_saved
    endif
!   let &guifont = guifont_saved
  
!   if !empty(skipped)
!     throw skipped
    endif
  endfunc
  
  func Test_set_guifontset()
!   let skipped = ''
  
!   if !has('xfontset')
!     let skipped = s:not_supported . 'xfontset'
!   else
!     let ctype_saved = v:ctype
  
!     " First, since XCreateFontSet(3) is very sensitive to locale, fonts must
!     " be chosen meticulously.
!     let font_head = '-misc-fixed-medium-r-normal--14'
! 
!     let font_aw70 = font_head . '-130-75-75-c-70'
!     let font_aw140 = font_head . '-130-75-75-c-140'
! 
!     let font_jisx0201 = font_aw70 . '-jisx0201.1976-0'
!     let font_jisx0208 = font_aw140 . '-jisx0208.1983-0'
! 
!     let full_XLFDs = join([ font_jisx0208, font_jisx0201 ], ',')
!     let short_XLFDs = join([ font_aw140, font_aw70 ], ',')
!     let singleton = font_head . '-*'
!     let aliases = 'k14,r14'
! 
!     " Second, among 'locales', look up such a locale that gets 'set
!     " guifontset=' to work successfully with every fontset specified with
!     " 'fontsets'.
!     let locales = [ 'ja_JP.UTF-8', 'ja_JP.eucJP', 'ja_JP.SJIS' ]
!     let fontsets = [ full_XLFDs, short_XLFDs, singleton, aliases ]
  
!     let feasible = 0
!     for locale in locales
!       try
!         exec 'language ctype' locale
!       catch /^Vim\%((\a\+)\)\=:E197/
!         continue
!       endtry
!       let done = 0
!       for fontset in fontsets
!         try
!           exec 'set guifontset=' . fontset
!         catch /^Vim\%((\a\+)\)\=:E\%(250\|252\|234\|597\|598\)/
!           break
!         endtry
!         let done += 1
!       endfor
!       if done == len(fontsets)
!         let feasible = 1
!         break
!       endif
!     endfor
! 
!     " Third, give a set of tests if it is found feasible.
!     if !feasible
!       let skipped = s:not_hosted
!     else
!       " N.B. 'v:ctype' has already been set to an appropriate value in the
!       " previous loop.
!       for fontset in fontsets
!         exec 'set guifontset=' . fontset
!         call assert_equal(fontset, &guifontset)
!       endfor
!     endif
  
!     " Finally, restore ctype.
!     exec 'language ctype' ctype_saved
    endif
  
!   if !empty(skipped)
!     throw skipped
    endif
  endfunc
  
  func Test_set_guifontwide()
!   let skipped = ''
  
!   if !s:x11_based_gui
!     let skipped = s:not_implemented
!   elseif has('gui_gtk')
!     let guifont_saved = &guifont
!     let guifontwide_saved = &guifontwide
! 
!     let fc_match = exepath('fc-match')
!     if empty(fc_match)
!       let skipped = s:not_hosted
      else
!       let &guifont = system('fc-match -f "%{family[0]} %{size}" monospace:size=10:lang=en')
!       let wide = system('fc-match -f "%{family[0]} %{size}" monospace:size=10:lang=ja')
!       exec 'set guifontwide=' . fnameescape(wide)
!       call assert_equal(wide, &guifontwide)
      endif
  
!     let &guifontwide = guifontwide_saved
!     let &guifont = guifont_saved
  
    elseif has('gui_athena') || has('gui_motif')
      " guifontwide is premised upon the xfontset feature.
!     if !has('xfontset')
!       let skipped = s:not_supported . 'xfontset'
!     else
!       let encoding_saved    = &encoding
!       let guifont_saved     = &guifont
!       let guifontset_saved  = &guifontset
!       let guifontwide_saved = &guifontwide
  
!       let nfont = '-misc-fixed-medium-r-normal-*-18-120-100-100-c-90-iso10646-1'
!       let wfont = '-misc-fixed-medium-r-normal-*-18-120-100-100-c-180-iso10646-1'
  
        set encoding=utf-8
  
***************
*** 225,242 ****
  
        " Case 1-1: Automatic selection
        set guifontwide=
!       exec 'set guifont=' . l:nfont
!       call assert_equal(l:wfont, &guifontwide)
  
        " Case 1-2: Manual selection
!       exec 'set guifontwide=' . l:wfont
!       exec 'set guifont=' . l:nfont
!       call assert_equal(l:wfont, &guifontwide)
  
        " Case 2: guifontset is invalid
        try
          set guifontset=-*-notexist-*
!         call assert_false(1, "'set guifontset=notexist' should have failed")
        catch
          call assert_exception('E598')
        endtry
--- 263,280 ----
  
        " Case 1-1: Automatic selection
        set guifontwide=
!       exec 'set guifont=' . nfont
!       call assert_equal(wfont, &guifontwide)
  
        " Case 1-2: Manual selection
!       exec 'set guifontwide=' . wfont
!       exec 'set guifont=' . nfont
!       call assert_equal(wfont, &guifontwide)
  
        " Case 2: guifontset is invalid
        try
          set guifontset=-*-notexist-*
!         call assert_false(1, "'set guifontset=-*-notexist-*' should have failed")
        catch
          call assert_exception('E598')
        endtry
***************
*** 245,275 ****
  
        " Case 2-1: Automatic selection
        set guifontwide=
!       exec 'set guifont=' . l:nfont
!       call assert_equal(l:wfont, &guifontwide)
  
        " Case 2-2: Manual selection
!       exec 'set guifontwide=' . l:wfont
!       exec 'set guifont=' . l:nfont
!       call assert_equal(l:wfont, &guifontwide)
! 
!       let &guifontwide = l:guifontwide_saved
!       let &guifontset = l:guifontset_saved
!       let &guifont = l:guifont_saved
!       let &encoding = l:encoding_saved
!     else
!       let skipped = 2
      endif
-   else
-     let skipped = 1
    endif
  
!   if skipped == 1
!     throw "Skipped: Test not implemented yet for this GUI"
!   elseif skipped == 2
!     throw "Skipped: Not supported by this GUI"
!   elseif skipped == 3
!     throw "Skipped: Test not supported by the environment"
    endif
  endfunc
  
--- 283,305 ----
  
        " Case 2-1: Automatic selection
        set guifontwide=
!       exec 'set guifont=' . nfont
!       call assert_equal(wfont, &guifontwide)
  
        " Case 2-2: Manual selection
!       exec 'set guifontwide=' . wfont
!       exec 'set guifont=' . nfont
!       call assert_equal(wfont, &guifontwide)
! 
!       let &guifontwide = guifontwide_saved
!       let &guifontset  = guifontset_saved
!       let &guifont     = guifont_saved
!       let &encoding    = encoding_saved
      endif
    endif
  
!   if !empty(skipped)
!     throw skipped
    endif
  endfunc
  
*** ../vim-8.0.0331/src/version.c	2017-02-17 12:04:35.843808317 +0100
--- src/version.c	2017-02-17 13:36:42.938916108 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     332,
  /**/

-- 
This computer is so slow, it takes forever to execute and endless loop!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0333
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0333
Problem:    Illegal memory access when 'complete' ends in a backslash.
Solution:   Check for trailing backslash. (Dominique Pelle, closes #1478)
Files:      src/option.c, src/testdir/test_options.vim


*** ../vim-8.0.0332/src/option.c	2017-02-05 14:13:12.152033013 +0100
--- src/option.c	2017-02-17 14:39:06.079032637 +0100
***************
*** 7017,7023 ****
  		    /* skip optional filename after 'k' and 's' */
  		    while (*s && *s != ',' && *s != ' ')
  		    {
! 			if (*s == '\\')
  			    ++s;
  			++s;
  		    }
--- 7017,7023 ----
  		    /* skip optional filename after 'k' and 's' */
  		    while (*s && *s != ',' && *s != ' ')
  		    {
! 			if (*s == '\\' && s[1] != NUL)
  			    ++s;
  			++s;
  		    }
*** ../vim-8.0.0332/src/testdir/test_options.vim	2017-02-05 14:13:12.152033013 +0100
--- src/testdir/test_options.vim	2017-02-17 14:46:07.183899766 +0100
***************
*** 136,141 ****
--- 136,150 ----
    call Check_dir_option('thesaurus')
  endfun
  
+ func Test_complete()
+   " Trailing single backslash used to cause invalid memory access.
+   set complete=s\
+   new
+   call feedkeys("i\<C-N>\<Esc>", 'xt')
+   bwipe!
+   set complete&
+ endfun
+ 
  func Test_set_completion()
    call feedkeys(":set di\<C-A>\<C-B>\"\<CR>", 'tx')
    call assert_equal('"set dictionary diff diffexpr diffopt digraph directory display', @:)
*** ../vim-8.0.0332/src/version.c	2017-02-17 13:44:44.299321045 +0100
--- src/version.c	2017-02-17 14:40:33.770380078 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     333,
  /**/

-- 
BEDEVERE: Wait.  Wait ... tell me, what also floats on water?
ALL:      Bread?  No, no, no.  Apples .... gravy ... very small rocks ...
ARTHUR:   A duck.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0334
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0334
Problem:    Can't access b:changedtick from a dict reference.
Solution:   Make changedtick a member of the b: dict. (inspired by neovim
            #6112)
Files:      src/structs.h, src/buffer.c, src/edit.c, src/eval.c,
            src/evalfunc.c, src/ex_docmd.c, src/main.c, src/globals.h,
            src/fileio.c, src/memline.c, src/misc1.c, src/syntax.c,
            src/proto/eval.pro, src/testdir/test_changedtick.vim,
            src/Makefile, src/testdir/test_alot.vim, src/testdir/test91.in,
            src/testdir/test91.ok, src/testdir/test_functions.vim


*** ../vim-8.0.0333/src/structs.h	2017-02-06 21:56:04.996335436 +0100
--- src/structs.h	2017-02-17 15:12:24.304192531 +0100
***************
*** 1916,1922 ****
  
      int		b_changed;	/* 'modified': Set to TRUE if something in the
  				   file has been changed and not written out. */
!     int		b_changedtick;	/* incremented for each change, also for undo */
  
      int		b_saving;	/* Set to TRUE if we are in the middle of
  				   saving the buffer. */
--- 1916,1924 ----
  
      int		b_changed;	/* 'modified': Set to TRUE if something in the
  				   file has been changed and not written out. */
!     varnumber_T	*b_changedtick;	/* points into b:changedtick or b_ct_val;
! 				   incremented for each change, also for undo */
!     varnumber_T b_ct_val;	/* fallback for b:changedtick */
  
      int		b_saving;	/* Set to TRUE if we are in the middle of
  				   saving the buffer. */
*** ../vim-8.0.0333/src/buffer.c	2017-01-24 17:48:32.466675400 +0100
--- src/buffer.c	2017-02-17 16:29:27.826094150 +0100
***************
*** 832,837 ****
--- 832,838 ----
      free_buffer_stuff(buf, TRUE);
  #ifdef FEAT_EVAL
      unref_var_dict(buf->b_vars);
+     buf->b_changedtick = &buf->b_ct_val;
  #endif
  #ifdef FEAT_LUA
      lua_buffer_free(buf);
***************
*** 873,878 ****
--- 874,902 ----
  }
  
  /*
+  * Initializes buf->b_changedtick.
+  */
+     static void
+ init_changedtick(buf_T *buf)
+ {
+ #ifdef FEAT_EVAL
+     dictitem_T *di = dictitem_alloc((char_u *)"changedtick");
+ 
+     if (di != NULL)
+     {
+ 	di->di_flags |= DI_FLAGS_LOCK | DI_FLAGS_FIX | DI_FLAGS_RO;
+ 	di->di_tv.v_type = VAR_NUMBER;
+ 	di->di_tv.v_lock = VAR_FIXED;
+ 	di->di_tv.vval.v_number = 0;
+ 	dict_add(buf->b_vars, di);
+ 	buf->b_changedtick = &di->di_tv.vval.v_number;
+     }
+     else
+ #endif
+ 	buf->b_changedtick = &buf->b_ct_val;
+ }
+ 
+ /*
   * Free stuff in the buffer for ":bdel" and when wiping out the buffer.
   */
      static void
***************
*** 889,896 ****
  #endif
      }
  #ifdef FEAT_EVAL
!     vars_clear(&buf->b_vars->dv_hashtab); /* free all internal variables */
!     hash_init(&buf->b_vars->dv_hashtab);
  #endif
  #ifdef FEAT_USR_CMDS
      uc_clear(&buf->b_ucmds);		/* clear local user commands */
--- 913,926 ----
  #endif
      }
  #ifdef FEAT_EVAL
!     {
! 	varnumber_T tick = *buf->b_changedtick;
! 
! 	vars_clear(&buf->b_vars->dv_hashtab); /* free all buffer variables */
! 	hash_init(&buf->b_vars->dv_hashtab);
! 	init_changedtick(buf);
! 	*buf->b_changedtick = tick;
!     }
  #endif
  #ifdef FEAT_USR_CMDS
      uc_clear(&buf->b_ucmds);		/* clear local user commands */
***************
*** 1979,1984 ****
--- 2009,2015 ----
  	}
  	init_var_dict(buf->b_vars, &buf->b_bufvar, VAR_SCOPE);
  #endif
+ 	init_changedtick(buf);
      }
  
      if (ffname != NULL)
*** ../vim-8.0.0333/src/edit.c	2017-02-09 17:36:59.293629503 +0100
--- src/edit.c	2017-02-17 15:19:35.880993583 +0100
***************
*** 1668,1674 ****
  #ifdef FEAT_AUTOCMD
      /* Trigger TextChangedI if b_changedtick differs. */
      if (ready && has_textchangedI()
! 	    && last_changedtick != curbuf->b_changedtick
  # ifdef FEAT_INS_EXPAND
  	    && !pum_visible()
  # endif
--- 1668,1674 ----
  #ifdef FEAT_AUTOCMD
      /* Trigger TextChangedI if b_changedtick differs. */
      if (ready && has_textchangedI()
! 	    && last_changedtick != *curbuf->b_changedtick
  # ifdef FEAT_INS_EXPAND
  	    && !pum_visible()
  # endif
***************
*** 1677,1683 ****
  	if (last_changedtick_buf == curbuf)
  	    apply_autocmds(EVENT_TEXTCHANGEDI, NULL, NULL, FALSE, curbuf);
  	last_changedtick_buf = curbuf;
! 	last_changedtick = curbuf->b_changedtick;
      }
  #endif
  
--- 1677,1683 ----
  	if (last_changedtick_buf == curbuf)
  	    apply_autocmds(EVENT_TEXTCHANGEDI, NULL, NULL, FALSE, curbuf);
  	last_changedtick_buf = curbuf;
! 	last_changedtick = *curbuf->b_changedtick;
      }
  #endif
  
*** ../vim-8.0.0333/src/eval.c	2017-01-28 18:08:08.155009961 +0100
--- src/eval.c	2017-02-17 15:56:13.384754244 +0100
***************
*** 1451,1464 ****
      static void
  list_buf_vars(int *first)
  {
-     char_u	numbuf[NUMBUFLEN];
- 
      list_hashtable_vars(&curbuf->b_vars->dv_hashtab, (char_u *)"b:",
  								 TRUE, first);
- 
-     sprintf((char *)numbuf, "%ld", (long)curbuf->b_changedtick);
-     list_one_var_a((char_u *)"b:", (char_u *)"changedtick", VAR_NUMBER,
- 							       numbuf, first);
  }
  
  /*
--- 1451,1458 ----
***************
*** 1806,1825 ****
  }
  
  /*
-  * If "arg" is equal to "b:changedtick" give an error and return TRUE.
-  */
-     int
- check_changedtick(char_u *arg)
- {
-     if (STRNCMP(arg, "b:changedtick", 13) == 0 && !eval_isnamec(arg[13]))
-     {
- 	EMSG2(_(e_readonlyvar), arg);
- 	return TRUE;
-     }
-     return FALSE;
- }
- 
- /*
   * Get an lval: variable, Dict item or List item that can be assigned a value
   * to: "name", "na{me}", "name[expr]", "name[expr:expr]", "name[expr][expr]",
   * "name.key", "name.key[expr]" etc.
--- 1800,1805 ----
***************
*** 2208,2239 ****
  
      if (lp->ll_tv == NULL)
      {
! 	if (!check_changedtick(lp->ll_name))
! 	{
! 	    cc = *endp;
! 	    *endp = NUL;
! 	    if (op != NULL && *op != '=')
! 	    {
! 		typval_T tv;
! 
! 		/* handle +=, -= and .= */
! 		di = NULL;
! 		if (get_var_tv(lp->ll_name, (int)STRLEN(lp->ll_name),
! 						 &tv, &di, TRUE, FALSE) == OK)
! 		{
! 		    if ((di == NULL
! 			   || (!var_check_ro(di->di_flags, lp->ll_name, FALSE)
! 			      && !tv_check_lock(di->di_tv.v_lock, lp->ll_name,
! 								      FALSE)))
! 			    && tv_op(&tv, rettv, op) == OK)
! 			set_var(lp->ll_name, &tv, FALSE);
! 		    clear_tv(&tv);
! 		}
  	    }
- 	    else
- 		set_var(lp->ll_name, rettv, copy);
- 	    *endp = cc;
  	}
      }
      else if (tv_check_lock(lp->ll_newkey == NULL
  		? lp->ll_tv->v_lock
--- 2188,2216 ----
  
      if (lp->ll_tv == NULL)
      {
! 	cc = *endp;
! 	*endp = NUL;
! 	if (op != NULL && *op != '=')
! 	{
! 	    typval_T tv;
! 
! 	    /* handle +=, -= and .= */
! 	    di = NULL;
! 	    if (get_var_tv(lp->ll_name, (int)STRLEN(lp->ll_name),
! 					     &tv, &di, TRUE, FALSE) == OK)
! 	    {
! 		if ((di == NULL
! 		       || (!var_check_ro(di->di_flags, lp->ll_name, FALSE)
! 			  && !tv_check_lock(di->di_tv.v_lock, lp->ll_name,
! 								  FALSE)))
! 			&& tv_op(&tv, rettv, op) == OK)
! 		    set_var(lp->ll_name, &tv, FALSE);
! 		clear_tv(&tv);
  	    }
  	}
+ 	else
+ 	    set_var(lp->ll_name, rettv, copy);
+ 	*endp = cc;
      }
      else if (tv_check_lock(lp->ll_newkey == NULL
  		? lp->ll_tv->v_lock
***************
*** 2776,2784 ****
  	*name_end = NUL;
  
  	/* Normal name or expanded name. */
! 	if (check_changedtick(lp->ll_name))
! 	    ret = FAIL;
! 	else if (do_unlet(lp->ll_name, forceit) == FAIL)
  	    ret = FAIL;
  	*name_end = cc;
      }
--- 2753,2759 ----
  	*name_end = NUL;
  
  	/* Normal name or expanded name. */
! 	if (do_unlet(lp->ll_name, forceit) == FAIL)
  	    ret = FAIL;
  	*name_end = cc;
      }
***************
*** 2904,2924 ****
  	*name_end = NUL;
  
  	/* Normal name or expanded name. */
! 	if (check_changedtick(lp->ll_name))
  	    ret = FAIL;
  	else
  	{
! 	    di = find_var(lp->ll_name, NULL, TRUE);
! 	    if (di == NULL)
! 		ret = FAIL;
  	    else
! 	    {
! 		if (lock)
! 		    di->di_flags |= DI_FLAGS_LOCK;
! 		else
! 		    di->di_flags &= ~DI_FLAGS_LOCK;
! 		item_lock(&di->di_tv, deep, lock);
! 	    }
  	}
  	*name_end = cc;
      }
--- 2879,2894 ----
  	*name_end = NUL;
  
  	/* Normal name or expanded name. */
! 	di = find_var(lp->ll_name, NULL, TRUE);
! 	if (di == NULL)
  	    ret = FAIL;
  	else
  	{
! 	    if (lock)
! 		di->di_flags |= DI_FLAGS_LOCK;
  	    else
! 		di->di_flags &= ~DI_FLAGS_LOCK;
! 	    item_lock(&di->di_tv, deep, lock);
  	}
  	*name_end = cc;
      }
***************
*** 3139,3149 ****
  	    ++hi;
  	return cat_prefix_varname('b', hi->hi_key);
      }
-     if (bdone == ht->ht_used)
-     {
- 	++bdone;
- 	return (char_u *)"b:changedtick";
-     }
  
      /* w: variables */
      ht = &curwin->w_vars->dv_hashtab;
--- 3109,3114 ----
***************
*** 6815,6821 ****
  {
      int		ret = OK;
      typval_T	*tv = NULL;
-     typval_T	atv;
      dictitem_T	*v;
      int		cc;
  
--- 6780,6785 ----
***************
*** 6824,6850 ****
      name[len] = NUL;
  
      /*
-      * Check for "b:changedtick".
-      */
-     if (STRCMP(name, "b:changedtick") == 0)
-     {
- 	atv.v_type = VAR_NUMBER;
- 	atv.vval.v_number = curbuf->b_changedtick;
- 	tv = &atv;
-     }
- 
-     /*
       * Check for user-defined variables.
       */
!     else
      {
! 	v = find_var(name, NULL, no_autoload);
! 	if (v != NULL)
! 	{
! 	    tv = &v->di_tv;
! 	    if (dip != NULL)
! 		*dip = v;
! 	}
      }
  
      if (tv == NULL)
--- 6788,6801 ----
      name[len] = NUL;
  
      /*
       * Check for user-defined variables.
       */
!     v = find_var(name, NULL, no_autoload);
!     if (v != NULL)
      {
! 	tv = &v->di_tv;
! 	if (dip != NULL)
! 	    *dip = v;
      }
  
      if (tv == NULL)
*** ../vim-8.0.0333/src/evalfunc.c	2017-02-01 17:24:29.681328124 +0100
--- src/evalfunc.c	2017-02-17 15:21:58.943933276 +0100
***************
*** 2539,2545 ****
  #ifdef FEAT_DIFF
      linenr_T		lnum = get_tv_lnum(argvars);
      static linenr_T	prev_lnum = 0;
!     static int		changedtick = 0;
      static int		fnum = 0;
      static int		change_start = 0;
      static int		change_end = 0;
--- 2539,2545 ----
  #ifdef FEAT_DIFF
      linenr_T		lnum = get_tv_lnum(argvars);
      static linenr_T	prev_lnum = 0;
!     static varnumber_T	changedtick = 0;
      static int		fnum = 0;
      static int		change_start = 0;
      static int		change_end = 0;
***************
*** 2550,2556 ****
      if (lnum < 0)	/* ignore type error in {lnum} arg */
  	lnum = 0;
      if (lnum != prev_lnum
! 	    || changedtick != curbuf->b_changedtick
  	    || fnum != curbuf->b_fnum)
      {
  	/* New line, buffer, change: need to get the values. */
--- 2550,2556 ----
      if (lnum < 0)	/* ignore type error in {lnum} arg */
  	lnum = 0;
      if (lnum != prev_lnum
! 	    || changedtick != *curbuf->b_changedtick
  	    || fnum != curbuf->b_fnum)
      {
  	/* New line, buffer, change: need to get the values. */
***************
*** 2572,2578 ****
  	else
  	    hlID = (hlf_T)0;
  	prev_lnum = lnum;
! 	changedtick = curbuf->b_changedtick;
  	fnum = curbuf->b_fnum;
      }
  
--- 2572,2578 ----
  	else
  	    hlID = (hlf_T)0;
  	prev_lnum = lnum;
! 	changedtick = *curbuf->b_changedtick;
  	fnum = curbuf->b_fnum;
      }
  
***************
*** 3957,3963 ****
      dict_add_nr_str(dict, "loaded", buf->b_ml.ml_mfp != NULL, NULL);
      dict_add_nr_str(dict, "listed", buf->b_p_bl, NULL);
      dict_add_nr_str(dict, "changed", bufIsChanged(buf), NULL);
!     dict_add_nr_str(dict, "changedtick", buf->b_changedtick, NULL);
      dict_add_nr_str(dict, "hidden",
  		    buf->b_ml.ml_mfp != NULL && buf->b_nwindows == 0,
  		    NULL);
--- 3957,3963 ----
      dict_add_nr_str(dict, "loaded", buf->b_ml.ml_mfp != NULL, NULL);
      dict_add_nr_str(dict, "listed", buf->b_p_bl, NULL);
      dict_add_nr_str(dict, "changed", bufIsChanged(buf), NULL);
!     dict_add_nr_str(dict, "changedtick", *buf->b_changedtick, NULL);
      dict_add_nr_str(dict, "hidden",
  		    buf->b_ml.ml_mfp != NULL && buf->b_nwindows == 0,
  		    NULL);
***************
*** 4190,4201 ****
  		/* buffer-local-option */
  		done = TRUE;
  	}
- 	else if (STRCMP(varname, "changedtick") == 0)
- 	{
- 	    rettv->v_type = VAR_NUMBER;
- 	    rettv->vval.v_number = curbuf->b_changedtick;
- 	    done = TRUE;
- 	}
  	else
  	{
  	    /* Look up the variable. */
--- 4190,4195 ----
***************
*** 6576,6596 ****
  	{
  	    if (lv.ll_tv == NULL)
  	    {
! 		if (check_changedtick(lv.ll_name))
! 		    rettv->vval.v_number = 1;	    /* always locked */
! 		else
  		{
! 		    di = find_var(lv.ll_name, NULL, TRUE);
! 		    if (di != NULL)
! 		    {
! 			/* Consider a variable locked when:
! 			 * 1. the variable itself is locked
! 			 * 2. the value of the variable is locked.
! 			 * 3. the List or Dict value is locked.
! 			 */
! 			rettv->vval.v_number = ((di->di_flags & DI_FLAGS_LOCK)
! 						  || tv_islocked(&di->di_tv));
! 		    }
  		}
  	    }
  	    else if (lv.ll_range)
--- 6570,6585 ----
  	{
  	    if (lv.ll_tv == NULL)
  	    {
! 		di = find_var(lv.ll_name, NULL, TRUE);
! 		if (di != NULL)
  		{
! 		    /* Consider a variable locked when:
! 		     * 1. the variable itself is locked
! 		     * 2. the value of the variable is locked.
! 		     * 3. the List or Dict value is locked.
! 		     */
! 		    rettv->vval.v_number = ((di->di_flags & DI_FLAGS_LOCK)
! 						   || tv_islocked(&di->di_tv));
  		}
  	    }
  	    else if (lv.ll_range)
***************
*** 11551,11558 ****
  	return;
      if (no < 0 || no >= NSUBEXP)
      {
!         EMSGN(_("E935: invalid submatch number: %d"), no);
!         return;
      }
      if (argvars[1].v_type != VAR_UNKNOWN)
  	retList = (int)get_tv_number_chk(&argvars[1], &error);
--- 11540,11547 ----
  	return;
      if (no < 0 || no >= NSUBEXP)
      {
! 	EMSGN(_("E935: invalid submatch number: %d"), no);
! 	return;
      }
      if (argvars[1].v_type != VAR_UNKNOWN)
  	retList = (int)get_tv_number_chk(&argvars[1], &error);
*** ../vim-8.0.0333/src/ex_docmd.c	2017-02-12 18:34:00.898048918 +0100
--- src/ex_docmd.c	2017-02-17 15:23:04.691446007 +0100
***************
*** 626,632 ****
      int		save_msg_scroll;
      int		prev_msg_row;
      linenr_T	prev_line;
!     int		changedtick;
  
      if (improved)
  	exmode_active = EXMODE_VIM;
--- 626,632 ----
      int		save_msg_scroll;
      int		prev_msg_row;
      linenr_T	prev_line;
!     varnumber_T	changedtick;
  
      if (improved)
  	exmode_active = EXMODE_VIM;
***************
*** 660,666 ****
  	need_wait_return = FALSE;
  	ex_pressedreturn = FALSE;
  	ex_no_reprint = FALSE;
! 	changedtick = curbuf->b_changedtick;
  	prev_msg_row = msg_row;
  	prev_line = curwin->w_cursor.lnum;
  	if (improved)
--- 660,666 ----
  	need_wait_return = FALSE;
  	ex_pressedreturn = FALSE;
  	ex_no_reprint = FALSE;
! 	changedtick = *curbuf->b_changedtick;
  	prev_msg_row = msg_row;
  	prev_line = curwin->w_cursor.lnum;
  	if (improved)
***************
*** 673,679 ****
  	lines_left = Rows - 1;
  
  	if ((prev_line != curwin->w_cursor.lnum
! 		    || changedtick != curbuf->b_changedtick) && !ex_no_reprint)
  	{
  	    if (curbuf->b_ml.ml_flags & ML_EMPTY)
  		EMSG(_(e_emptybuf));
--- 673,679 ----
  	lines_left = Rows - 1;
  
  	if ((prev_line != curwin->w_cursor.lnum
! 		   || changedtick != *curbuf->b_changedtick) && !ex_no_reprint)
  	{
  	    if (curbuf->b_ml.ml_flags & ML_EMPTY)
  		EMSG(_(e_emptybuf));
*** ../vim-8.0.0333/src/main.c	2017-02-03 22:01:43.934349479 +0100
--- src/main.c	2017-02-17 15:25:02.010576558 +0100
***************
*** 1164,1176 ****
  #ifdef FEAT_AUTOCMD
  	    /* Trigger TextChanged if b_changedtick differs. */
  	    if (!finish_op && has_textchanged()
! 		    && last_changedtick != curbuf->b_changedtick)
  	    {
  		if (last_changedtick_buf == curbuf)
  		    apply_autocmds(EVENT_TEXTCHANGED, NULL, NULL,
  							       FALSE, curbuf);
  		last_changedtick_buf = curbuf;
! 		last_changedtick = curbuf->b_changedtick;
  	    }
  #endif
  
--- 1164,1176 ----
  #ifdef FEAT_AUTOCMD
  	    /* Trigger TextChanged if b_changedtick differs. */
  	    if (!finish_op && has_textchanged()
! 		    && last_changedtick != *curbuf->b_changedtick)
  	    {
  		if (last_changedtick_buf == curbuf)
  		    apply_autocmds(EVENT_TEXTCHANGED, NULL, NULL,
  							       FALSE, curbuf);
  		last_changedtick_buf = curbuf;
! 		last_changedtick = *curbuf->b_changedtick;
  	    }
  #endif
  
***************
*** 1388,1398 ****
  		    /* Autocmd must have close the buffer already, skip. */
  		    continue;
  		buf = wp->w_buffer;
! 		if (buf->b_changedtick != -1)
  		{
  		    apply_autocmds(EVENT_BUFWINLEAVE, buf->b_fname,
  						    buf->b_fname, FALSE, buf);
! 		    buf->b_changedtick = -1;  /* note that we did it already */
  		    /* start all over, autocommands may mess up the lists */
  		    next_tp = first_tabpage;
  		    break;
--- 1388,1398 ----
  		    /* Autocmd must have close the buffer already, skip. */
  		    continue;
  		buf = wp->w_buffer;
! 		if (buf->b_ct_val != -1)
  		{
  		    apply_autocmds(EVENT_BUFWINLEAVE, buf->b_fname,
  						    buf->b_fname, FALSE, buf);
! 		    buf->b_ct_val = -1;  /* note that we did it already */
  		    /* start all over, autocommands may mess up the lists */
  		    next_tp = first_tabpage;
  		    break;
*** ../vim-8.0.0333/src/globals.h	2017-02-12 18:45:19.281209607 +0100
--- src/globals.h	2017-02-17 15:23:50.323107829 +0100
***************
*** 1088,1094 ****
  			= INIT_POS_T(0, 0, 0)
  # endif
  			;
! EXTERN int	last_changedtick INIT(= 0);   /* for TextChanged event */
  EXTERN buf_T	*last_changedtick_buf INIT(= NULL);
  #endif
  
--- 1088,1094 ----
  			= INIT_POS_T(0, 0, 0)
  # endif
  			;
! EXTERN varnumber_T last_changedtick INIT(= 0);   /* for TextChanged event */
  EXTERN buf_T	*last_changedtick_buf INIT(= NULL);
  #endif
  
*** ../vim-8.0.0333/src/fileio.c	2017-01-24 15:46:43.875356367 +0100
--- src/fileio.c	2017-02-17 15:30:25.812177039 +0100
***************
*** 4926,4934 ****
  #ifdef FEAT_AUTOCMD
  	/* buf->b_changedtick is always incremented in unchanged() but that
  	 * should not trigger a TextChanged event. */
! 	if (last_changedtick + 1 == buf->b_changedtick
  					       && last_changedtick_buf == buf)
! 	    last_changedtick = buf->b_changedtick;
  #endif
  	u_unchanged(buf);
  	u_update_save_nr(buf);
--- 4926,4934 ----
  #ifdef FEAT_AUTOCMD
  	/* buf->b_changedtick is always incremented in unchanged() but that
  	 * should not trigger a TextChanged event. */
! 	if (last_changedtick + 1 == *buf->b_changedtick
  					       && last_changedtick_buf == buf)
! 	    last_changedtick = *buf->b_changedtick;
  #endif
  	u_unchanged(buf);
  	u_update_save_nr(buf);
*** ../vim-8.0.0333/src/memline.c	2017-01-13 21:59:59.327172086 +0100
--- src/memline.c	2017-02-17 15:25:21.274433797 +0100
***************
*** 1148,1158 ****
      len = (int)STRLEN(fname);
      if (len >= 4 &&
  #if defined(VMS)
! 	    STRNICMP(fname + len - 4, "_s" , 2)
  #else
! 	    STRNICMP(fname + len - 4, ".s" , 2)
  #endif
! 		== 0
  		&& vim_strchr((char_u *)"UVWuvw", fname[len - 2]) != NULL
  		&& ASCII_ISALPHA(fname[len - 1]))
      {
--- 1148,1158 ----
      len = (int)STRLEN(fname);
      if (len >= 4 &&
  #if defined(VMS)
! 	    STRNICMP(fname + len - 4, "_s", 2)
  #else
! 	    STRNICMP(fname + len - 4, ".s", 2)
  #endif
! 						== 0
  		&& vim_strchr((char_u *)"UVWuvw", fname[len - 2]) != NULL
  		&& ASCII_ISALPHA(fname[len - 1]))
      {
***************
*** 1649,1655 ****
  	if (!(curbuf->b_ml.ml_line_count == 2 && *ml_get(1) == NUL))
  	{
  	    changed_int();
! 	    ++curbuf->b_changedtick;
  	}
      }
      else
--- 1649,1655 ----
  	if (!(curbuf->b_ml.ml_line_count == 2 && *ml_get(1) == NUL))
  	{
  	    changed_int();
! 	    ++*curbuf->b_changedtick;
  	}
      }
      else
***************
*** 1663,1669 ****
  	    if (i != 0)
  	    {
  		changed_int();
! 		++curbuf->b_changedtick;
  		break;
  	    }
  	}
--- 1663,1669 ----
  	    if (i != 0)
  	    {
  		changed_int();
! 		++*curbuf->b_changedtick;
  		break;
  	    }
  	}
*** ../vim-8.0.0333/src/misc1.c	2017-02-01 22:31:45.112052371 +0100
--- src/misc1.c	2017-02-17 15:26:35.901880755 +0100
***************
*** 492,498 ****
      static int	    prev_indent = 0;  /* cached indent value */
      static long	    prev_ts     = 0L; /* cached tabstop value */
      static char_u   *prev_line = NULL; /* cached pointer to line */
!     static int	    prev_tick = 0;   /* changedtick of cached value */
      int		    bri = 0;
      /* window width minus window margin space, i.e. what rests for text */
      const int	    eff_wwidth = W_WIDTH(wp)
--- 492,498 ----
      static int	    prev_indent = 0;  /* cached indent value */
      static long	    prev_ts     = 0L; /* cached tabstop value */
      static char_u   *prev_line = NULL; /* cached pointer to line */
!     static varnumber_T prev_tick = 0;   /* changedtick of cached value */
      int		    bri = 0;
      /* window width minus window margin space, i.e. what rests for text */
      const int	    eff_wwidth = W_WIDTH(wp)
***************
*** 502,512 ****
  
      /* used cached indent, unless pointer or 'tabstop' changed */
      if (prev_line != line || prev_ts != wp->w_buffer->b_p_ts
! 				  || prev_tick != wp->w_buffer->b_changedtick)
      {
  	prev_line = line;
  	prev_ts = wp->w_buffer->b_p_ts;
! 	prev_tick = wp->w_buffer->b_changedtick;
  	prev_indent = get_indent_str(line,
  				     (int)wp->w_buffer->b_p_ts, wp->w_p_list);
      }
--- 502,512 ----
  
      /* used cached indent, unless pointer or 'tabstop' changed */
      if (prev_line != line || prev_ts != wp->w_buffer->b_p_ts
! 				  || prev_tick != *wp->w_buffer->b_changedtick)
      {
  	prev_line = line;
  	prev_ts = wp->w_buffer->b_p_ts;
! 	prev_tick = *wp->w_buffer->b_changedtick;
  	prev_indent = get_indent_str(line,
  				     (int)wp->w_buffer->b_p_ts, wp->w_p_list);
      }
***************
*** 2768,2774 ****
  	}
  	changed_int();
      }
!     ++curbuf->b_changedtick;
  }
  
  /*
--- 2768,2774 ----
  	}
  	changed_int();
      }
!     ++*curbuf->b_changedtick;
  }
  
  /*
***************
*** 3195,3201 ****
  	need_maketitle = TRUE;	    /* set window title later */
  #endif
      }
!     ++buf->b_changedtick;
  #ifdef FEAT_NETBEANS_INTG
      netbeans_unmodified(buf);
  #endif
--- 3195,3201 ----
  	need_maketitle = TRUE;	    /* set window title later */
  #endif
      }
!     ++*buf->b_changedtick;
  #ifdef FEAT_NETBEANS_INTG
      netbeans_unmodified(buf);
  #endif
*** ../vim-8.0.0333/src/syntax.c	2017-01-22 19:25:28.228530629 +0100
--- src/syntax.c	2017-02-17 15:27:03.709674682 +0100
***************
*** 503,509 ****
      linenr_T	parsed_lnum;
      linenr_T	first_stored;
      int		dist;
!     static int	changedtick = 0;	/* remember the last change ID */
  
  #ifdef FEAT_CONCEAL
      current_sub_char = NUL;
--- 503,509 ----
      linenr_T	parsed_lnum;
      linenr_T	first_stored;
      int		dist;
!     static varnumber_T changedtick = 0;	/* remember the last change ID */
  
  #ifdef FEAT_CONCEAL
      current_sub_char = NUL;
***************
*** 516,528 ****
       */
      if (syn_block != wp->w_s
  	    || syn_buf != wp->w_buffer
! 	    || changedtick != syn_buf->b_changedtick)
      {
  	invalidate_current_state();
  	syn_buf = wp->w_buffer;
  	syn_block = wp->w_s;
      }
!     changedtick = syn_buf->b_changedtick;
      syn_win = wp;
  
      /*
--- 516,528 ----
       */
      if (syn_block != wp->w_s
  	    || syn_buf != wp->w_buffer
! 	    || changedtick != *syn_buf->b_changedtick)
      {
  	invalidate_current_state();
  	syn_buf = wp->w_buffer;
  	syn_block = wp->w_s;
      }
!     changedtick = *syn_buf->b_changedtick;
      syn_win = wp;
  
      /*
*** ../vim-8.0.0333/src/proto/eval.pro	2016-09-12 13:04:00.000000000 +0200
--- src/proto/eval.pro	2017-02-17 15:28:47.908902521 +0100
***************
*** 25,31 ****
  int eval_foldexpr(char_u *arg, int *cp);
  void ex_let(exarg_T *eap);
  void list_hashtable_vars(hashtab_T *ht, char_u *prefix, int empty, int *first);
- int check_changedtick(char_u *arg);
  char_u *get_lval(char_u *name, typval_T *rettv, lval_T *lp, int unlet, int skip, int flags, int fne_flags);
  void clear_lval(lval_T *lp);
  void *eval_for_line(char_u *arg, int *errp, char_u **nextcmdp, int skip);
--- 25,30 ----
*** ../vim-8.0.0333/src/testdir/test_changedtick.vim	2017-02-17 16:28:14.582631189 +0100
--- src/testdir/test_changedtick.vim	2017-02-17 15:54:21.101578599 +0100
***************
*** 0 ****
--- 1,45 ----
+ " Tests for b:changedtick
+ 
+ func Test_changedtick_increments()
+   new
+   " New buffer has an empty line, tick starts at 2.
+   let expected = 2
+   call assert_equal(expected, b:changedtick)
+   call assert_equal(expected, b:['changedtick'])
+   call setline(1, 'hello')
+   let expected += 1
+   call assert_equal(expected, b:changedtick)
+   call assert_equal(expected, b:['changedtick'])
+   undo
+   " Somehow undo counts as two changes.
+   let expected += 2
+   call assert_equal(expected, b:changedtick)
+   call assert_equal(expected, b:['changedtick'])
+   bwipe!
+ endfunc
+ 
+ func Test_changedtick_dict_entry()
+   let d = b:
+   call assert_equal(b:changedtick, d['changedtick'])
+ endfunc
+ 
+ func Test_changedtick_bdel()
+   new
+   let bnr = bufnr('%')
+   let v = b:changedtick
+   bdel
+   " Delete counts as a change too.
+   call assert_equal(v + 1, getbufvar(bnr, 'changedtick'))
+ endfunc
+ 
+ func Test_changedtick_fixed()
+   call assert_fails('let b:changedtick = 4', 'E46')
+   call assert_fails('let b:["changedtick"] = 4', 'E46')
+ 
+   call assert_fails('unlet b:changedtick', 'E795')
+   call assert_fails('unlet b:["changedtick"]', 'E46')
+ 
+   let d = b:
+   call assert_fails('unlet d["changedtick"]', 'E46')
+ 
+ endfunc
*** ../vim-8.0.0333/src/Makefile	2017-02-17 12:04:35.843808317 +0100
--- src/Makefile	2017-02-17 15:33:20.794880834 +0100
***************
*** 2099,2104 ****
--- 2099,2105 ----
  	test_cdo \
  	test_channel \
  	test_charsearch \
+ 	test_changedtick \
  	test_cmdline \
  	test_command_count \
  	test_crypt \
*** ../vim-8.0.0333/src/testdir/test_alot.vim	2017-02-01 20:53:18.659092738 +0100
--- src/testdir/test_alot.vim	2017-02-17 15:33:37.034760809 +0100
***************
*** 3,12 ****
  
  source test_assign.vim
  source test_autocmd.vim
  source test_cursor_func.vim
  source test_delete.vim
- source test_execute_func.vim
  source test_ex_undo.vim
  source test_expand.vim
  source test_expr.vim
  source test_expand_dllpath.vim
--- 3,13 ----
  
  source test_assign.vim
  source test_autocmd.vim
+ source test_changedtick.vim
  source test_cursor_func.vim
  source test_delete.vim
  source test_ex_undo.vim
+ source test_execute_func.vim
  source test_expand.vim
  source test_expr.vim
  source test_expand_dllpath.vim
*** ../vim-8.0.0333/src/testdir/test91.in	2015-08-25 16:14:21.000000000 +0200
--- src/testdir/test91.in	2017-02-17 16:05:39.560595078 +0100
***************
*** 1,4 ****
! Tests for getbufvar(), getwinvar(), gettabvar() and gettabwinvar().
  vim: set ft=vim :
  
  STARTTEST
--- 1,4 ----
! Tests for getwinvar(), gettabvar() and gettabwinvar().
  vim: set ft=vim :
  
  STARTTEST
***************
*** 10,43 ****
  :let t:testvar='abcd'
  :$put =string(gettabvar(1,'testvar'))
  :$put =string(gettabvar(1,'testvar'))
- :" Test for getbufvar()
- :let b:var_num = '1234'
- :let def_num = '5678'
- :$put =string(getbufvar(1, 'var_num'))
- :$put =string(getbufvar(1, 'var_num', def_num))
- :$put =string(getbufvar(1, ''))
- :$put =string(getbufvar(1, '', def_num))
- :unlet b:var_num
- :$put =string(getbufvar(1, 'var_num', def_num))
- :$put =string(getbufvar(1, ''))
- :$put =string(getbufvar(1, '', def_num))
- :$put =string(getbufvar(9, ''))
- :$put =string(getbufvar(9, '', def_num))
- :unlet def_num
- :$put =string(getbufvar(1, '&autoindent'))
- :$put =string(getbufvar(1, '&autoindent', 1))
  :"
- :" Open new window with forced option values
- :set fileformats=unix,dos
- :new ++ff=dos ++bin ++enc=iso-8859-2
- :let otherff = getbufvar(bufnr('%'), '&fileformat')
- :let otherbin = getbufvar(bufnr('%'), '&bin')
- :let otherfenc = getbufvar(bufnr('%'), '&fenc')
- :close
- :$put =otherff
- :$put =string(otherbin)
- :$put =otherfenc
- :unlet otherff otherbin otherfenc
  :" test for getwinvar()
  :let w:var_str = "Dance"
  :let def_str = "Chance"
--- 10,16 ----
*** ../vim-8.0.0333/src/testdir/test91.ok	2015-08-25 16:14:21.000000000 +0200
--- src/testdir/test91.ok	2017-02-17 16:23:08.896877188 +0100
***************
*** 1,20 ****
  start:
  'abcd'
  'abcd'
- '1234'
- '1234'
- {'var_num': '1234'}
- {'var_num': '1234'}
- '5678'
- {}
- {}
- ''
- '5678'
- 0
- 0
- dos
- 1
- iso-8859-2
  'Dance'
  'Dance'
  {'var_str': 'Dance'}
--- 1,6 ----
*** ../vim-8.0.0333/src/testdir/test_functions.vim	2017-02-05 14:15:24.583095563 +0100
--- src/testdir/test_functions.vim	2017-02-17 16:22:47.197036900 +0100
***************
*** 424,426 ****
--- 424,468 ----
    bwipe!
    iunmap <F2>
  endfunc
+ 
+ func Test_getbufvar()
+   let bnr = bufnr('%')
+   let b:var_num = '1234'
+   let def_num = '5678'
+   call assert_equal('1234', getbufvar(bnr, 'var_num'))
+   call assert_equal('1234', getbufvar(bnr, 'var_num', def_num))
+ 
+   let bd = getbufvar(bnr, '')
+   call assert_equal('1234', bd['var_num'])
+   call assert_true(exists("bd['changedtick']"))
+   call assert_equal(2, len(bd))
+ 
+   let bd2 = getbufvar(bnr, '', def_num)
+   call assert_equal(bd, bd2)
+ 
+   unlet b:var_num
+   call assert_equal(def_num, getbufvar(bnr, 'var_num', def_num))
+   call assert_equal('', getbufvar(bnr, 'var_num'))
+ 
+   let bd = getbufvar(bnr, '')
+   call assert_equal(1, len(bd))
+   let bd = getbufvar(bnr, '',def_num)
+   call assert_equal(1, len(bd))
+ 
+   call assert_equal('', getbufvar(9, ''))
+   call assert_equal(def_num, getbufvar(9, '', def_num))
+   unlet def_num
+ 
+   call assert_equal(0, getbufvar(1, '&autoindent'))
+   call assert_equal(0, getbufvar(1, '&autoindent', 1))
+ 
+   " Open new window with forced option values
+   set fileformats=unix,dos
+   new ++ff=dos ++bin ++enc=iso-8859-2
+   call assert_equal('dos', getbufvar(bufnr('%'), '&fileformat'))
+   call assert_equal(1, getbufvar(bufnr('%'), '&bin'))
+   call assert_equal('iso-8859-2', getbufvar(bufnr('%'), '&fenc'))
+   close
+ 
+   set fileformats&
+ endfunc
*** ../vim-8.0.0333/src/version.c	2017-02-17 14:53:11.704743399 +0100
--- src/version.c	2017-02-17 15:02:39.148530713 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     334,
  /**/

-- 
Never under any circumstances take a sleeping pill
and a laxative on the same night.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0335
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0335 (after 8.0.0335)
Problem:    Functions test fails.
Solution:   Use the right buffer number.
Files:      src/testdir/test_functions.vim


*** ../vim-8.0.0334/src/testdir/test_functions.vim	2017-02-17 16:31:16.929294079 +0100
--- src/testdir/test_functions.vim	2017-02-17 16:42:24.584395599 +0100
***************
*** 453,460 ****
    call assert_equal(def_num, getbufvar(9, '', def_num))
    unlet def_num
  
!   call assert_equal(0, getbufvar(1, '&autoindent'))
!   call assert_equal(0, getbufvar(1, '&autoindent', 1))
  
    " Open new window with forced option values
    set fileformats=unix,dos
--- 453,460 ----
    call assert_equal(def_num, getbufvar(9, '', def_num))
    unlet def_num
  
!   call assert_equal(0, getbufvar(bnr, '&autoindent'))
!   call assert_equal(0, getbufvar(bnr, '&autoindent', 1))
  
    " Open new window with forced option values
    set fileformats=unix,dos
*** ../vim-8.0.0334/src/version.c	2017-02-17 16:31:16.929294079 +0100
--- src/version.c	2017-02-17 16:43:11.784049154 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     335,
  /**/

-- 
If you had to identify, in one word, the reason why the
human race has not achieved, and never will achieve, its
full potential, that word would be "meetings."

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0336
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0336
Problem:    Flags of :substitute not sufficiently tested.
Solution:   Test up to two letter flag combinations. (James McCoy, closes
            #1479)
Files:      src/testdir/test_substitute.vim


*** ../vim-8.0.0335/src/testdir/test_substitute.vim	2016-09-02 19:39:33.000000000 +0200
--- src/testdir/test_substitute.vim	2017-02-17 18:26:59.866155239 +0100
***************
*** 39,41 ****
--- 39,108 ----
    call assert_equal('xxxxx', getline(13))
    enew!
  endfunction
+ 
+ function! Test_substitute_variants()
+   " Validate that all the 2-/3-letter variants which embed the flags into the
+   " command name actually work.
+   enew!
+   let ln = 'Testing string'
+   let variants = [
+ 	\ { 'cmd': ':s/Test/test/c', 'exp': 'testing string', 'prompt': 'y' },
+ 	\ { 'cmd': ':s/foo/bar/ce', 'exp': ln },
+ 	\ { 'cmd': ':s/t/r/cg', 'exp': 'Tesring srring', 'prompt': 'a' },
+ 	\ { 'cmd': ':s/t/r/ci', 'exp': 'resting string', 'prompt': 'y' },
+ 	\ { 'cmd': ':s/t/r/cI', 'exp': 'Tesring string', 'prompt': 'y' },
+ 	\ { 'cmd': ':s/t/r/cn', 'exp': ln },
+ 	\ { 'cmd': ':s/t/r/cp', 'exp': 'Tesring string', 'prompt': 'y' },
+ 	\ { 'cmd': ':s/t/r/cl', 'exp': 'Tesring string', 'prompt': 'y' },
+ 	\ { 'cmd': ':s/t/r/gc', 'exp': 'Tesring srring', 'prompt': 'a' },
+ 	\ { 'cmd': ':s/foo/bar/ge', 'exp': ln },
+ 	\ { 'cmd': ':s/t/r/g', 'exp': 'Tesring srring' },
+ 	\ { 'cmd': ':s/t/r/gi', 'exp': 'resring srring' },
+ 	\ { 'cmd': ':s/t/r/gI', 'exp': 'Tesring srring' },
+ 	\ { 'cmd': ':s/t/r/gn', 'exp': ln },
+ 	\ { 'cmd': ':s/t/r/gp', 'exp': 'Tesring srring' },
+ 	\ { 'cmd': ':s/t/r/gl', 'exp': 'Tesring srring' },
+ 	\ { 'cmd': ':s//r/gr', 'exp': 'Testr strr' },
+ 	\ { 'cmd': ':s/t/r/ic', 'exp': 'resting string', 'prompt': 'y' },
+ 	\ { 'cmd': ':s/foo/bar/ie', 'exp': ln },
+ 	\ { 'cmd': ':s/t/r/i', 'exp': 'resting string' },
+ 	\ { 'cmd': ':s/t/r/iI', 'exp': 'Tesring string' },
+ 	\ { 'cmd': ':s/t/r/in', 'exp': ln },
+ 	\ { 'cmd': ':s/t/r/ip', 'exp': 'resting string' },
+ 	\ { 'cmd': ':s//r/ir', 'exp': 'Testr string' },
+ 	\ { 'cmd': ':s/t/r/Ic', 'exp': 'Tesring string', 'prompt': 'y' },
+ 	\ { 'cmd': ':s/foo/bar/Ie', 'exp': ln },
+ 	\ { 'cmd': ':s/t/r/Ig', 'exp': 'Tesring srring' },
+ 	\ { 'cmd': ':s/t/r/Ii', 'exp': 'resting string' },
+ 	\ { 'cmd': ':s/t/r/I', 'exp': 'Tesring string' },
+ 	\ { 'cmd': ':s/t/r/Ip', 'exp': 'Tesring string' },
+ 	\ { 'cmd': ':s/t/r/Il', 'exp': 'Tesring string' },
+ 	\ { 'cmd': ':s//r/Ir', 'exp': 'Testr string' },
+ 	\ { 'cmd': ':s//r/rc', 'exp': 'Testr string', 'prompt': 'y' },
+ 	\ { 'cmd': ':s//r/rg', 'exp': 'Testr strr' },
+ 	\ { 'cmd': ':s//r/ri', 'exp': 'Testr string' },
+ 	\ { 'cmd': ':s//r/rI', 'exp': 'Testr string' },
+ 	\ { 'cmd': ':s//r/rn', 'exp': 'Testing string' },
+ 	\ { 'cmd': ':s//r/rp', 'exp': 'Testr string' },
+ 	\ { 'cmd': ':s//r/rl', 'exp': 'Testr string' },
+ 	\ { 'cmd': ':s//r/r', 'exp': 'Testr string' },
+ 	\]
+ 
+   for var in variants
+     for run in [1, 2]
+       let cmd = var.cmd
+       if run == 2 && cmd =~ "/.*/.*/."
+ 	" Change  :s/from/to/{flags}  to  :s{flags}
+ 	let cmd = substitute(cmd, '/.*/', '', '')
+       endif
+       call setline(1, [ln])
+       let msg = printf('using "%s"', cmd)
+       let @/='ing'
+       let v:errmsg = ''
+       call feedkeys(cmd . "\<CR>" . get(var, 'prompt', ''), 'ntx')
+       " No error should exist (matters for testing e flag)
+       call assert_equal('', v:errmsg, msg)
+       call assert_equal(var.exp, getline('.'), msg)
+     endfor
+   endfor
+ endfunction
*** ../vim-8.0.0335/src/version.c	2017-02-17 16:43:44.987805278 +0100
--- src/version.c	2017-02-17 18:15:08.655378318 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     336,
  /**/

-- 
Back off man, I'm a scientist.
              -- Peter, Ghostbusters

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0337
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0337
Problem:    Invalid memory access in :recover command.
Solution:   Avoid access before directory name. (Dominique Pelle,
            closes #1488)
Files:      src/Makefile, src/memline.c, src/testdir/test_alot.vim,
            src/testdir/test_recover.vim


*** ../vim-8.0.0336/src/Makefile	2017-02-17 16:31:16.929294079 +0100
--- src/Makefile	2017-02-18 16:49:41.448460562 +0100
***************
*** 2177,2182 ****
--- 2177,2183 ----
  	test_pyx2 \
  	test_pyx3 \
  	test_quickfix \
+ 	test_recover \
  	test_regexp_latin \
  	test_regexp_utf8 \
  	test_reltime \
*** ../vim-8.0.0336/src/memline.c	2017-02-17 16:31:16.925294107 +0100
--- src/memline.c	2017-02-18 16:47:19.329495925 +0100
***************
*** 1863,1870 ****
  	    else
  	    {
  #if defined(UNIX) || defined(WIN3264)
! 		p = dir_name + STRLEN(dir_name);
! 		if (after_pathsep(dir_name, p) && p[-1] == p[-2])
  		{
  		    /* Ends with '//', Use Full path for swap name */
  		    tail = make_percent_swname(dir_name, fname_res);
--- 1863,1872 ----
  	    else
  	    {
  #if defined(UNIX) || defined(WIN3264)
! 		int	len = STRLEN(dir_name);
! 
! 		p = dir_name + len;
! 		if (after_pathsep(dir_name, p) && len > 1 && p[-1] == p[-2])
  		{
  		    /* Ends with '//', Use Full path for swap name */
  		    tail = make_percent_swname(dir_name, fname_res);
***************
*** 3922,3929 ****
  #endif
  
  #if defined(UNIX) || defined(WIN3264)  /* Need _very_ long file names */
!     s = dir_name + STRLEN(dir_name);
!     if (after_pathsep(dir_name, s) && s[-1] == s[-2])
      {			       /* Ends with '//', Use Full path */
  	r = NULL;
  	if ((s = make_percent_swname(dir_name, fname)) != NULL)
--- 3924,3933 ----
  #endif
  
  #if defined(UNIX) || defined(WIN3264)  /* Need _very_ long file names */
!     int		len = STRLEN(dir_name);
! 
!     s = dir_name + len;
!     if (after_pathsep(dir_name, s) && len > 1 && s[-1] == s[-2])
      {			       /* Ends with '//', Use Full path */
  	r = NULL;
  	if ((s = make_percent_swname(dir_name, fname)) != NULL)
*** ../vim-8.0.0336/src/testdir/test_alot.vim	2017-02-17 16:31:16.929294079 +0100
--- src/testdir/test_alot.vim	2017-02-18 16:47:19.329495925 +0100
***************
*** 34,39 ****
--- 34,40 ----
  source test_partial.vim
  source test_popup.vim
  source test_put.vim
+ source test_recover.vim
  source test_reltime.vim
  source test_searchpos.vim
  source test_set.vim
*** ../vim-8.0.0336/src/testdir/test_recover.vim	2017-02-18 16:58:26.140636060 +0100
--- src/testdir/test_recover.vim	2017-02-18 16:56:25.153518210 +0100
***************
*** 0 ****
--- 1,14 ----
+ " Test :recover
+ 
+ func Test_recover_root_dir()
+   " This used to access invalid memory.
+   split Xtest
+   set dir=/
+   call assert_fails('recover', 'E305:')
+   close!
+ 
+   call assert_fails('split Xtest', 'E303:')
+   set dir&
+ endfunc
+ 
+ " TODO: move recover tests from test78.in to here.
*** ../vim-8.0.0336/src/version.c	2017-02-17 18:28:20.397563687 +0100
--- src/version.c	2017-02-18 16:49:07.724706267 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     337,
  /**/

-- 
Managers are like cats in a litter box.  They instinctively shuffle things
around to conceal what they've done.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0338
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0338 (after 8.0.0337)
Problem:    :recover test fails on MS-Windows.
Solution:   Use non-existing directory on MS-Windows.
Files:      src/testdir/test_recover.vim


*** ../vim-8.0.0337/src/testdir/test_recover.vim	2017-02-18 16:58:44.264503901 +0100
--- src/testdir/test_recover.vim	2017-02-18 22:41:35.767757105 +0100
***************
*** 7,12 ****
--- 7,16 ----
    call assert_fails('recover', 'E305:')
    close!
  
+   if has('win32')
+     " can write in / directory on MS-Windows
+     set dir=/notexist/
+   endif
    call assert_fails('split Xtest', 'E303:')
    set dir&
  endfunc
*** ../vim-8.0.0337/src/version.c	2017-02-18 16:58:44.268503872 +0100
--- src/version.c	2017-02-18 22:42:38.703275231 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     338,
  /**/

-- 
An easy way to determine if you have enough teamwork to be doomed is simply to
measure how long it takes from the time you decide to go to lunch together
until the time you actually eat.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0339
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0339
Problem:    Illegal memory access with vi'
Solution:   For quoted text objects bail out if the Visual area spans more
            than one line.
Files:      src/search.c, src/testdir/test_visual.vim


*** ../vim-8.0.0338/src/search.c	2017-02-17 11:39:54.990547790 +0100
--- src/search.c	2017-02-18 23:02:48.410031369 +0100
***************
*** 4357,4362 ****
--- 4357,4366 ----
      /* Correct cursor when 'selection' is exclusive */
      if (VIsual_active)
      {
+ 	/* this only works within one line */
+ 	if (VIsual.lnum != curwin->w_cursor.lnum)
+ 	    return FALSE;
+ 
  	vis_bef_curs = lt(VIsual, curwin->w_cursor);
  	if (*p_sel == 'e' && vis_bef_curs)
  	    dec_cursor();
*** ../vim-8.0.0338/src/testdir/test_visual.vim	2017-02-17 11:39:54.994547761 +0100
--- src/testdir/test_visual.vim	2017-02-18 22:50:10.315826096 +0100
***************
*** 43,45 ****
--- 43,52 ----
    normal vapo
    bwipe!
  endfunc
+ 
+ func Test_Visual_inner_quote()
+   new
+   normal oxX
+   normal vki'
+   bwipe!
+ endfunc
*** ../vim-8.0.0338/src/version.c	2017-02-18 22:43:15.718991813 +0100
--- src/version.c	2017-02-18 23:04:15.217360964 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     339,
  /**/

-- 
Our job was to build a computer information system for the branch banks.  We
were the perfect people for the job: Dean had seen a computer once, and I had
heard Dean talk about it.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0340
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0340
Problem:    Not checking return valud of dict_add(). (Coverity)
Solution:   Handle a failure.
Files:      src/buffer.c


*** ../vim-8.0.0339/src/buffer.c	2017-02-17 16:31:16.913294195 +0100
--- src/buffer.c	2017-02-19 13:52:25.754064669 +0100
***************
*** 888,895 ****
  	di->di_tv.v_type = VAR_NUMBER;
  	di->di_tv.v_lock = VAR_FIXED;
  	di->di_tv.vval.v_number = 0;
! 	dict_add(buf->b_vars, di);
! 	buf->b_changedtick = &di->di_tv.vval.v_number;
      }
      else
  #endif
--- 888,900 ----
  	di->di_tv.v_type = VAR_NUMBER;
  	di->di_tv.v_lock = VAR_FIXED;
  	di->di_tv.vval.v_number = 0;
! 	if (dict_add(buf->b_vars, di) == OK)
! 	    buf->b_changedtick = &di->di_tv.vval.v_number;
! 	else
! 	{
! 	    vim_free(di);
! 	    buf->b_changedtick = &buf->b_ct_val;
! 	}
      }
      else
  #endif
*** ../vim-8.0.0339/src/version.c	2017-02-18 23:11:57.345793837 +0100
--- src/version.c	2017-02-19 13:54:17.857256347 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     340,
  /**/

-- 
The only way the average employee can speak to an executive is by taking a
second job as a golf caddie.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0341
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0341
Problem:    When using complete() and typing a character undo is saved after
            the character was inserted. (Shougo)
Solution:   Save for undo before inserting the character.
Files:      src/edit.c, src/testdir/test_popup.vim


*** ../vim-8.0.0340/src/edit.c	2017-02-17 16:31:16.917294167 +0100
--- src/edit.c	2017-02-19 14:42:14.996457874 +0100
***************
*** 3583,3589 ****
--- 3583,3593 ----
  {
  #ifdef FEAT_MBYTE
      int		cc;
+ #endif
  
+     if (stop_arrow() == FAIL)
+ 	return;
+ #ifdef FEAT_MBYTE
      if (has_mbyte && (cc = (*mb_char2len)(c)) > 1)
      {
  	char_u	buf[MB_MAXBYTES + 1];
*** ../vim-8.0.0340/src/testdir/test_popup.vim	2017-02-09 17:36:59.293629503 +0100
--- src/testdir/test_popup.vim	2017-02-19 14:41:36.000740244 +0100
***************
*** 531,534 ****
--- 531,554 ----
    bw!
  endfunc
  
+ func CompleteUndo() abort
+   call complete(1, g:months)
+   return ''
+ endfunc
+ 
+ func Test_completion_can_undo()
+   inoremap <Right> <c-r>=CompleteUndo()<cr>
+   set completeopt+=noinsert,noselect
+ 
+   new
+   call feedkeys("a\<Right>a\<Esc>", 'xt')
+   call assert_equal('a', getline(1))
+   undo
+   call assert_equal('', getline(1))
+ 
+   bwipe!
+   set completeopt&
+   iunmap <Right>
+ endfunc
+ 
  " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.0.0340/src/version.c	2017-02-19 13:54:57.996966935 +0100
--- src/version.c	2017-02-19 14:43:54.619736549 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     341,
  /**/

-- 
Engineers will go without food and hygiene for days to solve a problem.
(Other times just because they forgot.)
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0342
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0342
Problem:    Double free when compiled with EXITFREE and setting 'ttytype'.
Solution:   Avoid setting P_ALLOCED on 'ttytype'. (Dominique Pelle,
            closes #1461)
Files:      src/option.c, src/testdir/test_options.vim


*** ../vim-8.0.0341/src/option.c	2017-02-17 14:53:11.704743399 +0100
--- src/option.c	2017-02-19 20:25:48.489199941 +0100
***************
*** 3775,3781 ****
  	if (options[i].indir == PV_NONE)
  	{
  	    /* global option: free value and default value. */
! 	    if (options[i].flags & P_ALLOCED && options[i].var != NULL)
  		free_string_option(*(char_u **)options[i].var);
  	    if (options[i].flags & P_DEF_ALLOCED)
  		free_string_option(options[i].def_val[VI_DEFAULT]);
--- 3775,3781 ----
  	if (options[i].indir == PV_NONE)
  	{
  	    /* global option: free value and default value. */
! 	    if ((options[i].flags & P_ALLOCED) && options[i].var != NULL)
  		free_string_option(*(char_u **)options[i].var);
  	    if (options[i].flags & P_DEF_ALLOCED)
  		free_string_option(options[i].def_val[VI_DEFAULT]);
***************
*** 5929,5936 ****
--- 5929,5942 ----
  	else if (set_termname(T_NAME) == FAIL)
  	    errmsg = (char_u *)N_("E522: Not found in termcap");
  	else
+ 	{
  	    /* Screen colors may have changed. */
  	    redraw_later_clear();
+ 
+ 	    /* Both 'term' and 'ttytype' point to T_NAME, only set the
+ 	     * P_ALLOCED flag on 'term'. */
+ 	    opt_idx = findoption((char_u *)"term");
+ 	}
      }
  
      /* 'backupcopy' */
*** ../vim-8.0.0341/src/testdir/test_options.vim	2017-02-17 14:53:11.704743399 +0100
--- src/testdir/test_options.vim	2017-02-19 20:30:01.851273297 +0100
***************
*** 235,237 ****
--- 235,256 ----
    call assert_fails("set showbreak=\x01", 'E595:')
    call assert_fails('set t_foo=', 'E846:')
  endfunc
+ 
+ func Test_set_ttytype()
+   if !has('gui_running') && has('unix')
+     " Setting 'ttytype' used to cause a double-free when exiting vim and
+     " when vim is compiled with -DEXITFREE.
+     set ttytype=ansi
+     call assert_equal('ansi', &ttytype)
+     call assert_equal(&ttytype, &term)
+     set ttytype=xterm
+     call assert_equal('xterm', &ttytype)
+     call assert_equal(&ttytype, &term)
+     " FIXME: "set ttytype=" gives E522 instead of E529
+     " in travis on some builds. Why? Commented out this test for now.
+     " call assert_fails('set ttytype=', 'E529:')
+     call assert_fails('set ttytype=xxx', 'E522:')
+     set ttytype&
+     call assert_equal(&ttytype, &term)
+   endif
+ endfunc
*** ../vim-8.0.0341/src/version.c	2017-02-19 15:26:14.353270128 +0100
--- src/version.c	2017-02-19 20:14:05.002473758 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     342,
  /**/

-- 
Engineers are always delighted to share wisdom, even in areas in which they
have no experience whatsoever.  Their logic provides them with inherent
insight into any field of expertise.  This can be a problem when dealing with
the illogical people who believe that knowledge can only be derived through
experience.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0343
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0343
Problem:    b:changedtick can be unlocked, even though it has no effect.
            (Nikolai Pavlov)
Solution:   Add a check and error E940. (closes #1496)
Files:      src/eval.c, src/testdir/test_changedtick.vim, runtime/doc/eval.txt


*** ../vim-8.0.0342/src/eval.c	2017-02-17 16:31:16.917294167 +0100
--- src/eval.c	2017-02-20 22:31:32.023285476 +0100
***************
*** 2882,2887 ****
--- 2882,2893 ----
  	di = find_var(lp->ll_name, NULL, TRUE);
  	if (di == NULL)
  	    ret = FAIL;
+ 	else if ((di->di_flags & DI_FLAGS_FIX)
+ 			&& di->di_tv.v_type != VAR_DICT
+ 			&& di->di_tv.v_type != VAR_LIST)
+ 	    /* For historic reasons this error is not given for a list or dict.
+ 	     * E.g., the b: dict could be locked/unlocked. */
+ 	    EMSG2(_("E940: Cannot lock or unlock variable %s"), lp->ll_name);
  	else
  	{
  	    if (lock)
*** ../vim-8.0.0342/src/testdir/test_changedtick.vim	2017-02-17 16:31:16.929294079 +0100
--- src/testdir/test_changedtick.vim	2017-02-20 22:20:30.172487079 +0100
***************
*** 33,45 ****
  endfunc
  
  func Test_changedtick_fixed()
!   call assert_fails('let b:changedtick = 4', 'E46')
!   call assert_fails('let b:["changedtick"] = 4', 'E46')
  
!   call assert_fails('unlet b:changedtick', 'E795')
!   call assert_fails('unlet b:["changedtick"]', 'E46')
  
    let d = b:
!   call assert_fails('unlet d["changedtick"]', 'E46')
  
  endfunc
--- 33,51 ----
  endfunc
  
  func Test_changedtick_fixed()
!   call assert_fails('let b:changedtick = 4', 'E46:')
!   call assert_fails('let b:["changedtick"] = 4', 'E46:')
  
!   call assert_fails('lockvar b:changedtick', 'E940:')
!   call assert_fails('lockvar b:["changedtick"]', 'E46:')
!   call assert_fails('unlockvar b:changedtick', 'E940:')
!   call assert_fails('unlockvar b:["changedtick"]', 'E46:')
!   call assert_fails('unlet b:changedtick', 'E795:')
!   call assert_fails('unlet b:["changedtick"]', 'E46:')
  
    let d = b:
!   call assert_fails('lockvar d["changedtick"]', 'E46:')
!   call assert_fails('unlockvar d["changedtick"]', 'E46:')
!   call assert_fails('unlet d["changedtick"]', 'E46:')
  
  endfunc
*** ../vim-8.0.0342/runtime/doc/eval.txt	2017-02-01 17:24:29.677328148 +0100
--- runtime/doc/eval.txt	2017-02-20 22:15:56.938641719 +0100
***************
*** 9063,9071 ****
  				:lockvar v
  				:let v = 'asdf'		" fails!
  				:unlet v
! <							*E741*
  			If you try to change a locked variable you get an
! 			error message: "E741: Value is locked: {name}"
  
  			[depth] is relevant when locking a |List| or
  			|Dictionary|.  It specifies how deep the locking goes:
--- 9082,9093 ----
  				:lockvar v
  				:let v = 'asdf'		" fails!
  				:unlet v
! <							*E741* *E940*
  			If you try to change a locked variable you get an
! 			error message: "E741: Value is locked: {name}".
! 			If you try to lock or unlock a built-in variable you
! 			get an error message: "E940: Cannot lock or unlock
! 			variable {name}".
  
  			[depth] is relevant when locking a |List| or
  			|Dictionary|.  It specifies how deep the locking goes:
*** ../vim-8.0.0342/src/version.c	2017-02-19 21:07:01.006386644 +0100
--- src/version.c	2017-02-20 22:22:02.543759670 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     343,
  /**/

-- 
For society, it's probably a good thing that engineers value function over
appearance.  For example, you wouldn't want engineers to build nuclear power
plants that only _look_ like they would keep all the radiation inside.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0344
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0344
Problem:    Unlet command leaks memory. (Nikolai Pavlov)
Solution:   Free the memory on error. (closes #1497)
Files:      src/eval.c, src/testdir/test_unlet.vim


*** ../vim-8.0.0343/src/eval.c	2017-02-20 22:35:29.013423395 +0100
--- src/eval.c	2017-02-20 23:01:52.241052040 +0100
***************
*** 2079,2085 ****
--- 2079,2088 ----
  	    }
  	    /* existing variable, need to check if it can be changed */
  	    else if (var_check_ro(lp->ll_di->di_flags, name, FALSE))
+ 	    {
+ 		clear_tv(&var1);
  		return NULL;
+ 	    }
  
  	    if (len == -1)
  		clear_tv(&var1);
*** ../vim-8.0.0343/src/testdir/test_unlet.vim	2016-01-15 18:39:37.000000000 +0100
--- src/testdir/test_unlet.vim	2017-02-20 22:52:35.737385559 +0100
***************
*** 17,19 ****
--- 17,23 ----
    unlet! does_not_exist
    call assert_fails('unlet does_not_exist', 'E108:')
  endfunc
+ 
+ func Test_unlet_fails()
+   call assert_fails('unlet v:["count"]', 'E46:')
+ endfunc
*** ../vim-8.0.0343/src/version.c	2017-02-20 22:35:29.017423364 +0100
--- src/version.c	2017-02-20 23:02:56.028555995 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     344,
  /**/

-- 
Imagine a world without hypothetical situations.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0345
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0345
Problem:    islocked('d.changedtick') does not work.
Solution:   Make it work.
Files:      src/buffer.c, src/eval.c, src/evalfunc.c, src/vim.h,
            src/testdir/test_changedtick.vim


*** ../vim-8.0.0344/src/buffer.c	2017-02-19 13:54:57.996966935 +0100
--- src/buffer.c	2017-02-21 20:30:48.544718101 +0100
***************
*** 884,890 ****
  
      if (di != NULL)
      {
! 	di->di_flags |= DI_FLAGS_LOCK | DI_FLAGS_FIX | DI_FLAGS_RO;
  	di->di_tv.v_type = VAR_NUMBER;
  	di->di_tv.v_lock = VAR_FIXED;
  	di->di_tv.vval.v_number = 0;
--- 884,890 ----
  
      if (di != NULL)
      {
! 	di->di_flags |= DI_FLAGS_FIX | DI_FLAGS_RO;
  	di->di_tv.v_type = VAR_NUMBER;
  	di->di_tv.v_lock = VAR_FIXED;
  	di->di_tv.vval.v_number = 0;
*** ../vim-8.0.0344/src/eval.c	2017-02-20 23:07:00.478656212 +0100
--- src/eval.c	2017-02-21 20:41:26.052528271 +0100
***************
*** 1811,1816 ****
--- 1811,1817 ----
   *
   * flags:
   *  GLV_QUIET:       do not give error messages
+  *  GLV_READ_ONLY:   will not change the variable
   *  GLV_NO_AUTOLOAD: do not use script autoloading
   *
   * Returns a pointer to just after the name, including indexes.
***************
*** 2078,2084 ****
  		break;
  	    }
  	    /* existing variable, need to check if it can be changed */
! 	    else if (var_check_ro(lp->ll_di->di_flags, name, FALSE))
  	    {
  		clear_tv(&var1);
  		return NULL;
--- 2079,2086 ----
  		break;
  	    }
  	    /* existing variable, need to check if it can be changed */
! 	    else if ((flags & GLV_READ_ONLY) == 0
! 			     && var_check_ro(lp->ll_di->di_flags, name, FALSE))
  	    {
  		clear_tv(&var1);
  		return NULL;
*** ../vim-8.0.0344/src/evalfunc.c	2017-02-17 16:31:16.921294136 +0100
--- src/evalfunc.c	2017-02-21 20:41:40.428433096 +0100
***************
*** 6561,6567 ****
  
      rettv->vval.v_number = -1;
      end = get_lval(get_tv_string(&argvars[0]), NULL, &lv, FALSE, FALSE,
! 					GLV_NO_AUTOLOAD, FNE_CHECK_START);
      if (end != NULL && lv.ll_name != NULL)
      {
  	if (*end != NUL)
--- 6561,6567 ----
  
      rettv->vval.v_number = -1;
      end = get_lval(get_tv_string(&argvars[0]), NULL, &lv, FALSE, FALSE,
! 			     GLV_NO_AUTOLOAD | GLV_READ_ONLY, FNE_CHECK_START);
      if (end != NULL && lv.ll_name != NULL)
      {
  	if (*end != NUL)
*** ../vim-8.0.0344/src/vim.h	2017-02-01 13:14:11.026177020 +0100
--- src/vim.h	2017-02-21 20:40:35.408862969 +0100
***************
*** 2474,2483 ****
--- 2474,2485 ----
  #define TFN_QUIET	2	/* no error messages */
  #define TFN_NO_AUTOLOAD	4	/* do not use script autoloading */
  #define TFN_NO_DEREF	8	/* do not dereference a Funcref */
+ #define TFN_READ_ONLY	16	/* will not change the var */
  
  /* Values for get_lval() flags argument: */
  #define GLV_QUIET	TFN_QUIET	/* no error messages */
  #define GLV_NO_AUTOLOAD	TFN_NO_AUTOLOAD	/* do not use script autoloading */
+ #define GLV_READ_ONLY	TFN_READ_ONLY	/* will not change the var */
  
  #define DO_NOT_FREE_CNT 99999	/* refcount for dict or list that should not
  				   be freed. */
*** ../vim-8.0.0344/src/testdir/test_changedtick.vim	2017-02-20 22:35:29.013423395 +0100
--- src/testdir/test_changedtick.vim	2017-02-21 20:39:05.941451793 +0100
***************
*** 32,37 ****
--- 32,43 ----
    call assert_equal(v + 1, getbufvar(bnr, 'changedtick'))
  endfunc
  
+ func Test_changedtick_islocked()
+   call assert_equal(0, islocked('b:changedtick'))
+   let d = b:
+   call assert_equal(0, islocked('d.changedtick'))
+ endfunc
+ 
  func Test_changedtick_fixed()
    call assert_fails('let b:changedtick = 4', 'E46:')
    call assert_fails('let b:["changedtick"] = 4', 'E46:')
*** ../vim-8.0.0344/src/version.c	2017-02-20 23:07:00.478656212 +0100
--- src/version.c	2017-02-21 20:45:50.126895362 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     345,
  /**/

-- 
No engineer can take a shower without wondering if some sort of Teflon coating
would make showering unnecessary.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0346
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0346
Problem:    Vim relies on limits.h to be included indirectly, but on Solaris 9
            it may not be. (Ben Fritz)
Solution:   Always include limits.h.
Files:      src/os_unixx.h, src/vim.h


*** ../vim-8.0.0345/src/os_unixx.h	2017-01-12 20:06:30.152522974 +0100
--- src/os_unixx.h	2017-02-21 21:56:38.403785632 +0100
***************
*** 69,84 ****
  #endif
  
  #ifdef HAVE_SYS_SYSTEMINFO_H
! /*
!  * foolish Sinix <sys/systeminfo.h> uses SYS_NMLN but doesn't include
!  * <limits.h>, where it is defined. Perhaps other systems have the same
!  * problem? Include it here. -- Slootman
!  */
! # if defined(HAVE_LIMITS_H) && !defined(_LIMITS_H)
! #  include <limits.h>		/* for SYS_NMLN (Sinix 5.41 / Unix SysV.4) */
! # endif
! 
! /* Define SYS_NMLN ourselves if it still isn't defined (for CrayT3E). */
  # ifndef SYS_NMLN
  #  define SYS_NMLN 32
  # endif
--- 69,75 ----
  #endif
  
  #ifdef HAVE_SYS_SYSTEMINFO_H
! /* <sys/systeminfo.h> uses SYS_NMLN but it may not be defined (CrayT3E). */
  # ifndef SYS_NMLN
  #  define SYS_NMLN 32
  # endif
*** ../vim-8.0.0345/src/vim.h	2017-02-21 20:47:09.966394747 +0100
--- src/vim.h	2017-02-21 21:48:00.687143800 +0100
***************
*** 487,492 ****
--- 487,495 ----
  # include <errno.h>
  #endif
  
+ /* for INT_MAX et al. */
+ #include <limits.h>
+ 
  /*
   * Allow other (non-unix) systems to configure themselves now
   * These are also in os_unix.h, because osdef.sh needs them there.
*** ../vim-8.0.0345/src/version.c	2017-02-21 20:47:09.966394747 +0100
--- src/version.c	2017-02-21 21:55:45.972124468 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     346,
  /**/

-- 
I used to be indecisive, now I'm not sure.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0347
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0347
Problem:    When using CTRL-X CTRL-U inside a comment, the use of the comment
            leader may not work. (Klement)
Solution:   Save and restore did_ai. (Christian Brabandt, closes #1494)
Files:      src/edit.c, src/testdir/test_popup.vim


*** ../vim-8.0.0346/src/edit.c	2017-02-19 15:26:14.353270128 +0100
--- src/edit.c	2017-02-21 22:56:12.180695294 +0100
***************
*** 5095,5100 ****
--- 5095,5101 ----
      int		n;
      int		save_w_wrow;
      int		insert_match;
+     int		save_did_ai = did_ai;
  
      compl_direction = ins_compl_key2dir(c);
      insert_match = ins_compl_use_match(c);
***************
*** 5378,5383 ****
--- 5379,5386 ----
  	    {
  		EMSG2(_(e_notset), ctrl_x_mode == CTRL_X_FUNCTION
  					     ? "completefunc" : "omnifunc");
+ 		/* restore did_ai, so that adding comment leader works */
+ 		did_ai = save_did_ai;
  		return FAIL;
  	    }
  
*** ../vim-8.0.0346/src/testdir/test_popup.vim	2017-02-19 15:26:14.353270128 +0100
--- src/testdir/test_popup.vim	2017-02-21 23:00:14.523126264 +0100
***************
*** 551,554 ****
--- 551,573 ----
    iunmap <Right>
  endfunc
  
+ func Test_completion_comment_formatting()
+   new
+   setl formatoptions=tcqro
+   call feedkeys("o/*\<cr>\<cr>/\<esc>", 'tx')
+   call assert_equal(['', '/*', ' *', ' */'], getline(1,4))
+   %d
+   call feedkeys("o/*\<cr>foobar\<cr>/\<esc>", 'tx')
+   call assert_equal(['', '/*', ' * foobar', ' */'], getline(1,4))
+   %d
+   try
+     call feedkeys("o/*\<cr>\<cr>\<c-x>\<c-u>/\<esc>", 'tx')
+     call assert_false(1, 'completefunc not set, should have failed')
+   catch
+     call assert_exception('E764:')
+   endtry
+   call assert_equal(['', '/*', ' *', ' */'], getline(1,4))
+   bwipe!
+ endfunc
+ 
  " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.0.0346/src/version.c	2017-02-21 21:57:02.475629988 +0100
--- src/version.c	2017-02-21 22:54:36.357315473 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     347,
  /**/

-- 
It's totally unfair to suggest - as many have - that engineers are socially
inept.  Engineers simply have different objectives when it comes to social
interaction.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0348
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0348
Problem:    When building with a shadow directory on macOS lacks the
            +clipboard feature.
Solution:   Link *.m files, specifically os_macosx.m. (Kazunobu Kuriyama)
Files:      src/Makefile


*** ../vim-8.0.0347/src/Makefile	2017-02-18 16:58:44.264503901 +0100
--- src/Makefile	2017-02-22 22:00:17.546458589 +0100
***************
*** 2763,2769 ****
  
  shadow:	runtime pixmaps
  	mkdir $(SHADOWDIR)
! 	cd $(SHADOWDIR); ln -s ../*.[ch] ../*.in ../*.sh ../*.xs ../*.xbm ../gui_gtk_res.xml ../toolcheck ../proto ../vimtutor ../gvimtutor ../mkinstalldirs .
  	mkdir $(SHADOWDIR)/auto
  	cd $(SHADOWDIR)/auto; ln -s ../../auto/configure .
  	mkdir $(SHADOWDIR)/po
--- 2763,2769 ----
  
  shadow:	runtime pixmaps
  	mkdir $(SHADOWDIR)
! 	cd $(SHADOWDIR); ln -s ../*.[chm] ../*.in ../*.sh ../*.xs ../*.xbm ../gui_gtk_res.xml ../toolcheck ../proto ../vimtutor ../gvimtutor ../mkinstalldirs .
  	mkdir $(SHADOWDIR)/auto
  	cd $(SHADOWDIR)/auto; ln -s ../../auto/configure .
  	mkdir $(SHADOWDIR)/po
*** ../vim-8.0.0347/src/version.c	2017-02-21 23:00:32.779008036 +0100
--- src/version.c	2017-02-22 22:02:24.809648238 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     348,
  /**/

-- 
The process for understanding customers primarily involves sitting around with
other marketing people and talking about what you would to if you were dumb
enough to be a customer.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0349
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0349
Problem:    Redrawing errors with GTK 3.
Solution:   When updating, first clear all rectangles and then draw them.
            (Kazunobu Kuriyama, Christian Ludwig, closes #848)
Files:      src/gui_gtk_x11.c


*** ../vim-8.0.0348/src/gui_gtk_x11.c	2017-02-01 11:50:04.346268005 +0100
--- src/gui_gtk_x11.c	2017-02-23 12:17:58.934631926 +0100
***************
*** 630,635 ****
--- 630,636 ----
      static void
  gui_gtk3_redraw(int x, int y, int width, int height)
  {
+     /* Range checks are left to gui_redraw_block() */
      gui_redraw_block(Y_2_ROW(y), X_2_COL(x),
  	    Y_2_ROW(y + height - 1), X_2_COL(x + width - 1),
  	    GUI_MON_NOCLEAR);
***************
*** 684,695 ****
  	if (list->status != CAIRO_STATUS_CLIP_NOT_REPRESENTABLE)
  	{
  	    int i;
  	    for (i = 0; i < list->num_rectangles; i++)
  	    {
  		const cairo_rectangle_t rect = list->rectangles[i];
  
! 		gui_mch_clear_block(Y_2_ROW(rect.y), 1,
! 			Y_2_ROW(rect.y + rect.height - 1), Columns);
  
  		if (blink_mode)
  		    gui_gtk3_redraw(rect.x, rect.y, rect.width, rect.height);
--- 685,704 ----
  	if (list->status != CAIRO_STATUS_CLIP_NOT_REPRESENTABLE)
  	{
  	    int i;
+ 
+ 	    /* First clear all the blocks and then redraw them.  Just in case
+ 	     * some blocks overlap. */
  	    for (i = 0; i < list->num_rectangles; i++)
  	    {
  		const cairo_rectangle_t rect = list->rectangles[i];
  
! 		gui_mch_clear_block(Y_2_ROW((int)rect.y), 0,
! 			Y_2_ROW((int)(rect.y + rect.height)) - 1, Columns - 1);
! 	    }
! 
! 	    for (i = 0; i < list->num_rectangles; i++)
! 	    {
! 		const cairo_rectangle_t rect = list->rectangles[i];
  
  		if (blink_mode)
  		    gui_gtk3_redraw(rect.x, rect.y, rect.width, rect.height);
***************
*** 6709,6716 ****
   * (row2, col2) inclusive.
   */
      void
! gui_mch_clear_block(int row1, int col1, int row2, int col2)
  {
  #if GTK_CHECK_VERSION(3,0,0)
      if (gtk_widget_get_window(gui.drawarea) == NULL)
  	return;
--- 6718,6731 ----
   * (row2, col2) inclusive.
   */
      void
! gui_mch_clear_block(int row1arg, int col1arg, int row2arg, int col2arg)
  {
+ 
+     int col1 = check_col(col1arg);
+     int col2 = check_col(col2arg);
+     int row1 = check_row(row1arg);
+     int row2 = check_row(row2arg);
+ 
  #if GTK_CHECK_VERSION(3,0,0)
      if (gtk_widget_get_window(gui.drawarea) == NULL)
  	return;
*** ../vim-8.0.0348/src/version.c	2017-02-22 22:04:01.133026003 +0100
--- src/version.c	2017-02-23 12:14:07.620065351 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     349,
  /**/

-- 
Contrary to popular belief, it's often your clothing that gets promoted, not
you.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0350
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0350
Problem:    Not enough test coverage for Perl.
Solution:   Add more Perl tests. (Dominique Perl, closes #1500)
Files:      src/testdir/test_perl.vim


*** ../vim-8.0.0349/src/testdir/test_perl.vim	2017-01-29 22:59:08.253373379 +0100
--- src/testdir/test_perl.vim	2017-02-23 13:43:48.118340300 +0100
***************
*** 26,32 ****
    call assert_equal('abc/def/', getline('$'))
  endfunc
  
! fu <SID>catch_peval(expr)
    try
      call perleval(a:expr)
    catch
--- 26,132 ----
    call assert_equal('abc/def/', getline('$'))
  endfunc
  
! func Test_buffer_Delete()
!   new
!   call setline(1, ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'])
!   perl $curbuf->Delete(7)
!   perl $curbuf->Delete(2, 5)
!   perl $curbuf->Delete(10)
!   call assert_equal(['a', 'f', 'h'],  getline(1, '$'))
!   bwipe!
! endfunc
! 
! func Test_buffer_Append()
!   new
!   perl $curbuf->Append(1, '1')
!   perl $curbuf->Append(2, '2', '3', '4')
!   perl @l = ('5' ..'7')
!   perl $curbuf->Append(0, @l)
!   call assert_equal(['5', '6', '7', '', '1', '2', '3', '4'], getline(1, '$'))
!   bwipe!
! endfunc
! 
! func Test_buffer_Set()
!   new
!   call setline(1, ['1', '2', '3', '4', '5'])
!   perl $curbuf->Set(2, 'a', 'b', 'c')
!   perl $curbuf->Set(4, 'A', 'B', 'C')
!   call assert_equal(['1', 'a', 'b', 'A', 'B'], getline(1, '$'))
!   bwipe!
! endfunc
! 
! func Test_buffer_Get()
!   new
!   call setline(1, ['1', '2', '3', '4'])
!   call assert_equal('2:3', perleval('join(":", $curbuf->Get(2, 3))'))
!   bwipe!
! endfunc
! 
! func Test_buffer_Count()
!   new
!   call setline(1, ['a', 'b', 'c'])
!   call assert_equal(3, perleval('$curbuf->Count()'))
!   bwipe!
! endfunc
! 
! func Test_buffer_Name()
!   new
!   call assert_equal('', perleval('$curbuf->Name()'))
!   bwipe!
!   new Xfoo
!   call assert_equal('Xfoo', perleval('$curbuf->Name()'))
!   bwipe!
! endfunc
! 
! func Test_buffer_Number()
!   call assert_equal(bufnr('%'), perleval('$curbuf->Number()'))
! endfunc
! 
! func Test_window_Cursor()
!   new
!   call setline(1, ['line1', 'line2'])
!   perl $curwin->Cursor(2, 3)
!   call assert_equal('2:3', perleval('join(":", $curwin->Cursor())'))
!   " Col is numbered from 0 in Perl, and from 1 in Vim script.
!   call assert_equal([0, 2, 4, 0], getpos('.'))
!   bwipe!
! endfunc
! 
! func Test_window_SetHeight()
!   new
!   perl $curwin->SetHeight(2)
!   call assert_equal(2, winheight(0))
!   bwipe!
! endfunc
! 
! func Test_VIM_Windows()
!   new
!   " VIM::Windows() without argument in scalar and list context.
!   perl $winnr = VIM::Windows()
!   perl @winlist = VIM::Windows()
!   perl $curbuf->Append(0, $winnr, scalar(@winlist))
!   call assert_equal(['2', '2', ''], getline(1, '$'))
! 
!   " VIM::Windows() with window number argument.
!   perl VIM::Windows(VIM::Eval('winnr()'))->Buffer()->Set(1, 'bar')
!   call assert_equal('bar', getline(1))
!   bwipe!
! endfunc
! 
! func Test_VIM_Buffers()
!   new Xbar
!   " VIM::Buffers() without argument in scalar and list context.
!   perl $nbuf = VIM::Buffers()
!   perl @buflist = VIM::Buffers()
! 
!   " VIM::Buffers() with argument.
!   perl $mybuf = (VIM::Buffers('Xbar'))[0]
!   perl $mybuf->Append(0, $nbuf, scalar(@buflist))
!   call assert_equal(['2', '2', ''], getline(1, '$'))
!   bwipe!
! endfunc
! 
! func <SID>catch_peval(expr)
    try
      call perleval(a:expr)
    catch
***************
*** 36,42 ****
    return ''
  endfunc
  
! function Test_perleval()
    call assert_false(perleval('undef'))
  
    " scalar
--- 136,142 ----
    return ''
  endfunc
  
! func Test_perleval()
    call assert_false(perleval('undef'))
  
    " scalar
***************
*** 75,81 ****
    call assert_true(perleval('\\0') =~ 'SCALAR(0x\x\+)')
  endfunc
  
! function Test_perldo()
    sp __TEST__
    exe 'read ' g:testname
    perldo s/perl/vieux_chameau/g
--- 175,181 ----
    call assert_true(perleval('\\0') =~ 'SCALAR(0x\x\+)')
  endfunc
  
! func Test_perldo()
    sp __TEST__
    exe 'read ' g:testname
    perldo s/perl/vieux_chameau/g
***************
*** 99,105 ****
    bwipe!
  endfunc
  
! function Test_VIM_package()
    perl VIM::DoCommand('let l:var = "foo"')
    call assert_equal(l:var, 'foo')
  
--- 199,205 ----
    bwipe!
  endfunc
  
! func Test_VIM_package()
    perl VIM::DoCommand('let l:var = "foo"')
    call assert_equal(l:var, 'foo')
  
***************
*** 108,114 ****
    call assert_true(&et)
  endfunc
  
! function Test_stdio()
    redir =>l:out
    perl <<EOF
      VIM::Msg("&VIM::Msg");
--- 208,214 ----
    call assert_true(&et)
  endfunc
  
! func Test_stdio()
    redir =>l:out
    perl <<EOF
      VIM::Msg("&VIM::Msg");
***************
*** 119,125 ****
    call assert_equal(['&VIM::Msg', 'STDOUT', 'STDERR'], split(l:out, "\n"))
  endfunc
  
! function Test_SvREFCNT()
    new t
    perl <<--perl
    my ($b, $w);
--- 219,225 ----
    call assert_equal(['&VIM::Msg', 'STDOUT', 'STDERR'], split(l:out, "\n"))
  endfunc
  
! func Test_SvREFCNT()
    new t
    perl <<--perl
    my ($b, $w);
*** ../vim-8.0.0349/src/version.c	2017-02-23 12:20:30.205696184 +0100
--- src/version.c	2017-02-23 13:45:40.205635940 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     350,
  /**/

-- 
A)bort, R)etry, D)o it right this time

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0351
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0351
Problem:    No test for concatenating an empty string that results from out of
            bounds indexing.
Solution:   Add a simple test.
Files:      src/testdir/test_expr.vim


*** ../vim-8.0.0350/src/testdir/test_expr.vim	2016-10-02 16:51:32.744592886 +0200
--- src/testdir/test_expr.vim	2017-01-27 22:12:24.710617084 +0100
***************
*** 473,475 ****
--- 473,480 ----
    call setmatches(set)
    call assert_equal(exp, getmatches())
  endfunc
+ 
+ func Test_empty_concatenate()
+   call assert_equal('b', 'a'[4:0] . 'b')
+   call assert_equal('b', 'b' . 'a'[4:0])
+ endfunc
*** ../vim-8.0.0350/src/version.c	2017-02-23 13:45:54.177548173 +0100
--- src/version.c	2017-02-23 13:48:52.476417616 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     351,
  /**/

-- 
A)bort, R)etry, P)lease don't bother me again

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0352
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0352
Problem:    The condition for when a typval needs to be cleared is too
            complicated.
Solution:   Init the type to VAR_UNKNOWN and clear it always.
Files:      src/eval.c


*** ../vim-8.0.0351/src/eval.c	2017-02-21 20:47:09.962394772 +0100
--- src/eval.c	2017-02-23 14:15:47.190004892 +0100
***************
*** 1898,1903 ****
--- 1898,1905 ----
       * Loop until no more [idx] or .key is following.
       */
      lp->ll_tv = &v->di_tv;
+     var1.v_type = VAR_UNKNOWN;
+     var2.v_type = VAR_UNKNOWN;
      while (*p == '[' || (*p == '.' && lp->ll_tv->v_type == VAR_DICT))
      {
  	if (!(lp->ll_tv->v_type == VAR_LIST && lp->ll_tv->vval.v_list != NULL)
***************
*** 1955,1962 ****
  		{
  		    if (!quiet)
  			EMSG(_(e_dictrange));
! 		    if (!empty1)
! 			clear_tv(&var1);
  		    return NULL;
  		}
  		if (rettv != NULL && (rettv->v_type != VAR_LIST
--- 1957,1963 ----
  		{
  		    if (!quiet)
  			EMSG(_(e_dictrange));
! 		    clear_tv(&var1);
  		    return NULL;
  		}
  		if (rettv != NULL && (rettv->v_type != VAR_LIST
***************
*** 1964,1971 ****
  		{
  		    if (!quiet)
  			EMSG(_("E709: [:] requires a List value"));
! 		    if (!empty1)
! 			clear_tv(&var1);
  		    return NULL;
  		}
  		p = skipwhite(p + 1);
--- 1965,1971 ----
  		{
  		    if (!quiet)
  			EMSG(_("E709: [:] requires a List value"));
! 		    clear_tv(&var1);
  		    return NULL;
  		}
  		p = skipwhite(p + 1);
***************
*** 1976,1990 ****
  		    lp->ll_empty2 = FALSE;
  		    if (eval1(&p, &var2, TRUE) == FAIL)	/* recursive! */
  		    {
! 			if (!empty1)
! 			    clear_tv(&var1);
  			return NULL;
  		    }
  		    if (get_tv_string_chk(&var2) == NULL)
  		    {
  			/* not a number or string */
! 			if (!empty1)
! 			    clear_tv(&var1);
  			clear_tv(&var2);
  			return NULL;
  		    }
--- 1976,1988 ----
  		    lp->ll_empty2 = FALSE;
  		    if (eval1(&p, &var2, TRUE) == FAIL)	/* recursive! */
  		    {
! 			clear_tv(&var1);
  			return NULL;
  		    }
  		    if (get_tv_string_chk(&var2) == NULL)
  		    {
  			/* not a number or string */
! 			clear_tv(&var1);
  			clear_tv(&var2);
  			return NULL;
  		    }
***************
*** 1998,2007 ****
  	    {
  		if (!quiet)
  		    EMSG(_(e_missbrac));
! 		if (!empty1)
! 		    clear_tv(&var1);
! 		if (lp->ll_range && !lp->ll_empty2)
! 		    clear_tv(&var2);
  		return NULL;
  	    }
  
--- 1996,2003 ----
  	    {
  		if (!quiet)
  		    EMSG(_(e_missbrac));
! 		clear_tv(&var1);
! 		clear_tv(&var2);
  		return NULL;
  	    }
  
***************
*** 2064,2079 ****
  		{
  		    if (!quiet)
  			EMSG2(_(e_dictkey), key);
! 		    if (len == -1)
! 			clear_tv(&var1);
  		    return NULL;
  		}
  		if (len == -1)
  		    lp->ll_newkey = vim_strsave(key);
  		else
  		    lp->ll_newkey = vim_strnsave(key, len);
! 		if (len == -1)
! 		    clear_tv(&var1);
  		if (lp->ll_newkey == NULL)
  		    p = NULL;
  		break;
--- 2060,2073 ----
  		{
  		    if (!quiet)
  			EMSG2(_(e_dictkey), key);
! 		    clear_tv(&var1);
  		    return NULL;
  		}
  		if (len == -1)
  		    lp->ll_newkey = vim_strsave(key);
  		else
  		    lp->ll_newkey = vim_strnsave(key, len);
! 		clear_tv(&var1);
  		if (lp->ll_newkey == NULL)
  		    p = NULL;
  		break;
***************
*** 2086,2093 ****
  		return NULL;
  	    }
  
! 	    if (len == -1)
! 		clear_tv(&var1);
  	    lp->ll_tv = &lp->ll_di->di_tv;
  	}
  	else
--- 2080,2086 ----
  		return NULL;
  	    }
  
! 	    clear_tv(&var1);
  	    lp->ll_tv = &lp->ll_di->di_tv;
  	}
  	else
***************
*** 2098,2108 ****
  	    if (empty1)
  		lp->ll_n1 = 0;
  	    else
! 	    {
  		lp->ll_n1 = (long)get_tv_number(&var1);
! 						    /* is number or string */
! 		clear_tv(&var1);
! 	    }
  	    lp->ll_dict = NULL;
  	    lp->ll_list = lp->ll_tv->vval.v_list;
  	    lp->ll_li = list_find(lp->ll_list, lp->ll_n1);
--- 2091,2100 ----
  	    if (empty1)
  		lp->ll_n1 = 0;
  	    else
! 		/* is number or string */
  		lp->ll_n1 = (long)get_tv_number(&var1);
! 	    clear_tv(&var1);
! 
  	    lp->ll_dict = NULL;
  	    lp->ll_list = lp->ll_tv->vval.v_list;
  	    lp->ll_li = list_find(lp->ll_list, lp->ll_n1);
***************
*** 2116,2123 ****
  	    }
  	    if (lp->ll_li == NULL)
  	    {
! 		if (lp->ll_range && !lp->ll_empty2)
! 		    clear_tv(&var2);
  		if (!quiet)
  		    EMSGN(_(e_listidx), lp->ll_n1);
  		return NULL;
--- 2108,2114 ----
  	    }
  	    if (lp->ll_li == NULL)
  	    {
! 		clear_tv(&var2);
  		if (!quiet)
  		    EMSGN(_(e_listidx), lp->ll_n1);
  		return NULL;
***************
*** 2161,2166 ****
--- 2152,2158 ----
  	}
      }
  
+     clear_tv(&var1);
      return p;
  }
  
*** ../vim-8.0.0351/src/version.c	2017-02-23 13:50:34.935755831 +0100
--- src/version.c	2017-02-23 14:23:51.678888394 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     352,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
2. You kiss your girlfriend's home page.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0353
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0353
Problem:    If [RO] in the status line is translated to a longer string, it is
            trunctted to 4 bytes.
Solution:   Skip over the resulting string. (Jente Hidskes, closes #1499)
Files:      src/screen.c


*** ../vim-8.0.0352/src/screen.c	2017-02-01 21:23:05.555250993 +0100
--- src/screen.c	2017-02-23 14:50:01.420901310 +0100
***************
*** 6730,6736 ****
  	if (wp->w_buffer->b_p_ro)
  	{
  	    STRCPY(p + len, _("[RO]"));
! 	    len += 4;
  	}
  
  	this_ru_col = ru_col - (Columns - W_WIDTH(wp));
--- 6730,6736 ----
  	if (wp->w_buffer->b_p_ro)
  	{
  	    STRCPY(p + len, _("[RO]"));
! 	    len += (int)STRLEN(p + len);
  	}
  
  	this_ru_col = ru_col - (Columns - W_WIDTH(wp));
*** ../vim-8.0.0352/src/version.c	2017-02-23 14:25:13.210370073 +0100
--- src/version.c	2017-02-23 14:51:38.488282132 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     353,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
5. You find yourself brainstorming for new subjects to search.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0354
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0354
Problem:    Test to check that setting termcap key fails sometimes.
Solution:   Check for "t_k1" to exist. (Christian Brabandt, closes #1459)
Files:      src/testdir/test_assign.vim


*** ../vim-8.0.0353/src/testdir/test_assign.vim	2017-02-04 21:50:14.226462278 +0100
--- src/testdir/test_assign.vim	2017-02-23 15:17:52.942254389 +0100
***************
*** 15,21 ****
    call assert_match('t_te.*^[[yes;', execute("set termcap"))
    let &t_te = old_t_te
  
!   if !has('gui_running')
      " Key code
      let old_t_k1 = &t_k1
      let &t_k1 = "that"
--- 15,21 ----
    call assert_match('t_te.*^[[yes;', execute("set termcap"))
    let &t_te = old_t_te
  
!   if exists("+t_k1")
      " Key code
      let old_t_k1 = &t_k1
      let &t_k1 = "that"
*** ../vim-8.0.0353/src/version.c	2017-02-23 14:55:55.602643421 +0100
--- src/version.c	2017-02-23 15:19:00.181827302 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     354,
  /**/

-- 
The goal of science is to build better mousetraps.
The goal of nature is to build better mice.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0355
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0355
Problem:    Using uninitialized memory when 'isfname' is empty.
Solution:   Don't call getpwnam() without an argument. (Dominique Pelle,
            closes #1464)
Files:      src/misc1.c, src/testdir/test_options.vim


*** ../vim-8.0.0354/src/misc1.c	2017-02-17 16:31:16.925294107 +0100
--- src/misc1.c	2017-02-23 17:00:02.835293538 +0100
***************
*** 4028,4042 ****
  		 */
  #  if defined(HAVE_GETPWNAM) && defined(HAVE_PWD_H)
  		{
- 		    struct passwd *pw;
- 
  		    /* Note: memory allocated by getpwnam() is never freed.
  		     * Calling endpwent() apparently doesn't help. */
! 		    pw = getpwnam((char *)dst + 1);
! 		    if (pw != NULL)
! 			var = (char_u *)pw->pw_dir;
! 		    else
! 			var = NULL;
  		}
  		if (var == NULL)
  #  endif
--- 4028,4039 ----
  		 */
  #  if defined(HAVE_GETPWNAM) && defined(HAVE_PWD_H)
  		{
  		    /* Note: memory allocated by getpwnam() is never freed.
  		     * Calling endpwent() apparently doesn't help. */
! 		    struct passwd *pw = (*dst == NUL)
! 					? NULL : getpwnam((char *)dst + 1);
! 
! 		    var = (pw == NULL) ? NULL : (char_u *)pw->pw_dir;
  		}
  		if (var == NULL)
  #  endif
***************
*** 9652,9658 ****
  # endif
  	    if (match_file_list(p_wig, (*files)[i], ffname))
  	    {
! 		/* remove this matching files from the list */
  		vim_free((*files)[i]);
  		for (j = i; j + 1 < *num_files; ++j)
  		    (*files)[j] = (*files)[j + 1];
--- 9649,9655 ----
  # endif
  	    if (match_file_list(p_wig, (*files)[i], ffname))
  	    {
! 		/* remove this matching file from the list */
  		vim_free((*files)[i]);
  		for (j = i; j + 1 < *num_files; ++j)
  		    (*files)[j] = (*files)[j + 1];
***************
*** 10736,10749 ****
  static int has_special_wildchar(char_u *p);
  
  /*
!  * Return TRUE if "p" contains a special wildcard character.
!  * Allowing for escaping.
   */
      static int
  has_special_wildchar(char_u *p)
  {
      for ( ; *p; mb_ptr_adv(p))
      {
  	if (*p == '\\' && p[1] != NUL)
  	    ++p;
  	else if (vim_strchr((char_u *)SPECIAL_WILDCHAR, *p) != NULL)
--- 10733,10747 ----
  static int has_special_wildchar(char_u *p);
  
  /*
!  * Return TRUE if "p" contains a special wildcard character, one that Vim
!  * cannot expand, requires using a shell.
   */
      static int
  has_special_wildchar(char_u *p)
  {
      for ( ; *p; mb_ptr_adv(p))
      {
+ 	/* Allow for escaping. */
  	if (*p == '\\' && p[1] != NUL)
  	    ++p;
  	else if (vim_strchr((char_u *)SPECIAL_WILDCHAR, *p) != NULL)
*** ../vim-8.0.0354/src/testdir/test_options.vim	2017-02-19 21:07:01.002386675 +0100
--- src/testdir/test_options.vim	2017-02-23 17:00:02.835293538 +0100
***************
*** 22,27 ****
--- 22,34 ----
    set whichwrap&
  endfunction
  
+ function! Test_isfname()
+   " This used to cause Vim to access uninitialized memory.
+   set isfname=
+   call assert_equal("~X", expand("~X"))
+   set isfname&
+ endfunction
+ 
  function Test_options()
    let caught = 'ok'
    try
*** ../vim-8.0.0354/src/version.c	2017-02-23 15:19:59.409451193 +0100
--- src/version.c	2017-02-23 16:59:49.219379339 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     355,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
9. All your daydreaming is preoccupied with getting a faster connection to the
   net: 28.8...ISDN...cable modem...T1...T3.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0356
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0356 (after 8.0.0342)
Problem:    Leaking memory when setting 'ttytype'.
Solution:   Get free_oldval from the right option entry.
Files:      src/option.c


*** ../vim-8.0.0355/src/option.c	2017-02-19 21:07:01.002386675 +0100
--- src/option.c	2017-02-23 17:15:56.021286655 +0100
***************
*** 5936,5941 ****
--- 5936,5942 ----
  	    /* Both 'term' and 'ttytype' point to T_NAME, only set the
  	     * P_ALLOCED flag on 'term'. */
  	    opt_idx = findoption((char_u *)"term");
+ 	    free_oldval = (options[opt_idx].flags & P_ALLOCED);
  	}
      }
  
*** ../vim-8.0.0355/src/version.c	2017-02-23 17:07:10.312599693 +0100
--- src/version.c	2017-02-23 17:17:47.756582472 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     356,
  /**/

-- 
"How is your new girlfriend?"
"90-60-90 man!"
"What, pale purple?"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0357
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0357
Problem:    Crash when setting 'guicursor' to weird value.
Solution:   Avoid negative size. (Dominique Pelle, closes #1465)
Files:      src/misc2.c, src/testdir/test_options.vim


*** ../vim-8.0.0356/src/misc2.c	2017-01-27 21:54:03.986030660 +0100
--- src/misc2.c	2017-02-23 17:58:06.424962060 +0100
***************
*** 3472,3482 ****
  	while (*modep != NUL)
  	{
  	    colonp = vim_strchr(modep, ':');
! 	    if (colonp == NULL)
  		return (char_u *)N_("E545: Missing colon");
  	    if (colonp == modep)
  		return (char_u *)N_("E546: Illegal mode");
- 	    commap = vim_strchr(modep, ',');
  
  	    /*
  	     * Repeat for all mode's before the colon.
--- 3472,3483 ----
  	while (*modep != NUL)
  	{
  	    colonp = vim_strchr(modep, ':');
! 	    commap = vim_strchr(modep, ',');
! 
! 	    if (colonp == NULL || (commap != NULL && commap < colonp))
  		return (char_u *)N_("E545: Missing colon");
  	    if (colonp == modep)
  		return (char_u *)N_("E546: Illegal mode");
  
  	    /*
  	     * Repeat for all mode's before the colon.
*** ../vim-8.0.0356/src/testdir/test_options.vim	2017-02-23 17:07:10.308599718 +0100
--- src/testdir/test_options.vim	2017-02-23 17:58:06.424962060 +0100
***************
*** 235,241 ****
    call assert_fails('set statusline=%{', 'E540:')
    call assert_fails('set statusline=' . repeat("%p", 81), 'E541:')
    call assert_fails('set statusline=%(', 'E542:')
!   call assert_fails('set guicursor=x', 'E545:')
    call assert_fails('set backupext=~ patchmode=~', 'E589:')
    call assert_fails('set winminheight=10 winheight=9', 'E591:')
    call assert_fails('set winminwidth=10 winwidth=9', 'E592:')
--- 235,248 ----
    call assert_fails('set statusline=%{', 'E540:')
    call assert_fails('set statusline=' . repeat("%p", 81), 'E541:')
    call assert_fails('set statusline=%(', 'E542:')
!   if has('cursorshape')
!     " This invalid value for 'guicursor' used to cause Vim to crash.
!     call assert_fails('set guicursor=i-ci,r-cr:h', 'E545:')
!     call assert_fails('set guicursor=i-ci', 'E545:')
!     call assert_fails('set guicursor=x', 'E545:')
!     call assert_fails('set guicursor=r-cr:horx', 'E548:')
!     call assert_fails('set guicursor=r-cr:hor0', 'E549:')
!   endif
    call assert_fails('set backupext=~ patchmode=~', 'E589:')
    call assert_fails('set winminheight=10 winheight=9', 'E591:')
    call assert_fails('set winminwidth=10 winwidth=9', 'E592:')
*** ../vim-8.0.0356/src/version.c	2017-02-23 17:18:33.340295191 +0100
--- src/version.c	2017-02-23 17:57:21.025254901 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     357,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
10. And even your night dreams are in HTML.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0358
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0358
Problem:    Invalid memory access in C-indent code.
Solution:   Don't go over end of empty line. (Dominique Pelle, closes #1492)
Files:      src/edit.c, src/testdir/test_options.vim


*** ../vim-8.0.0357/src/edit.c	2017-02-21 23:00:32.775008062 +0100
--- src/edit.c	2017-02-23 18:06:22.153767039 +0100
***************
*** 8181,8187 ****
  	{
  	    if (try_match && *look == keytyped)
  		return TRUE;
! 	    ++look;
  	}
  
  	/*
--- 8181,8188 ----
  	{
  	    if (try_match && *look == keytyped)
  		return TRUE;
! 	    if (*look != NUL)
! 		++look;
  	}
  
  	/*
*** ../vim-8.0.0357/src/testdir/test_options.vim	2017-02-23 17:59:17.148505954 +0100
--- src/testdir/test_options.vim	2017-02-23 18:06:22.153767039 +0100
***************
*** 135,140 ****
--- 135,147 ----
    call assert_fails("set " . a:name . "=/not.*there", "E474:")
  endfunc
  
+ func Test_cinkeys()
+   " This used to cause invalid memory access
+   set cindent cinkeys=0
+   norm a
+   set cindent& cinkeys&
+ endfunc
+ 
  func Test_dictionary()
    call Check_dir_option('dictionary')
  endfunc
*** ../vim-8.0.0357/src/version.c	2017-02-23 17:59:17.148505954 +0100
--- src/version.c	2017-02-23 18:07:11.705447921 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     358,
  /**/

-- 
The Feynman problem solving Algorithm:
	1) Write down the problem
	2) Think real hard
	3) Write down the answer

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0359
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0359
Problem:    'number' and 'relativenumber' are not properly tested.
Solution:   Add tests, change old style to new style tests. (Ozaki Kiichi,
            closes #1447)
Files:      src/Makefile, src/testdir/Make_all.mak, src/testdir/Make_vms.mms,
            src/testdir/test89.in, src/testdir/test89.ok,
            src/testdir/test_alot.vim, src/testdir/test_findfile.vim,
            src/testdir/test_number.vim


*** ../vim-8.0.0358/src/Makefile	2017-02-22 22:04:01.133026003 +0100
--- src/Makefile	2017-02-23 18:21:58.431729415 +0100
***************
*** 2082,2088 ****
  	test50 test51 test52 test53 test54 test55 test56 test57 test58 test59 \
  	test60 test64 test65 test66 test67 test68 test69 \
  	test70 test72 test73 test74 test75 test77 test78 test79 \
! 	test80 test82 test83 test84 test85 test86 test87 test88 test89 \
  	test90 test91 test94 test95 test97 test98 test99 \
  	test100 test101 test103 test104 test107 test108:
  	cd testdir; rm -f $@.out; $(MAKE) -f Makefile $@.out VIMPROG=../$(VIMTARGET) $(GUI_TESTARG) SCRIPTSOURCE=../$(SCRIPTSOURCE)
--- 2082,2088 ----
  	test50 test51 test52 test53 test54 test55 test56 test57 test58 test59 \
  	test60 test64 test65 test66 test67 test68 test69 \
  	test70 test72 test73 test74 test75 test77 test78 test79 \
! 	test80 test82 test83 test84 test85 test86 test87 test88 \
  	test90 test91 test94 test95 test97 test98 test99 \
  	test100 test101 test103 test104 test107 test108:
  	cd testdir; rm -f $@.out; $(MAKE) -f Makefile $@.out VIMPROG=../$(VIMTARGET) $(GUI_TESTARG) SCRIPTSOURCE=../$(SCRIPTSOURCE)
***************
*** 2122,2127 ****
--- 2122,2128 ----
  	test_fileformat \
  	test_filter_cmd \
  	test_filter_map \
+ 	test_findfile \
  	test_float_func \
  	test_fnameescape \
  	test_fnamemodify \
***************
*** 2164,2169 ****
--- 2165,2171 ----
  	test_nested_function \
  	test_netbeans \
  	test_normal \
+ 	test_number \
  	test_options \
  	test_packadd \
  	test_partial \
*** ../vim-8.0.0358/src/testdir/Make_all.mak	2017-02-17 12:04:35.843808317 +0100
--- src/testdir/Make_all.mak	2017-02-23 18:20:26.064325530 +0100
***************
*** 117,124 ****
  	test59.out \
  	test72.out \
  	test78.out \
! 	test83.out \
! 	test89.out
  
  
  # Tests specifically for MS-Windows.
--- 117,123 ----
  	test59.out \
  	test72.out \
  	test78.out \
! 	test83.out
  
  
  # Tests specifically for MS-Windows.
***************
*** 174,179 ****
--- 173,179 ----
  	    test_nested_function.res \
  	    test_netbeans.res \
  	    test_normal.res \
+ 	    test_number.res \
  	    test_packadd.res \
  	    test_paste.res \
  	    test_perl.res \
*** ../vim-8.0.0358/src/testdir/Make_vms.mms	2016-12-01 18:47:06.595684409 +0100
--- src/testdir/Make_vms.mms	2017-02-23 18:20:26.068325504 +0100
***************
*** 91,97 ****
         test66.out test67.out test68.out test69.out \
         test72.out test75.out \
         test77a.out test78.out test79.out test80.out \
!        test82.out test84.out test88.out test89.out \
         test90.out test91.out test94.out \
         test95.out test98.out test99.out \
         test103.out test104.out \
--- 91,97 ----
         test66.out test67.out test68.out test69.out \
         test72.out test75.out \
         test77a.out test78.out test79.out test80.out \
!        test82.out test84.out test88.out \
         test90.out test91.out test94.out \
         test95.out test98.out test99.out \
         test103.out test104.out \
*** ../vim-8.0.0358/src/testdir/test89.in	2013-07-13 14:00:31.000000000 +0200
--- src/testdir/test89.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,71 ****
- - Some tests for setting 'number' and 'relativenumber'
-   This is not all that useful now that the options are no longer reset when
-   setting the other.
- - Some tests for findfile() function
- 
- STARTTEST
- :so small.vim
- :set hidden nocp nu rnu viminfo+=nviminfo
- :redir @a | set nu? rnu? | redir END
- :e! xx
- :redir @b | set nu? rnu? | redir END
- :e! #
- :$put ='results:'
- :$put a
- :$put b
- :"
- :set nonu nornu
- :setglobal nu
- :setlocal rnu
- :redir @c | setglobal nu? | redir END
- :set nonu nornu
- :setglobal rnu
- :setlocal nu
- :redir @d | setglobal rnu? | redir END
- :$put =':setlocal must NOT reset the other global value'
- :$put c
- :$put d
- :"
- :set nonu nornu
- :setglobal nu
- :setglobal rnu
- :redir @e | setglobal nu? | redir END
- :set nonu nornu
- :setglobal rnu
- :setglobal nu
- :redir @f | setglobal rnu? | redir END
- :$put =':setglobal MUST reset the other global value'
- :$put e
- :$put f
- :"
- :set nonu nornu
- :set nu
- :set rnu
- :redir @g | setglobal nu? | redir END
- :set nonu nornu
- :set rnu
- :set nu
- :redir @h | setglobal rnu? | redir END
- :$put =':set MUST reset the other global value'
- :$put g
- :$put h
- :"
- :let cwd=getcwd()
- :cd ..
- :" Tests may be run from a shadow directory, so an extra cd needs to be done to
- :" get above src/
- :if fnamemodify(getcwd(), ':t') != 'src' | cd ../.. | else | cd .. | endif
- :$put =''
- :$put ='Testing findfile'
- :$put =''
- :set ssl
- :$put =findfile('test19.in','src/test*')
- :exe "cd" cwd
- :cd ..
- :$put =findfile('test19.in','test*')
- :$put =findfile('test19.in','testdir')
- :exe "cd" cwd
- :/^results/,$w! test.out
- :q!
- ENDTEST
- 
--- 0 ----
*** ../vim-8.0.0358/src/testdir/test89.ok	2013-07-03 17:06:20.000000000 +0200
--- src/testdir/test89.ok	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,28 ****
- results:
- 
-   number
-   relativenumber
- 
-   number
-   relativenumber
- :setlocal must NOT reset the other global value
- 
-   number
- 
-   relativenumber
- :setglobal MUST reset the other global value
- 
-   number
- 
-   relativenumber
- :set MUST reset the other global value
- 
-   number
- 
-   relativenumber
- 
- Testing findfile
- 
- src/testdir/test19.in
- testdir/test19.in
- testdir/test19.in
--- 0 ----
*** ../vim-8.0.0358/src/testdir/test_alot.vim	2017-02-18 16:58:44.264503901 +0100
--- src/testdir/test_alot.vim	2017-02-23 18:20:26.068325504 +0100
***************
*** 16,21 ****
--- 16,22 ----
  source test_fileformat.vim
  source test_filter_cmd.vim
  source test_filter_map.vim
+ source test_findfile.vim
  source test_float_func.vim
  source test_fnamemodify.vim
  source test_functions.vim
*** ../vim-8.0.0358/src/testdir/test_findfile.vim	2017-02-23 18:45:41.818563157 +0100
--- src/testdir/test_findfile.vim	2017-02-23 18:20:26.068325504 +0100
***************
*** 0 ****
--- 1,25 ----
+ " Test for findfile()
+ "
+ func Test_findfile()
+   new
+   let cwd=getcwd()
+   cd ..
+ 
+   " Tests may be run from a shadow directory, so an extra cd needs to be done to
+   " get above src/
+   if fnamemodify(getcwd(), ':t') != 'src'
+     cd ../.. 
+   else 
+     cd .. 
+   endif
+   set ssl
+ 
+   call assert_equal('src/testdir/test_findfile.vim', findfile('test_findfile.vim','src/test*'))
+   exe "cd" cwd
+   cd ..
+   call assert_equal('testdir/test_findfile.vim', findfile('test_findfile.vim','test*'))
+   call assert_equal('testdir/test_findfile.vim', findfile('test_findfile.vim','testdir'))
+ 
+   exe "cd" cwd
+   q!
+ endfunc
*** ../vim-8.0.0358/src/testdir/test_number.vim	2017-02-23 18:45:41.822563130 +0100
--- src/testdir/test_number.vim	2017-02-23 18:23:28.755146599 +0100
***************
*** 0 ****
--- 1,254 ----
+ " Test for 'number' and 'relativenumber'
+ 
+ source view_util.vim
+ 
+ func! s:screen_lines(start, end) abort
+   return ScreenLines([a:start, a:end], 8)
+ endfunc
+ 
+ func! s:compare_lines(expect, actual)
+   call assert_equal(a:expect, a:actual)
+ endfunc
+ 
+ func! s:test_windows(h, w) abort
+   call NewWindow(a:h, a:w)
+ endfunc
+ 
+ func! s:close_windows() abort
+   call CloseWindow()
+ endfunc
+ 
+ func! s:validate_cursor() abort
+   " update skipcol.
+   " wincol():
+   "   f_wincol
+   "     -> validate_cursor
+   "          -> curs_columns
+   call wincol()
+ endfunc
+ 
+ func Test_set_options()
+   set nu rnu
+   call assert_equal(1, &nu)
+   call assert_equal(1, &rnu)
+ 
+   call s:test_windows(10, 20)
+   call assert_equal(1, &nu)
+   call assert_equal(1, &rnu)
+   call s:close_windows()
+ 
+   set nu& rnu&
+ endfunc
+ 
+ func Test_set_global_and_local()
+   " setlocal must NOT reset the other global value
+   set nonu nornu
+   setglobal nu
+   setlocal rnu
+   call assert_equal(1, &g:nu)
+ 
+   set nonu nornu
+   setglobal rnu
+   setlocal nu
+   call assert_equal(1, &g:rnu)
+ 
+   " setglobal MUST reset the other global value
+   set nonu nornu
+   setglobal nu
+   setglobal rnu
+   call assert_equal(1, &g:nu)
+ 
+   set nonu nornu
+   setglobal rnu
+   setglobal nu
+   call assert_equal(1, &g:rnu)
+ 
+   " set MUST reset the other global value
+   set nonu nornu
+   set nu
+   set rnu
+   call assert_equal(1, &g:nu)
+ 
+   set nonu nornu
+   set rnu
+   set nu
+   call assert_equal(1, &g:rnu)
+ 
+   set nu& rnu&
+ endfunc
+ 
+ func Test_number()
+   call s:test_windows(10, 20)
+   call setline(1, ["abcdefghij", "klmnopqrst", "uvwxyzABCD", "EFGHIJKLMN", "OPQRSTUVWX", "YZ"])
+   setl number
+   let lines = s:screen_lines(1, 4)
+   let expect = [
+ \ "  1 abcd",
+ \ "  2 klmn",
+ \ "  3 uvwx",
+ \ "  4 EFGH",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows()
+ endfunc
+ 
+ func Test_relativenumber()
+   call s:test_windows(10, 20)
+   call setline(1, ["abcdefghij", "klmnopqrst", "uvwxyzABCD", "EFGHIJKLMN", "OPQRSTUVWX", "YZ"])
+   3
+   setl relativenumber
+   let lines = s:screen_lines(1, 6)
+   let expect = [
+ \ "  2 abcd",
+ \ "  1 klmn",
+ \ "  0 uvwx",
+ \ "  1 EFGH",
+ \ "  2 OPQR",
+ \ "  3 YZ  ",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows()
+ endfunc
+ 
+ func Test_number_with_relativenumber()
+   call s:test_windows(10, 20)
+   call setline(1, ["abcdefghij", "klmnopqrst", "uvwxyzABCD", "EFGHIJKLMN", "OPQRSTUVWX", "YZ"])
+   4
+   setl number relativenumber
+   let lines = s:screen_lines(1, 6)
+   let expect = [
+ \ "  3 abcd",
+ \ "  2 klmn",
+ \ "  1 uvwx",
+ \ "4   EFGH",
+ \ "  1 OPQR",
+ \ "  2 YZ  ",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows()
+ endfunc
+ 
+ func Test_number_with_linewrap1()
+   call s:test_windows(3, 20)
+   normal! 61ia
+   setl number wrap
+   call s:validate_cursor()
+   let lines = s:screen_lines(1, 3)
+   let expect = [
+ \ "--1 aaaa",
+ \ "    aaaa",
+ \ "    aaaa",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows()
+ endfunc
+ 
+ " Pending: https://groups.google.com/forum/#!topic/vim_dev/tzNKP7EDWYI
+ func XTest_number_with_linewrap2()
+   call s:test_windows(3, 20)
+   normal! 61ia
+   setl number wrap
+   call s:validate_cursor()
+   0
+   call s:validate_cursor()
+   let lines = s:screen_lines(1, 3)
+   let expect = [
+ \ "  1 aaaa",
+ \ "    aaaa",
+ \ "    aaaa",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows()
+ endfunc
+ 
+ " Pending: https://groups.google.com/forum/#!topic/vim_dev/tzNKP7EDWYI
+ func XTest_number_with_linewrap3()
+   call s:test_windows(4, 20)
+   normal! 81ia
+   setl number wrap
+   call s:validate_cursor()
+   setl nonumber
+   call s:validate_cursor()
+   let lines = s:screen_lines(1, 4)
+   let expect = [
+ \ "aaaaaaaa",
+ \ "aaaaaaaa",
+ \ "aaaaaaaa",
+ \ "a       ",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows()
+ endfunc
+ 
+ func Test_numberwidth()
+   call s:test_windows(10, 20)
+   call setline(1, repeat(['aaaa'], 10))
+   setl number numberwidth=6
+   let lines = s:screen_lines(1, 3)
+   let expect = [
+ \ "    1 aa",
+ \ "    2 aa",
+ \ "    3 aa",
+ \ ]
+   call s:compare_lines(expect, lines)
+ 
+   set relativenumber
+   let lines = s:screen_lines(1, 3)
+   let expect = [
+ \ "1     aa",
+ \ "    1 aa",
+ \ "    2 aa",
+ \ ]
+   call s:compare_lines(expect, lines)
+ 
+   set nonumber
+   let lines = s:screen_lines(1, 3)
+   let expect = [
+ \ "    0 aa",
+ \ "    1 aa",
+ \ "    2 aa",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows()
+ endfunc
+ 
+ func Test_numberwidth_adjusted()
+   call s:test_windows(10, 20)
+   call setline(1, repeat(['aaaa'], 10000))
+   setl number numberwidth=4
+   let lines = s:screen_lines(1, 3)
+   let expect = [
+ \ "    1 aa",
+ \ "    2 aa",
+ \ "    3 aa",
+ \ ]
+   call s:compare_lines(expect, lines)
+ 
+   $
+   let lines = s:screen_lines(8, 10)
+   let expect = [
+ \ " 9998 aa",
+ \ " 9999 aa",
+ \ "10000 aa",
+ \ ]
+   call s:compare_lines(expect, lines)
+ 
+   setl relativenumber
+   let lines = s:screen_lines(8, 10)
+   let expect = [
+ \ "    2 aa",
+ \ "    1 aa",
+ \ "10000 aa",
+ \ ]
+   call s:compare_lines(expect, lines)
+ 
+   setl nonumber
+   let lines = s:screen_lines(8, 10)
+   let expect = [
+ \ "  2 aaaa",
+ \ "  1 aaaa",
+ \ "  0 aaaa",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows()
+ endfunc
*** ../vim-8.0.0358/src/version.c	2017-02-23 18:08:51.328806464 +0100
--- src/version.c	2017-02-23 18:21:46.731804918 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     359,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
11. You find yourself typing "com" after every period when using a word
    processor.com

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0360
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0360
Problem:    Sometimes VimL is used, which is confusing.
Solution:   Consistently use "Vim script". (Hirohito Higashi)
Files:      runtime/doc/if_mzsch.txt, runtime/doc/if_pyth.txt,
            runtime/doc/syntax.txt, runtime/doc/usr_02.txt,
            runtime/doc/version7.txt, src/Makefile, src/eval.c,
            src/ex_getln.c, src/if_py_both.h, src/if_xcmdsrv.c,
            src/testdir/Make_all.mak, src/testdir/runtest.vim,
            src/testdir/test49.vim, src/testdir/test_vimscript.vim,
            src/testdir/test_viml.vim


*** ../vim-8.0.0359/runtime/doc/if_mzsch.txt	2016-09-12 12:45:25.000000000 +0200
--- runtime/doc/if_mzsch.txt	2017-02-23 18:49:31.945088705 +0100
***************
*** 249,255 ****
  5. mzeval() Vim function				    *mzscheme-mzeval*
  
  To facilitate bi-directional interface, you can use |mzeval()| function to
! evaluate MzScheme expressions and pass their values to VimL.
  
  ==============================================================================
  6. Using Function references				    *mzscheme-funcref*
--- 249,255 ----
  5. mzeval() Vim function				    *mzscheme-mzeval*
  
  To facilitate bi-directional interface, you can use |mzeval()| function to
! evaluate MzScheme expressions and pass their values to Vim script.
  
  ==============================================================================
  6. Using Function references				    *mzscheme-funcref*
*** ../vim-8.0.0359/runtime/doc/if_pyth.txt	2017-01-28 15:58:45.336197327 +0100
--- runtime/doc/if_pyth.txt	2017-02-23 18:49:31.945088705 +0100
***************
*** 676,686 ****
                       dictionary. Note that explicit `self` keyword used when 
                       calling resulting object overrides this attribute.
          auto_rebind  Boolean. True if partial created from this Python object 
!                      and stored in the VimL dictionary should be automatically 
!                      rebound to the dictionary it is stored in when this 
!                      dictionary is indexed. Exposes Vim internal difference 
!                      between `dict.func` (auto_rebind=True) and 
!                      `function(dict.func,dict)` (auto_rebind=False). This 
                       attribute makes no sense if `self` attribute is `None`.
  
      Constructor additionally accepts `args`, `self` and `auto_rebind` 
--- 676,686 ----
                       dictionary. Note that explicit `self` keyword used when 
                       calling resulting object overrides this attribute.
          auto_rebind  Boolean. True if partial created from this Python object 
!                      and stored in the Vim script dictionary should be
!                      automatically rebound to the dictionary it is stored in
!                      when this dictionary is indexed. Exposes Vim internal
!                      difference between `dict.func` (auto_rebind=True) and
!                      `function(dict.func,dict)` (auto_rebind=False). This
                       attribute makes no sense if `self` attribute is `None`.
  
      Constructor additionally accepts `args`, `self` and `auto_rebind` 
***************
*** 711,717 ****
  8. pyeval() and py3eval() Vim functions			*python-pyeval*
  
  To facilitate bi-directional interface, you can use |pyeval()| and |py3eval()| 
! functions to evaluate Python expressions and pass their values to VimL.
  |pyxeval()| is also available.
  
  ==============================================================================
--- 711,717 ----
  8. pyeval() and py3eval() Vim functions			*python-pyeval*
  
  To facilitate bi-directional interface, you can use |pyeval()| and |py3eval()| 
! functions to evaluate Python expressions and pass their values to Vim script.
  |pyxeval()| is also available.
  
  ==============================================================================
*** ../vim-8.0.0359/runtime/doc/syntax.txt	2016-09-12 13:39:47.000000000 +0200
--- runtime/doc/syntax.txt	2017-02-23 18:49:31.949088680 +0100
***************
*** 3322,3329 ****
     g:vimsyn_folding =~ 't' : fold tcl      script
  <
  							*g:vimsyn_noerror*
! Not all error highlighting that syntax/vim.vim does may be correct; VimL is a
! difficult language to highlight correctly.  A way to suppress error
  highlighting is to put the following line in your |vimrc|: >
  
  	let g:vimsyn_noerror = 1
--- 3327,3334 ----
     g:vimsyn_folding =~ 't' : fold tcl      script
  <
  							*g:vimsyn_noerror*
! Not all error highlighting that syntax/vim.vim does may be correct; Vim script
! is a difficult language to highlight correctly.  A way to suppress error
  highlighting is to put the following line in your |vimrc|: >
  
  	let g:vimsyn_noerror = 1
*** ../vim-8.0.0359/runtime/doc/usr_02.txt	2016-09-12 12:45:48.000000000 +0200
--- runtime/doc/usr_02.txt	2017-02-23 18:49:31.949088680 +0100
***************
*** 589,595 ****
      register: >
     	:help quote:
  
! 13) Vim Script (VimL) is available at >
  	:help eval.txt
  <   Certain aspects of the language are available at :h expr-X where "X" is a
     single letter. E.g.  >
--- 589,595 ----
      register: >
     	:help quote:
  
! 13) Vim script is available at >
  	:help eval.txt
  <   Certain aspects of the language are available at :h expr-X where "X" is a
     single letter. E.g.  >
***************
*** 599,608 ****
     Also important is >
     	:help function-list
  <   to find a short description of all functions available.  Help topics for
!    VimL functions always include the "()", so: >
     	:help append()
! <   talks about the append VimL function rather than how to append text in the
!    current buffer.
  
  14) Mappings are talked about in the help page :h |map.txt|. Use >
      	:help mapmode-i
--- 599,608 ----
     Also important is >
     	:help function-list
  <   to find a short description of all functions available.  Help topics for
!    Vim script functions always include the "()", so: >
     	:help append()
! <   talks about the append Vim script function rather than how to append text
!    in the current buffer.
  
  14) Mappings are talked about in the help page :h |map.txt|. Use >
      	:help mapmode-i
*** ../vim-8.0.0359/runtime/doc/version7.txt	2016-09-12 12:45:49.000000000 +0200
--- runtime/doc/version7.txt	2017-02-23 18:49:31.949088680 +0100
***************
*** 10202,10208 ****
  interfaces to some extent. Extent will be improved in the future.
  
  Added special |python-vars| objects also available for |python-buffer| and 
! |python-window|. They ease access to VimL variables from Python.
  
  Now you no longer need to alter `sys.path` to import your module: special 
  hooks are responsible for importing from {rtp}/python2, {rtp}/python3 and 
--- 10202,10208 ----
  interfaces to some extent. Extent will be improved in the future.
  
  Added special |python-vars| objects also available for |python-buffer| and 
! |python-window|. They ease access to Vim script variables from Python.
  
  Now you no longer need to alter `sys.path` to import your module: special 
  hooks are responsible for importing from {rtp}/python2, {rtp}/python3 and 
*** ../vim-8.0.0359/src/Makefile	2017-02-23 18:46:24.462288941 +0100
--- src/Makefile	2017-02-23 18:49:31.953088654 +0100
***************
*** 2213,2219 ****
  	test_usercommands \
  	test_utf8 \
  	test_viminfo \
! 	test_viml \
  	test_visual \
  	test_window_cmd \
  	test_window_id \
--- 2213,2219 ----
  	test_usercommands \
  	test_utf8 \
  	test_viminfo \
! 	test_vimscript \
  	test_visual \
  	test_window_cmd \
  	test_window_id \
*** ../vim-8.0.0359/src/eval.c	2017-02-23 14:25:13.210370073 +0100
--- src/eval.c	2017-02-23 18:49:31.953088654 +0100
***************
*** 950,956 ****
  
  
  /*
!  * Call some vimL function and return the result in "*rettv".
   * Uses argv[argc] for the function arguments.  Only Number and String
   * arguments are currently supported.
   * Returns OK or FAIL.
--- 950,956 ----
  
  
  /*
!  * Call some Vim script function and return the result in "*rettv".
   * Uses argv[argc] for the function arguments.  Only Number and String
   * arguments are currently supported.
   * Returns OK or FAIL.
***************
*** 1027,1033 ****
  }
  
  /*
!  * Call vimL function "func" and return the result as a number.
   * Returns -1 when calling the function fails.
   * Uses argv[argc] for the function arguments.
   */
--- 1027,1033 ----
  }
  
  /*
!  * Call Vim script function "func" and return the result as a number.
   * Returns -1 when calling the function fails.
   * Uses argv[argc] for the function arguments.
   */
***************
*** 1055,1061 ****
  
  # if (defined(FEAT_USR_CMDS) && defined(FEAT_CMDL_COMPL)) || defined(PROTO)
  /*
!  * Call vimL function "func" and return the result as a string.
   * Returns NULL when calling the function fails.
   * Uses argv[argc] for the function arguments.
   */
--- 1055,1061 ----
  
  # if (defined(FEAT_USR_CMDS) && defined(FEAT_CMDL_COMPL)) || defined(PROTO)
  /*
!  * Call Vim script function "func" and return the result as a string.
   * Returns NULL when calling the function fails.
   * Uses argv[argc] for the function arguments.
   */
***************
*** 1080,1086 ****
  # endif
  
  /*
!  * Call vimL function "func" and return the result as a List.
   * Uses argv[argc] for the function arguments.
   * Returns NULL when there is something wrong.
   */
--- 1080,1086 ----
  # endif
  
  /*
!  * Call Vim script function "func" and return the result as a List.
   * Uses argv[argc] for the function arguments.
   * Returns NULL when there is something wrong.
   */
*** ../vim-8.0.0359/src/ex_getln.c	2017-02-09 18:25:09.151838714 +0100
--- src/ex_getln.c	2017-02-23 18:49:31.953088654 +0100
***************
*** 5140,5147 ****
  static void * call_user_expand_func(void *(*user_expand_func)(char_u *, int, char_u **, int), expand_T	*xp, int *num_file, char_u ***file);
  
  /*
!  * Call "user_expand_func()" to invoke a user defined VimL function and return
!  * the result (either a string or a List).
   */
      static void *
  call_user_expand_func(
--- 5140,5147 ----
  static void * call_user_expand_func(void *(*user_expand_func)(char_u *, int, char_u **, int), expand_T	*xp, int *num_file, char_u ***file);
  
  /*
!  * Call "user_expand_func()" to invoke a user defined Vim script function and
!  * return the result (either a string or a List).
   */
      static void *
  call_user_expand_func(
*** ../vim-8.0.0359/src/if_py_both.h	2017-01-29 21:30:48.332627641 +0100
--- src/if_py_both.h	2017-02-23 18:49:31.953088654 +0100
***************
*** 582,590 ****
  VimTryEnd(void)
  {
      --trylevel;
!     /* Without this it stops processing all subsequent VimL commands and
!      * generates strange error messages if I e.g. try calling Test() in a
!      * cycle */
      did_emsg = FALSE;
      /* Keyboard interrupt should be preferred over anything else */
      if (got_int)
--- 582,590 ----
  VimTryEnd(void)
  {
      --trylevel;
!     /* Without this it stops processing all subsequent Vim script commands and
!      * generates strange error messages if I e.g. try calling Test() in a cycle
!      */
      did_emsg = FALSE;
      /* Keyboard interrupt should be preferred over anything else */
      if (got_int)
***************
*** 625,631 ****
  	discard_current_exception();
  	return -1;
      }
!     /* Finally transform VimL exception to python one */
      else
      {
  	PyErr_SetVim((char *)current_exception->value);
--- 625,631 ----
  	discard_current_exception();
  	return -1;
      }
!     /* Finally transform Vim script exception to python one */
      else
      {
  	PyErr_SetVim((char *)current_exception->value);
*** ../vim-8.0.0359/src/if_xcmdsrv.c	2016-08-29 22:42:20.000000000 +0200
--- src/if_xcmdsrv.c	2017-02-23 18:49:31.953088654 +0100
***************
*** 1449,1456 ****
  	    char_u	*enc;
  
  	    /*
! 	     * This is a (n)otification.  Sent with serverreply_send in VimL.
! 	     * Execute any autocommand and save it for later retrieval
  	     */
  	    p += 2;
  	    gotWindow = 0;
--- 1449,1456 ----
  	    char_u	*enc;
  
  	    /*
! 	     * This is a (n)otification.  Sent with serverreply_send in Vim
! 	     * script.  Execute any autocommand and save it for later retrieval
  	     */
  	    p += 2;
  	    gotWindow = 0;
*** ../vim-8.0.0359/src/testdir/Make_all.mak	2017-02-23 18:46:24.462288941 +0100
--- src/testdir/Make_all.mak	2017-02-23 18:49:31.953088654 +0100
***************
*** 199,205 ****
  	    test_undo.res \
  	    test_usercommands.res \
  	    test_viminfo.res \
! 	    test_viml.res \
  	    test_visual.res \
  	    test_window_id.res \
  	    test_writefile.res \
--- 199,205 ----
  	    test_undo.res \
  	    test_usercommands.res \
  	    test_viminfo.res \
! 	    test_vimscript.res \
  	    test_visual.res \
  	    test_window_id.res \
  	    test_writefile.res \
*** ../vim-8.0.0359/src/testdir/runtest.vim	2017-02-01 23:17:30.909975952 +0100
--- src/testdir/runtest.vim	2017-02-23 18:49:31.953088654 +0100
***************
*** 147,153 ****
  let s:errors = []
  let s:messages = []
  let s:skipped = []
! if expand('%') =~ 'test_viml.vim'
    " this test has intentional s:errors, don't use try/catch.
    source %
  else
--- 147,153 ----
  let s:errors = []
  let s:messages = []
  let s:skipped = []
! if expand('%') =~ 'test_vimscript.vim'
    " this test has intentional s:errors, don't use try/catch.
    source %
  else
*** ../vim-8.0.0359/src/testdir/test49.vim	2016-02-07 20:24:49.000000000 +0100
--- src/testdir/test49.vim	2017-02-23 18:49:31.957088629 +0100
***************
*** 608,614 ****
  " END_OF_TEST_ENVIRONMENT - do not change or remove this line.
  
  
! " Tests 1 to 15 were moved to test_viml.vim
  let Xtest = 16
  
  "-------------------------------------------------------------------------------
--- 608,614 ----
  " END_OF_TEST_ENVIRONMENT - do not change or remove this line.
  
  
! " Tests 1 to 15 were moved to test_vimscript.vim
  let Xtest = 16
  
  "-------------------------------------------------------------------------------
*** ../vim-8.0.0359/src/testdir/test_vimscript.vim	2017-02-23 18:57:49.325919004 +0100
--- src/testdir/test_vimscript.vim	2017-02-23 18:49:31.957088629 +0100
***************
*** 0 ****
--- 1,1316 ----
+ " Test various aspects of the Vim script language.
+ " Most of this was formerly in test49.
+ 
+ "-------------------------------------------------------------------------------
+ " Test environment							    {{{1
+ "-------------------------------------------------------------------------------
+ 
+ com!               XpathINIT  let g:Xpath = ''
+ com! -nargs=1 -bar Xpath      let g:Xpath = g:Xpath . <args>
+ 
+ " Append a message to the "messages" file
+ func! Xout(text)
+     split messages
+     $put =a:text
+     wq
+ endfunc
+ 
+ com! -nargs=1	     Xout     call Xout(<args>)
+ 
+ " MakeScript() - Make a script file from a function.			    {{{2
+ "
+ " Create a script that consists of the body of the function a:funcname.
+ " Replace any ":return" by a ":finish", any argument variable by a global
+ " variable, and and every ":call" by a ":source" for the next following argument
+ " in the variable argument list.  This function is useful if similar tests are
+ " to be made for a ":return" from a function call or a ":finish" in a script
+ " file.
+ function! MakeScript(funcname, ...)
+     let script = tempname()
+     execute "redir! >" . script
+     execute "function" a:funcname
+     redir END
+     execute "edit" script
+     " Delete the "function" and the "endfunction" lines.  Do not include the
+     " word "function" in the pattern since it might be translated if LANG is
+     " set.  When MakeScript() is being debugged, this deletes also the debugging
+     " output of its line 3 and 4.
+     exec '1,/.*' . a:funcname . '(.*)/d'
+     /^\d*\s*endfunction\>/,$d
+     %s/^\d*//e
+     %s/return/finish/e
+     %s/\<a:\(\h\w*\)/g:\1/ge
+     normal gg0
+     let cnt = 0
+     while search('\<call\s*\%(\u\|s:\)\w*\s*(.*)', 'W') > 0
+ 	let cnt = cnt + 1
+ 	s/\<call\s*\%(\u\|s:\)\w*\s*(.*)/\='source ' . a:{cnt}/
+     endwhile
+     g/^\s*$/d
+     write
+     bwipeout
+     return script
+ endfunction
+ 
+ " ExecAsScript - Source a temporary script made from a function.	    {{{2
+ "
+ " Make a temporary script file from the function a:funcname, ":source" it, and
+ " delete it afterwards.  However, if an exception is thrown the file may remain,
+ " the caller should call DeleteTheScript() afterwards.
+ let s:script_name = ''
+ function! ExecAsScript(funcname)
+     " Make a script from the function passed as argument.
+     let s:script_name = MakeScript(a:funcname)
+ 
+     " Source and delete the script.
+     exec "source" s:script_name
+     call delete(s:script_name)
+     let s:script_name = ''
+ endfunction
+ 
+ function! DeleteTheScript()
+     if s:script_name
+ 	call delete(s:script_name)
+ 	let s:script_name = ''
+     endif
+ endfunc
+ 
+ com! -nargs=1 -bar ExecAsScript call ExecAsScript(<f-args>)
+ 
+ 
+ "-------------------------------------------------------------------------------
+ " Test 1:   :endwhile in function					    {{{1
+ "
+ "	    Detect if a broken loop is (incorrectly) reactivated by the
+ "	    :endwhile.  Use a :return to prevent an endless loop, and make
+ "	    this test first to get a meaningful result on an error before other
+ "	    tests will hang.
+ "-------------------------------------------------------------------------------
+ 
+ function! T1_F()
+     Xpath 'a'
+     let first = 1
+     while 1
+ 	Xpath 'b'
+ 	if first
+ 	    Xpath 'c'
+ 	    let first = 0
+ 	    break
+ 	else
+ 	    Xpath 'd'
+ 	    return
+ 	endif
+     endwhile
+ endfunction
+ 
+ function! T1_G()
+     Xpath 'h'
+     let first = 1
+     while 1
+ 	Xpath 'i'
+ 	if first
+ 	    Xpath 'j'
+ 	    let first = 0
+ 	    break
+ 	else
+ 	    Xpath 'k'
+ 	    return
+ 	endif
+ 	if 1	" unmatched :if
+     endwhile
+ endfunction
+ 
+ func Test_endwhile_function()
+   XpathINIT
+   call T1_F()
+   Xpath 'F'
+ 
+   try
+     call T1_G()
+   catch
+     " Catch missing :endif
+     call assert_true(v:exception =~ 'E171')
+     Xpath 'x'
+   endtry
+   Xpath 'G'
+ 
+   call assert_equal('abcFhijxG', g:Xpath)
+ endfunc
+ 
+ "-------------------------------------------------------------------------------
+ " Test 2:   :endwhile in script						    {{{1
+ "
+ "	    Detect if a broken loop is (incorrectly) reactivated by the
+ "	    :endwhile.  Use a :finish to prevent an endless loop, and place
+ "	    this test before others that might hang to get a meaningful result
+ "	    on an error.
+ "
+ "	    This test executes the bodies of the functions T1_F and T1_G from
+ "	    the previous test as script files (:return replaced by :finish).
+ "-------------------------------------------------------------------------------
+ 
+ func Test_endwhile_script()
+   XpathINIT
+   ExecAsScript T1_F
+   Xpath 'F'
+   call DeleteTheScript()
+ 
+   try
+     ExecAsScript T1_G
+   catch
+     " Catch missing :endif
+     call assert_true(v:exception =~ 'E171')
+     Xpath 'x'
+   endtry
+   Xpath 'G'
+   call DeleteTheScript()
+ 
+   call assert_equal('abcFhijxG', g:Xpath)
+ endfunc
+ 
+ "-------------------------------------------------------------------------------
+ " Test 3:   :if, :elseif, :while, :continue, :break			    {{{1
+ "-------------------------------------------------------------------------------
+ 
+ function Test_if_while()
+     XpathINIT
+     if 1
+ 	Xpath 'a'
+ 	let loops = 3
+ 	while loops > -1	    " main loop: loops == 3, 2, 1 (which breaks)
+ 	    if loops <= 0
+ 		let break_err = 1
+ 		let loops = -1
+ 	    else
+ 		Xpath 'b' . loops
+ 	    endif
+ 	    if (loops == 2)
+ 		while loops == 2 " dummy loop
+ 		    Xpath 'c' . loops
+ 		    let loops = loops - 1
+ 		    continue    " stop dummy loop
+ 		    Xpath 'd' . loops
+ 		endwhile
+ 		continue	    " continue main loop
+ 		Xpath 'e' . loops
+ 	    elseif (loops == 1)
+ 		let p = 1
+ 		while p	    " dummy loop
+ 		    Xpath 'f' . loops
+ 		    let p = 0
+ 		    break	    " break dummy loop
+ 		    Xpath 'g' . loops
+ 		endwhile
+ 		Xpath 'h' . loops
+ 		unlet p
+ 		break	    " break main loop
+ 		Xpath 'i' . loops
+ 	    endif
+ 	    if (loops > 0)
+ 		Xpath 'j' . loops
+ 	    endif
+ 	    while loops == 3    " dummy loop
+ 		let loops = loops - 1
+ 	    endwhile	    " end dummy loop
+ 	endwhile		    " end main loop
+ 	Xpath 'k'
+     else
+ 	Xpath 'l'
+     endif
+     Xpath 'm'
+     if exists("break_err")
+ 	Xpath 'm'
+ 	unlet break_err
+     endif
+ 
+     unlet loops
+ 
+     call assert_equal('ab3j3b2c2b1f1h1km', g:Xpath)
+ endfunc
+ 
+ "-------------------------------------------------------------------------------
+ " Test 4:   :return							    {{{1
+ "-------------------------------------------------------------------------------
+ 
+ function! T4_F()
+     if 1
+ 	Xpath 'a'
+ 	let loops = 3
+ 	while loops > 0				"    3:  2:     1:
+ 	    Xpath 'b' . loops
+ 	    if (loops == 2)
+ 		Xpath 'c' . loops
+ 		return
+ 		Xpath 'd' . loops
+ 	    endif
+ 	    Xpath 'e' . loops
+ 	    let loops = loops - 1
+ 	endwhile
+ 	Xpath 'f'
+     else
+ 	Xpath 'g'
+     endif
+ endfunction
+ 
+ function Test_return()
+     XpathINIT
+     call T4_F()
+     Xpath '4'
+ 
+     call assert_equal('ab3e3b2c24', g:Xpath)
+ endfunction
+ 
+ 
+ "-------------------------------------------------------------------------------
+ " Test 5:   :finish							    {{{1
+ "
+ "	    This test executes the body of the function T4_F from the previous
+ "	    test as a script file (:return replaced by :finish).
+ "-------------------------------------------------------------------------------
+ 
+ function Test_finish()
+     XpathINIT
+     ExecAsScript T4_F
+     Xpath '5'
+     call DeleteTheScript()
+ 
+     call assert_equal('ab3e3b2c25', g:Xpath)
+ endfunction
+ 
+ 
+ 
+ "-------------------------------------------------------------------------------
+ " Test 6:   Defining functions in :while loops				    {{{1
+ "
+ "	     Functions can be defined inside other functions.  An inner function
+ "	     gets defined when the outer function is executed.  Functions may
+ "	     also be defined inside while loops.  Expressions in braces for
+ "	     defining the function name are allowed.
+ "
+ "	     The functions are defined when sourcing the script, only the
+ "	     resulting path is checked in the test function.
+ "-------------------------------------------------------------------------------
+ 
+ XpathINIT
+ 
+ " The command CALL collects the argument of all its invocations in "calls"
+ " when used from a function (that is, when the global variable "calls" needs
+ " the "g:" prefix).  This is to check that the function code is skipped when
+ " the function is defined.  For inner functions, do so only if the outer
+ " function is not being executed.
+ "
+ let calls = ""
+ com! -nargs=1 CALL
+     	\ if !exists("calls") && !exists("outer") |
+     	\ let g:calls = g:calls . <args> |
+     	\ endif
+ 
+ let i = 0
+ while i < 3
+     let i = i + 1
+     if i == 1
+ 	Xpath 'a'
+ 	function! F1(arg)
+ 	    CALL a:arg
+ 	    let outer = 1
+ 
+ 	    let j = 0
+ 	    while j < 1
+ 		Xpath 'b'
+ 		let j = j + 1
+ 		function! G1(arg)
+ 		    CALL a:arg
+ 		endfunction
+ 		Xpath 'c'
+ 	    endwhile
+ 	endfunction
+ 	Xpath 'd'
+ 
+ 	continue
+     endif
+ 
+     Xpath 'e' . i
+     function! F{i}(i, arg)
+ 	CALL a:arg
+ 	let outer = 1
+ 
+ 	if a:i == 3
+ 	    Xpath 'f'
+ 	endif
+ 	let k = 0
+ 	while k < 3
+ 	    Xpath 'g' . k
+ 	    let k = k + 1
+ 	    function! G{a:i}{k}(arg)
+ 		CALL a:arg
+ 	    endfunction
+ 	    Xpath 'h' . k
+ 	endwhile
+     endfunction
+     Xpath 'i'
+ 
+ endwhile
+ 
+ if exists("*G1")
+     Xpath 'j'
+ endif
+ if exists("*F1")
+     call F1("F1")
+     if exists("*G1")
+         call G1("G1")
+     endif
+ endif
+ 
+ if exists("G21") || exists("G22") || exists("G23")
+     Xpath 'k'
+ endif
+ if exists("*F2")
+     call F2(2, "F2")
+     if exists("*G21")
+         call G21("G21")
+     endif
+     if exists("*G22")
+         call G22("G22")
+     endif
+     if exists("*G23")
+         call G23("G23")
+     endif
+ endif
+ 
+ if exists("G31") || exists("G32") || exists("G33")
+     Xpath 'l'
+ endif
+ if exists("*F3")
+     call F3(3, "F3")
+     if exists("*G31")
+         call G31("G31")
+     endif
+     if exists("*G32")
+         call G32("G32")
+     endif
+     if exists("*G33")
+         call G33("G33")
+     endif
+ endif
+ 
+ Xpath 'm'
+ 
+ let g:test6_result = g:Xpath
+ let g:test6_calls = calls
+ 
+ unlet calls
+ delfunction F1
+ delfunction G1
+ delfunction F2
+ delfunction G21
+ delfunction G22
+ delfunction G23
+ delfunction G31
+ delfunction G32
+ delfunction G33
+ 
+ function Test_defining_functions()
+     call assert_equal('ade2ie3ibcg0h1g1h2g2h3fg0h1g1h2g2h3m', g:test6_result)
+     call assert_equal('F1G1F2G21G22G23F3G31G32G33', g:test6_calls)
+ endfunc
+ 
+ "-------------------------------------------------------------------------------
+ " Test 7:   Continuing on errors outside functions			    {{{1
+ "
+ "	    On an error outside a function, the script processing continues
+ "	    at the line following the outermost :endif or :endwhile.  When not
+ "	    inside an :if or :while, the script processing continues at the next
+ "	    line.
+ "-------------------------------------------------------------------------------
+ 
+ XpathINIT
+ 
+ if 1
+     Xpath 'a'
+     while 1
+ 	Xpath 'b'
+ 	asdf
+ 	Xpath 'c'
+ 	break
+     endwhile | Xpath 'd'
+     Xpath 'e'
+ endif | Xpath 'f'
+ Xpath 'g'
+ 
+ while 1
+     Xpath 'h'
+     if 1
+ 	Xpath 'i'
+ 	asdf
+ 	Xpath 'j'
+     endif | Xpath 'k'
+     Xpath 'l'
+     break
+ endwhile | Xpath 'm'
+ Xpath 'n'
+ 
+ asdf
+ Xpath 'o'
+ 
+ asdf | Xpath 'p'
+ Xpath 'q'
+ 
+ let g:test7_result = g:Xpath
+ 
+ func Test_error_in_script()
+     call assert_equal('abghinoq', g:test7_result)
+ endfunc
+ 
+ "-------------------------------------------------------------------------------
+ " Test 8:   Aborting and continuing on errors inside functions		    {{{1
+ "
+ "	    On an error inside a function without the "abort" attribute, the
+ "	    script processing continues at the next line (unless the error was
+ "	    in a :return command).  On an error inside a function with the
+ "	    "abort" attribute, the function is aborted and the script processing
+ "	    continues after the function call; the value -1 is returned then.
+ "-------------------------------------------------------------------------------
+ 
+ XpathINIT
+ 
+ function! T8_F()
+     if 1
+ 	Xpath 'a'
+ 	while 1
+ 	    Xpath 'b'
+ 	    asdf
+ 	    Xpath 'c'
+ 	    asdf | Xpath 'd'
+ 	    Xpath 'e'
+ 	    break
+ 	endwhile
+ 	Xpath 'f'
+     endif | Xpath 'g'
+     Xpath 'h'
+ 
+     while 1
+ 	Xpath 'i'
+ 	if 1
+ 	    Xpath 'j'
+ 	    asdf
+ 	    Xpath 'k'
+ 	    asdf | Xpath 'l'
+ 	    Xpath 'm'
+ 	endif
+ 	Xpath 'n'
+ 	break
+     endwhile | Xpath 'o'
+     Xpath 'p'
+ 
+     return novar		" returns (default return value 0)
+     Xpath 'q'
+     return 1			" not reached
+ endfunction
+ 
+ function! T8_G() abort
+     if 1
+ 	Xpath 'r'
+ 	while 1
+ 	    Xpath 's'
+ 	    asdf		" returns -1
+ 	    Xpath 't'
+ 	    break
+ 	endwhile
+ 	Xpath 'v'
+     endif | Xpath 'w'
+     Xpath 'x'
+ 
+     return -4			" not reached
+ endfunction
+ 
+ function! T8_H() abort
+     while 1
+ 	Xpath 'A'
+ 	if 1
+ 	    Xpath 'B'
+ 	    asdf		" returns -1
+ 	    Xpath 'C'
+ 	endif
+ 	Xpath 'D'
+ 	break
+     endwhile | Xpath 'E'
+     Xpath 'F'
+ 
+     return -4			" not reached
+ endfunction
+ 
+ " Aborted functions (T8_G and T8_H) return -1.
+ let g:test8_sum = (T8_F() + 1) - 4 * T8_G() - 8 * T8_H()
+ Xpath 'X'
+ let g:test8_result = g:Xpath
+ 
+ func Test_error_in_function()
+     call assert_equal(13, g:test8_sum)
+     call assert_equal('abcefghijkmnoprsABX', g:test8_result)
+ 
+     delfunction T8_F
+     delfunction T8_G
+     delfunction T8_H
+ endfunc
+ 
+ 
+ "-------------------------------------------------------------------------------
+ " Test 9:   Continuing after aborted functions				    {{{1
+ "
+ "	    When a function with the "abort" attribute is aborted due to an
+ "	    error, the next function back in the call hierarchy without an
+ "	    "abort" attribute continues; the value -1 is returned then.
+ "-------------------------------------------------------------------------------
+ 
+ XpathINIT
+ 
+ function! F() abort
+     Xpath 'a'
+     let result = G()	" not aborted
+     Xpath 'b'
+     if result != 2
+ 	Xpath 'c'
+     endif
+     return 1
+ endfunction
+ 
+ function! G()		" no abort attribute
+     Xpath 'd'
+     if H() != -1	" aborted
+ 	Xpath 'e'
+     endif
+     Xpath 'f'
+     return 2
+ endfunction
+ 
+ function! H() abort
+     Xpath 'g'
+     call I()		" aborted
+     Xpath 'h'
+     return 4
+ endfunction
+ 
+ function! I() abort
+     Xpath 'i'
+     asdf		" error
+     Xpath 'j'
+     return 8
+ endfunction
+ 
+ if F() != 1
+     Xpath 'k'
+ endif
+ 
+ let g:test9_result = g:Xpath
+ 
+ delfunction F
+ delfunction G
+ delfunction H
+ delfunction I
+ 
+ func Test_func_abort()
+     call assert_equal('adgifb', g:test9_result)
+ endfunc
+ 
+ 
+ "-------------------------------------------------------------------------------
+ " Test 10:  :if, :elseif, :while argument parsing			    {{{1
+ "
+ "	    A '"' or '|' in an argument expression must not be mixed up with
+ "	    a comment or a next command after a bar.  Parsing errors should
+ "	    be recognized.
+ "-------------------------------------------------------------------------------
+ 
+ XpathINIT
+ 
+ function! MSG(enr, emsg)
+     let english = v:lang == "C" || v:lang =~ '^[Ee]n'
+     if a:enr == ""
+ 	Xout "TODO: Add message number for:" a:emsg
+ 	let v:errmsg = ":" . v:errmsg
+     endif
+     let match = 1
+     if v:errmsg !~ '^'.a:enr.':' || (english && v:errmsg !~ a:emsg)
+ 	let match = 0
+ 	if v:errmsg == ""
+ 	    Xout "Message missing."
+ 	else
+ 	    let v:errmsg = escape(v:errmsg, '"')
+ 	    Xout "Unexpected message:" v:errmsg
+ 	endif
+     endif
+     return match
+ endfunction
+ 
+ if 1 || strlen("\"") | Xpath 'a'
+     Xpath 'b'
+ endif
+ Xpath 'c'
+ 
+ if 0
+ elseif 1 || strlen("\"") | Xpath 'd'
+     Xpath 'e'
+ endif
+ Xpath 'f'
+ 
+ while 1 || strlen("\"") | Xpath 'g'
+     Xpath 'h'
+     break
+ endwhile
+ Xpath 'i'
+ 
+ let v:errmsg = ""
+ if 1 ||| strlen("\"") | Xpath 'j'
+     Xpath 'k'
+ endif
+ Xpath 'l'
+ if !MSG('E15', "Invalid expression")
+     Xpath 'm'
+ endif
+ 
+ let v:errmsg = ""
+ if 0
+ elseif 1 ||| strlen("\"") | Xpath 'n'
+     Xpath 'o'
+ endif
+ Xpath 'p'
+ if !MSG('E15', "Invalid expression")
+     Xpath 'q'
+ endif
+ 
+ let v:errmsg = ""
+ while 1 ||| strlen("\"") | Xpath 'r'
+     Xpath 's'
+     break
+ endwhile
+ Xpath 't'
+ if !MSG('E15', "Invalid expression")
+     Xpath 'u'
+ endif
+ 
+ let g:test10_result = g:Xpath
+ delfunction MSG
+ 
+ func Test_expr_parsing()
+     call assert_equal('abcdefghilpt', g:test10_result)
+ endfunc
+ 
+ 
+ "-------------------------------------------------------------------------------
+ " Test 11:  :if, :elseif, :while argument evaluation after abort	    {{{1
+ "
+ "	    When code is skipped over due to an error, the boolean argument to
+ "	    an :if, :elseif, or :while must not be evaluated.
+ "-------------------------------------------------------------------------------
+ 
+ XpathINIT
+ 
+ let calls = 0
+ 
+ function! P(num)
+     let g:calls = g:calls + a:num   " side effect on call
+     return 0
+ endfunction
+ 
+ if 1
+     Xpath 'a'
+     asdf		" error
+     Xpath 'b'
+     if P(1)		" should not be called
+ 	Xpath 'c'
+     elseif !P(2)	" should not be called
+ 	Xpath 'd'
+     else
+ 	Xpath 'e'
+     endif
+     Xpath 'f'
+     while P(4)		" should not be called
+ 	Xpath 'g'
+     endwhile
+     Xpath 'h'
+ endif
+ Xpath 'x'
+ 
+ let g:test11_calls = calls
+ let g:test11_result = g:Xpath
+ 
+ unlet calls
+ delfunction P
+ 
+ func Test_arg_abort()
+     call assert_equal(0, g:test11_calls)
+     call assert_equal('ax', g:test11_result)
+ endfunc
+ 
+ 
+ "-------------------------------------------------------------------------------
+ " Test 12:  Expressions in braces in skipped code			    {{{1
+ "
+ "	    In code skipped over due to an error or inactive conditional,
+ "	    an expression in braces as part of a variable or function name
+ "	    should not be evaluated.
+ "-------------------------------------------------------------------------------
+ 
+ XpathINIT
+ 
+ function! NULL()
+     Xpath 'a'
+     return 0
+ endfunction
+ 
+ function! ZERO()
+     Xpath 'b'
+     return 0
+ endfunction
+ 
+ function! F0()
+     Xpath 'c'
+ endfunction
+ 
+ function! F1(arg)
+     Xpath 'e'
+ endfunction
+ 
+ let V0 = 1
+ 
+ Xpath 'f'
+ echo 0 ? F{NULL() + V{ZERO()}}() : 1
+ 
+ Xpath 'g'
+ if 0
+     Xpath 'h'
+     call F{NULL() + V{ZERO()}}()
+ endif
+ 
+ Xpath 'i'
+ if 1
+     asdf		" error
+     Xpath 'j'
+     call F1(F{NULL() + V{ZERO()}}())
+ endif
+ 
+ Xpath 'k'
+ if 1
+     asdf		" error
+     Xpath 'l'
+     call F{NULL() + V{ZERO()}}()
+ endif
+ 
+ let g:test12_result = g:Xpath
+ 
+ func Test_braces_skipped()
+     call assert_equal('fgik', g:test12_result)
+ endfunc
+ 
+ 
+ "-------------------------------------------------------------------------------
+ " Test 13:  Failure in argument evaluation for :while			    {{{1
+ "
+ "	    A failure in the expression evaluation for the condition of a :while
+ "	    causes the whole :while loop until the matching :endwhile being
+ "	    ignored.  Continuation is at the next following line.
+ "-------------------------------------------------------------------------------
+ 
+ XpathINIT
+ 
+ Xpath 'a'
+ while asdf
+     Xpath 'b'
+     while 1
+ 	Xpath 'c'
+ 	break
+     endwhile
+     Xpath 'd'
+     break
+ endwhile
+ Xpath 'e'
+ 
+ while asdf | Xpath 'f' | endwhile | Xpath 'g'
+ Xpath 'h'
+ let g:test13_result = g:Xpath
+ 
+ func Test_while_fail()
+     call assert_equal('aeh', g:test13_result)
+ endfunc
+ 
+ 
+ "-------------------------------------------------------------------------------
+ " Test 14:  Failure in argument evaluation for :if			    {{{1
+ "
+ "	    A failure in the expression evaluation for the condition of an :if
+ "	    does not cause the corresponding :else or :endif being matched to
+ "	    a previous :if/:elseif.  Neither of both branches of the failed :if
+ "	    are executed.
+ "-------------------------------------------------------------------------------
+ 
+ XpathINIT
+ 
+ function! F()
+     Xpath 'a'
+     let x = 0
+     if x		" false
+ 	Xpath 'b'
+     elseif !x		" always true
+ 	Xpath 'c'
+ 	let x = 1
+ 	if g:boolvar	" possibly undefined
+ 	    Xpath 'd'
+ 	else
+ 	    Xpath 'e'
+ 	endif
+ 	Xpath 'f'
+     elseif x		" never executed
+ 	Xpath 'g'
+     endif
+     Xpath 'h'
+ endfunction
+ 
+ let boolvar = 1
+ call F()
+ Xpath '-'
+ 
+ unlet boolvar
+ call F()
+ let g:test14_result = g:Xpath
+ 
+ delfunction F
+ 
+ func Test_if_fail()
+     call assert_equal('acdfh-acfh', g:test14_result)
+ endfunc
+ 
+ 
+ "-------------------------------------------------------------------------------
+ " Test 15:  Failure in argument evaluation for :if (bar)		    {{{1
+ "
+ "	    Like previous test, except that the failing :if ... | ... | :endif
+ "	    is in a single line.
+ "-------------------------------------------------------------------------------
+ 
+ XpathINIT
+ 
+ function! F()
+     Xpath 'a'
+     let x = 0
+     if x		" false
+ 	Xpath 'b'
+     elseif !x		" always true
+ 	Xpath 'c'
+ 	let x = 1
+ 	if g:boolvar | Xpath 'd' | else | Xpath 'e' | endif
+ 	Xpath 'f'
+     elseif x		" never executed
+ 	Xpath 'g'
+     endif
+     Xpath 'h'
+ endfunction
+ 
+ let boolvar = 1
+ call F()
+ Xpath '-'
+ 
+ unlet boolvar
+ call F()
+ let g:test15_result = g:Xpath
+ 
+ delfunction F
+ 
+ func Test_if_bar_fail()
+     call assert_equal('acdfh-acfh', g:test15_result)
+ endfunc
+ 
+ "-------------------------------------------------------------------------------
+ " Test 90:  Recognizing {} in variable name.			    {{{1
+ "-------------------------------------------------------------------------------
+ 
+ func Test_curlies()
+     let s:var = 66
+     let ns = 's'
+     call assert_equal(66, {ns}:var)
+ 
+     let g:a = {}
+     let g:b = 't'
+     let g:a[g:b] = 77
+     call assert_equal(77, g:a['t'])
+ endfunc
+ 
+ "-------------------------------------------------------------------------------
+ " Test 91:  using type().					    {{{1
+ "-------------------------------------------------------------------------------
+ 
+ func Test_type()
+     call assert_equal(0, type(0))
+     call assert_equal(1, type(""))
+     call assert_equal(2, type(function("tr")))
+     call assert_equal(2, type(function("tr", [8])))
+     call assert_equal(3, type([]))
+     call assert_equal(4, type({}))
+     call assert_equal(5, type(0.0))
+     call assert_equal(6, type(v:false))
+     call assert_equal(6, type(v:true))
+     call assert_equal(7, type(v:none))
+     call assert_equal(7, type(v:null))
+     call assert_equal(8, v:t_job)
+     call assert_equal(9, v:t_channel)
+     call assert_equal(v:t_number, type(0))
+     call assert_equal(v:t_string, type(""))
+     call assert_equal(v:t_func, type(function("tr")))
+     call assert_equal(v:t_func, type(function("tr", [8])))
+     call assert_equal(v:t_list, type([]))
+     call assert_equal(v:t_dict, type({}))
+     call assert_equal(v:t_float, type(0.0))
+     call assert_equal(v:t_bool, type(v:false))
+     call assert_equal(v:t_bool, type(v:true))
+     call assert_equal(v:t_none, type(v:none))
+     call assert_equal(v:t_none, type(v:null))
+ 
+ 
+     call assert_equal(0, 0 + v:false)
+     call assert_equal(1, 0 + v:true)
+     call assert_equal(0, 0 + v:none)
+     call assert_equal(0, 0 + v:null)
+ 
+     call assert_equal('v:false', '' . v:false)
+     call assert_equal('v:true', '' . v:true)
+     call assert_equal('v:none', '' . v:none)
+     call assert_equal('v:null', '' . v:null)
+ 
+     call assert_true(v:false == 0)
+     call assert_false(v:false != 0)
+     call assert_true(v:true == 1)
+     call assert_false(v:true != 1)
+     call assert_false(v:true == v:false)
+     call assert_true(v:true != v:false)
+ 
+     call assert_true(v:null == 0)
+     call assert_false(v:null != 0)
+     call assert_true(v:none == 0)
+     call assert_false(v:none != 0)
+ 
+     call assert_true(v:false is v:false)
+     call assert_true(v:true is v:true)
+     call assert_true(v:none is v:none)
+     call assert_true(v:null is v:null)
+ 
+     call assert_false(v:false isnot v:false)
+     call assert_false(v:true isnot v:true)
+     call assert_false(v:none isnot v:none)
+     call assert_false(v:null isnot v:null)
+ 
+     call assert_false(v:false is 0)
+     call assert_false(v:true is 1)
+     call assert_false(v:true is v:false)
+     call assert_false(v:none is 0)
+     call assert_false(v:null is 0)
+     call assert_false(v:null is v:none)
+ 
+     call assert_true(v:false isnot 0)
+     call assert_true(v:true isnot 1)
+     call assert_true(v:true isnot v:false)
+     call assert_true(v:none isnot 0)
+     call assert_true(v:null isnot 0)
+     call assert_true(v:null isnot v:none)
+ 
+     call assert_equal(v:false, eval(string(v:false)))
+     call assert_equal(v:true, eval(string(v:true)))
+     call assert_equal(v:none, eval(string(v:none)))
+     call assert_equal(v:null, eval(string(v:null)))
+ 
+     call assert_equal(v:false, copy(v:false))
+     call assert_equal(v:true, copy(v:true))
+     call assert_equal(v:none, copy(v:none))
+     call assert_equal(v:null, copy(v:null))
+ 
+     call assert_equal([v:false], deepcopy([v:false]))
+     call assert_equal([v:true], deepcopy([v:true]))
+     call assert_equal([v:none], deepcopy([v:none]))
+     call assert_equal([v:null], deepcopy([v:null]))
+ 
+     call assert_true(empty(v:false))
+     call assert_false(empty(v:true))
+     call assert_true(empty(v:null))
+     call assert_true(empty(v:none))
+ 
+     func ChangeYourMind()
+       try
+ 	return v:true
+       finally
+         return 'something else'
+       endtry
+     endfunc
+ 
+     call ChangeYourMind()
+ endfunc
+ 
+ "-------------------------------------------------------------------------------
+ " Test 92:  skipping code					    {{{1
+ "-------------------------------------------------------------------------------
+ 
+ func Test_skip()
+     let Fn = function('Test_type')
+     call assert_false(0 && Fn[1])
+     call assert_false(0 && string(Fn))
+     call assert_false(0 && len(Fn))
+     let l = []
+     call assert_false(0 && l[1])
+     call assert_false(0 && string(l))
+     call assert_false(0 && len(l))
+     let f = 1.0
+     call assert_false(0 && f[1])
+     call assert_false(0 && string(f))
+     call assert_false(0 && len(f))
+     let sp = v:null
+     call assert_false(0 && sp[1])
+     call assert_false(0 && string(sp))
+     call assert_false(0 && len(sp))
+ 
+ endfunc
+ 
+ "-------------------------------------------------------------------------------
+ " Test 93:  :echo and string()					    {{{1
+ "-------------------------------------------------------------------------------
+ 
+ func Test_echo_and_string()
+     " String
+     let a = 'foo bar'
+     redir => result
+     echo a
+     echo string(a)
+     redir END
+     let l = split(result, "\n")
+     call assert_equal(["foo bar",
+ 		     \ "'foo bar'"], l)
+ 
+     " Float
+     if has('float')
+ 	let a = -1.2e0
+ 	redir => result
+ 	echo a
+ 	echo string(a)
+ 	redir END
+ 	let l = split(result, "\n")
+ 	call assert_equal(["-1.2",
+ 			 \ "-1.2"], l)
+     endif
+ 
+     " Funcref
+     redir => result
+     echo function('string')
+     echo string(function('string'))
+     redir END
+     let l = split(result, "\n")
+     call assert_equal(["string",
+ 		     \ "function('string')"], l)
+ 
+     " Recursive dictionary
+     let a = {}
+     let a["a"] = a
+     redir => result
+     echo a
+     echo string(a)
+     redir END
+     let l = split(result, "\n")
+     call assert_equal(["{'a': {...}}",
+ 		     \ "{'a': {...}}"], l)
+ 
+     " Recursive list
+     let a = [0]
+     let a[0] = a
+     redir => result
+     echo a
+     echo string(a)
+     redir END
+     let l = split(result, "\n")
+     call assert_equal(["[[...]]",
+ 		     \ "[[...]]"], l)
+ 
+     " Empty dictionaries in a list
+     let a = {}
+     redir => result
+     echo [a, a, a]
+     echo string([a, a, a])
+     redir END
+     let l = split(result, "\n")
+     call assert_equal(["[{}, {}, {}]",
+ 		     \ "[{}, {}, {}]"], l)
+ 
+     " Empty dictionaries in a dictionary
+     let a = {}
+     let b = {"a": a, "b": a}
+     redir => result
+     echo b
+     echo string(b)
+     redir END
+     let l = split(result, "\n")
+     call assert_equal(["{'a': {}, 'b': {}}",
+ 		     \ "{'a': {}, 'b': {}}"], l)
+ 
+     " Empty lists in a list
+     let a = []
+     redir => result
+     echo [a, a, a]
+     echo string([a, a, a])
+     redir END
+     let l = split(result, "\n")
+     call assert_equal(["[[], [], []]",
+ 		     \ "[[], [], []]"], l)
+ 
+     " Empty lists in a dictionary
+     let a = []
+     let b = {"a": a, "b": a}
+     redir => result
+     echo b
+     echo string(b)
+     redir END
+     let l = split(result, "\n")
+     call assert_equal(["{'a': [], 'b': []}",
+ 		     \ "{'a': [], 'b': []}"], l)
+ 
+     " Dictionaries in a list
+     let a = {"one": "yes", "two": "yes", "three": "yes"}
+     redir => result
+     echo [a, a, a]
+     echo string([a, a, a])
+     redir END
+     let l = split(result, "\n")
+     call assert_equal(["[{'one': 'yes', 'two': 'yes', 'three': 'yes'}, {...}, {...}]",
+ 		     \ "[{'one': 'yes', 'two': 'yes', 'three': 'yes'}, {'one': 'yes', 'two': 'yes', 'three': 'yes'}, {'one': 'yes', 'two': 'yes', 'three': 'yes'}]"], l)
+ 
+     " Dictionaries in a dictionary
+     let a = {"one": "yes", "two": "yes", "three": "yes"}
+     let b = {"a": a, "b": a}
+     redir => result
+     echo b
+     echo string(b)
+     redir END
+     let l = split(result, "\n")
+     call assert_equal(["{'a': {'one': 'yes', 'two': 'yes', 'three': 'yes'}, 'b': {...}}",
+ 		     \ "{'a': {'one': 'yes', 'two': 'yes', 'three': 'yes'}, 'b': {'one': 'yes', 'two': 'yes', 'three': 'yes'}}"], l)
+ 
+     " Lists in a list
+     let a = [1, 2, 3]
+     redir => result
+     echo [a, a, a]
+     echo string([a, a, a])
+     redir END
+     let l = split(result, "\n")
+     call assert_equal(["[[1, 2, 3], [...], [...]]",
+ 		     \ "[[1, 2, 3], [1, 2, 3], [1, 2, 3]]"], l)
+ 
+     " Lists in a dictionary
+     let a = [1, 2, 3]
+     let b = {"a": a, "b": a}
+     redir => result
+     echo b
+     echo string(b)
+     redir END
+     let l = split(result, "\n")
+     call assert_equal(["{'a': [1, 2, 3], 'b': [...]}",
+ 		     \ "{'a': [1, 2, 3], 'b': [1, 2, 3]}"], l)
+ 
+ endfunc
+ 
+ "-------------------------------------------------------------------------------
+ " Test 94:  64-bit Numbers					    {{{1
+ "-------------------------------------------------------------------------------
+ 
+ func Test_num64()
+     if !has('num64')
+ 	return
+     endif
+ 
+     call assert_notequal( 4294967296, 0)
+     call assert_notequal(-4294967296, 0)
+     call assert_equal( 4294967296,  0xFFFFffff + 1)
+     call assert_equal(-4294967296, -0xFFFFffff - 1)
+ 
+     call assert_equal( 9223372036854775807,  1 / 0)
+     call assert_equal(-9223372036854775807, -1 / 0)
+     call assert_equal(-9223372036854775807 - 1,  0 / 0)
+ 
+     call assert_equal( 0x7FFFffffFFFFffff, float2nr( 1.0e150))
+     call assert_equal(-0x7FFFffffFFFFffff, float2nr(-1.0e150))
+ 
+     let rng = range(0xFFFFffff, 0x100000001)
+     call assert_equal([0xFFFFffff, 0x100000000, 0x100000001], rng)
+     call assert_equal(0x100000001, max(rng))
+     call assert_equal(0xFFFFffff, min(rng))
+     call assert_equal(rng, sort(range(0x100000001, 0xFFFFffff, -1), 'N'))
+ endfunc
+ 
+ "-------------------------------------------------------------------------------
+ " Test 95:  lines of :append, :change, :insert			    {{{1
+ "-------------------------------------------------------------------------------
+ 
+ function! DefineFunction(name, body)
+     let func = join(['function! ' . a:name . '()'] + a:body + ['endfunction'], "\n")
+     exec func
+ endfunction
+ 
+ func Test_script_lines()
+     " :append
+     try
+         call DefineFunction('T_Append', [
+                     \ 'append',
+                     \ 'py <<EOS',
+                     \ '.',
+                     \ ])
+     catch
+         call assert_false(1, "Can't define function")
+     endtry
+     try
+         call DefineFunction('T_Append', [
+                     \ 'append',
+                     \ 'abc',
+                     \ ])
+         call assert_false(1, "Shouldn't be able to define function")
+     catch
+         call assert_exception('Vim(function):E126: Missing :endfunction')
+     endtry
+ 
+     " :change
+     try
+         call DefineFunction('T_Change', [
+                     \ 'change',
+                     \ 'py <<EOS',
+                     \ '.',
+                     \ ])
+     catch
+         call assert_false(1, "Can't define function")
+     endtry
+     try
+         call DefineFunction('T_Change', [
+                     \ 'change',
+                     \ 'abc',
+                     \ ])
+         call assert_false(1, "Shouldn't be able to define function")
+     catch
+         call assert_exception('Vim(function):E126: Missing :endfunction')
+     endtry
+ 
+     " :insert
+     try
+         call DefineFunction('T_Insert', [
+                     \ 'insert',
+                     \ 'py <<EOS',
+                     \ '.',
+                     \ ])
+     catch
+         call assert_false(1, "Can't define function")
+     endtry
+     try
+         call DefineFunction('T_Insert', [
+                     \ 'insert',
+                     \ 'abc',
+                     \ ])
+         call assert_false(1, "Shouldn't be able to define function")
+     catch
+         call assert_exception('Vim(function):E126: Missing :endfunction')
+     endtry
+ endfunc
+ 
+ "-------------------------------------------------------------------------------
+ " Modelines								    {{{1
+ " vim: ts=8 sw=4 tw=80 fdm=marker
+ " vim: fdt=substitute(substitute(foldtext(),\ '\\%(^+--\\)\\@<=\\(\\s*\\)\\(.\\{-}\\)\:\ \\%(\"\ \\)\\=\\(Test\ \\d*\\)\:\\s*',\ '\\3\ (\\2)\:\ \\1',\ \"\"),\ '\\(Test\\s*\\)\\(\\d\\)\\D\\@=',\ '\\1\ \\2',\ "")
+ "-------------------------------------------------------------------------------
*** ../vim-8.0.0359/src/testdir/test_viml.vim	2017-01-22 18:34:53.684030783 +0100
--- src/testdir/test_viml.vim	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,1316 ****
- " Test various aspects of the Vim language.
- " Most of this was formerly in test49.
- 
- "-------------------------------------------------------------------------------
- " Test environment							    {{{1
- "-------------------------------------------------------------------------------
- 
- com!               XpathINIT  let g:Xpath = ''
- com! -nargs=1 -bar Xpath      let g:Xpath = g:Xpath . <args>
- 
- " Append a message to the "messages" file
- func! Xout(text)
-     split messages
-     $put =a:text
-     wq
- endfunc
- 
- com! -nargs=1	     Xout     call Xout(<args>)
- 
- " MakeScript() - Make a script file from a function.			    {{{2
- "
- " Create a script that consists of the body of the function a:funcname.
- " Replace any ":return" by a ":finish", any argument variable by a global
- " variable, and and every ":call" by a ":source" for the next following argument
- " in the variable argument list.  This function is useful if similar tests are
- " to be made for a ":return" from a function call or a ":finish" in a script
- " file.
- function! MakeScript(funcname, ...)
-     let script = tempname()
-     execute "redir! >" . script
-     execute "function" a:funcname
-     redir END
-     execute "edit" script
-     " Delete the "function" and the "endfunction" lines.  Do not include the
-     " word "function" in the pattern since it might be translated if LANG is
-     " set.  When MakeScript() is being debugged, this deletes also the debugging
-     " output of its line 3 and 4.
-     exec '1,/.*' . a:funcname . '(.*)/d'
-     /^\d*\s*endfunction\>/,$d
-     %s/^\d*//e
-     %s/return/finish/e
-     %s/\<a:\(\h\w*\)/g:\1/ge
-     normal gg0
-     let cnt = 0
-     while search('\<call\s*\%(\u\|s:\)\w*\s*(.*)', 'W') > 0
- 	let cnt = cnt + 1
- 	s/\<call\s*\%(\u\|s:\)\w*\s*(.*)/\='source ' . a:{cnt}/
-     endwhile
-     g/^\s*$/d
-     write
-     bwipeout
-     return script
- endfunction
- 
- " ExecAsScript - Source a temporary script made from a function.	    {{{2
- "
- " Make a temporary script file from the function a:funcname, ":source" it, and
- " delete it afterwards.  However, if an exception is thrown the file may remain,
- " the caller should call DeleteTheScript() afterwards.
- let s:script_name = ''
- function! ExecAsScript(funcname)
-     " Make a script from the function passed as argument.
-     let s:script_name = MakeScript(a:funcname)
- 
-     " Source and delete the script.
-     exec "source" s:script_name
-     call delete(s:script_name)
-     let s:script_name = ''
- endfunction
- 
- function! DeleteTheScript()
-     if s:script_name
- 	call delete(s:script_name)
- 	let s:script_name = ''
-     endif
- endfunc
- 
- com! -nargs=1 -bar ExecAsScript call ExecAsScript(<f-args>)
- 
- 
- "-------------------------------------------------------------------------------
- " Test 1:   :endwhile in function					    {{{1
- "
- "	    Detect if a broken loop is (incorrectly) reactivated by the
- "	    :endwhile.  Use a :return to prevent an endless loop, and make
- "	    this test first to get a meaningful result on an error before other
- "	    tests will hang.
- "-------------------------------------------------------------------------------
- 
- function! T1_F()
-     Xpath 'a'
-     let first = 1
-     while 1
- 	Xpath 'b'
- 	if first
- 	    Xpath 'c'
- 	    let first = 0
- 	    break
- 	else
- 	    Xpath 'd'
- 	    return
- 	endif
-     endwhile
- endfunction
- 
- function! T1_G()
-     Xpath 'h'
-     let first = 1
-     while 1
- 	Xpath 'i'
- 	if first
- 	    Xpath 'j'
- 	    let first = 0
- 	    break
- 	else
- 	    Xpath 'k'
- 	    return
- 	endif
- 	if 1	" unmatched :if
-     endwhile
- endfunction
- 
- func Test_endwhile_function()
-   XpathINIT
-   call T1_F()
-   Xpath 'F'
- 
-   try
-     call T1_G()
-   catch
-     " Catch missing :endif
-     call assert_true(v:exception =~ 'E171')
-     Xpath 'x'
-   endtry
-   Xpath 'G'
- 
-   call assert_equal('abcFhijxG', g:Xpath)
- endfunc
- 
- "-------------------------------------------------------------------------------
- " Test 2:   :endwhile in script						    {{{1
- "
- "	    Detect if a broken loop is (incorrectly) reactivated by the
- "	    :endwhile.  Use a :finish to prevent an endless loop, and place
- "	    this test before others that might hang to get a meaningful result
- "	    on an error.
- "
- "	    This test executes the bodies of the functions T1_F and T1_G from
- "	    the previous test as script files (:return replaced by :finish).
- "-------------------------------------------------------------------------------
- 
- func Test_endwhile_script()
-   XpathINIT
-   ExecAsScript T1_F
-   Xpath 'F'
-   call DeleteTheScript()
- 
-   try
-     ExecAsScript T1_G
-   catch
-     " Catch missing :endif
-     call assert_true(v:exception =~ 'E171')
-     Xpath 'x'
-   endtry
-   Xpath 'G'
-   call DeleteTheScript()
- 
-   call assert_equal('abcFhijxG', g:Xpath)
- endfunc
- 
- "-------------------------------------------------------------------------------
- " Test 3:   :if, :elseif, :while, :continue, :break			    {{{1
- "-------------------------------------------------------------------------------
- 
- function Test_if_while()
-     XpathINIT
-     if 1
- 	Xpath 'a'
- 	let loops = 3
- 	while loops > -1	    " main loop: loops == 3, 2, 1 (which breaks)
- 	    if loops <= 0
- 		let break_err = 1
- 		let loops = -1
- 	    else
- 		Xpath 'b' . loops
- 	    endif
- 	    if (loops == 2)
- 		while loops == 2 " dummy loop
- 		    Xpath 'c' . loops
- 		    let loops = loops - 1
- 		    continue    " stop dummy loop
- 		    Xpath 'd' . loops
- 		endwhile
- 		continue	    " continue main loop
- 		Xpath 'e' . loops
- 	    elseif (loops == 1)
- 		let p = 1
- 		while p	    " dummy loop
- 		    Xpath 'f' . loops
- 		    let p = 0
- 		    break	    " break dummy loop
- 		    Xpath 'g' . loops
- 		endwhile
- 		Xpath 'h' . loops
- 		unlet p
- 		break	    " break main loop
- 		Xpath 'i' . loops
- 	    endif
- 	    if (loops > 0)
- 		Xpath 'j' . loops
- 	    endif
- 	    while loops == 3    " dummy loop
- 		let loops = loops - 1
- 	    endwhile	    " end dummy loop
- 	endwhile		    " end main loop
- 	Xpath 'k'
-     else
- 	Xpath 'l'
-     endif
-     Xpath 'm'
-     if exists("break_err")
- 	Xpath 'm'
- 	unlet break_err
-     endif
- 
-     unlet loops
- 
-     call assert_equal('ab3j3b2c2b1f1h1km', g:Xpath)
- endfunc
- 
- "-------------------------------------------------------------------------------
- " Test 4:   :return							    {{{1
- "-------------------------------------------------------------------------------
- 
- function! T4_F()
-     if 1
- 	Xpath 'a'
- 	let loops = 3
- 	while loops > 0				"    3:  2:     1:
- 	    Xpath 'b' . loops
- 	    if (loops == 2)
- 		Xpath 'c' . loops
- 		return
- 		Xpath 'd' . loops
- 	    endif
- 	    Xpath 'e' . loops
- 	    let loops = loops - 1
- 	endwhile
- 	Xpath 'f'
-     else
- 	Xpath 'g'
-     endif
- endfunction
- 
- function Test_return()
-     XpathINIT
-     call T4_F()
-     Xpath '4'
- 
-     call assert_equal('ab3e3b2c24', g:Xpath)
- endfunction
- 
- 
- "-------------------------------------------------------------------------------
- " Test 5:   :finish							    {{{1
- "
- "	    This test executes the body of the function T4_F from the previous
- "	    test as a script file (:return replaced by :finish).
- "-------------------------------------------------------------------------------
- 
- function Test_finish()
-     XpathINIT
-     ExecAsScript T4_F
-     Xpath '5'
-     call DeleteTheScript()
- 
-     call assert_equal('ab3e3b2c25', g:Xpath)
- endfunction
- 
- 
- 
- "-------------------------------------------------------------------------------
- " Test 6:   Defining functions in :while loops				    {{{1
- "
- "	     Functions can be defined inside other functions.  An inner function
- "	     gets defined when the outer function is executed.  Functions may
- "	     also be defined inside while loops.  Expressions in braces for
- "	     defining the function name are allowed.
- "
- "	     The functions are defined when sourcing the script, only the
- "	     resulting path is checked in the test function.
- "-------------------------------------------------------------------------------
- 
- XpathINIT
- 
- " The command CALL collects the argument of all its invocations in "calls"
- " when used from a function (that is, when the global variable "calls" needs
- " the "g:" prefix).  This is to check that the function code is skipped when
- " the function is defined.  For inner functions, do so only if the outer
- " function is not being executed.
- "
- let calls = ""
- com! -nargs=1 CALL
-     	\ if !exists("calls") && !exists("outer") |
-     	\ let g:calls = g:calls . <args> |
-     	\ endif
- 
- let i = 0
- while i < 3
-     let i = i + 1
-     if i == 1
- 	Xpath 'a'
- 	function! F1(arg)
- 	    CALL a:arg
- 	    let outer = 1
- 
- 	    let j = 0
- 	    while j < 1
- 		Xpath 'b'
- 		let j = j + 1
- 		function! G1(arg)
- 		    CALL a:arg
- 		endfunction
- 		Xpath 'c'
- 	    endwhile
- 	endfunction
- 	Xpath 'd'
- 
- 	continue
-     endif
- 
-     Xpath 'e' . i
-     function! F{i}(i, arg)
- 	CALL a:arg
- 	let outer = 1
- 
- 	if a:i == 3
- 	    Xpath 'f'
- 	endif
- 	let k = 0
- 	while k < 3
- 	    Xpath 'g' . k
- 	    let k = k + 1
- 	    function! G{a:i}{k}(arg)
- 		CALL a:arg
- 	    endfunction
- 	    Xpath 'h' . k
- 	endwhile
-     endfunction
-     Xpath 'i'
- 
- endwhile
- 
- if exists("*G1")
-     Xpath 'j'
- endif
- if exists("*F1")
-     call F1("F1")
-     if exists("*G1")
-         call G1("G1")
-     endif
- endif
- 
- if exists("G21") || exists("G22") || exists("G23")
-     Xpath 'k'
- endif
- if exists("*F2")
-     call F2(2, "F2")
-     if exists("*G21")
-         call G21("G21")
-     endif
-     if exists("*G22")
-         call G22("G22")
-     endif
-     if exists("*G23")
-         call G23("G23")
-     endif
- endif
- 
- if exists("G31") || exists("G32") || exists("G33")
-     Xpath 'l'
- endif
- if exists("*F3")
-     call F3(3, "F3")
-     if exists("*G31")
-         call G31("G31")
-     endif
-     if exists("*G32")
-         call G32("G32")
-     endif
-     if exists("*G33")
-         call G33("G33")
-     endif
- endif
- 
- Xpath 'm'
- 
- let g:test6_result = g:Xpath
- let g:test6_calls = calls
- 
- unlet calls
- delfunction F1
- delfunction G1
- delfunction F2
- delfunction G21
- delfunction G22
- delfunction G23
- delfunction G31
- delfunction G32
- delfunction G33
- 
- function Test_defining_functions()
-     call assert_equal('ade2ie3ibcg0h1g1h2g2h3fg0h1g1h2g2h3m', g:test6_result)
-     call assert_equal('F1G1F2G21G22G23F3G31G32G33', g:test6_calls)
- endfunc
- 
- "-------------------------------------------------------------------------------
- " Test 7:   Continuing on errors outside functions			    {{{1
- "
- "	    On an error outside a function, the script processing continues
- "	    at the line following the outermost :endif or :endwhile.  When not
- "	    inside an :if or :while, the script processing continues at the next
- "	    line.
- "-------------------------------------------------------------------------------
- 
- XpathINIT
- 
- if 1
-     Xpath 'a'
-     while 1
- 	Xpath 'b'
- 	asdf
- 	Xpath 'c'
- 	break
-     endwhile | Xpath 'd'
-     Xpath 'e'
- endif | Xpath 'f'
- Xpath 'g'
- 
- while 1
-     Xpath 'h'
-     if 1
- 	Xpath 'i'
- 	asdf
- 	Xpath 'j'
-     endif | Xpath 'k'
-     Xpath 'l'
-     break
- endwhile | Xpath 'm'
- Xpath 'n'
- 
- asdf
- Xpath 'o'
- 
- asdf | Xpath 'p'
- Xpath 'q'
- 
- let g:test7_result = g:Xpath
- 
- func Test_error_in_script()
-     call assert_equal('abghinoq', g:test7_result)
- endfunc
- 
- "-------------------------------------------------------------------------------
- " Test 8:   Aborting and continuing on errors inside functions		    {{{1
- "
- "	    On an error inside a function without the "abort" attribute, the
- "	    script processing continues at the next line (unless the error was
- "	    in a :return command).  On an error inside a function with the
- "	    "abort" attribute, the function is aborted and the script processing
- "	    continues after the function call; the value -1 is returned then.
- "-------------------------------------------------------------------------------
- 
- XpathINIT
- 
- function! T8_F()
-     if 1
- 	Xpath 'a'
- 	while 1
- 	    Xpath 'b'
- 	    asdf
- 	    Xpath 'c'
- 	    asdf | Xpath 'd'
- 	    Xpath 'e'
- 	    break
- 	endwhile
- 	Xpath 'f'
-     endif | Xpath 'g'
-     Xpath 'h'
- 
-     while 1
- 	Xpath 'i'
- 	if 1
- 	    Xpath 'j'
- 	    asdf
- 	    Xpath 'k'
- 	    asdf | Xpath 'l'
- 	    Xpath 'm'
- 	endif
- 	Xpath 'n'
- 	break
-     endwhile | Xpath 'o'
-     Xpath 'p'
- 
-     return novar		" returns (default return value 0)
-     Xpath 'q'
-     return 1			" not reached
- endfunction
- 
- function! T8_G() abort
-     if 1
- 	Xpath 'r'
- 	while 1
- 	    Xpath 's'
- 	    asdf		" returns -1
- 	    Xpath 't'
- 	    break
- 	endwhile
- 	Xpath 'v'
-     endif | Xpath 'w'
-     Xpath 'x'
- 
-     return -4			" not reached
- endfunction
- 
- function! T8_H() abort
-     while 1
- 	Xpath 'A'
- 	if 1
- 	    Xpath 'B'
- 	    asdf		" returns -1
- 	    Xpath 'C'
- 	endif
- 	Xpath 'D'
- 	break
-     endwhile | Xpath 'E'
-     Xpath 'F'
- 
-     return -4			" not reached
- endfunction
- 
- " Aborted functions (T8_G and T8_H) return -1.
- let g:test8_sum = (T8_F() + 1) - 4 * T8_G() - 8 * T8_H()
- Xpath 'X'
- let g:test8_result = g:Xpath
- 
- func Test_error_in_function()
-     call assert_equal(13, g:test8_sum)
-     call assert_equal('abcefghijkmnoprsABX', g:test8_result)
- 
-     delfunction T8_F
-     delfunction T8_G
-     delfunction T8_H
- endfunc
- 
- 
- "-------------------------------------------------------------------------------
- " Test 9:   Continuing after aborted functions				    {{{1
- "
- "	    When a function with the "abort" attribute is aborted due to an
- "	    error, the next function back in the call hierarchy without an
- "	    "abort" attribute continues; the value -1 is returned then.
- "-------------------------------------------------------------------------------
- 
- XpathINIT
- 
- function! F() abort
-     Xpath 'a'
-     let result = G()	" not aborted
-     Xpath 'b'
-     if result != 2
- 	Xpath 'c'
-     endif
-     return 1
- endfunction
- 
- function! G()		" no abort attribute
-     Xpath 'd'
-     if H() != -1	" aborted
- 	Xpath 'e'
-     endif
-     Xpath 'f'
-     return 2
- endfunction
- 
- function! H() abort
-     Xpath 'g'
-     call I()		" aborted
-     Xpath 'h'
-     return 4
- endfunction
- 
- function! I() abort
-     Xpath 'i'
-     asdf		" error
-     Xpath 'j'
-     return 8
- endfunction
- 
- if F() != 1
-     Xpath 'k'
- endif
- 
- let g:test9_result = g:Xpath
- 
- delfunction F
- delfunction G
- delfunction H
- delfunction I
- 
- func Test_func_abort()
-     call assert_equal('adgifb', g:test9_result)
- endfunc
- 
- 
- "-------------------------------------------------------------------------------
- " Test 10:  :if, :elseif, :while argument parsing			    {{{1
- "
- "	    A '"' or '|' in an argument expression must not be mixed up with
- "	    a comment or a next command after a bar.  Parsing errors should
- "	    be recognized.
- "-------------------------------------------------------------------------------
- 
- XpathINIT
- 
- function! MSG(enr, emsg)
-     let english = v:lang == "C" || v:lang =~ '^[Ee]n'
-     if a:enr == ""
- 	Xout "TODO: Add message number for:" a:emsg
- 	let v:errmsg = ":" . v:errmsg
-     endif
-     let match = 1
-     if v:errmsg !~ '^'.a:enr.':' || (english && v:errmsg !~ a:emsg)
- 	let match = 0
- 	if v:errmsg == ""
- 	    Xout "Message missing."
- 	else
- 	    let v:errmsg = escape(v:errmsg, '"')
- 	    Xout "Unexpected message:" v:errmsg
- 	endif
-     endif
-     return match
- endfunction
- 
- if 1 || strlen("\"") | Xpath 'a'
-     Xpath 'b'
- endif
- Xpath 'c'
- 
- if 0
- elseif 1 || strlen("\"") | Xpath 'd'
-     Xpath 'e'
- endif
- Xpath 'f'
- 
- while 1 || strlen("\"") | Xpath 'g'
-     Xpath 'h'
-     break
- endwhile
- Xpath 'i'
- 
- let v:errmsg = ""
- if 1 ||| strlen("\"") | Xpath 'j'
-     Xpath 'k'
- endif
- Xpath 'l'
- if !MSG('E15', "Invalid expression")
-     Xpath 'm'
- endif
- 
- let v:errmsg = ""
- if 0
- elseif 1 ||| strlen("\"") | Xpath 'n'
-     Xpath 'o'
- endif
- Xpath 'p'
- if !MSG('E15', "Invalid expression")
-     Xpath 'q'
- endif
- 
- let v:errmsg = ""
- while 1 ||| strlen("\"") | Xpath 'r'
-     Xpath 's'
-     break
- endwhile
- Xpath 't'
- if !MSG('E15', "Invalid expression")
-     Xpath 'u'
- endif
- 
- let g:test10_result = g:Xpath
- delfunction MSG
- 
- func Test_expr_parsing()
-     call assert_equal('abcdefghilpt', g:test10_result)
- endfunc
- 
- 
- "-------------------------------------------------------------------------------
- " Test 11:  :if, :elseif, :while argument evaluation after abort	    {{{1
- "
- "	    When code is skipped over due to an error, the boolean argument to
- "	    an :if, :elseif, or :while must not be evaluated.
- "-------------------------------------------------------------------------------
- 
- XpathINIT
- 
- let calls = 0
- 
- function! P(num)
-     let g:calls = g:calls + a:num   " side effect on call
-     return 0
- endfunction
- 
- if 1
-     Xpath 'a'
-     asdf		" error
-     Xpath 'b'
-     if P(1)		" should not be called
- 	Xpath 'c'
-     elseif !P(2)	" should not be called
- 	Xpath 'd'
-     else
- 	Xpath 'e'
-     endif
-     Xpath 'f'
-     while P(4)		" should not be called
- 	Xpath 'g'
-     endwhile
-     Xpath 'h'
- endif
- Xpath 'x'
- 
- let g:test11_calls = calls
- let g:test11_result = g:Xpath
- 
- unlet calls
- delfunction P
- 
- func Test_arg_abort()
-     call assert_equal(0, g:test11_calls)
-     call assert_equal('ax', g:test11_result)
- endfunc
- 
- 
- "-------------------------------------------------------------------------------
- " Test 12:  Expressions in braces in skipped code			    {{{1
- "
- "	    In code skipped over due to an error or inactive conditional,
- "	    an expression in braces as part of a variable or function name
- "	    should not be evaluated.
- "-------------------------------------------------------------------------------
- 
- XpathINIT
- 
- function! NULL()
-     Xpath 'a'
-     return 0
- endfunction
- 
- function! ZERO()
-     Xpath 'b'
-     return 0
- endfunction
- 
- function! F0()
-     Xpath 'c'
- endfunction
- 
- function! F1(arg)
-     Xpath 'e'
- endfunction
- 
- let V0 = 1
- 
- Xpath 'f'
- echo 0 ? F{NULL() + V{ZERO()}}() : 1
- 
- Xpath 'g'
- if 0
-     Xpath 'h'
-     call F{NULL() + V{ZERO()}}()
- endif
- 
- Xpath 'i'
- if 1
-     asdf		" error
-     Xpath 'j'
-     call F1(F{NULL() + V{ZERO()}}())
- endif
- 
- Xpath 'k'
- if 1
-     asdf		" error
-     Xpath 'l'
-     call F{NULL() + V{ZERO()}}()
- endif
- 
- let g:test12_result = g:Xpath
- 
- func Test_braces_skipped()
-     call assert_equal('fgik', g:test12_result)
- endfunc
- 
- 
- "-------------------------------------------------------------------------------
- " Test 13:  Failure in argument evaluation for :while			    {{{1
- "
- "	    A failure in the expression evaluation for the condition of a :while
- "	    causes the whole :while loop until the matching :endwhile being
- "	    ignored.  Continuation is at the next following line.
- "-------------------------------------------------------------------------------
- 
- XpathINIT
- 
- Xpath 'a'
- while asdf
-     Xpath 'b'
-     while 1
- 	Xpath 'c'
- 	break
-     endwhile
-     Xpath 'd'
-     break
- endwhile
- Xpath 'e'
- 
- while asdf | Xpath 'f' | endwhile | Xpath 'g'
- Xpath 'h'
- let g:test13_result = g:Xpath
- 
- func Test_while_fail()
-     call assert_equal('aeh', g:test13_result)
- endfunc
- 
- 
- "-------------------------------------------------------------------------------
- " Test 14:  Failure in argument evaluation for :if			    {{{1
- "
- "	    A failure in the expression evaluation for the condition of an :if
- "	    does not cause the corresponding :else or :endif being matched to
- "	    a previous :if/:elseif.  Neither of both branches of the failed :if
- "	    are executed.
- "-------------------------------------------------------------------------------
- 
- XpathINIT
- 
- function! F()
-     Xpath 'a'
-     let x = 0
-     if x		" false
- 	Xpath 'b'
-     elseif !x		" always true
- 	Xpath 'c'
- 	let x = 1
- 	if g:boolvar	" possibly undefined
- 	    Xpath 'd'
- 	else
- 	    Xpath 'e'
- 	endif
- 	Xpath 'f'
-     elseif x		" never executed
- 	Xpath 'g'
-     endif
-     Xpath 'h'
- endfunction
- 
- let boolvar = 1
- call F()
- Xpath '-'
- 
- unlet boolvar
- call F()
- let g:test14_result = g:Xpath
- 
- delfunction F
- 
- func Test_if_fail()
-     call assert_equal('acdfh-acfh', g:test14_result)
- endfunc
- 
- 
- "-------------------------------------------------------------------------------
- " Test 15:  Failure in argument evaluation for :if (bar)		    {{{1
- "
- "	    Like previous test, except that the failing :if ... | ... | :endif
- "	    is in a single line.
- "-------------------------------------------------------------------------------
- 
- XpathINIT
- 
- function! F()
-     Xpath 'a'
-     let x = 0
-     if x		" false
- 	Xpath 'b'
-     elseif !x		" always true
- 	Xpath 'c'
- 	let x = 1
- 	if g:boolvar | Xpath 'd' | else | Xpath 'e' | endif
- 	Xpath 'f'
-     elseif x		" never executed
- 	Xpath 'g'
-     endif
-     Xpath 'h'
- endfunction
- 
- let boolvar = 1
- call F()
- Xpath '-'
- 
- unlet boolvar
- call F()
- let g:test15_result = g:Xpath
- 
- delfunction F
- 
- func Test_if_bar_fail()
-     call assert_equal('acdfh-acfh', g:test15_result)
- endfunc
- 
- "-------------------------------------------------------------------------------
- " Test 90:  Recognizing {} in variable name.			    {{{1
- "-------------------------------------------------------------------------------
- 
- func Test_curlies()
-     let s:var = 66
-     let ns = 's'
-     call assert_equal(66, {ns}:var)
- 
-     let g:a = {}
-     let g:b = 't'
-     let g:a[g:b] = 77
-     call assert_equal(77, g:a['t'])
- endfunc
- 
- "-------------------------------------------------------------------------------
- " Test 91:  using type().					    {{{1
- "-------------------------------------------------------------------------------
- 
- func Test_type()
-     call assert_equal(0, type(0))
-     call assert_equal(1, type(""))
-     call assert_equal(2, type(function("tr")))
-     call assert_equal(2, type(function("tr", [8])))
-     call assert_equal(3, type([]))
-     call assert_equal(4, type({}))
-     call assert_equal(5, type(0.0))
-     call assert_equal(6, type(v:false))
-     call assert_equal(6, type(v:true))
-     call assert_equal(7, type(v:none))
-     call assert_equal(7, type(v:null))
-     call assert_equal(8, v:t_job)
-     call assert_equal(9, v:t_channel)
-     call assert_equal(v:t_number, type(0))
-     call assert_equal(v:t_string, type(""))
-     call assert_equal(v:t_func, type(function("tr")))
-     call assert_equal(v:t_func, type(function("tr", [8])))
-     call assert_equal(v:t_list, type([]))
-     call assert_equal(v:t_dict, type({}))
-     call assert_equal(v:t_float, type(0.0))
-     call assert_equal(v:t_bool, type(v:false))
-     call assert_equal(v:t_bool, type(v:true))
-     call assert_equal(v:t_none, type(v:none))
-     call assert_equal(v:t_none, type(v:null))
- 
- 
-     call assert_equal(0, 0 + v:false)
-     call assert_equal(1, 0 + v:true)
-     call assert_equal(0, 0 + v:none)
-     call assert_equal(0, 0 + v:null)
- 
-     call assert_equal('v:false', '' . v:false)
-     call assert_equal('v:true', '' . v:true)
-     call assert_equal('v:none', '' . v:none)
-     call assert_equal('v:null', '' . v:null)
- 
-     call assert_true(v:false == 0)
-     call assert_false(v:false != 0)
-     call assert_true(v:true == 1)
-     call assert_false(v:true != 1)
-     call assert_false(v:true == v:false)
-     call assert_true(v:true != v:false)
- 
-     call assert_true(v:null == 0)
-     call assert_false(v:null != 0)
-     call assert_true(v:none == 0)
-     call assert_false(v:none != 0)
- 
-     call assert_true(v:false is v:false)
-     call assert_true(v:true is v:true)
-     call assert_true(v:none is v:none)
-     call assert_true(v:null is v:null)
- 
-     call assert_false(v:false isnot v:false)
-     call assert_false(v:true isnot v:true)
-     call assert_false(v:none isnot v:none)
-     call assert_false(v:null isnot v:null)
- 
-     call assert_false(v:false is 0)
-     call assert_false(v:true is 1)
-     call assert_false(v:true is v:false)
-     call assert_false(v:none is 0)
-     call assert_false(v:null is 0)
-     call assert_false(v:null is v:none)
- 
-     call assert_true(v:false isnot 0)
-     call assert_true(v:true isnot 1)
-     call assert_true(v:true isnot v:false)
-     call assert_true(v:none isnot 0)
-     call assert_true(v:null isnot 0)
-     call assert_true(v:null isnot v:none)
- 
-     call assert_equal(v:false, eval(string(v:false)))
-     call assert_equal(v:true, eval(string(v:true)))
-     call assert_equal(v:none, eval(string(v:none)))
-     call assert_equal(v:null, eval(string(v:null)))
- 
-     call assert_equal(v:false, copy(v:false))
-     call assert_equal(v:true, copy(v:true))
-     call assert_equal(v:none, copy(v:none))
-     call assert_equal(v:null, copy(v:null))
- 
-     call assert_equal([v:false], deepcopy([v:false]))
-     call assert_equal([v:true], deepcopy([v:true]))
-     call assert_equal([v:none], deepcopy([v:none]))
-     call assert_equal([v:null], deepcopy([v:null]))
- 
-     call assert_true(empty(v:false))
-     call assert_false(empty(v:true))
-     call assert_true(empty(v:null))
-     call assert_true(empty(v:none))
- 
-     func ChangeYourMind()
-       try
- 	return v:true
-       finally
-         return 'something else'
-       endtry
-     endfunc
- 
-     call ChangeYourMind()
- endfunc
- 
- "-------------------------------------------------------------------------------
- " Test 92:  skipping code					    {{{1
- "-------------------------------------------------------------------------------
- 
- func Test_skip()
-     let Fn = function('Test_type')
-     call assert_false(0 && Fn[1])
-     call assert_false(0 && string(Fn))
-     call assert_false(0 && len(Fn))
-     let l = []
-     call assert_false(0 && l[1])
-     call assert_false(0 && string(l))
-     call assert_false(0 && len(l))
-     let f = 1.0
-     call assert_false(0 && f[1])
-     call assert_false(0 && string(f))
-     call assert_false(0 && len(f))
-     let sp = v:null
-     call assert_false(0 && sp[1])
-     call assert_false(0 && string(sp))
-     call assert_false(0 && len(sp))
- 
- endfunc
- 
- "-------------------------------------------------------------------------------
- " Test 93:  :echo and string()					    {{{1
- "-------------------------------------------------------------------------------
- 
- func Test_echo_and_string()
-     " String
-     let a = 'foo bar'
-     redir => result
-     echo a
-     echo string(a)
-     redir END
-     let l = split(result, "\n")
-     call assert_equal(["foo bar",
- 		     \ "'foo bar'"], l)
- 
-     " Float
-     if has('float')
- 	let a = -1.2e0
- 	redir => result
- 	echo a
- 	echo string(a)
- 	redir END
- 	let l = split(result, "\n")
- 	call assert_equal(["-1.2",
- 			 \ "-1.2"], l)
-     endif
- 
-     " Funcref
-     redir => result
-     echo function('string')
-     echo string(function('string'))
-     redir END
-     let l = split(result, "\n")
-     call assert_equal(["string",
- 		     \ "function('string')"], l)
- 
-     " Recursive dictionary
-     let a = {}
-     let a["a"] = a
-     redir => result
-     echo a
-     echo string(a)
-     redir END
-     let l = split(result, "\n")
-     call assert_equal(["{'a': {...}}",
- 		     \ "{'a': {...}}"], l)
- 
-     " Recursive list
-     let a = [0]
-     let a[0] = a
-     redir => result
-     echo a
-     echo string(a)
-     redir END
-     let l = split(result, "\n")
-     call assert_equal(["[[...]]",
- 		     \ "[[...]]"], l)
- 
-     " Empty dictionaries in a list
-     let a = {}
-     redir => result
-     echo [a, a, a]
-     echo string([a, a, a])
-     redir END
-     let l = split(result, "\n")
-     call assert_equal(["[{}, {}, {}]",
- 		     \ "[{}, {}, {}]"], l)
- 
-     " Empty dictionaries in a dictionary
-     let a = {}
-     let b = {"a": a, "b": a}
-     redir => result
-     echo b
-     echo string(b)
-     redir END
-     let l = split(result, "\n")
-     call assert_equal(["{'a': {}, 'b': {}}",
- 		     \ "{'a': {}, 'b': {}}"], l)
- 
-     " Empty lists in a list
-     let a = []
-     redir => result
-     echo [a, a, a]
-     echo string([a, a, a])
-     redir END
-     let l = split(result, "\n")
-     call assert_equal(["[[], [], []]",
- 		     \ "[[], [], []]"], l)
- 
-     " Empty lists in a dictionary
-     let a = []
-     let b = {"a": a, "b": a}
-     redir => result
-     echo b
-     echo string(b)
-     redir END
-     let l = split(result, "\n")
-     call assert_equal(["{'a': [], 'b': []}",
- 		     \ "{'a': [], 'b': []}"], l)
- 
-     " Dictionaries in a list
-     let a = {"one": "yes", "two": "yes", "three": "yes"}
-     redir => result
-     echo [a, a, a]
-     echo string([a, a, a])
-     redir END
-     let l = split(result, "\n")
-     call assert_equal(["[{'one': 'yes', 'two': 'yes', 'three': 'yes'}, {...}, {...}]",
- 		     \ "[{'one': 'yes', 'two': 'yes', 'three': 'yes'}, {'one': 'yes', 'two': 'yes', 'three': 'yes'}, {'one': 'yes', 'two': 'yes', 'three': 'yes'}]"], l)
- 
-     " Dictionaries in a dictionary
-     let a = {"one": "yes", "two": "yes", "three": "yes"}
-     let b = {"a": a, "b": a}
-     redir => result
-     echo b
-     echo string(b)
-     redir END
-     let l = split(result, "\n")
-     call assert_equal(["{'a': {'one': 'yes', 'two': 'yes', 'three': 'yes'}, 'b': {...}}",
- 		     \ "{'a': {'one': 'yes', 'two': 'yes', 'three': 'yes'}, 'b': {'one': 'yes', 'two': 'yes', 'three': 'yes'}}"], l)
- 
-     " Lists in a list
-     let a = [1, 2, 3]
-     redir => result
-     echo [a, a, a]
-     echo string([a, a, a])
-     redir END
-     let l = split(result, "\n")
-     call assert_equal(["[[1, 2, 3], [...], [...]]",
- 		     \ "[[1, 2, 3], [1, 2, 3], [1, 2, 3]]"], l)
- 
-     " Lists in a dictionary
-     let a = [1, 2, 3]
-     let b = {"a": a, "b": a}
-     redir => result
-     echo b
-     echo string(b)
-     redir END
-     let l = split(result, "\n")
-     call assert_equal(["{'a': [1, 2, 3], 'b': [...]}",
- 		     \ "{'a': [1, 2, 3], 'b': [1, 2, 3]}"], l)
- 
- endfunc
- 
- "-------------------------------------------------------------------------------
- " Test 94:  64-bit Numbers					    {{{1
- "-------------------------------------------------------------------------------
- 
- func Test_num64()
-     if !has('num64')
- 	return
-     endif
- 
-     call assert_notequal( 4294967296, 0)
-     call assert_notequal(-4294967296, 0)
-     call assert_equal( 4294967296,  0xFFFFffff + 1)
-     call assert_equal(-4294967296, -0xFFFFffff - 1)
- 
-     call assert_equal( 9223372036854775807,  1 / 0)
-     call assert_equal(-9223372036854775807, -1 / 0)
-     call assert_equal(-9223372036854775807 - 1,  0 / 0)
- 
-     call assert_equal( 0x7FFFffffFFFFffff, float2nr( 1.0e150))
-     call assert_equal(-0x7FFFffffFFFFffff, float2nr(-1.0e150))
- 
-     let rng = range(0xFFFFffff, 0x100000001)
-     call assert_equal([0xFFFFffff, 0x100000000, 0x100000001], rng)
-     call assert_equal(0x100000001, max(rng))
-     call assert_equal(0xFFFFffff, min(rng))
-     call assert_equal(rng, sort(range(0x100000001, 0xFFFFffff, -1), 'N'))
- endfunc
- 
- "-------------------------------------------------------------------------------
- " Test 95:  lines of :append, :change, :insert			    {{{1
- "-------------------------------------------------------------------------------
- 
- function! DefineFunction(name, body)
-     let func = join(['function! ' . a:name . '()'] + a:body + ['endfunction'], "\n")
-     exec func
- endfunction
- 
- func Test_script_lines()
-     " :append
-     try
-         call DefineFunction('T_Append', [
-                     \ 'append',
-                     \ 'py <<EOS',
-                     \ '.',
-                     \ ])
-     catch
-         call assert_false(1, "Can't define function")
-     endtry
-     try
-         call DefineFunction('T_Append', [
-                     \ 'append',
-                     \ 'abc',
-                     \ ])
-         call assert_false(1, "Shouldn't be able to define function")
-     catch
-         call assert_exception('Vim(function):E126: Missing :endfunction')
-     endtry
- 
-     " :change
-     try
-         call DefineFunction('T_Change', [
-                     \ 'change',
-                     \ 'py <<EOS',
-                     \ '.',
-                     \ ])
-     catch
-         call assert_false(1, "Can't define function")
-     endtry
-     try
-         call DefineFunction('T_Change', [
-                     \ 'change',
-                     \ 'abc',
-                     \ ])
-         call assert_false(1, "Shouldn't be able to define function")
-     catch
-         call assert_exception('Vim(function):E126: Missing :endfunction')
-     endtry
- 
-     " :insert
-     try
-         call DefineFunction('T_Insert', [
-                     \ 'insert',
-                     \ 'py <<EOS',
-                     \ '.',
-                     \ ])
-     catch
-         call assert_false(1, "Can't define function")
-     endtry
-     try
-         call DefineFunction('T_Insert', [
-                     \ 'insert',
-                     \ 'abc',
-                     \ ])
-         call assert_false(1, "Shouldn't be able to define function")
-     catch
-         call assert_exception('Vim(function):E126: Missing :endfunction')
-     endtry
- endfunc
- 
- "-------------------------------------------------------------------------------
- " Modelines								    {{{1
- " vim: ts=8 sw=4 tw=80 fdm=marker
- " vim: fdt=substitute(substitute(foldtext(),\ '\\%(^+--\\)\\@<=\\(\\s*\\)\\(.\\{-}\\)\:\ \\%(\"\ \\)\\=\\(Test\ \\d*\\)\:\\s*',\ '\\3\ (\\2)\:\ \\1',\ \"\"),\ '\\(Test\\s*\\)\\(\\d\\)\\D\\@=',\ '\\1\ \\2',\ "")
- "-------------------------------------------------------------------------------
--- 0 ----
*** ../vim-8.0.0359/src/version.c	2017-02-23 18:46:24.466288916 +0100
--- src/version.c	2017-02-23 18:50:44.848624212 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     360,
  /**/

-- 
Me?  A skeptic?  I trust you have proof.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0361
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0361
Problem:    GUI initialisation is not sufficiently tested.
Solution:   Add the gui_init test. (Kazuki Kuriyama)
Files:      src/Makefile, src/testdir/Make_all.mak, src/testdir/Make_dos.mak,
            src/testdir/Make_ming.mak, src/testdir/Makefile,
            src/testdir/gui_init.vim, src/testdir/setup_gui.vim,
            src/testdir/test_gui.vim, src/testdir/test_gui_init.vim,
	    Filelist


*** ../vim-8.0.0360/src/Makefile	2017-02-23 19:00:28.508904228 +0100
--- src/Makefile	2017-02-23 19:13:12.408028718 +0100
***************
*** 2133,2138 ****
--- 2133,2139 ----
  	test_gn \
  	test_goto \
  	test_gui \
+ 	test_gui_init \
  	test_hardcopy \
  	test_help \
  	test_help_tagjump \
*** ../vim-8.0.0360/src/testdir/Make_all.mak	2017-02-23 19:00:28.512904202 +0100
--- src/testdir/Make_all.mak	2017-02-23 19:16:26.794787125 +0100
***************
*** 2,8 ****
  # Common Makefile, defines the list of tests to run.
  #
  
! NO_PLUGIN = -U NONE --noplugin --not-a-term
  
  # The first script creates small.vim.
  SCRIPTS_FIRST = \
--- 2,11 ----
  # Common Makefile, defines the list of tests to run.
  #
  
! # Options for protecting the tests against undesirable interaction with the
! # environment
! NO_PLUGINS = --noplugin --not-a-term
! NO_INITS = -U NONE $(NO_PLUGINS)
  
  # The first script creates small.vim.
  SCRIPTS_FIRST = \
***************
*** 152,157 ****
--- 155,161 ----
  	    test_gf.res \
  	    test_gn.res \
  	    test_gui.res \
+ 	    test_gui_init.res \
  	    test_hardcopy.res \
  	    test_help.res \
  	    test_hide.res \
*** ../vim-8.0.0360/src/testdir/Make_dos.mak	2017-01-06 17:59:54.735385599 +0100
--- src/testdir/Make_dos.mak	2017-02-23 19:19:53.693465487 +0100
***************
*** 38,44 ****
  $(DOSTMP_INFILES): $(*B).in
  	if not exist $(DOSTMP)\NUL md $(DOSTMP)
  	if exist $@ del $@
! 	$(VIMPROG) -u dos.vim $(NO_PLUGIN) "+set ff=dos|f $@|wq" $(*B).in
  
  # For each input file dostmp/test99.in run the tests.
  # This moves test99.in to test99.in.bak temporarily.
--- 38,44 ----
  $(DOSTMP_INFILES): $(*B).in
  	if not exist $(DOSTMP)\NUL md $(DOSTMP)
  	if exist $@ del $@
! 	$(VIMPROG) -u dos.vim $(NO_INITS) "+set ff=dos|f $@|wq" $(*B).in
  
  # For each input file dostmp/test99.in run the tests.
  # This moves test99.in to test99.in.bak temporarily.
***************
*** 47,53 ****
  	move $(*B).in $(*B).in.bak > nul
  	copy $(DOSTMP)\$(*B).in $(*B).in > nul
  	copy $(*B).ok test.ok > nul
! 	$(VIMPROG) -u dos.vim $(NO_PLUGIN) -s dotest.in $(*B).in
  	-@if exist test.out MOVE /y test.out $(DOSTMP)\$(*B).out > nul
  	-@if exist $(*B).in.bak move /y $(*B).in.bak $(*B).in > nul
  	-@if exist test.ok del test.ok
--- 47,53 ----
  	move $(*B).in $(*B).in.bak > nul
  	copy $(DOSTMP)\$(*B).in $(*B).in > nul
  	copy $(*B).ok test.ok > nul
! 	$(VIMPROG) -u dos.vim $(NO_INITS) -s dotest.in $(*B).in
  	-@if exist test.out MOVE /y test.out $(DOSTMP)\$(*B).out > nul
  	-@if exist $(*B).in.bak move /y $(*B).in.bak $(*B).in > nul
  	-@if exist test.ok del test.ok
***************
*** 55,61 ****
  	-@if exist Xfind rd /s /q Xfind
  	-@del X*
  	-@if exist viminfo del viminfo
! 	$(VIMPROG) -u dos.vim $(NO_PLUGIN) "+set ff=unix|f test.out|wq" \
  		$(DOSTMP)\$(*B).out
  	@diff test.out $*.ok & if errorlevel 1 \
  		( move /y test.out $*.failed > nul \
--- 55,61 ----
  	-@if exist Xfind rd /s /q Xfind
  	-@del X*
  	-@if exist viminfo del viminfo
! 	$(VIMPROG) -u dos.vim $(NO_INITS) "+set ff=unix|f test.out|wq" \
  		$(DOSTMP)\$(*B).out
  	@diff test.out $*.ok & if errorlevel 1 \
  		( move /y test.out $*.failed > nul \
***************
*** 104,110 ****
  
  bench_re_freeze.out: bench_re_freeze.vim
  	-if exist benchmark.out del benchmark.out
! 	$(VIMPROG) -u dos.vim $(NO_PLUGIN) $*.in
  	@IF EXIST benchmark.out ( type benchmark.out )
  
  # New style of tests uses Vim script with assert calls.  These are easier
--- 104,110 ----
  
  bench_re_freeze.out: bench_re_freeze.vim
  	-if exist benchmark.out del benchmark.out
! 	$(VIMPROG) -u dos.vim $(NO_INITS) $*.in
  	@IF EXIST benchmark.out ( type benchmark.out )
  
  # New style of tests uses Vim script with assert calls.  These are easier
***************
*** 115,119 ****
  
  .vim.res:
  	@echo "$(VIMPROG)" > vimcmd
! 	$(VIMPROG) -u NONE $(NO_PLUGIN) -S runtest.vim $*.vim
  	@del vimcmd
--- 115,129 ----
  
  .vim.res:
  	@echo "$(VIMPROG)" > vimcmd
! 	$(VIMPROG) -u NONE $(NO_INITS) -S runtest.vim $*.vim
! 	@del vimcmd
! 
! test_gui.res: test_gui.vim
! 	@echo "$(VIMPROG)" > vimcmd
! 	$(VIMPROG) -u NONE $(NO_INITS) -S runtest.vim $<
! 	@del vimcmd
! 
! test_gui_init.res: test_gui_init.vim
! 	@echo "$(VIMPROG)" > vimcmd
! 	$(VIMPROG) -u NONE -U gui_init.vim $(NO_PLUGINS) -S runtest.vim $<
  	@del vimcmd
*** ../vim-8.0.0360/src/testdir/Make_ming.mak	2016-11-07 22:13:29.171894387 +0100
--- src/testdir/Make_ming.mak	2017-02-23 19:18:56.485830934 +0100
***************
*** 66,73 ****
  
  # TODO: find a way to avoid changing the distributed files.
  fixff:
! 	-$(VIMPROG) -u dos.vim $(NO_PLUGIN) "+argdo set ff=dos|upd" +q *.in *.ok
! 	-$(VIMPROG) -u dos.vim $(NO_PLUGIN) "+argdo set ff=unix|upd" +q \
  		dotest.in test60.ok test_listchars.ok \
  		test_getcwd.ok test_wordcount.ok
  
--- 66,73 ----
  
  # TODO: find a way to avoid changing the distributed files.
  fixff:
! 	-$(VIMPROG) -u dos.vim $(NO_INITS) "+argdo set ff=dos|upd" +q *.in *.ok
! 	-$(VIMPROG) -u dos.vim $(NO_INITS) "+argdo set ff=unix|upd" +q \
  		dotest.in test60.ok test_listchars.ok \
  		test_getcwd.ok test_wordcount.ok
  
***************
*** 91,97 ****
  
  .in.out:
  	-@if exist $*.ok $(CP) $*.ok test.ok
! 	$(VIMPROG) -u dos.vim $(NO_PLUGIN) -s dotest.in $*.in
  	@diff test.out $*.ok
  	-@if exist $*.out $(DEL) $*.out
  	@$(MV) test.out $*.out
--- 91,97 ----
  
  .in.out:
  	-@if exist $*.ok $(CP) $*.ok test.ok
! 	$(VIMPROG) -u dos.vim $(NO_INITS) -s dotest.in $*.in
  	@diff test.out $*.ok
  	-@if exist $*.out $(DEL) $*.out
  	@$(MV) test.out $*.out
***************
*** 107,113 ****
  
  bench_re_freeze.out: bench_re_freeze.vim
  	-$(DEL) benchmark.out
! 	$(VIMPROG) -u dos.vim $(NO_PLUGIN) $*.in
  	$(CAT) benchmark.out
  
  # New style of tests uses Vim script with assert calls.  These are easier
--- 107,113 ----
  
  bench_re_freeze.out: bench_re_freeze.vim
  	-$(DEL) benchmark.out
! 	$(VIMPROG) -u dos.vim $(NO_INITS) $*.in
  	$(CAT) benchmark.out
  
  # New style of tests uses Vim script with assert calls.  These are easier
***************
*** 118,123 ****
  
  .vim.res:
  	@echo "$(VIMPROG)" > vimcmd
! 	$(VIMPROG) -u NONE $(NO_PLUGIN) -S runtest.vim $*.vim
  	@$(DEL) vimcmd
  
--- 118,133 ----
  
  .vim.res:
  	@echo "$(VIMPROG)" > vimcmd
! 	$(VIMPROG) -u NONE $(NO_INITS) -S runtest.vim $*.vim
! 	@$(DEL) vimcmd
! 
! test_gui.res: test_gui.vim
! 	@echo "$(VIMPROG)" > vimcmd
! 	$(VIMPROG) -u NONE $(NO_INITS) -S runtest.vim $<
! 	@$(DEL) vimcmd
! 
! test_gui_init.res: test_gui_init.vim
! 	@echo "$(VIMPROG)" > vimcmd
! 	$(VIMPROG) -u NONE -U gui_init.vim $(NO_PLUGINS) -S runtest.vim $<
  	@$(DEL) vimcmd
  
*** ../vim-8.0.0360/src/testdir/Makefile	2017-01-30 22:00:56.621028503 +0100
--- src/testdir/Makefile	2017-02-23 19:22:31.588456794 +0100
***************
*** 52,58 ****
  
  RM_ON_RUN = test.out X* viminfo
  RM_ON_START = tiny.vim small.vim mbyte.vim mzscheme.vim lua.vim test.ok benchmark.out
! RUN_VIM = VIMRUNTIME=$(SCRIPTSOURCE); export VIMRUNTIME; $(VALGRIND) $(VIMPROG) -f $(GUI_FLAG) -u unix.vim $(NO_PLUGIN) -s dotest.in
  
  clean:
  	-rm -rf *.out *.failed *.res *.rej *.orig test.log messages $(RM_ON_RUN) $(RM_ON_START) valgrind.*
--- 52,58 ----
  
  RM_ON_RUN = test.out X* viminfo
  RM_ON_START = tiny.vim small.vim mbyte.vim mzscheme.vim lua.vim test.ok benchmark.out
! RUN_VIM = VIMRUNTIME=$(SCRIPTSOURCE); export VIMRUNTIME; $(VALGRIND) $(VIMPROG) -f $(GUI_FLAG) -u unix.vim $(NO_INITS) -s dotest.in
  
  clean:
  	-rm -rf *.out *.failed *.res *.rej *.orig test.log messages $(RM_ON_RUN) $(RM_ON_START) valgrind.*
***************
*** 118,124 ****
  # New style of tests uses Vim script with assert calls.  These are easier
  # to write and a lot easier to read and debug.
  # Limitation: Only works with the +eval feature.
! RUN_VIMTEST = VIMRUNTIME=$(SCRIPTSOURCE); export VIMRUNTIME; $(VALGRIND) $(VIMPROG) -f $(GUI_FLAG) -u unix.vim $(NO_PLUGIN)
  
  newtests: newtestssilent
  	@/bin/sh -c "if test -f messages && grep -q 'SKIPPED\|FAILED' messages; then cat messages && if test -f test.log; then cat test.log; fi ; fi"
--- 118,124 ----
  # New style of tests uses Vim script with assert calls.  These are easier
  # to write and a lot easier to read and debug.
  # Limitation: Only works with the +eval feature.
! RUN_VIMTEST = VIMRUNTIME=$(SCRIPTSOURCE); export VIMRUNTIME; $(VALGRIND) $(VIMPROG) -f $(GUI_FLAG) -u unix.vim
  
  newtests: newtestssilent
  	@/bin/sh -c "if test -f messages && grep -q 'SKIPPED\|FAILED' messages; then cat messages && if test -f test.log; then cat test.log; fi ; fi"
***************
*** 128,132 ****
  
  .vim.res:
  	@echo "$(RUN_VIMTEST)" > vimcmd
! 	$(RUN_VIMTEST) -U NONE -S runtest.vim $*.vim
  	@rm vimcmd
--- 128,142 ----
  
  .vim.res:
  	@echo "$(RUN_VIMTEST)" > vimcmd
! 	$(RUN_VIMTEST) $(NO_INITS) -S runtest.vim $*.vim
! 	@rm vimcmd
! 
! test_gui.res: test_gui.vim
! 	@echo "$(RUN_GVIMTEST)" > vimcmd
! 	$(RUN_VIMTEST) -u NONE $(NO_INITS) -S runtest.vim $<
! 	@rm vimcmd
! 
! test_gui_init.res: test_gui_init.vim
! 	@echo "$(RUN_GVIMTEST_WITH_GVIMRC)" > vimcmd
! 	$(RUN_VIMTEST) -u NONE -U gui_init.vim $(NO_PLUGINS) -S runtest.vim $<
  	@rm vimcmd
*** ../vim-8.0.0360/src/testdir/gui_init.vim	2017-02-23 19:26:34.190906826 +0100
--- src/testdir/gui_init.vim	2017-02-23 19:13:12.408028718 +0100
***************
*** 0 ****
--- 1,5 ----
+ " gvimrc for test_gui_init.vim
+ 
+ if has('gui_athena') || has('gui_motif') || has('gui_gtk2') || has('gui_gtk3')
+   set guiheadroom=0
+ endif
*** ../vim-8.0.0360/src/testdir/setup_gui.vim	2017-02-23 19:26:34.194906800 +0100
--- src/testdir/setup_gui.vim	2017-02-23 19:13:12.408028718 +0100
***************
*** 0 ****
--- 1,29 ----
+ " Common preparations for running GUI tests.
+ 
+ let g:x11_based_gui = has('gui_athena') || has('gui_motif')
+ 	\ || has('gui_gtk2') || has('gui_gnome') || has('gui_gtk3')
+ 
+ " Reasons for 'skipped'.
+ let g:not_supported   = "Skipped: Feature/Option not supported by this GUI: "
+ let g:not_implemented = "Skipped: Test not implemented yet for this GUI"
+ let g:not_hosted      = "Skipped: Test not hosted by the system/environment"
+ 
+ " For KDE set a font, empty 'guifont' may cause a hang.
+ func GUISetUpCommon()
+   if has("gui_kde")
+     set guifont=Courier\ 10\ Pitch/8/-1/5/50/0/0/0/0/0
+   endif
+ 
+   " Gnome insists on creating $HOME/.gnome2/, set $HOME to avoid changing the
+   " actual home directory.  But avoid triggering fontconfig by setting the
+   " cache directory.  Only needed for Unix.
+   if $XDG_CACHE_HOME == '' && exists('g:tester_HOME')
+     let $XDG_CACHE_HOME = g:tester_HOME . '/.cache'
+   endif
+   call mkdir('Xhome')
+   let $HOME = fnamemodify('Xhome', ':p')
+ endfunc
+ 
+ func GUITearDownCommon()
+   call delete('Xhome', 'rf')
+ endfunc
*** ../vim-8.0.0360/src/testdir/test_gui.vim	2017-02-17 13:44:44.299321045 +0100
--- src/testdir/test_gui.vim	2017-02-23 19:13:12.408028718 +0100
***************
*** 4,35 ****
    finish
  endif
  
! let s:x11_based_gui = has('gui_athena') || has('gui_motif')
! 	\ || has('gui_gtk2') || has('gui_gnome') || has('gui_gtk3')
  
! " Reasons for 'skipped'.
! let s:not_supported   = "Skipped: Feature/Option not supported by this GUI: "
! let s:not_implemented = "Skipped: Test not implemented yet for this GUI"
! let s:not_hosted      = "Skipped: Test not hosted by the system/environment"
! 
! " For KDE set a font, empty 'guifont' may cause a hang.
! func SetUp()
!   if has("gui_kde")
!     set guifont=Courier\ 10\ Pitch/8/-1/5/50/0/0/0/0/0
!   endif
! 
!   " Gnome insists on creating $HOME/.gnome2/, set $HOME to avoid changing the
!   " actual home directory.  But avoid triggering fontconfig by setting the
!   " cache directory.  Only needed for Unix.
!   if $XDG_CACHE_HOME == '' && exists('g:tester_HOME')
!     let $XDG_CACHE_HOME = g:tester_HOME . '/.cache'
!   endif
!   call mkdir('Xhome')
!   let $HOME = fnamemodify('Xhome', ':p')
  endfunc
  
  func TearDown()
!   call delete('Xhome', 'rf')
  endfunc
  
  " Test for resetting "secure" flag after GUI has started.
--- 4,17 ----
    finish
  endif
  
! source setup_gui.vim
  
! func Setup()
!   call GUISetUpCommon()
  endfunc
  
  func TearDown()
!   call GUITearDownCommon()
  endfunc
  
  " Test for resetting "secure" flag after GUI has started.
***************
*** 43,50 ****
  func Test_getfontname_with_arg()
    let skipped = ''
  
!   if !s:x11_based_gui
!     let skipped = s:not_implemented
    elseif has('gui_athena') || has('gui_motif')
      " Invalid font name. The result should be an empty string.
      call assert_equal('', getfontname('notexist'))
--- 25,32 ----
  func Test_getfontname_with_arg()
    let skipped = ''
  
!   if !g:x11_based_gui
!     let skipped = g:not_implemented
    elseif has('gui_athena') || has('gui_motif')
      " Invalid font name. The result should be an empty string.
      call assert_equal('', getfontname('notexist'))
***************
*** 72,79 ****
  
    let fname = getfontname()
  
!   if !s:x11_based_gui
!     let skipped = s:not_implemented
    elseif has('gui_kde')
      " 'expected' is the value specified by SetUp() above.
      call assert_equal('Courier 10 Pitch/8/-1/5/50/0/0/0/0/0', fname)
--- 54,61 ----
  
    let fname = getfontname()
  
!   if !g:x11_based_gui
!     let skipped = g:not_implemented
    elseif has('gui_kde')
      " 'expected' is the value specified by SetUp() above.
      call assert_equal('Courier 10 Pitch/8/-1/5/50/0/0/0/0/0', fname)
***************
*** 100,107 ****
      set guifontset=
    endif
  
!   if !s:x11_based_gui
!     let skipped = s:not_implemented
    elseif has('gui_athena') || has('gui_motif')
      " Non-empty font list with invalid font names.
      "
--- 82,89 ----
      set guifontset=
    endif
  
!   if !g:x11_based_gui
!     let skipped = g:not_implemented
    elseif has('gui_athena') || has('gui_motif')
      " Non-empty font list with invalid font names.
      "
***************
*** 153,159 ****
    let skipped = ''
  
    if !has('xfontset')
!     let skipped = s:not_supported . 'xfontset'
    else
      let ctype_saved = v:ctype
  
--- 135,141 ----
    let skipped = ''
  
    if !has('xfontset')
!     let skipped = g:not_supported . 'xfontset'
    else
      let ctype_saved = v:ctype
  
***************
*** 202,208 ****
  
      " Third, give a set of tests if it is found feasible.
      if !feasible
!       let skipped = s:not_hosted
      else
        " N.B. 'v:ctype' has already been set to an appropriate value in the
        " previous loop.
--- 184,190 ----
  
      " Third, give a set of tests if it is found feasible.
      if !feasible
!       let skipped = g:not_hosted
      else
        " N.B. 'v:ctype' has already been set to an appropriate value in the
        " previous loop.
***************
*** 224,238 ****
  func Test_set_guifontwide()
    let skipped = ''
  
!   if !s:x11_based_gui
!     let skipped = s:not_implemented
    elseif has('gui_gtk')
      let guifont_saved = &guifont
      let guifontwide_saved = &guifontwide
  
      let fc_match = exepath('fc-match')
      if empty(fc_match)
!       let skipped = s:not_hosted
      else
        let &guifont = system('fc-match -f "%{family[0]} %{size}" monospace:size=10:lang=en')
        let wide = system('fc-match -f "%{family[0]} %{size}" monospace:size=10:lang=ja')
--- 206,220 ----
  func Test_set_guifontwide()
    let skipped = ''
  
!   if !g:x11_based_gui
!     let skipped = g:not_implemented
    elseif has('gui_gtk')
      let guifont_saved = &guifont
      let guifontwide_saved = &guifontwide
  
      let fc_match = exepath('fc-match')
      if empty(fc_match)
!       let skipped = g:not_hosted
      else
        let &guifont = system('fc-match -f "%{family[0]} %{size}" monospace:size=10:lang=en')
        let wide = system('fc-match -f "%{family[0]} %{size}" monospace:size=10:lang=ja')
***************
*** 246,252 ****
    elseif has('gui_athena') || has('gui_motif')
      " guifontwide is premised upon the xfontset feature.
      if !has('xfontset')
!       let skipped = s:not_supported . 'xfontset'
      else
        let encoding_saved    = &encoding
        let guifont_saved     = &guifont
--- 228,234 ----
    elseif has('gui_athena') || has('gui_motif')
      " guifontwide is premised upon the xfontset feature.
      if !has('xfontset')
!       let skipped = g:not_supported . 'xfontset'
      else
        let encoding_saved    = &encoding
        let guifont_saved     = &guifont
***************
*** 303,308 ****
--- 285,306 ----
    endif
  endfunc
  
+ func Test_set_guiheadroom()
+   let skipped = ''
+ 
+   if !g:x11_based_gui
+     let skipped = g:not_supported . 'guiheadroom'
+   else
+     " Since this script is to be read together with '-U NONE', the default
+     " value must be preserved.
+     call assert_equal(50, &guiheadroom)
+   endif
+ 
+   if !empty(skipped)
+     throw skipped
+   endif
+ endfunc
+ 
  func Test_getwinpos()
    call assert_match('Window position: X \d\+, Y \d\+', execute('winpos'))
    call assert_true(getwinposx() >= 0)
***************
*** 317,323 ****
  endfunc
  
  func Test_windowid_variable()
!   if s:x11_based_gui || has('win32')
      call assert_true(v:windowid > 0)
    else
      call assert_equal(0, v:windowid)
--- 315,321 ----
  endfunc
  
  func Test_windowid_variable()
!   if g:x11_based_gui || has('win32')
      call assert_true(v:windowid > 0)
    else
      call assert_equal(0, v:windowid)
*** ../vim-8.0.0360/src/testdir/test_gui_init.vim	2017-02-23 19:26:34.206906723 +0100
--- src/testdir/test_gui_init.vim	2017-02-23 19:13:12.408028718 +0100
***************
*** 0 ****
--- 1,35 ----
+ " Tests specifically for the GUI features/options that need to be set up at
+ " startup to take effect at runtime.
+ 
+ if !has('gui') || ($DISPLAY == "" && !has('gui_running'))
+   finish
+ endif
+ 
+ source setup_gui.vim
+ 
+ func Setup()
+   call GUISetUpCommon()
+ endfunc
+ 
+ func TearDown()
+   call GUITearDownCommon()
+ endfunc
+ 
+ " Make sure that the tests will be done with the GUI activated.
+ gui -f
+ 
+ func Test_set_guiheadroom()
+   let skipped = ''
+ 
+   if !g:x11_based_gui
+     let skipped = g:not_supported . 'guiheadroom'
+   else
+     " The 'expected' value must be consistent with the value specified with
+     " gui_init.vim.
+     call assert_equal(0, &guiheadroom)
+   endif
+ 
+   if !empty(skipped)
+     throw skipped
+   endif
+ endfunc
*** ../vim-8.0.0360/Filelist	2017-01-28 18:42:52.809791676 +0100
--- Filelist	2017-02-23 19:28:00.654354379 +0100
***************
*** 105,111 ****
--- 105,114 ----
  		src/testdir/sautest/autoload/*.vim \
  		src/testdir/runtest.vim \
  		src/testdir/shared.vim \
+ 		src/testdir/view_util.vim \
  		src/testdir/setup.vim \
+ 		src/testdir/gui_init.vim \
+ 		src/testdir/setup_gui.vim \
  		src/testdir/test[0-9]*.ok \
  		src/testdir/test[0-9]*a.ok \
  		src/testdir/test_[a-z]*.ok \
*** ../vim-8.0.0360/src/version.c	2017-02-23 19:00:28.516904176 +0100
--- src/version.c	2017-02-23 19:09:16.489535424 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     361,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
12. You turn off your modem and get this awful empty feeling, like you just
    pulled the plug on a loved one.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0362
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0362 (after 8.0.0361)
Problem:    Tests fail on MS-Windows.
Solution:   Use $*.vim instead of $<.
Files:      src/testdir/Make_dos.mak


*** ../vim-8.0.0361/src/testdir/Make_dos.mak	2017-02-23 19:32:18.068709554 +0100
--- src/testdir/Make_dos.mak	2017-02-23 20:15:53.380151503 +0100
***************
*** 120,129 ****
  
  test_gui.res: test_gui.vim
  	@echo "$(VIMPROG)" > vimcmd
! 	$(VIMPROG) -u NONE $(NO_INITS) -S runtest.vim $<
  	@del vimcmd
  
  test_gui_init.res: test_gui_init.vim
  	@echo "$(VIMPROG)" > vimcmd
! 	$(VIMPROG) -u NONE -U gui_init.vim $(NO_PLUGINS) -S runtest.vim $<
  	@del vimcmd
--- 120,129 ----
  
  test_gui.res: test_gui.vim
  	@echo "$(VIMPROG)" > vimcmd
! 	$(VIMPROG) -u NONE $(NO_INITS) -S runtest.vim $*.vim
  	@del vimcmd
  
  test_gui_init.res: test_gui_init.vim
  	@echo "$(VIMPROG)" > vimcmd
! 	$(VIMPROG) -u NONE -U gui_init.vim $(NO_PLUGINS) -S runtest.vim $*.vim
  	@del vimcmd
*** ../vim-8.0.0361/src/version.c	2017-02-23 19:32:18.072709528 +0100
--- src/version.c	2017-02-23 20:16:39.167864660 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     362,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
13. You refer to going to the bathroom as downloading.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0363
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0363
Problem:    Travis is too slow to keep up with patches.
Solution:   Increase git depth to 20
Files:      .travis.yml


*** ../vim-8.0.0362/.travis.yml	2017-01-27 22:20:09.539496898 +0100
--- .travis.yml	2017-02-23 20:19:15.050888924 +0100
***************
*** 25,31 ****
  sudo: false
  
  git:
!   depth: 10
  
  # instead of a 2*2*8 matrix (2*os + 2*compiler + 8*env),
  # exclude some builds on mac os x and linux
--- 25,31 ----
  sudo: false
  
  git:
!   depth: 20
  
  # instead of a 2*2*8 matrix (2*os + 2*compiler + 8*env),
  # exclude some builds on mac os x and linux
*** ../vim-8.0.0362/src/version.c	2017-02-23 20:17:09.255676362 +0100
--- src/version.c	2017-02-23 20:20:12.262530711 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     363,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
14. You start introducing yourself as "Jim at I-I-Net dot net dot au"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0364
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0364
Problem:    ]s does not move cursor with two spell errors in one line. (Manuel
            Ortega)
Solution:   Don't stop search immediately when wrapped, search the line first.
            (Ken Takata)  Add a test.
Files:      src/spell.c, src/Makefile, src/testdir/test_spell.vim,
            src/testdir/Make_all.mak


*** ../vim-8.0.0363/src/spell.c	2016-11-10 20:01:41.201582868 +0100
--- src/spell.c	2017-02-25 14:17:13.361695979 +0100
***************
*** 1734,1747 ****
  	if (curline)
  	    break;	/* only check cursor line */
  
  	/* Advance to next line. */
  	if (dir == BACKWARD)
  	{
- 	    /* If we are back at the starting line and searched it again there
- 	     * is no match, give up. */
- 	    if (lnum == wp->w_cursor.lnum && wrapped)
- 		break;
- 
  	    if (lnum > 1)
  		--lnum;
  	    else if (!p_ws)
--- 1734,1747 ----
  	if (curline)
  	    break;	/* only check cursor line */
  
+ 	/* If we are back at the starting line and searched it again there
+ 	 * is no match, give up. */
+ 	if (lnum == wp->w_cursor.lnum && wrapped)
+ 	    break;
+ 
  	/* Advance to next line. */
  	if (dir == BACKWARD)
  	{
  	    if (lnum > 1)
  		--lnum;
  	    else if (!p_ws)
***************
*** 1775,1781 ****
  
  	    /* If we are back at the starting line and there is no match then
  	     * give up. */
! 	    if (lnum == wp->w_cursor.lnum && (!found_one || wrapped))
  		break;
  
  	    /* Skip the characters at the start of the next line that were
--- 1775,1781 ----
  
  	    /* If we are back at the starting line and there is no match then
  	     * give up. */
! 	    if (lnum == wp->w_cursor.lnum && !found_one)
  		break;
  
  	    /* Skip the characters at the start of the next line that were
*** ../vim-8.0.0363/src/Makefile	2017-02-23 19:32:18.068709554 +0100
--- src/Makefile	2017-02-25 14:07:44.085061911 +0100
***************
*** 2193,2198 ****
--- 2193,2199 ----
  	test_smartindent \
  	test_sort \
  	test_source_utf8 \
+ 	test_spell \
  	test_startup \
  	test_startup_utf8 \
  	test_stat \
*** ../vim-8.0.0363/src/testdir/test_spell.vim	2017-02-25 14:20:27.592545219 +0100
--- src/testdir/test_spell.vim	2017-02-25 14:14:25.706688358 +0100
***************
*** 0 ****
--- 1,20 ----
+ " Test spell checking
+ " TODO: move test58 tests here
+ 
+ if !has('spell')
+   finish
+ endif
+ 
+ func Test_wrap_search()
+   new
+   call setline(1, ['The', '', 'A plong line with two zpelling mistakes', '', 'End'])
+   set spell wrapscan
+   normal ]s
+   call assert_equal('plong', expand('<cword>'))
+   normal ]s
+   call assert_equal('zpelling', expand('<cword>'))
+   normal ]s
+   call assert_equal('plong', expand('<cword>'))
+   bwipe!
+   set nospell
+ endfunc
*** ../vim-8.0.0363/src/testdir/Make_all.mak	2017-02-23 19:32:18.068709554 +0100
--- src/testdir/Make_all.mak	2017-02-25 14:13:56.186863001 +0100
***************
*** 192,197 ****
--- 192,198 ----
  	    test_search.res \
  	    test_signs.res \
  	    test_smartindent.res \
+ 	    test_spell.res \
  	    test_startup.res \
  	    test_startup_utf8.res \
  	    test_stat.res \
*** ../vim-8.0.0363/src/version.c	2017-02-23 20:20:46.054319107 +0100
--- src/version.c	2017-02-25 14:09:53.796295923 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     364,
  /**/

-- 
Shift happens.
                -- Doppler

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0365
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0365
Problem:    Might free a dict item that wasn't allocated.
Solution:   Call dictitem_free(). (Nikolai Pavlov)  Use this for
            b:changedtick.
Files:      src/dict.c, src/structs.h, src/buffer.c, src/edit.c,
            src/evalfunc.c, src/ex_docmd.c, src/fileio.c, src/main.c,
            src/memline.c, src/misc1.c, src/syntax.c


*** ../vim-8.0.0364/src/dict.c	2016-11-10 20:01:41.181582995 +0100
--- src/dict.c	2017-02-25 14:33:33.327756619 +0100
***************
*** 88,95 ****
  	     * something recursive causing trouble. */
  	    di = HI2DI(hi);
  	    hash_remove(&d->dv_hashtab, hi);
! 	    clear_tv(&di->di_tv);
! 	    vim_free(di);
  	    --todo;
  	}
      }
--- 88,94 ----
  	     * something recursive causing trouble. */
  	    di = HI2DI(hi);
  	    hash_remove(&d->dv_hashtab, hi);
! 	    dictitem_free(di);
  	    --todo;
  	}
      }
*** ../vim-8.0.0364/src/structs.h	2017-02-17 16:31:16.909294226 +0100
--- src/structs.h	2017-02-25 14:39:55.349390887 +0100
***************
*** 1916,1924 ****
  
      int		b_changed;	/* 'modified': Set to TRUE if something in the
  				   file has been changed and not written out. */
!     varnumber_T	*b_changedtick;	/* points into b:changedtick or b_ct_val;
  				   incremented for each change, also for undo */
!     varnumber_T b_ct_val;	/* fallback for b:changedtick */
  
      int		b_saving;	/* Set to TRUE if we are in the middle of
  				   saving the buffer. */
--- 1916,1925 ----
  
      int		b_changed;	/* 'modified': Set to TRUE if something in the
  				   file has been changed and not written out. */
!     dictitem16_T b_ct_di;	/* holds the b:changedtick value in
! 				   b_ct_di.di_tv.vval.v_number;
  				   incremented for each change, also for undo */
! #define CHANGEDTICK(buf) ((buf)->b_ct_di.di_tv.vval.v_number)
  
      int		b_saving;	/* Set to TRUE if we are in the middle of
  				   saving the buffer. */
*** ../vim-8.0.0364/src/buffer.c	2017-02-21 20:47:09.958394797 +0100
--- src/buffer.c	2017-02-25 14:50:32.457430069 +0100
***************
*** 832,838 ****
      free_buffer_stuff(buf, TRUE);
  #ifdef FEAT_EVAL
      unref_var_dict(buf->b_vars);
-     buf->b_changedtick = &buf->b_ct_val;
  #endif
  #ifdef FEAT_LUA
      lua_buffer_free(buf);
--- 832,837 ----
***************
*** 874,904 ****
  }
  
  /*
!  * Initializes buf->b_changedtick.
   */
      static void
  init_changedtick(buf_T *buf)
  {
! #ifdef FEAT_EVAL
!     dictitem_T *di = dictitem_alloc((char_u *)"changedtick");
  
!     if (di != NULL)
!     {
! 	di->di_flags |= DI_FLAGS_FIX | DI_FLAGS_RO;
! 	di->di_tv.v_type = VAR_NUMBER;
! 	di->di_tv.v_lock = VAR_FIXED;
! 	di->di_tv.vval.v_number = 0;
! 	if (dict_add(buf->b_vars, di) == OK)
! 	    buf->b_changedtick = &di->di_tv.vval.v_number;
! 	else
! 	{
! 	    vim_free(di);
! 	    buf->b_changedtick = &buf->b_ct_val;
! 	}
!     }
!     else
! #endif
! 	buf->b_changedtick = &buf->b_ct_val;
  }
  
  /*
--- 873,892 ----
  }
  
  /*
!  * Initializes b:changedtick.
   */
      static void
  init_changedtick(buf_T *buf)
  {
!     dictitem_T *di = (dictitem_T *)&buf->b_ct_di;
  
!     di->di_flags = DI_FLAGS_FIX | DI_FLAGS_RO;
!     di->di_tv.v_type = VAR_NUMBER;
!     di->di_tv.v_lock = VAR_FIXED;
!     di->di_tv.vval.v_number = 0;
! 
!     STRCPY(buf->b_ct_di.di_key, "changedtick");
!     (void)dict_add(buf->b_vars, di);
  }
  
  /*
***************
*** 919,930 ****
      }
  #ifdef FEAT_EVAL
      {
! 	varnumber_T tick = *buf->b_changedtick;
  
  	vars_clear(&buf->b_vars->dv_hashtab); /* free all buffer variables */
  	hash_init(&buf->b_vars->dv_hashtab);
  	init_changedtick(buf);
! 	*buf->b_changedtick = tick;
      }
  #endif
  #ifdef FEAT_USR_CMDS
--- 907,918 ----
      }
  #ifdef FEAT_EVAL
      {
! 	varnumber_T tick = CHANGEDTICK(buf);
  
  	vars_clear(&buf->b_vars->dv_hashtab); /* free all buffer variables */
  	hash_init(&buf->b_vars->dv_hashtab);
  	init_changedtick(buf);
! 	CHANGEDTICK(buf) = tick;
      }
  #endif
  #ifdef FEAT_USR_CMDS
*** ../vim-8.0.0364/src/edit.c	2017-02-23 18:08:51.324806489 +0100
--- src/edit.c	2017-02-25 14:44:35.111655103 +0100
***************
*** 1668,1674 ****
  #ifdef FEAT_AUTOCMD
      /* Trigger TextChangedI if b_changedtick differs. */
      if (ready && has_textchangedI()
! 	    && last_changedtick != *curbuf->b_changedtick
  # ifdef FEAT_INS_EXPAND
  	    && !pum_visible()
  # endif
--- 1668,1674 ----
  #ifdef FEAT_AUTOCMD
      /* Trigger TextChangedI if b_changedtick differs. */
      if (ready && has_textchangedI()
! 	    && last_changedtick != CHANGEDTICK(curbuf)
  # ifdef FEAT_INS_EXPAND
  	    && !pum_visible()
  # endif
***************
*** 1677,1683 ****
  	if (last_changedtick_buf == curbuf)
  	    apply_autocmds(EVENT_TEXTCHANGEDI, NULL, NULL, FALSE, curbuf);
  	last_changedtick_buf = curbuf;
! 	last_changedtick = *curbuf->b_changedtick;
      }
  #endif
  
--- 1677,1683 ----
  	if (last_changedtick_buf == curbuf)
  	    apply_autocmds(EVENT_TEXTCHANGEDI, NULL, NULL, FALSE, curbuf);
  	last_changedtick_buf = curbuf;
! 	last_changedtick = CHANGEDTICK(curbuf);
      }
  #endif
  
*** ../vim-8.0.0364/src/evalfunc.c	2017-02-21 20:47:09.966394747 +0100
--- src/evalfunc.c	2017-02-25 14:45:27.639327794 +0100
***************
*** 2550,2556 ****
      if (lnum < 0)	/* ignore type error in {lnum} arg */
  	lnum = 0;
      if (lnum != prev_lnum
! 	    || changedtick != *curbuf->b_changedtick
  	    || fnum != curbuf->b_fnum)
      {
  	/* New line, buffer, change: need to get the values. */
--- 2550,2556 ----
      if (lnum < 0)	/* ignore type error in {lnum} arg */
  	lnum = 0;
      if (lnum != prev_lnum
! 	    || changedtick != CHANGEDTICK(curbuf)
  	    || fnum != curbuf->b_fnum)
      {
  	/* New line, buffer, change: need to get the values. */
***************
*** 2572,2578 ****
  	else
  	    hlID = (hlf_T)0;
  	prev_lnum = lnum;
! 	changedtick = *curbuf->b_changedtick;
  	fnum = curbuf->b_fnum;
      }
  
--- 2572,2578 ----
  	else
  	    hlID = (hlf_T)0;
  	prev_lnum = lnum;
! 	changedtick = CHANGEDTICK(curbuf);
  	fnum = curbuf->b_fnum;
      }
  
***************
*** 3957,3963 ****
      dict_add_nr_str(dict, "loaded", buf->b_ml.ml_mfp != NULL, NULL);
      dict_add_nr_str(dict, "listed", buf->b_p_bl, NULL);
      dict_add_nr_str(dict, "changed", bufIsChanged(buf), NULL);
!     dict_add_nr_str(dict, "changedtick", *buf->b_changedtick, NULL);
      dict_add_nr_str(dict, "hidden",
  		    buf->b_ml.ml_mfp != NULL && buf->b_nwindows == 0,
  		    NULL);
--- 3957,3963 ----
      dict_add_nr_str(dict, "loaded", buf->b_ml.ml_mfp != NULL, NULL);
      dict_add_nr_str(dict, "listed", buf->b_p_bl, NULL);
      dict_add_nr_str(dict, "changed", bufIsChanged(buf), NULL);
!     dict_add_nr_str(dict, "changedtick", CHANGEDTICK(buf), NULL);
      dict_add_nr_str(dict, "hidden",
  		    buf->b_ml.ml_mfp != NULL && buf->b_nwindows == 0,
  		    NULL);
*** ../vim-8.0.0364/src/ex_docmd.c	2017-02-17 16:31:16.921294136 +0100
--- src/ex_docmd.c	2017-02-25 14:45:58.859133297 +0100
***************
*** 660,666 ****
  	need_wait_return = FALSE;
  	ex_pressedreturn = FALSE;
  	ex_no_reprint = FALSE;
! 	changedtick = *curbuf->b_changedtick;
  	prev_msg_row = msg_row;
  	prev_line = curwin->w_cursor.lnum;
  	if (improved)
--- 660,666 ----
  	need_wait_return = FALSE;
  	ex_pressedreturn = FALSE;
  	ex_no_reprint = FALSE;
! 	changedtick = CHANGEDTICK(curbuf);
  	prev_msg_row = msg_row;
  	prev_line = curwin->w_cursor.lnum;
  	if (improved)
***************
*** 673,679 ****
  	lines_left = Rows - 1;
  
  	if ((prev_line != curwin->w_cursor.lnum
! 		   || changedtick != *curbuf->b_changedtick) && !ex_no_reprint)
  	{
  	    if (curbuf->b_ml.ml_flags & ML_EMPTY)
  		EMSG(_(e_emptybuf));
--- 673,679 ----
  	lines_left = Rows - 1;
  
  	if ((prev_line != curwin->w_cursor.lnum
! 		   || changedtick != CHANGEDTICK(curbuf)) && !ex_no_reprint)
  	{
  	    if (curbuf->b_ml.ml_flags & ML_EMPTY)
  		EMSG(_(e_emptybuf));
*** ../vim-8.0.0364/src/fileio.c	2017-02-17 16:31:16.925294107 +0100
--- src/fileio.c	2017-02-25 14:46:43.194857144 +0100
***************
*** 4924,4934 ****
      {
  	unchanged(buf, TRUE);
  #ifdef FEAT_AUTOCMD
! 	/* buf->b_changedtick is always incremented in unchanged() but that
  	 * should not trigger a TextChanged event. */
! 	if (last_changedtick + 1 == *buf->b_changedtick
  					       && last_changedtick_buf == buf)
! 	    last_changedtick = *buf->b_changedtick;
  #endif
  	u_unchanged(buf);
  	u_update_save_nr(buf);
--- 4924,4934 ----
      {
  	unchanged(buf, TRUE);
  #ifdef FEAT_AUTOCMD
! 	/* b:changedtick is always incremented in unchanged() but that
  	 * should not trigger a TextChanged event. */
! 	if (last_changedtick + 1 == CHANGEDTICK(buf)
  					       && last_changedtick_buf == buf)
! 	    last_changedtick = CHANGEDTICK(buf);
  #endif
  	u_unchanged(buf);
  	u_update_save_nr(buf);
*** ../vim-8.0.0364/src/main.c	2017-02-17 16:31:16.921294136 +0100
--- src/main.c	2017-02-25 14:52:12.920805203 +0100
***************
*** 1162,1176 ****
  #endif
  
  #ifdef FEAT_AUTOCMD
! 	    /* Trigger TextChanged if b_changedtick differs. */
  	    if (!finish_op && has_textchanged()
! 		    && last_changedtick != *curbuf->b_changedtick)
  	    {
  		if (last_changedtick_buf == curbuf)
  		    apply_autocmds(EVENT_TEXTCHANGED, NULL, NULL,
  							       FALSE, curbuf);
  		last_changedtick_buf = curbuf;
! 		last_changedtick = *curbuf->b_changedtick;
  	    }
  #endif
  
--- 1162,1176 ----
  #endif
  
  #ifdef FEAT_AUTOCMD
! 	    /* Trigger TextChanged if b:changedtick differs. */
  	    if (!finish_op && has_textchanged()
! 		    && last_changedtick != CHANGEDTICK(curbuf))
  	    {
  		if (last_changedtick_buf == curbuf)
  		    apply_autocmds(EVENT_TEXTCHANGED, NULL, NULL,
  							       FALSE, curbuf);
  		last_changedtick_buf = curbuf;
! 		last_changedtick = CHANGEDTICK(curbuf);
  	    }
  #endif
  
***************
*** 1388,1398 ****
  		    /* Autocmd must have close the buffer already, skip. */
  		    continue;
  		buf = wp->w_buffer;
! 		if (buf->b_ct_val != -1)
  		{
  		    apply_autocmds(EVENT_BUFWINLEAVE, buf->b_fname,
  						    buf->b_fname, FALSE, buf);
! 		    buf->b_ct_val = -1;  /* note that we did it already */
  		    /* start all over, autocommands may mess up the lists */
  		    next_tp = first_tabpage;
  		    break;
--- 1388,1398 ----
  		    /* Autocmd must have close the buffer already, skip. */
  		    continue;
  		buf = wp->w_buffer;
! 		if (CHANGEDTICK(buf) != -1)
  		{
  		    apply_autocmds(EVENT_BUFWINLEAVE, buf->b_fname,
  						    buf->b_fname, FALSE, buf);
! 		    CHANGEDTICK(buf) = -1;  /* note that we did it already */
  		    /* start all over, autocommands may mess up the lists */
  		    next_tp = first_tabpage;
  		    break;
*** ../vim-8.0.0364/src/memline.c	2017-02-18 16:58:44.264503901 +0100
--- src/memline.c	2017-02-25 14:48:03.078359721 +0100
***************
*** 1649,1655 ****
  	if (!(curbuf->b_ml.ml_line_count == 2 && *ml_get(1) == NUL))
  	{
  	    changed_int();
! 	    ++*curbuf->b_changedtick;
  	}
      }
      else
--- 1649,1655 ----
  	if (!(curbuf->b_ml.ml_line_count == 2 && *ml_get(1) == NUL))
  	{
  	    changed_int();
! 	    ++CHANGEDTICK(curbuf);
  	}
      }
      else
***************
*** 1663,1669 ****
  	    if (i != 0)
  	    {
  		changed_int();
! 		++*curbuf->b_changedtick;
  		break;
  	    }
  	}
--- 1663,1669 ----
  	    if (i != 0)
  	    {
  		changed_int();
! 		++CHANGEDTICK(curbuf);
  		break;
  	    }
  	}
*** ../vim-8.0.0364/src/misc1.c	2017-02-23 17:07:10.308599718 +0100
--- src/misc1.c	2017-02-25 14:49:15.509908867 +0100
***************
*** 502,512 ****
  
      /* used cached indent, unless pointer or 'tabstop' changed */
      if (prev_line != line || prev_ts != wp->w_buffer->b_p_ts
! 				  || prev_tick != *wp->w_buffer->b_changedtick)
      {
  	prev_line = line;
  	prev_ts = wp->w_buffer->b_p_ts;
! 	prev_tick = *wp->w_buffer->b_changedtick;
  	prev_indent = get_indent_str(line,
  				     (int)wp->w_buffer->b_p_ts, wp->w_p_list);
      }
--- 502,512 ----
  
      /* used cached indent, unless pointer or 'tabstop' changed */
      if (prev_line != line || prev_ts != wp->w_buffer->b_p_ts
! 				  || prev_tick != CHANGEDTICK(wp->w_buffer))
      {
  	prev_line = line;
  	prev_ts = wp->w_buffer->b_p_ts;
! 	prev_tick = CHANGEDTICK(wp->w_buffer);
  	prev_indent = get_indent_str(line,
  				     (int)wp->w_buffer->b_p_ts, wp->w_p_list);
      }
***************
*** 2768,2774 ****
  	}
  	changed_int();
      }
!     ++*curbuf->b_changedtick;
  }
  
  /*
--- 2768,2774 ----
  	}
  	changed_int();
      }
!     ++CHANGEDTICK(curbuf);
  }
  
  /*
***************
*** 3195,3201 ****
  	need_maketitle = TRUE;	    /* set window title later */
  #endif
      }
!     ++*buf->b_changedtick;
  #ifdef FEAT_NETBEANS_INTG
      netbeans_unmodified(buf);
  #endif
--- 3195,3201 ----
  	need_maketitle = TRUE;	    /* set window title later */
  #endif
      }
!     ++CHANGEDTICK(buf);
  #ifdef FEAT_NETBEANS_INTG
      netbeans_unmodified(buf);
  #endif
*** ../vim-8.0.0364/src/syntax.c	2017-02-17 16:31:16.929294079 +0100
--- src/syntax.c	2017-02-25 14:49:57.257649075 +0100
***************
*** 516,528 ****
       */
      if (syn_block != wp->w_s
  	    || syn_buf != wp->w_buffer
! 	    || changedtick != *syn_buf->b_changedtick)
      {
  	invalidate_current_state();
  	syn_buf = wp->w_buffer;
  	syn_block = wp->w_s;
      }
!     changedtick = *syn_buf->b_changedtick;
      syn_win = wp;
  
      /*
--- 516,528 ----
       */
      if (syn_block != wp->w_s
  	    || syn_buf != wp->w_buffer
! 	    || changedtick != CHANGEDTICK(syn_buf))
      {
  	invalidate_current_state();
  	syn_buf = wp->w_buffer;
  	syn_block = wp->w_s;
      }
!     changedtick = CHANGEDTICK(syn_buf);
      syn_win = wp;
  
      /*
*** ../vim-8.0.0364/src/version.c	2017-02-25 14:20:56.784372170 +0100
--- src/version.c	2017-02-25 14:56:48.031095489 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     365,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
22. You've already visited all the links at Yahoo and you're halfway through
    Lycos.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0366
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0366 (after 8.0.0365)
Problem:    Build fails with tiny features.
Solution:   Add #ifdef.
Files:      src/buffer.c


*** ../vim-8.0.0365/src/buffer.c	2017-02-25 14:59:29.902090452 +0100
--- src/buffer.c	2017-02-25 15:37:05.619913236 +0100
***************
*** 885,892 ****
--- 885,894 ----
      di->di_tv.v_lock = VAR_FIXED;
      di->di_tv.vval.v_number = 0;
  
+ #ifdef FEAT_EVAL
      STRCPY(buf->b_ct_di.di_key, "changedtick");
      (void)dict_add(buf->b_vars, di);
+ #endif
  }
  
  /*
*** ../vim-8.0.0365/src/version.c	2017-02-25 14:59:29.910090402 +0100
--- src/version.c	2017-02-25 15:41:01.498403671 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     366,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
23. You can't call your mother...she doesn't have a modem.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0367
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0367
Problem:    If configure defines _LARGE_FILES some include files are included
            before it is defined.
Solution:   Include vim.h first. (Sam Thursfield, closes #1508)
Files:      src/gui_at_sb.c, src/gui_athena.c, src/gui_motif.c, src/gui_x11.c,
            src/gui_xmdlg.c


*** ../vim-8.0.0366/src/gui_at_sb.c	2016-08-29 22:42:20.000000000 +0200
--- src/gui_at_sb.c	2017-02-25 15:53:35.521594542 +0100
***************
*** 60,70 ****
  /* created by weissman, Mon Jul  7 13:20:03 1986 */
  /* converted by swick, Thu Aug 27 1987 */
  
  #include <X11/IntrinsicP.h>
  #include <X11/StringDefs.h>
  
  #include <X11/Xaw/XawInit.h>
- #include "vim.h"
  #include "gui_at_sb.h"
  
  #include <X11/Xmu/Drawing.h>
--- 60,71 ----
  /* created by weissman, Mon Jul  7 13:20:03 1986 */
  /* converted by swick, Thu Aug 27 1987 */
  
+ #include "vim.h"
+ 
  #include <X11/IntrinsicP.h>
  #include <X11/StringDefs.h>
  
  #include <X11/Xaw/XawInit.h>
  #include "gui_at_sb.h"
  
  #include <X11/Xmu/Drawing.h>
*** ../vim-8.0.0366/src/gui_athena.c	2016-08-29 22:42:20.000000000 +0200
--- src/gui_athena.c	2017-02-25 15:53:35.521594542 +0100
***************
*** 9,14 ****
--- 9,16 ----
   * See README.txt for an overview of the Vim source code.
   */
  
+ #include "vim.h"
+ 
  #include <X11/StringDefs.h>
  #include <X11/Intrinsic.h>
  #ifdef FEAT_GUI_NEXTAW
***************
*** 34,40 ****
  # include <X11/Xaw/AsciiText.h>
  #endif /* FEAT_GUI_NEXTAW */
  
- #include "vim.h"
  #ifndef FEAT_GUI_NEXTAW
  # include "gui_at_sb.h"
  #endif
--- 36,41 ----
*** ../vim-8.0.0366/src/gui_motif.c	2016-08-29 22:42:20.000000000 +0200
--- src/gui_motif.c	2017-02-25 15:53:35.521594542 +0100
***************
*** 8,13 ****
--- 8,15 ----
   * See README.txt for an overview of the Vim source code.
   */
  
+ #include "vim.h"
+ 
  #include <Xm/Form.h>
  #include <Xm/RowColumn.h>
  #include <Xm/PushB.h>
***************
*** 33,40 ****
  #include <X11/StringDefs.h>
  #include <X11/Intrinsic.h>
  
- #include "vim.h"
- 
  #ifdef HAVE_X11_XPM_H
  # include <X11/xpm.h>
  #else
--- 35,40 ----
*** ../vim-8.0.0366/src/gui_x11.c	2016-08-29 22:42:20.000000000 +0200
--- src/gui_x11.c	2017-02-25 15:53:35.521594542 +0100
***************
*** 12,17 ****
--- 12,19 ----
   * Not used for GTK.
   */
  
+ #include "vim.h"
+ 
  #include <X11/keysym.h>
  #include <X11/Xatom.h>
  #include <X11/StringDefs.h>
***************
*** 19,26 ****
  #include <X11/Shell.h>
  #include <X11/cursorfont.h>
  
- #include "vim.h"
- 
  /*
   * For Workshop XpmP.h is preferred, because it makes the signs drawn with a
   * transparent background instead of black.
--- 21,26 ----
*** ../vim-8.0.0366/src/gui_xmdlg.c	2016-08-29 22:42:20.000000000 +0200
--- src/gui_xmdlg.c	2017-02-25 15:53:35.521594542 +0100
***************
*** 16,21 ****
--- 16,23 ----
   * when using a dynamic scrollbar policy.
   */
  
+ #include "vim.h"
+ 
  #include <Xm/Form.h>
  #include <Xm/PushBG.h>
  #include <Xm/Text.h>
***************
*** 36,43 ****
  #include <X11/StringDefs.h>
  #include <X11/Intrinsic.h>
  
- #include "vim.h"
- 
  extern Widget vimShell;
  
  #ifdef FEAT_MENU
--- 38,43 ----
*** ../vim-8.0.0366/src/version.c	2017-02-25 15:41:33.142201356 +0100
--- src/version.c	2017-02-25 16:00:23.462981271 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     367,
  /**/

-- 
Computers are useless. They can only give you answers.
                -- Pablo Picasso

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0368
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0368
Problem:    Not all options are tested with a range of values.
Solution:   Generate a test script from the source code.
Files:      Filelist, src/gen_opt_test.vim, src/testdir/test_options.vim,
            src/Makefile


*** ../vim-8.0.0367/Filelist	2017-02-23 19:32:18.068709554 +0100
--- Filelist	2017-02-25 18:16:57.298760316 +0100
***************
*** 97,102 ****
--- 97,103 ----
  		src/tee/tee.c \
  		src/xxd/xxd.c \
  		src/main.aap \
+ 		src/gen_opt_test.vim \
  		src/testdir/main.aap \
  		src/testdir/README.txt \
  		src/testdir/Make_all.mak \
*** ../vim-8.0.0367/src/gen_opt_test.vim	2017-02-25 20:39:44.794990022 +0100
--- src/gen_opt_test.vim	2017-02-25 20:37:27.243850294 +0100
***************
*** 0 ****
--- 1,190 ----
+ " Script to generate testdir/opt_test.vim from option.c
+ 
+ if 0
+   finish
+ endif
+ 
+ set cpo=&vim
+ set nomore
+ 
+ let script = [
+       \ 'let save_columns = &columns',
+       \ 'let save_lines = &lines',
+       \ 'let save_term = &term',
+       \ ]
+ 
+ edit option.c
+ /#define p_term
+ let end = line('.')
+ 
+ " Two lists with values: values that work and values that fail.
+ " When not listed, "othernum" or "otherstring" is used.
+ let test_values = {
+       \ 'cmdheight': [[1, 2, 10], [-1, 0]],
+       \ 'cmdwinheight': [[1, 2, 10], [-1, 0]],
+       \ 'columns': [[12, 80], [-1, 0, 10]],
+       \ 'conceallevel': [[0, 1, 2, 3], [-1, 4, 99]],
+       \ 'foldcolumn': [[0, 1, 4, 12], [-1, 13, 999]],
+       \ 'helpheight': [[0, 10, 100], [-1]],
+       \ 'history': [[0, 1, 100], [-1, 10001]],
+       \ 'iminsert': [[0, 1, 2], [-1, 3, 999]],
+       \ 'imsearch': [[-1, 0, 1, 2], [-2, 3, 999]],
+       \ 'lines': [[2, 24], [-1, 0, 1]],
+       \ 'numberwidth': [[1, 4, 8, 10], [-1, 0, 11]],
+       \ 'regexpengine': [[0, 1, 2], [-1, 3, 999]],
+       \ 'report': [[0, 1, 2, 9999], [-1]],
+       \ 'scroll': [[0, 1, 2, 20], [-1]],
+       \ 'scrolljump': [[-50, -1, 0, 1, 2, 20], [999]],
+       \ 'scrolloff': [[0, 1, 2, 20], [-1]],
+       \ 'shiftwidth': [[0, 1, 8, 999], [-1]],
+       \ 'sidescroll': [[0, 1, 8, 999], [-1]],
+       \ 'sidescrolloff': [[0, 1, 8, 999], [-1]],
+       \ 'tabstop': [[1, 4, 8, 12], [-1, 0]],
+       \ 'textwidth': [[0, 1, 8, 99], [-1]],
+       \ 'timeoutlen': [[0, 8, 99999], [-1]],
+       \ 'titlelen': [[0, 1, 8, 9999], [-1]],
+       \ 'updatecount': [[0, 1, 8, 9999], [-1]],
+       \ 'updatetime': [[0, 1, 8, 9999], [-1]],
+       \ 'verbose': [[-1, 0, 1, 8, 9999], []],
+       \ 'winheight': [[1, 10, 999], [-1, 0]],
+       \ 'winminheight': [[0, 1], [-1]],
+       \ 'winminwidth': [[0, 1, 10], [-1]],
+       \ 'winwidth': [[1, 10, 999], [-1, 0]],
+       \
+       \ 'ambiwidth': [['', 'single'], ['xxx']],
+       \ 'background': [['', 'light', 'dark'], ['xxx']],
+       \ 'backspace': [[0, 2, '', 'eol', 'eol,start'], ['xxx']],
+       \ 'backupcopy': [['yes', 'auto'], ['', 'xxx', 'yes,no']],
+       \ 'backupext': [['xxx'], ['']],
+       \ 'belloff': [['', 'all', 'copy,error'], ['xxx']],
+       \ 'breakindentopt': [['', 'min:3', 'sbr'], ['xxx', 'min', 'min:x']],
+       \ 'browsedir': [['', 'last', '/tmp/'], ['xxx']],
+       \ 'bufhidden': [['', 'hide', 'wipe'], ['xxx', 'hide,wipe']],
+       \ 'buftype': [['', 'help', 'nofile'], ['xxx', 'help,nofile']],
+       \ 'casemap': [['', 'internal'], ['xxx']],
+       \ 'cedit': [['', '\<Esc>'], ['xxx', 'f']],
+       \ 'clipboard': [['', 'unnamed', 'autoselect,unnamed'], ['xxx']],
+       \ 'colorcolumn': [['', '8', '+2'], ['xxx']],
+       \ 'comments': [['', 'b:#'], ['xxx']],
+       \ 'commentstring': [['', '/*%s*/'], ['xxx']],
+       \ 'complete': [['', 'w,b'], ['xxx']],
+       \ 'concealcursor': [['', 'n', 'nvic'], ['xxx']],
+       \ 'completeopt': [['', 'menu', 'menu,longest'], ['xxx', 'menu,,,longest,']],
+       \ 'cryptmethod': [['', 'zip'], ['xxx']],
+       \ 'cscopequickfix': [['', 's-', 's-,c+,e0'], ['xxx', 's,g,d']],
+       \ 'debug': [['', 'msg', 'msg', 'beep'], ['xxx']],
+       \ 'diffopt': [['', 'filler', 'icase,iwhite'], ['xxx']],
+       \ 'display': [['', 'lastline', 'lastline,uhex'], ['xxx']],
+       \ 'eadirection': [['', 'both', 'ver'], ['xxx', 'ver,hor']],
+       \ 'encoding': [['latin1'], ['xxx', '']],
+       \ 'eventignore': [['', 'WinEnter', 'WinLeave,winenter'], ['xxx']],
+       \ 'fileencoding': [['', 'latin1', 'xxx'], []],
+       \ 'fileformat': [['', 'dos', 'unix'], ['xxx']],
+       \ 'fileformats': [['', 'dos', 'dos,unix'], ['xxx']],
+       \ 'fillchars': [['', 'vert:x'], ['xxx']],
+       \ 'foldclose': [['', 'all'], ['xxx']],
+       \ 'foldmethod': [['manual', 'indent'], ['', 'xxx', 'expr,diff']],
+       \ 'foldopen': [['', 'all', 'hor,jump'], ['xxx']],
+       \ 'foldmarker': [['((,))'], ['', 'xxx']],
+       \ 'formatoptions': [['', 'vt', 'v,t'], ['xxx']],
+       \ 'guicursor': [['', 'n:block-Cursor'], ['xxx']],
+       \ 'helplang': [['', 'de', 'de,it'], ['xxx']],
+       \ 'highlight': [['', 'e:Error'], ['xxx']],
+       \ 'isfname': [['', '@', '@,48-52'], ['xxx', '@48']],
+       \ 'isident': [['', '@', '@,48-52'], ['xxx', '@48']],
+       \ 'iskeyword': [['', '@', '@,48-52'], ['xxx', '@48']],
+       \ 'isprint': [['', '@', '@,48-52'], ['xxx', '@48']],
+       \ 'keymap': [['', 'accents'], ['xxx']],
+       \ 'keymodel': [['', 'startsel', 'startsel,stopsel'], ['xxx']],
+       \ 'langmap': [['', 'xX', 'aA,bB'], ['xxx']],
+       \ 'listchars': [['', 'eol:x', 'eol:x,space:y'], ['xxx']],
+       \ 'matchpairs': [['', '(:)', '(:),<:>'], ['xxx']],
+       \ 'mkspellmem': [['10000,100,12'], ['', 'xxx']],
+       \ 'mouse': [['', 'a', 'nvi'], ['xxx', 'n,v,i']],
+       \ 'mousemodel': [['', 'popup'], ['xxx']],
+       \ 'mouseshape': [['', 'n:arrow'], ['xxx']],
+       \ 'nrformats': [['', 'alpha', 'alpha,hex,bin'], ['xxx']],
+       \ 'printmbfont': [['', 'r:some', 'b:Bold,c:yes'], ['xxx']],
+       \ 'printoptions': [['', 'header:0', 'left:10pc,top:5pc'], ['xxx']],
+       \ 'scrollopt': [['', 'ver', 'ver,hor'], ['xxx']],
+       \ 'selection': [['old', 'inclusive'], ['', 'xxx']],
+       \ 'selectmode': [['', 'mouse', 'key,cmd'], ['xxx']],
+       \ 'sessionoptions': [['', 'blank', 'help,options,slash'], ['xxx']],
+       \ 'signcolumn': [['', 'auto', 'no'], ['xxx', 'no,yes']],
+       \ 'spellfile': [['', 'file.en.add'], ['xxx', '/tmp/file']],
+       \ 'spellsuggest': [['', 'best', 'double,33'], ['xxx']],
+       \ 'switchbuf': [['', 'useopen', 'split,newtab'], ['xxx']],
+       \ 'tagcase': [['smart', 'match'], ['', 'xxx', 'smart,match']],
+       \ 'term': [['ansi'], ['', 'gui']],
+       \ 'toolbar': [['', 'icons', 'text'], ['xxx']],
+       \ 'toolbariconsize': [['', 'tiny', 'huge'], ['xxx']],
+       \ 'ttymouse': [['', 'xterm'], ['xxx']],
+       \ 'ttytype': [['ansi'], ['', 'gui']],
+       \ 'viewoptions': [['', 'cursor', 'unix,slash'], ['xxx']],
+       \ 'viminfo': [['', '''50', '"30'], ['xxx']],
+       \ 'virtualedit': [['', 'all', 'all,block'], ['xxx']],
+       \ 'whichwrap': [['', 'b,s', 'bs'], ['xxx']],
+       \ 'wildmode': [['', 'full', 'list:full', 'full,longest'], ['xxx']],
+       \ 'wildoptions': [['', 'tagfile'], ['xxx']],
+       \ 'winaltkeys': [['menu', 'no'], ['', 'xxx']],
+       \
+       \ 'luadll': [[], []],
+       \ 'macatsui': [[], []],
+       \ 'perldll': [[], []],
+       \ 'pythondll': [[], []],
+       \ 'pythonthreedll': [[], []],
+       \ 'pyxversion': [[], []],
+       \ 'rubydll': [[], []],
+       \ 'tcldll': [[], []],
+       \
+       \ 'othernum': [[-1, 0, 100], []],
+       \ 'otherstring': [['', 'xxx'], []],
+       \}
+ 
+ 1
+ /struct vimoption options
+ while 1
+   /{"
+   if line('.') > end
+     break
+   endif
+   let line = getline('.')
+   let name = substitute(line, '.*{"\([^"]*\)".*', '\1', '')
+   let shortname = substitute(line, '.*"\([^"]*\)".*', '\1', '')
+ 
+   if has_key(test_values, name)
+     let a = test_values[name]
+   elseif line =~ 'P_NUM'
+     let a = test_values['othernum']
+   else
+     let a = test_values['otherstring']
+   endif
+   if len(a[0]) > 0 || len(a[1]) > 0
+     if line =~ 'P_BOOL'
+       call add(script, 'set ' . name)
+       call add(script, 'set ' . shortname)
+       call add(script, 'set no' . name)
+       call add(script, 'set no' . shortname)
+     else
+       for val in a[0]
+ 	call add(script, 'set ' . name . '=' . val)
+ 	call add(script, 'set ' . shortname . '=' . val)
+       endfor
+       for val in a[1]
+ 	call add(script, "call assert_fails('set " . name . "=" . val . "')")
+ 	call add(script, "call assert_fails('set " . shortname . "=" . val . "')")
+       endfor
+     endif
+ 
+     call add(script, 'set ' . name . '&')
+     call add(script, 'set ' . shortname . '&')
+   endif
+ endwhile
+ 
+ call add(script, 'let &term = save_term')
+ call add(script, 'let &columns = save_columns')
+ call add(script, 'let &lines = save_lines')
+ 
+ call writefile(script, 'testdir/opt_test.vim')
+ 
+ qa!
*** ../vim-8.0.0367/src/testdir/test_options.vim	2017-02-23 18:08:51.328806464 +0100
--- src/testdir/test_options.vim	2017-02-25 20:26:27.319902222 +0100
***************
*** 275,277 ****
--- 275,295 ----
      call assert_equal(&ttytype, &term)
    endif
  endfunc
+ 
+ func Test_set_all()
+   set tw=75
+   set iskeyword=a-z,A-Z
+   set nosplitbelow
+   let out = execute('set all')
+   call assert_match('textwidth=75', out)
+   call assert_match('iskeyword=a-z,A-Z', out)
+   call assert_match('nosplitbelow', out)
+   set tw& iskeyword& splitbelow&
+ endfunc
+ 
+ func Test_set_values()
+   " The file is only generated when running "make test" in the src directory.
+   if filereadable('opt_test.vim')
+     source opt_test.vim
+   endif
+ endfunc
*** ../vim-8.0.0367/src/Makefile	2017-02-25 14:20:56.784372170 +0100
--- src/Makefile	2017-02-25 20:22:22.541404084 +0100
***************
*** 2025,2030 ****
--- 2025,2031 ----
  #
  scripttests:
  	$(MAKE) -f Makefile $(VIMTARGET)
+ 	$(MAKE) -f Makefile testdir/opt_test.vim
  	if test -n "$(MAKEMO)" -a -f $(PODIR)/Makefile; then \
  		cd $(PODIR); $(MAKE) -f Makefile check VIM=../$(VIMTARGET); \
  	fi
***************
*** 2033,2038 ****
--- 2034,2041 ----
  	fi
  	cd testdir; $(MAKE) -f Makefile $(GUI_TESTTARGET) VIMPROG=../$(VIMTARGET) $(GUI_TESTARG) SCRIPTSOURCE=../$(SCRIPTSOURCE)
  
+ testdir/opt_test.vim: option.c gen_opt_test.vim
+ 	./$(VIMTARGET) -u gen_opt_test.vim --noplugin --not-a-term
  
  # Run the tests with the GUI.  Assumes vim/gvim was already built
  testgui:
***************
*** 2753,2758 ****
--- 2756,2762 ----
  	-rm -f *.o objects/* core $(VIMTARGET).core $(VIMTARGET) vim xxd/*.o
  	-rm -f $(TOOLS) auto/osdef.h auto/pathdef.c auto/if_perl.c auto/gui_gtk_gresources.c auto/gui_gtk_gresources.h
  	-rm -f conftest* *~ auto/link.sed
+ 	-rm -f testdir/opt_test.vim
  	-rm -f $(UNITTEST_TARGETS)
  	-rm -f runtime pixmaps
  	-rm -rf $(APPDIR)
***************
*** 2767,2773 ****
  
  shadow:	runtime pixmaps
  	mkdir $(SHADOWDIR)
! 	cd $(SHADOWDIR); ln -s ../*.[chm] ../*.in ../*.sh ../*.xs ../*.xbm ../gui_gtk_res.xml ../toolcheck ../proto ../vimtutor ../gvimtutor ../mkinstalldirs .
  	mkdir $(SHADOWDIR)/auto
  	cd $(SHADOWDIR)/auto; ln -s ../../auto/configure .
  	mkdir $(SHADOWDIR)/po
--- 2771,2777 ----
  
  shadow:	runtime pixmaps
  	mkdir $(SHADOWDIR)
! 	cd $(SHADOWDIR); ln -s ../*.[chm] ../*.in ../*.vim ../*.sh ../*.xs ../*.xbm ../gui_gtk_res.xml ../toolcheck ../proto ../vimtutor ../gvimtutor ../mkinstalldirs .
  	mkdir $(SHADOWDIR)/auto
  	cd $(SHADOWDIR)/auto; ln -s ../../auto/configure .
  	mkdir $(SHADOWDIR)/po
*** ../vim-8.0.0367/src/version.c	2017-02-25 16:01:41.062484813 +0100
--- src/version.c	2017-02-25 20:38:31.223450054 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     368,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
25. You believe nothing looks sexier than a man in boxer shorts illuminated
    only by a 17" inch svga monitor.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0369
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0369 (after 8.0.0368)
Problem:    The 'balloondelay', 'ballooneval' and 'balloonexpr' options are
            not defined without the +balloon_eval feature. Testing that an
            option value fails does not work for unsupported options.
Solution:   Make the options defined but not supported.  Don't test if
            setting unsupported options fails.
Files:      src/option.c, src/gen_opt_test.vim


*** ../vim-8.0.0368/src/option.c	2017-02-23 17:18:33.340295191 +0100
--- src/option.c	2017-02-25 20:52:23.178260314 +0100
***************
*** 624,642 ****
  			    {(char_u *)0L, (char_u *)0L}
  #endif
  			    SCRIPTID_INIT},
- #ifdef FEAT_BEVAL
      {"balloondelay","bdlay",P_NUM|P_VI_DEF,
  			    (char_u *)&p_bdlay, PV_NONE,
! 			    {(char_u *)600L, (char_u *)0L} SCRIPTID_INIT},
      {"ballooneval", "beval",P_BOOL|P_VI_DEF|P_NO_MKRC,
  			    (char_u *)&p_beval, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
! # ifdef FEAT_EVAL
      {"balloonexpr", "bexpr", P_STRING|P_ALLOCED|P_VI_DEF|P_VIM,
  			    (char_u *)&p_bexpr, PV_BEXPR,
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
! # endif
  #endif
      {"beautify",    "bf",   P_BOOL|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
--- 624,656 ----
  			    {(char_u *)0L, (char_u *)0L}
  #endif
  			    SCRIPTID_INIT},
      {"balloondelay","bdlay",P_NUM|P_VI_DEF,
+ #ifdef FEAT_BEVAL
  			    (char_u *)&p_bdlay, PV_NONE,
! 			    {(char_u *)600L, (char_u *)0L}
! #else
! 			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L}
! #endif
! 			    SCRIPTID_INIT},
      {"ballooneval", "beval",P_BOOL|P_VI_DEF|P_NO_MKRC,
+ #ifdef FEAT_BEVAL
  			    (char_u *)&p_beval, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}
! #else
! 			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L}
! #endif
! 			    SCRIPTID_INIT},
      {"balloonexpr", "bexpr", P_STRING|P_ALLOCED|P_VI_DEF|P_VIM,
+ #if defined(FEAT_BEVAL) && defined(FEAT_EVAL)
  			    (char_u *)&p_bexpr, PV_BEXPR,
! 			    {(char_u *)"", (char_u *)0L}
! #else
! 			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L}
  #endif
+ 			    SCRIPTID_INIT},
      {"beautify",    "bf",   P_BOOL|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
*** ../vim-8.0.0368/src/gen_opt_test.vim	2017-02-25 20:40:31.758696482 +0100
--- src/gen_opt_test.vim	2017-02-25 21:09:39.243830189 +0100
***************
*** 27,34 ****
        \ 'foldcolumn': [[0, 1, 4, 12], [-1, 13, 999]],
        \ 'helpheight': [[0, 10, 100], [-1]],
        \ 'history': [[0, 1, 100], [-1, 10001]],
!       \ 'iminsert': [[0, 1, 2], [-1, 3, 999]],
!       \ 'imsearch': [[-1, 0, 1, 2], [-2, 3, 999]],
        \ 'lines': [[2, 24], [-1, 0, 1]],
        \ 'numberwidth': [[1, 4, 8, 10], [-1, 0, 11]],
        \ 'regexpengine': [[0, 1, 2], [-1, 3, 999]],
--- 27,34 ----
        \ 'foldcolumn': [[0, 1, 4, 12], [-1, 13, 999]],
        \ 'helpheight': [[0, 10, 100], [-1]],
        \ 'history': [[0, 1, 100], [-1, 10001]],
!       \ 'iminsert': [[0, 1], [-1, 3, 999]],
!       \ 'imsearch': [[-1, 0, 1], [-2, 3, 999]],
        \ 'lines': [[2, 24], [-1, 0, 1]],
        \ 'numberwidth': [[1, 4, 8, 10], [-1, 0, 11]],
        \ 'regexpengine': [[0, 1, 2], [-1, 3, 999]],
***************
*** 170,179 ****
--- 170,183 ----
  	call add(script, 'set ' . name . '=' . val)
  	call add(script, 'set ' . shortname . '=' . val)
        endfor
+ 
+       " setting an option can only fail when it's implemented.
+       call add(script, "if exists('+" . name . "')")
        for val in a[1]
  	call add(script, "call assert_fails('set " . name . "=" . val . "')")
  	call add(script, "call assert_fails('set " . shortname . "=" . val . "')")
        endfor
+       call add(script, "endif")
      endif
  
      call add(script, 'set ' . name . '&')
*** ../vim-8.0.0368/src/version.c	2017-02-25 20:40:31.762696457 +0100
--- src/version.c	2017-02-25 20:54:08.261606602 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     369,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
27. You refer to your age as 3.x.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0370
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0370
Problem:    Invalid memory access when setting wildchar empty.
Solution:   Avoid going over the end of the option value. (Dominique Pelle,
            closes #1509)  Make option test check all number options with
            empty value.
Files:      src/gen_opt_test.vim, src/option.c, src/testdir/test_options.vim


*** ../vim-8.0.0369/src/gen_opt_test.vim	2017-02-25 21:12:25.418784376 +0100
--- src/gen_opt_test.vim	2017-02-25 21:23:34.874399493 +0100
***************
*** 46,51 ****
--- 46,52 ----
        \ 'updatecount': [[0, 1, 8, 9999], [-1]],
        \ 'updatetime': [[0, 1, 8, 9999], [-1]],
        \ 'verbose': [[-1, 0, 1, 8, 9999], []],
+       \ 'wildcharm': [[-1, 0, 100], []],
        \ 'winheight': [[1, 10, 999], [-1, 0]],
        \ 'winminheight': [[0, 1], [-1]],
        \ 'winminwidth': [[0, 1, 10], [-1]],
***************
*** 137,143 ****
        \ 'rubydll': [[], []],
        \ 'tcldll': [[], []],
        \
!       \ 'othernum': [[-1, 0, 100], []],
        \ 'otherstring': [['', 'xxx'], []],
        \}
  
--- 138,144 ----
        \ 'rubydll': [[], []],
        \ 'tcldll': [[], []],
        \
!       \ 'othernum': [[-1, 0, 100], ['']],
        \ 'otherstring': [['', 'xxx'], []],
        \}
  
*** ../vim-8.0.0369/src/option.c	2017-02-25 21:12:25.418784376 +0100
--- src/option.c	2017-02-25 21:27:46.256760999 +0100
***************
*** 4612,4618 ****
  				    || (long *)varp == &p_wcm)
  				&& (*arg == '<'
  				    || *arg == '^'
! 				    || ((!arg[1] || vim_iswhite(arg[1]))
  					&& !VIM_ISDIGIT(*arg))))
  			{
  			    value = string_to_key(arg);
--- 4612,4618 ----
  				    || (long *)varp == &p_wcm)
  				&& (*arg == '<'
  				    || *arg == '^'
! 				    || (*arg != NUL && (!arg[1] || vim_iswhite(arg[1]))
  					&& !VIM_ISDIGIT(*arg))))
  			{
  			    value = string_to_key(arg);
***************
*** 5843,5849 ****
  							   opt_flags)) == NULL)
  	    did_set_option(opt_idx, opt_flags, TRUE);
  
! 	/* call autocomamnd after handling side effects */
  #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
  	if (saved_oldval != NULL)
  	{
--- 5843,5849 ----
  							   opt_flags)) == NULL)
  	    did_set_option(opt_idx, opt_flags, TRUE);
  
! 	/* call autocommand after handling side effects */
  #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
  	if (saved_oldval != NULL)
  	{
*** ../vim-8.0.0369/src/testdir/test_options.vim	2017-02-25 20:40:31.758696482 +0100
--- src/testdir/test_options.vim	2017-02-25 21:27:13.784972419 +0100
***************
*** 29,34 ****
--- 29,47 ----
    set isfname&
  endfunction
  
+ function Test_wildchar()
+   " Empty 'wildchar' used to access invalid memory.
+   call assert_fails('set wildchar=', 'E521:')
+   call assert_fails('set wildchar=abc', 'E521:')
+   set wildchar=<Esc>
+   let a=execute('set wildchar?')
+   call assert_equal("\n  wildchar=<Esc>", a)
+   set wildchar=27
+   let a=execute('set wildchar?')
+   call assert_equal("\n  wildchar=<Esc>", a)
+   set wildchar&
+ endfunction
+ 
  function Test_options()
    let caught = 'ok'
    try
*** ../vim-8.0.0369/src/version.c	2017-02-25 21:12:25.418784376 +0100
--- src/version.c	2017-02-25 21:26:49.201132526 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     370,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
28. You have comandeered your teenager's phone line for the net and even his
    friends know not to call on his line anymore.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0371
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0371 (after 8.0.0365)
Problem:    Leaking memory when setting v:completed_item.
Solution:   Or the flags instead of setting them.
Files:      src/eval.c


*** ../vim-8.0.0370/src/eval.c	2017-02-23 19:00:28.508904228 +0100
--- src/eval.c	2017-02-25 21:33:30.890402599 +0100
***************
*** 6640,6646 ****
  	    if (HASHITEM_EMPTY(hi))
  		continue;
  	    --todo;
! 	    HI2DI(hi)->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;
  	}
      }
  }
--- 6640,6646 ----
  	    if (HASHITEM_EMPTY(hi))
  		continue;
  	    --todo;
! 	    HI2DI(hi)->di_flags |= DI_FLAGS_RO | DI_FLAGS_FIX;
  	}
      }
  }
*** ../vim-8.0.0370/src/version.c	2017-02-25 21:37:53.872571889 +0100
--- src/version.c	2017-02-25 21:38:50.224181115 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     371,
  /**/

-- 
Anyone who is capable of getting themselves made President should on no
account be allowed to do the job.
		-- Douglas Adams, "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0372
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0372
Problem:    More options are not always defined.
Solution:   Consistently define all possible options.
Files:      src/option.c, src/testdir/test_expand_dllpath.vim


*** ../vim-8.0.0371/src/option.c	2017-02-25 21:37:53.872571889 +0100
--- src/option.c	2017-02-25 22:08:40.155918120 +0100
***************
*** 559,569 ****
  			    {(char_u *)0L, (char_u *)0L}
  #endif
  			    SCRIPTID_INIT},
- #ifdef FEAT_AUTOCHDIR
      {"autochdir",  "acd",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_acd, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
  #endif
      {"autoindent",  "ai",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_ai, PV_AI,
  			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
--- 559,573 ----
  			    {(char_u *)0L, (char_u *)0L}
  #endif
  			    SCRIPTID_INIT},
      {"autochdir",  "acd",   P_BOOL|P_VI_DEF,
+ #ifdef FEAT_AUTOCHDIR
  			    (char_u *)&p_acd, PV_NONE,
! 			    {(char_u *)FALSE, (char_u *)0L}
! #else
! 			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L}
  #endif
+ 			    SCRIPTID_INIT},
      {"autoindent",  "ai",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_ai, PV_AI,
  			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
***************
*** 1210,1271 ****
      {"flash",	    "fl",   P_BOOL|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
- #ifdef FEAT_FOLDING
      {"foldclose",   "fcl",  P_STRING|P_VI_DEF|P_ONECOMMA|P_NODUP|P_RWIN,
  			    (char_u *)&p_fcl, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"foldcolumn",  "fdc",  P_NUM|P_VI_DEF|P_RWIN,
  			    (char_u *)VAR_WIN, PV_FDC,
! 			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"foldenable",  "fen",  P_BOOL|P_VI_DEF|P_RWIN,
  			    (char_u *)VAR_WIN, PV_FEN,
! 			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
      {"foldexpr",    "fde",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
! # ifdef FEAT_EVAL
  			    (char_u *)VAR_WIN, PV_FDE,
  			    {(char_u *)"0", (char_u *)NULL}
! # else
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
! # endif
  			    SCRIPTID_INIT},
      {"foldignore",  "fdi",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
  			    (char_u *)VAR_WIN, PV_FDI,
! 			    {(char_u *)"#", (char_u *)NULL} SCRIPTID_INIT},
      {"foldlevel",   "fdl",  P_NUM|P_VI_DEF|P_RWIN,
  			    (char_u *)VAR_WIN, PV_FDL,
! 			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
      {"foldlevelstart","fdls", P_NUM|P_VI_DEF|P_CURSWANT,
  			    (char_u *)&p_fdls, PV_NONE,
! 			    {(char_u *)-1L, (char_u *)0L} SCRIPTID_INIT},
      {"foldmarker",  "fmr",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|
  						    P_RWIN|P_ONECOMMA|P_NODUP,
  			    (char_u *)VAR_WIN, PV_FMR,
  			    {(char_u *)"{{{,}}}", (char_u *)NULL}
  			    SCRIPTID_INIT},
      {"foldmethod",  "fdm",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
  			    (char_u *)VAR_WIN, PV_FDM,
! 			    {(char_u *)"manual", (char_u *)NULL} SCRIPTID_INIT},
      {"foldminlines","fml",  P_NUM|P_VI_DEF|P_RWIN,
  			    (char_u *)VAR_WIN, PV_FML,
! 			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
      {"foldnestmax", "fdn",  P_NUM|P_VI_DEF|P_RWIN,
  			    (char_u *)VAR_WIN, PV_FDN,
! 			    {(char_u *)20L, (char_u *)0L} SCRIPTID_INIT},
      {"foldopen",    "fdo",  P_STRING|P_VI_DEF|P_ONECOMMA|P_NODUP|P_CURSWANT,
  			    (char_u *)&p_fdo, PV_NONE,
  		 {(char_u *)"block,hor,mark,percent,quickfix,search,tag,undo",
! 						 (char_u *)0L} SCRIPTID_INIT},
      {"foldtext",    "fdt",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
! # ifdef FEAT_EVAL
  			    (char_u *)VAR_WIN, PV_FDT,
  			    {(char_u *)"foldtext()", (char_u *)NULL}
! # else
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
- # endif
- 			    SCRIPTID_INIT},
  #endif
      {"formatexpr", "fex",   P_STRING|P_ALLOCED|P_VI_DEF|P_VIM,
  #ifdef FEAT_EVAL
  			    (char_u *)&p_fex, PV_FEX,
--- 1214,1338 ----
      {"flash",	    "fl",   P_BOOL|P_VI_DEF,
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"foldclose",   "fcl",  P_STRING|P_VI_DEF|P_ONECOMMA|P_NODUP|P_RWIN,
+ #ifdef FEAT_FOLDING
  			    (char_u *)&p_fcl, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L}
! #else
! 			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)NULL, (char_u *)0L}
! #endif
! 			    SCRIPTID_INIT},
      {"foldcolumn",  "fdc",  P_NUM|P_VI_DEF|P_RWIN,
+ #ifdef FEAT_FOLDING
  			    (char_u *)VAR_WIN, PV_FDC,
! 			    {(char_u *)FALSE, (char_u *)0L}
! #else
! 			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)NULL, (char_u *)0L}
! #endif
! 			    SCRIPTID_INIT},
      {"foldenable",  "fen",  P_BOOL|P_VI_DEF|P_RWIN,
+ #ifdef FEAT_FOLDING
  			    (char_u *)VAR_WIN, PV_FEN,
! 			    {(char_u *)TRUE, (char_u *)0L}
! #else
! 			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)NULL, (char_u *)0L}
! #endif
! 			    SCRIPTID_INIT},
      {"foldexpr",    "fde",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
! #if defined(FEAT_FOLDING) && defined(FEAT_EVAL)
  			    (char_u *)VAR_WIN, PV_FDE,
  			    {(char_u *)"0", (char_u *)NULL}
! #else
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
! #endif
  			    SCRIPTID_INIT},
      {"foldignore",  "fdi",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
+ #ifdef FEAT_FOLDING
  			    (char_u *)VAR_WIN, PV_FDI,
! 			    {(char_u *)"#", (char_u *)NULL}
! #else
! 			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)NULL, (char_u *)0L}
! #endif
! 			    SCRIPTID_INIT},
      {"foldlevel",   "fdl",  P_NUM|P_VI_DEF|P_RWIN,
+ #ifdef FEAT_FOLDING
  			    (char_u *)VAR_WIN, PV_FDL,
! 			    {(char_u *)0L, (char_u *)0L}
! #else
! 			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)NULL, (char_u *)0L}
! #endif
! 			    SCRIPTID_INIT},
      {"foldlevelstart","fdls", P_NUM|P_VI_DEF|P_CURSWANT,
+ #ifdef FEAT_FOLDING
  			    (char_u *)&p_fdls, PV_NONE,
! 			    {(char_u *)-1L, (char_u *)0L}
! #else
! 			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)NULL, (char_u *)0L}
! #endif
! 			    SCRIPTID_INIT},
      {"foldmarker",  "fmr",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|
+ #ifdef FEAT_FOLDING
  						    P_RWIN|P_ONECOMMA|P_NODUP,
  			    (char_u *)VAR_WIN, PV_FMR,
  			    {(char_u *)"{{{,}}}", (char_u *)NULL}
+ #else
+ 			    (char_u *)NULL, PV_NONE,
+ 			    {(char_u *)NULL, (char_u *)0L}
+ #endif
  			    SCRIPTID_INIT},
      {"foldmethod",  "fdm",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
+ #ifdef FEAT_FOLDING
  			    (char_u *)VAR_WIN, PV_FDM,
! 			    {(char_u *)"manual", (char_u *)NULL}
! #else
! 			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)NULL, (char_u *)0L}
! #endif
! 			    SCRIPTID_INIT},
      {"foldminlines","fml",  P_NUM|P_VI_DEF|P_RWIN,
+ #ifdef FEAT_FOLDING
  			    (char_u *)VAR_WIN, PV_FML,
! 			    {(char_u *)1L, (char_u *)0L}
! #else
! 			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)NULL, (char_u *)0L}
! #endif
! 			    SCRIPTID_INIT},
      {"foldnestmax", "fdn",  P_NUM|P_VI_DEF|P_RWIN,
+ #ifdef FEAT_FOLDING
  			    (char_u *)VAR_WIN, PV_FDN,
! 			    {(char_u *)20L, (char_u *)0L}
! #else
! 			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)NULL, (char_u *)0L}
! #endif
! 			    SCRIPTID_INIT},
      {"foldopen",    "fdo",  P_STRING|P_VI_DEF|P_ONECOMMA|P_NODUP|P_CURSWANT,
+ #ifdef FEAT_FOLDING
  			    (char_u *)&p_fdo, PV_NONE,
  		 {(char_u *)"block,hor,mark,percent,quickfix,search,tag,undo",
! 						 (char_u *)0L}
! #else
! 			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)NULL, (char_u *)0L}
! #endif
! 			    SCRIPTID_INIT},
      {"foldtext",    "fdt",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|P_RWIN,
! #if defined(FEAT_FOLDING) && defined(FEAT_EVAL)
  			    (char_u *)VAR_WIN, PV_FDT,
  			    {(char_u *)"foldtext()", (char_u *)NULL}
! #else
  			    (char_u *)NULL, PV_NONE,
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
+ 			    SCRIPTID_INIT},
      {"formatexpr", "fex",   P_STRING|P_ALLOCED|P_VI_DEF|P_VIM,
  #ifdef FEAT_EVAL
  			    (char_u *)&p_fex, PV_FEX,
***************
*** 1803,1819 ****
      {"loadplugins", "lpl",  P_BOOL|P_VI_DEF,
  			    (char_u *)&p_lpl, PV_NONE,
  			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
- #if defined(DYNAMIC_LUA)
      {"luadll",      NULL,   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_luadll, PV_NONE,
  			    {(char_u *)DYNAMIC_LUA_DLL, (char_u *)0L}
! 			    SCRIPTID_INIT},
  #endif
! #ifdef FEAT_GUI_MAC
      {"macatsui",    NULL,   P_BOOL|P_VI_DEF|P_RCLR,
  			    (char_u *)&p_macatsui, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
  #endif
      {"magic",	    NULL,   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_magic, PV_NONE,
  			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
--- 1870,1893 ----
      {"loadplugins", "lpl",  P_BOOL|P_VI_DEF,
  			    (char_u *)&p_lpl, PV_NONE,
  			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
      {"luadll",      NULL,   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
+ #if defined(DYNAMIC_LUA)
  			    (char_u *)&p_luadll, PV_NONE,
  			    {(char_u *)DYNAMIC_LUA_DLL, (char_u *)0L}
! #else
! 			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"macatsui",    NULL,   P_BOOL|P_VI_DEF|P_RCLR,
+ #ifdef FEAT_GUI_MAC
  			    (char_u *)&p_macatsui, PV_NONE,
! 			    {(char_u *)TRUE, (char_u *)0L}
! #else
! 			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)"", (char_u *)0L}
  #endif
+ 			    SCRIPTID_INIT},
      {"magic",	    NULL,   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_magic, PV_NONE,
  			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
***************
*** 2045,2056 ****
  			    (char_u *)".,/usr/include,,",
  #endif
  				(char_u *)0L} SCRIPTID_INIT},
- #if defined(DYNAMIC_PERL)
      {"perldll",     NULL,   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_perldll, PV_NONE,
  			    {(char_u *)DYNAMIC_PERL_DLL, (char_u *)0L}
! 			    SCRIPTID_INIT},
  #endif
      {"preserveindent", "pi", P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_pi, PV_PI,
  			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
--- 2119,2133 ----
  			    (char_u *)".,/usr/include,,",
  #endif
  				(char_u *)0L} SCRIPTID_INIT},
      {"perldll",     NULL,   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
+ #if defined(DYNAMIC_PERL)
  			    (char_u *)&p_perldll, PV_NONE,
  			    {(char_u *)DYNAMIC_PERL_DLL, (char_u *)0L}
! #else
! 			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L}
  #endif
+ 			    SCRIPTID_INIT},
      {"preserveindent", "pi", P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_pi, PV_PI,
  			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
***************
*** 2156,2173 ****
  			    (char_u *)NULL, PV_NONE,
  #endif
  			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
- #if defined(DYNAMIC_PYTHON3)
      {"pythonthreedll",  NULL,   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_py3dll, PV_NONE,
  			    {(char_u *)DYNAMIC_PYTHON3_DLL, (char_u *)0L}
! 			    SCRIPTID_INIT},
  #endif
! #if defined(DYNAMIC_PYTHON)
      {"pythondll",   NULL,   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_pydll, PV_NONE,
  			    {(char_u *)DYNAMIC_PYTHON_DLL, (char_u *)0L}
! 			    SCRIPTID_INIT},
  #endif
      {"pyxversion", "pyx",   P_NUM|P_VI_DEF|P_SECURE,
  #if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)
  			    (char_u *)&p_pyx, PV_NONE,
--- 2233,2256 ----
  			    (char_u *)NULL, PV_NONE,
  #endif
  			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
      {"pythonthreedll",  NULL,   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
+ #if defined(DYNAMIC_PYTHON3)
  			    (char_u *)&p_py3dll, PV_NONE,
  			    {(char_u *)DYNAMIC_PYTHON3_DLL, (char_u *)0L}
! #else
! 			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)NULL, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"pythondll",   NULL,   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
+ #if defined(DYNAMIC_PYTHON)
  			    (char_u *)&p_pydll, PV_NONE,
  			    {(char_u *)DYNAMIC_PYTHON_DLL, (char_u *)0L}
! #else
! 			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)NULL, (char_u *)0L}
  #endif
+ 			    SCRIPTID_INIT},
      {"pyxversion", "pyx",   P_NUM|P_VI_DEF|P_SECURE,
  #if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3)
  			    (char_u *)&p_pyx, PV_NONE,
***************
*** 2249,2260 ****
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
  			    SCRIPTID_INIT},
- #if defined(DYNAMIC_RUBY)
      {"rubydll",     NULL,   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_rubydll, PV_NONE,
  			    {(char_u *)DYNAMIC_RUBY_DLL, (char_u *)0L}
! 			    SCRIPTID_INIT},
  #endif
      {"ruler",	    "ru",   P_BOOL|P_VI_DEF|P_VIM|P_RSTAT,
  #ifdef FEAT_CMDL_INFO
  			    (char_u *)&p_ru, PV_NONE,
--- 2332,2346 ----
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
  			    SCRIPTID_INIT},
      {"rubydll",     NULL,   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
+ #if defined(DYNAMIC_RUBY)
  			    (char_u *)&p_rubydll, PV_NONE,
  			    {(char_u *)DYNAMIC_RUBY_DLL, (char_u *)0L}
! #else
! 			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)NULL, (char_u *)0L}
  #endif
+ 			    SCRIPTID_INIT},
      {"ruler",	    "ru",   P_BOOL|P_VI_DEF|P_VIM|P_RSTAT,
  #ifdef FEAT_CMDL_INFO
  			    (char_u *)&p_ru, PV_NONE,
***************
*** 2642,2653 ****
      {"tagstack",    "tgst", P_BOOL|P_VI_DEF,
  			    (char_u *)&p_tgst, PV_NONE,
  			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
- #if defined(DYNAMIC_TCL)
      {"tcldll",      NULL,   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  			    (char_u *)&p_tcldll, PV_NONE,
  			    {(char_u *)DYNAMIC_TCL_DLL, (char_u *)0L}
! 			    SCRIPTID_INIT},
  #endif
      {"term",	    NULL,   P_STRING|P_EXPAND|P_NODEFAULT|P_NO_MKRC|P_VI_DEF|P_RALL,
  			    (char_u *)&T_NAME, PV_NONE,
  			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
--- 2728,2742 ----
      {"tagstack",    "tgst", P_BOOL|P_VI_DEF,
  			    (char_u *)&p_tgst, PV_NONE,
  			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
      {"tcldll",      NULL,   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
+ #if defined(DYNAMIC_TCL)
  			    (char_u *)&p_tcldll, PV_NONE,
  			    {(char_u *)DYNAMIC_TCL_DLL, (char_u *)0L}
! #else
! 			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L}
  #endif
+ 			    SCRIPTID_INIT},
      {"term",	    NULL,   P_STRING|P_EXPAND|P_NODEFAULT|P_NO_MKRC|P_VI_DEF|P_RALL,
  			    (char_u *)&T_NAME, PV_NONE,
  			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
***************
*** 2742,2758 ****
  			    (char_u *)NULL, PV_NONE,
  #endif
  			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
- #if defined(FEAT_TOOLBAR) && !defined(FEAT_GUI_W32)
      {"toolbar",     "tb",   P_STRING|P_ONECOMMA|P_VI_DEF|P_NODUP,
  			    (char_u *)&p_toolbar, PV_NONE,
  			    {(char_u *)"icons,tooltips", (char_u *)0L}
! 			    SCRIPTID_INIT},
  #endif
! #if defined(FEAT_TOOLBAR) && defined(FEAT_GUI_GTK)
      {"toolbariconsize",	"tbis", P_STRING|P_VI_DEF,
  			    (char_u *)&p_tbis, PV_NONE,
! 			    {(char_u *)"small", (char_u *)0L} SCRIPTID_INIT},
  #endif
      {"ttimeout",    NULL,   P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_ttimeout, PV_NONE,
  			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
--- 2831,2854 ----
  			    (char_u *)NULL, PV_NONE,
  #endif
  			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"toolbar",     "tb",   P_STRING|P_ONECOMMA|P_VI_DEF|P_NODUP,
+ #if defined(FEAT_TOOLBAR) && !defined(FEAT_GUI_W32)
  			    (char_u *)&p_toolbar, PV_NONE,
  			    {(char_u *)"icons,tooltips", (char_u *)0L}
! #else
! 			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L}
  #endif
! 			    SCRIPTID_INIT},
      {"toolbariconsize",	"tbis", P_STRING|P_VI_DEF,
+ #if defined(FEAT_TOOLBAR) && defined(FEAT_GUI_GTK)
  			    (char_u *)&p_tbis, PV_NONE,
! 			    {(char_u *)"small", (char_u *)0L}
! #else
! 			    (char_u *)NULL, PV_NONE,
! 			    {(char_u *)0L, (char_u *)0L}
  #endif
+ 			    SCRIPTID_INIT},
      {"ttimeout",    NULL,   P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_ttimeout, PV_NONE,
  			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
*** ../vim-8.0.0371/src/testdir/test_expand_dllpath.vim	2016-07-21 20:04:54.000000000 +0200
--- src/testdir/test_expand_dllpath.vim	2017-02-25 22:14:49.477288503 +0100
***************
*** 14,20 ****
  endfunc
  
  func s:generate_test_if_exists(optname)
!   if exists('&' . a:optname)
      execute join([
            \ 'func Test_expand_' . a:optname . '()',
            \ '  call s:test_expand_dllpath("' . a:optname . '")',
--- 14,20 ----
  endfunc
  
  func s:generate_test_if_exists(optname)
!   if exists('+' . a:optname)
      execute join([
            \ 'func Test_expand_' . a:optname . '()',
            \ '  call s:test_expand_dllpath("' . a:optname . '")',
*** ../vim-8.0.0371/src/version.c	2017-02-25 21:39:13.300021243 +0100
--- src/version.c	2017-02-25 21:49:03.335961364 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     372,
  /**/

-- 
Bypasses are devices that allow some people to dash from point A to
point B very fast while other people dash from point B to point A very
fast.  People living at point C, being a point directly in between, are
often given to wonder what's so great about point A that so many people
from point B are so keen to get there and what's so great about point B
that so many people from point A are so keen to get there.  They often
wish that people would just once and for all work out where the hell
they wanted to be.
		-- Douglas Adams, "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0373
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0373
Problem:    Build fails without +folding.
Solution:   Move misplaced #ifdef.
Files:      src/option.c


*** ../vim-8.0.0372/src/option.c	2017-02-25 22:18:38.435667187 +0100
--- src/option.c	2017-02-25 22:36:08.436308261 +0100
***************
*** 1278,1285 ****
  #endif
  			    SCRIPTID_INIT},
      {"foldmarker",  "fmr",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|
- #ifdef FEAT_FOLDING
  						    P_RWIN|P_ONECOMMA|P_NODUP,
  			    (char_u *)VAR_WIN, PV_FMR,
  			    {(char_u *)"{{{,}}}", (char_u *)NULL}
  #else
--- 1278,1285 ----
  #endif
  			    SCRIPTID_INIT},
      {"foldmarker",  "fmr",  P_STRING|P_ALLOCED|P_VIM|P_VI_DEF|
  						    P_RWIN|P_ONECOMMA|P_NODUP,
+ #ifdef FEAT_FOLDING
  			    (char_u *)VAR_WIN, PV_FMR,
  			    {(char_u *)"{{{,}}}", (char_u *)NULL}
  #else
*** ../vim-8.0.0372/src/version.c	2017-02-25 22:18:38.435667187 +0100
--- src/version.c	2017-02-25 22:36:39.096095077 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     373,
  /**/

-- 
Don't Panic!
		-- The Hitchhiker's Guide to the Galaxy

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0374
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0374
Problem:    Invalid memory access when using :sc in Ex mode. (Dominique Pelle)
Solution:   Avoid the column being negative.  Also fix a hang in Ex mode.
Files:      src/ex_getln.c, src/ex_cmds.c, src/testdir/test_substitute.vim


*** ../vim-8.0.0373/src/ex_getln.c	2017-02-23 19:00:28.512904202 +0100
--- src/ex_getln.c	2017-02-26 13:38:24.580726710 +0100
***************
*** 2369,2377 ****
  	if (ga_grow(&line_ga, 40) == FAIL)
  	    break;
  
! 	/* Get one character at a time. */
  	prev_char = c1;
! 	c1 = vgetc();
  
  	/*
  	 * Handle line editing.
--- 2369,2384 ----
  	if (ga_grow(&line_ga, 40) == FAIL)
  	    break;
  
! 	/*
! 	 * Get one character at a time.
! 	 */
  	prev_char = c1;
! 
! 	/* Check for a ":normal" command and no more characters left. */
! 	if (ex_normal_busy > 0 && typebuf.tb_len == 0)
! 	    c1 = '\n';
! 	else
! 	    c1 = vgetc();
  
  	/*
  	 * Handle line editing.
*** ../vim-8.0.0373/src/ex_cmds.c	2017-02-09 11:54:46.742748026 +0100
--- src/ex_cmds.c	2017-02-26 13:39:34.196309654 +0100
***************
*** 5288,5293 ****
--- 5288,5295 ----
  
  			    getvcol(curwin, &curwin->w_cursor, &sc, NULL, NULL);
  			    curwin->w_cursor.col = regmatch.endpos[0].col - 1;
+ 			    if (curwin->w_cursor.col < 0)
+ 				curwin->w_cursor.col = 0;
  			    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &ec);
  			    if (subflags.do_number || curwin->w_p_nu)
  			    {
*** ../vim-8.0.0373/src/testdir/test_substitute.vim	2017-02-17 18:28:20.397563687 +0100
--- src/testdir/test_substitute.vim	2017-02-26 13:23:47.517973575 +0100
***************
*** 106,108 ****
--- 106,116 ----
      endfor
    endfor
  endfunction
+ 
+ func Test_substitute_repeat()
+   " This caused an invalid memory access.
+   split Xfile
+   s/^/x
+   call feedkeys("Qsc\<CR>y", 'tx')
+   bwipe!
+ endfunc
*** ../vim-8.0.0373/src/version.c	2017-02-25 22:37:10.019880144 +0100
--- src/version.c	2017-02-26 13:37:51.412925384 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     374,
  /**/

-- 
For a moment, nothing happened.
Then, after a second or so, nothing continued to happen.
		-- Douglas Adams, "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0375
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0375
Problem:    The "+ register is not tested.
Solution:   Add a test using another Vim instance to change the "+ register.
            (Kazuki Kuriyama)
Files:      src/testdir/test_gui.vim


*** ../vim-8.0.0374/src/testdir/test_gui.vim	2017-02-23 19:32:18.068709554 +0100
--- src/testdir/test_gui.vim	2017-02-26 14:56:41.355400256 +0100
***************
*** 72,77 ****
--- 72,118 ----
    endif
  endfunc
  
+ func Test_quoteplus()
+   let skipped = ''
+ 
+   if !g:x11_based_gui
+     let skipped = g:not_supported . 'quoteplus'
+   else
+     let quoteplus_saved = @+
+ 
+     let test_call     = 'Can you hear me?'
+     let test_response = 'Yes, I can.'
+     let vim_exe = exepath(v:progpath)
+     let testee = 'VIMRUNTIME=' . $VIMRUNTIME . '; export VIMRUNTIME;'
+           \ . vim_exe . ' -f -g -u NONE -U NONE --noplugin -c ''%s'''
+     let cmd = 'call feedkeys("'
+           \ . '\"+p'
+           \ . ':s/' . test_call . '/' . test_response . '/\<CR>'
+           \ . '\"+yis'
+           \ . ':q!\<CR>", "tx")'
+     let run_vimtest = printf(testee, cmd)
+ 
+     " Set the quoteplus register to test_call, and another gvim will launched.
+     " Then, it first tries to paste the content of its own quotedplus register
+     " onto it.  Second, it tries to substitute test_responce for the pasted
+     " sentence.  If the sentence is identical to test_call, the substitution
+     " should succeed.  Third, it tries to yank the result of the substitution
+     " to its own quoteplus register, and last it quits.  When system()
+     " returns, the content of the quoteplus register should be identical to
+     " test_response if those quoteplus registers are synchronized properly
+     " with/through the X11 clipboard.
+     let @+ = test_call
+     call system(run_vimtest)
+     call assert_equal(test_response, @+)
+ 
+     let @+ = quoteplus_saved
+   endif
+ 
+   if !empty(skipped)
+     throw skipped
+   endif
+ endfunc
+ 
  func Test_set_guifont()
    let skipped = ''
  
*** ../vim-8.0.0374/src/version.c	2017-02-26 14:00:03.852862844 +0100
--- src/version.c	2017-02-26 15:00:31.805867406 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     375,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
1. At lunch time, sit in your parked car with sunglasses on and point
   a hair dryer at passing cars. See if they slow down.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0376
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0376
Problem:    Size computations in spell file reading are not exactly right.
Solution:   Make "len" a "long" and check with LONG_MAX.
Files:      src/spellfile.c


*** ../vim-8.0.0375/src/spellfile.c	2017-02-09 21:07:07.040797650 +0100
--- src/spellfile.c	2017-02-26 15:26:20.787791150 +0100
***************
*** 1585,1591 ****
      int		prefixtree,	/* TRUE for the prefix tree */
      int		prefixcnt)	/* when "prefixtree" is TRUE: prefix count */
  {
!     int		len;
      int		idx;
      char_u	*bp;
      idx_T	*ip;
--- 1585,1591 ----
      int		prefixtree,	/* TRUE for the prefix tree */
      int		prefixcnt)	/* when "prefixtree" is TRUE: prefix count */
  {
!     long	len;
      int		idx;
      char_u	*bp;
      idx_T	*ip;
***************
*** 1595,1601 ****
      len = get4c(fd);
      if (len < 0)
  	return SP_TRUNCERROR;
!     if (len >= 0x3ffffff)
  	/* Invalid length, multiply with sizeof(int) would overflow. */
  	return SP_FORMERROR;
      if (len > 0)
--- 1595,1601 ----
      len = get4c(fd);
      if (len < 0)
  	return SP_TRUNCERROR;
!     if (len >= LONG_MAX / (long)sizeof(int))
  	/* Invalid length, multiply with sizeof(int) would overflow. */
  	return SP_FORMERROR;
      if (len > 0)
*** ../vim-8.0.0375/src/version.c	2017-02-26 15:08:17.578786550 +0100
--- src/version.c	2017-02-26 15:24:16.984560380 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     376,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
3. Every time someone asks you to do something, ask if they want fries
   with that.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0377
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0377
Problem:    Possible overflow when reading corrupted undo file.
Solution:   Check if allocated size is not too big. (King)
Files:      src/undo.c


*** ../vim-8.0.0376/src/undo.c	2017-01-17 22:09:41.310252893 +0100
--- src/undo.c	2017-02-26 18:10:43.165993259 +0100
***************
*** 1787,1793 ****
      linenr_T	line_lnum;
      colnr_T	line_colnr;
      linenr_T	line_count;
!     int		num_head = 0;
      long	old_header_seq, new_header_seq, cur_header_seq;
      long	seq_last, seq_cur;
      long	last_save_nr = 0;
--- 1787,1793 ----
      linenr_T	line_lnum;
      colnr_T	line_colnr;
      linenr_T	line_count;
!     long	num_head = 0;
      long	old_header_seq, new_header_seq, cur_header_seq;
      long	seq_last, seq_cur;
      long	last_save_nr = 0;
***************
*** 1974,1980 ****
       * When there are no headers uhp_table is NULL. */
      if (num_head > 0)
      {
! 	uhp_table = (u_header_T **)U_ALLOC_LINE(
  					     num_head * sizeof(u_header_T *));
  	if (uhp_table == NULL)
  	    goto error;
--- 1974,1981 ----
       * When there are no headers uhp_table is NULL. */
      if (num_head > 0)
      {
! 	if (num_head < LONG_MAX / (long)sizeof(u_header_T *))
! 	    uhp_table = (u_header_T **)U_ALLOC_LINE(
  					     num_head * sizeof(u_header_T *));
  	if (uhp_table == NULL)
  	    goto error;
*** ../vim-8.0.0376/src/version.c	2017-02-26 15:27:18.463432807 +0100
--- src/version.c	2017-02-26 18:10:54.129917726 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     377,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
5. Put decaf in the coffee maker for 3 weeks. Once everyone has gotten
   over their caffeine addictions, switch to espresso.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0378
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0378
Problem:    Another possible overflow when reading corrupted undo file.
Solution:   Check if allocated size is not too big. (King)
Files:      src/undo.c


*** ../vim-8.0.0377/src/undo.c	2017-02-26 18:11:32.741651768 +0100
--- src/undo.c	2017-02-26 18:15:58.615822683 +0100
***************
*** 1385,1391 ****
  {
      int		i;
      u_entry_T	*uep;
!     char_u	**array;
      char_u	*line;
      int		line_len;
  
--- 1385,1391 ----
  {
      int		i;
      u_entry_T	*uep;
!     char_u	**array = NULL;
      char_u	*line;
      int		line_len;
  
***************
*** 1402,1408 ****
      uep->ue_size = undo_read_4c(bi);
      if (uep->ue_size > 0)
      {
! 	array = (char_u **)U_ALLOC_LINE(sizeof(char_u *) * uep->ue_size);
  	if (array == NULL)
  	{
  	    *error = TRUE;
--- 1402,1409 ----
      uep->ue_size = undo_read_4c(bi);
      if (uep->ue_size > 0)
      {
! 	if (uep->ue_size < LONG_MAX / (int)sizeof(char_u *))
! 	    array = (char_u **)U_ALLOC_LINE(sizeof(char_u *) * uep->ue_size);
  	if (array == NULL)
  	{
  	    *error = TRUE;
***************
*** 1410,1417 ****
  	}
  	vim_memset(array, 0, sizeof(char_u *) * uep->ue_size);
      }
-     else
- 	array = NULL;
      uep->ue_array = array;
  
      for (i = 0; i < uep->ue_size; ++i)
--- 1411,1416 ----
*** ../vim-8.0.0377/src/version.c	2017-02-26 18:11:32.741651768 +0100
--- src/version.c	2017-02-26 18:16:39.331542915 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     378,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
6. In the memo field of all your checks, write "for sexual favors".

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0379
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0379
Problem:    CTRL-Z and mouse click use CTRL-O unnecessary.
Solution:   Remove stuffing CTRL-O. (James McCoy, closes #1453)
Files:      src/edit.c, src/normal.c


*** ../vim-8.0.0378/src/edit.c	2017-02-25 14:59:29.902090452 +0100
--- src/edit.c	2017-02-26 18:57:40.030814080 +0100
***************
*** 1038,1045 ****
  	    if (!p_im)
  		goto normalchar;	/* insert CTRL-Z as normal char */
  	    do_cmdline_cmd((char_u *)"stop");
! 	    c = Ctrl_O;
! 	    /*FALLTHROUGH*/
  
  	case Ctrl_O:	/* execute one command */
  #ifdef FEAT_COMPL_FUNC
--- 1038,1047 ----
  	    if (!p_im)
  		goto normalchar;	/* insert CTRL-Z as normal char */
  	    do_cmdline_cmd((char_u *)"stop");
! #ifdef CURSOR_SHAPE
! 	    ui_cursor_shape();		/* may need to update cursor shape */
! #endif
! 	    continue;
  
  	case Ctrl_O:	/* execute one command */
  #ifdef FEAT_COMPL_FUNC
*** ../vim-8.0.0378/src/normal.c	2017-02-04 21:34:27.293529871 +0100
--- src/normal.c	2017-02-26 18:59:51.769924816 +0100
***************
*** 2982,2989 ****
  		|| (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)
  	    && bt_quickfix(curbuf))
      {
- 	if (State & INSERT)
- 	    stuffcharReadbuff(Ctrl_O);
  	if (curwin->w_llist_ref == NULL)	/* quickfix window */
  	    do_cmdline_cmd((char_u *)".cc");
  	else					/* location list window */
--- 2982,2987 ----
***************
*** 6193,6202 ****
--- 6191,6202 ----
  #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
      /* In a quickfix window a <CR> jumps to the error under the cursor. */
      if (bt_quickfix(curbuf) && cap->cmdchar == CAR)
+     {
  	if (curwin->w_llist_ref == NULL)
  	    do_cmdline_cmd((char_u *)".cc");	/* quickfix window */
  	else
  	    do_cmdline_cmd((char_u *)".ll");	/* location list window */
+     }
      else
  #endif
      {
*** ../vim-8.0.0378/src/version.c	2017-02-26 18:17:05.855360711 +0100
--- src/version.c	2017-02-26 19:08:49.174299548 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     379,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
8. Don't use any punctuation marks.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0380
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0380
Problem:    With 'linebreak' set and 'breakat' includes ">" a double-wide
            character results in "<<" displayed.
Solution:   Check for the character not to be replaced. (Ozaki Kiichi,
            closes #1456)
Files:      src/screen.c, src/testdir/test_listlbr_utf8.vim


*** ../vim-8.0.0379/src/screen.c	2017-02-23 14:55:55.602643421 +0100
--- src/screen.c	2017-02-26 19:16:23.503358032 +0100
***************
*** 4189,4194 ****
--- 4189,4196 ----
  	}
  	else
  	{
+ 	    int c0;
+ 
  	    if (p_extra_free != NULL)
  	    {
  		vim_free(p_extra_free);
***************
*** 4197,4203 ****
  	    /*
  	     * Get a character from the line itself.
  	     */
! 	    c = *ptr;
  #ifdef FEAT_MBYTE
  	    if (has_mbyte)
  	    {
--- 4199,4205 ----
  	    /*
  	     * Get a character from the line itself.
  	     */
! 	    c0 = c = *ptr;
  #ifdef FEAT_MBYTE
  	    if (has_mbyte)
  	    {
***************
*** 4214,4220 ****
  			/* Overlong encoded ASCII or ASCII with composing char
  			 * is displayed normally, except a NUL. */
  			if (mb_c < 0x80)
! 			    c = mb_c;
  			mb_utf8 = TRUE;
  
  			/* At start of the line we can have a composing char.
--- 4216,4222 ----
  			/* Overlong encoded ASCII or ASCII with composing char
  			 * is displayed normally, except a NUL. */
  			if (mb_c < 0x80)
! 			    c0 = c = mb_c;
  			mb_utf8 = TRUE;
  
  			/* At start of the line we can have a composing char.
***************
*** 4538,4544 ****
  		/*
  		 * Found last space before word: check for line break.
  		 */
! 		if (wp->w_p_lbr && vim_isbreak(c) && !vim_isbreak(*ptr))
  		{
  # ifdef FEAT_MBYTE
  		    int mb_off = has_mbyte ? (*mb_head_off)(line, ptr - 1) : 0;
--- 4540,4547 ----
  		/*
  		 * Found last space before word: check for line break.
  		 */
! 		if (wp->w_p_lbr && c0 == c
! 				      && vim_isbreak(c) && !vim_isbreak(*ptr))
  		{
  # ifdef FEAT_MBYTE
  		    int mb_off = has_mbyte ? (*mb_head_off)(line, ptr - 1) : 0;
*** ../vim-8.0.0379/src/testdir/test_listlbr_utf8.vim	2017-02-05 21:14:26.743355267 +0100
--- src/testdir/test_listlbr_utf8.vim	2017-02-26 19:12:34.960813861 +0100
***************
*** 193,195 ****
--- 193,222 ----
    call s:compare_lines(expect, lines)
    call s:close_windows()
  endfunc
+ 
+ func Test_illegal_byte_and_breakat()
+   call s:test_windows("setl sbr= brk+=<")
+   vert resize 18
+   call setline(1, repeat("\x80", 6))
+   redraw!
+   let lines = s:screen_lines([1, 2], winwidth(0))
+   let expect = [
+ \ "<80><80><80><80><8",
+ \ "0><80>            ",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows('setl brk&vim')
+ endfunc
+ 
+ func Test_multibyte_wrap_and_breakat()
+   call s:test_windows("setl sbr= brk+=>")
+   call setline(1, repeat('a', 17) . repeat('', 2))
+   redraw!
+   let lines = s:screen_lines([1, 2], winwidth(0))
+   let expect = [
+ \ "aaaaaaaaaaaaaaaaa>",
+ \ "                  ",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows('setl brk&vim')
+ endfunc
*** ../vim-8.0.0379/src/version.c	2017-02-26 19:09:01.398217128 +0100
--- src/version.c	2017-02-26 19:17:48.814813913 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     380,
  /**/

-- 
If Pacman had affected us as kids we'd be running around in dark rooms,
munching pills and listening to repetitive music.
                       -- Marcus Brigstocke

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0381
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0381
Problem:    Diff mode is not sufficiently tested.
Solution:   Add more diff mode tests. (Dominique Pelle, closes #1515)
Files:      src/testdir/test_diffmode.vim


*** ../vim-8.0.0380/src/testdir/test_diffmode.vim	2017-02-03 23:16:24.349040487 +0100
--- src/testdir/test_diffmode.vim	2017-02-26 19:57:47.275393904 +0100
***************
*** 272,274 ****
--- 272,349 ----
    call delete('Xtest1')
    call delete('Xtest2')
  endfunc
+ 
+ func Test_diff_move_to()
+   new
+   call setline(1, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
+   diffthis
+   vnew
+   call setline(1, [1, '2x', 3, 4, 4, 5, '6x', 7, '8x', 9, '10x'])
+   diffthis
+   norm ]c
+   call assert_equal(2, line('.'))
+   norm 3]c
+   call assert_equal(9, line('.'))
+   norm 10]c
+   call assert_equal(11, line('.'))
+   norm [c
+   call assert_equal(9, line('.'))
+   norm 2[c
+   call assert_equal(5, line('.'))
+   norm 10[c
+   call assert_equal(2, line('.'))
+   %bwipe!
+ endfunc
+ 
+ func Test_diffpatch()
+   " The patch program on MS-Windows may fail or hang.
+   if !executable('patch') || !has('unix')
+     return
+   endif
+   new
+   insert
+ ***************
+ *** 1,3 ****
+   1
+ ! 2
+   3
+ --- 1,4 ----
+   1
+ ! 2x
+   3
+ + 4
+ .
+   saveas Xpatch
+   bwipe!
+   new
+   call assert_fails('diffpatch Xpatch', 'E816:')
+   call setline(1, ['1', '2', '3'])
+   diffpatch Xpatch
+   call assert_equal(['1', '2x', '3', '4'], getline(1, '$'))
+   call delete('Xpatch')
+   bwipe!
+ endfunc
+ 
+ func Test_diff_too_many_buffers()
+   for i in range(1, 8)
+     exe "new Xtest" . i
+     diffthis
+   endfor
+   new Xtest9
+   call assert_fails('diffthis', 'E96:')
+   %bwipe!
+ endfunc
+ 
+ func Test_diff_nomodifiable()
+   new
+   call setline(1, [1, 2, 3, 4])
+   setl nomodifiable
+   diffthis
+   vnew
+   call setline(1, ['1x', 2, 3, 3, 4])
+   diffthis
+   call assert_fails('norm dp', 'E793:')
+   setl nomodifiable
+   call assert_fails('norm do', 'E21:')
+   %bwipe!
+ endfunc
*** ../vim-8.0.0380/src/version.c	2017-02-26 19:40:55.869921651 +0100
--- src/version.c	2017-02-26 19:45:56.199986586 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     381,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
11. Specify that your drive-through order is "to go".

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0382
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0382 (after 8.0.0380)
Problem:    Warning in tiny build for unused variable. (Tony Mechelynck)
Solution:   Add #ifdefs.
Files:      src/screen.c


*** ../vim-8.0.0381/src/screen.c	2017-02-26 19:40:55.869921651 +0100
--- src/screen.c	2017-02-27 20:31:17.944449891 +0100
***************
*** 4189,4195 ****
--- 4189,4197 ----
  	}
  	else
  	{
+ #ifdef FEAT_LINEBREAK
  	    int c0;
+ #endif
  
  	    if (p_extra_free != NULL)
  	    {
***************
*** 4199,4205 ****
--- 4201,4209 ----
  	    /*
  	     * Get a character from the line itself.
  	     */
+ #ifdef FEAT_LINEBREAK
  	    c0 = c = *ptr;
+ #endif
  #ifdef FEAT_MBYTE
  	    if (has_mbyte)
  	    {
***************
*** 4216,4222 ****
  			/* Overlong encoded ASCII or ASCII with composing char
  			 * is displayed normally, except a NUL. */
  			if (mb_c < 0x80)
! 			    c0 = c = mb_c;
  			mb_utf8 = TRUE;
  
  			/* At start of the line we can have a composing char.
--- 4220,4231 ----
  			/* Overlong encoded ASCII or ASCII with composing char
  			 * is displayed normally, except a NUL. */
  			if (mb_c < 0x80)
! 			{
! 			    c = mb_c;
! # ifdef FEAT_LINEBREAK
! 			    c0 = mb_c;
! # endif
! 			}
  			mb_utf8 = TRUE;
  
  			/* At start of the line we can have a composing char.
*** ../vim-8.0.0381/src/version.c	2017-02-26 19:59:55.578563703 +0100
--- src/version.c	2017-02-27 20:33:17.191681633 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     382,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
17. When the money comes out the ATM, scream "I won!, I won! 3rd
    time this week!!!!!"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0383
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0383 (after 8.0.0382)
Problem:    Misplaced #ifdef. (Christ van Willigen)
Solution:   Split assignment.
Files:      src/screen.c


*** ../vim-8.0.0382/src/screen.c	2017-02-27 20:33:42.351519580 +0100
--- src/screen.c	2017-02-27 21:09:24.853363193 +0100
***************
*** 4201,4208 ****
  	    /*
  	     * Get a character from the line itself.
  	     */
  #ifdef FEAT_LINEBREAK
! 	    c0 = c = *ptr;
  #endif
  #ifdef FEAT_MBYTE
  	    if (has_mbyte)
--- 4201,4209 ----
  	    /*
  	     * Get a character from the line itself.
  	     */
+ 	    c = *ptr;
  #ifdef FEAT_LINEBREAK
! 	    c0 = *ptr;
  #endif
  #ifdef FEAT_MBYTE
  	    if (has_mbyte)
*** ../vim-8.0.0382/src/version.c	2017-02-27 20:33:42.351519580 +0100
--- src/version.c	2017-02-27 21:11:03.560706206 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     383,
  /**/

-- 
In many of the more relaxed civilizations on the Outer Eastern Rim of the
Galaxy, "The Hitchhiker's Guide to the Galaxy" has already supplanted the
great "Encyclopedia Galactica" as the standard repository of all knowledge
and wisdom, for though it has many omissions and contains much that is
apocryphal, or at least wildly inaccurate, it scores over the older, more
pedestrian work in two important respects.
First, it is slightly cheaper; and second, it has the words "DON'T PANIC"
inscribed in large friendly letters on its cover.
		-- Douglas Adams, "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0384
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0384
Problem:    Timer test failed for no apparent reason.
Solution:   Mark the test as flaky.
Files:      src/testdir/runtest.vim


*** ../vim-8.0.0383/src/testdir/runtest.vim	2017-02-23 19:00:28.512904202 +0100
--- src/testdir/runtest.vim	2017-02-27 21:31:45.620474255 +0100
***************
*** 165,170 ****
--- 165,171 ----
        \ 'Test_collapse_buffers()',
        \ 'Test_communicate()',
        \ 'Test_nb_basic()',
+       \ 'Test_oneshot()',
        \ 'Test_pipe_through_sort_all()',
        \ 'Test_pipe_through_sort_some()',
        \ 'Test_reltime()',
*** ../vim-8.0.0383/src/version.c	2017-02-27 21:11:29.992530355 +0100
--- src/version.c	2017-02-27 21:32:48.068061905 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     384,
  /**/

-- 
One difference between a man and a machine is that a machine is quiet
when well oiled.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0385
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0385
Problem:    No tests for arabic.
Solution:   Add a first test for arabic. (Dominique Pelle, closes #1518)
Files:      src/Makefile, src/testdir/Make_all.mak,
            src/testdir/test_arabic.vim


*** ../vim-8.0.0384/src/Makefile	2017-02-25 20:40:31.762696457 +0100
--- src/Makefile	2017-02-27 21:38:03.693920587 +0100
***************
*** 2092,2097 ****
--- 2092,2098 ----
  
  # Run individual NEW style test, assuming that Vim was already compiled.
  test_arglist \
+ 	test_arabic \
  	test_assert \
  	test_assign \
  	test_autochdir \
*** ../vim-8.0.0384/src/testdir/Make_all.mak	2017-02-25 14:20:56.784372170 +0100
--- src/testdir/Make_all.mak	2017-02-27 21:38:03.693920587 +0100
***************
*** 133,139 ****
  
  # Tests using runtest.vim.vim.
  # Keep test_alot*.res as the last one, sort the others.
! NEW_TESTS = test_arglist.res \
  	    test_assert.res \
  	    test_autochdir.res \
  	    test_backspace_opt.res \
--- 133,140 ----
  
  # Tests using runtest.vim.vim.
  # Keep test_alot*.res as the last one, sort the others.
! NEW_TESTS = test_arabic.res \
! 	    test_arglist.res \
  	    test_assert.res \
  	    test_autochdir.res \
  	    test_backspace_opt.res \
*** ../vim-8.0.0384/src/testdir/test_arabic.vim	2017-02-27 21:47:44.373939962 +0100
--- src/testdir/test_arabic.vim	2017-02-27 21:47:12.370158836 +0100
***************
*** 0 ****
--- 1,92 ----
+ " Simplistic testing of Arabic mode.
+ 
+ if !has('arabic')
+   finish
+ endif
+ 
+ set encoding=utf-8
+ scriptencoding utf-8
+ 
+ " Return list of utf8 sequences of each character at line lnum.
+ " Combining characters are treated as a single item.
+ func GetCharsUtf8(lnum)
+   call cursor(a:lnum, 1)
+   let chars = []
+   let numchars = strchars(getline('.'), 1)
+   for i in range(1, numchars)
+     exe 'norm ' i . '|'
+     call add(chars, execute('norm g8'))
+   endfor
+   return chars
+ endfunc
+ 
+ func Test_arabic_toggle()
+   set arabic
+   call assert_equal(1, &rightleft)
+   call assert_equal(1, &arabicshape)
+   call assert_equal('arabic', &keymap)
+   call assert_equal(1, &delcombine)
+ 
+   set iminsert=1 imsearch=1
+   set arabic&
+   call assert_equal(0, &rightleft)
+   call assert_equal(1, &arabicshape)
+   call assert_equal('arabic', &keymap)
+   call assert_equal(1, &delcombine)
+   call assert_equal(0, &iminsert)
+   call assert_equal(-1, &imsearch)
+ 
+   set arabicshape& keymap= delcombine&
+ endfunc
+ 
+ func Test_arabic_input()
+   new
+   set arabic
+   " Typing sghl in Arabic insert mode should show the
+   " Arabic word 'Salaam' i.e. 'peace'.
+   call feedkeys('isghl', 'tx')
+   redraw
+   call assert_equal([
+   \ "\nd8 b3 ",
+   \ "\nd9 84 + d8 a7 ",
+   \ "\nd9 85 "], GetCharsUtf8(1))
+ 
+   " Without shaping, it should give individual Arabic letters.
+   set noarabicshape
+   redraw
+   call assert_equal([
+   \ "\nd8 b3 ",
+   \ "\nd9 84 ",
+   \ "\nd8 a7 ",
+   \ "\nd9 85 "], GetCharsUtf8(1))
+ 
+   set arabicshape&
+   set arabic&
+   bwipe!
+ endfunc
+ 
+ func Test_arabic_toggle_keymap()
+   new
+   set arabic
+   call feedkeys("i12\<C-^>12\<C-^>12", 'tx')
+   redraw
+   call assert_equal('12', getline('.'))
+   set arabic&
+   bwipe!
+ endfunc
+ 
+ func Test_delcombine()
+   new
+   set arabic
+   call feedkeys("isghl\<BS>\<BS>", 'tx')
+   redraw
+   call assert_equal(["\nd8 b3 ", "\nd9 84 "], GetCharsUtf8(1))
+ 
+   " Now the same with nodelcombine
+   set nodelcombine
+   %d
+   call feedkeys("isghl\<BS>\<BS>", 'tx')
+   call assert_equal(["\nd8 b3 "], GetCharsUtf8(1)) 
+   set arabic&
+   bwipe!
+ endfunc
*** ../vim-8.0.0384/src/version.c	2017-02-27 21:35:49.618842663 +0100
--- src/version.c	2017-02-27 21:39:05.661494810 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     385,
  /**/

-- 
I'm not familiar with this proof, but I'm aware of a significant
following of toddlers who believe that peanut butter is the solution
to all of life's problems... 		-- Tim Hammerquist

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0386
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0386
Problem:    Tiny build has a problem with generating the options test.
Solution:   Change the "if" to skip over statements.
Files:      src/gen_opt_test.vim


*** ../vim-8.0.0385/src/gen_opt_test.vim	2017-02-25 21:37:53.868571917 +0100
--- src/gen_opt_test.vim	2017-02-27 22:55:09.666299413 +0100
***************
*** 1,10 ****
  " Script to generate testdir/opt_test.vim from option.c
  
- if 0
-   finish
- endif
- 
  set cpo=&vim
  set nomore
  
  let script = [
--- 1,10 ----
  " Script to generate testdir/opt_test.vim from option.c
  
  set cpo=&vim
+ 
+ " Only do this when build with the +eval feature.
+ if 1
+ 
  set nomore
  
  let script = [
***************
*** 130,136 ****
        \ 'winaltkeys': [['menu', 'no'], ['', 'xxx']],
        \
        \ 'luadll': [[], []],
-       \ 'macatsui': [[], []],
        \ 'perldll': [[], []],
        \ 'pythondll': [[], []],
        \ 'pythonthreedll': [[], []],
--- 130,135 ----
***************
*** 192,195 ****
--- 191,196 ----
  
  call writefile(script, 'testdir/opt_test.vim')
  
+ endif
+ 
  qa!
*** ../vim-8.0.0385/src/version.c	2017-02-27 21:48:06.217790605 +0100
--- src/version.c	2017-02-27 22:56:29.485748868 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     386,
  /**/

-- 
The startling truth finally became apparent, and it was this: Numbers
written on restaurant checks within the confines of restaurants do not follow
the same mathematical laws as numbers written on any other pieces of paper in
any other parts of the Universe.  This single statement took the scientific
world by storm.  So many mathematical conferences got held in such good
restaurants that many of the finest minds of a generation died of obesity and
heart failure, and the science of mathematics was put back by years.
		-- Douglas Adams, "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0387
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0387
Problem:    compiler warnings
Solution:   Add type casts. (Christian Brabandt)
Files:      src/channel.c, src/memline.c


*** ../vim-8.0.0386/src/channel.c	2017-02-06 21:56:04.996335436 +0100
--- src/channel.c	2017-02-28 21:17:38.970334357 +0100
***************
*** 1966,1972 ****
  	     * more (but still incomplete): set a deadline of 100 msec. */
  	    ch_logn(channel,
  		    "Incomplete message (%d bytes) - wait 100 msec for more",
! 		    buflen);
  	    reader.js_used = 0;
  	    chanpart->ch_wait_len = buflen;
  #ifdef WIN32
--- 1966,1972 ----
  	     * more (but still incomplete): set a deadline of 100 msec. */
  	    ch_logn(channel,
  		    "Incomplete message (%d bytes) - wait 100 msec for more",
! 		    (int)buflen);
  	    reader.js_used = 0;
  	    chanpart->ch_wait_len = buflen;
  #ifdef WIN32
***************
*** 3299,3304 ****
--- 3299,3305 ----
  	channel_read(channel, part, "channel_read_block");
      }
  
+     /* We have a complete message now. */
      if (mode == MODE_RAW)
      {
  	msg = channel_get_all(channel, part);
*** ../vim-8.0.0386/src/memline.c	2017-02-25 14:59:29.910090402 +0100
--- src/memline.c	2017-02-28 21:19:27.997595282 +0100
***************
*** 1863,1869 ****
  	    else
  	    {
  #if defined(UNIX) || defined(WIN3264)
! 		int	len = STRLEN(dir_name);
  
  		p = dir_name + len;
  		if (after_pathsep(dir_name, p) && len > 1 && p[-1] == p[-2])
--- 1863,1869 ----
  	    else
  	    {
  #if defined(UNIX) || defined(WIN3264)
! 		int	len = (int)STRLEN(dir_name);
  
  		p = dir_name + len;
  		if (after_pathsep(dir_name, p) && len > 1 && p[-1] == p[-2])
***************
*** 3924,3930 ****
  #endif
  
  #if defined(UNIX) || defined(WIN3264)  /* Need _very_ long file names */
!     int		len = STRLEN(dir_name);
  
      s = dir_name + len;
      if (after_pathsep(dir_name, s) && len > 1 && s[-1] == s[-2])
--- 3924,3930 ----
  #endif
  
  #if defined(UNIX) || defined(WIN3264)  /* Need _very_ long file names */
!     int		len = (int)STRLEN(dir_name);
  
      s = dir_name + len;
      if (after_pathsep(dir_name, s) && len > 1 && s[-1] == s[-2])
*** ../vim-8.0.0386/src/version.c	2017-02-27 22:59:35.524466813 +0100
--- src/version.c	2017-02-28 21:26:00.302982683 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     387,
  /**/

-- 
'Well, here's something to occupy you and keep your mind off things.'
'It won't work, I have an exceptionally large mind.'
		-- Douglas Adams, "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0388
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0388
Problem:    filtering lines through "cat", without changing the line count,
            changes manual folds.
Solution:   Change how marks and folds are adjusted. (Matthew Malcomson, from
            neovim #6194.
Files:      src/fold.c, src/testdir/test_fold.vim


*** ../vim-8.0.0387/src/fold.c	2016-08-29 22:42:20.000000000 +0200
--- src/fold.c	2017-02-28 21:49:29.553420143 +0100
***************
*** 1576,1591 ****
  		{
  		    /* 5. fold is below line1 and contains line2; need to
  		     * correct nested folds too */
- 		    foldMarkAdjustRecurse(&fp->fd_nested, line1 - fp->fd_top,
- 				  line2 - fp->fd_top, amount,
- 				  amount_after + (fp->fd_top - top));
  		    if (amount == MAXLNUM)
  		    {
  			fp->fd_len -= line2 - fp->fd_top + 1;
  			fp->fd_top = line1;
  		    }
  		    else
  		    {
  			fp->fd_len += amount_after - amount;
  			fp->fd_top += amount;
  		    }
--- 1576,1598 ----
  		{
  		    /* 5. fold is below line1 and contains line2; need to
  		     * correct nested folds too */
  		    if (amount == MAXLNUM)
  		    {
+ 			foldMarkAdjustRecurse(&fp->fd_nested,
+ 				  line1 - fp->fd_top,
+ 				  line2 - fp->fd_top,
+ 				  amount,
+ 				  amount_after + (fp->fd_top - top));
  			fp->fd_len -= line2 - fp->fd_top + 1;
  			fp->fd_top = line1;
  		    }
  		    else
  		    {
+ 			foldMarkAdjustRecurse(&fp->fd_nested,
+ 				  line1 - fp->fd_top,
+ 				  line2 - fp->fd_top,
+ 				  amount,
+ 				  amount_after - amount);
  			fp->fd_len += amount_after - amount;
  			fp->fd_top += amount;
  		    }
*** ../vim-8.0.0387/src/testdir/test_fold.vim	2017-01-02 14:57:05.494810156 +0100
--- src/testdir/test_fold.vim	2017-02-28 21:45:38.099010024 +0100
***************
*** 1,6 ****
  " Test for folding
  
! function! Test_address_fold()
    new
    call setline(1, ['int FuncName() {/*{{{*/', 1, 2, 3, 4, 5, '}/*}}}*/',
  	      \ 'after fold 1', 'after fold 2', 'after fold 3'])
--- 1,6 ----
  " Test for folding
  
! func! Test_address_fold()
    new
    call setline(1, ['int FuncName() {/*{{{*/', 1, 2, 3, 4, 5, '}/*}}}*/',
  	      \ 'after fold 1', 'after fold 2', 'after fold 3'])
***************
*** 62,70 ****
    call assert_equal(['4', '5', '}/*}}}*/'], getreg(0,1,1))
  
    quit!
! endfunction
  
! function! Test_indent_fold()
      new
      call setline(1, ['', 'a', '    b', '    c'])
      setl fen fdm=indent
--- 62,70 ----
    call assert_equal(['4', '5', '}/*}}}*/'], getreg(0,1,1))
  
    quit!
! endfunc
  
! func! Test_indent_fold()
      new
      call setline(1, ['', 'a', '    b', '    c'])
      setl fen fdm=indent
***************
*** 72,80 ****
      norm! >>
      let a=map(range(1,4), 'foldclosed(v:val)')
      call assert_equal([-1,-1,-1,-1], a)
! endfu
  
! function! Test_indent_fold()
      new
      call setline(1, ['', 'a', '    b', '    c'])
      setl fen fdm=indent
--- 72,80 ----
      norm! >>
      let a=map(range(1,4), 'foldclosed(v:val)')
      call assert_equal([-1,-1,-1,-1], a)
! endfunc
  
! func! Test_indent_fold()
      new
      call setline(1, ['', 'a', '    b', '    c'])
      setl fen fdm=indent
***************
*** 83,91 ****
      let a=map(range(1,4), 'foldclosed(v:val)')
      call assert_equal([-1,-1,-1,-1], a)
      bw!
! endfu
  
! function! Test_indent_fold2()
      new
      call setline(1, ['', '{{{', '}}}', '{{{', '}}}'])
      setl fen fdm=marker
--- 83,91 ----
      let a=map(range(1,4), 'foldclosed(v:val)')
      call assert_equal([-1,-1,-1,-1], a)
      bw!
! endfunc
  
! func! Test_indent_fold2()
      new
      call setline(1, ['', '{{{', '}}}', '{{{', '}}}'])
      setl fen fdm=marker
***************
*** 94,97 ****
      let a=map(range(1,5), 'foldclosed(v:val)')
      call assert_equal([-1,-1,-1,4,4], a)
      bw!
! endfu
--- 94,114 ----
      let a=map(range(1,5), 'foldclosed(v:val)')
      call assert_equal([-1,-1,-1,4,4], a)
      bw!
! endfunc
! 
! func Test_manual_fold_with_filter()
!   if !executable('cat')
!     return
!   endif
!   new
!   call setline(1, range(1, 20))
!   4,$fold
!   %foldopen
!   10,$fold
!   %foldopen
!   " This filter command should not have an effect
!   1,8! cat
!   call feedkeys('5ggzdzMGdd', 'xt')
!   call assert_equal(['1', '2', '3', '4', '5', '6', '7', '8', '9'], getline(1, '$'))
!   bwipe!
! endfunc
*** ../vim-8.0.0387/src/version.c	2017-02-28 21:26:12.826899315 +0100
--- src/version.c	2017-02-28 21:52:28.440193664 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     388,
  /**/

-- 
"You know, it's at times like this when I'm trapped in a Vogon airlock with
a man from Betelgeuse and about to die of asphyxiation in deep space that I
really wish I'd listened to what my mother told me when I was young!"
"Why, what did she tell you?"
"I don't know, I didn't listen!"
		-- Arthur Dent and Ford Prefect in Douglas Adams'
		   "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0389
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0389
Problem:    Test for arabic does not check what is displayed.
Solution:   Improve what is asserted. (Dominique Pelle, closes #1523)
            Add a first shaping test.
Files:      src/testdir/test_arabic.vim


*** ../vim-8.0.0388/src/testdir/test_arabic.vim	2017-02-27 21:48:06.217790605 +0100
--- src/testdir/test_arabic.vim	2017-02-28 22:46:44.550375400 +0100
***************
*** 1,21 ****
  " Simplistic testing of Arabic mode.
  
! if !has('arabic')
    finish
  endif
  
! set encoding=utf-8
! scriptencoding utf-8
  
! " Return list of utf8 sequences of each character at line lnum.
  " Combining characters are treated as a single item.
! func GetCharsUtf8(lnum)
    call cursor(a:lnum, 1)
    let chars = []
    let numchars = strchars(getline('.'), 1)
    for i in range(1, numchars)
      exe 'norm ' i . '|'
!     call add(chars, execute('norm g8'))
    endfor
    return chars
  endfunc
--- 1,23 ----
  " Simplistic testing of Arabic mode.
  
! if !has('arabic') || !has('multi_byte')
    finish
  endif
  
! source view_util.vim
  
! " Return list of Unicode characters at line lnum.
  " Combining characters are treated as a single item.
! func s:get_chars(lnum)
    call cursor(a:lnum, 1)
    let chars = []
    let numchars = strchars(getline('.'), 1)
    for i in range(1, numchars)
      exe 'norm ' i . '|'
!     let c=execute('ascii')
!     let c=substitute(c, '\n\?<.\{-}Hex\s*', 'U+', 'g')
!     let c=substitute(c, ',\s*Octal\s*\d*', '', 'g')
!     call add(chars, c)
    endfor
    return chars
  endfunc
***************
*** 43,67 ****
    new
    set arabic
    " Typing sghl in Arabic insert mode should show the
!   " Arabic word 'Salaam' i.e. 'peace'.
!   call feedkeys('isghl', 'tx')
!   redraw
    call assert_equal([
!   \ "\nd8 b3 ",
!   \ "\nd9 84 + d8 a7 ",
!   \ "\nd9 85 "], GetCharsUtf8(1))
  
    " Without shaping, it should give individual Arabic letters.
    set noarabicshape
!   redraw
    call assert_equal([
!   \ "\nd8 b3 ",
!   \ "\nd9 84 ",
!   \ "\nd8 a7 ",
!   \ "\nd9 85 "], GetCharsUtf8(1))
  
!   set arabicshape&
!   set arabic&
    bwipe!
  endfunc
  
--- 45,72 ----
    new
    set arabic
    " Typing sghl in Arabic insert mode should show the
!   " Arabic word 'Salaam' i.e. 'peace', spelled:
!   " SEEN, LAM, ALEF, MEEM.
!   " See: https://www.mediawiki.org/wiki/VisualEditor/Typing/Right-to-left
!   call feedkeys('isghl!', 'tx')
!   call assert_match("^ *!\uFEE1\uFEFC\uFEB3$", ScreenLines(1, &columns)[0])
    call assert_equal([
!   \ 'U+0633',
!   \ 'U+0644 U+0627',
!   \ 'U+0645',
!   \ 'U+21'], s:get_chars(1))
  
    " Without shaping, it should give individual Arabic letters.
    set noarabicshape
!   call assert_match("^ *!\u0645\u0627\u0644\u0633$", ScreenLines(1, &columns)[0])
    call assert_equal([
!   \ 'U+0633',
!   \ 'U+0644',
!   \ 'U+0627',
!   \ 'U+0645',
!   \ 'U+21'], s:get_chars(1))
  
!   set arabic& arabicshape&
    bwipe!
  endfunc
  
***************
*** 69,75 ****
    new
    set arabic
    call feedkeys("i12\<C-^>12\<C-^>12", 'tx')
!   redraw
    call assert_equal('12', getline('.'))
    set arabic&
    bwipe!
--- 74,80 ----
    new
    set arabic
    call feedkeys("i12\<C-^>12\<C-^>12", 'tx')
!   call assert_match("^ *21$", ScreenLines(1, &columns)[0])
    call assert_equal('12', getline('.'))
    set arabic&
    bwipe!
***************
*** 79,92 ****
    new
    set arabic
    call feedkeys("isghl\<BS>\<BS>", 'tx')
!   redraw
!   call assert_equal(["\nd8 b3 ", "\nd9 84 "], GetCharsUtf8(1))
  
!   " Now the same with nodelcombine
    set nodelcombine
    %d
    call feedkeys("isghl\<BS>\<BS>", 'tx')
!   call assert_equal(["\nd8 b3 "], GetCharsUtf8(1)) 
    set arabic&
    bwipe!
  endfunc
--- 84,133 ----
    new
    set arabic
    call feedkeys("isghl\<BS>\<BS>", 'tx')
!   call assert_match("^ *\uFEDE\uFEB3$", ScreenLines(1, &columns)[0])
!   call assert_equal(['U+0633', 'U+0644'], s:get_chars(1))
  
!   " Now the same with 'nodelcombine'
    set nodelcombine
    %d
    call feedkeys("isghl\<BS>\<BS>", 'tx')
!   call assert_match("^ *\uFEB1$", ScreenLines(1, &columns)[0])
!   call assert_equal(['U+0633'], s:get_chars(1))
    set arabic&
    bwipe!
  endfunc
+ 
+ let s:a_YEH_HAMZA = "\u0626"
+ let s:a_i_YEH_HAMZA = "\ufe8b"
+ 
+ let s:a_HAMZA = "\u0621"
+ let s:a_s_HAMZA = "\ufe80"
+ 
+ let s:a_ALEF_MADDA = "\u0622"
+ let s:a_s_ALEF_MADDA = "\ufe81"
+ 
+ let s:a_ALEF_HAMZA_ABOVE = "\u0623"
+ let s:a_s_ALEF_HAMZA_ABOVE = "\ufe83"
+ 
+ let s:a_GHAIN = "\u063a"
+ let s:a_f_GHAIN = "\ufece"
+ let s:a_s_GHAIN = "\ufecd"
+ 
+ func Test_shape_initial()
+   new
+   set arabicshape
+ 
+   " Shaping arabic {testchar} non-arabic   Uses chg_c_a2i().
+   " pair[0] = testchar, pair[1] = next-result, pair[2] = current-result
+   for pair in [[s:a_YEH_HAMZA, s:a_f_GHAIN, s:a_i_YEH_HAMZA],
+ 	\ [s:a_HAMZA, s:a_s_GHAIN, s:a_s_HAMZA],
+ 	\ [s:a_ALEF_MADDA, s:a_s_GHAIN, s:a_s_ALEF_MADDA],
+ 	\ [s:a_ALEF_HAMZA_ABOVE, s:a_s_GHAIN, s:a_s_ALEF_HAMZA_ABOVE],
+ 	\ ]
+     call setline(1, s:a_GHAIN . pair[0] . ' ')
+     call assert_equal([pair[1] . pair[2] . ' '], ScreenLines(1, 3))
+   endfor
+ 
+   set arabicshape&
+   bwipe!
+ endfunc
*** ../vim-8.0.0388/src/version.c	2017-02-28 21:53:51.279626358 +0100
--- src/version.c	2017-02-28 22:07:20.238106417 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     389,
  /**/

-- 
If you put 7 of the most talented OSS developers in a room for a week
and asked them to fix a bug in a spreadsheet program, in 1 week
you'd have 2 new mail readers and a text-based web browser.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0390
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0390
Problem:    When the window scrolls horizontally when the popup menu is
            displayed part of it may not be cleared. (Neovim issue #6184)
Solution:   Remove the menu when the windows scrolled. (closes #1524)
Files:      src/edit.c


*** ../vim-8.0.0389/src/edit.c	2017-02-26 19:09:01.394217154 +0100
--- src/edit.c	2017-03-01 12:23:55.272834262 +0100
***************
*** 186,192 ****
  static int  ins_compl_key2count(int c);
  static int  ins_compl_use_match(int c);
  static int  ins_complete(int c, int enable_pum);
! static void show_pum(int save_w_wrow);
  static unsigned  quote_meta(char_u *dest, char_u *str, int len);
  #endif /* FEAT_INS_EXPAND */
  
--- 186,192 ----
  static int  ins_compl_key2count(int c);
  static int  ins_compl_use_match(int c);
  static int  ins_complete(int c, int enable_pum);
! static void show_pum(int prev_w_wrow, int prev_w_leftcol);
  static unsigned  quote_meta(char_u *dest, char_u *str, int len);
  #endif /* FEAT_INS_EXPAND */
  
***************
*** 2818,2823 ****
--- 2818,2824 ----
  set_completion(colnr_T startcol, list_T *list)
  {
      int save_w_wrow = curwin->w_wrow;
+     int save_w_leftcol = curwin->w_leftcol;
  
      /* If already doing completions stop it. */
      if (ctrl_x_mode != 0)
***************
*** 2858,2864 ****
  
      /* Lazily show the popup menu, unless we got interrupted. */
      if (!compl_interrupted)
! 	show_pum(save_w_wrow);
      out_flush();
  }
  
--- 2859,2865 ----
  
      /* Lazily show the popup menu, unless we got interrupted. */
      if (!compl_interrupted)
! 	show_pum(save_w_wrow, save_w_leftcol);
      out_flush();
  }
  
***************
*** 5096,5101 ****
--- 5097,5103 ----
      colnr_T	curs_col;	    /* cursor column */
      int		n;
      int		save_w_wrow;
+     int		save_w_leftcol;
      int		insert_match;
      int		save_did_ai = did_ai;
  
***************
*** 5539,5544 ****
--- 5541,5547 ----
       * Find next match (and following matches).
       */
      save_w_wrow = curwin->w_wrow;
+     save_w_leftcol = curwin->w_leftcol;
      n = ins_compl_next(TRUE, ins_compl_key2count(c), insert_match, FALSE);
  
      /* may undisplay the popup menu */
***************
*** 5691,5699 ****
  
      /* Show the popup menu, unless we got interrupted. */
      if (enable_pum && !compl_interrupted)
!     {
! 	show_pum(save_w_wrow);
!     }
      compl_was_interrupted = compl_interrupted;
      compl_interrupted = FALSE;
  
--- 5694,5701 ----
  
      /* Show the popup menu, unless we got interrupted. */
      if (enable_pum && !compl_interrupted)
! 	show_pum(save_w_wrow, save_w_leftcol);
! 
      compl_was_interrupted = compl_interrupted;
      compl_interrupted = FALSE;
  
***************
*** 5701,5721 ****
  }
  
      static void
! show_pum(int save_w_wrow)
  {
!   /* RedrawingDisabled may be set when invoked through complete(). */
!   int n = RedrawingDisabled;
  
!   RedrawingDisabled = 0;
  
!   /* If the cursor moved we need to remove the pum first. */
!   setcursor();
!   if (save_w_wrow != curwin->w_wrow)
!       ins_compl_del_pum();
  
!   ins_compl_show_pum();
!   setcursor();
!   RedrawingDisabled = n;
  }
  
  /*
--- 5703,5724 ----
  }
  
      static void
! show_pum(int prev_w_wrow, int prev_w_leftcol)
  {
!     /* RedrawingDisabled may be set when invoked through complete(). */
!     int n = RedrawingDisabled;
  
!     RedrawingDisabled = 0;
  
!     /* If the cursor moved or the display scrolled we need to remove the pum
!      * first. */
!     setcursor();
!     if (prev_w_wrow != curwin->w_wrow || prev_w_leftcol != curwin->w_leftcol)
! 	ins_compl_del_pum();
  
!     ins_compl_show_pum();
!     setcursor();
!     RedrawingDisabled = n;
  }
  
  /*
*** ../vim-8.0.0389/src/version.c	2017-02-28 22:51:08.468606327 +0100
--- src/version.c	2017-03-01 12:26:02.840006635 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     390,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
30. Even though you died last week, you've managed to retain OPS on your
    favorite IRC channel.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0391
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0391
Problem:    Arabic support is verbose and not well tested.
Solution:   Simplify the code.  Add more tests.
Files:      src/arabic.c, src/testdir/test_arabic.vim


*** ../vim-8.0.0390/src/arabic.c	2016-08-29 22:39:44.000000000 +0200
--- src/arabic.c	2017-03-01 13:22:50.649978477 +0100
***************
*** 200,325 ****
      static int
  chg_c_a2s(int cur_c)
  {
-     int tempc;
- 
      switch (cur_c)
      {
! 	case a_HAMZA:
! 	    tempc = a_s_HAMZA;
! 	    break;
! 	case a_ALEF_MADDA:
! 	    tempc = a_s_ALEF_MADDA;
! 	    break;
! 	case a_ALEF_HAMZA_ABOVE:
! 	    tempc = a_s_ALEF_HAMZA_ABOVE;
! 	    break;
! 	case a_WAW_HAMZA:
! 	    tempc = a_s_WAW_HAMZA;
! 	    break;
! 	case a_ALEF_HAMZA_BELOW:
! 	    tempc = a_s_ALEF_HAMZA_BELOW;
! 	    break;
! 	case a_YEH_HAMZA:
! 	    tempc = a_s_YEH_HAMZA;
! 	    break;
! 	case a_ALEF:
! 	    tempc = a_s_ALEF;
! 	    break;
! 	case a_TEH_MARBUTA:
! 	    tempc = a_s_TEH_MARBUTA;
! 	    break;
! 	case a_DAL:
! 	    tempc = a_s_DAL;
! 	    break;
! 	case a_THAL:
! 	    tempc = a_s_THAL;
! 	    break;
! 	case a_REH:
! 	    tempc = a_s_REH;
! 	    break;
! 	case a_ZAIN:
! 	    tempc = a_s_ZAIN;
! 	    break;
! 	case a_TATWEEL:			/* exceptions */
! 	    tempc = cur_c;
! 	    break;
! 	case a_WAW:
! 	    tempc = a_s_WAW;
! 	    break;
! 	case a_ALEF_MAKSURA:
! 	    tempc = a_s_ALEF_MAKSURA;
! 	    break;
! 	case a_BEH:
! 	    tempc = a_s_BEH;
! 	    break;
! 	case a_TEH:
! 	    tempc = a_s_TEH;
! 	    break;
! 	case a_THEH:
! 	    tempc = a_s_THEH;
! 	    break;
! 	case a_JEEM:
! 	    tempc = a_s_JEEM;
! 	    break;
! 	case a_HAH:
! 	    tempc = a_s_HAH;
! 	    break;
! 	case a_KHAH:
! 	    tempc = a_s_KHAH;
! 	    break;
! 	case a_SEEN:
! 	    tempc = a_s_SEEN;
! 	    break;
! 	case a_SHEEN:
! 	    tempc = a_s_SHEEN;
! 	    break;
! 	case a_SAD:
! 	    tempc = a_s_SAD;
! 	    break;
! 	case a_DAD:
! 	    tempc = a_s_DAD;
! 	    break;
! 	case a_TAH:
! 	    tempc = a_s_TAH;
! 	    break;
! 	case a_ZAH:
! 	    tempc = a_s_ZAH;
! 	    break;
! 	case a_AIN:
! 	    tempc = a_s_AIN;
! 	    break;
! 	case a_GHAIN:
! 	    tempc = a_s_GHAIN;
! 	    break;
! 	case a_FEH:
! 	    tempc = a_s_FEH;
! 	    break;
! 	case a_QAF:
! 	    tempc = a_s_QAF;
! 	    break;
! 	case a_KAF:
! 	    tempc = a_s_KAF;
! 	    break;
! 	case a_LAM:
! 	    tempc = a_s_LAM;
! 	    break;
! 	case a_MEEM:
! 	    tempc = a_s_MEEM;
! 	    break;
! 	case a_NOON:
! 	    tempc = a_s_NOON;
! 	    break;
! 	case a_HEH:
! 	    tempc = a_s_HEH;
! 	    break;
! 	case a_YEH:
! 	    tempc = a_s_YEH;
! 	    break;
! 	default:
! 	    tempc = 0;
      }
  
!     return tempc;
  }
  
  
--- 200,247 ----
      static int
  chg_c_a2s(int cur_c)
  {
      switch (cur_c)
      {
! 	case a_HAMZA: return a_s_HAMZA;
! 	case a_ALEF_MADDA: return a_s_ALEF_MADDA;
! 	case a_ALEF_HAMZA_ABOVE: return a_s_ALEF_HAMZA_ABOVE;
! 	case a_WAW_HAMZA: return a_s_WAW_HAMZA;
! 	case a_ALEF_HAMZA_BELOW: return a_s_ALEF_HAMZA_BELOW;
! 	case a_YEH_HAMZA: return a_s_YEH_HAMZA;
! 	case a_ALEF: return a_s_ALEF;
! 	case a_TEH_MARBUTA: return a_s_TEH_MARBUTA;
! 	case a_DAL: return a_s_DAL;
! 	case a_THAL: return a_s_THAL;
! 	case a_REH: return a_s_REH;
! 	case a_ZAIN: return a_s_ZAIN;
! 	case a_TATWEEL: return cur_c;	/* exceptions */
! 	case a_WAW: return a_s_WAW;
! 	case a_ALEF_MAKSURA: return a_s_ALEF_MAKSURA;
! 	case a_BEH: return a_s_BEH;
! 	case a_TEH: return a_s_TEH;
! 	case a_THEH: return a_s_THEH;
! 	case a_JEEM: return a_s_JEEM;
! 	case a_HAH: return a_s_HAH;
! 	case a_KHAH: return a_s_KHAH;
! 	case a_SEEN: return a_s_SEEN;
! 	case a_SHEEN: return a_s_SHEEN;
! 	case a_SAD: return a_s_SAD;
! 	case a_DAD: return a_s_DAD;
! 	case a_TAH: return a_s_TAH;
! 	case a_ZAH: return a_s_ZAH;
! 	case a_AIN: return a_s_AIN;
! 	case a_GHAIN: return a_s_GHAIN;
! 	case a_FEH: return a_s_FEH;
! 	case a_QAF: return a_s_QAF;
! 	case a_KAF: return a_s_KAF;
! 	case a_LAM: return a_s_LAM;
! 	case a_MEEM: return a_s_MEEM;
! 	case a_NOON: return a_s_NOON;
! 	case a_HEH: return a_s_HEH;
! 	case a_YEH: return a_s_YEH;
      }
  
!     return 0;
  }
  
  
***************
*** 329,454 ****
      static int
  chg_c_a2i(int cur_c)
  {
-     int tempc;
- 
      switch (cur_c)
      {
! 	case a_YEH_HAMZA:
! 	    tempc = a_i_YEH_HAMZA;
! 	    break;
  	case a_HAMZA:			/* exceptions */
! 	    tempc = a_s_HAMZA;
! 	    break;
  	case a_ALEF_MADDA:		/* exceptions */
! 	    tempc = a_s_ALEF_MADDA;
! 	    break;
  	case a_ALEF_HAMZA_ABOVE:	/* exceptions */
! 	    tempc = a_s_ALEF_HAMZA_ABOVE;
! 	    break;
  	case a_WAW_HAMZA:		/* exceptions */
! 	    tempc = a_s_WAW_HAMZA;
! 	    break;
  	case a_ALEF_HAMZA_BELOW:	/* exceptions */
! 	    tempc = a_s_ALEF_HAMZA_BELOW;
! 	    break;
  	case a_ALEF:			/* exceptions */
! 	    tempc = a_s_ALEF;
! 	    break;
  	case a_TEH_MARBUTA:		/* exceptions */
! 	    tempc = a_s_TEH_MARBUTA;
! 	    break;
  	case a_DAL:			/* exceptions */
! 	    tempc = a_s_DAL;
! 	    break;
  	case a_THAL:			/* exceptions */
! 	    tempc = a_s_THAL;
! 	    break;
  	case a_REH:			/* exceptions */
! 	    tempc = a_s_REH;
! 	    break;
  	case a_ZAIN:			/* exceptions */
! 	    tempc = a_s_ZAIN;
! 	    break;
  	case a_TATWEEL:			/* exceptions */
! 	    tempc = cur_c;
! 	    break;
  	case a_WAW:			/* exceptions */
! 	    tempc = a_s_WAW;
! 	    break;
  	case a_ALEF_MAKSURA:		/* exceptions */
! 	    tempc = a_s_ALEF_MAKSURA;
! 	    break;
! 	case a_BEH:
! 	    tempc = a_i_BEH;
! 	    break;
! 	case a_TEH:
! 	    tempc = a_i_TEH;
! 	    break;
! 	case a_THEH:
! 	    tempc = a_i_THEH;
! 	    break;
! 	case a_JEEM:
! 	    tempc = a_i_JEEM;
! 	    break;
! 	case a_HAH:
! 	    tempc = a_i_HAH;
! 	    break;
! 	case a_KHAH:
! 	    tempc = a_i_KHAH;
! 	    break;
! 	case a_SEEN:
! 	    tempc = a_i_SEEN;
! 	    break;
! 	case a_SHEEN:
! 	    tempc = a_i_SHEEN;
! 	    break;
! 	case a_SAD:
! 	    tempc = a_i_SAD;
! 	    break;
! 	case a_DAD:
! 	    tempc = a_i_DAD;
! 	    break;
! 	case a_TAH:
! 	    tempc = a_i_TAH;
! 	    break;
! 	case a_ZAH:
! 	    tempc = a_i_ZAH;
! 	    break;
! 	case a_AIN:
! 	    tempc = a_i_AIN;
! 	    break;
! 	case a_GHAIN:
! 	    tempc = a_i_GHAIN;
! 	    break;
! 	case a_FEH:
! 	    tempc = a_i_FEH;
! 	    break;
! 	case a_QAF:
! 	    tempc = a_i_QAF;
! 	    break;
! 	case a_KAF:
! 	    tempc = a_i_KAF;
! 	    break;
! 	case a_LAM:
! 	    tempc = a_i_LAM;
! 	    break;
! 	case a_MEEM:
! 	    tempc = a_i_MEEM;
! 	    break;
! 	case a_NOON:
! 	    tempc = a_i_NOON;
! 	    break;
! 	case a_HEH:
! 	    tempc = a_i_HEH;
! 	    break;
! 	case a_YEH:
! 	    tempc = a_i_YEH;
! 	    break;
! 	default:
! 	    tempc = 0;
      }
  
!     return tempc;
  }
  
  
--- 251,312 ----
      static int
  chg_c_a2i(int cur_c)
  {
      switch (cur_c)
      {
! 	case a_YEH_HAMZA: return a_i_YEH_HAMZA;
  	case a_HAMZA:			/* exceptions */
! 	    return a_s_HAMZA;
  	case a_ALEF_MADDA:		/* exceptions */
! 	    return a_s_ALEF_MADDA;
  	case a_ALEF_HAMZA_ABOVE:	/* exceptions */
! 	    return a_s_ALEF_HAMZA_ABOVE;
  	case a_WAW_HAMZA:		/* exceptions */
! 	    return a_s_WAW_HAMZA;
  	case a_ALEF_HAMZA_BELOW:	/* exceptions */
! 	    return a_s_ALEF_HAMZA_BELOW;
  	case a_ALEF:			/* exceptions */
! 	    return a_s_ALEF;
  	case a_TEH_MARBUTA:		/* exceptions */
! 	    return a_s_TEH_MARBUTA;
  	case a_DAL:			/* exceptions */
! 	    return a_s_DAL;
  	case a_THAL:			/* exceptions */
! 	    return a_s_THAL;
  	case a_REH:			/* exceptions */
! 	    return a_s_REH;
  	case a_ZAIN:			/* exceptions */
! 	    return a_s_ZAIN;
  	case a_TATWEEL:			/* exceptions */
! 	    return cur_c;
  	case a_WAW:			/* exceptions */
! 	    return a_s_WAW;
  	case a_ALEF_MAKSURA:		/* exceptions */
! 	    return a_s_ALEF_MAKSURA;
! 	case a_BEH: return a_i_BEH;
! 	case a_TEH: return a_i_TEH;
! 	case a_THEH: return a_i_THEH;
! 	case a_JEEM: return a_i_JEEM;
! 	case a_HAH: return a_i_HAH;
! 	case a_KHAH: return a_i_KHAH;
! 	case a_SEEN: return a_i_SEEN;
! 	case a_SHEEN: return a_i_SHEEN;
! 	case a_SAD: return a_i_SAD;
! 	case a_DAD: return a_i_DAD;
! 	case a_TAH: return a_i_TAH;
! 	case a_ZAH: return a_i_ZAH;
! 	case a_AIN: return a_i_AIN;
! 	case a_GHAIN: return a_i_GHAIN;
! 	case a_FEH: return a_i_FEH;
! 	case a_QAF: return a_i_QAF;
! 	case a_KAF: return a_i_KAF;
! 	case a_LAM: return a_i_LAM;
! 	case a_MEEM: return a_i_MEEM;
! 	case a_NOON: return a_i_NOON;
! 	case a_HEH: return a_i_HEH;
! 	case a_YEH: return a_i_YEH;
      }
  
!     return 0;
  }
  
  
***************
*** 458,583 ****
      static int
  chg_c_a2m(int cur_c)
  {
-     int tempc;
- 
      switch (cur_c)
      {
! 	case a_HAMZA:			/* exception */
! 	    tempc = a_s_HAMZA;
! 	    break;
! 	case a_ALEF_MADDA:		/* exception */
! 	    tempc = a_f_ALEF_MADDA;
! 	    break;
! 	case a_ALEF_HAMZA_ABOVE:	/* exception */
! 	    tempc = a_f_ALEF_HAMZA_ABOVE;
! 	    break;
! 	case a_WAW_HAMZA:		/* exception */
! 	    tempc = a_f_WAW_HAMZA;
! 	    break;
! 	case a_ALEF_HAMZA_BELOW:	/* exception */
! 	    tempc = a_f_ALEF_HAMZA_BELOW;
! 	    break;
! 	case a_YEH_HAMZA:
! 	    tempc = a_m_YEH_HAMZA;
! 	    break;
! 	case a_ALEF:			/* exception */
! 	    tempc = a_f_ALEF;
! 	    break;
! 	case a_BEH:
! 	    tempc = a_m_BEH;
! 	    break;
! 	case a_TEH_MARBUTA:		/* exception */
! 	    tempc = a_f_TEH_MARBUTA;
! 	    break;
! 	case a_TEH:
! 	    tempc = a_m_TEH;
! 	    break;
! 	case a_THEH:
! 	    tempc = a_m_THEH;
! 	    break;
! 	case a_JEEM:
! 	    tempc = a_m_JEEM;
! 	    break;
! 	case a_HAH:
! 	    tempc = a_m_HAH;
! 	    break;
! 	case a_KHAH:
! 	    tempc = a_m_KHAH;
! 	    break;
! 	case a_DAL:			/* exception */
! 	    tempc = a_f_DAL;
! 	    break;
! 	case a_THAL:			/* exception */
! 	    tempc = a_f_THAL;
! 	    break;
! 	case a_REH:			/* exception */
! 	    tempc = a_f_REH;
! 	    break;
! 	case a_ZAIN:			/* exception */
! 	    tempc = a_f_ZAIN;
! 	    break;
! 	case a_SEEN:
! 	    tempc = a_m_SEEN;
! 	    break;
! 	case a_SHEEN:
! 	    tempc = a_m_SHEEN;
! 	    break;
! 	case a_SAD:
! 	    tempc = a_m_SAD;
! 	    break;
! 	case a_DAD:
! 	    tempc = a_m_DAD;
! 	    break;
! 	case a_TAH:
! 	    tempc = a_m_TAH;
! 	    break;
! 	case a_ZAH:
! 	    tempc = a_m_ZAH;
! 	    break;
! 	case a_AIN:
! 	    tempc = a_m_AIN;
! 	    break;
! 	case a_GHAIN:
! 	    tempc = a_m_GHAIN;
! 	    break;
! 	case a_TATWEEL:			/* exception */
! 	    tempc = cur_c;
! 	    break;
! 	case a_FEH:
! 	    tempc = a_m_FEH;
! 	    break;
! 	case a_QAF:
! 	    tempc = a_m_QAF;
! 	    break;
! 	case a_KAF:
! 	    tempc = a_m_KAF;
! 	    break;
! 	case a_LAM:
! 	    tempc = a_m_LAM;
! 	    break;
! 	case a_MEEM:
! 	    tempc = a_m_MEEM;
! 	    break;
! 	case a_NOON:
! 	    tempc = a_m_NOON;
! 	    break;
! 	case a_HEH:
! 	    tempc = a_m_HEH;
! 	    break;
! 	case a_WAW:			/* exception */
! 	    tempc = a_f_WAW;
! 	    break;
! 	case a_ALEF_MAKSURA:		/* exception */
! 	    tempc = a_f_ALEF_MAKSURA;
! 	    break;
! 	case a_YEH:
! 	    tempc = a_m_YEH;
! 	    break;
! 	default:
! 	    tempc = 0;
      }
  
!     return tempc;
  }
  
  
--- 316,363 ----
      static int
  chg_c_a2m(int cur_c)
  {
      switch (cur_c)
      {
! 	case a_HAMZA: return a_s_HAMZA;	/* exception */
! 	case a_ALEF_MADDA: return a_f_ALEF_MADDA;	/* exception */
! 	case a_ALEF_HAMZA_ABOVE: return a_f_ALEF_HAMZA_ABOVE;	/* exception */
! 	case a_WAW_HAMZA: return a_f_WAW_HAMZA;	/* exception */
! 	case a_ALEF_HAMZA_BELOW: return a_f_ALEF_HAMZA_BELOW;	/* exception */
! 	case a_YEH_HAMZA: return a_m_YEH_HAMZA;
! 	case a_ALEF: return a_f_ALEF;	/* exception */
! 	case a_BEH: return a_m_BEH;
! 	case a_TEH_MARBUTA: return a_f_TEH_MARBUTA;	/* exception */
! 	case a_TEH: return a_m_TEH;
! 	case a_THEH: return a_m_THEH;
! 	case a_JEEM: return a_m_JEEM;
! 	case a_HAH: return a_m_HAH;
! 	case a_KHAH: return a_m_KHAH;
! 	case a_DAL: return a_f_DAL;	/* exception */
! 	case a_THAL: return a_f_THAL;	/* exception */
! 	case a_REH: return a_f_REH;	/* exception */
! 	case a_ZAIN: return a_f_ZAIN;	/* exception */
! 	case a_SEEN: return a_m_SEEN;
! 	case a_SHEEN: return a_m_SHEEN;
! 	case a_SAD: return a_m_SAD;
! 	case a_DAD: return a_m_DAD;
! 	case a_TAH: return a_m_TAH;
! 	case a_ZAH: return a_m_ZAH;
! 	case a_AIN: return a_m_AIN;
! 	case a_GHAIN: return a_m_GHAIN;
! 	case a_TATWEEL: return cur_c;	/* exception */
! 	case a_FEH: return a_m_FEH;
! 	case a_QAF: return a_m_QAF;
! 	case a_KAF: return a_m_KAF;
! 	case a_LAM: return a_m_LAM;
! 	case a_MEEM: return a_m_MEEM;
! 	case a_NOON: return a_m_NOON;
! 	case a_HEH: return a_m_HEH;
! 	case a_WAW: return a_f_WAW;	/* exception */
! 	case a_ALEF_MAKSURA: return a_f_ALEF_MAKSURA;	/* exception */
! 	case a_YEH: return a_m_YEH;
      }
  
!     return 0;
  }
  
  
*** ../vim-8.0.0390/src/testdir/test_arabic.vim	2017-02-28 22:51:08.468606327 +0100
--- src/testdir/test_arabic.vim	2017-03-01 14:01:20.219098602 +0100
***************
*** 97,128 ****
    bwipe!
  endfunc
  
  let s:a_YEH_HAMZA = "\u0626"
! let s:a_i_YEH_HAMZA = "\ufe8b"
  
! let s:a_HAMZA = "\u0621"
! let s:a_s_HAMZA = "\ufe80"
  
! let s:a_ALEF_MADDA = "\u0622"
! let s:a_s_ALEF_MADDA = "\ufe81"
  
! let s:a_ALEF_HAMZA_ABOVE = "\u0623"
! let s:a_s_ALEF_HAMZA_ABOVE = "\ufe83"
  
! let s:a_GHAIN = "\u063a"
! let s:a_f_GHAIN = "\ufece"
  let s:a_s_GHAIN = "\ufecd"
  
  func Test_shape_initial()
    new
    set arabicshape
  
!   " Shaping arabic {testchar} non-arabic   Uses chg_c_a2i().
    " pair[0] = testchar, pair[1] = next-result, pair[2] = current-result
    for pair in [[s:a_YEH_HAMZA, s:a_f_GHAIN, s:a_i_YEH_HAMZA],
  	\ [s:a_HAMZA, s:a_s_GHAIN, s:a_s_HAMZA],
  	\ [s:a_ALEF_MADDA, s:a_s_GHAIN, s:a_s_ALEF_MADDA],
  	\ [s:a_ALEF_HAMZA_ABOVE, s:a_s_GHAIN, s:a_s_ALEF_HAMZA_ABOVE],
  	\ ]
      call setline(1, s:a_GHAIN . pair[0] . ' ')
      call assert_equal([pair[1] . pair[2] . ' '], ScreenLines(1, 3))
--- 97,361 ----
    bwipe!
  endfunc
  
+ " Values from src/arabic.h (not all used yet)
+ let s:a_COMMA = "\u060C"
+ let s:a_SEMICOLON = "\u061B"
+ let s:a_QUESTION = "\u061F"
+ let s:a_HAMZA = "\u0621"
+ let s:a_ALEF_MADDA = "\u0622"
+ let s:a_ALEF_HAMZA_ABOVE = "\u0623"
+ let s:a_WAW_HAMZA = "\u0624"
+ let s:a_ALEF_HAMZA_BELOW = "\u0625"
  let s:a_YEH_HAMZA = "\u0626"
! let s:a_ALEF = "\u0627"
! let s:a_BEH = "\u0628"
! let s:a_TEH_MARBUTA = "\u0629"
! let s:a_TEH = "\u062a"
! let s:a_THEH = "\u062b"
! let s:a_JEEM = "\u062c"
! let s:a_HAH = "\u062d"
! let s:a_KHAH = "\u062e"
! let s:a_DAL = "\u062f"
! let s:a_THAL = "\u0630"
! let s:a_REH = "\u0631"
! let s:a_ZAIN = "\u0632"
! let s:a_SEEN = "\u0633"
! let s:a_SHEEN = "\u0634"
! let s:a_SAD = "\u0635"
! let s:a_DAD = "\u0636"
! let s:a_TAH = "\u0637"
! let s:a_ZAH = "\u0638"
! let s:a_AIN = "\u0639"
! let s:a_GHAIN = "\u063a"
! let s:a_TATWEEL = "\u0640"
! let s:a_FEH = "\u0641"
! let s:a_QAF = "\u0642"
! let s:a_KAF = "\u0643"
! let s:a_LAM = "\u0644"
! let s:a_MEEM = "\u0645"
! let s:a_NOON = "\u0646"
! let s:a_HEH = "\u0647"
! let s:a_WAW = "\u0648"
! let s:a_ALEF_MAKSURA = "\u0649"
! let s:a_YEH = "\u064a"
  
! let s:a_FATHATAN = "\u064b"
! let s:a_DAMMATAN = "\u064c"
! let s:a_KASRATAN = "\u064d"
! let s:a_FATHA = "\u064e"
! let s:a_DAMMA = "\u064f"
! let s:a_KASRA = "\u0650"
! let s:a_SHADDA = "\u0651"
! let s:a_SUKUN = "\u0652"
  
! let s:a_MADDA_ABOVE = "\u0653"
! let s:a_HAMZA_ABOVE = "\u0654"
! let s:a_HAMZA_BELOW = "\u0655"
  
! let s:a_ZERO = "\u0660"
! let s:a_ONE = "\u0661"
! let s:a_TWO = "\u0662"
! let s:a_THREE = "\u0663"
! let s:a_FOUR = "\u0664"
! let s:a_FIVE = "\u0665"
! let s:a_SIX = "\u0666"
! let s:a_SEVEN = "\u0667"
! let s:a_EIGHT = "\u0668"
! let s:a_NINE = "\u0669"
! let s:a_PERCENT = "\u066a"
! let s:a_DECIMAL = "\u066b"
! let s:a_THOUSANDS = "\u066c"
! let s:a_STAR = "\u066d"
! let s:a_MINI_ALEF = "\u0670"
  
! let s:a_s_FATHATAN = "\ufe70"
! let s:a_m_TATWEEL_FATHATAN = "\ufe71"
! let s:a_s_DAMMATAN = "\ufe72"
! 
! let s:a_s_KASRATAN = "\ufe74"
! 
! let s:a_s_FATHA = "\ufe76"
! let s:a_m_FATHA = "\ufe77"
! let s:a_s_DAMMA = "\ufe78"
! let s:a_m_DAMMA = "\ufe79"
! let s:a_s_KASRA = "\ufe7a"
! let s:a_m_KASRA = "\ufe7b"
! let s:a_s_SHADDA = "\ufe7c"
! let s:a_m_SHADDA = "\ufe7d"
! let s:a_s_SUKUN = "\ufe7e"
! let s:a_m_SUKUN = "\ufe7f"
! 
! let s:a_s_HAMZA = "\ufe80"
! let s:a_s_ALEF_MADDA = "\ufe81"
! let s:a_f_ALEF_MADDA = "\ufe82"
! let s:a_s_ALEF_HAMZA_ABOVE = "\ufe83"
! let s:a_f_ALEF_HAMZA_ABOVE = "\ufe84"
! let s:a_s_WAW_HAMZA = "\ufe85"
! let s:a_f_WAW_HAMZA = "\ufe86"
! let s:a_s_ALEF_HAMZA_BELOW = "\ufe87"
! let s:a_f_ALEF_HAMZA_BELOW = "\ufe88"
! let s:a_s_YEH_HAMZA = "\ufe89"
! let s:a_f_YEH_HAMZA = "\ufe8a"
! let s:a_i_YEH_HAMZA = "\ufe8b"
! let s:a_m_YEH_HAMZA = "\ufe8c"
! let s:a_s_ALEF = "\ufe8d"
! let s:a_f_ALEF = "\ufe8e"
! let s:a_s_BEH = "\ufe8f"
! let s:a_f_BEH = "\ufe90"
! let s:a_i_BEH = "\ufe91"
! let s:a_m_BEH = "\ufe92"
! let s:a_s_TEH_MARBUTA = "\ufe93"
! let s:a_f_TEH_MARBUTA = "\ufe94"
! let s:a_s_TEH = "\ufe95"
! let s:a_f_TEH = "\ufe96"
! let s:a_i_TEH = "\ufe97"
! let s:a_m_TEH = "\ufe98"
! let s:a_s_THEH = "\ufe99"
! let s:a_f_THEH = "\ufe9a"
! let s:a_i_THEH = "\ufe9b"
! let s:a_m_THEH = "\ufe9c"
! let s:a_s_JEEM = "\ufe9d"
! let s:a_f_JEEM = "\ufe9e"
! let s:a_i_JEEM = "\ufe9f"
! let s:a_m_JEEM = "\ufea0"
! let s:a_s_HAH = "\ufea1"
! let s:a_f_HAH = "\ufea2"
! let s:a_i_HAH = "\ufea3"
! let s:a_m_HAH = "\ufea4"
! let s:a_s_KHAH = "\ufea5"
! let s:a_f_KHAH = "\ufea6"
! let s:a_i_KHAH = "\ufea7"
! let s:a_m_KHAH = "\ufea8"
! let s:a_s_DAL = "\ufea9"
! let s:a_f_DAL = "\ufeaa"
! let s:a_s_THAL = "\ufeab"
! let s:a_f_THAL = "\ufeac"
! let s:a_s_REH = "\ufead"
! let s:a_f_REH = "\ufeae"
! let s:a_s_ZAIN = "\ufeaf"
! let s:a_f_ZAIN = "\ufeb0"
! let s:a_s_SEEN = "\ufeb1"
! let s:a_f_SEEN = "\ufeb2"
! let s:a_i_SEEN = "\ufeb3"
! let s:a_m_SEEN = "\ufeb4"
! let s:a_s_SHEEN = "\ufeb5"
! let s:a_f_SHEEN = "\ufeb6"
! let s:a_i_SHEEN = "\ufeb7"
! let s:a_m_SHEEN = "\ufeb8"
! let s:a_s_SAD = "\ufeb9"
! let s:a_f_SAD = "\ufeba"
! let s:a_i_SAD = "\ufebb"
! let s:a_m_SAD = "\ufebc"
! let s:a_s_DAD = "\ufebd"
! let s:a_f_DAD = "\ufebe"
! let s:a_i_DAD = "\ufebf"
! let s:a_m_DAD = "\ufec0"
! let s:a_s_TAH = "\ufec1"
! let s:a_f_TAH = "\ufec2"
! let s:a_i_TAH = "\ufec3"
! let s:a_m_TAH = "\ufec4"
! let s:a_s_ZAH = "\ufec5"
! let s:a_f_ZAH = "\ufec6"
! let s:a_i_ZAH = "\ufec7"
! let s:a_m_ZAH = "\ufec8"
! let s:a_s_AIN = "\ufec9"
! let s:a_f_AIN = "\ufeca"
! let s:a_i_AIN = "\ufecb"
! let s:a_m_AIN = "\ufecc"
  let s:a_s_GHAIN = "\ufecd"
+ let s:a_f_GHAIN = "\ufece"
+ let s:a_i_GHAIN = "\ufecf"
+ let s:a_m_GHAIN = "\ufed0"
+ let s:a_s_FEH = "\ufed1"
+ let s:a_f_FEH = "\ufed2"
+ let s:a_i_FEH = "\ufed3"
+ let s:a_m_FEH = "\ufed4"
+ let s:a_s_QAF = "\ufed5"
+ let s:a_f_QAF = "\ufed6"
+ let s:a_i_QAF = "\ufed7"
+ let s:a_m_QAF = "\ufed8"
+ let s:a_s_KAF = "\ufed9"
+ let s:a_f_KAF = "\ufeda"
+ let s:a_i_KAF = "\ufedb"
+ let s:a_m_KAF = "\ufedc"
+ let s:a_s_LAM = "\ufedd"
+ let s:a_f_LAM = "\ufede"
+ let s:a_i_LAM = "\ufedf"
+ let s:a_m_LAM = "\ufee0"
+ let s:a_s_MEEM = "\ufee1"
+ let s:a_f_MEEM = "\ufee2"
+ let s:a_i_MEEM = "\ufee3"
+ let s:a_m_MEEM = "\ufee4"
+ let s:a_s_NOON = "\ufee5"
+ let s:a_f_NOON = "\ufee6"
+ let s:a_i_NOON = "\ufee7"
+ let s:a_m_NOON = "\ufee8"
+ let s:a_s_HEH = "\ufee9"
+ let s:a_f_HEH = "\ufeea"
+ let s:a_i_HEH = "\ufeeb"
+ let s:a_m_HEH = "\ufeec"
+ let s:a_s_WAW = "\ufeed"
+ let s:a_f_WAW = "\ufeee"
+ let s:a_s_ALEF_MAKSURA = "\ufeef"
+ let s:a_f_ALEF_MAKSURA = "\ufef0"
+ let s:a_s_YEH = "\ufef1"
+ let s:a_f_YEH = "\ufef2"
+ let s:a_i_YEH = "\ufef3"
+ let s:a_m_YEH = "\ufef4"
+ let s:a_s_LAM_ALEF_MADDA_ABOVE = "\ufef5"
+ let s:a_f_LAM_ALEF_MADDA_ABOVE = "\ufef6"
+ let s:a_s_LAM_ALEF_HAMZA_ABOVE = "\ufef7"
+ let s:a_f_LAM_ALEF_HAMZA_ABOVE = "\ufef8"
+ let s:a_s_LAM_ALEF_HAMZA_BELOW = "\ufef9"
+ let s:a_f_LAM_ALEF_HAMZA_BELOW = "\ufefa"
+ let s:a_s_LAM_ALEF = "\ufefb"
+ let s:a_f_LAM_ALEF = "\ufefc"
+ 
+ let s:a_BYTE_ORDER_MARK = "\ufeff"
  
  func Test_shape_initial()
    new
    set arabicshape
  
!   " Shaping arabic {testchar} non-arabic   Tests chg_c_a2i().
    " pair[0] = testchar, pair[1] = next-result, pair[2] = current-result
    for pair in [[s:a_YEH_HAMZA, s:a_f_GHAIN, s:a_i_YEH_HAMZA],
  	\ [s:a_HAMZA, s:a_s_GHAIN, s:a_s_HAMZA],
  	\ [s:a_ALEF_MADDA, s:a_s_GHAIN, s:a_s_ALEF_MADDA],
  	\ [s:a_ALEF_HAMZA_ABOVE, s:a_s_GHAIN, s:a_s_ALEF_HAMZA_ABOVE],
+ 	\ [s:a_WAW_HAMZA, s:a_s_GHAIN, s:a_s_WAW_HAMZA],
+ 	\ [s:a_ALEF_HAMZA_BELOW, s:a_s_GHAIN, s:a_s_ALEF_HAMZA_BELOW],
+ 	\ [s:a_ALEF, s:a_s_GHAIN, s:a_s_ALEF],
+ 	\ [s:a_TEH_MARBUTA, s:a_s_GHAIN, s:a_s_TEH_MARBUTA],
+ 	\ [s:a_DAL, s:a_s_GHAIN, s:a_s_DAL],
+ 	\ [s:a_THAL, s:a_s_GHAIN, s:a_s_THAL],
+ 	\ [s:a_REH, s:a_s_GHAIN, s:a_s_REH],
+ 	\ [s:a_ZAIN, s:a_s_GHAIN, s:a_s_ZAIN],
+ 	\ [s:a_TATWEEL, s:a_f_GHAIN, s:a_TATWEEL],
+ 	\ [s:a_WAW, s:a_s_GHAIN, s:a_s_WAW],
+ 	\ [s:a_ALEF_MAKSURA, s:a_s_GHAIN, s:a_s_ALEF_MAKSURA],
+ 	\ [s:a_BEH, s:a_f_GHAIN, s:a_i_BEH],
+ 	\ [s:a_TEH, s:a_f_GHAIN, s:a_i_TEH],
+ 	\ [s:a_THEH, s:a_f_GHAIN, s:a_i_THEH],
+ 	\ [s:a_JEEM, s:a_f_GHAIN, s:a_i_JEEM],
+ 	\ [s:a_HAH, s:a_f_GHAIN, s:a_i_HAH],
+ 	\ [s:a_KHAH, s:a_f_GHAIN, s:a_i_KHAH],
+ 	\ [s:a_SEEN, s:a_f_GHAIN, s:a_i_SEEN],
+ 	\ [s:a_SHEEN, s:a_f_GHAIN, s:a_i_SHEEN],
+ 	\ [s:a_SAD, s:a_f_GHAIN, s:a_i_SAD],
+ 	\ [s:a_DAD, s:a_f_GHAIN, s:a_i_DAD],
+ 	\ [s:a_TAH, s:a_f_GHAIN, s:a_i_TAH],
+ 	\ [s:a_ZAH, s:a_f_GHAIN, s:a_i_ZAH],
+ 	\ [s:a_AIN, s:a_f_GHAIN, s:a_i_AIN],
+ 	\ [s:a_GHAIN, s:a_f_GHAIN, s:a_i_GHAIN],
+ 	\ [s:a_FEH, s:a_f_GHAIN, s:a_i_FEH],
+ 	\ [s:a_QAF, s:a_f_GHAIN, s:a_i_QAF],
+ 	\ [s:a_KAF, s:a_f_GHAIN, s:a_i_KAF],
+ 	\ [s:a_LAM, s:a_f_GHAIN, s:a_i_LAM],
+ 	\ [s:a_MEEM, s:a_f_GHAIN, s:a_i_MEEM],
+ 	\ [s:a_NOON, s:a_f_GHAIN, s:a_i_NOON],
+ 	\ [s:a_HEH, s:a_f_GHAIN, s:a_i_HEH],
+ 	\ [s:a_YEH, s:a_f_GHAIN, s:a_i_YEH],
  	\ ]
      call setline(1, s:a_GHAIN . pair[0] . ' ')
      call assert_equal([pair[1] . pair[2] . ' '], ScreenLines(1, 3))
***************
*** 131,133 ****
--- 364,472 ----
    set arabicshape&
    bwipe!
  endfunc
+ 
+ func Test_shape_isolated()
+   new
+   set arabicshape
+ 
+   " Shaping non-arabic {testchar} non-arabic   Tests chg_c_a2s().
+   " pair[0] = testchar, pair[1] = current-result
+   for pair in [[s:a_HAMZA, s:a_s_HAMZA],
+ 	\ [s:a_ALEF_MADDA, s:a_s_ALEF_MADDA],
+ 	\ [s:a_ALEF_HAMZA_ABOVE, s:a_s_ALEF_HAMZA_ABOVE],
+ 	\ [s:a_WAW_HAMZA, s:a_s_WAW_HAMZA],
+ 	\ [s:a_ALEF_HAMZA_BELOW, s:a_s_ALEF_HAMZA_BELOW],
+ 	\ [s:a_YEH_HAMZA, s:a_s_YEH_HAMZA],
+ 	\ [s:a_ALEF, s:a_s_ALEF],
+ 	\ [s:a_TEH_MARBUTA, s:a_s_TEH_MARBUTA],
+ 	\ [s:a_DAL, s:a_s_DAL],
+ 	\ [s:a_THAL, s:a_s_THAL],
+ 	\ [s:a_REH, s:a_s_REH],
+ 	\ [s:a_ZAIN, s:a_s_ZAIN],
+ 	\ [s:a_TATWEEL, s:a_TATWEEL],
+ 	\ [s:a_WAW, s:a_s_WAW],
+ 	\ [s:a_ALEF_MAKSURA, s:a_s_ALEF_MAKSURA],
+ 	\ [s:a_BEH, s:a_s_BEH],
+ 	\ [s:a_TEH, s:a_s_TEH],
+ 	\ [s:a_THEH, s:a_s_THEH],
+ 	\ [s:a_JEEM, s:a_s_JEEM],
+ 	\ [s:a_HAH, s:a_s_HAH],
+ 	\ [s:a_KHAH, s:a_s_KHAH],
+ 	\ [s:a_SEEN, s:a_s_SEEN],
+ 	\ [s:a_SHEEN, s:a_s_SHEEN],
+ 	\ [s:a_SAD, s:a_s_SAD],
+ 	\ [s:a_DAD, s:a_s_DAD],
+ 	\ [s:a_TAH, s:a_s_TAH],
+ 	\ [s:a_ZAH, s:a_s_ZAH],
+ 	\ [s:a_AIN, s:a_s_AIN],
+ 	\ [s:a_GHAIN, s:a_s_GHAIN],
+ 	\ [s:a_FEH, s:a_s_FEH],
+ 	\ [s:a_QAF, s:a_s_QAF],
+ 	\ [s:a_KAF, s:a_s_KAF],
+ 	\ [s:a_LAM, s:a_s_LAM],
+ 	\ [s:a_MEEM, s:a_s_MEEM],
+ 	\ [s:a_NOON, s:a_s_NOON],
+ 	\ [s:a_HEH, s:a_s_HEH],
+ 	\ [s:a_YEH, s:a_s_YEH],
+ 	\ ]
+     call setline(1, ' ' . pair[0] . ' ')
+     call assert_equal([' ' . pair[1] . ' '], ScreenLines(1, 3))
+   endfor
+ 
+   set arabicshape&
+   bwipe!
+ endfunc
+ 
+ func Test_shape_medial()
+   new
+   set arabicshape
+ 
+   " Shaping arabic {testchar} arabic   Tests chg_c_a2m().
+   " pair[0] = testchar, pair[1] = next-result, pair[2] = current-result,
+   " pair[3] = previous-result
+   for pair in [[s:a_HAMZA, s:a_s_GHAIN, s:a_s_HAMZA, s:a_s_BEH],
+ 	\[s:a_ALEF_MADDA, s:a_s_GHAIN, s:a_f_ALEF_MADDA, s:a_i_BEH],
+ 	\[s:a_ALEF_HAMZA_ABOVE, s:a_s_GHAIN, s:a_f_ALEF_HAMZA_ABOVE, s:a_i_BEH],
+ 	\[s:a_WAW_HAMZA, s:a_s_GHAIN, s:a_f_WAW_HAMZA, s:a_i_BEH],
+ 	\[s:a_ALEF_HAMZA_BELOW, s:a_s_GHAIN, s:a_f_ALEF_HAMZA_BELOW, s:a_i_BEH],
+ 	\[s:a_YEH_HAMZA, s:a_f_GHAIN, s:a_m_YEH_HAMZA, s:a_i_BEH],
+ 	\[s:a_ALEF, s:a_s_GHAIN, s:a_f_ALEF, s:a_i_BEH],
+ 	\[s:a_BEH, s:a_f_GHAIN, s:a_m_BEH, s:a_i_BEH],
+ 	\[s:a_TEH_MARBUTA, s:a_s_GHAIN, s:a_f_TEH_MARBUTA, s:a_i_BEH],
+ 	\[s:a_TEH, s:a_f_GHAIN, s:a_m_TEH, s:a_i_BEH],
+ 	\[s:a_THEH, s:a_f_GHAIN, s:a_m_THEH, s:a_i_BEH],
+ 	\[s:a_JEEM, s:a_f_GHAIN, s:a_m_JEEM, s:a_i_BEH],
+ 	\[s:a_HAH, s:a_f_GHAIN, s:a_m_HAH, s:a_i_BEH],
+ 	\[s:a_KHAH, s:a_f_GHAIN, s:a_m_KHAH, s:a_i_BEH],
+ 	\[s:a_DAL, s:a_s_GHAIN, s:a_f_DAL, s:a_i_BEH],
+ 	\[s:a_THAL, s:a_s_GHAIN, s:a_f_THAL, s:a_i_BEH],
+ 	\[s:a_REH, s:a_s_GHAIN, s:a_f_REH, s:a_i_BEH],
+ 	\[s:a_ZAIN, s:a_s_GHAIN, s:a_f_ZAIN, s:a_i_BEH],
+ 	\[s:a_SEEN, s:a_f_GHAIN, s:a_m_SEEN, s:a_i_BEH],
+ 	\[s:a_SHEEN, s:a_f_GHAIN, s:a_m_SHEEN, s:a_i_BEH],
+ 	\[s:a_SAD, s:a_f_GHAIN, s:a_m_SAD, s:a_i_BEH],
+ 	\[s:a_DAD, s:a_f_GHAIN, s:a_m_DAD, s:a_i_BEH],
+ 	\[s:a_TAH, s:a_f_GHAIN, s:a_m_TAH, s:a_i_BEH],
+ 	\[s:a_ZAH, s:a_f_GHAIN, s:a_m_ZAH, s:a_i_BEH],
+ 	\[s:a_AIN, s:a_f_GHAIN, s:a_m_AIN, s:a_i_BEH],
+ 	\[s:a_GHAIN, s:a_f_GHAIN, s:a_m_GHAIN, s:a_i_BEH],
+ 	\[s:a_TATWEEL, s:a_f_GHAIN, s:a_TATWEEL, s:a_i_BEH],
+ 	\[s:a_FEH, s:a_f_GHAIN, s:a_m_FEH, s:a_i_BEH],
+ 	\[s:a_QAF, s:a_f_GHAIN, s:a_m_QAF, s:a_i_BEH],
+ 	\[s:a_KAF, s:a_f_GHAIN, s:a_m_KAF, s:a_i_BEH],
+ 	\[s:a_LAM, s:a_f_GHAIN, s:a_m_LAM, s:a_i_BEH],
+ 	\[s:a_MEEM, s:a_f_GHAIN, s:a_m_MEEM, s:a_i_BEH],
+ 	\[s:a_NOON, s:a_f_GHAIN, s:a_m_NOON, s:a_i_BEH],
+ 	\[s:a_HEH, s:a_f_GHAIN, s:a_m_HEH, s:a_i_BEH],
+ 	\[s:a_WAW, s:a_s_GHAIN, s:a_f_WAW, s:a_i_BEH],
+ 	\[s:a_ALEF_MAKSURA, s:a_s_GHAIN, s:a_f_ALEF_MAKSURA, s:a_i_BEH],
+ 	\[s:a_YEH, s:a_f_GHAIN, s:a_m_YEH, s:a_i_BEH],
+ 	\ ]
+     call setline(1, s:a_GHAIN . pair[0] . s:a_BEH)
+     call assert_equal([pair[1] . pair[2] . pair[3]], ScreenLines(1, 3))
+   endfor
+ 
+   set arabicshape&
+   bwipe!
+ endfunc
+ 
*** ../vim-8.0.0390/src/version.c	2017-03-01 12:29:03.578834362 +0100
--- src/version.c	2017-03-01 12:49:11.731006864 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     391,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
32. You don't know what sex three of your closest friends are, because they
    have neutral nicknames and you never bothered to ask.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0392
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0392
Problem:    GUI test fails with Athena and Motif.
Solution:   Add test_ignore_error().  Use it to ignore the "failed to create
            input context" error.
Files:      src/message.c, src/proto/message.pro, src/evalfunc.c,
            src/testdir/test_gui.vim, runtime/doc/eval.txt


*** ../vim-8.0.0391/src/message.c	2017-01-14 19:24:48.654828136 +0100
--- src/message.c	2017-03-01 14:43:50.650575988 +0100
***************
*** 539,544 ****
--- 539,569 ----
      return FALSE;
  }
  
+ #ifdef FEAT_EVAL
+ static garray_T ignore_error_list = GA_EMPTY;
+ 
+     void
+ ignore_error_for_testing(char_u *error)
+ {
+     if (ignore_error_list.ga_itemsize == 0)
+ 	ga_init2(&ignore_error_list, sizeof(char_u *), 1);
+ 
+     ga_add_string(&ignore_error_list, error);
+ }
+ 
+     static int
+ ignore_error(char_u *msg)
+ {
+     int i;
+ 
+     for (i = 0; i < ignore_error_list.ga_len; ++i)
+ 	if (strstr((char *)msg,
+ 		  (char *)((char_u **)(ignore_error_list.ga_data))[i]) != NULL)
+ 	    return TRUE;
+     return FALSE;
+ }
+ #endif
+ 
  #if !defined(HAVE_STRERROR) || defined(PROTO)
  /*
   * Replacement for perror() that behaves more or less like emsg() was called.
***************
*** 577,582 ****
--- 602,613 ----
      if (emsg_not_now())
  	return TRUE;
  
+ #ifdef FEAT_EVAL
+     /* When testing some errors are turned into a normal message. */
+     if (ignore_error(s))
+ 	return msg(s);
+ #endif
+ 
      called_emsg = TRUE;
  
      /*
*** ../vim-8.0.0391/src/proto/message.pro	2016-11-10 20:01:41.201582868 +0100
--- src/proto/message.pro	2017-03-01 14:42:43.571011184 +0100
***************
*** 8,13 ****
--- 8,14 ----
  void reset_last_sourcing(void);
  void msg_source(int attr);
  int emsg_not_now(void);
+ void ignore_error_for_testing(char_u *error);
  void do_perror(char *msg);
  int emsg(char_u *s);
  int emsg2(char_u *s, char_u *a1);
*** ../vim-8.0.0391/src/evalfunc.c	2017-02-25 14:59:29.906090427 +0100
--- src/evalfunc.c	2017-03-01 14:17:03.577012930 +0100
***************
*** 389,394 ****
--- 389,395 ----
  static void f_test_autochdir(typval_T *argvars, typval_T *rettv);
  static void f_test_disable_char_avail(typval_T *argvars, typval_T *rettv);
  static void f_test_garbagecollect_now(typval_T *argvars, typval_T *rettv);
+ static void f_test_ignore_error(typval_T *argvars, typval_T *rettv);
  #ifdef FEAT_JOB_CHANNEL
  static void f_test_null_channel(typval_T *argvars, typval_T *rettv);
  #endif
***************
*** 823,828 ****
--- 824,830 ----
      {"test_autochdir",	0, 0, f_test_autochdir},
      {"test_disable_char_avail", 1, 1, f_test_disable_char_avail},
      {"test_garbagecollect_now",	0, 0, f_test_garbagecollect_now},
+     {"test_ignore_error",	1, 1, f_test_ignore_error},
  #ifdef FEAT_JOB_CHANNEL
      {"test_null_channel", 0, 0, f_test_null_channel},
  #endif
***************
*** 12325,12330 ****
--- 12327,12341 ----
      garbage_collect(TRUE);
  }
  
+ /*
+  * "test_ignore_error()" function
+  */
+     static void
+ f_test_ignore_error(typval_T *argvars, typval_T *rettv UNUSED)
+ {
+      ignore_error_for_testing(get_tv_string(&argvars[0]));
+ }
+ 
  #ifdef FEAT_JOB_CHANNEL
      static void
  f_test_null_channel(typval_T *argvars UNUSED, typval_T *rettv)
*** ../vim-8.0.0391/src/testdir/test_gui.vim	2017-02-26 15:08:17.578786550 +0100
--- src/testdir/test_gui.vim	2017-03-01 14:59:40.224455941 +0100
***************
*** 17,22 ****
--- 17,25 ----
  " Test for resetting "secure" flag after GUI has started.
  " Must be run first.
  func Test_1_set_secure()
+   " Ignore the "failed to create input context" error.
+   call test_ignore_error('E285')
+ 
    set exrc secure
    gui -f
    call assert_equal(1, has('gui_running'))
*** ../vim-8.0.0391/runtime/doc/eval.txt	2017-02-20 22:35:29.017423364 +0100
--- runtime/doc/eval.txt	2017-03-01 14:41:34.051462246 +0100
***************
*** 2357,2362 ****
--- 2358,2364 ----
  test_autochdir()		none	enable 'autochdir' during startup
  test_disable_char_avail({expr}) none	test without typeahead
  test_garbagecollect_now()	none	free memory right now for testing
+ test_ignore_error({expr})	none	ignore a specific error
  test_null_channel()		Channel	null value for testing
  test_null_dict()		Dict	null value for testing
  test_null_job()			Job	null value for testing
***************
*** 7773,7778 ****
--- 7785,7799 ----
  		internally, and |v:testing| must have been set before calling
  		any function.
  
+ test_ignore_error({expr})			 *test_ignore_error()*
+ 		Ignore any error containing {expr}.  A normal message is given
+ 		instead.
+ 		This is only meant to be used in tests, where catching the
+ 		error with try/catch cannot be used (because it skips over
+ 		following code).
+ 		{expr} is used literally, not as a pattern.
+ 		There is currently no way to revert this.
+ 
  test_null_channel()					*test_null_channel()*
  		Return a Channel that is null. Only useful for testing.
  		{only available when compiled with the +channel feature}
*** ../vim-8.0.0391/src/version.c	2017-03-01 14:02:25.554677542 +0100
--- src/version.c	2017-03-01 14:36:48.457315658 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     392,
  /**/

-- 
Q. What happens to programmers when they die?
A: MS-Windows programmers are reinstalled.  C++ programmers become undefined,
   anyone who refers to them will die as well. Java programmers reincarnate
   after being garbage collected, unless they are in permgen, in which case
   they become zombies.  Zimbu programmers leave a stack trace that tells us
   exactly where they died and how they got there.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0393
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0393 (after 8.0.0190)
Problem:    When the same tag appears more than once, the order is
            unpredictable. (Charles Campbell)
Solution:   Besides using a dict for finding duplicates, use a grow array for
            keeping the tags in sequence.
Files:      src/tag.c, src/testdir/test_tagjump.vim


*** ../vim-8.0.0392/src/tag.c	2017-01-23 20:47:09.037078522 +0100
--- src/tag.c	2017-03-01 15:38:25.293498562 +0100
***************
*** 35,43 ****
  } tagptrs_T;
  
  /*
!  * The matching tags are first stored in one of the ht_match[] hash tables.  In
   * which one depends on the priority of the match.
!  * At the end, all the matches from ht_match[] are concatenated, to make a list
   * sorted on priority.
   */
  #define MT_ST_CUR	0		/* static match in current file */
--- 35,44 ----
  } tagptrs_T;
  
  /*
!  * The matching tags are first stored in one of the hash tables.  In
   * which one depends on the priority of the match.
!  * ht_match[] is used to find duplicates, ga_match[] to keep them in sequence.
!  * At the end, all the matches from ga_match[] are concatenated, to make a list
   * sorted on priority.
   */
  #define MT_ST_CUR	0		/* static match in current file */
***************
*** 1339,1345 ****
  #endif
  
      char_u	*mfp;
!     hashtab_T	ht_match[MT_COUNT];
      hash_T	hash = 0;
      int		match_count = 0;		/* number of matches found */
      char_u	**matches;
--- 1340,1347 ----
  #endif
  
      char_u	*mfp;
!     garray_T	ga_match[MT_COUNT];	/* stores matches in sequence */
!     hashtab_T	ht_match[MT_COUNT];	/* stores matches by key */
      hash_T	hash = 0;
      int		match_count = 0;		/* number of matches found */
      char_u	**matches;
***************
*** 1405,1411 ****
--- 1407,1416 ----
      ebuf = alloc(LSIZE);
  #endif
      for (mtt = 0; mtt < MT_COUNT; ++mtt)
+     {
+ 	ga_init2(&ga_match[mtt], (int)sizeof(char_u *), 100);
  	hash_init(&ht_match[mtt]);
+     }
  
      /* check for out of memory situation */
      if (lbuf == NULL || tag_fname == NULL
***************
*** 2213,2219 ****
  	    }
  
  	    /*
! 	     * If a match is found, add it to ht_match[].
  	     */
  	    if (match)
  	    {
--- 2218,2224 ----
  	    }
  
  	    /*
! 	     * If a match is found, add it to ht_match[] and ga_match[].
  	     */
  	    if (match)
  	    {
***************
*** 2271,2277 ****
  		}
  
  		/*
! 		 * Add the found match in ht_match[mtt].
  		 * Store the info we need later, which depends on the kind of
  		 * tags we are dealing with.
  		 */
--- 2276,2282 ----
  		}
  
  		/*
! 		 * Add the found match in ht_match[mtt] and ga_match[mtt].
  		 * Store the info we need later, which depends on the kind of
  		 * tags we are dealing with.
  		 */
***************
*** 2423,2429 ****
  		    if (HASHITEM_EMPTY(hi))
  		    {
  			if (hash_add_item(&ht_match[mtt], hi, mfp, hash)
! 								       == FAIL)
  			{
  			    /* Out of memory! Just forget about the rest. */
  			    retval = OK;
--- 2428,2435 ----
  		    if (HASHITEM_EMPTY(hi))
  		    {
  			if (hash_add_item(&ht_match[mtt], hi, mfp, hash)
! 								       == FAIL
! 				       || ga_grow(&ga_match[mtt], 1) != OK)
  			{
  			    /* Out of memory! Just forget about the rest. */
  			    retval = OK;
***************
*** 2431,2437 ****
--- 2437,2447 ----
  			    break;
  			}
  			else
+ 			{
+ 			    ((char_u **)(ga_match[mtt].ga_data))
+ 						[ga_match[mtt].ga_len++] = mfp;
  			    ++match_count;
+ 			}
  		    }
  		    else
  			/* duplicate tag, drop it */
***************
*** 2533,2539 ****
  #endif
  
      /*
!      * Move the matches from the ht_match[] arrays into one list of
       * matches.  When retval == FAIL, free the matches.
       */
      if (retval == FAIL)
--- 2543,2549 ----
  #endif
  
      /*
!      * Move the matches from the ga_match[] arrays into one list of
       * matches.  When retval == FAIL, free the matches.
       */
      if (retval == FAIL)
***************
*** 2547,2580 ****
      match_count = 0;
      for (mtt = 0; mtt < MT_COUNT; ++mtt)
      {
! 	hashitem_T	*hi;
! 	long_u		todo;
! 
! 	todo = (long)ht_match[mtt].ht_used;
! 	for (hi = ht_match[mtt].ht_array; todo > 0; ++hi)
  	{
! 	    if (!HASHITEM_EMPTY(hi))
  	    {
! 		mfp = hi->hi_key;
! 		if (matches == NULL)
! 		    vim_free(mfp);
! 		else
  		{
! 		    if (!name_only)
! 		    {
! 			/* Change mtt back to zero-based. */
! 			*mfp = *mfp - 1;
  
! 			/* change the TAG_SEP back to NUL */
! 			for (p = mfp + 1; *p != NUL; ++p)
! 			    if (*p == TAG_SEP)
! 				*p = NUL;
! 		    }
! 		    matches[match_count++] = (char_u *)mfp;
  		}
! 		todo--;
  	    }
  	}
  	hash_clear(&ht_match[mtt]);
      }
  
--- 2557,2584 ----
      match_count = 0;
      for (mtt = 0; mtt < MT_COUNT; ++mtt)
      {
! 	for (i = 0; i < ga_match[mtt].ga_len; ++i)
  	{
! 	    mfp = ((char_u **)(ga_match[mtt].ga_data))[i];
! 	    if (matches == NULL)
! 		vim_free(mfp);
! 	    else
  	    {
! 		if (!name_only)
  		{
! 		    /* Change mtt back to zero-based. */
! 		    *mfp = *mfp - 1;
  
! 		    /* change the TAG_SEP back to NUL */
! 		    for (p = mfp + 1; *p != NUL; ++p)
! 			if (*p == TAG_SEP)
! 			    *p = NUL;
  		}
! 		matches[match_count++] = (char_u *)mfp;
  	    }
  	}
+ 
+ 	ga_clear(&ga_match[mtt]);
  	hash_clear(&ht_match[mtt]);
      }
  
*** ../vim-8.0.0392/src/testdir/test_tagjump.vim	2017-01-16 20:53:31.154599637 +0100
--- src/testdir/test_tagjump.vim	2017-03-01 15:25:28.362478203 +0100
***************
*** 35,44 ****
--- 35,68 ----
    tag one
    call assert_equal(2, line('.'))
  
+   bwipe!
    set tags&
    call delete('Xtags')
    call delete('Xfile1')
+ endfunc
+ 
+ func Test_duplicate_tagjump()
+   set tags=Xtags
+   call writefile(["!_TAG_FILE_ENCODING\tutf-8\t//",
+         \ "thesame\tXfile1\t1;\"\td\tfile:",
+         \ "thesame\tXfile1\t2;\"\td\tfile:",
+         \ "thesame\tXfile1\t3;\"\td\tfile:",
+         \ ],
+         \ 'Xtags')
+   new Xfile1
+   call setline(1, ['thesame one', 'thesame two', 'thesame three'])
+   write
+   tag thesame
+   call assert_equal(1, line('.'))
+   tnext
+   call assert_equal(2, line('.'))
+   tnext
+   call assert_equal(3, line('.'))
+ 
    bwipe!
+   set tags&
+   call delete('Xtags')
+   call delete('Xfile1')
  endfunc
  
  " Tests for [ CTRL-I and CTRL-W CTRL-I commands
*** ../vim-8.0.0392/src/version.c	2017-03-01 15:07:01.345621994 +0100
--- src/version.c	2017-03-01 15:27:14.853795967 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     393,
  /**/

-- 
To define recursion, we must first define recursion.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0394
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0394
Problem:    Tabs are not aligned when scrolling horizontally and a Tab doesn't
            fit. (Axel Bender)
Solution:   Handle a Tab as a not fitting character. (Christian Brabandt)
            Also fix that ":redraw" does not scroll horizontally to show the
            cursor.  And fix the test that depended on the old behavior.
Files:      src/screen.c, src/ex_docmd.c, src/testdir/test_listlbr.vim,
            src/testdir/test_listlbr_utf8.vim,
            src/testdir/test_breakindent.vim


*** ../vim-8.0.0393/src/screen.c	2017-02-27 21:11:29.988530382 +0100
--- src/screen.c	2017-03-01 18:03:28.751547298 +0100
***************
*** 3429,3438 ****
  #else
  	    --ptr;
  #endif
  #ifdef FEAT_MBYTE
!            /* character fits on the screen, don't need to skip it */
!            if ((*mb_ptr2cells)(ptr) >= c && col == 0)
  #endif
  	       n_skip = v - vcol;
  	}
  
--- 3429,3441 ----
  #else
  	    --ptr;
  #endif
+ 	    /* If the character fits on the screen, don't need to skip it.
+ 	     * Except for a TAB. */
+ 	    if ((
  #ifdef FEAT_MBYTE
! 			(*mb_ptr2cells)(ptr) >= c ||
  #endif
+ 		       *ptr == TAB) && col == 0)
  	       n_skip = v - vcol;
  	}
  
*** ../vim-8.0.0393/src/ex_docmd.c	2017-02-25 14:59:29.906090427 +0100
--- src/ex_docmd.c	2017-03-01 17:32:27.037653167 +0100
***************
*** 9812,9817 ****
--- 9812,9818 ----
  
      RedrawingDisabled = 0;
      p_lz = FALSE;
+     validate_cursor();
      update_topline();
      update_screen(eap->forceit ? CLEAR : VIsual_active ? INVERTED : 0);
  #ifdef FEAT_TITLE
*** ../vim-8.0.0393/src/testdir/test_listlbr.vim	2017-02-05 21:14:26.743355267 +0100
--- src/testdir/test_listlbr.vim	2017-03-01 17:12:54.318105910 +0100
***************
*** 217,219 ****
--- 217,235 ----
    call s:compare_lines(expect, lines)
    call s:close_windows()
  endfunc
+ 
+ func Test_list_with_tab_and_skipping_first_chars()
+   call s:test_windows('setl list listchars=tab:>- ts=70 nowrap')
+   call setline(1, ["iiiiiiiiiiiiiiii\taaaaaaaaaaaaaaaaaa", "iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\taaaaaaaaaaaaaaaaaa", "iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\taaaaaaaaaaaaaaaaaa", "iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\taaaaaaaaaaaaaaaaaa"])
+   call cursor(4,64)
+   norm! 2zl
+   let lines = s:screen_lines([1, 4], winwidth(0))
+   let expect = [
+ \ "---------------aaaaa",
+ \ "---------------aaaaa",
+ \ "---------------aaaaa",
+ \ "iiiiiiiii>-----aaaaa",
+ \ ]
+   call s:compare_lines(expect, lines)
+   call s:close_windows()
+ endfu
*** ../vim-8.0.0393/src/testdir/test_listlbr_utf8.vim	2017-02-26 19:40:55.869921651 +0100
--- src/testdir/test_listlbr_utf8.vim	2017-03-01 17:23:12.433679374 +0100
***************
*** 220,222 ****
--- 220,256 ----
    call s:compare_lines(expect, lines)
    call s:close_windows('setl brk&vim')
  endfunc
+ 
+ func Test_chinese_char_on_wrap_column()
+   call s:test_windows("setl nolbr wrap sbr=")
+   syntax off
+   call setline(1, [
+ \ 'aaaaaaaaaaaaaaaaaaa'.
+ \ 'aaaaaaaaaaaaaaaaa'.
+ \ 'aaaaaaaaaaaaaaaaa'.
+ \ 'aaaaaaaaaaaaaaaaa'.
+ \ 'aaaaaaaaaaaaaaaaa'.
+ \ 'aaaaaaaaaaaaaaaaa'.
+ \ 'aaaaaaaaaaaaaaaaa'.
+ \ 'aaaaaaaaaaaaaaaaa'.
+ \ 'aaaaaaaaaaaaaaaaa'.
+ \ 'aaaaaaaaaaaaaaaaa'.
+ \ 'hello'])
+   call cursor(1,1)
+   norm! $
+   redraw!
+   let expect=[
+ \ 'aaaaaaaaaaaaaaaaa>',
+ \ 'aaaaaaaaaaaaaaaaa>',
+ \ 'aaaaaaaaaaaaaaaaa>',
+ \ 'aaaaaaaaaaaaaaaaa>',
+ \ 'aaaaaaaaaaaaaaaaa>',
+ \ 'aaaaaaaaaaaaaaaaa>',
+ \ 'aaaaaaaaaaaaaaaaa>',
+ \ 'aaaaaaaaaaaaaaaaa>',
+ \ 'aaaaaaaaaaaaaaaaa>',
+ \ 'hello             ']
+   let lines = s:screen_lines([1, 10], winwidth(0))
+   call s:compare_lines(expect, lines)
+   call s:close_windows()
+ endfu
*** ../vim-8.0.0393/src/testdir/test_breakindent.vim	2017-02-05 21:14:26.743355267 +0100
--- src/testdir/test_breakindent.vim	2017-03-01 17:42:25.897230778 +0100
***************
*** 274,280 ****
  
  function Test_breakindent16()
    " Check that overlong lines are indented correctly.
-   " TODO: currently it does not fail even when the bug is not fixed.
    let s:input=""
    call s:test_windows('setl breakindent briopt=min:0 ts=4')
    call setline(1, "\t".repeat("1234567890", 10))
--- 274,279 ----
***************
*** 283,298 ****
    redraw!
    let lines=s:screen_lines(1,10)
    let expect=[
- \ "    123456",
  \ "    789012",
  \ "    345678",
  \ ]
    call s:compare_lines(expect, lines)
    let lines=s:screen_lines(4,10)
    let expect=[
- \ "    901234",
  \ "    567890",
  \ "    123456",
  \ ]
    call s:compare_lines(expect, lines)
    call s:close_windows()
--- 282,297 ----
    redraw!
    let lines=s:screen_lines(1,10)
    let expect=[
  \ "    789012",
  \ "    345678",
+ \ "    901234",
  \ ]
    call s:compare_lines(expect, lines)
    let lines=s:screen_lines(4,10)
    let expect=[
  \ "    567890",
  \ "    123456",
+ \ "    7890  ",
  \ ]
    call s:compare_lines(expect, lines)
    call s:close_windows()
*** ../vim-8.0.0393/src/version.c	2017-03-01 15:45:01.410957865 +0100
--- src/version.c	2017-03-01 17:23:52.709388031 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     394,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
34. You laugh at people with a 10 Mbit connection.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0395
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0395 (after 8.0.0392)
Problem:    Testing the + register fails with Motif.
Solution:   Also ignore the "failed to create input context" error in the
            second gvim.  Don't use msg() when it would result in a dialog.
Files:      src/message.c, src/testdir/test_gui.vim, src/testdir/setup_gui.vim


*** ../vim-8.0.0394/src/message.c	2017-03-01 15:07:01.337622045 +0100
--- src/message.c	2017-03-01 18:22:39.194544583 +0100
***************
*** 605,611 ****
  #ifdef FEAT_EVAL
      /* When testing some errors are turned into a normal message. */
      if (ignore_error(s))
! 	return msg(s);
  #endif
  
      called_emsg = TRUE;
--- 605,612 ----
  #ifdef FEAT_EVAL
      /* When testing some errors are turned into a normal message. */
      if (ignore_error(s))
! 	/* don't call msg() if it results in a dialog */
! 	return msg_use_printf() ? FALSE : msg(s);
  #endif
  
      called_emsg = TRUE;
*** ../vim-8.0.0394/src/testdir/test_gui.vim	2017-03-01 15:07:01.341622020 +0100
--- src/testdir/test_gui.vim	2017-03-01 18:16:45.625230856 +0100
***************
*** 17,25 ****
  " Test for resetting "secure" flag after GUI has started.
  " Must be run first.
  func Test_1_set_secure()
-   " Ignore the "failed to create input context" error.
-   call test_ignore_error('E285')
- 
    set exrc secure
    gui -f
    call assert_equal(1, has('gui_running'))
--- 17,22 ----
***************
*** 87,99 ****
      let test_response = 'Yes, I can.'
      let vim_exe = exepath(v:progpath)
      let testee = 'VIMRUNTIME=' . $VIMRUNTIME . '; export VIMRUNTIME;'
!           \ . vim_exe . ' -f -g -u NONE -U NONE --noplugin -c ''%s'''
!     let cmd = 'call feedkeys("'
            \ . '\"+p'
            \ . ':s/' . test_call . '/' . test_response . '/\<CR>'
            \ . '\"+yis'
            \ . ':q!\<CR>", "tx")'
!     let run_vimtest = printf(testee, cmd)
  
      " Set the quoteplus register to test_call, and another gvim will launched.
      " Then, it first tries to paste the content of its own quotedplus register
--- 84,99 ----
      let test_response = 'Yes, I can.'
      let vim_exe = exepath(v:progpath)
      let testee = 'VIMRUNTIME=' . $VIMRUNTIME . '; export VIMRUNTIME;'
!           \ . vim_exe
! 	  \ . ' -f -g -u NONE -U NONE --noplugin --cmd ''%s'' -c ''%s'''
!     " Ignore the "failed to create input context" error.
!     let cmd1 = 'call test_ignore_error("E285")'
!     let cmd2 = 'call feedkeys("'
            \ . '\"+p'
            \ . ':s/' . test_call . '/' . test_response . '/\<CR>'
            \ . '\"+yis'
            \ . ':q!\<CR>", "tx")'
!     let run_vimtest = printf(testee, cmd1, cmd2)
  
      " Set the quoteplus register to test_call, and another gvim will launched.
      " Then, it first tries to paste the content of its own quotedplus register
*** ../vim-8.0.0394/src/testdir/setup_gui.vim	2017-02-23 19:32:18.068709554 +0100
--- src/testdir/setup_gui.vim	2017-03-01 18:27:18.132432664 +0100
***************
*** 27,29 ****
--- 27,32 ----
  func GUITearDownCommon()
    call delete('Xhome', 'rf')
  endfunc
+ 
+ " Ignore the "failed to create input context" error.
+ call test_ignore_error('E285')
*** ../vim-8.0.0394/src/version.c	2017-03-01 18:04:01.579277621 +0100
--- src/version.c	2017-03-01 18:21:35.071030952 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     395,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
35. Your husband tells you he's had the beard for 2 months.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0396
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0396
Problem:    'balloonexpr' only works synchronously.
Solution:   Add balloon_show(). (Jusufadis Bakamovic, closes #1449)
Files:      runtime/doc/eval.txt, src/evalfunc.c, src/os_unix.c,
            src/os_win32.c


*** ../vim-8.0.0395/runtime/doc/eval.txt	2017-03-01 15:07:01.345621994 +0100
--- runtime/doc/eval.txt	2017-03-01 19:42:10.566755873 +0100
***************
*** 1980,1998 ****
  arglistid([{winnr} [, {tabnr}]]) Number	argument list id
  argv({nr})			String	{nr} entry of the argument list
  argv()				List	the argument list
! assert_equal({exp}, {act} [, {msg}])     none  assert {exp} is equal to {act}
! assert_exception({error} [, {msg}])      none  assert {error} is in v:exception
! assert_fails({cmd} [, {error}])          none  assert {cmd} fails
! assert_false({actual} [, {msg}])         none  assert {actual} is false
  assert_inrange({lower}, {upper}, {actual} [, {msg}])
  				none	assert {actual} is inside the range
! assert_match({pat}, {text} [, {msg}])    none  assert {pat} matches {text}
  assert_notequal({exp}, {act} [, {msg}])  none  assert {exp} is not equal {act}
  assert_notmatch({pat}, {text} [, {msg}]) none  assert {pat} not matches {text}
! assert_true({actual} [, {msg}])          none  assert {actual} is true
  asin({expr})			Float	arc sine of {expr}
  atan({expr})			Float	arc tangent of {expr}
  atan2({expr1}, {expr2})		Float	arc tangent of {expr1} / {expr2}
  browse({save}, {title}, {initdir}, {default})
  				String	put up a file requester
  browsedir({title}, {initdir})	String	put up a directory requester
--- 1981,2000 ----
  arglistid([{winnr} [, {tabnr}]]) Number	argument list id
  argv({nr})			String	{nr} entry of the argument list
  argv()				List	the argument list
! assert_equal({exp}, {act} [, {msg}])  none  assert {exp} is equal to {act}
! assert_exception({error} [, {msg}])   none  assert {error} is in v:exception
! assert_fails({cmd} [, {error}])	      none  assert {cmd} fails
! assert_false({actual} [, {msg}])      none  assert {actual} is false
  assert_inrange({lower}, {upper}, {actual} [, {msg}])
  				none	assert {actual} is inside the range
! assert_match({pat}, {text} [, {msg}])	 none  assert {pat} matches {text}
  assert_notequal({exp}, {act} [, {msg}])  none  assert {exp} is not equal {act}
  assert_notmatch({pat}, {text} [, {msg}]) none  assert {pat} not matches {text}
! assert_true({actual} [, {msg}])		 none  assert {actual} is true
  asin({expr})			Float	arc sine of {expr}
  atan({expr})			Float	arc tangent of {expr}
  atan2({expr1}, {expr2})		Float	arc tangent of {expr1} / {expr2}
+ balloon_show({msg})		none	show {msg} inside the balloon
  browse({save}, {title}, {initdir}, {default})
  				String	put up a file requester
  browsedir({title}, {initdir})	String	put up a directory requester
***************
*** 2618,2623 ****
--- 2620,2644 ----
  <			2.356194
  		{only available when compiled with the |+float| feature}
  
+ balloon_show({msg})                                     *balloon_show()*
+                 Show {msg} inside the balloon.
+                 Example: >
+ 			func GetBalloonContent()
+ 			   " initiate getting the content
+ 			   return ''
+ 			endfunc
+ 			set balloonexpr=GetBalloonContent()
+ 
+ 			func BalloonCallback(result)
+                           call balloon_show(a:result)
+ 			endfunc
+ <
+ 		The intended use is that fetching the content of the balloon
+ 		is initiated from 'balloonexpr'.  It will invoke an
+ 		asynchronous method, in which a callback invokes
+ 		balloon_show().  The 'balloonexpr' itself can return an
+ 		empty string or a placeholder.
+                 {only available when compiled with the +beval feature}
  
  							*browse()*
  browse({save}, {title}, {initdir}, {default})
*** ../vim-8.0.0395/src/evalfunc.c	2017-03-01 15:07:01.341622020 +0100
--- src/evalfunc.c	2017-03-01 19:44:58.649444654 +0100
***************
*** 58,63 ****
--- 58,66 ----
  static void f_atan(typval_T *argvars, typval_T *rettv);
  static void f_atan2(typval_T *argvars, typval_T *rettv);
  #endif
+ #ifdef FEAT_BEVAL
+ static void f_balloon_show(typval_T *argvars, typval_T *rettv);
+ #endif
  static void f_browse(typval_T *argvars, typval_T *rettv);
  static void f_browsedir(typval_T *argvars, typval_T *rettv);
  static void f_bufexists(typval_T *argvars, typval_T *rettv);
***************
*** 484,489 ****
--- 487,495 ----
      {"atan",		1, 1, f_atan},
      {"atan2",		2, 2, f_atan2},
  #endif
+ #ifdef FEAT_BEVAL
+     {"balloon_show",	1, 1, f_balloon_show},
+ #endif
      {"browse",		4, 4, f_browse},
      {"browsedir",	2, 2, f_browsedir},
      {"bufexists",	1, 1, f_bufexists},
***************
*** 1362,1367 ****
--- 1368,1384 ----
  }
  #endif
  
+ /*
+  * "balloon_show()" function
+  */
+ #ifdef FEAT_BEVAL
+     static void
+ f_balloon_show(typval_T *argvars, typval_T *rettv UNUSED)
+ {
+     gui_mch_post_balloon(balloonEval, get_tv_string_chk(&argvars[0]));
+ }
+ #endif
+ 
  /*
   * "browse(save, title, initdir, default)" function
   */
*** ../vim-8.0.0395/src/os_unix.c	2017-01-17 16:45:00.170121773 +0100
--- src/os_unix.c	2017-03-01 20:13:17.772268535 +0100
***************
*** 467,472 ****
--- 467,478 ----
  	if ((wait_time < 0 || wait_time > 100L) && channel_any_readahead())
  	    wait_time = 10L;
  #endif
+ #ifdef FEAT_BEVAL
+ 	if (p_beval && wait_time > 100L)
+ 	    /* The 'balloonexpr' may indirectly invoke a callback while waiting
+ 	     * for a character, need to check often. */
+ 	    wait_time = 100L;
+ #endif
  
  	/*
  	 * We want to be interrupted by the winch signal
*** ../vim-8.0.0395/src/os_win32.c	2017-02-05 15:10:47.747484014 +0100
--- src/os_win32.c	2017-03-01 20:13:44.668060956 +0100
***************
*** 1467,1472 ****
--- 1467,1478 ----
  		    dwWaitTime = 10;
  	    }
  #endif
+ #ifdef FEAT_BEVAL
+ 	    if (p_beval && dwWaitTime > 100)
+ 		/* The 'balloonexpr' may indirectly invoke a callback while
+ 		 * waiting for a character, need to check often. */
+ 		dwWaitTime = 100;
+ #endif
  #ifdef FEAT_MZSCHEME
  	    if (mzthreads_allowed() && p_mzq > 0
  				    && (msec < 0 || (long)dwWaitTime > p_mzq))
*** ../vim-8.0.0395/src/version.c	2017-03-01 18:30:30.578978886 +0100
--- src/version.c	2017-03-01 20:25:00.366724336 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     396,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
36. You miss more than five meals a week downloading the latest games from
    Apogee.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0397
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0397 (after 8.0.0392)
Problem:    Cannot build with the viminfo feature but without the eval
            feature.
Solution:   Adjust #ifdef. (John Marriott)
Files:      src/message.c, src/misc2.c


*** ../vim-8.0.0396/src/message.c	2017-03-01 18:30:30.578978886 +0100
--- src/message.c	2017-03-01 20:34:27.574287509 +0100
***************
*** 539,545 ****
      return FALSE;
  }
  
! #ifdef FEAT_EVAL
  static garray_T ignore_error_list = GA_EMPTY;
  
      void
--- 539,545 ----
      return FALSE;
  }
  
! #if defined(FEAT_EVAL) || defined(PROTO)
  static garray_T ignore_error_list = GA_EMPTY;
  
      void
*** ../vim-8.0.0396/src/misc2.c	2017-02-23 17:59:17.148505954 +0100
--- src/misc2.c	2017-03-01 20:34:46.306144896 +0100
***************
*** 2099,2105 ****
      return s;
  }
  
! #if defined(FEAT_VIMINFO) || defined(PROTO)
  /*
   * Make a copy of string "p" and add it to "gap".
   * When out of memory nothing changes.
--- 2099,2105 ----
      return s;
  }
  
! #if defined(FEAT_VIMINFO) || defined(FEAT_EVAL) || defined(PROTO)
  /*
   * Make a copy of string "p" and add it to "gap".
   * When out of memory nothing changes.
*** ../vim-8.0.0396/src/version.c	2017-03-01 20:32:40.143105301 +0100
--- src/version.c	2017-03-01 20:36:18.945439499 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     397,
  /**/

-- 
Micro$oft: where do you want to go today?
    Linux: where do you want to go tomorrow?
  FreeBSD: are you guys coming, or what?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0398
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0398
Problem:    Illegal memory access with "t".
Solution:   Use strncmp() instead of memcmp(). (Dominique Pelle, closes #1528)
Files:      src/search.c, src/testdir/test_search.vim


*** ../vim-8.0.0397/src/search.c	2017-02-18 23:11:57.341793867 +0100
--- src/search.c	2017-03-01 22:12:50.380085355 +0100
***************
*** 1693,1704 ****
  		    if (p[col] == c && stop)
  			break;
  		}
! 		else
! 		{
! 		    if (memcmp(p + col, lastc_bytes, lastc_bytelen) == 0
  								       && stop)
! 			break;
! 		}
  		stop = TRUE;
  	    }
  	}
--- 1693,1701 ----
  		    if (p[col] == c && stop)
  			break;
  		}
! 		else if (STRNCMP(p + col, lastc_bytes, lastc_bytelen) == 0
  								       && stop)
! 		    break;
  		stop = TRUE;
  	    }
  	}
*** ../vim-8.0.0397/src/testdir/test_search.vim	2017-01-06 20:03:45.426748945 +0100
--- src/testdir/test_search.vim	2017-03-01 22:10:32.129166002 +0100
***************
*** 294,296 ****
--- 294,303 ----
    q!
  endfunc
  
+ func Test_searchc()
+   " These commands used to cause memory overflow in searchc().
+   new
+   norm ixx
+   exe "norm 0t\u93cf"
+   bw!
+ endfunc
*** ../vim-8.0.0397/src/version.c	2017-03-01 20:40:35.623484230 +0100
--- src/version.c	2017-03-01 22:11:38.928643793 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     398,
  /**/

-- 
Everyone has a photographic memory. Some don't have film.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0399
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0399
Problem:    Crash when using balloon_show() when not supported. (Hirohito
            Higashi)
Solution:   Check for balloonEval not to be NULL. (Ken Takata)
Files:      src/evalfunc.c, src/testdir/test_functions.vim


*** ../vim-8.0.0398/src/evalfunc.c	2017-03-01 20:32:40.139105332 +0100
--- src/evalfunc.c	2017-03-02 22:07:43.577727924 +0100
***************
*** 1375,1381 ****
      static void
  f_balloon_show(typval_T *argvars, typval_T *rettv UNUSED)
  {
!     gui_mch_post_balloon(balloonEval, get_tv_string_chk(&argvars[0]));
  }
  #endif
  
--- 1375,1382 ----
      static void
  f_balloon_show(typval_T *argvars, typval_T *rettv UNUSED)
  {
!     if (balloonEval != NULL)
! 	gui_mch_post_balloon(balloonEval, get_tv_string_chk(&argvars[0]));
  }
  #endif
  
*** ../vim-8.0.0398/src/testdir/test_functions.vim	2017-02-17 16:43:44.983805306 +0100
--- src/testdir/test_functions.vim	2017-03-02 22:07:27.789853704 +0100
***************
*** 466,468 ****
--- 466,473 ----
  
    set fileformats&
  endfunc
+ 
+ func Test_balloon_show()
+   " This won't do anything but must not crash either.
+   call balloon_show('hi!')
+ endfunc
*** ../vim-8.0.0398/src/version.c	2017-03-01 22:17:01.946120304 +0100
--- src/version.c	2017-03-02 22:08:55.837152407 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     399,
  /**/

-- 
Seen it all, done it all, can't remember most of it.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0400
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0400
Problem:    Some tests have a one second delay.
Solution:   Add --not-a-term in RunVim().
Files:      src/testdir/shared.vim


*** ../vim-8.0.0399/src/testdir/shared.vim	2016-11-29 21:54:41.116260206 +0100
--- src/testdir/shared.vim	2017-03-02 22:37:47.851168423 +0100
***************
*** 192,197 ****
--- 192,198 ----
    if cmd !~ '-u NONE'
      let cmd = cmd . ' -u NONE'
    endif
+   let cmd .= ' --not-a-term'
  
    " With pipecmd we can't set VIMRUNTIME.
    if a:pipecmd != ''
*** ../vim-8.0.0399/src/version.c	2017-03-02 22:11:28.479904237 +0100
--- src/version.c	2017-03-02 22:41:29.477384472 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     400,
  /**/

-- 
Portable Computer:  A device invented to force businessmen
to work at home, on vacation, and on business trips.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0401
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0401
Problem:    Test fails with missing balloon feature.
Solution:   Add check for balloon feature.
Files:      src/testdir/test_functions.vim


*** ../vim-8.0.0400/src/testdir/test_functions.vim	2017-03-02 22:11:28.479904237 +0100
--- src/testdir/test_functions.vim	2017-03-02 22:46:28.658996207 +0100
***************
*** 468,473 ****
  endfunc
  
  func Test_balloon_show()
!   " This won't do anything but must not crash either.
!   call balloon_show('hi!')
  endfunc
--- 468,475 ----
  endfunc
  
  func Test_balloon_show()
!   if has('balloon_eval')
!     " This won't do anything but must not crash either.
!     call balloon_show('hi!')
!   endif
  endfunc
*** ../vim-8.0.0400/src/version.c	2017-03-02 22:42:56.944691932 +0100
--- src/version.c	2017-03-02 22:47:43.658393099 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     401,
  /**/

-- 
Bumper sticker: Honk if you love peace and quiet.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0402
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0402
Problem:    :map completion does not have <special>. (Dominique Pelle)
Solution:   Recognize <special> in completion.  Add a test.
Files:      src/getchar.c, src/testdir/test_cmdline.vim


*** ../vim-8.0.0401/src/getchar.c	2017-01-21 20:04:17.570757762 +0100
--- src/getchar.c	2017-03-02 22:59:16.888826155 +0100
***************
*** 4216,4221 ****
--- 4216,4226 ----
  		arg = skipwhite(arg + 8);
  		continue;
  	    }
+ 	    if (STRNCMP(arg, "<special>", 9) == 0)
+ 	    {
+ 		arg = skipwhite(arg + 9);
+ 		continue;
+ 	    }
  #ifdef FEAT_EVAL
  	    if (STRNCMP(arg, "<script>", 8) == 0)
  	    {
***************
*** 4267,4273 ****
      {
  	count = 0;
  
! 	for (i = 0; i < 6; ++i)
  	{
  	    if (i == 0)
  		p = (char_u *)"<silent>";
--- 4272,4278 ----
      {
  	count = 0;
  
! 	for (i = 0; i < 7; ++i)
  	{
  	    if (i == 0)
  		p = (char_u *)"<silent>";
***************
*** 4285,4290 ****
--- 4290,4297 ----
  #endif
  	    else if (i == 5)
  		p = (char_u *)"<nowait>";
+ 	    else if (i == 6)
+ 		p = (char_u *)"<special>";
  	    else
  		continue;
  
*** ../vim-8.0.0401/src/testdir/test_cmdline.vim	2017-02-09 22:28:11.354931464 +0100
--- src/testdir/test_cmdline.vim	2017-03-02 23:05:20.073914654 +0100
***************
*** 25,30 ****
--- 25,50 ----
    set nowildmenu
  endfunc
  
+ func Test_map_completion()
+   if !has('cmdline_compl')
+     return
+   endif
+   call feedkeys(":map <unique> <si\<Tab>\<Home>\"\<CR>", 'xt')
+   call assert_equal('"map <unique> <silent>', getreg(':'))
+   call feedkeys(":map <script> <un\<Tab>\<Home>\"\<CR>", 'xt')
+   call assert_equal('"map <script> <unique>', getreg(':'))
+   call feedkeys(":map <expr> <sc\<Tab>\<Home>\"\<CR>", 'xt')
+   call assert_equal('"map <expr> <script>', getreg(':'))
+   call feedkeys(":map <buffer> <e\<Tab>\<Home>\"\<CR>", 'xt')
+   call assert_equal('"map <buffer> <expr>', getreg(':'))
+   call feedkeys(":map <nowait> <b\<Tab>\<Home>\"\<CR>", 'xt')
+   call assert_equal('"map <nowait> <buffer>', getreg(':'))
+   call feedkeys(":map <special> <no\<Tab>\<Home>\"\<CR>", 'xt')
+   call assert_equal('"map <special> <nowait>', getreg(':'))
+   call feedkeys(":map <silent> <sp\<Tab>\<Home>\"\<CR>", 'xt')
+   call assert_equal('"map <silent> <special>', getreg(':'))
+ endfunc
+ 
  func Test_match_completion()
    if !has('cmdline_compl')
      return
*** ../vim-8.0.0401/src/version.c	2017-03-02 22:47:56.898286649 +0100
--- src/version.c	2017-03-02 23:03:33.534768400 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     402,
  /**/

-- 
Nothing is fool-proof to a sufficiently talented fool.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0403
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0403
Problem:    GUI tests may fail.
Solution:   Ignore the E285 error better. (Kazunobu Kuriyama)
Files:      src/testdir/test_gui.vim, src/testdir/test_gui_init.vim


*** ../vim-8.0.0402/src/testdir/test_gui.vim	2017-03-01 18:30:30.578978886 +0100
--- src/testdir/test_gui.vim	2017-03-04 13:27:19.909960708 +0100
***************
*** 85,99 ****
      let vim_exe = exepath(v:progpath)
      let testee = 'VIMRUNTIME=' . $VIMRUNTIME . '; export VIMRUNTIME;'
            \ . vim_exe
! 	  \ . ' -f -g -u NONE -U NONE --noplugin --cmd ''%s'' -c ''%s'''
      " Ignore the "failed to create input context" error.
!     let cmd1 = 'call test_ignore_error("E285")'
!     let cmd2 = 'call feedkeys("'
            \ . '\"+p'
            \ . ':s/' . test_call . '/' . test_response . '/\<CR>'
            \ . '\"+yis'
            \ . ':q!\<CR>", "tx")'
!     let run_vimtest = printf(testee, cmd1, cmd2)
  
      " Set the quoteplus register to test_call, and another gvim will launched.
      " Then, it first tries to paste the content of its own quotedplus register
--- 85,100 ----
      let vim_exe = exepath(v:progpath)
      let testee = 'VIMRUNTIME=' . $VIMRUNTIME . '; export VIMRUNTIME;'
            \ . vim_exe
! 	  \ . ' -u NONE -U NONE --noplugin --not-a-term -c ''%s'''
      " Ignore the "failed to create input context" error.
!     let cmd = 'call test_ignore_error("E285") | '
! 	  \ . 'gui -f | '
! 	  \ . 'call feedkeys("'
            \ . '\"+p'
            \ . ':s/' . test_call . '/' . test_response . '/\<CR>'
            \ . '\"+yis'
            \ . ':q!\<CR>", "tx")'
!     let run_vimtest = printf(testee, cmd)
  
      " Set the quoteplus register to test_call, and another gvim will launched.
      " Then, it first tries to paste the content of its own quotedplus register
*** ../vim-8.0.0402/src/testdir/test_gui_init.vim	2017-02-23 19:32:18.068709554 +0100
--- src/testdir/test_gui_init.vim	2017-03-04 13:26:46.806208916 +0100
***************
*** 15,21 ****
    call GUITearDownCommon()
  endfunc
  
! " Make sure that the tests will be done with the GUI activated.
  gui -f
  
  func Test_set_guiheadroom()
--- 15,24 ----
    call GUITearDownCommon()
  endfunc
  
! " Ignore the "failed to create input context" error.
! call test_ignore_error('E285')
! 
! " Start the GUI now, in the foreground.
  gui -f
  
  func Test_set_guiheadroom()
*** ../vim-8.0.0402/src/version.c	2017-03-02 23:05:45.545710576 +0100
--- src/version.c	2017-03-04 13:31:36.232033126 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     403,
  /**/

-- 
It was recently discovered that research causes cancer in rats.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0404
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0404
Problem:    Not enough testing for quickfix.
Solution:   Add some more tests. (Yegappan Lakshmanan)
Files:      src/testdir/test_quickfix.vim


*** ../vim-8.0.0403/src/testdir/test_quickfix.vim	2016-11-13 15:09:21.301005386 +0100
--- src/testdir/test_quickfix.vim	2017-03-04 13:43:51.586451422 +0100
***************
*** 128,133 ****
--- 128,141 ----
    let l = split(result, "\n")
    call assert_equal([' 2 Xtestfile1:1 col 3: Line1',
  		   \ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)
+ 
+   " Test for '+'
+   redir => result
+   Xlist! +2
+   redir END
+   let l = split(result, "\n")
+   call assert_equal([' 2 Xtestfile1:1 col 3: Line1',
+ 		   \ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)
  endfunc
  
  func Test_clist()
***************
*** 925,930 ****
--- 933,943 ----
  	      \ "(67,3)  warning: 's' already defined"
  	      \]
    set efm=%+P[%f],(%l\\,%c)%*[\ ]%t%*[^:]:\ %m,%-Q
+   " To exercise the push/pop file functionality in quickfix, the test files
+   " need to be created.
+   call writefile(['Line1'], 'Xtestfile1')
+   call writefile(['Line2'], 'Xtestfile2')
+   call writefile(['Line3'], 'Xtestfile3')
    cexpr ""
    for l in lines
        caddexpr l
***************
*** 935,940 ****
--- 948,956 ----
    call assert_equal(2, l[2].col)
    call assert_equal('w', l[2].type)
    call assert_equal('e', l[3].type)
+   call delete('Xtestfile1')
+   call delete('Xtestfile2')
+   call delete('Xtestfile3')
  
    " Tests for %E, %C and %Z format specifiers
    let lines = ["Error 275",
***************
*** 1369,1379 ****
--- 1385,1409 ----
    call assert_equal(2, winnr('$'))
    call assert_equal(1, bufwinnr('Xqftestfile3'))
  
+   " If only quickfix window is open in the current tabpage, jumping to an
+   " entry with 'switchubf' set to 'usetab' should search in other tabpages.
    enew | only
+   set switchbuf=usetab
+   tabedit Xqftestfile1
+   tabedit Xqftestfile2
+   tabedit Xqftestfile3
+   tabfirst
+   copen | only
+   clast
+   call assert_equal(4, tabpagenr())
+   tabfirst | tabonly | enew | only
  
    call delete('Xqftestfile1')
    call delete('Xqftestfile2')
    call delete('Xqftestfile3')
+   set switchbuf&vim
+ 
+   enew | only
  endfunc
  
  func Xadjust_qflnum(cchar)
***************
*** 1691,1693 ****
--- 1721,1776 ----
    caddbuffer
    let &efm = save_efm
  endfunc
+ 
+ " Tests for jumping to entries from the location list window and quickfix
+ " window
+ func Test_cwindow_jump()
+   set efm=%f%%%l%%%m
+   lgetexpr ["F1%10%Line 10", "F2%20%Line 20", "F3%30%Line 30"]
+   lopen | only
+   lfirst
+   call assert_true(winnr('$') == 2)
+   call assert_true(winnr() == 1)
+   " Location list for the new window should be set
+   call assert_true(getloclist(0)[2].text == 'Line 30')
+ 
+   " Open a scratch buffer
+   " Open a new window and create a location list
+   " Open the location list window and close the other window
+   " Jump to an entry.
+   " Should create a new window and jump to the entry. The scrtach buffer
+   " should not be used.
+   enew | only
+   set buftype=nofile
+   below new
+   lgetexpr ["F1%10%Line 10", "F2%20%Line 20", "F3%30%Line 30"]
+   lopen
+   2wincmd c
+   lnext
+   call assert_true(winnr('$') == 3)
+   call assert_true(winnr() == 2)
+ 
+   " Open two windows with two different location lists
+   " Open the location list window and close the previous window
+   " Jump to an entry in the location list window
+   " Should open the file in the first window and not set the location list.
+   enew | only
+   lgetexpr ["F1%5%Line 5"]
+   below new
+   lgetexpr ["F1%10%Line 10", "F2%20%Line 20", "F3%30%Line 30"]
+   lopen
+   2wincmd c
+   lnext
+   call assert_true(winnr() == 1)
+   call assert_true(getloclist(0)[0].text == 'Line 5')
+ 
+   enew | only
+   cgetexpr ["F1%10%Line 10", "F2%20%Line 20", "F3%30%Line 30"]
+   copen
+   cnext
+   call assert_true(winnr('$') == 2)
+   call assert_true(winnr() == 1)
+ 
+   enew | only
+   set efm&vim
+ endfunc
*** ../vim-8.0.0403/src/version.c	2017-03-04 13:32:06.967801328 +0100
--- src/version.c	2017-03-04 13:45:55.285505601 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     404,
  /**/

-- 
Don't read everything you believe.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0405
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0405
Problem:    v:progpath may become invalid after ":cd".
Solution:   Turn v:progpath into a full path if needed.
Files:      src/main.c, src/testdir/test_startup.vim, runtime/doc/eval.txt


*** ../vim-8.0.0404/src/main.c	2017-02-25 14:59:29.906090427 +0100
--- src/main.c	2017-03-04 14:33:21.034707076 +0100
***************
*** 57,62 ****
--- 57,65 ----
  # if defined(HAS_SWAP_EXISTS_ACTION)
  static void check_swap_exists_action(void);
  # endif
+ # ifdef FEAT_EVAL
+ static void set_progpath(char_u *argv0);
+ # endif
  # if defined(FEAT_CLIENTSERVER) || defined(PROTO)
  static void exec_on_server(mparm_T *parmp);
  static void prepare_server(mparm_T *parmp);
***************
*** 1694,1700 ****
  
  #ifdef FEAT_EVAL
      set_vim_var_string(VV_PROGNAME, initstr, -1);
!     set_vim_var_string(VV_PROGPATH, (char_u *)parmp->argv[0], -1);
  #endif
  
      if (TOLOWER_ASC(initstr[0]) == 'r')
--- 1697,1703 ----
  
  #ifdef FEAT_EVAL
      set_vim_var_string(VV_PROGNAME, initstr, -1);
!     set_progpath((char_u *)parmp->argv[0]);
  #endif
  
      if (TOLOWER_ASC(initstr[0]) == 'r')
***************
*** 3417,3423 ****
  }
  #endif
  
! #endif
  
  #if defined(STARTUPTIME) || defined(PROTO)
  static void time_diff(struct timeval *then, struct timeval *now);
--- 3420,3426 ----
  }
  #endif
  
! #endif /* NO_VIM_MAIN */
  
  #if defined(STARTUPTIME) || defined(PROTO)
  static void time_diff(struct timeval *then, struct timeval *now);
***************
*** 3525,3530 ****
--- 3528,3557 ----
  
  #endif
  
+ #ifndef NO_VIM_MAIN
+     static void
+ set_progpath(char_u *argv0)
+ {
+     char_u *val = argv0;
+     char_u buf[MAXPATHL];
+ 
+     /* A relative path containing a "/" will become invalid when using ":cd",
+      * turn it into a full path.
+      * On MS-Windows "vim.exe" is found in the current directory, thus also do
+      * it when there is no path and the file exists. */
+     if ( !mch_isFullName(argv0)
+ # ifdef WIN32
+ 	    && mch_can_exe(argv0, NULL, TRUE)
+ # else
+ 	    && gettail(argv0) != argv0
+ # endif
+ 	    && vim_FullName(argv0, buf, MAXPATHL, TRUE) != FAIL)
+ 	val = buf;
+     set_vim_var_string(VV_PROGPATH, val, -1);
+ }
+ 
+ #endif /* NO_VIM_MAIN */
+ 
  #if (defined(FEAT_CLIENTSERVER) && !defined(NO_VIM_MAIN)) || defined(PROTO)
  
  /*
*** ../vim-8.0.0404/src/testdir/test_startup.vim	2016-08-09 22:44:21.000000000 +0200
--- src/testdir/test_startup.vim	2017-03-04 14:28:29.700635631 +0100
***************
*** 183,185 ****
--- 183,199 ----
    endif
    call delete('Xtestout')
  endfunc
+ 
+ func Test_progpath()
+   " Tests normally run with "./vim" or "../vim", these must have been expanded
+   " to a full path.
+   if has('unix')
+     call assert_equal('/', v:progpath[0])
+   elseif has('win32')
+     call assert_equal(':', v:progpath[1])
+     call assert_match('[/\\]', v:progpath[2])
+   endif
+ 
+   " Only expect "vim" to appear in v:progname.
+   call assert_match('vim\c', v:progname)
+ endfunc
*** ../vim-8.0.0404/runtime/doc/eval.txt	2017-03-01 20:32:40.135105362 +0100
--- runtime/doc/eval.txt	2017-03-04 14:35:18.241915232 +0100
***************
*** 1788,1795 ****
  		|--remote-expr|.
  		To get the full path use: >
  			echo exepath(v:progpath)
! <		NOTE: This does not work when the command is a relative path
! 		and the current directory has changed.
  		Read-only.
  
  					*v:register* *register-variable*
--- 1789,1799 ----
  		|--remote-expr|.
  		To get the full path use: >
  			echo exepath(v:progpath)
! <		If the path is relative it will be expanded to the full path,
! 		so that it still works after `:cd`. Thus starting "./vim"
! 		results in "/home/user/path/to/vim/src/vim".
! 		On MS-Windows the executable may be called "vim.exe", but the
! 		".exe" is not added to v:progpath.
  		Read-only.
  
  					*v:register* *register-variable*
*** ../vim-8.0.0404/src/version.c	2017-03-04 13:47:08.248946851 +0100
--- src/version.c	2017-03-04 14:29:03.184412579 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     405,
  /**/

-- 
I started out with nothing, and I still have most of it.
                                -- Michael Davis -- "Tonight Show"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0406
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0406
Problem:    The arabic shaping code is verbose.
Solution:   Shorten the code without changing the functionality.
Files:      src/arabic.c


*** ../vim-8.0.0405/src/arabic.c	2017-03-01 14:02:25.554677542 +0100
--- src/arabic.c	2017-03-04 14:46:21.313254125 +0100
***************
*** 240,246 ****
  	case a_HEH: return a_s_HEH;
  	case a_YEH: return a_s_YEH;
      }
- 
      return 0;
  }
  
--- 240,245 ----
***************
*** 305,311 ****
  	case a_HEH: return a_i_HEH;
  	case a_YEH: return a_i_YEH;
      }
- 
      return 0;
  }
  
--- 304,309 ----
***************
*** 356,362 ****
  	case a_ALEF_MAKSURA: return a_f_ALEF_MAKSURA;	/* exception */
  	case a_YEH: return a_m_YEH;
      }
- 
      return 0;
  }
  
--- 354,359 ----
***************
*** 367,502 ****
      static int
  chg_c_a2f(int cur_c)
  {
-     int tempc;
- 
      /* NOTE: these encodings need to be accounted for
! 
! 	a_f_ALEF_MADDA;
! 	a_f_ALEF_HAMZA_ABOVE;
! 	a_f_ALEF_HAMZA_BELOW;
! 	a_f_LAM_ALEF_MADDA_ABOVE;
! 	a_f_LAM_ALEF_HAMZA_ABOVE;
! 	a_f_LAM_ALEF_HAMZA_BELOW;
! 	*/
! 
      switch (cur_c)
      {
! 	case a_HAMZA:			/* exception */
! 	    tempc = a_s_HAMZA;
! 	    break;
! 	case a_ALEF_MADDA:
! 	    tempc = a_f_ALEF_MADDA;
! 	    break;
! 	case a_ALEF_HAMZA_ABOVE:
! 	    tempc = a_f_ALEF_HAMZA_ABOVE;
! 	    break;
! 	case a_WAW_HAMZA:
! 	    tempc = a_f_WAW_HAMZA;
! 	    break;
! 	case a_ALEF_HAMZA_BELOW:
! 	    tempc = a_f_ALEF_HAMZA_BELOW;
! 	    break;
! 	case a_YEH_HAMZA:
! 	    tempc = a_f_YEH_HAMZA;
! 	    break;
! 	case a_ALEF:
! 	    tempc = a_f_ALEF;
! 	    break;
! 	case a_BEH:
! 	    tempc = a_f_BEH;
! 	    break;
! 	case a_TEH_MARBUTA:
! 	    tempc = a_f_TEH_MARBUTA;
! 	    break;
! 	case a_TEH:
! 	    tempc = a_f_TEH;
! 	    break;
! 	case a_THEH:
! 	    tempc = a_f_THEH;
! 	    break;
! 	case a_JEEM:
! 	    tempc = a_f_JEEM;
! 	    break;
! 	case a_HAH:
! 	    tempc = a_f_HAH;
! 	    break;
! 	case a_KHAH:
! 	    tempc = a_f_KHAH;
! 	    break;
! 	case a_DAL:
! 	    tempc = a_f_DAL;
! 	    break;
! 	case a_THAL:
! 	    tempc = a_f_THAL;
! 	    break;
! 	case a_REH:
! 	    tempc = a_f_REH;
! 	    break;
! 	case a_ZAIN:
! 	    tempc = a_f_ZAIN;
! 	    break;
! 	case a_SEEN:
! 	    tempc = a_f_SEEN;
! 	    break;
! 	case a_SHEEN:
! 	    tempc = a_f_SHEEN;
! 	    break;
! 	case a_SAD:
! 	    tempc = a_f_SAD;
! 	    break;
! 	case a_DAD:
! 	    tempc = a_f_DAD;
! 	    break;
! 	case a_TAH:
! 	    tempc = a_f_TAH;
! 	    break;
! 	case a_ZAH:
! 	    tempc = a_f_ZAH;
! 	    break;
! 	case a_AIN:
! 	    tempc = a_f_AIN;
! 	    break;
! 	case a_GHAIN:
! 	    tempc = a_f_GHAIN;
! 	    break;
! 	case a_TATWEEL:			/* exception */
! 	    tempc = cur_c;
! 	    break;
! 	case a_FEH:
! 	    tempc = a_f_FEH;
! 	    break;
! 	case a_QAF:
! 	    tempc = a_f_QAF;
! 	    break;
! 	case a_KAF:
! 	    tempc = a_f_KAF;
! 	    break;
! 	case a_LAM:
! 	    tempc = a_f_LAM;
! 	    break;
! 	case a_MEEM:
! 	    tempc = a_f_MEEM;
! 	    break;
! 	case a_NOON:
! 	    tempc = a_f_NOON;
! 	    break;
! 	case a_HEH:
! 	    tempc = a_f_HEH;
! 	    break;
! 	case a_WAW:
! 	    tempc = a_f_WAW;
! 	    break;
! 	case a_ALEF_MAKSURA:
! 	    tempc = a_f_ALEF_MAKSURA;
! 	    break;
! 	case a_YEH:
! 	    tempc = a_f_YEH;
! 	    break;
! 	default:
! 	    tempc = 0;
      }
! 
!     return tempc;
  }
  
  
--- 364,418 ----
      static int
  chg_c_a2f(int cur_c)
  {
      /* NOTE: these encodings need to be accounted for
!      * a_f_ALEF_MADDA;
!      * a_f_ALEF_HAMZA_ABOVE;
!      * a_f_ALEF_HAMZA_BELOW;
!      * a_f_LAM_ALEF_MADDA_ABOVE;
!      * a_f_LAM_ALEF_HAMZA_ABOVE;
!      * a_f_LAM_ALEF_HAMZA_BELOW;
!      */
      switch (cur_c)
      {
! 	case a_HAMZA: return a_s_HAMZA;	/* exception */
! 	case a_ALEF_MADDA: return a_f_ALEF_MADDA;
! 	case a_ALEF_HAMZA_ABOVE: return a_f_ALEF_HAMZA_ABOVE;
! 	case a_WAW_HAMZA: return a_f_WAW_HAMZA;
! 	case a_ALEF_HAMZA_BELOW: return a_f_ALEF_HAMZA_BELOW;
! 	case a_YEH_HAMZA: return a_f_YEH_HAMZA;
! 	case a_ALEF: return a_f_ALEF;
! 	case a_BEH: return a_f_BEH;
! 	case a_TEH_MARBUTA: return a_f_TEH_MARBUTA;
! 	case a_TEH: return a_f_TEH;
! 	case a_THEH: return a_f_THEH;
! 	case a_JEEM: return a_f_JEEM;
! 	case a_HAH: return a_f_HAH;
! 	case a_KHAH: return a_f_KHAH;
! 	case a_DAL: return a_f_DAL;
! 	case a_THAL: return a_f_THAL;
! 	case a_REH: return a_f_REH;
! 	case a_ZAIN: return a_f_ZAIN;
! 	case a_SEEN: return a_f_SEEN;
! 	case a_SHEEN: return a_f_SHEEN;
! 	case a_SAD: return a_f_SAD;
! 	case a_DAD: return a_f_DAD;
! 	case a_TAH: return a_f_TAH;
! 	case a_ZAH: return a_f_ZAH;
! 	case a_AIN: return a_f_AIN;
! 	case a_GHAIN: return a_f_GHAIN;
! 	case a_TATWEEL:	return cur_c;	/* exception */
! 	case a_FEH: return a_f_FEH;
! 	case a_QAF: return a_f_QAF;
! 	case a_KAF: return a_f_KAF;
! 	case a_LAM: return a_f_LAM;
! 	case a_MEEM: return a_f_MEEM;
! 	case a_NOON: return a_f_NOON;
! 	case a_HEH: return a_f_HEH;
! 	case a_WAW: return a_f_WAW;
! 	case a_ALEF_MAKSURA: return a_f_ALEF_MAKSURA;
! 	case a_YEH: return a_f_YEH;
      }
!     return 0;
  }
  
  
***************
*** 506,589 ****
      static int
  chg_c_i2m(int cur_c)
  {
-     int tempc;
- 
      switch (cur_c)
      {
! 	case a_i_YEH_HAMZA:
! 	    tempc = a_m_YEH_HAMZA;
! 	    break;
! 	case a_i_BEH:
! 	    tempc = a_m_BEH;
! 	    break;
! 	case a_i_TEH:
! 	    tempc = a_m_TEH;
! 	    break;
! 	case a_i_THEH:
! 	    tempc = a_m_THEH;
! 	    break;
! 	case a_i_JEEM:
! 	    tempc = a_m_JEEM;
! 	    break;
! 	case a_i_HAH:
! 	    tempc = a_m_HAH;
! 	    break;
! 	case a_i_KHAH:
! 	    tempc = a_m_KHAH;
! 	    break;
! 	case a_i_SEEN:
! 	    tempc = a_m_SEEN;
! 	    break;
! 	case a_i_SHEEN:
! 	    tempc = a_m_SHEEN;
! 	    break;
! 	case a_i_SAD:
! 	    tempc = a_m_SAD;
! 	    break;
! 	case a_i_DAD:
! 	    tempc = a_m_DAD;
! 	    break;
! 	case a_i_TAH:
! 	    tempc = a_m_TAH;
! 	    break;
! 	case a_i_ZAH:
! 	    tempc = a_m_ZAH;
! 	    break;
! 	case a_i_AIN:
! 	    tempc = a_m_AIN;
! 	    break;
! 	case a_i_GHAIN:
! 	    tempc = a_m_GHAIN;
! 	    break;
! 	case a_i_FEH:
! 	    tempc = a_m_FEH;
! 	    break;
! 	case a_i_QAF:
! 	    tempc = a_m_QAF;
! 	    break;
! 	case a_i_KAF:
! 	    tempc = a_m_KAF;
! 	    break;
! 	case a_i_LAM:
! 	    tempc = a_m_LAM;
! 	    break;
! 	case a_i_MEEM:
! 	    tempc = a_m_MEEM;
! 	    break;
! 	case a_i_NOON:
! 	    tempc = a_m_NOON;
! 	    break;
! 	case a_i_HEH:
! 	    tempc = a_m_HEH;
! 	    break;
! 	case a_i_YEH:
! 	    tempc = a_m_YEH;
! 	    break;
! 	default:
! 	    tempc = 0;
      }
! 
!     return tempc;
  }
  
  
--- 422,454 ----
      static int
  chg_c_i2m(int cur_c)
  {
      switch (cur_c)
      {
! 	case a_i_YEH_HAMZA: return a_m_YEH_HAMZA;
! 	case a_i_BEH: return a_m_BEH;
! 	case a_i_TEH: return a_m_TEH;
! 	case a_i_THEH: return a_m_THEH;
! 	case a_i_JEEM: return a_m_JEEM;
! 	case a_i_HAH: return a_m_HAH;
! 	case a_i_KHAH: return a_m_KHAH;
! 	case a_i_SEEN: return a_m_SEEN;
! 	case a_i_SHEEN: return a_m_SHEEN;
! 	case a_i_SAD: return a_m_SAD;
! 	case a_i_DAD: return a_m_DAD;
! 	case a_i_TAH: return a_m_TAH;
! 	case a_i_ZAH: return a_m_ZAH;
! 	case a_i_AIN: return a_m_AIN;
! 	case a_i_GHAIN: return a_m_GHAIN;
! 	case a_i_FEH: return a_m_FEH;
! 	case a_i_QAF: return a_m_QAF;
! 	case a_i_KAF: return a_m_KAF;
! 	case a_i_LAM: return a_m_LAM;
! 	case a_i_MEEM: return a_m_MEEM;
! 	case a_i_NOON: return a_m_NOON;
! 	case a_i_HEH: return a_m_HEH;
! 	case a_i_YEH: return a_m_YEH;
      }
!     return 0;
  }
  
  
***************
*** 593,610 ****
      static int
  chg_c_f2m(int cur_c)
  {
-     int tempc;
- 
      switch (cur_c)
      {
  	/* NOTE: these encodings are multi-positional, no ?
! 	   case a_f_ALEF_MADDA:
! 	   case a_f_ALEF_HAMZA_ABOVE:
! 	   case a_f_ALEF_HAMZA_BELOW:
! 	   */
! 	case a_f_YEH_HAMZA:
! 	    tempc = a_m_YEH_HAMZA;
! 	    break;
  	case a_f_WAW_HAMZA:		/* exceptions */
  	case a_f_ALEF:
  	case a_f_TEH_MARBUTA:
--- 458,471 ----
      static int
  chg_c_f2m(int cur_c)
  {
      switch (cur_c)
      {
  	/* NOTE: these encodings are multi-positional, no ?
! 	 * case a_f_ALEF_MADDA:
! 	 * case a_f_ALEF_HAMZA_ABOVE:
! 	 * case a_f_ALEF_HAMZA_BELOW:
! 	 */
! 	case a_f_YEH_HAMZA: return a_m_YEH_HAMZA;
  	case a_f_WAW_HAMZA:		/* exceptions */
  	case a_f_ALEF:
  	case a_f_TEH_MARBUTA:
***************
*** 614,698 ****
  	case a_f_ZAIN:
  	case a_f_WAW:
  	case a_f_ALEF_MAKSURA:
! 	    tempc = cur_c;
! 	    break;
! 	case a_f_BEH:
! 	    tempc = a_m_BEH;
! 	    break;
! 	case a_f_TEH:
! 	    tempc = a_m_TEH;
! 	    break;
! 	case a_f_THEH:
! 	    tempc = a_m_THEH;
! 	    break;
! 	case a_f_JEEM:
! 	    tempc = a_m_JEEM;
! 	    break;
! 	case a_f_HAH:
! 	    tempc = a_m_HAH;
! 	    break;
! 	case a_f_KHAH:
! 	    tempc = a_m_KHAH;
! 	    break;
! 	case a_f_SEEN:
! 	    tempc = a_m_SEEN;
! 	    break;
! 	case a_f_SHEEN:
! 	    tempc = a_m_SHEEN;
! 	    break;
! 	case a_f_SAD:
! 	    tempc = a_m_SAD;
! 	    break;
! 	case a_f_DAD:
! 	    tempc = a_m_DAD;
! 	    break;
! 	case a_f_TAH:
! 	    tempc = a_m_TAH;
! 	    break;
! 	case a_f_ZAH:
! 	    tempc = a_m_ZAH;
! 	    break;
! 	case a_f_AIN:
! 	    tempc = a_m_AIN;
! 	    break;
! 	case a_f_GHAIN:
! 	    tempc = a_m_GHAIN;
! 	    break;
! 	case a_f_FEH:
! 	    tempc = a_m_FEH;
! 	    break;
! 	case a_f_QAF:
! 	    tempc = a_m_QAF;
! 	    break;
! 	case a_f_KAF:
! 	    tempc = a_m_KAF;
! 	    break;
! 	case a_f_LAM:
! 	    tempc = a_m_LAM;
! 	    break;
! 	case a_f_MEEM:
! 	    tempc = a_m_MEEM;
! 	    break;
! 	case a_f_NOON:
! 	    tempc = a_m_NOON;
! 	    break;
! 	case a_f_HEH:
! 	    tempc = a_m_HEH;
! 	    break;
! 	case a_f_YEH:
! 	    tempc = a_m_YEH;
! 	    break;
! 	    /* NOTE: these encodings are multi-positional, no ?
! 		case a_f_LAM_ALEF_MADDA_ABOVE:
! 		case a_f_LAM_ALEF_HAMZA_ABOVE:
! 		case a_f_LAM_ALEF_HAMZA_BELOW:
! 		case a_f_LAM_ALEF:
! 		*/
! 	default:
! 	    tempc = 0;
!     }
  
!     return tempc;
  }
  
  
--- 475,512 ----
  	case a_f_ZAIN:
  	case a_f_WAW:
  	case a_f_ALEF_MAKSURA:
! 		return cur_c;
! 	case a_f_BEH: return a_m_BEH;
! 	case a_f_TEH: return a_m_TEH;
! 	case a_f_THEH: return a_m_THEH;
! 	case a_f_JEEM: return a_m_JEEM;
! 	case a_f_HAH: return a_m_HAH;
! 	case a_f_KHAH: return a_m_KHAH;
! 	case a_f_SEEN: return a_m_SEEN;
! 	case a_f_SHEEN: return a_m_SHEEN;
! 	case a_f_SAD: return a_m_SAD;
! 	case a_f_DAD: return a_m_DAD;
! 	case a_f_TAH: return a_m_TAH;
! 	case a_f_ZAH: return a_m_ZAH;
! 	case a_f_AIN: return a_m_AIN;
! 	case a_f_GHAIN: return a_m_GHAIN;
! 	case a_f_FEH: return a_m_FEH;
! 	case a_f_QAF: return a_m_QAF;
! 	case a_f_KAF: return a_m_KAF;
! 	case a_f_LAM: return a_m_LAM;
! 	case a_f_MEEM: return a_m_MEEM;
! 	case a_f_NOON: return a_m_NOON;
! 	case a_f_HEH: return a_m_HEH;
! 	case a_f_YEH: return a_m_YEH;
  
! 	/* NOTE: these encodings are multi-positional, no ?
! 	 * case a_f_LAM_ALEF_MADDA_ABOVE:
! 	 * case a_f_LAM_ALEF_HAMZA_ABOVE:
! 	 * case a_f_LAM_ALEF_HAMZA_BELOW:
! 	 * case a_f_LAM_ALEF:
! 	 */
!     }
!     return 0;
  }
  
  
***************
*** 702,728 ****
      static int
  chg_c_laa2i(int hid_c)
  {
-     int tempc;
- 
      switch (hid_c)
      {
! 	case a_ALEF_MADDA:
! 	    tempc = a_s_LAM_ALEF_MADDA_ABOVE;
! 	    break;
! 	case a_ALEF_HAMZA_ABOVE:
! 	    tempc = a_s_LAM_ALEF_HAMZA_ABOVE;
! 	    break;
! 	case a_ALEF_HAMZA_BELOW:
! 	    tempc = a_s_LAM_ALEF_HAMZA_BELOW;
! 	    break;
! 	case a_ALEF:
! 	    tempc = a_s_LAM_ALEF;
! 	    break;
! 	default:
! 	    tempc = 0;
      }
! 
!     return tempc;
  }
  
  
--- 516,529 ----
      static int
  chg_c_laa2i(int hid_c)
  {
      switch (hid_c)
      {
! 	case a_ALEF_MADDA: return a_s_LAM_ALEF_MADDA_ABOVE;
! 	case a_ALEF_HAMZA_ABOVE: return a_s_LAM_ALEF_HAMZA_ABOVE;
! 	case a_ALEF_HAMZA_BELOW: return a_s_LAM_ALEF_HAMZA_BELOW;
! 	case a_ALEF: return a_s_LAM_ALEF;
      }
!     return 0;
  }
  
  
***************
*** 732,758 ****
      static int
  chg_c_laa2f(int hid_c)
  {
-     int tempc;
- 
      switch (hid_c)
      {
! 	case a_ALEF_MADDA:
! 	    tempc = a_f_LAM_ALEF_MADDA_ABOVE;
! 	    break;
! 	case a_ALEF_HAMZA_ABOVE:
! 	    tempc = a_f_LAM_ALEF_HAMZA_ABOVE;
! 	    break;
! 	case a_ALEF_HAMZA_BELOW:
! 	    tempc = a_f_LAM_ALEF_HAMZA_BELOW;
! 	    break;
! 	case a_ALEF:
! 	    tempc = a_f_LAM_ALEF;
! 	    break;
! 	default:
! 	    tempc = 0;
      }
! 
!     return tempc;
  }
  
  /*
--- 533,546 ----
      static int
  chg_c_laa2f(int hid_c)
  {
      switch (hid_c)
      {
! 	case a_ALEF_MADDA: return a_f_LAM_ALEF_MADDA_ABOVE;
! 	case a_ALEF_HAMZA_ABOVE: return a_f_LAM_ALEF_HAMZA_ABOVE;
! 	case a_ALEF_HAMZA_BELOW: return a_f_LAM_ALEF_HAMZA_BELOW;
! 	case a_ALEF: return a_f_LAM_ALEF;
      }
!     return 0;
  }
  
  /*
*** ../vim-8.0.0405/src/version.c	2017-03-04 14:37:14.649120059 +0100
--- src/version.c	2017-03-04 14:47:19.112833437 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     406,
  /**/

-- 
Well, you come from nothing, you go back to nothing...  What have you
lost?  Nothing!
				-- Monty Python: The life of Brian

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0407
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0407 (after 8.0.0388)
Problem:    Filtering folds with marker method not tested.
Solution:   Also set 'foldmethod' to "marker".
Files:      src/testdir/test_fold.vim


*** ../vim-8.0.0406/src/testdir/test_fold.vim	2017-02-28 21:53:51.275626386 +0100
--- src/testdir/test_fold.vim	2017-03-04 15:22:22.689322725 +0100
***************
*** 100,114 ****
    if !executable('cat')
      return
    endif
!   new
!   call setline(1, range(1, 20))
!   4,$fold
!   %foldopen
!   10,$fold
!   %foldopen
!   " This filter command should not have an effect
!   1,8! cat
!   call feedkeys('5ggzdzMGdd', 'xt')
!   call assert_equal(['1', '2', '3', '4', '5', '6', '7', '8', '9'], getline(1, '$'))
!   bwipe!
  endfunc
--- 100,119 ----
    if !executable('cat')
      return
    endif
!   for type in ['manual', 'marker']
!     exe 'set foldmethod=' . type
!     new
!     call setline(1, range(1, 20))
!     4,$fold
!     %foldopen
!     10,$fold
!     %foldopen
!     " This filter command should not have an effect
!     1,8! cat
!     call feedkeys('5ggzdzMGdd', 'xt')
!     call assert_equal(['1', '2', '3', '4', '5', '6', '7', '8', '9'], getline(1, '$'))
! 
!     bwipe!
!     set foldmethod&
!   endfor
  endfunc
*** ../vim-8.0.0406/src/version.c	2017-03-04 14:50:15.279549901 +0100
--- src/version.c	2017-03-04 15:26:10.371591258 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     407,
  /**/

-- 
Microsoft is to software what McDonalds is to gourmet cooking

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0408
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0408
Problem:    Updating folds does not work properly when inserting a file and a
            few other situations.
Solution:   Adjust the way folds are updated. (Matthew Malcomson)
Files:      src/fold.c, src/testdir/test_fold.vim


*** ../vim-8.0.0407/src/fold.c	2017-02-28 21:53:51.275626386 +0100
--- src/fold.c	2017-03-04 18:29:45.985625604 +0100
***************
*** 2505,2511 ****
  			 * before where we started looking, extend it.  If it
  			 * starts at another line, update nested folds to keep
  			 * their position, compensating for the new fd_top. */
! 			if (fp->fd_top >= startlnum && fp->fd_top != firstlnum)
  			{
  			    if (fp->fd_top > firstlnum)
  				/* like lines are inserted */
--- 2505,2515 ----
  			 * before where we started looking, extend it.  If it
  			 * starts at another line, update nested folds to keep
  			 * their position, compensating for the new fd_top. */
! 			if (fp->fd_top == firstlnum)
! 			{
! 			    /* have found a fold beginning where we want */
! 			}
! 			else if (fp->fd_top >= startlnum)
  			{
  			    if (fp->fd_top > firstlnum)
  				/* like lines are inserted */
***************
*** 2523,2540 ****
  			    fp->fd_top = firstlnum;
  			    fold_changed = TRUE;
  			}
! 			else if (flp->start != 0 && lvl == level
! 						   && fp->fd_top != firstlnum)
  			{
! 			    /* Existing fold that includes startlnum must stop
! 			     * if we find the start of a new fold at the same
! 			     * level.  Split it.  Delete contained folds at
! 			     * this point to split them too. */
! 			    foldRemove(&fp->fd_nested, flp->lnum - fp->fd_top,
! 						      flp->lnum - fp->fd_top);
  			    i = (int)(fp - (fold_T *)gap->ga_data);
! 			    foldSplit(gap, i, flp->lnum, flp->lnum - 1);
  			    fp = (fold_T *)gap->ga_data + i + 1;
  			    /* If using the "marker" or "syntax" method, we
  			     * need to continue until the end of the fold is
  			     * found. */
--- 2527,2570 ----
  			    fp->fd_top = firstlnum;
  			    fold_changed = TRUE;
  			}
! 			else if ((flp->start != 0 && lvl == level)
! 						     || firstlnum != startlnum)
  			{
! 			    linenr_T breakstart;
! 			    linenr_T breakend;
! 
! 			    /*
! 			     * Before there was a fold spanning from above
! 			     * startlnum to below firstlnum. This fold is valid
! 			     * above startlnum (because we are not updating
! 			     * that range), but there should now be a break in
! 			     * it.
! 			     * If the break is because we are now forced to
! 			     * start a new fold at the level "level" at line
! 			     * fline->lnum, then we need to split the fold at
! 			     * fline->lnum.
! 			     * If the break is because the range
! 			     * [startlnum, firstlnum) is now at a lower indent
! 			     * than "level", we need to split the fold in this
! 			     * range.
! 			     * Any splits have to be done recursively.
! 			     */
! 			    if (firstlnum != startlnum)
! 			    {
! 				breakstart = startlnum;
! 				breakend = firstlnum;
! 			    }
! 			    else
! 			    {
! 				breakstart = flp->lnum;
! 				breakend = flp->lnum;
! 			    }
! 			    foldRemove(&fp->fd_nested, breakstart - fp->fd_top,
! 						      breakend - fp->fd_top);
  			    i = (int)(fp - (fold_T *)gap->ga_data);
! 			    foldSplit(gap, i, breakstart, breakend - 1);
  			    fp = (fold_T *)gap->ga_data + i + 1;
+ 
  			    /* If using the "marker" or "syntax" method, we
  			     * need to continue until the end of the fold is
  			     * found. */
***************
*** 2543,2548 ****
--- 2573,2592 ----
  				    || getlevel == foldlevelSyntax)
  				finish = TRUE;
  			}
+ 
+ 			if (fp->fd_top == startlnum && concat)
+ 			{
+ 			    i = (int)(fp - (fold_T *)gap->ga_data);
+ 			    if (i != 0)
+ 			    {
+ 				fp2 = fp - 1;
+ 				if (fp2->fd_top + fp2->fd_len == fp->fd_top)
+ 				{
+ 				    foldMerge(fp2, gap, fp);
+ 				    fp = fp2;
+ 				}
+ 			    }
+ 			}
  			break;
  		    }
  		    if (fp->fd_top >= startlnum)
*** ../vim-8.0.0407/src/testdir/test_fold.vim	2017-03-04 15:28:49.422383686 +0100
--- src/testdir/test_fold.vim	2017-03-04 18:39:30.289078439 +0100
***************
*** 117,119 ****
--- 117,205 ----
      set foldmethod&
    endfor
  endfunc
+ 
+ func! Test_indent_fold_with_read()
+   new
+   set foldmethod=indent
+   call setline(1, repeat(["\<Tab>a"], 4))
+   for n in range(1, 4)
+     call assert_equal(1, foldlevel(n))
+   endfor
+ 
+   call writefile(["a", "", "\<Tab>a"], 'Xfile')
+   foldopen
+   2read Xfile
+   %foldclose
+   call assert_equal(1, foldlevel(1))
+   call assert_equal(2, foldclosedend(1))
+   call assert_equal(0, foldlevel(3))
+   call assert_equal(0, foldlevel(4))
+   call assert_equal(1, foldlevel(5))
+   call assert_equal(7, foldclosedend(5))
+ 
+   bwipe!
+   set foldmethod&
+   call delete('Xfile')
+ endfunc
+ 
+ func Test_combining_folds_indent()
+   new
+   let one = "\<Tab>a"
+   let zero = 'a'
+   call setline(1, [one, one, zero, zero, zero, one, one, one])
+   set foldmethod=indent
+   3,5d
+   %foldclose
+   call assert_equal(5, foldclosedend(1))
+ 
+   set foldmethod&
+   bwipe!
+ endfunc
+ 
+ func Test_combining_folds_marker()
+   new
+   call setline(1, ['{{{', '}}}', '', '', '', '{{{', '', '}}}'])
+   set foldmethod=marker
+   3,5d
+   %foldclose
+   call assert_equal(2, foldclosedend(1))
+ 
+   set foldmethod&
+   bwipe!
+ endfunc
+ 
+ func s:TestFoldExpr(lnum)
+   let thisline = getline(a:lnum)
+   if thisline == 'a'
+     return 1
+   elseif thisline == 'b'
+     return 0
+   elseif thisline == 'c'
+     return '<1'
+   elseif thisline == 'd'
+     return '>1'
+   endif
+   return 0
+ endfunction
+ 
+ func Test_update_folds_expr_read()
+   new
+   call setline(1, ['a', 'a', 'a', 'a', 'a', 'a'])
+   set foldmethod=expr
+   set foldexpr=s:TestFoldExpr(v:lnum)
+   2
+   foldopen
+   call writefile(['b', 'b', 'a', 'a', 'd', 'a', 'a', 'c'], 'Xfile')
+   read Xfile
+   %foldclose
+   call assert_equal(2, foldclosedend(1))
+   call assert_equal(0, foldlevel(3))
+   call assert_equal(0, foldlevel(4))
+   call assert_equal(6, foldclosedend(5))
+   call assert_equal(10, foldclosedend(7))
+   call assert_equal(14, foldclosedend(11))
+ 
+   call delete('Xfile')
+   bwipe!
+   set foldmethod& foldexpr&
+ endfunc
*** ../vim-8.0.0407/src/version.c	2017-03-04 15:28:49.422383686 +0100
--- src/version.c	2017-03-04 18:39:29.289085913 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     408,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
46. Your wife makes a new rule: "The computer cannot come to bed."

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0409
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0409
Problem:    set_progpath is defined but not always used
Solution:   Adjust #ifdef.
Files:      src/main.c


*** ../vim-8.0.0408/src/main.c	2017-03-04 14:37:14.649120059 +0100
--- src/main.c	2017-03-04 18:55:56.037675946 +0100
***************
*** 3528,3534 ****
  
  #endif
  
! #ifndef NO_VIM_MAIN
      static void
  set_progpath(char_u *argv0)
  {
--- 3528,3534 ----
  
  #endif
  
! #if !defined(NO_VIM_MAIN) && defined(FEAT_EVAL)
      static void
  set_progpath(char_u *argv0)
  {
*** ../vim-8.0.0408/src/version.c	2017-03-04 18:42:35.719691735 +0100
--- src/version.c	2017-03-04 18:56:37.021367469 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     409,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
47. You are so familiar with the WWW that you find the search engines useless.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0410
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0410
Problem:    Newer gettext/iconv library has extra dll file.
Solution:   Add the file to the Makefile and nsis script. (Christian Brabandt)
Files:      Makefile, nsis/gvim.nsi


*** ../vim-8.0.0409/Makefile	2016-09-12 14:03:36.000000000 +0200
--- Makefile	2017-03-04 20:07:09.837033885 +0100
***************
*** 120,127 ****
  #
  # MS-Windows:
  # - Run make on Unix to update the ".mo" files.
! # - Get libintl-8.dll and libiconv-2.dll. E.g. from
  #   https://mlocati.github.io/gettext-iconv-windows/ .
  #   Put them in the top directory, "make dosrt" uses them.
  # - > make dossrc
  #   > make dosrt
--- 120,128 ----
  #
  # MS-Windows:
  # - Run make on Unix to update the ".mo" files.
! # - Get libintl-8.dll, libiconv-2.dll and libgcc_s_sjlj-1.dll. E.g. from
  #   https://mlocati.github.io/gettext-iconv-windows/ .
+ #   Use the "shared-32.zip file and extract the archive to get the files.
  #   Put them in the top directory, "make dosrt" uses them.
  # - > make dossrc
  #   > make dosrt
***************
*** 468,473 ****
--- 469,475 ----
  	    done
  	cp libintl-8.dll dist/vim/$(VIMRTDIR)/
  	cp libiconv-2.dll dist/vim/$(VIMRTDIR)/
+ 	cp libgcc_s_sjlj-1.dll dist/vim/$(VIMRTDIR)/
  
  
  # Used before uploading.  Don't delete the AAPDIR/sign files!
*** ../vim-8.0.0409/nsis/gvim.nsi	2016-08-28 18:43:57.000000000 +0200
--- nsis/gvim.nsi	2017-03-04 19:52:56.471596945 +0100
***************
*** 385,390 ****
--- 385,391 ----
  		File ${VIMRT}\libintl-8.dll
  		File ${VIMRT}\libiconv-2.dll
  		File /nonfatal ${VIMRT}\libwinpthread-1.dll
+ 		File /nonfatal ${VIMRT}\libgcc_s_sjlj-1.dll
  	SectionEnd
  !endif
  
*** ../vim-8.0.0409/src/version.c	2017-03-04 19:11:08.434790994 +0100
--- src/version.c	2017-03-04 20:08:29.320340389 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     410,
  /**/

-- 
The real
trick is
this: to
keep the
lines as
short as
possible
and keep
the size
the same
yet free
from the
need for
hyphena-
Dammit!!  (Matthew Winn)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0411
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0411
Problem:    We can't change the case in menu entries, it breaks translations.
Solution:   Ignore case when looking up a menu translation.
Files:      src/menu.c, src/testdir/test_menu.vim


*** ../vim-8.0.0410/src/menu.c	2016-08-29 22:42:20.000000000 +0200
--- src/menu.c	2017-03-04 20:16:19.700592029 +0100
***************
*** 2455,2461 ****
      char_u		*dname;
  
      for (i = 0; i < menutrans_ga.ga_len; ++i)
! 	if (STRNCMP(name, tp[i].from, len) == 0 && tp[i].from[len] == NUL)
  	    return tp[i].to;
  
      /* Now try again while ignoring '&' characters. */
--- 2455,2461 ----
      char_u		*dname;
  
      for (i = 0; i < menutrans_ga.ga_len; ++i)
! 	if (STRNICMP(name, tp[i].from, len) == 0 && tp[i].from[len] == NUL)
  	    return tp[i].to;
  
      /* Now try again while ignoring '&' characters. */
***************
*** 2466,2472 ****
      if (dname != NULL)
      {
  	for (i = 0; i < menutrans_ga.ga_len; ++i)
! 	    if (STRCMP(dname, tp[i].from_noamp) == 0)
  	    {
  		vim_free(dname);
  		return tp[i].to;
--- 2466,2472 ----
      if (dname != NULL)
      {
  	for (i = 0; i < menutrans_ga.ga_len; ++i)
! 	    if (STRICMP(dname, tp[i].from_noamp) == 0)
  	    {
  		vim_free(dname);
  		return tp[i].to;
*** ../vim-8.0.0410/src/testdir/test_menu.vim	2016-01-03 23:23:48.000000000 +0100
--- src/testdir/test_menu.vim	2017-03-04 20:35:10.467763599 +0100
***************
*** 1,9 ****
--- 1,29 ----
  " Test that the system menu can be loaded.
  
+ if !has('menu')
+   finish
+ endif
+ 
  func Test_load_menu()
    try
      source $VIMRUNTIME/menu.vim
    catch
      call assert_false(1, 'error while loading menus: ' . v:exception)
    endtry
+   source $VIMRUNTIME/delmenu.vim
+ endfunc
+ 
+ func Test_translate_menu()
+   if !has('multi_lang')
+     return
+   endif
+   if !filereadable($VIMRUNTIME . '/lang/menu_de_de.latin1.vim')
+     throw 'Skipped: translated menu not found'
+   endif
+ 
+   set langmenu=de_de
+   source $VIMRUNTIME/menu.vim
+   call assert_match(':browse tabnew', execute(':menu File.In\ neuem\ Tab\ ffnen\.\.\.'))
+ 
+   source $VIMRUNTIME/delmenu.vim
  endfunc
*** ../vim-8.0.0410/src/version.c	2017-03-04 20:09:30.495831503 +0100
--- src/version.c	2017-03-04 20:22:36.617663263 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     411,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
48. You get a tatoo that says "This body best viewed with Netscape 3.1 or
    higher."

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0412
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0412 (after 8.0.0411)
Problem:    Menu test fails on MS-Windows.
Solution:   Use a menu entry with only ASCII characters.
Files:      src/testdir/test_menu.vim


*** ../vim-8.0.0411/src/testdir/test_menu.vim	2017-03-04 20:41:30.776854255 +0100
--- src/testdir/test_menu.vim	2017-03-04 21:00:08.108277296 +0100
***************
*** 23,29 ****
  
    set langmenu=de_de
    source $VIMRUNTIME/menu.vim
!   call assert_match(':browse tabnew', execute(':menu File.In\ neuem\ Tab\ ffnen\.\.\.'))
  
    source $VIMRUNTIME/delmenu.vim
  endfunc
--- 23,29 ----
  
    set langmenu=de_de
    source $VIMRUNTIME/menu.vim
!   call assert_match('browse confirm w', execute(':menu Datei.Speichern'))
  
    source $VIMRUNTIME/delmenu.vim
  endfunc
*** ../vim-8.0.0411/src/version.c	2017-03-04 20:41:30.776854255 +0100
--- src/version.c	2017-03-04 21:01:24.487684866 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     412,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
49. You never have to deal with busy signals when calling your ISP...because
    you never log off.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0413
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0413 (after 8.0.0412)
Problem:    Menu test fails on MS-Windows using gvim.
Solution:   First delete the English menus.
Files:      src/testdir/test_menu.vim


*** ../vim-8.0.0412/src/testdir/test_menu.vim	2017-03-04 21:02:16.683279776 +0100
--- src/testdir/test_menu.vim	2017-03-04 21:39:12.825984184 +0100
***************
*** 10,15 ****
--- 10,16 ----
    catch
      call assert_false(1, 'error while loading menus: ' . v:exception)
    endtry
+   call assert_match('browse confirm w', execute(':menu File.Save'))
    source $VIMRUNTIME/delmenu.vim
  endfunc
  
***************
*** 21,26 ****
--- 22,29 ----
      throw 'Skipped: translated menu not found'
    endif
  
+   " First delete any English menus.
+   source $VIMRUNTIME/delmenu.vim
    set langmenu=de_de
    source $VIMRUNTIME/menu.vim
    call assert_match('browse confirm w', execute(':menu Datei.Speichern'))
*** ../vim-8.0.0412/src/version.c	2017-03-04 21:02:16.683279776 +0100
--- src/version.c	2017-03-04 21:40:26.089412686 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     413,
  /**/

-- 
CVS sux, men don't like commitment

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0414
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0414
Problem:    Balloon eval is not tested.
Solution:   Add a few balloon tests. (Kazunobu Kuriyama)
Files:      src/testdir/test_gui.vim


*** ../vim-8.0.0413/src/testdir/test_gui.vim	2017-03-04 13:32:06.967801328 +0100
--- src/testdir/test_gui.vim	2017-03-05 13:25:24.010083703 +0100
***************
*** 22,27 ****
--- 22,35 ----
    call assert_equal(1, has('gui_running'))
  endfunc
  
+ " As for non-GUI, a balloon_show() test was already added with patch 8.0.0401
+ func Test_balloon_show()
+   if has('balloon_eval')
+     " This won't do anything but must not crash either.
+     call balloon_show('hi!')
+   endif
+ endfunc
+ 
  func Test_getfontname_with_arg()
    let skipped = ''
  
***************
*** 117,122 ****
--- 125,253 ----
    endif
  endfunc
  
+ func Test_set_balloondelay()
+   if !exists('+balloondelay')
+     return
+   endif
+ 
+   let balloondelay_saved = &balloondelay
+ 
+   " Check if the default value is identical to that described in the manual.
+   set balloondelay&
+   call assert_equal(600, &balloondelay)
+ 
+   " Edge cases
+ 
+   " XXX This fact should be hidden so that people won't be tempted to write
+   " plugin/TimeMachine.vim.  TODO Add reasonable range checks to the source
+   " code.
+   set balloondelay=-1
+   call assert_equal(-1, &balloondelay)
+ 
+   " Though it's possible to interpret the zero delay to be 'as soon as
+   " possible' or even 'indefinite', its actual meaning depends on the GUI
+   " toolkit in use after all.
+   set balloondelay=0
+   call assert_equal(0, &balloondelay)
+ 
+   set balloondelay=1
+   call assert_equal(1, &balloondelay)
+ 
+   " Since p_bdelay is of type long currently, the upper bound can be
+   " impractically huge and machine-dependent.  Practically, it's sufficient
+   " to check if balloondelay works with 0xffffffff (32 bits) for now.
+   set balloondelay=4294967295
+   call assert_equal(4294967295, &balloondelay)
+ 
+   let &balloondelay = balloondelay_saved
+ endfunc
+ 
+ func Test_set_ballooneval()
+   if !exists('+ballooneval')
+     return
+   endif
+ 
+   let ballooneval_saved = &ballooneval
+ 
+   set ballooneval&
+   call assert_equal(0, &ballooneval)
+ 
+   set ballooneval
+   call assert_notequal(0, &ballooneval)
+ 
+   set noballooneval
+   call assert_equal(0, &ballooneval)
+ 
+   let &ballooneval = ballooneval_saved
+ endfunc
+ 
+ func Test_set_balloonexpr()
+   if !exists('+balloonexpr')
+     return
+   endif
+ 
+   let balloonexpr_saved = &balloonexpr
+ 
+   " Default value
+   set balloonexpr&
+   call assert_equal('', &balloonexpr)
+ 
+   " User-defined function
+   new
+   func MyBalloonExpr()
+       return 'Cursor is at line ' . v:beval_lnum .
+ 	      \', column ' . v:beval_col .
+ 	      \ ' of file ' .  bufname(v:beval_bufnr) .
+ 	      \ ' on word "' . v:beval_text . '"' .
+ 	      \ ' in window ' . v:beval_winid . ' (#' . v:beval_winnr . ')'
+   endfunc
+   setl balloonexpr=MyBalloonExpr()
+   setl ballooneval
+   call assert_equal('MyBalloonExpr()', &balloonexpr)
+   " TODO Read non-empty text, place the pointer at a character of a word,
+   " and check if the content of the balloon is the smae as what is expected.
+   " Also, check if textlock works as expected.
+   setl balloonexpr&
+   call assert_equal('', &balloonexpr)
+   delfunc MyBalloonExpr
+   bwipe!
+ 
+   " Multiline support
+   if has('balloon_multiline')
+     " Multiline balloon using NL
+     new
+     func MyBalloonFuncForMultilineUsingNL()
+       return "Multiline\nSuppported\nBalloon\nusing NL"
+     endfunc
+     setl balloonexpr=MyBalloonFuncForMultilineUsingNL()
+     setl ballooneval
+     call assert_equal('MyBalloonFuncForMultilineUsingNL()', &balloonexpr)
+     " TODO Read non-empty text, place the pointer at a character of a word,
+     " and check if the content of the balloon is the smae as what is
+     " expected.  Also, check if textlock works as expected.
+     setl balloonexpr&
+     delfunc MyBalloonFuncForMultilineUsingNL
+     bwipe!
+ 
+     " Multiline balloon using List
+     new
+     func MyBalloonFuncForMultilineUsingList()
+       return [ 'Multiline', 'Suppported', 'Balloon', 'using List' ]
+     endfunc
+     setl balloonexpr=MyBalloonFuncForMultilineUsingList()
+     setl ballooneval
+     call assert_equal('MyBalloonFuncForMultilineUsingList()', &balloonexpr)
+     " TODO Read non-empty text, place the pointer at a character of a word,
+     " and check if the content of the balloon is the smae as what is
+     " expected.  Also, check if textlock works as expected.
+     setl balloonexpr&
+     delfunc MyBalloonFuncForMultilineUsingList
+     bwipe!
+   endif
+ 
+   let &balloonexpr = balloonexpr_saved
+ endfunc
+ 
  func Test_set_guifont()
    let skipped = ''
  
*** ../vim-8.0.0413/src/version.c	2017-03-04 21:40:56.393176702 +0100
--- src/version.c	2017-03-05 13:26:31.101580474 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     414,
  /**/

-- 
Never go to the toilet in a paperless office.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0415
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0415 (after 8.0.0414)
Problem:    Balloon test fails on MS-Windows.
Solution:   Test with 0x7fffffff instead of 0xffffffff.
Files:      src/testdir/test_gui.vim


*** ../vim-8.0.0414/src/testdir/test_gui.vim	2017-03-05 13:27:21.657200851 +0100
--- src/testdir/test_gui.vim	2017-03-05 13:46:38.904512441 +0100
***************
*** 155,163 ****
  
    " Since p_bdelay is of type long currently, the upper bound can be
    " impractically huge and machine-dependent.  Practically, it's sufficient
!   " to check if balloondelay works with 0xffffffff (32 bits) for now.
!   set balloondelay=4294967295
!   call assert_equal(4294967295, &balloondelay)
  
    let &balloondelay = balloondelay_saved
  endfunc
--- 155,163 ----
  
    " Since p_bdelay is of type long currently, the upper bound can be
    " impractically huge and machine-dependent.  Practically, it's sufficient
!   " to check if balloondelay works with 0x7fffffff (32 bits) for now.
!   set balloondelay=2147483647
!   call assert_equal(2147483647, &balloondelay)
  
    let &balloondelay = balloondelay_saved
  endfunc
*** ../vim-8.0.0414/src/version.c	2017-03-05 13:27:21.657200851 +0100
--- src/version.c	2017-03-05 13:43:04.494125396 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     415,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
52. You ask a plumber how much it would cost to replace the chair in front of
    your computer with a toilet.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0416
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0416
Problem:    Setting v:progpath is not quite right.
Solution:   On MS-Windows add the extension. On Unix use the full path for a
            relative directory. (partly by James McCoy, closes #1531)
Files:      src/main.c, src/os_win32.c, src/os_unix.c


*** ../vim-8.0.0415/src/main.c	2017-03-04 19:11:08.434790994 +0100
--- src/main.c	2017-03-05 14:13:11.212545322 +0100
***************
*** 3533,3553 ****
  set_progpath(char_u *argv0)
  {
      char_u *val = argv0;
      char_u buf[MAXPATHL];
  
      /* A relative path containing a "/" will become invalid when using ":cd",
       * turn it into a full path.
       * On MS-Windows "vim.exe" is found in the current directory, thus also do
       * it when there is no path and the file exists. */
!     if ( !mch_isFullName(argv0)
  # ifdef WIN32
! 	    && mch_can_exe(argv0, NULL, TRUE)
  # else
! 	    && gettail(argv0) != argv0
  # endif
! 	    && vim_FullName(argv0, buf, MAXPATHL, TRUE) != FAIL)
! 	val = buf;
      set_vim_var_string(VV_PROGPATH, val, -1);
  }
  
  #endif /* NO_VIM_MAIN */
--- 3533,3563 ----
  set_progpath(char_u *argv0)
  {
      char_u *val = argv0;
+ #ifdef WIN32
+     char_u *path = NULL;
+ #else
      char_u buf[MAXPATHL];
+ #endif
  
      /* A relative path containing a "/" will become invalid when using ":cd",
       * turn it into a full path.
       * On MS-Windows "vim.exe" is found in the current directory, thus also do
       * it when there is no path and the file exists. */
!     if (!mch_isFullName(argv0))
!     {
  # ifdef WIN32
! 	if (mch_can_exe(argv0, &path, FALSE) && path != NULL)
! 	    val = path;
  # else
! 	if (gettail(argv0) != argv0
! 			   && vim_FullName(argv0, buf, MAXPATHL, TRUE) != FAIL)
! 	    val = buf;
  # endif
!     }
      set_vim_var_string(VV_PROGPATH, val, -1);
+ #ifdef WIN32
+     vim_free(path);
+ #endif
  }
  
  #endif /* NO_VIM_MAIN */
*** ../vim-8.0.0415/src/os_win32.c	2017-03-01 20:32:40.143105301 +0100
--- src/os_win32.c	2017-03-05 14:02:09.309516465 +0100
***************
*** 1902,1918 ****
  #endif
  
  /*
!  * Return TRUE if "name" is in $PATH.
   * TODO: Should somehow check if it's really executable.
   */
      static int
! executable_exists(char *name, char_u **path)
  {
      char	*dum;
      char	fname[_MAX_PATH];
      char	*curpath, *newpath;
      long	n;
  
  #ifdef FEAT_MBYTE
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
--- 1902,1932 ----
  #endif
  
  /*
!  * If "use_path" is TRUE: Return TRUE if "name" is in $PATH.
!  * If "use_path" is FALSE: Return TRUE if "name" exists.
!  * When returning TRUE and "path" is not NULL save the path and set "*path" to
!  * the allocated memory.
   * TODO: Should somehow check if it's really executable.
   */
      static int
! executable_exists(char *name, char_u **path, int use_path)
  {
      char	*dum;
      char	fname[_MAX_PATH];
      char	*curpath, *newpath;
      long	n;
  
+     if (!use_path)
+     {
+ 	if (mch_getperm(name) != -1 && !mch_isdir(name))
+ 	{
+ 	    if (path != NULL)
+ 		*path = vim_strsave((char_u *)name);
+ 	    return TRUE;
+ 	}
+ 	return FALSE;
+     }
+ 
  #ifdef FEAT_MBYTE
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
***************
*** 2038,2044 ****
  	    vimrun_path = (char *)vim_strsave(vimrun_location);
  	    s_dont_use_vimrun = FALSE;
  	}
! 	else if (executable_exists("vimrun.exe", NULL))
  	    s_dont_use_vimrun = FALSE;
  
  	/* Don't give the warning for a missing vimrun.exe right now, but only
--- 2052,2058 ----
  	    vimrun_path = (char *)vim_strsave(vimrun_location);
  	    s_dont_use_vimrun = FALSE;
  	}
! 	else if (executable_exists("vimrun.exe", NULL, TRUE))
  	    s_dont_use_vimrun = FALSE;
  
  	/* Don't give the warning for a missing vimrun.exe right now, but only
***************
*** 2052,2058 ****
       * If "finstr.exe" doesn't exist, use "grep -n" for 'grepprg'.
       * Otherwise the default "findstr /n" is used.
       */
!     if (!executable_exists("findstr.exe", NULL))
  	set_option_value((char_u *)"grepprg", 0, (char_u *)"grep -n", 0);
  
  #ifdef FEAT_CLIPBOARD
--- 2066,2072 ----
       * If "finstr.exe" doesn't exist, use "grep -n" for 'grepprg'.
       * Otherwise the default "findstr /n" is used.
       */
!     if (!executable_exists("findstr.exe", NULL, TRUE))
  	set_option_value((char_u *)"grepprg", 0, (char_u *)"grep -n", 0);
  
  #ifdef FEAT_CLIPBOARD
***************
*** 3358,3366 ****
  }
  
  /*
!  * Return 1 if "name" can be executed, 0 if not.
   * If "use_path" is FALSE only check if "name" is executable.
!  * Return -1 if unknown.
   */
      int
  mch_can_exe(char_u *name, char_u **path, int use_path)
--- 3372,3381 ----
  }
  
  /*
!  * Return TRUE if "name" can be executed, FALSE if not.
   * If "use_path" is FALSE only check if "name" is executable.
!  * When returning TRUE and "path" is not NULL save the path and set "*path" to
!  * the allocated memory.
   */
      int
  mch_can_exe(char_u *name, char_u **path, int use_path)
***************
*** 3371,3387 ****
  
      if (len >= _MAX_PATH)	/* safety check */
  	return FALSE;
-     if (!use_path)
-     {
- 	/* TODO: check if file is really executable. */
- 	return mch_getperm(name) != -1 && !mch_isdir(name);
-     }
  
      /* If there already is an extension try using the name directly.  Also do
       * this with a Unix-shell like 'shell'. */
      if (vim_strchr(gettail(name), '.') != NULL
  			       || strstr((char *)gettail(p_sh), "sh") != NULL)
! 	if (executable_exists((char *)name, path))
  	    return TRUE;
  
      /*
--- 3386,3397 ----
  
      if (len >= _MAX_PATH)	/* safety check */
  	return FALSE;
  
      /* If there already is an extension try using the name directly.  Also do
       * this with a Unix-shell like 'shell'. */
      if (vim_strchr(gettail(name), '.') != NULL
  			       || strstr((char *)gettail(p_sh), "sh") != NULL)
! 	if (executable_exists((char *)name, path, use_path))
  	    return TRUE;
  
      /*
***************
*** 3403,3409 ****
  	}
  	else
  	    copy_option_part(&p, buf + len, _MAX_PATH - len, ";");
! 	if (executable_exists((char *)buf, path))
  	    return TRUE;
      }
      return FALSE;
--- 3413,3419 ----
  	}
  	else
  	    copy_option_part(&p, buf + len, _MAX_PATH - len, ";");
! 	if (executable_exists((char *)buf, path, use_path))
  	    return TRUE;
      }
      return FALSE;
*** ../vim-8.0.0415/src/os_unix.c	2017-03-01 20:32:40.143105301 +0100
--- src/os_unix.c	2017-03-05 14:19:26.093729136 +0100
***************
*** 3103,3109 ****
  	{
  	    if (path != NULL)
  	    {
! 		if (name[0] == '.')
  		    *path = FullName_save(name, TRUE);
  		else
  		    *path = vim_strsave(name);
--- 3103,3109 ----
  	{
  	    if (path != NULL)
  	    {
! 		if (name[0] != '/')
  		    *path = FullName_save(name, TRUE);
  		else
  		    *path = vim_strsave(name);
***************
*** 3142,3148 ****
  	{
  	    if (path != NULL)
  	    {
! 		if (buf[0] == '.')
  		    *path = FullName_save(buf, TRUE);
  		else
  		    *path = vim_strsave(buf);
--- 3142,3148 ----
  	{
  	    if (path != NULL)
  	    {
! 		if (buf[0] != '/')
  		    *path = FullName_save(buf, TRUE);
  		else
  		    *path = vim_strsave(buf);
*** ../vim-8.0.0415/src/version.c	2017-03-05 13:48:04.667867105 +0100
--- src/version.c	2017-03-05 14:21:00.701013738 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     416,
  /**/

-- 
Q: What is a patch 22?
A: A patch you need to include to make it possible to include patches.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0417
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0417
Problem:    Test for the clipboard fails sometimes.
Solution:   Add it to the flaky tests.
Files:      src/testdir/runtest.vim


*** ../vim-8.0.0416/src/testdir/runtest.vim	2017-02-27 21:35:49.618842663 +0100
--- src/testdir/runtest.vim	2017-03-05 14:24:06.171611631 +0100
***************
*** 168,173 ****
--- 168,174 ----
        \ 'Test_oneshot()',
        \ 'Test_pipe_through_sort_all()',
        \ 'Test_pipe_through_sort_some()',
+       \ 'Test_quoteplus()',
        \ 'Test_reltime()',
        \ ]
  
*** ../vim-8.0.0416/src/version.c	2017-03-05 14:29:08.721325460 +0100
--- src/version.c	2017-03-05 14:30:27.056733727 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     417,
  /**/

-- 
"I can't complain, but sometimes I still do."   (Joe Walsh)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0418
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0418
Problem:    ASAN logs are disabled and don't cause a failure.
Solution:   Enable ASAN logs and fail if not empty. (James McCoy,
            closes #1425)
Files:      .travis.yml


*** ../vim-8.0.0417/.travis.yml	2017-02-23 20:20:46.050319132 +0100
--- .travis.yml	2017-03-05 14:51:56.454961183 +0100
***************
*** 19,32 ****
    - BUILD=yes TEST=test COVERAGE=no FEATURES=huge SHADOWOPT= SRCDIR=./src CHECK_AUTOCONF=no
      "CONFOPT='--enable-perlinterp --enable-pythoninterp --enable-rubyinterp --enable-luainterp'"
      # ASAN build
!   - BUILD=yes TEST=test SANITIZER_CFLAGS="-g -O1 -fsanitize=address -fno-omit-frame-pointer" FEATURES=huge SRCDIR=./src CHECK_AUTOCONF=no
      "CONFOPT='--enable-perlinterp --enable-pythoninterp --enable-rubyinterp --enable-luainterp'"
  
  sudo: false
  
- git:
-   depth: 20
- 
  # instead of a 2*2*8 matrix (2*os + 2*compiler + 8*env),
  # exclude some builds on mac os x and linux
  # linux: 2*compiler + 5*env + mac: 2*compiler + 2*env
--- 19,30 ----
    - BUILD=yes TEST=test COVERAGE=no FEATURES=huge SHADOWOPT= SRCDIR=./src CHECK_AUTOCONF=no
      "CONFOPT='--enable-perlinterp --enable-pythoninterp --enable-rubyinterp --enable-luainterp'"
      # ASAN build
!   - BUILD=yes TEST=test SANITIZER_CFLAGS="-g -O1 -DABORT_ON_INTERNAL_ERROR -DEXITFREE -fsanitize=address -fno-omit-frame-pointer"
!     FEATURES=huge SRCDIR=./src CHECK_AUTOCONF=no ASAN_OPTIONS="print_stacktrace=1 log_path=asan"
      "CONFOPT='--enable-perlinterp --enable-pythoninterp --enable-rubyinterp --enable-luainterp'"
  
  sudo: false
  
  # instead of a 2*2*8 matrix (2*os + 2*compiler + 8*env),
  # exclude some builds on mac os x and linux
  # linux: 2*compiler + 5*env + mac: 2*compiler + 2*env
***************
*** 42,52 ****
        env: BUILD=yes TEST=scripttests COVERAGE=yes CFLAGS=--coverage LDFLAGS=--coverage FEATURES=huge SHADOWOPT= SRCDIR=./src CHECK_AUTOCONF=no
              "CONFOPT='--enable-perlinterp --enable-pythoninterp --enable-python3interp --enable-rubyinterp --enable-luainterp'"
      - os: osx
!       env: BUILD=yes TEST=test SANITIZER_CFLAGS="-g -O1 -fsanitize=address -fno-omit-frame-pointer" FEATURES=huge SRCDIR=./src CHECK_AUTOCONF=no
              "CONFOPT='--enable-perlinterp --enable-pythoninterp --enable-rubyinterp --enable-luainterp'"
      - os: linux
        compiler: gcc
!       env: BUILD=yes TEST=test SANITIZER_CFLAGS="-g -O1 -fsanitize=address -fno-omit-frame-pointer" FEATURES=huge SRCDIR=./src CHECK_AUTOCONF=no
              "CONFOPT='--enable-perlinterp --enable-pythoninterp --enable-rubyinterp --enable-luainterp'"
      - os: linux
        compiler: clang
--- 40,52 ----
        env: BUILD=yes TEST=scripttests COVERAGE=yes CFLAGS=--coverage LDFLAGS=--coverage FEATURES=huge SHADOWOPT= SRCDIR=./src CHECK_AUTOCONF=no
              "CONFOPT='--enable-perlinterp --enable-pythoninterp --enable-python3interp --enable-rubyinterp --enable-luainterp'"
      - os: osx
!       env: BUILD=yes TEST=test SANITIZER_CFLAGS="-g -O1 -DABORT_ON_INTERNAL_ERROR -DEXITFREE -fsanitize=address -fno-omit-frame-pointer"
!             FEATURES=huge SRCDIR=./src CHECK_AUTOCONF=no ASAN_OPTIONS="print_stacktrace=1 log_path=asan"
              "CONFOPT='--enable-perlinterp --enable-pythoninterp --enable-rubyinterp --enable-luainterp'"
      - os: linux
        compiler: gcc
!       env: BUILD=yes TEST=test SANITIZER_CFLAGS="-g -O1 -DABORT_ON_INTERNAL_ERROR -DEXITFREE -fsanitize=address -fno-omit-frame-pointer"
!             FEATURES=huge SRCDIR=./src CHECK_AUTOCONF=no ASAN_OPTIONS="print_stacktrace=1 log_path=asan"
              "CONFOPT='--enable-perlinterp --enable-pythoninterp --enable-rubyinterp --enable-luainterp'"
      - os: linux
        compiler: clang
***************
*** 92,98 ****
--- 92,101 ----
    - if [ "x$SHADOWOPT" != x ]; then make -C src shadow; fi
    - (cd ${SRCDIR} && ./configure --with-features=$FEATURES $CONFOPT --enable-fail-if-missing && if [ "$BUILD" = "yes" ]; then make -j$NPROC; fi)
    - if [ "$BUILD" = "yes" ]; then ${SRCDIR}/vim --version; fi
+   - if [ -n "$ASAN_OPTIONS" ]; then export PATH=/usr/lib/llvm-$(clang -v 2>&1 | sed -n 's/.*version \([1-9]\.[0-9][0-9]*\).*/\1/p')/bin:$PATH; fi
    - make $SHADOWOPT $TEST
+   - if [ -n "$ASAN_OPTIONS" ]; then for log in $(find -type f -name 'asan.*' -size +0); do cat "$log"; err=1; done; fi
+   - if [ -n "$err" ]; then exit 1; fi
  
  after_success:
    - if [ "$COVERAGE" = "yes" ]; then ~/.local/bin/coveralls -b $SRCDIR -x .xs -e ${SRCDIR}/xxd -e ${SRCDIR}/if_perl.c --encodings utf-8 latin-1 EUC-KR; fi
*** ../vim-8.0.0417/src/version.c	2017-03-05 14:30:48.372572724 +0100
--- src/version.c	2017-03-05 14:54:28.821804635 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     418,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
55. You ask your doctor to implant a gig in your brain.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0419
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0419
Problem:    Test for v:progpath fails on MS-Windows.
Solution:   Expand to full path.  Also add ".exe" when the path is an absolute
            path.
Files:      src/os_win32.c, src/main.c


*** ../vim-8.0.0418/src/os_win32.c	2017-03-05 14:29:08.717325490 +0100
--- src/os_win32.c	2017-03-05 15:12:18.152262944 +0100
***************
*** 1921,1927 ****
  	if (mch_getperm(name) != -1 && !mch_isdir(name))
  	{
  	    if (path != NULL)
! 		*path = vim_strsave((char_u *)name);
  	    return TRUE;
  	}
  	return FALSE;
--- 1921,1932 ----
  	if (mch_getperm(name) != -1 && !mch_isdir(name))
  	{
  	    if (path != NULL)
! 	    {
! 		if (mch_isFullName(name))
! 		    *path = vim_strsave((char_u *)name);
! 		else
! 		    *path = FullName_save((char_u *)name, FALSE);
! 	    }
  	    return TRUE;
  	}
  	return FALSE;
*** ../vim-8.0.0418/src/main.c	2017-03-05 14:29:08.717325490 +0100
--- src/main.c	2017-03-05 15:06:05.156510344 +0100
***************
*** 3533,3563 ****
  set_progpath(char_u *argv0)
  {
      char_u *val = argv0;
- #ifdef WIN32
-     char_u *path = NULL;
- #else
-     char_u buf[MAXPATHL];
- #endif
  
      /* A relative path containing a "/" will become invalid when using ":cd",
       * turn it into a full path.
!      * On MS-Windows "vim.exe" is found in the current directory, thus also do
!      * it when there is no path and the file exists. */
!     if (!mch_isFullName(argv0))
!     {
  # ifdef WIN32
! 	if (mch_can_exe(argv0, &path, FALSE) && path != NULL)
! 	    val = path;
  # else
  	if (gettail(argv0) != argv0
  			   && vim_FullName(argv0, buf, MAXPATHL, TRUE) != FAIL)
  	    val = buf;
- # endif
      }
      set_vim_var_string(VV_PROGPATH, val, -1);
! #ifdef WIN32
      vim_free(path);
! #endif
  }
  
  #endif /* NO_VIM_MAIN */
--- 3533,3562 ----
  set_progpath(char_u *argv0)
  {
      char_u *val = argv0;
  
      /* A relative path containing a "/" will become invalid when using ":cd",
       * turn it into a full path.
!      * On MS-Windows "vim" should be expanded to "vim.exe", thus always do
!      * this. */
  # ifdef WIN32
!     char_u *path = NULL;
! 
!     if (mch_can_exe(argv0, &path, FALSE) && path != NULL)
! 	val = path;
  # else
+     char_u buf[MAXPATHL];
+ 
+     if (!mch_isFullName(argv0))
+     {
  	if (gettail(argv0) != argv0
  			   && vim_FullName(argv0, buf, MAXPATHL, TRUE) != FAIL)
  	    val = buf;
      }
+ # endif
      set_vim_var_string(VV_PROGPATH, val, -1);
! # ifdef WIN32
      vim_free(path);
! # endif
  }
  
  #endif /* NO_VIM_MAIN */
*** ../vim-8.0.0418/src/version.c	2017-03-05 14:56:03.601083320 +0100
--- src/version.c	2017-03-05 15:07:04.464059946 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     419,
  /**/

-- 
ERROR 047: Keyboard not found.  Press RETURN to continue.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0420
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0420
Problem:    When running :make the output may be in the system encoding,
            different from 'encoding'.
Solution:   Add the 'makeencoding' option. (Ken Takata)
Files:      runtime/doc/options.txt, runtime/doc/quickfix.txt,
            runtime/doc/quickref.txt, src/Makefile, src/buffer.c,
            src/if_cscope.c, src/main.c, src/option.c, src/option.h,
            src/proto/quickfix.pro, src/quickfix.c, src/structs.h,
            src/testdir/Make_all.mak, src/testdir/test_makeencoding.py,
            src/testdir/test_makeencoding.vim


*** ../vim-8.0.0419/runtime/doc/options.txt	2017-01-28 15:58:45.340197300 +0100
--- runtime/doc/options.txt	2017-03-05 17:10:37.131206854 +0100
***************
*** 4946,4951 ****
--- 4994,5018 ----
  	This option cannot be set from a |modeline| or in the |sandbox|, for
  	security reasons.
  
+ 					*'makeencoding'* *'menc'*
+ 'makeencoding' 'menc'	string	(default "")
+ 			global or local to buffer |global-local|
+ 			{only available when compiled with the |+multi_byte|
+ 			feature}
+ 			{not in Vi}
+ 	Encoding used for reading the output of external commands.  When empty,
+ 	encoding is not converted.
+ 	This is used for `:make`, `:lmake`, `:grep`, `:lgrep`, `:grepadd`,
+ 	`:lgrepadd`, `:cfile`, `:cgetfile`, `:caddfile`, `:lfile`, `:lgetfile`,
+ 	and `:laddfile`.
+ 
+ 	This would be mostly useful when you use MS-Windows and set 'encoding'
+ 	to "utf-8".  If |+iconv| is enabled and GNU libiconv is used, setting
+ 	'makeencoding' to "char" has the same effect as setting to the system
+ 	locale encoding.  Example: >
+ 		:set encoding=utf-8
+ 		:set makeencoding=char	" system locale is used
+ <
  						*'makeprg'* *'mp'*
  'makeprg' 'mp'		string	(default "make", VMS: "MMS")
  			global or local to buffer |global-local|
*** ../vim-8.0.0419/runtime/doc/quickfix.txt	2016-09-12 12:45:48.000000000 +0200
--- runtime/doc/quickfix.txt	2017-03-05 17:10:37.131206854 +0100
***************
*** 164,169 ****
--- 164,172 ----
  			keep Vim running while compiling.  If you give the
  			name of the errorfile, the 'errorfile' option will
  			be set to [errorfile].  See |:cc| for [!].
+ 			If the encoding of the error file differs from the
+ 			'encoding' option, you can use the 'makeencoding'
+ 			option to specify the encoding.
  
  							*:lf* *:lfile*
  :lf[ile][!] [errorfile]	Same as ":cfile", except the location list for the
***************
*** 175,180 ****
--- 178,186 ----
  :cg[etfile] [errorfile]					*:cg* *:cgetfile*
  			Read the error file.  Just like ":cfile" but don't
  			jump to the first error.
+ 			If the encoding of the error file differs from the
+ 			'encoding' option, you can use the 'makeencoding'
+ 			option to specify the encoding.
  
  
  :lg[etfile] [errorfile]					*:lg* *:lgetfile*
***************
*** 185,190 ****
--- 191,199 ----
  :caddf[ile] [errorfile]	Read the error file and add the errors from the
  			errorfile to the current quickfix list. If a quickfix
  			list is not present, then a new list is created.
+ 			If the encoding of the error file differs from the
+ 			'encoding' option, you can use the 'makeencoding'
+ 			option to specify the encoding.
  
  							*:laddf* *:laddfile*
  :laddf[ile] [errorfile]	Same as ":caddfile", except the location list for the
***************
*** 320,325 ****
--- 329,335 ----
  	endfunction
  
  	au QuickfixCmdPost make call QfMakeConv()
+ Another option is using 'makeencoding'.
  
  
  EXECUTE A COMMAND IN ALL THE BUFFERS IN QUICKFIX OR LOCATION LIST:
***************
*** 586,591 ****
--- 596,604 ----
  			   like |:cnext| and |:cprevious|, see above.
  			This command does not accept a comment, any "
  			characters are considered part of the arguments.
+ 			If the encoding of the program output differs from the
+ 			'encoding' option, you can use the 'makeencoding'
+ 			option to specify the encoding.
  
  							*:lmak* *:lmake*
  :lmak[e][!] [arguments]
***************
*** 645,650 ****
--- 658,664 ----
  	au QuickfixCmdPost make call QfMakeConv()
  
  (Example by Faque Cheng)
+ Another option is using 'makeencoding'.
  
  ==============================================================================
  5. Using :vimgrep and :grep				*grep* *lid*
***************
*** 759,764 ****
--- 773,781 ----
  			When 'grepprg' is "internal" this works like
  			|:vimgrep|.  Note that the pattern needs to be
  			enclosed in separator characters then.
+ 			If the encoding of the program output differs from the
+ 			'encoding' option, you can use the 'makeencoding'
+ 			option to specify the encoding.
  
  							    *:lgr* *:lgrep*
  :lgr[ep][!] [arguments]	Same as ":grep", except the location list for the
***************
*** 783,788 ****
--- 800,809 ----
  				  \ | catch /E480:/
  				  \ | endtry"
  <
+ 			If the encoding of the program output differs from the
+ 			'encoding' option, you can use the 'makeencoding'
+ 			option to specify the encoding.
+ 
  							*:lgrepa* *:lgrepadd*
  :lgrepa[dd][!] [arguments]
  			Same as ":grepadd", except the location list for the
*** ../vim-8.0.0419/runtime/doc/quickref.txt	2017-01-28 15:58:45.340197300 +0100
--- runtime/doc/quickref.txt	2017-03-05 17:10:37.131206854 +0100
***************
*** 782,787 ****
--- 782,788 ----
  'macatsui'		    Mac GUI: use ATSUI text drawing
  'magic'			    changes special characters in search patterns
  'makeef'	  'mef'     name of the errorfile for ":make"
+ 'makeencoding'	  'menc'    encoding of external make/grep commands
  'makeprg'	  'mp'	    program to use for the ":make" command
  'matchpairs'	  'mps'     pairs of characters that "%" can match
  'matchtime'	  'mat'     tenths of a second to show matching paren
*** ../vim-8.0.0419/src/Makefile	2017-02-27 21:48:06.217790605 +0100
--- src/Makefile	2017-03-05 17:10:37.131206854 +0100
***************
*** 2157,2162 ****
--- 2157,2163 ----
  	test_listlbr \
  	test_listlbr_utf8 \
  	test_lua \
+ 	test_makeencoding \
  	test_man \
  	test_mapping \
  	test_marks \
*** ../vim-8.0.0419/src/buffer.c	2017-02-25 15:41:33.142201356 +0100
--- src/buffer.c	2017-03-05 17:10:37.131206854 +0100
***************
*** 2255,2260 ****
--- 2255,2263 ----
      clear_string_option(&buf->b_p_lw);
  #endif
      clear_string_option(&buf->b_p_bkc);
+ #ifdef FEAT_MBYTE
+     clear_string_option(&buf->b_p_menc);
+ #endif
  }
  
  /*
*** ../vim-8.0.0419/src/if_cscope.c	2017-01-15 17:18:52.684270653 +0100
--- src/if_cscope.c	2017-03-05 17:10:37.131206854 +0100
***************
*** 1242,1248 ****
  		wp = curwin;
  	    /* '-' starts a new error list */
  	    if (qf_init(wp, tmp, (char_u *)"%f%*\\t%l%*\\t%m",
! 						  *qfpos == '-', cmdline) > 0)
  	    {
  # ifdef FEAT_WINDOWS
  		if (postponed_split != 0)
--- 1242,1248 ----
  		wp = curwin;
  	    /* '-' starts a new error list */
  	    if (qf_init(wp, tmp, (char_u *)"%f%*\\t%l%*\\t%m",
! 					  *qfpos == '-', cmdline, NULL) > 0)
  	    {
  # ifdef FEAT_WINDOWS
  		if (postponed_split != 0)
*** ../vim-8.0.0419/src/main.c	2017-03-05 15:19:28.278417362 +0100
--- src/main.c	2017-03-05 17:10:37.131206854 +0100
***************
*** 559,569 ****
       */
      if (params.edit_type == EDIT_QF)
      {
  	if (params.use_ef != NULL)
  	    set_string_option_direct((char_u *)"ef", -1,
  					   params.use_ef, OPT_FREE, SID_CARG);
  	vim_snprintf((char *)IObuff, IOSIZE, "cfile %s", p_ef);
! 	if (qf_init(NULL, p_ef, p_efm, TRUE, IObuff) < 0)
  	{
  	    out_char('\n');
  	    mch_exit(3);
--- 559,574 ----
       */
      if (params.edit_type == EDIT_QF)
      {
+ 	char_u	*enc = NULL;
+ 
+ # ifdef FEAT_MBYTE
+ 	enc = p_menc;
+ # endif
  	if (params.use_ef != NULL)
  	    set_string_option_direct((char_u *)"ef", -1,
  					   params.use_ef, OPT_FREE, SID_CARG);
  	vim_snprintf((char *)IObuff, IOSIZE, "cfile %s", p_ef);
! 	if (qf_init(NULL, p_ef, p_efm, TRUE, IObuff, enc) < 0)
  	{
  	    out_char('\n');
  	    mch_exit(3);
*** ../vim-8.0.0419/src/option.c	2017-02-25 22:37:10.015880173 +0100
--- src/option.c	2017-03-05 17:18:16.131693875 +0100
***************
*** 139,144 ****
--- 139,147 ----
  # define PV_LISP	OPT_BUF(BV_LISP)
  # define PV_LW		OPT_BOTH(OPT_BUF(BV_LW))
  #endif
+ #ifdef FEAT_MBYTE
+ # define PV_MENC	OPT_BOTH(OPT_BUF(BV_MENC))
+ #endif
  #define PV_MA		OPT_BUF(BV_MA)
  #define PV_ML		OPT_BUF(BV_ML)
  #define PV_MOD		OPT_BUF(BV_MOD)
***************
*** 1900,1905 ****
--- 1903,1917 ----
  			    {(char_u *)NULL, (char_u *)0L}
  #endif
  			    SCRIPTID_INIT},
+     {"makeencoding","menc", P_STRING|P_VI_DEF,
+ #ifdef FEAT_MBYTE
+ 			    (char_u *)&p_menc, PV_MENC,
+ 			    {(char_u *)"", (char_u *)0L}
+ #else
+ 			    (char_u *)NULL, PV_NONE,
+ 			    {(char_u *)0L, (char_u *)0L}
+ #endif
+ 			    SCRIPTID_INIT},
      {"makeprg",	    "mp",   P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  #ifdef FEAT_QUICKFIX
  			    (char_u *)&p_mp, PV_MP,
***************
*** 5686,5691 ****
--- 5698,5706 ----
      check_string_option(&buf->b_p_lw);
  #endif
      check_string_option(&buf->b_p_bkc);
+ #ifdef FEAT_MBYTE
+     check_string_option(&buf->b_p_menc);
+ #endif
  }
  
  /*
***************
*** 6289,6296 ****
  #endif
  
  #ifdef FEAT_MBYTE
!     /* 'encoding' and 'fileencoding' */
!     else if (varp == &p_enc || gvarp == &p_fenc || varp == &p_tenc)
      {
  	if (gvarp == &p_fenc)
  	{
--- 6304,6312 ----
  #endif
  
  #ifdef FEAT_MBYTE
!     /* 'encoding', 'fileencoding', 'termencoding' and 'makeencoding' */
!     else if (varp == &p_enc || gvarp == &p_fenc || varp == &p_tenc
! 							   || gvarp == &p_menc)
      {
  	if (gvarp == &p_fenc)
  	{
***************
*** 10425,10430 ****
--- 10441,10451 ----
  	    clear_string_option(&buf->b_p_lw);
  	    break;
  #endif
+ #ifdef FEAT_MBYTE
+ 	case PV_MENC:
+ 	    clear_string_option(&buf->b_p_menc);
+ 	    break;
+ #endif
      }
  }
  
***************
*** 10478,10483 ****
--- 10499,10507 ----
  	    case PV_LW:   return (char_u *)&(curbuf->b_p_lw);
  #endif
  	    case PV_BKC:  return (char_u *)&(curbuf->b_p_bkc);
+ #ifdef FEAT_MBYTE
+ 	    case PV_MENC: return (char_u *)&(curbuf->b_p_menc);
+ #endif
  	}
  	return NULL; /* "cannot happen" */
      }
***************
*** 10553,10558 ****
--- 10577,10586 ----
  	case PV_LW:	return *curbuf->b_p_lw != NUL
  				    ? (char_u *)&(curbuf->b_p_lw) : p->var;
  #endif
+ #ifdef FEAT_MBYTE
+ 	case PV_MENC:	return *curbuf->b_p_menc != NUL
+ 				    ? (char_u *)&(curbuf->b_p_menc) : p->var;
+ #endif
  
  #ifdef FEAT_ARABIC
  	case PV_ARAB:	return (char_u *)&(curwin->w_p_arab);
***************
*** 11154,11159 ****
--- 11182,11190 ----
  #ifdef FEAT_LISP
  	    buf->b_p_lw = empty_option;
  #endif
+ #ifdef FEAT_MBYTE
+ 	    buf->b_p_menc = empty_option;
+ #endif
  
  	    /*
  	     * Don't copy the options set by ex_help(), use the saved values,
*** ../vim-8.0.0419/src/option.h	2017-01-28 15:58:45.352197224 +0100
--- src/option.h	2017-03-05 17:10:37.135206824 +0100
***************
*** 630,635 ****
--- 630,638 ----
  EXTERN int	p_macatsui;	/* 'macatsui' */
  #endif
  EXTERN int	p_magic;	/* 'magic' */
+ #ifdef FEAT_MBYTE
+ EXTERN char_u	*p_menc;	/* 'makeencoding' */
+ #endif
  #ifdef FEAT_QUICKFIX
  EXTERN char_u	*p_mef;		/* 'makeef' */
  EXTERN char_u	*p_mp;		/* 'makeprg' */
***************
*** 1065,1070 ****
--- 1068,1076 ----
      , BV_LISP
      , BV_LW
  #endif
+ #ifdef FEAT_MBYTE
+     , BV_MENC
+ #endif
      , BV_MA
      , BV_ML
      , BV_MOD
*** ../vim-8.0.0419/src/proto/quickfix.pro	2016-09-12 13:04:17.000000000 +0200
--- src/proto/quickfix.pro	2017-03-05 17:10:37.135206824 +0100
***************
*** 1,5 ****
  /* quickfix.c */
! int qf_init(win_T *wp, char_u *efile, char_u *errorformat, int newlist, char_u *qf_title);
  void qf_free_all(win_T *wp);
  void copy_loclist(win_T *from, win_T *to);
  void qf_jump(qf_info_T *qi, int dir, int errornr, int forceit);
--- 1,5 ----
  /* quickfix.c */
! int qf_init(win_T *wp, char_u *efile, char_u *errorformat, int newlist, char_u *qf_title, char_u *enc);
  void qf_free_all(win_T *wp);
  void copy_loclist(win_T *from, win_T *to);
  void qf_jump(qf_info_T *qi, int dir, int errornr, int forceit);
*** ../vim-8.0.0419/src/quickfix.c	2016-11-13 15:09:21.301005386 +0100
--- src/quickfix.c	2017-03-05 17:31:16.949720034 +0100
***************
*** 116,122 ****
  
  static efm_T	*fmt_start = NULL; /* cached across qf_parse_line() calls */
  
! static int	qf_init_ext(qf_info_T *qi, char_u *efile, buf_T *buf, typval_T *tv, char_u *errorformat, int newlist, linenr_T lnumfirst, linenr_T lnumlast, char_u *qf_title);
  static void	qf_store_title(qf_info_T *qi, char_u *title);
  static void	qf_new_list(qf_info_T *qi, char_u *qf_title);
  static void	ll_free_all(qf_info_T **pqi);
--- 116,122 ----
  
  static efm_T	*fmt_start = NULL; /* cached across qf_parse_line() calls */
  
! static int	qf_init_ext(qf_info_T *qi, char_u *efile, buf_T *buf, typval_T *tv, char_u *errorformat, int newlist, linenr_T lnumfirst, linenr_T lnumlast, char_u *qf_title, char_u *enc);
  static void	qf_store_title(qf_info_T *qi, char_u *title);
  static void	qf_new_list(qf_info_T *qi, char_u *qf_title);
  static void	ll_free_all(qf_info_T **pqi);
***************
*** 167,173 ****
      char_u	    *efile,
      char_u	    *errorformat,
      int		    newlist,		/* TRUE: start a new error list */
!     char_u	    *qf_title)
  {
      qf_info_T	    *qi = &ql_info;
  
--- 167,174 ----
      char_u	    *efile,
      char_u	    *errorformat,
      int		    newlist,		/* TRUE: start a new error list */
!     char_u	    *qf_title,
!     char_u	    *enc)
  {
      qf_info_T	    *qi = &ql_info;
  
***************
*** 180,186 ****
  
      return qf_init_ext(qi, efile, curbuf, NULL, errorformat, newlist,
  						    (linenr_T)0, (linenr_T)0,
! 						    qf_title);
  }
  
  /*
--- 181,187 ----
  
      return qf_init_ext(qi, efile, curbuf, NULL, errorformat, newlist,
  						    (linenr_T)0, (linenr_T)0,
! 						    qf_title, enc);
  }
  
  /*
***************
*** 498,503 ****
--- 499,505 ----
      buf_T	*buf;
      linenr_T	buflnum;
      linenr_T	lnumlast;
+     vimconv_T	vc;
  } qfstate_T;
  
      static char_u *
***************
*** 713,718 ****
--- 715,744 ----
      else
  	state->linebuf = IObuff;
  
+ #ifdef FEAT_MBYTE
+     /* Convert a line if it contains a non-ASCII character. */
+     if (state->vc.vc_type != CONV_NONE && has_non_ascii(state->linebuf)) {
+ 	char_u	*line;
+ 
+ 	line = string_convert(&state->vc, state->linebuf, &state->linelen);
+ 	if (line != NULL)
+ 	{
+ 	    if (state->linelen < IOSIZE)
+ 	    {
+ 		STRCPY(state->linebuf, line);
+ 		vim_free(line);
+ 	    }
+ 	    else
+ 	    {
+ 		vim_free(state->growbuf);
+ 		state->linebuf = state->growbuf = line;
+ 		state->growbufsiz = state->linelen < LINE_MAXLEN
+ 						? state->linelen : LINE_MAXLEN;
+ 	    }
+ 	}
+     }
+ #endif
+ 
      return QF_OK;
  }
  
***************
*** 1105,1115 ****
      int		    newlist,		/* TRUE: start a new error list */
      linenr_T	    lnumfirst,		/* first line number to use */
      linenr_T	    lnumlast,		/* last line number to use */
!     char_u	    *qf_title)
  {
!     qfstate_T	    state = {NULL, 0, NULL, 0, NULL, NULL, NULL, NULL,
! 			     NULL, 0, 0};
!     qffields_T	    fields = {NULL, NULL, 0, 0L, 0, FALSE, NULL, 0, 0, 0};
  #ifdef FEAT_WINDOWS
      qfline_T	    *old_last = NULL;
      int		    adding = FALSE;
--- 1131,1141 ----
      int		    newlist,		/* TRUE: start a new error list */
      linenr_T	    lnumfirst,		/* first line number to use */
      linenr_T	    lnumlast,		/* last line number to use */
!     char_u	    *qf_title,
!     char_u	    *enc)
  {
!     qfstate_T	    state;
!     qffields_T	    fields;
  #ifdef FEAT_WINDOWS
      qfline_T	    *old_last = NULL;
      int		    adding = FALSE;
***************
*** 1120,1125 ****
--- 1146,1158 ----
      int		    retval = -1;	/* default: return error flag */
      int		    status;
  
+     vim_memset(&state, 0, sizeof(state));
+     vim_memset(&fields, 0, sizeof(fields));
+ #ifdef FEAT_MBYTE
+     state.vc.vc_type = CONV_NONE;
+     if (enc != NULL && *enc != NUL)
+ 	convert_setup(&state.vc, enc, p_enc);
+ #endif
      fields.namebuf = alloc_id(CMDBUFFSIZE + 1, aid_qf_namebuf);
      fields.errmsglen = CMDBUFFSIZE + 1;
      fields.errmsg = alloc_id(fields.errmsglen, aid_qf_errmsg);
***************
*** 1286,1291 ****
--- 1319,1328 ----
  #ifdef FEAT_WINDOWS
      qf_update_buffer(qi, old_last);
  #endif
+ #ifdef FEAT_MBYTE
+     if (state.vc.vc_type != CONV_NONE)
+ 	convert_setup(&state.vc, NULL, NULL);
+ #endif
  
      return retval;
  }
***************
*** 3431,3436 ****
--- 3468,3474 ----
  {
      char_u	*fname;
      char_u	*cmd;
+     char_u	*enc = NULL;
      unsigned	len;
      win_T	*wp = NULL;
      qf_info_T	*qi = &ql_info;
***************
*** 3464,3469 ****
--- 3502,3510 ----
  # endif
      }
  #endif
+ #ifdef FEAT_MBYTE
+     enc = (*curbuf->b_p_menc != NUL) ? curbuf->b_p_menc : p_menc;
+ #endif
  
      if (eap->cmdidx == CMD_lmake || eap->cmdidx == CMD_lgrep
  	|| eap->cmdidx == CMD_lgrepadd)
***************
*** 3511,3517 ****
  			    && eap->cmdidx != CMD_lmake) ? p_gefm : p_efm,
  					   (eap->cmdidx != CMD_grepadd
  					    && eap->cmdidx != CMD_lgrepadd),
! 					   *eap->cmdlinep);
      if (wp != NULL)
  	qi = GET_LOC_LIST(wp);
  #ifdef FEAT_AUTOCMD
--- 3552,3558 ----
  			    && eap->cmdidx != CMD_lmake) ? p_gefm : p_efm,
  					   (eap->cmdidx != CMD_grepadd
  					    && eap->cmdidx != CMD_lgrepadd),
! 					   *eap->cmdlinep, enc);
      if (wp != NULL)
  	qi = GET_LOC_LIST(wp);
  #ifdef FEAT_AUTOCMD
***************
*** 3850,3855 ****
--- 3891,3897 ----
      void
  ex_cfile(exarg_T *eap)
  {
+     char_u	*enc = NULL;
      win_T	*wp = NULL;
      qf_info_T	*qi = &ql_info;
  #ifdef FEAT_AUTOCMD
***************
*** 3874,3879 ****
--- 3916,3924 ----
      if (au_name != NULL)
  	apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name, NULL, FALSE, curbuf);
  #endif
+ #ifdef FEAT_MBYTE
+     enc = (*curbuf->b_p_menc != NUL) ? curbuf->b_p_menc : p_menc;
+ #endif
  #ifdef FEAT_BROWSE
      if (cmdmod.browse)
      {
***************
*** 3901,3907 ****
       */
      if (qf_init(wp, p_ef, p_efm, (eap->cmdidx != CMD_caddfile
  				  && eap->cmdidx != CMD_laddfile),
! 							   *eap->cmdlinep) > 0
  				  && (eap->cmdidx == CMD_cfile
  					     || eap->cmdidx == CMD_lfile))
      {
--- 3946,3952 ----
       */
      if (qf_init(wp, p_ef, p_efm, (eap->cmdidx != CMD_caddfile
  				  && eap->cmdidx != CMD_laddfile),
! 						       *eap->cmdlinep, enc) > 0
  				  && (eap->cmdidx == CMD_cfile
  					     || eap->cmdidx == CMD_lfile))
      {
***************
*** 4927,4933 ****
  			    (eap->cmdidx != CMD_caddbuffer
  			     && eap->cmdidx != CMD_laddbuffer),
  						   eap->line1, eap->line2,
! 						   qf_title) > 0)
  	    {
  #ifdef FEAT_AUTOCMD
  		if (au_name != NULL)
--- 4972,4978 ----
  			    (eap->cmdidx != CMD_caddbuffer
  			     && eap->cmdidx != CMD_laddbuffer),
  						   eap->line1, eap->line2,
! 						   qf_title, NULL) > 0)
  	    {
  #ifdef FEAT_AUTOCMD
  		if (au_name != NULL)
***************
*** 4995,5001 ****
  	    if (qf_init_ext(qi, NULL, NULL, tv, p_efm,
  			    (eap->cmdidx != CMD_caddexpr
  			     && eap->cmdidx != CMD_laddexpr),
! 				 (linenr_T)0, (linenr_T)0, *eap->cmdlinep) > 0)
  	    {
  #ifdef FEAT_AUTOCMD
  		if (au_name != NULL)
--- 5040,5047 ----
  	    if (qf_init_ext(qi, NULL, NULL, tv, p_efm,
  			    (eap->cmdidx != CMD_caddexpr
  			     && eap->cmdidx != CMD_laddexpr),
! 				 (linenr_T)0, (linenr_T)0, *eap->cmdlinep,
! 				 NULL) > 0)
  	    {
  #ifdef FEAT_AUTOCMD
  		if (au_name != NULL)
*** ../vim-8.0.0419/src/structs.h	2017-02-25 14:59:29.902090452 +0100
--- src/structs.h	2017-03-05 17:10:37.139206793 +0100
***************
*** 2133,2138 ****
--- 2133,2141 ----
  #ifdef FEAT_LISP
      int		b_p_lisp;	/* 'lisp' */
  #endif
+ #ifdef FEAT_MBYTE
+     char_u	*b_p_menc;	/* 'makeencoding' */
+ #endif
      char_u	*b_p_mps;	/* 'matchpairs' */
      int		b_p_ml;		/* 'modeline' */
      int		b_p_ml_nobin;	/* b_p_ml saved for binary mode */
*** ../vim-8.0.0419/src/testdir/Make_all.mak	2017-02-27 21:48:06.217790605 +0100
--- src/testdir/Make_all.mak	2017-03-05 17:10:37.139206793 +0100
***************
*** 170,175 ****
--- 170,176 ----
  	    test_listlbr.res \
  	    test_listlbr_utf8.res \
  	    test_lua.res \
+ 	    test_makeencoding.res \
  	    test_man.res \
  	    test_marks.res \
  	    test_matchadd_conceal.res \
*** ../vim-8.0.0419/src/testdir/test_makeencoding.py	2017-03-05 17:35:05.371967791 +0100
--- src/testdir/test_makeencoding.py	2017-03-05 17:10:37.139206793 +0100
***************
*** 0 ****
--- 1,67 ----
+ #!/usr/bin/python
+ # -*- coding: utf-8 -*-
+ 
+ # Test program for :make, :grep and :cgetfile.
+ 
+ from __future__ import print_function, unicode_literals
+ import locale
+ import io
+ import sys
+ 
+ def set_output_encoding(enc=None):
+     """Set the encoding of stdout and stderr
+ 
+     arguments:
+       enc -- Encoding name.
+              If omitted, locale.getpreferredencoding() is used.
+     """
+     if enc is None:
+         enc = locale.getpreferredencoding()
+ 
+     def get_text_writer(fo, **kwargs):
+         kw = dict(kwargs)
+         kw.setdefault('errors', 'backslashreplace') # use \uXXXX style
+         kw.setdefault('closefd', False)
+ 
+         if sys.version_info[0] < 3:
+             # Work around for Python 2.x
+             # New line conversion isn't needed here. Done in somewhere else.
+             writer = io.open(fo.fileno(), mode='w', newline='', **kw)
+             write = writer.write    # save the original write() function
+             enc = locale.getpreferredencoding()
+             def convwrite(s):
+                 if isinstance(s, bytes):
+                     write(s.decode(enc))    # convert to unistr
+                 else:
+                     write(s)
+                 try:
+                     writer.flush()  # needed on Windows
+                 except IOError:
+                     pass
+             writer.write = convwrite
+         else:
+             writer = io.open(fo.fileno(), mode='w', **kw)
+         return writer
+ 
+     sys.stdout = get_text_writer(sys.stdout, encoding=enc)
+     sys.stderr = get_text_writer(sys.stderr, encoding=enc)
+ 
+ 
+ def main():
+     enc = 'utf-8'
+     if len(sys.argv) > 1:
+         enc = sys.argv[1]
+     set_output_encoding(enc)
+ 
+     message_tbl = {
+             'utf-8': '  ',
+             'latin1': '',
+             'cp932': '',
+             'cp936': '',
+             }
+ 
+     print('Xfoobar.c(10) : %s (%s)' % (message_tbl[enc], enc))
+ 
+ 
+ if __name__ == "__main__":
+     main()
*** ../vim-8.0.0419/src/testdir/test_makeencoding.vim	2017-03-05 17:35:05.379967730 +0100
--- src/testdir/test_makeencoding.vim	2017-03-05 17:10:37.139206793 +0100
***************
*** 0 ****
--- 1,106 ----
+ " Tests for 'makeencoding'.
+ if !has('multi_byte')
+   finish
+ endif
+ 
+ source shared.vim
+ 
+ let s:python = PythonProg()
+ if s:python == ''
+   " Can't run this test.
+   finish
+ endif
+ 
+ let s:script = 'test_makeencoding.py'
+ 
+ let s:message_tbl = {
+       \ 'utf-8': '  ',
+       \ 'latin1': '',
+       \ 'cp932': '',
+       \ 'cp936': '',
+       \}
+ 
+ 
+ " Tests for :cgetfile and :lgetfile.
+ func Test_getfile()
+   set errorfile=Xerror.txt
+   set errorformat=%f(%l)\ :\ %m
+ 
+   " :cgetfile
+   for enc in keys(s:message_tbl)
+     let &makeencoding = enc
+     exec "silent !" . s:python . " " . s:script . " " . enc . " > " . &errorfile
+     cgetfile
+     copen
+     call assert_equal("Xfoobar.c|10| " . s:message_tbl[enc] . " (" . enc . ")",
+           \ getline('.'))
+     cclose
+   endfor
+ 
+   " :lgetfile
+   for enc in keys(s:message_tbl)
+     let &makeencoding = enc
+     exec "silent !" . s:python . " " . s:script . " " . enc . " > " . &errorfile
+     lgetfile
+     lopen
+     call assert_equal("Xfoobar.c|10| " . s:message_tbl[enc] . " (" . enc . ")",
+           \ getline('.'))
+     lclose
+   endfor
+ 
+   call delete(&errorfile)
+ endfunc
+ 
+ 
+ " Tests for :grep and :lgrep.
+ func Test_grep()
+   let &grepprg = s:python
+   set grepformat=%f(%l)\ :\ %m
+ 
+   " :grep
+   for enc in keys(s:message_tbl)
+     let &makeencoding = enc
+     exec "silent grep! " . s:script . " " . enc
+     copen
+     call assert_equal("Xfoobar.c|10| " . s:message_tbl[enc] . " (" . enc . ")",
+           \ getline('.'))
+     cclose
+   endfor
+ 
+   " :lgrep
+   for enc in keys(s:message_tbl)
+     let &makeencoding = enc
+     exec "silent lgrep! " . s:script . " " . enc
+     lopen
+     call assert_equal("Xfoobar.c|10| " . s:message_tbl[enc] . " (" . enc . ")",
+           \ getline('.'))
+     lclose
+   endfor
+ endfunc
+ 
+ 
+ " Tests for :make and :lmake.
+ func Test_make()
+   let &makeprg = s:python
+   set errorformat=%f(%l)\ :\ %m
+ 
+   " :make
+   for enc in keys(s:message_tbl)
+     let &makeencoding = enc
+     exec "silent make! " . s:script . " " . enc
+     copen
+     call assert_equal("Xfoobar.c|10| " . s:message_tbl[enc] . " (" . enc . ")",
+           \ getline('.'))
+     cclose
+   endfor
+ 
+   " :lmake
+   for enc in keys(s:message_tbl)
+     let &makeencoding = enc
+     exec "silent lmake! " . s:script . " " . enc
+     lopen
+     call assert_equal("Xfoobar.c|10| " . s:message_tbl[enc] . " (" . enc . ")",
+           \ getline('.'))
+     lclose
+   endfor
+ endfunc
*** ../vim-8.0.0419/src/version.c	2017-03-05 15:19:28.278417362 +0100
--- src/version.c	2017-03-05 17:31:57.817406853 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     420,
  /**/

-- 
Time is money.  Especially if you make clocks.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0421
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0421
Problem:    Diff mode is displayed wrong when adding a line at the end of a
            buffer.
Solution:   Adjust marks in diff mode. (James McCoy, closes #1329)
Files:      src/misc1.c, src/ops.c, src/testdir/test_diffmode.vim


*** ../vim-8.0.0420/src/misc1.c	2017-02-25 14:59:29.910090402 +0100
--- src/misc1.c	2017-03-05 18:01:34.499758386 +0100
***************
*** 1427,1434 ****
  	/* Postpone calling changed_lines(), because it would mess up folding
  	 * with markers.
  	 * Skip mark_adjust when adding a line after the last one, there can't
! 	 * be marks there. */
! 	if (curwin->w_cursor.lnum + 1 < curbuf->b_ml.ml_line_count)
  	    mark_adjust(curwin->w_cursor.lnum + 1, (linenr_T)MAXLNUM, 1L, 0L);
  	did_append = TRUE;
      }
--- 1427,1438 ----
  	/* Postpone calling changed_lines(), because it would mess up folding
  	 * with markers.
  	 * Skip mark_adjust when adding a line after the last one, there can't
! 	 * be marks there. But still needed in diff mode. */
! 	if (curwin->w_cursor.lnum + 1 < curbuf->b_ml.ml_line_count
! #ifdef FEAT_DIFF
! 		|| curwin->w_p_diff
! #endif
! 	    )
  	    mark_adjust(curwin->w_cursor.lnum + 1, (linenr_T)MAXLNUM, 1L, 0L);
  	did_append = TRUE;
      }
***************
*** 2863,2870 ****
  appended_lines_mark(linenr_T lnum, long count)
  {
      /* Skip mark_adjust when adding a line after the last one, there can't
!      * be marks there. */
!     if (lnum + count < curbuf->b_ml.ml_line_count)
  	mark_adjust(lnum + 1, (linenr_T)MAXLNUM, count, 0L);
      changed_lines(lnum + 1, 0, lnum + 1, count);
  }
--- 2867,2878 ----
  appended_lines_mark(linenr_T lnum, long count)
  {
      /* Skip mark_adjust when adding a line after the last one, there can't
!      * be marks there. But it's still needed in diff mode. */
!     if (lnum + count < curbuf->b_ml.ml_line_count
! #ifdef FEAT_DIFF
! 	    || curwin->w_p_diff
! #endif
! 	)
  	mark_adjust(lnum + 1, (linenr_T)MAXLNUM, count, 0L);
      changed_lines(lnum + 1, 0, lnum + 1, count);
  }
*** ../vim-8.0.0420/src/ops.c	2017-02-04 21:34:27.293529871 +0100
--- src/ops.c	2017-03-05 18:01:54.271606363 +0100
***************
*** 3927,3935 ****
  		    curbuf->b_op_start.lnum++;
  	    }
  	    /* Skip mark_adjust when adding lines after the last one, there
! 	     * can't be marks there. */
  	    if (curbuf->b_op_start.lnum + (y_type == MCHAR) - 1 + nr_lines
! 						 < curbuf->b_ml.ml_line_count)
  		mark_adjust(curbuf->b_op_start.lnum + (y_type == MCHAR),
  					     (linenr_T)MAXLNUM, nr_lines, 0L);
  
--- 3927,3939 ----
  		    curbuf->b_op_start.lnum++;
  	    }
  	    /* Skip mark_adjust when adding lines after the last one, there
! 	     * can't be marks there. But still needed in diff mode. */
  	    if (curbuf->b_op_start.lnum + (y_type == MCHAR) - 1 + nr_lines
! 						 < curbuf->b_ml.ml_line_count
! #ifdef FEAT_DIFF
! 						 || curwin->w_p_diff
! #endif
! 						 )
  		mark_adjust(curbuf->b_op_start.lnum + (y_type == MCHAR),
  					     (linenr_T)MAXLNUM, nr_lines, 0L);
  
***************
*** 6311,6317 ****
  
  /*
   * Routine to export any final X selection we had to the environment
!  * so that the text is still available after vim has exited. X selections
   * only exist while the owning application exists, so we write to the
   * permanent (while X runs) store CUT_BUFFER0.
   * Dump the CLIPBOARD selection if we own it (it's logically the more
--- 6315,6321 ----
  
  /*
   * Routine to export any final X selection we had to the environment
!  * so that the text is still available after Vim has exited. X selections
   * only exist while the owning application exists, so we write to the
   * permanent (while X runs) store CUT_BUFFER0.
   * Dump the CLIPBOARD selection if we own it (it's logically the more
*** ../vim-8.0.0420/src/testdir/test_diffmode.vim	2017-02-26 19:59:55.578563703 +0100
--- src/testdir/test_diffmode.vim	2017-03-05 17:57:11.533780674 +0100
***************
*** 347,349 ****
--- 347,369 ----
    call assert_fails('norm do', 'E21:')
    %bwipe!
  endfunc
+ 
+ func Test_diff_lastline()
+   enew!
+   only!
+   call setline(1, ['This is a ', 'line with five ', 'rows'])
+   diffthis
+   botright vert new
+   call setline(1, ['This is', 'a line with ', 'four rows'])
+   diffthis
+   1
+   call feedkeys("Je a\<CR>", 'tx')
+   call feedkeys("Je a\<CR>", 'tx')
+   let w1lines = winline()
+   wincmd w
+   $
+   let w2lines = winline()
+   call assert_equal(w2lines, w1lines)
+   bwipe!
+   bwipe!
+ endfunc
*** ../vim-8.0.0420/src/version.c	2017-03-05 17:43:10.624245543 +0100
--- src/version.c	2017-03-05 17:56:47.981961829 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     421,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
60. As your car crashes through the guardrail on a mountain road, your first
    instinct is to search for the "back" button.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0422
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0422
Problem:    Python test fails with Python 3.6.
Solution:   Convert new exception messages to old ones. (closes #1359)
Files:      src/testdir/test87.in


*** ../vim-8.0.0421/src/testdir/test87.in	2016-09-09 14:57:15.000000000 +0200
--- src/testdir/test87.in	2017-03-05 18:33:37.193000759 +0100
***************
*** 230,242 ****
                  cb.append(expr + ':' + repr((e.__class__, AttributeError(str(e)[str(e).rfind(" '") + 2:-1]))))
              elif sys.version_info >= (3, 3) and e.__class__ is ImportError and str(e).find('No module named \'') >= 0:
                  cb.append(expr + ':' + repr((e.__class__, ImportError(str(e).replace("'", '')))))
              elif sys.version_info >= (3, 3) and e.__class__ is TypeError:
                  m = py33_type_error_pattern.search(str(e))
                  if m:
                      msg = '__call__() takes exactly {0} positional argument ({1} given)'.format(m.group(1), m.group(2))
                      cb.append(expr + ':' + repr((e.__class__, TypeError(msg))))
                  else:
!                     cb.append(expr + ':' + repr((e.__class__, e)))
              elif sys.version_info >= (3, 5) and e.__class__ is ValueError and str(e) == 'embedded null byte':
                  cb.append(expr + ':' + repr((TypeError, TypeError('expected bytes with no null'))))
              else:
--- 230,255 ----
                  cb.append(expr + ':' + repr((e.__class__, AttributeError(str(e)[str(e).rfind(" '") + 2:-1]))))
              elif sys.version_info >= (3, 3) and e.__class__ is ImportError and str(e).find('No module named \'') >= 0:
                  cb.append(expr + ':' + repr((e.__class__, ImportError(str(e).replace("'", '')))))
+             elif sys.version_info >= (3, 6) and e.__class__ is ModuleNotFoundError:
+                 # Python 3.6 gives ModuleNotFoundError, change it to an ImportError
+                 cb.append(expr + ':' + repr((ImportError, ImportError(str(e).replace("'", '')))))
              elif sys.version_info >= (3, 3) and e.__class__ is TypeError:
                  m = py33_type_error_pattern.search(str(e))
                  if m:
                      msg = '__call__() takes exactly {0} positional argument ({1} given)'.format(m.group(1), m.group(2))
                      cb.append(expr + ':' + repr((e.__class__, TypeError(msg))))
                  else:
!                     msg = repr((e.__class__, e))
!                     # Messages changed with Python 3.6, change new to old.
!                     newmsg1 = """'argument must be str, bytes or bytearray, not None'"""
!                     oldmsg1 = '''"Can't convert 'NoneType' object to str implicitly"'''
!                     if msg.find(newmsg1) > -1:
!                         msg = msg.replace(newmsg1, oldmsg1)
!                     newmsg2 = """'argument must be str, bytes or bytearray, not int'"""
!                     oldmsg2 = '''"Can't convert 'int' object to str implicitly"'''
!                     if msg.find(newmsg2) > -1:
!                         msg = msg.replace(newmsg2, oldmsg2)
!                     cb.append(expr + ':' + msg)
              elif sys.version_info >= (3, 5) and e.__class__ is ValueError and str(e) == 'embedded null byte':
                  cb.append(expr + ':' + repr((TypeError, TypeError('expected bytes with no null'))))
              else:
*** ../vim-8.0.0421/src/version.c	2017-03-05 18:02:59.999101021 +0100
--- src/version.c	2017-03-05 18:58:44.309529086 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     422,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
61. Your best friends know your e-mail address, but neither your phone number
    nor the address where you live.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0423
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0423
Problem:    The effect of adding "#" to 'cinoptions' is not always removed.
            (David Briscoe)
Solution:   Reset b_ind_hash_comment. (Christian Brabandt, closes #1475)
Files:      src/misc1.c, src/Makefile, src/testdir/Make_all.mak,
            src/testdir/test_cindent.vim, src/testdir/test3.in


*** ../vim-8.0.0422/src/misc1.c	2017-03-05 18:02:59.999101021 +0100
--- src/misc1.c	2017-03-05 19:27:22.488545085 +0100
***************
*** 6974,6979 ****
--- 6974,6982 ----
       * while(). */
      buf->b_ind_if_for_while = 0;
  
+     /* indentation for # comments */
+     buf->b_ind_hash_comment = 0;
+ 
      for (p = buf->b_p_cino; *p; )
      {
  	l = p++;
*** ../vim-8.0.0422/src/Makefile	2017-03-05 17:43:10.616245604 +0100
--- src/Makefile	2017-03-05 19:26:32.516922193 +0100
***************
*** 2104,2109 ****
--- 2104,2110 ----
  	test_channel \
  	test_charsearch \
  	test_changedtick \
+ 	test_cindent \
  	test_cmdline \
  	test_command_count \
  	test_crypt \
*** ../vim-8.0.0422/src/testdir/Make_all.mak	2017-03-05 17:43:10.624245543 +0100
--- src/testdir/Make_all.mak	2017-03-05 19:26:53.360764901 +0100
***************
*** 143,148 ****
--- 143,149 ----
  	    test_cdo.res \
  	    test_channel.res \
  	    test_charsearch.res \
+ 	    test_cindent.res \
  	    test_cmdline.res \
  	    test_command_count.res \
  	    test_crypt.res \
*** ../vim-8.0.0422/src/testdir/test_cindent.vim	2017-03-05 19:43:06.225417095 +0100
--- src/testdir/test_cindent.vim	2017-03-05 19:26:14.357059228 +0100
***************
*** 0 ****
--- 1,16 ----
+ " Test for cinoptions and cindent
+ "
+ " TODO: rewrite test3.in into this new style test
+ 
+ func Test_cino_hash()
+   " Test that curbuf->b_ind_hash_comment is correctly reset
+   new
+   setlocal cindent cinoptions=#1
+   setlocal cinoptions=
+   call setline(1, ["#include <iostream>"])
+   call cursor(1, 1)
+   norm! o#include
+   "call feedkeys("o#include\<esc>", 't')
+   call assert_equal(["#include <iostream>", "#include"], getline(1,2))
+   bwipe!
+ endfunc
*** ../vim-8.0.0422/src/testdir/test3.in	2017-01-07 15:39:36.397759526 +0100
--- src/testdir/test3.in	2017-03-05 19:41:45.302028954 +0100
***************
*** 1,6 ****
  /* vim: set cin ts=4 sw=4 : */
  
! Test for 'cindent'
  
  STARTTEST
  :so small.vim
--- 1,7 ----
  /* vim: set cin ts=4 sw=4 : */
  
! Test for 'cindent'.
! For new tests, consider putting them in test_cindent.vim.
  
  STARTTEST
  :so small.vim
*** ../vim-8.0.0422/src/version.c	2017-03-05 19:00:29.888725017 +0100
--- src/version.c	2017-03-05 19:42:33.585663888 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     423,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
62. If your doorbell rings, you think that new mail has arrived.  And then
    you're disappointed that it's only someone at the door.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0424
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0424
Problem:    Compiler warnings on MS-Windows. (Ajit Thakkar)
Solution:   Add type casts.
Files:      src/os_win32.c


*** ../vim-8.0.0423/src/os_win32.c	2017-03-05 15:19:28.278417362 +0100
--- src/os_win32.c	2017-03-05 19:47:34.363389445 +0100
***************
*** 1918,1928 ****
  
      if (!use_path)
      {
! 	if (mch_getperm(name) != -1 && !mch_isdir(name))
  	{
  	    if (path != NULL)
  	    {
! 		if (mch_isFullName(name))
  		    *path = vim_strsave((char_u *)name);
  		else
  		    *path = FullName_save((char_u *)name, FALSE);
--- 1918,1928 ----
  
      if (!use_path)
      {
! 	if (mch_getperm((char_u *)name) != -1 && !mch_isdir((char_u *)name))
  	{
  	    if (path != NULL)
  	    {
! 		if (mch_isFullName((char_u *)name))
  		    *path = vim_strsave((char_u *)name);
  		else
  		    *path = FullName_save((char_u *)name, FALSE);
*** ../vim-8.0.0423/src/version.c	2017-03-05 19:43:44.549127317 +0100
--- src/version.c	2017-03-05 19:48:43.598865824 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     424,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
64. The remote to the T.V. is missing...and you don't even care.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0425
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0425
Problem:    Build errors when building without folding.
Solution:   Add #ifdefs. (John Marriott)
Files:      src/diff.c, src/edit.c, src/option.c, src/syntax.c


*** ../vim-8.0.0424/src/diff.c	2017-02-03 23:16:24.349040487 +0100
--- src/diff.c	2017-03-05 21:12:47.820078988 +0100
***************
*** 2616,2622 ****
      return lnum;
  }
  
- #if defined(FEAT_FOLDING) || defined(PROTO)
  /*
   * For line "lnum" in the current window find the equivalent lnum in window
   * "wp", compensating for inserted/deleted lines.
--- 2616,2621 ----
***************
*** 2656,2661 ****
  	n = dp->df_lnum[i] + dp->df_count[i];
      return n;
  }
- #endif
  
  #endif	/* FEAT_DIFF */
--- 2655,2659 ----
*** ../vim-8.0.0424/src/edit.c	2017-03-01 12:29:03.578834362 +0100
--- src/edit.c	2017-03-05 21:14:50.939110028 +0100
***************
*** 541,548 ****
  
      /*
       * Handle restarting Insert mode.
!      * Don't do this for "CTRL-O ." (repeat an insert): we get here with
!      * restart_edit non-zero, and something in the stuff buffer.
       */
      if (restart_edit != 0 && stuff_empty())
      {
--- 541,548 ----
  
      /*
       * Handle restarting Insert mode.
!      * Don't do this for "CTRL-O ." (repeat an insert): In that case we get
!      * here with something in the stuff buffer.
       */
      if (restart_edit != 0 && stuff_empty())
      {
***************
*** 1453,1462 ****
--- 1453,1466 ----
  
  docomplete:
  	    compl_busy = TRUE;
+ #ifdef FEAT_FOLDING
  	    disable_fold_update++;  /* don't redraw folds here */
+ #endif
  	    if (ins_complete(c, TRUE) == FAIL)
  		compl_cont_status = 0;
+ #ifdef FEAT_FOLDING
  	    disable_fold_update--;
+ #endif
  	    compl_busy = FALSE;
  	    break;
  #endif /* FEAT_INS_EXPAND */
*** ../vim-8.0.0424/src/option.c	2017-03-05 17:43:10.620245573 +0100
--- src/option.c	2017-03-05 21:15:35.430760118 +0100
***************
*** 4535,4542 ****
  		 * "wrap" gets set. */
  		if (curwin->w_p_diff
  			&& opt_idx >= 0  /* shut up coverity warning */
! 			&& (options[opt_idx].indir == PV_FDM
! 			    || options[opt_idx].indir == PV_WRAP))
  		    goto skip;
  #endif
  	    }
--- 4535,4545 ----
  		 * "wrap" gets set. */
  		if (curwin->w_p_diff
  			&& opt_idx >= 0  /* shut up coverity warning */
! 			&& (
! #ifdef FEAT_FOLDING
! 			    options[opt_idx].indir == PV_FDM ||
! #endif
! 			    options[opt_idx].indir == PV_WRAP))
  		    goto skip;
  #endif
  	    }
*** ../vim-8.0.0424/src/syntax.c	2017-02-25 14:59:29.910090402 +0100
--- src/syntax.c	2017-03-05 21:16:37.590271467 +0100
***************
*** 1183,1193 ****
      void
  syn_stack_free_all(synblock_T *block)
  {
      win_T	*wp;
  
      syn_stack_free_block(block);
  
- 
  #ifdef FEAT_FOLDING
      /* When using "syntax" fold method, must update all folds. */
      FOR_ALL_WINDOWS(wp)
--- 1183,1194 ----
      void
  syn_stack_free_all(synblock_T *block)
  {
+ #ifdef FEAT_FOLDING
      win_T	*wp;
+ #endif
  
      syn_stack_free_block(block);
  
  #ifdef FEAT_FOLDING
      /* When using "syntax" fold method, must update all folds. */
      FOR_ALL_WINDOWS(wp)
*** ../vim-8.0.0424/src/version.c	2017-03-05 19:49:09.402670667 +0100
--- src/version.c	2017-03-05 21:12:40.112139684 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     425,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
68. Your cat always puts viruses on your dogs homepage

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0426
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0426
Problem:    Insufficient testing for statusline.
Solution:   Add several tests. (Dominique Pelle, closes #1534)
Files:      src/testdir/test_statusline.vim


*** ../vim-8.0.0425/src/testdir/test_statusline.vim	2016-04-04 23:03:08.000000000 +0200
--- src/testdir/test_statusline.vim	2017-03-06 20:27:03.627268819 +0100
***************
*** 1,19 ****
! function! StatuslineWithCaughtError()
    let s:func_in_statusline_called = 1
    try
      call eval('unknown expression')
    catch
    endtry
    return ''
! endfunction
  
! function! StatuslineWithError()
    let s:func_in_statusline_called = 1
    call eval('unknown expression')
    return ''
! endfunction
  
! function! Test_caught_error_in_statusline()
    let s:func_in_statusline_called = 0
    set laststatus=2
    let statusline = '%{StatuslineWithCaughtError()}'
--- 1,39 ----
! " Test 'statusline'
! "
! " Not tested yet:
! "   %a
! "   %N
! "   %T
! "   %X
! "   %*
! 
! source view_util.vim
! 
! func s:get_statusline()
!   return ScreenLines(&lines - 1, &columns)[0]
! endfunc
! 
! func StatuslineWithCaughtError()
    let s:func_in_statusline_called = 1
    try
      call eval('unknown expression')
    catch
    endtry
    return ''
! endfunc
  
! func StatuslineWithError()
    let s:func_in_statusline_called = 1
    call eval('unknown expression')
    return ''
! endfunc
  
! " Function used to display syntax group.
! func SyntaxItem()
!   return synIDattr(synID(line("."),col("."),1),"name")
! endfunc
! 
! func Test_caught_error_in_statusline()
    let s:func_in_statusline_called = 0
    set laststatus=2
    let statusline = '%{StatuslineWithCaughtError()}'
***************
*** 22,30 ****
    call assert_true(s:func_in_statusline_called)
    call assert_equal(statusline, &statusline)
    set statusline=
! endfunction
  
! function! Test_statusline_will_be_disabled_with_error()
    let s:func_in_statusline_called = 0
    set laststatus=2
    let statusline = '%{StatuslineWithError()}'
--- 42,50 ----
    call assert_true(s:func_in_statusline_called)
    call assert_equal(statusline, &statusline)
    set statusline=
! endfunc
  
! func Test_statusline_will_be_disabled_with_error()
    let s:func_in_statusline_called = 0
    set laststatus=2
    let statusline = '%{StatuslineWithError()}'
***************
*** 36,39 ****
    call assert_true(s:func_in_statusline_called)
    call assert_equal('', &statusline)
    set statusline=
! endfunction
--- 56,274 ----
    call assert_true(s:func_in_statusline_called)
    call assert_equal('', &statusline)
    set statusline=
! endfunc
! 
! func Test_statusline()
!   new Xstatusline
!   only
!   set laststatus=2
!   set splitbelow
!   call setline(1, range(1, 200))
! 
!   " %b: Value of character under cursor.
!   " %B: As above, in hexadecimal.
!   call cursor(180, 2)
!   set statusline=%b,%B
!   call assert_match('^56,38\s*$', s:get_statusline())
! 
!   " %o: Byte number in file of byte under cursor, first byte is 1.
!   " %O: As above, in hexadecimal.
!   set statusline=%o,%O
!   set fileformat=dos
!   call assert_match('^789,315\s*$', s:get_statusline())
!   set fileformat=mac
!   call assert_match('^610,262\s*$', s:get_statusline())
!   set fileformat=unix
!   call assert_match('^610,262\s*$', s:get_statusline())
!   set fileformat&
! 
!   " %f: Path to the file in the buffer, as typed or relative to current dir.
!   set statusline=%f
!   call assert_match('^Xstatusline\s*$', s:get_statusline())
! 
!   " %F: Full path to the file in the buffer.
!   set statusline=%F
!   call assert_match('/testdir/Xstatusline\s*$', s:get_statusline())
! 
!   " %h: Help buffer flag, text is "[help]".
!   " %H: Help buffer flag, text is ",HLP".
!   set statusline=%h,%H
!   call assert_match('^,\s*$', s:get_statusline())
!   help
!   call assert_match('^\[Help\],HLP\s*$', s:get_statusline())
!   helpclose
! 
!   " %k: Value of "b:keymap_name" or 'keymap'
!   "     when :lmap mappings are being used: <keymap>"
!   set statusline=%k
!   if has('keymap')
!     set keymap=esperanto
!     call assert_match('^<Eo>\s*$', s:get_statusline())
!     set keymap&
!   else
!     call assert_match('^\s*$', s:get_statusline())
!   endif
! 
!   " %l: Line number.
!   " %L: Number of line in buffer.
!   " %c: Column number.
!   set statusline=%l/%L,%c
!   call assert_match('^180/200,2\s*$', s:get_statusline())
! 
!   " %m: Modified flag, text is "[+]", "[-]" if 'modifiable' is off.
!   " %M: Modified flag, text is ",+" or ",-".
!   set statusline=%m%M
!   call assert_match('^\[+\],+\s*$', s:get_statusline())
!   set nomodifiable
!   call assert_match('^\[+-\],+-\s*$', s:get_statusline())
!   write
!   call assert_match('^\[-\],-\s*$', s:get_statusline())
!   set modifiable&
!   call assert_match('^\s*$', s:get_statusline())
! 
!   " %n: Buffer number.
!   set statusline=%n
!   call assert_match('^'.bufnr('%').'\s*$', s:get_statusline())
! 
!   " %p: Percentage through file in lines as in CTRL-G.
!   " %P: Percentage through file of displayed window.
!   set statusline=%p,%P
!   0
!   call assert_match('^0,Top\s*$', s:get_statusline())
!   norm G
!   call assert_match('^100,Bot\s*$', s:get_statusline())
!   180
!   " Don't check the exact percentage as it depends on the window size
!   call assert_match('^90,\(Top\|Bot\|\d\+%\)\s*$', s:get_statusline())
! 
!   " %q: "[Quickfix List]", "[Location List]" or empty.
!   set statusline=%q
!   call assert_match('^\s*$', s:get_statusline())
!   copen
!   call assert_match('^\[Quickfix List\]\s*$', s:get_statusline())
!   cclose
!   lexpr getline(1, 2)
!   lopen
!   call assert_match('^\[Location List\]\s*$', s:get_statusline())
!   lclose
! 
!   " %r: Readonly flag, text is "[RO]".
!   " %R: Readonly flag, text is ",RO".
!   set statusline=%r,%R
!   call assert_match('^,\s*$', s:get_statusline())
!   help
!   call assert_match('^\[RO\],RO\s*$', s:get_statusline())
!   helpclose
! 
!   " %t: File name (tail) of file in the buffer.
!   set statusline=%t
!   call assert_match('^Xstatusline\s*$', s:get_statusline())
! 
!   " %v: Virtual column number.
!   " %V: Virtual column number as -{num}. Not displayed if equal to 'c'.
!   call cursor(180, 2)
!   set statusline=%v,%V
!   call assert_match('^2,\s*$', s:get_statusline())
!   set virtualedit=all
!   norm 10|
!   call assert_match('^10,-10\s*$', s:get_statusline())
!   set virtualedit&
! 
!   " %w: Preview window flag, text is "[Preview]".
!   " %W: Preview window flag, text is ",PRV".
!   set statusline=%w%W
!   call assert_match('^\s*$', s:get_statusline())
!   pedit
!   wincmd j
!   call assert_match('^\[Preview\],PRV\s*$', s:get_statusline())
!   pclose
! 
!   " %y: Type of file in the buffer, e.g., "[vim]". See 'filetype'.
!   " %Y: Type of file in the buffer, e.g., ",VIM". See 'filetype'.
!   set statusline=%y\ %Y
!   call assert_match('^\s*$', s:get_statusline())
!   setfiletype vim
!   call assert_match('^\[vim\] VIM\s*$', s:get_statusline())
! 
!   " %=: Separation point between left and right aligned items.
!   set statusline=foo%=bar
!   call assert_match('^foo\s\+bar\s*$', s:get_statusline())
! 
!   " Test min/max width, leading zeroes, left/right justify.
!   set statusline=%04B
!   call cursor(180, 2)
!   call assert_match('^0038\s*$', s:get_statusline())
!   set statusline=#%4B#
!   call assert_match('^#  38#\s*$', s:get_statusline())
!   set statusline=#%-4B#
!   call assert_match('^#38  #\s*$', s:get_statusline())
!   set statusline=%.6f
!   call assert_match('^<sline\s*$', s:get_statusline())
! 
!   " %<: Where to truncate.
!   exe 'set statusline=a%<b' . repeat('c', 1000) . 'd'
!   call assert_match('^a<c*d$', s:get_statusline())
!   exe 'set statusline=a' . repeat('b', 1000) . '%<c'
!   call assert_match('^ab*>$', s:get_statusline())
! 
!   "%{: Evaluate expression between '%{' and '}' and substitute result.
!   syntax on
!   set statusline=%{SyntaxItem()}
!   call assert_match('^vimNumber\s*$', s:get_statusline())
!   s/^/"/
!   call assert_match('^vimLineComment\s*$', s:get_statusline())
!   syntax off
! 
!   "%(: Start of item group.
!   set statusline=ab%(cd%q%)de
!   call assert_match('^abde\s*$', s:get_statusline())
!   copen
!   call assert_match('^abcd\[Quickfix List\1]de\s*$', s:get_statusline())
!   cclose
! 
!   " %#: Set highlight group. The name must follow and then a # again.
!   set statusline=ab%#Todo#cd%#Error#ef
!   call assert_match('^abcdef\s*$', s:get_statusline())
!   let sa1=screenattr(&lines - 1, 1)
!   let sa2=screenattr(&lines - 1, 3)
!   let sa3=screenattr(&lines - 1, 5)
!   call assert_notequal(sa1, sa2)
!   call assert_notequal(sa1, sa3)
!   call assert_notequal(sa2, sa3)
!   call assert_equal(sa1, screenattr(&lines - 1, 2))
!   call assert_equal(sa2, screenattr(&lines - 1, 4))
!   call assert_equal(sa3, screenattr(&lines - 1, 6))
!   call assert_equal(sa3, screenattr(&lines - 1, 7))
! 
!   " %*: Set highlight group to User{N}
!   set statusline=a%1*b%0*c
!   call assert_match('^abc\s*$', s:get_statusline())
!   let sa1=screenattr(&lines - 1, 1)
!   let sa2=screenattr(&lines - 1, 2)
!   let sa3=screenattr(&lines - 1, 3)
!   call assert_equal(sa1, sa3)
!   call assert_notequal(sa1, sa2)
! 
!   " %%: a percent sign.
!   set statusline=10%%
!   call assert_match('^10%\s*$', s:get_statusline())
! 
!   " %!: evaluated expression is used as the option value
!   set statusline=%!2*3+1
!   call assert_match('7\s*$', s:get_statusline())
! 
!   " Check statusline in current and non-current window
!   " with the 'fillchars' option.
!   set fillchars=stl:^,stlnc:=,vert:\|,fold:-,diff:-
!   vsplit
!   set statusline=x%=y
!   call assert_match('^x^\+y^x=\+y$', s:get_statusline())
!   set fillchars&
!   close
! 
!   %bw!
!   call delete('Xstatusline')
!   set statusline&
!   set laststatus&
!   set splitbelow&
! endfunc
*** ../vim-8.0.0425/src/version.c	2017-03-05 21:18:21.885452125 +0100
--- src/version.c	2017-03-06 20:22:17.893428870 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     426,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
70. ISDN lines are added to your house on a hourly basis

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0427
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0427
Problem:    'makeencoding' missing from the options window.
Solution:   Add the entry.
Files:      runtime/optwin.vim


*** ../vim-8.0.0426/runtime/optwin.vim	2017-01-28 15:58:45.340197300 +0100
--- runtime/optwin.vim	2017-03-06 21:42:43.124400455 +0100
***************
*** 1,7 ****
  " These commands create the option window.
  "
  " Maintainer:	Bram Moolenaar <Bram@vim.org>
! " Last Change:	2016 Aug 21
  
  " If there already is an option window, jump to that one.
  if bufwinnr("option-window") > 0
--- 1,7 ----
  " These commands create the option window.
  "
  " Maintainer:	Bram Moolenaar <Bram@vim.org>
! " Last Change:	2017 Mar 06
  
  " If there already is an option window, jump to that one.
  if bufwinnr("option-window") > 0
***************
*** 1131,1136 ****
--- 1131,1139 ----
    call <SID>OptionG("gp", &gp)
    call append("$", "grepformat\tlist of formats for output of 'grepprg'")
    call <SID>OptionG("gfm", &gfm)
+   call append("$", "makeencoding\tencoding of the \":make\" and \":grep\" output")
+   call append("$", "\t(global or local to buffer)")
+   call <SID>OptionG("menc", &menc)
  endif
  
  
*** ../vim-8.0.0426/src/version.c	2017-03-06 20:28:05.978797725 +0100
--- src/version.c	2017-03-06 21:44:05.095764263 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     427,
  /**/

-- 
Proof techniques #2: Proof by Oddity.
	SAMPLE: To prove that horses have an infinite number of legs.
(1) Horses have an even number of legs.
(2) They have two legs in back and fore legs in front.
(3) This makes a total of six legs, which certainly is an odd number of
    legs for a horse.
(4) But the only number that is both odd and even is infinity.
(5) Therefore, horses must have an infinite number of legs.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0428
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0428
Problem:    Git and hg see new files after running tests. (Manuel Ortega)
Solution:   Add the generated file to .hgignore (or .gitignore). Delete the
            resulting verbose file. (Christian Brabandt)  Improve dependency
            on opt_test.vim.  Reset the 'more' option.
Files:      .hgignore, src/gen_opt_test.vim, src/testdir/gen_opt_test.vim,
            src/Makefile, src/testdir/Make_all.mak, src/testdir/Makefile,
            src/testdir/Make_dos.mak, src/testdir/Make_ming.mak,
            Filelist


*** ../vim-8.0.0427/.hgignore	2016-01-19 15:32:47.000000000 +0100
--- .hgignore	2017-03-07 20:56:57.861986058 +0100
***************
*** 79,82 ****
--- 79,83 ----
  src/testdir/dostmp/*
  src/testdir/messages
  src/testdir/viminfo
+ src/testdir/opt_test.vim
  src/memfile_test
*** ../vim-8.0.0427/src/gen_opt_test.vim	2017-02-27 22:59:35.524466813 +0100
--- src/gen_opt_test.vim	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,196 ****
- " Script to generate testdir/opt_test.vim from option.c
- 
- set cpo=&vim
- 
- " Only do this when build with the +eval feature.
- if 1
- 
- set nomore
- 
- let script = [
-       \ 'let save_columns = &columns',
-       \ 'let save_lines = &lines',
-       \ 'let save_term = &term',
-       \ ]
- 
- edit option.c
- /#define p_term
- let end = line('.')
- 
- " Two lists with values: values that work and values that fail.
- " When not listed, "othernum" or "otherstring" is used.
- let test_values = {
-       \ 'cmdheight': [[1, 2, 10], [-1, 0]],
-       \ 'cmdwinheight': [[1, 2, 10], [-1, 0]],
-       \ 'columns': [[12, 80], [-1, 0, 10]],
-       \ 'conceallevel': [[0, 1, 2, 3], [-1, 4, 99]],
-       \ 'foldcolumn': [[0, 1, 4, 12], [-1, 13, 999]],
-       \ 'helpheight': [[0, 10, 100], [-1]],
-       \ 'history': [[0, 1, 100], [-1, 10001]],
-       \ 'iminsert': [[0, 1], [-1, 3, 999]],
-       \ 'imsearch': [[-1, 0, 1], [-2, 3, 999]],
-       \ 'lines': [[2, 24], [-1, 0, 1]],
-       \ 'numberwidth': [[1, 4, 8, 10], [-1, 0, 11]],
-       \ 'regexpengine': [[0, 1, 2], [-1, 3, 999]],
-       \ 'report': [[0, 1, 2, 9999], [-1]],
-       \ 'scroll': [[0, 1, 2, 20], [-1]],
-       \ 'scrolljump': [[-50, -1, 0, 1, 2, 20], [999]],
-       \ 'scrolloff': [[0, 1, 2, 20], [-1]],
-       \ 'shiftwidth': [[0, 1, 8, 999], [-1]],
-       \ 'sidescroll': [[0, 1, 8, 999], [-1]],
-       \ 'sidescrolloff': [[0, 1, 8, 999], [-1]],
-       \ 'tabstop': [[1, 4, 8, 12], [-1, 0]],
-       \ 'textwidth': [[0, 1, 8, 99], [-1]],
-       \ 'timeoutlen': [[0, 8, 99999], [-1]],
-       \ 'titlelen': [[0, 1, 8, 9999], [-1]],
-       \ 'updatecount': [[0, 1, 8, 9999], [-1]],
-       \ 'updatetime': [[0, 1, 8, 9999], [-1]],
-       \ 'verbose': [[-1, 0, 1, 8, 9999], []],
-       \ 'wildcharm': [[-1, 0, 100], []],
-       \ 'winheight': [[1, 10, 999], [-1, 0]],
-       \ 'winminheight': [[0, 1], [-1]],
-       \ 'winminwidth': [[0, 1, 10], [-1]],
-       \ 'winwidth': [[1, 10, 999], [-1, 0]],
-       \
-       \ 'ambiwidth': [['', 'single'], ['xxx']],
-       \ 'background': [['', 'light', 'dark'], ['xxx']],
-       \ 'backspace': [[0, 2, '', 'eol', 'eol,start'], ['xxx']],
-       \ 'backupcopy': [['yes', 'auto'], ['', 'xxx', 'yes,no']],
-       \ 'backupext': [['xxx'], ['']],
-       \ 'belloff': [['', 'all', 'copy,error'], ['xxx']],
-       \ 'breakindentopt': [['', 'min:3', 'sbr'], ['xxx', 'min', 'min:x']],
-       \ 'browsedir': [['', 'last', '/tmp/'], ['xxx']],
-       \ 'bufhidden': [['', 'hide', 'wipe'], ['xxx', 'hide,wipe']],
-       \ 'buftype': [['', 'help', 'nofile'], ['xxx', 'help,nofile']],
-       \ 'casemap': [['', 'internal'], ['xxx']],
-       \ 'cedit': [['', '\<Esc>'], ['xxx', 'f']],
-       \ 'clipboard': [['', 'unnamed', 'autoselect,unnamed'], ['xxx']],
-       \ 'colorcolumn': [['', '8', '+2'], ['xxx']],
-       \ 'comments': [['', 'b:#'], ['xxx']],
-       \ 'commentstring': [['', '/*%s*/'], ['xxx']],
-       \ 'complete': [['', 'w,b'], ['xxx']],
-       \ 'concealcursor': [['', 'n', 'nvic'], ['xxx']],
-       \ 'completeopt': [['', 'menu', 'menu,longest'], ['xxx', 'menu,,,longest,']],
-       \ 'cryptmethod': [['', 'zip'], ['xxx']],
-       \ 'cscopequickfix': [['', 's-', 's-,c+,e0'], ['xxx', 's,g,d']],
-       \ 'debug': [['', 'msg', 'msg', 'beep'], ['xxx']],
-       \ 'diffopt': [['', 'filler', 'icase,iwhite'], ['xxx']],
-       \ 'display': [['', 'lastline', 'lastline,uhex'], ['xxx']],
-       \ 'eadirection': [['', 'both', 'ver'], ['xxx', 'ver,hor']],
-       \ 'encoding': [['latin1'], ['xxx', '']],
-       \ 'eventignore': [['', 'WinEnter', 'WinLeave,winenter'], ['xxx']],
-       \ 'fileencoding': [['', 'latin1', 'xxx'], []],
-       \ 'fileformat': [['', 'dos', 'unix'], ['xxx']],
-       \ 'fileformats': [['', 'dos', 'dos,unix'], ['xxx']],
-       \ 'fillchars': [['', 'vert:x'], ['xxx']],
-       \ 'foldclose': [['', 'all'], ['xxx']],
-       \ 'foldmethod': [['manual', 'indent'], ['', 'xxx', 'expr,diff']],
-       \ 'foldopen': [['', 'all', 'hor,jump'], ['xxx']],
-       \ 'foldmarker': [['((,))'], ['', 'xxx']],
-       \ 'formatoptions': [['', 'vt', 'v,t'], ['xxx']],
-       \ 'guicursor': [['', 'n:block-Cursor'], ['xxx']],
-       \ 'helplang': [['', 'de', 'de,it'], ['xxx']],
-       \ 'highlight': [['', 'e:Error'], ['xxx']],
-       \ 'isfname': [['', '@', '@,48-52'], ['xxx', '@48']],
-       \ 'isident': [['', '@', '@,48-52'], ['xxx', '@48']],
-       \ 'iskeyword': [['', '@', '@,48-52'], ['xxx', '@48']],
-       \ 'isprint': [['', '@', '@,48-52'], ['xxx', '@48']],
-       \ 'keymap': [['', 'accents'], ['xxx']],
-       \ 'keymodel': [['', 'startsel', 'startsel,stopsel'], ['xxx']],
-       \ 'langmap': [['', 'xX', 'aA,bB'], ['xxx']],
-       \ 'listchars': [['', 'eol:x', 'eol:x,space:y'], ['xxx']],
-       \ 'matchpairs': [['', '(:)', '(:),<:>'], ['xxx']],
-       \ 'mkspellmem': [['10000,100,12'], ['', 'xxx']],
-       \ 'mouse': [['', 'a', 'nvi'], ['xxx', 'n,v,i']],
-       \ 'mousemodel': [['', 'popup'], ['xxx']],
-       \ 'mouseshape': [['', 'n:arrow'], ['xxx']],
-       \ 'nrformats': [['', 'alpha', 'alpha,hex,bin'], ['xxx']],
-       \ 'printmbfont': [['', 'r:some', 'b:Bold,c:yes'], ['xxx']],
-       \ 'printoptions': [['', 'header:0', 'left:10pc,top:5pc'], ['xxx']],
-       \ 'scrollopt': [['', 'ver', 'ver,hor'], ['xxx']],
-       \ 'selection': [['old', 'inclusive'], ['', 'xxx']],
-       \ 'selectmode': [['', 'mouse', 'key,cmd'], ['xxx']],
-       \ 'sessionoptions': [['', 'blank', 'help,options,slash'], ['xxx']],
-       \ 'signcolumn': [['', 'auto', 'no'], ['xxx', 'no,yes']],
-       \ 'spellfile': [['', 'file.en.add'], ['xxx', '/tmp/file']],
-       \ 'spellsuggest': [['', 'best', 'double,33'], ['xxx']],
-       \ 'switchbuf': [['', 'useopen', 'split,newtab'], ['xxx']],
-       \ 'tagcase': [['smart', 'match'], ['', 'xxx', 'smart,match']],
-       \ 'term': [['ansi'], ['', 'gui']],
-       \ 'toolbar': [['', 'icons', 'text'], ['xxx']],
-       \ 'toolbariconsize': [['', 'tiny', 'huge'], ['xxx']],
-       \ 'ttymouse': [['', 'xterm'], ['xxx']],
-       \ 'ttytype': [['ansi'], ['', 'gui']],
-       \ 'viewoptions': [['', 'cursor', 'unix,slash'], ['xxx']],
-       \ 'viminfo': [['', '''50', '"30'], ['xxx']],
-       \ 'virtualedit': [['', 'all', 'all,block'], ['xxx']],
-       \ 'whichwrap': [['', 'b,s', 'bs'], ['xxx']],
-       \ 'wildmode': [['', 'full', 'list:full', 'full,longest'], ['xxx']],
-       \ 'wildoptions': [['', 'tagfile'], ['xxx']],
-       \ 'winaltkeys': [['menu', 'no'], ['', 'xxx']],
-       \
-       \ 'luadll': [[], []],
-       \ 'perldll': [[], []],
-       \ 'pythondll': [[], []],
-       \ 'pythonthreedll': [[], []],
-       \ 'pyxversion': [[], []],
-       \ 'rubydll': [[], []],
-       \ 'tcldll': [[], []],
-       \
-       \ 'othernum': [[-1, 0, 100], ['']],
-       \ 'otherstring': [['', 'xxx'], []],
-       \}
- 
- 1
- /struct vimoption options
- while 1
-   /{"
-   if line('.') > end
-     break
-   endif
-   let line = getline('.')
-   let name = substitute(line, '.*{"\([^"]*\)".*', '\1', '')
-   let shortname = substitute(line, '.*"\([^"]*\)".*', '\1', '')
- 
-   if has_key(test_values, name)
-     let a = test_values[name]
-   elseif line =~ 'P_NUM'
-     let a = test_values['othernum']
-   else
-     let a = test_values['otherstring']
-   endif
-   if len(a[0]) > 0 || len(a[1]) > 0
-     if line =~ 'P_BOOL'
-       call add(script, 'set ' . name)
-       call add(script, 'set ' . shortname)
-       call add(script, 'set no' . name)
-       call add(script, 'set no' . shortname)
-     else
-       for val in a[0]
- 	call add(script, 'set ' . name . '=' . val)
- 	call add(script, 'set ' . shortname . '=' . val)
-       endfor
- 
-       " setting an option can only fail when it's implemented.
-       call add(script, "if exists('+" . name . "')")
-       for val in a[1]
- 	call add(script, "call assert_fails('set " . name . "=" . val . "')")
- 	call add(script, "call assert_fails('set " . shortname . "=" . val . "')")
-       endfor
-       call add(script, "endif")
-     endif
- 
-     call add(script, 'set ' . name . '&')
-     call add(script, 'set ' . shortname . '&')
-   endif
- endwhile
- 
- call add(script, 'let &term = save_term')
- call add(script, 'let &columns = save_columns')
- call add(script, 'let &lines = save_lines')
- 
- call writefile(script, 'testdir/opt_test.vim')
- 
- endif
- 
- qa!
--- 0 ----
*** ../vim-8.0.0427/src/testdir/gen_opt_test.vim	2017-03-07 21:26:10.252206659 +0100
--- src/testdir/gen_opt_test.vim	2017-03-07 21:09:04.380247479 +0100
***************
*** 0 ****
--- 1,204 ----
+ " Script to generate testdir/opt_test.vim from option.c
+ 
+ set cpo=&vim
+ 
+ " Only do this when build with the +eval feature.
+ if 1
+ 
+ set nomore
+ 
+ let script = [
+       \ 'let save_columns = &columns',
+       \ 'let save_lines = &lines',
+       \ 'let save_term = &term',
+       \ ]
+ 
+ edit option.c
+ /#define p_term
+ let end = line('.')
+ 
+ " Two lists with values: values that work and values that fail.
+ " When not listed, "othernum" or "otherstring" is used.
+ let test_values = {
+       \ 'cmdheight': [[1, 2, 10], [-1, 0]],
+       \ 'cmdwinheight': [[1, 2, 10], [-1, 0]],
+       \ 'columns': [[12, 80], [-1, 0, 10]],
+       \ 'conceallevel': [[0, 1, 2, 3], [-1, 4, 99]],
+       \ 'foldcolumn': [[0, 1, 4, 12], [-1, 13, 999]],
+       \ 'helpheight': [[0, 10, 100], [-1]],
+       \ 'history': [[0, 1, 100], [-1, 10001]],
+       \ 'iminsert': [[0, 1], [-1, 3, 999]],
+       \ 'imsearch': [[-1, 0, 1], [-2, 3, 999]],
+       \ 'lines': [[2, 24], [-1, 0, 1]],
+       \ 'numberwidth': [[1, 4, 8, 10], [-1, 0, 11]],
+       \ 'regexpengine': [[0, 1, 2], [-1, 3, 999]],
+       \ 'report': [[0, 1, 2, 9999], [-1]],
+       \ 'scroll': [[0, 1, 2, 20], [-1]],
+       \ 'scrolljump': [[-50, -1, 0, 1, 2, 20], [999]],
+       \ 'scrolloff': [[0, 1, 2, 20], [-1]],
+       \ 'shiftwidth': [[0, 1, 8, 999], [-1]],
+       \ 'sidescroll': [[0, 1, 8, 999], [-1]],
+       \ 'sidescrolloff': [[0, 1, 8, 999], [-1]],
+       \ 'tabstop': [[1, 4, 8, 12], [-1, 0]],
+       \ 'textwidth': [[0, 1, 8, 99], [-1]],
+       \ 'timeoutlen': [[0, 8, 99999], [-1]],
+       \ 'titlelen': [[0, 1, 8, 9999], [-1]],
+       \ 'updatecount': [[0, 1, 8, 9999], [-1]],
+       \ 'updatetime': [[0, 1, 8, 9999], [-1]],
+       \ 'verbose': [[-1, 0, 1, 8, 9999], []],
+       \ 'wildcharm': [[-1, 0, 100], []],
+       \ 'winheight': [[1, 10, 999], [-1, 0]],
+       \ 'winminheight': [[0, 1], [-1]],
+       \ 'winminwidth': [[0, 1, 10], [-1]],
+       \ 'winwidth': [[1, 10, 999], [-1, 0]],
+       \
+       \ 'ambiwidth': [['', 'single'], ['xxx']],
+       \ 'background': [['', 'light', 'dark'], ['xxx']],
+       \ 'backspace': [[0, 2, '', 'eol', 'eol,start'], ['xxx']],
+       \ 'backupcopy': [['yes', 'auto'], ['', 'xxx', 'yes,no']],
+       \ 'backupext': [['xxx'], ['']],
+       \ 'belloff': [['', 'all', 'copy,error'], ['xxx']],
+       \ 'breakindentopt': [['', 'min:3', 'sbr'], ['xxx', 'min', 'min:x']],
+       \ 'browsedir': [['', 'last', '/tmp/'], ['xxx']],
+       \ 'bufhidden': [['', 'hide', 'wipe'], ['xxx', 'hide,wipe']],
+       \ 'buftype': [['', 'help', 'nofile'], ['xxx', 'help,nofile']],
+       \ 'casemap': [['', 'internal'], ['xxx']],
+       \ 'cedit': [['', '\<Esc>'], ['xxx', 'f']],
+       \ 'clipboard': [['', 'unnamed', 'autoselect,unnamed'], ['xxx']],
+       \ 'colorcolumn': [['', '8', '+2'], ['xxx']],
+       \ 'comments': [['', 'b:#'], ['xxx']],
+       \ 'commentstring': [['', '/*%s*/'], ['xxx']],
+       \ 'complete': [['', 'w,b'], ['xxx']],
+       \ 'concealcursor': [['', 'n', 'nvic'], ['xxx']],
+       \ 'completeopt': [['', 'menu', 'menu,longest'], ['xxx', 'menu,,,longest,']],
+       \ 'cryptmethod': [['', 'zip'], ['xxx']],
+       \ 'cscopequickfix': [['', 's-', 's-,c+,e0'], ['xxx', 's,g,d']],
+       \ 'debug': [['', 'msg', 'msg', 'beep'], ['xxx']],
+       \ 'diffopt': [['', 'filler', 'icase,iwhite'], ['xxx']],
+       \ 'display': [['', 'lastline', 'lastline,uhex'], ['xxx']],
+       \ 'eadirection': [['', 'both', 'ver'], ['xxx', 'ver,hor']],
+       \ 'encoding': [['latin1'], ['xxx', '']],
+       \ 'eventignore': [['', 'WinEnter', 'WinLeave,winenter'], ['xxx']],
+       \ 'fileencoding': [['', 'latin1', 'xxx'], []],
+       \ 'fileformat': [['', 'dos', 'unix'], ['xxx']],
+       \ 'fileformats': [['', 'dos', 'dos,unix'], ['xxx']],
+       \ 'fillchars': [['', 'vert:x'], ['xxx']],
+       \ 'foldclose': [['', 'all'], ['xxx']],
+       \ 'foldmethod': [['manual', 'indent'], ['', 'xxx', 'expr,diff']],
+       \ 'foldopen': [['', 'all', 'hor,jump'], ['xxx']],
+       \ 'foldmarker': [['((,))'], ['', 'xxx']],
+       \ 'formatoptions': [['', 'vt', 'v,t'], ['xxx']],
+       \ 'guicursor': [['', 'n:block-Cursor'], ['xxx']],
+       \ 'helplang': [['', 'de', 'de,it'], ['xxx']],
+       \ 'highlight': [['', 'e:Error'], ['xxx']],
+       \ 'isfname': [['', '@', '@,48-52'], ['xxx', '@48']],
+       \ 'isident': [['', '@', '@,48-52'], ['xxx', '@48']],
+       \ 'iskeyword': [['', '@', '@,48-52'], ['xxx', '@48']],
+       \ 'isprint': [['', '@', '@,48-52'], ['xxx', '@48']],
+       \ 'keymap': [['', 'accents'], ['xxx']],
+       \ 'keymodel': [['', 'startsel', 'startsel,stopsel'], ['xxx']],
+       \ 'langmap': [['', 'xX', 'aA,bB'], ['xxx']],
+       \ 'listchars': [['', 'eol:x', 'eol:x,space:y'], ['xxx']],
+       \ 'matchpairs': [['', '(:)', '(:),<:>'], ['xxx']],
+       \ 'mkspellmem': [['10000,100,12'], ['', 'xxx']],
+       \ 'mouse': [['', 'a', 'nvi'], ['xxx', 'n,v,i']],
+       \ 'mousemodel': [['', 'popup'], ['xxx']],
+       \ 'mouseshape': [['', 'n:arrow'], ['xxx']],
+       \ 'nrformats': [['', 'alpha', 'alpha,hex,bin'], ['xxx']],
+       \ 'printmbfont': [['', 'r:some', 'b:Bold,c:yes'], ['xxx']],
+       \ 'printoptions': [['', 'header:0', 'left:10pc,top:5pc'], ['xxx']],
+       \ 'scrollopt': [['', 'ver', 'ver,hor'], ['xxx']],
+       \ 'selection': [['old', 'inclusive'], ['', 'xxx']],
+       \ 'selectmode': [['', 'mouse', 'key,cmd'], ['xxx']],
+       \ 'sessionoptions': [['', 'blank', 'help,options,slash'], ['xxx']],
+       \ 'signcolumn': [['', 'auto', 'no'], ['xxx', 'no,yes']],
+       \ 'spellfile': [['', 'file.en.add'], ['xxx', '/tmp/file']],
+       \ 'spellsuggest': [['', 'best', 'double,33'], ['xxx']],
+       \ 'switchbuf': [['', 'useopen', 'split,newtab'], ['xxx']],
+       \ 'tagcase': [['smart', 'match'], ['', 'xxx', 'smart,match']],
+       \ 'term': [['ansi'], ['', 'gui']],
+       \ 'toolbar': [['', 'icons', 'text'], ['xxx']],
+       \ 'toolbariconsize': [['', 'tiny', 'huge'], ['xxx']],
+       \ 'ttymouse': [['', 'xterm'], ['xxx']],
+       \ 'ttytype': [['ansi'], ['', 'gui']],
+       \ 'viewoptions': [['', 'cursor', 'unix,slash'], ['xxx']],
+       \ 'viminfo': [['', '''50', '"30'], ['xxx']],
+       \ 'virtualedit': [['', 'all', 'all,block'], ['xxx']],
+       \ 'whichwrap': [['', 'b,s', 'bs'], ['xxx']],
+       \ 'wildmode': [['', 'full', 'list:full', 'full,longest'], ['xxx']],
+       \ 'wildoptions': [['', 'tagfile'], ['xxx']],
+       \ 'winaltkeys': [['menu', 'no'], ['', 'xxx']],
+       \
+       \ 'luadll': [[], []],
+       \ 'perldll': [[], []],
+       \ 'pythondll': [[], []],
+       \ 'pythonthreedll': [[], []],
+       \ 'pyxversion': [[], []],
+       \ 'rubydll': [[], []],
+       \ 'tcldll': [[], []],
+       \
+       \ 'othernum': [[-1, 0, 100], ['']],
+       \ 'otherstring': [['', 'xxx'], []],
+       \}
+ 
+ 1
+ /struct vimoption options
+ while 1
+   /{"
+   if line('.') > end
+     break
+   endif
+   let line = getline('.')
+   let name = substitute(line, '.*{"\([^"]*\)".*', '\1', '')
+   let shortname = substitute(line, '.*"\([^"]*\)".*', '\1', '')
+ 
+   if has_key(test_values, name)
+     let a = test_values[name]
+   elseif line =~ 'P_NUM'
+     let a = test_values['othernum']
+   else
+     let a = test_values['otherstring']
+   endif
+   if len(a[0]) > 0 || len(a[1]) > 0
+     if line =~ 'P_BOOL'
+       call add(script, 'set ' . name)
+       call add(script, 'set ' . shortname)
+       call add(script, 'set no' . name)
+       call add(script, 'set no' . shortname)
+     else
+       for val in a[0]
+ 	call add(script, 'set ' . name . '=' . val)
+ 	call add(script, 'set ' . shortname . '=' . val)
+ 
+ 	if name == 'verbosefile' && !empty(val)
+ 	  call add(script, 'call delete("'. val. '")')
+ 	endif
+       endfor
+ 
+       " setting an option can only fail when it's implemented.
+       call add(script, "if exists('+" . name . "')")
+       for val in a[1]
+ 	call add(script, "call assert_fails('set " . name . "=" . val . "')")
+ 	call add(script, "call assert_fails('set " . shortname . "=" . val . "')")
+       endfor
+       call add(script, "endif")
+     endif
+ 
+     call add(script, 'set ' . name . '&')
+     call add(script, 'set ' . shortname . '&')
+ 
+     if name == 'more'
+       call add(script, 'set nomore')
+     endif
+   endif
+ endwhile
+ 
+ call add(script, 'let &term = save_term')
+ call add(script, 'let &columns = save_columns')
+ call add(script, 'let &lines = save_lines')
+ 
+ call writefile(script, 'testdir/opt_test.vim')
+ 
+ endif
+ 
+ qa!
*** ../vim-8.0.0427/src/Makefile	2017-03-05 19:43:44.549127317 +0100
--- src/Makefile	2017-03-07 21:15:23.073271970 +0100
***************
*** 2025,2031 ****
  #
  scripttests:
  	$(MAKE) -f Makefile $(VIMTARGET)
- 	$(MAKE) -f Makefile testdir/opt_test.vim
  	if test -n "$(MAKEMO)" -a -f $(PODIR)/Makefile; then \
  		cd $(PODIR); $(MAKE) -f Makefile check VIM=../$(VIMTARGET); \
  	fi
--- 2025,2030 ----
***************
*** 2034,2042 ****
  	fi
  	cd testdir; $(MAKE) -f Makefile $(GUI_TESTTARGET) VIMPROG=../$(VIMTARGET) $(GUI_TESTARG) SCRIPTSOURCE=../$(SCRIPTSOURCE)
  
- testdir/opt_test.vim: option.c gen_opt_test.vim
- 	./$(VIMTARGET) -u gen_opt_test.vim --noplugin --not-a-term
- 
  # Run the tests with the GUI.  Assumes vim/gvim was already built
  testgui:
  	cd testdir; $(MAKE) -f Makefile $(GUI_TESTTARGET) VIMPROG=../$(VIMTARGET) GUI_FLAG=-g $(GUI_TESTARG) SCRIPTSOURCE=../$(SCRIPTSOURCE)
--- 2033,2038 ----
*** ../vim-8.0.0427/src/testdir/Make_all.mak	2017-03-05 19:43:44.549127317 +0100
--- src/testdir/Make_all.mak	2017-03-07 21:12:57.410415314 +0100
***************
*** 221,223 ****
--- 221,224 ----
  
  test60.out: test60.vim
  
+ test_options.res: opt_test.vim
*** ../vim-8.0.0427/src/testdir/Makefile	2017-02-23 19:32:18.068709554 +0100
--- src/testdir/Makefile	2017-03-07 21:16:38.280682202 +0100
***************
*** 55,61 ****
  RUN_VIM = VIMRUNTIME=$(SCRIPTSOURCE); export VIMRUNTIME; $(VALGRIND) $(VIMPROG) -f $(GUI_FLAG) -u unix.vim $(NO_INITS) -s dotest.in
  
  clean:
! 	-rm -rf *.out *.failed *.res *.rej *.orig test.log messages $(RM_ON_RUN) $(RM_ON_START) valgrind.*
  
  test1.out: test1.in
  	-rm -rf $*.failed $(RM_ON_RUN) $(RM_ON_START) wrongtermsize
--- 55,61 ----
  RUN_VIM = VIMRUNTIME=$(SCRIPTSOURCE); export VIMRUNTIME; $(VALGRIND) $(VIMPROG) -f $(GUI_FLAG) -u unix.vim $(NO_INITS) -s dotest.in
  
  clean:
! 	-rm -rf *.out *.failed *.res *.rej *.orig opt_test.vim test.log messages $(RM_ON_RUN) $(RM_ON_START) valgrind.*
  
  test1.out: test1.in
  	-rm -rf $*.failed $(RM_ON_RUN) $(RM_ON_START) wrongtermsize
***************
*** 140,142 ****
--- 140,146 ----
  	@echo "$(RUN_GVIMTEST_WITH_GVIMRC)" > vimcmd
  	$(RUN_VIMTEST) -u NONE -U gui_init.vim $(NO_PLUGINS) -S runtest.vim $<
  	@rm vimcmd
+ 
+ opt_test.vim: ../option.c gen_opt_test.vim
+ 	$(VIMPROG) -u gen_opt_test.vim --noplugin --not-a-term
+ 
*** ../vim-8.0.0427/src/testdir/Make_dos.mak	2017-02-23 20:17:09.251676386 +0100
--- src/testdir/Make_dos.mak	2017-03-07 21:17:46.864144700 +0100
***************
*** 94,99 ****
--- 94,100 ----
  	-if exist test.log del test.log
  	-if exist messages del messages
  	-if exist benchmark.out del benchmark.out
+ 	-if exist opt_test.vim del opt_test.vim
  
  nolog:
  	-if exist test.log del test.log
***************
*** 127,129 ****
--- 128,133 ----
  	@echo "$(VIMPROG)" > vimcmd
  	$(VIMPROG) -u NONE -U gui_init.vim $(NO_PLUGINS) -S runtest.vim $*.vim
  	@del vimcmd
+ 
+ opt_test.vim: ../option.c gen_opt_test.vim
+ 	$(VIMPROG) -u gen_opt_test.vim --noplugin --not-a-term
*** ../vim-8.0.0427/src/testdir/Make_ming.mak	2017-02-23 19:32:18.068709554 +0100
--- src/testdir/Make_ming.mak	2017-03-07 21:24:32.340972891 +0100
***************
*** 88,93 ****
--- 88,94 ----
  	-@if exist viminfo $(DEL) viminfo
  	-@if exist test.log $(DEL) test.log
  	-@if exist messages $(DEL) messages
+ 	-@if exist opt_test.vim $(DEL) opt_test.vim
  
  .in.out:
  	-@if exist $*.ok $(CP) $*.ok test.ok
***************
*** 131,133 ****
--- 132,136 ----
  	$(VIMPROG) -u NONE -U gui_init.vim $(NO_PLUGINS) -S runtest.vim $<
  	@$(DEL) vimcmd
  
+ opt_test.vim: ../option.c gen_opt_test.vim
+ 	$(VIMPROG) -u gen_opt_test.vim --noplugin --not-a-term
*** ../vim-8.0.0427/Filelist	2017-02-25 20:40:31.758696482 +0100
--- Filelist	2017-03-07 21:18:56.631598228 +0100
***************
*** 97,103 ****
  		src/tee/tee.c \
  		src/xxd/xxd.c \
  		src/main.aap \
! 		src/gen_opt_test.vim \
  		src/testdir/main.aap \
  		src/testdir/README.txt \
  		src/testdir/Make_all.mak \
--- 97,103 ----
  		src/tee/tee.c \
  		src/xxd/xxd.c \
  		src/main.aap \
! 		src/testdir/gen_opt_test.vim \
  		src/testdir/main.aap \
  		src/testdir/README.txt \
  		src/testdir/Make_all.mak \
*** ../vim-8.0.0427/src/version.c	2017-03-06 21:44:47.063429442 +0100
--- src/version.c	2017-03-07 21:25:57.344309200 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     428,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
80. At parties, you introduce your spouse as your "service provider."

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0429
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0429
Problem:    Options test does not always test everything.
Solution:   Fix dependency for opt_test.vim.  Give a message when opt_test.vim
            was not found.
Files:      src/testdir/test_options.vim, src/testdir/gen_opt_test.vim,
            src/testdir/Makefile, src/testdir/Make_all.mak,
            src/testdir/Make_dos.mak, src/testdir/Make_ming.mak

*** ../vim-8.0.0428/src/testdir/test_options.vim	2017-02-25 21:37:53.872571889 +0100
--- src/testdir/test_options.vim	2017-03-07 21:40:23.269227970 +0100
***************
*** 301,308 ****
  endfunc
  
  func Test_set_values()
-   " The file is only generated when running "make test" in the src directory.
    if filereadable('opt_test.vim')
      source opt_test.vim
    endif
  endfunc
--- 301,309 ----
  endfunc
  
  func Test_set_values()
    if filereadable('opt_test.vim')
      source opt_test.vim
+   else
+     throw 'Skipped: opt_test.vim does not exist'
    endif
  endfunc
*** ../vim-8.0.0428/src/testdir/gen_opt_test.vim	2017-03-07 21:27:01.347786655 +0100
--- src/testdir/gen_opt_test.vim	2017-03-07 22:21:30.537111016 +0100
***************
*** 13,19 ****
        \ 'let save_term = &term',
        \ ]
  
! edit option.c
  /#define p_term
  let end = line('.')
  
--- 13,19 ----
        \ 'let save_term = &term',
        \ ]
  
! edit
  /#define p_term
  let end = line('.')
  
***************
*** 197,203 ****
  call add(script, 'let &columns = save_columns')
  call add(script, 'let &lines = save_lines')
  
! call writefile(script, 'testdir/opt_test.vim')
  
  endif
  
--- 197,203 ----
  call add(script, 'let &columns = save_columns')
  call add(script, 'let &lines = save_lines')
  
! call writefile(script, 'opt_test.vim')
  
  endif
  
*** ../vim-8.0.0428/src/testdir/Makefile	2017-03-07 21:27:01.347786655 +0100
--- src/testdir/Makefile	2017-03-07 22:23:39.520067530 +0100
***************
*** 142,146 ****
  	@rm vimcmd
  
  opt_test.vim: ../option.c gen_opt_test.vim
! 	$(VIMPROG) -u gen_opt_test.vim --noplugin --not-a-term
! 
--- 142,145 ----
  	@rm vimcmd
  
  opt_test.vim: ../option.c gen_opt_test.vim
! 	$(VIMPROG) -u gen_opt_test.vim --noplugin --not-a-term ../option.c
*** ../vim-8.0.0428/src/testdir/Make_all.mak	2017-03-07 21:27:01.347786655 +0100
--- src/testdir/Make_all.mak	2017-03-07 22:25:50.483009157 +0100
***************
*** 221,224 ****
  
  test60.out: test60.vim
  
! test_options.res: opt_test.vim
--- 221,224 ----
  
  test60.out: test60.vim
  
! test_options.res test_alot.res: opt_test.vim
*** ../vim-8.0.0428/src/testdir/Make_dos.mak	2017-03-07 21:27:01.347786655 +0100
--- src/testdir/Make_dos.mak	2017-03-07 22:07:48.503773088 +0100
***************
*** 130,133 ****
  	@del vimcmd
  
  opt_test.vim: ../option.c gen_opt_test.vim
! 	$(VIMPROG) -u gen_opt_test.vim --noplugin --not-a-term
--- 130,133 ----
  	@del vimcmd
  
  opt_test.vim: ../option.c gen_opt_test.vim
! 	$(VIMPROG) -u gen_opt_test.vim --noplugin --not-a-term ../option.c
*** ../vim-8.0.0428/src/testdir/Make_ming.mak	2017-03-07 21:27:01.347786655 +0100
--- src/testdir/Make_ming.mak	2017-03-07 22:08:27.279457926 +0100
***************
*** 133,136 ****
  	@$(DEL) vimcmd
  
  opt_test.vim: ../option.c gen_opt_test.vim
! 	$(VIMPROG) -u gen_opt_test.vim --noplugin --not-a-term
--- 133,136 ----
  	@$(DEL) vimcmd
  
  opt_test.vim: ../option.c gen_opt_test.vim
! 	$(VIMPROG) -u gen_opt_test.vim --noplugin --not-a-term ../option.c
*** ../vim-8.0.0428/src/version.c	2017-03-07 21:27:01.351786622 +0100
--- src/version.c	2017-03-07 22:32:26.379816289 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     429,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
81. At social functions you introduce your husband as "my domain server."

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0430
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0430
Problem:    Options test fails or hangs on MS-Windows.
Solution:   Run it separately instead of part of test_alot.  Use "-S" instead
            of "-u" to run the script.  Fix failures.
Files:      src/testdir/Make_all.mak, src/testdir/test_alot.vim,
            src/testdir/Makefile, src/testdir/Make_dos.mak,
            src/testdir/Make_ming.mak, src/testdir/gen_opt_test.vim


*** ../vim-8.0.0429/src/testdir/Make_all.mak	2017-03-07 22:33:27.619323238 +0100
--- src/testdir/Make_all.mak	2017-03-07 22:55:20.412882145 +0100
***************
*** 181,186 ****
--- 181,187 ----
  	    test_netbeans.res \
  	    test_normal.res \
  	    test_number.res \
+ 	    test_options.res \
  	    test_packadd.res \
  	    test_paste.res \
  	    test_perl.res \
*** ../vim-8.0.0429/src/testdir/test_alot.vim	2017-02-23 18:46:24.462288941 +0100
--- src/testdir/test_alot.vim	2017-03-07 22:56:25.972362704 +0100
***************
*** 50,53 ****
  source test_true_false.vim
  source test_unlet.vim
  source test_window_cmd.vim
- source test_options.vim
--- 50,52 ----
*** ../vim-8.0.0429/src/testdir/Makefile	2017-03-07 22:33:27.619323238 +0100
--- src/testdir/Makefile	2017-03-07 23:15:58.735059748 +0100
***************
*** 142,145 ****
  	@rm vimcmd
  
  opt_test.vim: ../option.c gen_opt_test.vim
! 	$(VIMPROG) -u gen_opt_test.vim --noplugin --not-a-term ../option.c
--- 142,145 ----
  	@rm vimcmd
  
  opt_test.vim: ../option.c gen_opt_test.vim
! 	$(VIMPROG) -u NONE -S gen_opt_test.vim --noplugin --not-a-term ../option.c
*** ../vim-8.0.0429/src/testdir/Make_dos.mak	2017-03-07 22:33:27.619323238 +0100
--- src/testdir/Make_dos.mak	2017-03-07 23:17:44.806210383 +0100
***************
*** 130,133 ****
  	@del vimcmd
  
  opt_test.vim: ../option.c gen_opt_test.vim
! 	$(VIMPROG) -u gen_opt_test.vim --noplugin --not-a-term ../option.c
--- 130,133 ----
  	@del vimcmd
  
  opt_test.vim: ../option.c gen_opt_test.vim
! 	$(VIMPROG) -u NONE -S gen_opt_test.vim --noplugin --not-a-term ../option.c
*** ../vim-8.0.0429/src/testdir/Make_ming.mak	2017-03-07 22:33:27.619323238 +0100
--- src/testdir/Make_ming.mak	2017-03-07 23:17:53.246142816 +0100
***************
*** 133,136 ****
  	@$(DEL) vimcmd
  
  opt_test.vim: ../option.c gen_opt_test.vim
! 	$(VIMPROG) -u gen_opt_test.vim --noplugin --not-a-term ../option.c
--- 133,136 ----
  	@$(DEL) vimcmd
  
  opt_test.vim: ../option.c gen_opt_test.vim
! 	$(VIMPROG) -u NONE -S gen_opt_test.vim --noplugin --not-a-term ../option.c
*** ../vim-8.0.0429/src/testdir/gen_opt_test.vim	2017-03-07 22:33:27.619323238 +0100
--- src/testdir/gen_opt_test.vim	2017-03-07 23:58:59.887087468 +0100
***************
*** 13,19 ****
        \ 'let save_term = &term',
        \ ]
  
- edit
  /#define p_term
  let end = line('.')
  
--- 13,18 ----
***************
*** 30,35 ****
--- 29,35 ----
        \ 'iminsert': [[0, 1], [-1, 3, 999]],
        \ 'imsearch': [[-1, 0, 1], [-2, 3, 999]],
        \ 'lines': [[2, 24], [-1, 0, 1]],
+       \ 'linespace': [[0, 2, 4], ['']],
        \ 'numberwidth': [[1, 4, 8, 10], [-1, 0, 11]],
        \ 'regexpengine': [[0, 1, 2], [-1, 3, 999]],
        \ 'report': [[0, 1, 2, 9999], [-1]],
***************
*** 59,65 ****
        \ 'backupext': [['xxx'], ['']],
        \ 'belloff': [['', 'all', 'copy,error'], ['xxx']],
        \ 'breakindentopt': [['', 'min:3', 'sbr'], ['xxx', 'min', 'min:x']],
!       \ 'browsedir': [['', 'last', '/tmp/'], ['xxx']],
        \ 'bufhidden': [['', 'hide', 'wipe'], ['xxx', 'hide,wipe']],
        \ 'buftype': [['', 'help', 'nofile'], ['xxx', 'help,nofile']],
        \ 'casemap': [['', 'internal'], ['xxx']],
--- 59,65 ----
        \ 'backupext': [['xxx'], ['']],
        \ 'belloff': [['', 'all', 'copy,error'], ['xxx']],
        \ 'breakindentopt': [['', 'min:3', 'sbr'], ['xxx', 'min', 'min:x']],
!       \ 'browsedir': [['', 'last', '/'], ['xxx']],
        \ 'bufhidden': [['', 'hide', 'wipe'], ['xxx', 'hide,wipe']],
        \ 'buftype': [['', 'help', 'nofile'], ['xxx', 'help,nofile']],
        \ 'casemap': [['', 'internal'], ['xxx']],
***************
*** 89,94 ****
--- 89,96 ----
        \ 'foldmarker': [['((,))'], ['', 'xxx']],
        \ 'formatoptions': [['', 'vt', 'v,t'], ['xxx']],
        \ 'guicursor': [['', 'n:block-Cursor'], ['xxx']],
+       \ 'guifont': [['', 'fixedsys'], []],
+       \ 'guifontwide': [['', 'fixedsys'], []],
        \ 'helplang': [['', 'de', 'de,it'], ['xxx']],
        \ 'highlight': [['', 'e:Error'], ['xxx']],
        \ 'isfname': [['', '@', '@,48-52'], ['xxx', '@48']],
***************
*** 108,113 ****
--- 110,116 ----
        \ 'printmbfont': [['', 'r:some', 'b:Bold,c:yes'], ['xxx']],
        \ 'printoptions': [['', 'header:0', 'left:10pc,top:5pc'], ['xxx']],
        \ 'scrollopt': [['', 'ver', 'ver,hor'], ['xxx']],
+       \ 'renderoptions': [['', 'type:directx'], ['xxx']],
        \ 'selection': [['old', 'inclusive'], ['', 'xxx']],
        \ 'selectmode': [['', 'mouse', 'key,cmd'], ['xxx']],
        \ 'sessionoptions': [['', 'blank', 'help,options,slash'], ['xxx']],
***************
*** 116,126 ****
        \ 'spellsuggest': [['', 'best', 'double,33'], ['xxx']],
        \ 'switchbuf': [['', 'useopen', 'split,newtab'], ['xxx']],
        \ 'tagcase': [['smart', 'match'], ['', 'xxx', 'smart,match']],
!       \ 'term': [['ansi'], ['', 'gui']],
        \ 'toolbar': [['', 'icons', 'text'], ['xxx']],
        \ 'toolbariconsize': [['', 'tiny', 'huge'], ['xxx']],
        \ 'ttymouse': [['', 'xterm'], ['xxx']],
!       \ 'ttytype': [['ansi'], ['', 'gui']],
        \ 'viewoptions': [['', 'cursor', 'unix,slash'], ['xxx']],
        \ 'viminfo': [['', '''50', '"30'], ['xxx']],
        \ 'virtualedit': [['', 'all', 'all,block'], ['xxx']],
--- 119,129 ----
        \ 'spellsuggest': [['', 'best', 'double,33'], ['xxx']],
        \ 'switchbuf': [['', 'useopen', 'split,newtab'], ['xxx']],
        \ 'tagcase': [['smart', 'match'], ['', 'xxx', 'smart,match']],
!       \ 'term': [[], []],
        \ 'toolbar': [['', 'icons', 'text'], ['xxx']],
        \ 'toolbariconsize': [['', 'tiny', 'huge'], ['xxx']],
        \ 'ttymouse': [['', 'xterm'], ['xxx']],
!       \ 'ttytype': [[], []],
        \ 'viewoptions': [['', 'cursor', 'unix,slash'], ['xxx']],
        \ 'viminfo': [['', '''50', '"30'], ['xxx']],
        \ 'virtualedit': [['', 'all', 'all,block'], ['xxx']],
***************
*** 189,194 ****
--- 192,199 ----
  
      if name == 'more'
        call add(script, 'set nomore')
+     elseif name == 'lines'
+       call add(script, 'let &lines = save_lines')
      endif
    endif
  endwhile
*** ../vim-8.0.0429/src/version.c	2017-03-07 22:33:27.619323238 +0100
--- src/version.c	2017-03-07 23:59:43.262201627 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     430,
  /**/

-- 
If your nose runs, and your feet smell, you might be upside down.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0431
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0431
Problem:    'cinoptions' cannot set indent for extern block.
Solution:   Add the "E" flag in 'cinoptions'. (Hirohito Higashi)
Files:      runtime/doc/indent.txt, src/misc1.c, src/structs.h,
            src/testdir/test_cindent.vim


*** ../vim-8.0.0430/runtime/doc/indent.txt	2016-09-12 12:45:26.000000000 +0200
--- runtime/doc/indent.txt	2017-03-08 21:34:43.061320700 +0100
***************
*** 325,330 ****
--- 325,345 ----
  		      void function();       void function();
  		  }                          }
  <
+ 							*cino-E*
+ 	EN    Indent inside C++ linkage specifications (extern "C" or
+ 	      extern "C++") N characters extra compared to a normal block.
+ 	      (default 0).
+ 
+ 		cino=			   cino=E-s >
+ 		  extern "C" {               extern "C" {
+ 		      void function();       void function();
+ 		  }                          }
+ 
+ 		  extern "C"                 extern "C"
+ 		  {                          {
+ 		      void function();       void function();
+ 		  }                          }
+ <
  							*cino-p*
  	pN    Parameter declarations for K&R-style function declarations will
  	      be indented N characters from the margin.  (default
***************
*** 554,560 ****
  
  
  The defaults, spelled out in full, are:
! 	cinoptions=>s,e0,n0,f0,{0,}0,^0,L-1,:s,=s,l0,b0,gs,hs,N0,ps,ts,is,+s,
  			c3,C0,/0,(2s,us,U0,w0,W0,k0,m0,j0,J0,)20,*70,#0
  
  Vim puts a line in column 1 if:
--- 569,575 ----
  
  
  The defaults, spelled out in full, are:
! 	cinoptions=>s,e0,n0,f0,{0,}0,^0,L-1,:s,=s,l0,b0,gs,hs,N0,E0,ps,ts,is,+s,
  			c3,C0,/0,(2s,us,U0,w0,W0,k0,m0,j0,J0,)20,*70,#0
  
  Vim puts a line in column 1 if:
*** ../vim-8.0.0430/src/misc1.c	2017-03-05 19:43:44.545127347 +0100
--- src/misc1.c	2017-03-08 21:34:43.065320672 +0100
***************
*** 5810,5815 ****
--- 5810,5863 ----
  }
  
  /*
+  * Recognize a `extern "C"` or `extern "C++"` linkage specifications.
+  */
+     static int
+ cin_is_cpp_extern_c(char_u *s)
+ {
+     char_u	*p;
+     int		has_string_literal = FALSE;
+ 
+     s = cin_skipcomment(s);
+     if (STRNCMP(s, "extern", 6) == 0 && (s[6] == NUL || !vim_iswordc(s[6])))
+     {
+ 	p = cin_skipcomment(skipwhite(s + 6));
+ 	while (*p != NUL)
+ 	{
+ 	    if (vim_iswhite(*p))
+ 	    {
+ 		p = cin_skipcomment(skipwhite(p));
+ 	    }
+ 	    else if (*p == '{')
+ 	    {
+ 		break;
+ 	    }
+ 	    else if (p[0] == '"' && p[1] == 'C' && p[2] == '"')
+ 	    {
+ 		if (has_string_literal)
+ 		    return FALSE;
+ 		has_string_literal = TRUE;
+ 		p += 3;
+ 	    }
+ 	    else if (p[0] == '"' && p[1] == 'C' && p[2] == '+' && p[3] == '+'
+ 		    && p[4] == '"')
+ 	    {
+ 		if (has_string_literal)
+ 		    return FALSE;
+ 		has_string_literal = TRUE;
+ 		p += 5;
+ 	    }
+ 	    else
+ 	    {
+ 		return FALSE;
+ 	    }
+ 	}
+ 	return has_string_literal ? TRUE : FALSE;
+     }
+     return FALSE;
+ }
+ 
+ /*
   * Return a pointer to the first non-empty non-comment character after a ':'.
   * Return NULL if not found.
   *	  case 234:    a = b;
***************
*** 6652,6657 ****
--- 6700,6706 ----
  {
      char_u	*line;
      char_u	*p;
+     char_u	*new_p;
  
      p = line = ml_get(trypos->lnum);
      while (*p && (colnr_T)(p - line) < trypos->col)
***************
*** 6660,6667 ****
  	    p = cin_skipcomment(p);
  	else
  	{
! 	    p = skip_string(p);
! 	    ++p;
  	}
      }
      return (int)(p - line);
--- 6709,6719 ----
  	    p = cin_skipcomment(p);
  	else
  	{
! 	    new_p = skip_string(p);
! 	    if (new_p == p)
! 		++p;
! 	    else
! 		p = new_p;
  	}
      }
      return (int)(p - line);
***************
*** 6977,6982 ****
--- 7029,7037 ----
      /* indentation for # comments */
      buf->b_ind_hash_comment = 0;
  
+     /* Handle C++ extern "C" or "C++" */
+     buf->b_ind_cpp_extern_c = 0;
+ 
      for (p = buf->b_p_cino; *p; )
      {
  	l = p++;
***************
*** 7051,7056 ****
--- 7106,7112 ----
  	    case '#': buf->b_ind_hash_comment = n; break;
  	    case 'N': buf->b_ind_cpp_namespace = n; break;
  	    case 'k': buf->b_ind_if_for_while = n; break;
+ 	    case 'E': buf->b_ind_cpp_extern_c = n; break;
  	}
  	if (*p == ',')
  	    ++p;
***************
*** 7764,7769 ****
--- 7820,7827 ----
  		    l = skipwhite(ml_get_curline());
  		    if (cin_is_cpp_namespace(l))
  			amount += curbuf->b_ind_cpp_namespace;
+ 		    else if (cin_is_cpp_extern_c(l))
+ 			amount += curbuf->b_ind_cpp_extern_c;
  		}
  		else
  		{
***************
*** 7990,7995 ****
--- 8048,8059 ----
  							    - added_to_amount;
  				break;
  			    }
+ 			    else if (cin_is_cpp_extern_c(l))
+ 			    {
+ 				amount += curbuf->b_ind_cpp_extern_c
+ 							    - added_to_amount;
+ 				break;
+ 			    }
  
  			    if (cin_nocode(l))
  				continue;
*** ../vim-8.0.0430/src/structs.h	2017-03-05 17:43:10.624245543 +0100
--- src/structs.h	2017-03-08 21:34:43.069320646 +0100
***************
*** 2236,2241 ****
--- 2236,2242 ----
      int		b_ind_hash_comment;
      int		b_ind_cpp_namespace;
      int		b_ind_if_for_while;
+     int		b_ind_cpp_extern_c;
  #endif
  
      linenr_T	b_no_eol_lnum;	/* non-zero lnum when last line of next binary
*** ../vim-8.0.0430/src/testdir/test_cindent.vim	2017-03-05 19:43:44.549127317 +0100
--- src/testdir/test_cindent.vim	2017-03-08 21:55:12.984178666 +0100
***************
*** 14,16 ****
--- 14,76 ----
    call assert_equal(["#include <iostream>", "#include"], getline(1,2))
    bwipe!
  endfunc
+ 
+ func Test_cino_extern_c()
+   " Test for cino-E
+ 
+   let without_ind = [
+         \ '#ifdef __cplusplus',
+         \ 'extern "C" {',
+         \ '#endif',
+         \ 'int func_a(void);',
+         \ '#ifdef __cplusplus',
+         \ '}',
+         \ '#endif'
+         \ ]
+ 
+   let with_ind = [
+         \ '#ifdef __cplusplus',
+         \ 'extern "C" {',
+         \ '#endif',
+         \ "\tint func_a(void);",
+         \ '#ifdef __cplusplus',
+         \ '}',
+         \ '#endif'
+         \ ]
+   new
+   setlocal cindent cinoptions=E0
+   call setline(1, without_ind)
+   call feedkeys("gg=G", 'tx')
+   call assert_equal(with_ind, getline(1, '$'))
+ 
+   setlocal cinoptions=E-s
+   call setline(1, with_ind)
+   call feedkeys("gg=G", 'tx')
+   call assert_equal(without_ind, getline(1, '$'))
+ 
+   setlocal cinoptions=Es
+   let tests = [
+         \ ['recognized', ['extern "C" {'], "\t\t;"],
+         \ ['recognized', ['extern "C++" {'], "\t\t;"],
+         \ ['recognized', ['extern /* com */ "C"{'], "\t\t;"],
+         \ ['recognized', ['extern"C"{'], "\t\t;"],
+         \ ['recognized', ['extern "C"', '{'], "\t\t;"],
+         \ ['not recognized', ['extern {'], "\t;"],
+         \ ['not recognized', ['extern /*"C"*/{'], "\t;"],
+         \ ['not recognized', ['extern "C" //{'], ";"],
+         \ ['not recognized', ['extern "C" /*{*/'], ";"],
+         \ ]
+ 
+   for pair in tests
+     let lines = pair[1]
+     call setline(1, lines)
+     call feedkeys(len(lines) . "Go;", 'tx')
+     call assert_equal(pair[2], getline(len(lines) + 1), 'Failed for "' . string(lines) . '"')
+   endfor
+ 
+ 
+ 
+   bwipe!
+ endfunc
+ 
+ " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.0.0430/src/version.c	2017-03-08 00:01:31.489347798 +0100
--- src/version.c	2017-03-08 21:37:32.088116586 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     431,
  /**/

-- 
From "know your smileys":
 y:-)	Bad toupee

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0432
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0432
Problem:    "make shadow" creates an invalid link.
Solution:   Don't link "*.vim". (Kazunobu Kuriyama)
Files:      src/Makefile


*** ../vim-8.0.0431/src/Makefile	2017-03-07 21:27:01.347786655 +0100
--- src/Makefile	2017-03-08 22:36:59.458144563 +0100
***************
*** 2770,2776 ****
  
  shadow:	runtime pixmaps
  	mkdir $(SHADOWDIR)
! 	cd $(SHADOWDIR); ln -s ../*.[chm] ../*.in ../*.vim ../*.sh ../*.xs ../*.xbm ../gui_gtk_res.xml ../toolcheck ../proto ../vimtutor ../gvimtutor ../mkinstalldirs .
  	mkdir $(SHADOWDIR)/auto
  	cd $(SHADOWDIR)/auto; ln -s ../../auto/configure .
  	mkdir $(SHADOWDIR)/po
--- 2770,2776 ----
  
  shadow:	runtime pixmaps
  	mkdir $(SHADOWDIR)
! 	cd $(SHADOWDIR); ln -s ../*.[chm] ../*.in ../*.sh ../*.xs ../*.xbm ../gui_gtk_res.xml ../toolcheck ../proto ../vimtutor ../gvimtutor ../mkinstalldirs .
  	mkdir $(SHADOWDIR)/auto
  	cd $(SHADOWDIR)/auto; ln -s ../../auto/configure .
  	mkdir $(SHADOWDIR)/po
*** ../vim-8.0.0431/src/version.c	2017-03-08 22:19:21.721870759 +0100
--- src/version.c	2017-03-08 22:37:48.045796891 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     432,
  /**/

-- 
From "know your smileys":
 :~)	A man with a tape recorder up his nose

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0433
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0433
Problem:    Quite a few beeps when running tests.
Solution:   Set 'belloff' for these tests. (Christian Brabandt)
Files:      src/testdir/test103.in, src/testdir/test14.in,
            src/testdir/test29.in, src/testdir/test30.in,
            src/testdir/test32.in, src/testdir/test45.in,
            src/testdir/test72.in, src/testdir/test73.in,
            src/testdir/test77.in, src/testdir/test78.in,
            src/testdir/test85.in, src/testdir/test94.in,
            src/testdir/test_alot.vim, src/testdir/test_alot_utf8.vim,
            src/testdir/test_close_count.in, src/testdir/test_cmdline.vim,
            src/testdir/test_diffmode.vim, src/testdir/test_digraph.vim,
            src/testdir/test_erasebackword.in, src/testdir/test_normal.vim,
            src/testdir/test_packadd.vim, src/testdir/test_search.vim,
            src/testdir/test_textobjects.vim, src/testdir/test_undo.vim,
            src/testdir/test_usercommands.vim, src/testdir/test_visual.vim


*** ../vim-8.0.0432/src/testdir/test103.in	2013-11-21 14:02:09.000000000 +0100
--- src/testdir/test103.in	2017-03-08 22:48:59.304883131 +0100
***************
*** 1,6 ****
--- 1,7 ----
  Test for visual mode not being reset causing E315 error.
  STARTTEST
  :so small.vim
+ :set belloff=all
  :enew
  :let g:msg="Everything's fine."
  :function! TriggerTheProblem()
*** ../vim-8.0.0432/src/testdir/test14.in	2014-01-14 21:13:39.000000000 +0100
--- src/testdir/test14.in	2017-03-08 22:48:59.304883131 +0100
***************
*** 6,11 ****
--- 6,12 ----
  
  STARTTEST
  :so small.vim
+ :set belloff=all
  /Start cursor here
  vaBiBD:?Bug?,/Piece/-2w! test.out
  /^- Bug
*** ../vim-8.0.0432/src/testdir/test29.in	2015-08-11 18:30:19.000000000 +0200
--- src/testdir/test29.in	2017-03-08 22:48:59.304883131 +0100
***************
*** 103,108 ****
--- 103,109 ----
  
  STARTTEST
  :" Test with backspace set to the non-compatible setting
+ :set belloff=all
  /^\d\+ this
  :set cp bs=2
  Avim1
*** ../vim-8.0.0432/src/testdir/test30.in	2015-02-27 17:42:21.000000000 +0100
--- src/testdir/test30.in	2017-03-08 22:48:59.304883131 +0100
***************
*** 4,9 ****
--- 4,10 ----
  
  STARTTEST
  :so small.vim
+ :set belloff=all
  :" first write three test files, one in each format
  :set fileformat=unix
  :set fileformats=
*** ../vim-8.0.0432/src/testdir/test32.in	2013-09-08 18:08:07.000000000 +0200
--- src/testdir/test32.in	2017-03-08 22:48:59.304883131 +0100
***************
*** 23,28 ****
--- 23,29 ----
  STARTTEST
  :so small.vim
  :se nocp viminfo+=nviminfo cpt=.,w ff=unix | $-2,$w!Xtestfile | set ff&
+ :set belloff=all
  :se cot=
  nO#include "Xtestfile"
  ru
*** ../vim-8.0.0432/src/testdir/test45.in	2015-04-15 12:31:42.000000000 +0200
--- src/testdir/test45.in	2017-03-08 22:48:59.304883131 +0100
***************
*** 2,7 ****
--- 2,8 ----
  
  STARTTEST
  :so small.vim
+ :set belloff=all
  :" We also need the +syntax feature here.
  :if !has("syntax")
     e! test.ok
*** ../vim-8.0.0432/src/testdir/test72.in	2014-11-05 16:34:30.000000000 +0100
--- src/testdir/test72.in	2017-03-08 22:48:59.304883131 +0100
***************
*** 4,9 ****
--- 4,10 ----
  
  STARTTEST
  :so small.vim
+ :set belloff=all
  :"
  :" Test 'undofile': first a simple one-line change.
  :set nocompatible viminfo+=nviminfo visualbell
***************
*** 25,31 ****
  :set undofile
  :bwipe!
  :e Xtestfile
- :" TODO: this beeps
  u:.w >>test.out
  :"
  :" Test 'undofile', add 10 lines, delete 6 lines, undo 3
--- 26,31 ----
*** ../vim-8.0.0432/src/testdir/test73.in	2016-06-08 21:40:30.000000000 +0200
--- src/testdir/test73.in	2017-03-08 22:48:59.304883131 +0100
***************
*** 2,7 ****
--- 2,8 ----
  
  STARTTEST
  :so small.vim
+ :set belloff=all
  :" Do all test in a separate window to avoid E211 when we recursively
  :" delete the Xfind directory during cleanup
  :"
*** ../vim-8.0.0432/src/testdir/test77.in	2013-06-19 20:03:54.000000000 +0200
--- src/testdir/test77.in	2017-03-08 22:48:59.304883131 +0100
***************
*** 10,15 ****
--- 10,16 ----
  
  STARTTEST
  :so small.vim
+ :set belloff=all
  :if !executable("cksum")
  : e! test.ok
  : w! test.out
*** ../vim-8.0.0432/src/testdir/test78.in	2011-07-15 13:26:22.000000000 +0200
--- src/testdir/test78.in	2017-03-08 22:48:59.304883131 +0100
***************
*** 6,12 ****
  
  STARTTEST
  :so small.vim
! :set nocp fileformat=unix undolevels=-1 viminfo+=nviminfo
  :e! Xtest
  ggdG
  :let text = "\tabcdefghijklmnoparstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnoparstuvwxyz0123456789"
--- 6,12 ----
  
  STARTTEST
  :so small.vim
! :set nocp fileformat=unix undolevels=-1 viminfo+=nviminfo belloff=all
  :e! Xtest
  ggdG
  :let text = "\tabcdefghijklmnoparstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnoparstuvwxyz0123456789"
*** ../vim-8.0.0432/src/testdir/test85.in	2013-04-15 13:12:43.000000000 +0200
--- src/testdir/test85.in	2017-03-08 22:48:59.304883131 +0100
***************
*** 2,7 ****
--- 2,8 ----
  
  STARTTEST
  :so small.vim
+ :set belloff=all
  :so lua.vim
  :set nocompatible viminfo+=nviminfo
  :lua l = vim.list():add"item0":add"dictionary with list OK":add"item2"
*** ../vim-8.0.0432/src/testdir/test94.in	2015-11-21 14:16:35.000000000 +0100
--- src/testdir/test94.in	2017-03-08 22:48:59.304883131 +0100
***************
*** 17,22 ****
--- 17,23 ----
  
  STARTTEST
  :so small.vim
+ :set belloff=all
  :set enc=utf-8 nocp viminfo+=nviminfo
  :
  :" User functions
*** ../vim-8.0.0432/src/testdir/test_alot.vim	2017-03-08 00:01:31.489347798 +0100
--- src/testdir/test_alot.vim	2017-03-08 22:48:59.304883131 +0100
***************
*** 1,6 ****
--- 1,7 ----
  " A series of tests that can run in one Vim invocation.
  " This makes testing go faster, since Vim doesn't need to restart.
  
+ set belloff=all
  source test_assign.vim
  source test_autocmd.vim
  source test_changedtick.vim
*** ../vim-8.0.0432/src/testdir/test_alot_utf8.vim	2017-01-28 13:47:48.518498595 +0100
--- src/testdir/test_alot_utf8.vim	2017-03-08 22:48:59.304883131 +0100
***************
*** 5,10 ****
--- 5,11 ----
  " runtest.vim.  Checking for the multi_byte feature is in the individual
  " files, so that they can be run by themselves.
  
+ set belloff=all
  source test_expr_utf8.vim
  source test_matchadd_conceal_utf8.vim
  source test_regexp_utf8.vim
*** ../vim-8.0.0432/src/testdir/test_close_count.in	2015-01-07 15:33:21.000000000 +0100
--- src/testdir/test_close_count.in	2017-03-08 22:48:59.304883131 +0100
***************
*** 2,7 ****
--- 2,8 ----
  
  STARTTEST
  :so small.vim
+ :set belloff=all
  :let tests = []
  :for i in range(5)
  :new
*** ../vim-8.0.0432/src/testdir/test_cmdline.vim	2017-03-02 23:05:45.545710576 +0100
--- src/testdir/test_cmdline.vim	2017-03-08 22:48:59.304883131 +0100
***************
*** 1,5 ****
--- 1,7 ----
  " Tests for editing the command line.
  
+ set belloff=all
+ 
  func Test_complete_tab()
    call writefile(['testfile'], 'Xtestfile')
    call feedkeys(":e Xtest\t\r", "tx")
*** ../vim-8.0.0432/src/testdir/test_diffmode.vim	2017-03-05 18:02:59.999101021 +0100
--- src/testdir/test_diffmode.vim	2017-03-08 22:48:59.304883131 +0100
***************
*** 1,4 ****
--- 1,5 ----
  " Tests for diff mode
+ set belloff=all
  
  func Test_diff_fold_sync()
    enew!
*** ../vim-8.0.0432/src/testdir/test_digraph.vim	2016-08-18 21:34:47.000000000 +0200
--- src/testdir/test_digraph.vim	2017-03-08 22:48:59.304883131 +0100
***************
*** 3,8 ****
--- 3,9 ----
  if !has("digraphs") || !has("multi_byte")
    finish
  endif
+ set belloff=all
  
  func! Put_Dig(chars)
    exe "norm! o\<c-k>".a:chars
*** ../vim-8.0.0432/src/testdir/test_erasebackword.in	2015-01-30 03:19:14.000000000 +0100
--- src/testdir/test_erasebackword.in	2017-03-08 22:48:59.304883131 +0100
***************
*** 2,7 ****
--- 2,8 ----
  
  STARTTEST
  :so small.vim
+ :set belloff=all
  :so mbyte.vim
  :set encoding=utf-8
  G
*** ../vim-8.0.0432/src/testdir/test_normal.vim	2017-02-01 22:31:45.112052371 +0100
--- src/testdir/test_normal.vim	2017-03-08 22:48:59.304883131 +0100
***************
*** 1,5 ****
--- 1,6 ----
  " Test for various Normal mode commands
  
+ set belloff=all
  func! Setup_NewWindow()
    10new
    call setline(1, range(1,100))
*** ../vim-8.0.0432/src/testdir/test_packadd.vim	2017-02-11 23:00:31.409774572 +0100
--- src/testdir/test_packadd.vim	2017-03-08 22:48:59.304883131 +0100
***************
*** 1,5 ****
--- 1,7 ----
  " Tests for 'packpath' and :packadd
  
+ set belloff=all
+ 
  func SetUp()
    let s:topdir = expand('%:h') . '/Xdir'
    exe 'set packpath=' . s:topdir
*** ../vim-8.0.0432/src/testdir/test_search.vim	2017-03-01 22:17:01.946120304 +0100
--- src/testdir/test_search.vim	2017-03-08 22:48:59.304883131 +0100
***************
*** 1,5 ****
--- 1,6 ----
  " Test for the search command
  
+ set belloff=all
  func Test_search_cmdline()
    if !exists('+incsearch')
      return
*** ../vim-8.0.0432/src/testdir/test_textobjects.vim	2016-07-23 21:55:05.000000000 +0200
--- src/testdir/test_textobjects.vim	2017-03-08 22:48:59.304883131 +0100
***************
*** 4,9 ****
--- 4,10 ----
    finish
  endif
  
+ set belloff=all
  function! CpoM(line, useM, expected)
    new
  
*** ../vim-8.0.0432/src/testdir/test_undo.vim	2017-01-17 22:09:41.310252893 +0100
--- src/testdir/test_undo.vim	2017-03-08 22:48:59.304883131 +0100
***************
*** 3,8 ****
--- 3,9 ----
  " undo-able pieces.  Do that by setting 'undolevels'.
  " Also tests :earlier and :later.
  
+ set belloff=all
  func Test_undotree()
    exe "normal Aabc\<Esc>"
    set ul=100
*** ../vim-8.0.0432/src/testdir/test_usercommands.vim	2017-01-26 22:07:28.518844549 +0100
--- src/testdir/test_usercommands.vim	2017-03-08 22:48:59.304883131 +0100
***************
*** 1,6 ****
--- 1,7 ----
  " Tests for user defined commands
  
  " Test for <mods> in user defined commands
+ set belloff=all
  function Test_cmdmods()
    let g:mods = ''
  
*** ../vim-8.0.0432/src/testdir/test_visual.vim	2017-02-18 23:11:57.345793837 +0100
--- src/testdir/test_visual.vim	2017-03-08 22:48:59.304883131 +0100
***************
*** 3,8 ****
--- 3,10 ----
    finish
  endif
  
+ set belloff=all
+ 
  func Test_block_shift_multibyte()
    " Uses double-wide character.
    if !has('multi_byte')
*** ../vim-8.0.0432/src/version.c	2017-03-08 22:39:46.536941572 +0100
--- src/version.c	2017-03-08 22:52:26.127401427 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     433,
  /**/

-- 
From "know your smileys":
 !-|	I-am-a-Cylon-Centurian-with-one-red-eye-bouncing-back-and-forth

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0434
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0434
Problem:    Clang version not correctly detected.
Solution:   Adjust the configure script. (Kazunobu Kuriyama)
Files:      src/configure.ac, src/auto/configure


*** ../vim-8.0.0433/src/configure.ac	2016-12-09 20:11:22.367819580 +0100
--- src/configure.ac	2017-03-09 11:55:05.842637743 +0100
***************
*** 67,74 ****
  dnl warning when that flag is passed to.  Accordingly, adjust CFLAGS based on
  dnl the version number of the clang in use.
  dnl Note that this does not work to get the version of clang 3.1 or 3.2.
! AC_MSG_CHECKING(for recent clang version)
! CLANG_VERSION_STRING=`$CC --version 2>/dev/null | sed  -n -e 's/^.*clang.*\([[0-9]][[0-9]]*\.[[0-9]][[0-9]]*\.[[0-9]][[0-9]]*\).*$/\1/p'`
  if test x"$CLANG_VERSION_STRING" != x"" ; then
    CLANG_MAJOR=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/\([[0-9]][[0-9]]*\)\.[[0-9]][[0-9]]*\.[[0-9]][[0-9]]*/\1/p'`
    CLANG_MINOR=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/[[0-9]][[0-9]]*\.\([[0-9]][[0-9]]*\)\.[[0-9]][[0-9]]*/\1/p'`
--- 67,74 ----
  dnl warning when that flag is passed to.  Accordingly, adjust CFLAGS based on
  dnl the version number of the clang in use.
  dnl Note that this does not work to get the version of clang 3.1 or 3.2.
! AC_MSG_CHECKING(for clang version)
! CLANG_VERSION_STRING=`$CC --version 2>/dev/null | sed  -n -e 's/^.*clang[[^0-9]]*\([[0-9]][[0-9]]*\.[[0-9]][[0-9]]*\.[[0-9]][[0-9]]*\).*$/\1/p'`
  if test x"$CLANG_VERSION_STRING" != x"" ; then
    CLANG_MAJOR=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/\([[0-9]][[0-9]]*\)\.[[0-9]][[0-9]]*\.[[0-9]][[0-9]]*/\1/p'`
    CLANG_MINOR=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/[[0-9]][[0-9]]*\.\([[0-9]][[0-9]]*\)\.[[0-9]][[0-9]]*/\1/p'`
***************
*** 79,89 ****
    dnl change the constant 500002075 below appropriately.  To get the
    dnl integer corresponding to a version number, refer to the
    dnl definition of CLANG_VERSION above.
    if test "$CLANG_VERSION" -ge 500002075 ; then
!     CFLAGS=`echo "$CFLAGS" | sed -n -e 's/-fno-strength-reduce/ /p'`
    fi
  else
!   AC_MSG_RESULT(no)
  fi
  
  dnl If configure thinks we are cross compiling, there might be something
--- 79,93 ----
    dnl change the constant 500002075 below appropriately.  To get the
    dnl integer corresponding to a version number, refer to the
    dnl definition of CLANG_VERSION above.
+   AC_MSG_CHECKING(if clang supports -fno-strength-reduce)
    if test "$CLANG_VERSION" -ge 500002075 ; then
!     AC_MSG_RESULT(no)
!     CFLAGS=`echo "$CFLAGS" | sed -e 's/-fno-strength-reduce/ /'`
!   else
!     AC_MSG_RESULT(yes)
    fi
  else
!   AC_MSG_RESULT(N/A)
  fi
  
  dnl If configure thinks we are cross compiling, there might be something
***************
*** 3016,3021 ****
--- 3020,3033 ----
  dnl end of GUI-checking
  dnl ---------------------------------------------------------------------------
  
+ AC_MSG_CHECKING([for /proc/self/exe])
+ if test -L "/proc/self/exe"; then
+     AC_MSG_RESULT(yes)
+     AC_DEFINE(HAVE_PROC_SELF_EXE)
+ else
+     AC_MSG_RESULT(no)
+ fi
+ 
  dnl Check for Cygwin, which needs an extra source file if not using X11
  AC_MSG_CHECKING(for CYGWIN or MSYS environment)
  case `uname` in
*** ../vim-8.0.0433/src/auto/configure	2016-12-09 20:11:22.371819553 +0100
--- src/auto/configure	2017-03-09 11:55:10.874602161 +0100
***************
*** 4114,4122 ****
    fi
  fi
  
! { $as_echo "$as_me:${as_lineno-$LINENO}: checking for recent clang version" >&5
! $as_echo_n "checking for recent clang version... " >&6; }
! CLANG_VERSION_STRING=`$CC --version 2>/dev/null | sed  -n -e 's/^.*clang.*\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\).*$/\1/p'`
  if test x"$CLANG_VERSION_STRING" != x"" ; then
    CLANG_MAJOR=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/\([0-9][0-9]*\)\.[0-9][0-9]*\.[0-9][0-9]*/\1/p'`
    CLANG_MINOR=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/[0-9][0-9]*\.\([0-9][0-9]*\)\.[0-9][0-9]*/\1/p'`
--- 4114,4122 ----
    fi
  fi
  
! { $as_echo "$as_me:${as_lineno-$LINENO}: checking for clang version" >&5
! $as_echo_n "checking for clang version... " >&6; }
! CLANG_VERSION_STRING=`$CC --version 2>/dev/null | sed  -n -e 's/^.*clang[^0-9]*\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\).*$/\1/p'`
  if test x"$CLANG_VERSION_STRING" != x"" ; then
    CLANG_MAJOR=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/\([0-9][0-9]*\)\.[0-9][0-9]*\.[0-9][0-9]*/\1/p'`
    CLANG_MINOR=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/[0-9][0-9]*\.\([0-9][0-9]*\)\.[0-9][0-9]*/\1/p'`
***************
*** 4124,4135 ****
    CLANG_VERSION=`expr $CLANG_MAJOR '*' 1000000 '+' $CLANG_MINOR '*' 1000 '+' $CLANG_REVISION`
    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CLANG_VERSION" >&5
  $as_echo "$CLANG_VERSION" >&6; }
!           if test "$CLANG_VERSION" -ge 500002075 ; then
!     CFLAGS=`echo "$CFLAGS" | sed -n -e 's/-fno-strength-reduce/ /p'`
    fi
  else
!   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
! $as_echo "no" >&6; }
  fi
  
  CROSS_COMPILING=
--- 4124,4142 ----
    CLANG_VERSION=`expr $CLANG_MAJOR '*' 1000000 '+' $CLANG_MINOR '*' 1000 '+' $CLANG_REVISION`
    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CLANG_VERSION" >&5
  $as_echo "$CLANG_VERSION" >&6; }
!           { $as_echo "$as_me:${as_lineno-$LINENO}: checking if clang supports -fno-strength-reduce" >&5
! $as_echo_n "checking if clang supports -fno-strength-reduce... " >&6; }
!   if test "$CLANG_VERSION" -ge 500002075 ; then
!     { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
! $as_echo "no" >&6; }
!     CFLAGS=`echo "$CFLAGS" | sed -e 's/-fno-strength-reduce/ /'`
!   else
!     { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
! $as_echo "yes" >&6; }
    fi
  else
!   { $as_echo "$as_me:${as_lineno-$LINENO}: result: N/A" >&5
! $as_echo "N/A" >&6; }
  fi
  
  CROSS_COMPILING=
***************
*** 10094,10099 ****
--- 10101,10118 ----
  
  
  
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for /proc/self/exe" >&5
+ $as_echo_n "checking for /proc/self/exe... " >&6; }
+ if test -L "/proc/self/exe"; then
+     { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+ $as_echo "yes" >&6; }
+     $as_echo "#define HAVE_PROC_SELF_EXE 1" >>confdefs.h
+ 
+ else
+     { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+ $as_echo "no" >&6; }
+ fi
+ 
  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for CYGWIN or MSYS environment" >&5
  $as_echo_n "checking for CYGWIN or MSYS environment... " >&6; }
  case `uname` in
*** ../vim-8.0.0433/src/version.c	2017-03-08 22:55:14.918181192 +0100
--- src/version.c	2017-03-09 11:57:14.797728899 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     434,
  /**/

-- 
From "know your smileys":
 :-O>-o   Smiley American tourist (note big mouth and camera)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0435
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0435
Problem:    Some functions are not tested.
Solution:   Add more tests for functions. (Dominique Pelle, closes #1541)
Files:      src/testdir/test_functions.vim


*** ../vim-8.0.0434/src/testdir/test_functions.vim	2017-03-02 22:47:56.898286649 +0100
--- src/testdir/test_functions.vim	2017-03-09 12:06:09.405990264 +0100
***************
*** 27,32 ****
--- 27,39 ----
    call assert_equal(1, empty(v:false))
    call assert_equal(0, empty(v:true))
  
+   if has('channel')
+     call assert_equal(1, empty(test_null_channel()))
+   endif
+   if has('job')
+     call assert_equal(1, empty(test_null_job()))
+   endif
+ 
    call assert_equal(0, empty(function('Test_empty')))
  endfunc
  
***************
*** 467,472 ****
--- 474,720 ----
    set fileformats&
  endfunc
  
+ func Test_bufexists()
+   call assert_equal(0, bufexists('does_not_exist'))
+   call assert_equal(1, bufexists(bufnr('%')))
+   call assert_equal(0, bufexists(0))
+   new Xfoo
+   let bn = bufnr('%')
+   call assert_equal(1, bufexists(bn))
+   call assert_equal(1, bufexists('Xfoo'))
+   call assert_equal(1, bufexists(getcwd() . '/Xfoo'))
+   call assert_equal(1, bufexists(0))
+   bw
+   call assert_equal(0, bufexists(bn))
+   call assert_equal(0, bufexists('Xfoo'))
+ endfunc
+ 
+ func Test_last_buffer_nr()
+   call assert_equal(bufnr('$'), last_buffer_nr())
+ endfunc
+ 
+ func Test_stridx()
+   call assert_equal(-1, stridx('', 'l'))
+   call assert_equal(0,  stridx('', ''))
+   call assert_equal(0,  stridx('hello', ''))
+   call assert_equal(-1, stridx('hello', 'L'))
+   call assert_equal(2,  stridx('hello', 'l', -1))
+   call assert_equal(2,  stridx('hello', 'l', 0))
+   call assert_equal(2,  stridx('hello', 'l', 1))
+   call assert_equal(3,  stridx('hello', 'l', 3))
+   call assert_equal(-1, stridx('hello', 'l', 4))
+   call assert_equal(-1, stridx('hello', 'l', 10))
+   call assert_equal(2,  stridx('hello', 'll'))
+   call assert_equal(-1, stridx('hello', 'hello world'))
+ endfunc
+ 
+ func Test_strridx()
+   call assert_equal(-1, strridx('', 'l'))
+   call assert_equal(0,  strridx('', ''))
+   call assert_equal(5,  strridx('hello', ''))
+   call assert_equal(-1, strridx('hello', 'L'))
+   call assert_equal(3,  strridx('hello', 'l'))
+   call assert_equal(3,  strridx('hello', 'l', 10))
+   call assert_equal(3,  strridx('hello', 'l', 3))
+   call assert_equal(2,  strridx('hello', 'l', 2))
+   call assert_equal(-1, strridx('hello', 'l', 1))
+   call assert_equal(-1, strridx('hello', 'l', 0))
+   call assert_equal(-1, strridx('hello', 'l', -1))
+   call assert_equal(2,  strridx('hello', 'll'))
+   call assert_equal(-1, strridx('hello', 'hello world'))
+ endfunc
+ 
+ func Test_matchend()
+   call assert_equal(7,  matchend('testing', 'ing'))
+   call assert_equal(7,  matchend('testing', 'ing', 2))
+   call assert_equal(-1, matchend('testing', 'ing', 5))
+ endfunc
+ 
+ func Test_nextnonblank_prevnonblank()
+   new
+ insert
+ This
+ 
+ 
+ is
+ 
+ a
+ Test
+ .
+   call assert_equal(0, nextnonblank(-1))
+   call assert_equal(0, nextnonblank(0))
+   call assert_equal(1, nextnonblank(1))
+   call assert_equal(4, nextnonblank(2))
+   call assert_equal(4, nextnonblank(3))
+   call assert_equal(4, nextnonblank(4))
+   call assert_equal(6, nextnonblank(5))
+   call assert_equal(6, nextnonblank(6))
+   call assert_equal(7, nextnonblank(7))
+   call assert_equal(0, nextnonblank(8))
+ 
+   call assert_equal(0, prevnonblank(-1))
+   call assert_equal(0, prevnonblank(0))
+   call assert_equal(1, prevnonblank(1))
+   call assert_equal(1, prevnonblank(2))
+   call assert_equal(1, prevnonblank(3))
+   call assert_equal(4, prevnonblank(4))
+   call assert_equal(4, prevnonblank(5))
+   call assert_equal(6, prevnonblank(6))
+   call assert_equal(7, prevnonblank(7))
+   call assert_equal(0, prevnonblank(8))
+   bw!
+ endfunc
+ 
+ func Test_byte2line_line2byte()
+   new
+   call setline(1, ['a', 'bc', 'd'])
+ 
+   set fileformat=unix
+   call assert_equal([-1, -1, 1, 1, 2, 2, 2, 3, 3, -1],
+   \                 map(range(-1, 8), 'byte2line(v:val)'))
+   call assert_equal([-1, -1, 1, 3, 6, 8, -1],
+   \                 map(range(-1, 5), 'line2byte(v:val)'))
+ 
+   set fileformat=mac
+   call assert_equal([-1, -1, 1, 1, 2, 2, 2, 3, 3, -1],
+   \                 map(range(-1, 8), 'byte2line(v:val)'))
+   call assert_equal([-1, -1, 1, 3, 6, 8, -1],
+   \                 map(range(-1, 5), 'line2byte(v:val)'))
+ 
+   set fileformat=dos
+   call assert_equal([-1, -1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, -1],
+   \                 map(range(-1, 11), 'byte2line(v:val)'))
+   call assert_equal([-1, -1, 1, 4, 8, 11, -1],
+   \                 map(range(-1, 5), 'line2byte(v:val)'))
+ 
+   set fileformat&
+   bw!
+ endfunc
+ 
+ func Test_count()
+   let l = ['a', 'a', 'A', 'b']
+   call assert_equal(2, count(l, 'a'))
+   call assert_equal(1, count(l, 'A'))
+   call assert_equal(1, count(l, 'b'))
+   call assert_equal(0, count(l, 'B'))
+ 
+   call assert_equal(2, count(l, 'a', 0))
+   call assert_equal(1, count(l, 'A', 0))
+   call assert_equal(1, count(l, 'b', 0))
+   call assert_equal(0, count(l, 'B', 0))
+ 
+   call assert_equal(3, count(l, 'a', 1))
+   call assert_equal(3, count(l, 'A', 1))
+   call assert_equal(1, count(l, 'b', 1))
+   call assert_equal(1, count(l, 'B', 1))
+   call assert_equal(0, count(l, 'c', 1))
+ 
+   call assert_equal(1, count(l, 'a', 0, 1))
+   call assert_equal(2, count(l, 'a', 1, 1))
+   call assert_fails('call count(l, "a", 0, 10)', 'E684:')
+ 
+   let d = {1: 'a', 2: 'a', 3: 'A', 4: 'b'}
+   call assert_equal(2, count(d, 'a'))
+   call assert_equal(1, count(d, 'A'))
+   call assert_equal(1, count(d, 'b'))
+   call assert_equal(0, count(d, 'B'))
+ 
+   call assert_equal(2, count(d, 'a', 0))
+   call assert_equal(1, count(d, 'A', 0))
+   call assert_equal(1, count(d, 'b', 0))
+   call assert_equal(0, count(d, 'B', 0))
+ 
+   call assert_equal(3, count(d, 'a', 1))
+   call assert_equal(3, count(d, 'A', 1))
+   call assert_equal(1, count(d, 'b', 1))
+   call assert_equal(1, count(d, 'B', 1))
+   call assert_equal(0, count(d, 'c', 1))
+ 
+   call assert_fails('call count(d, "a", 0, 1)', 'E474:')
+   call assert_fails('call count("a", "a")', 'E712:')
+ endfunc
+ 
+ func Test_changenr()
+   new Xchangenr
+   call assert_equal(0, changenr())
+   norm ifoo
+   call assert_equal(1, changenr())
+   set undolevels=10
+   norm Sbar
+   call assert_equal(2, changenr())
+   undo
+   call assert_equal(1, changenr())
+   redo
+   call assert_equal(2, changenr())
+   bw!
+   set undolevels&
+ endfunc
+ 
+ func Test_filewritable()
+   new Xfilewritable
+   write!
+   call assert_equal(1, filewritable('Xfilewritable'))
+ 
+   call assert_notequal(0, setfperm('Xfilewritable', 'r--r-----'))
+   call assert_equal(0, filewritable('Xfilewritable'))
+ 
+   call assert_notequal(0, setfperm('Xfilewritable', 'rw-r-----'))
+   call assert_equal(1, filewritable('Xfilewritable'))
+ 
+   call assert_equal(0, filewritable('doesnotexist'))
+ 
+   call delete('Xfilewritable')
+   bw!
+ endfunc
+ 
+ func Test_hostname()
+   let hostname_vim = hostname()
+   if has('unix')
+     let hostname_system = systemlist('uname -n')[0]
+     call assert_equal(hostname_vim, hostname_system)
+   endif
+ endfunc
+ 
+ func Test_getpid()
+   " getpid() always returns the same value within a vim instance.
+   call assert_equal(getpid(), getpid())
+   if has('unix')
+     call assert_equal(systemlist('echo $PPID')[0], string(getpid()))
+   endif
+ endfunc
+ 
+ func Test_hlexists()
+   call assert_equal(0, hlexists('does_not_exist'))
+   call assert_equal(0, hlexists('Number'))
+   call assert_equal(0, highlight_exists('does_not_exist'))
+   call assert_equal(0, highlight_exists('Number'))
+   syntax on
+   call assert_equal(0, hlexists('does_not_exist'))
+   call assert_equal(1, hlexists('Number'))
+   call assert_equal(0, highlight_exists('does_not_exist'))
+   call assert_equal(1, highlight_exists('Number'))
+   syntax off
+ endfunc
+ 
+ func Test_col()
+   new
+   call setline(1, 'abcdef')
+   norm gg4|mx6|mY2|
+   call assert_equal(2, col('.'))
+   call assert_equal(7, col('$'))
+   call assert_equal(4, col("'x"))
+   call assert_equal(6, col("'Y"))
+   call assert_equal(2, col([1, 2]))
+   call assert_equal(7, col([1, '$']))
+ 
+   call assert_equal(0, col(''))
+   call assert_equal(0, col('x'))
+   call assert_equal(0, col([2, '$']))
+   call assert_equal(0, col([1, 100]))
+   call assert_equal(0, col([1]))
+   bw!
+ endfunc
+ 
  func Test_balloon_show()
    if has('balloon_eval')
      " This won't do anything but must not crash either.
*** ../vim-8.0.0434/src/version.c	2017-03-09 11:58:35.445168330 +0100
--- src/version.c	2017-03-09 12:04:00.006899932 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     435,
  /**/

-- 
How many light bulbs does it take to change a person?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0436
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0436
Problem:    Running the options test sometimes resizes the terminal.
Solution:   Clear out t_WS.
Files:      src/testdir/gen_opt_test.vim


*** ../vim-8.0.0435/src/testdir/gen_opt_test.vim	2017-03-08 00:01:31.489347798 +0100
--- src/testdir/gen_opt_test.vim	2017-03-09 12:57:48.372314842 +0100
***************
*** 7,16 ****
--- 7,19 ----
  
  set nomore
  
+ " The terminal size is restored at the end.
+ " Clear out t_WS, we don't want to resize the actual terminal.
  let script = [
        \ 'let save_columns = &columns',
        \ 'let save_lines = &lines',
        \ 'let save_term = &term',
+       \ 'set t_WS=',
        \ ]
  
  /#define p_term
*** ../vim-8.0.0435/src/version.c	2017-03-09 12:09:27.188601005 +0100
--- src/version.c	2017-03-09 12:59:28.035617968 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     436,
  /**/

-- 
In order for something to become clean, something else must become dirty;
but you can get everything dirty without getting anything clean.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0437
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0437
Problem:    The packadd test does not create the symlink correctly and does
            not test the right thing.
Solution:   Create the directory and symlink correctly.
Files:      src/testdir/test_packadd.vim


*** ../vim-8.0.0436/src/testdir/test_packadd.vim	2017-03-08 22:55:14.914181221 +0100
--- src/testdir/test_packadd.vim	2017-03-09 13:57:19.975564600 +0100
***************
*** 71,81 ****
  
  func Test_packadd_symlink_dir()
    if !has('unix')
! 	  return
    endif
    let top2_dir = s:topdir . '/Xdir2'
    let real_dir = s:topdir . '/Xsym'
!   exec "silent !ln -s" real_dir top2_dir
    let &rtp = top2_dir . ',' . top2_dir . '/after'
    let &packpath = &rtp
  
--- 71,82 ----
  
  func Test_packadd_symlink_dir()
    if !has('unix')
!     return
    endif
    let top2_dir = s:topdir . '/Xdir2'
    let real_dir = s:topdir . '/Xsym'
!   call mkdir(real_dir, 'p')
!   exec "silent !ln -s Xsym"  top2_dir
    let &rtp = top2_dir . ',' . top2_dir . '/after'
    let &packpath = &rtp
  
*** ../vim-8.0.0436/src/version.c	2017-03-09 13:54:56.228561435 +0100
--- src/version.c	2017-03-09 13:56:07.084070177 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     437,
  /**/

-- 
You are only young once, but you can stay immature indefinitely.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0438
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0438
Problem:    The fnamemodify test changes 'shell' in a way later tests may not
            be able to use system().
Solution:   Save and restore 'shell'.
Files:      src/testdir/test_fnamemodify.vim


*** ../vim-8.0.0437/src/testdir/test_fnamemodify.vim	2016-03-25 18:39:32.000000000 +0100
--- src/testdir/test_fnamemodify.vim	2017-03-09 13:47:37.579597437 +0100
***************
*** 1,6 ****
--- 1,8 ----
  " Test filename modifiers.
  
  func Test_fnamemodify()
+   let save_home = $HOME
+   let save_shell = &shell
    let $HOME = fnamemodify('.', ':p:h:h')
    set shell=sh
  
***************
*** 39,45 ****
    call assert_equal("'abc\ndef'", fnamemodify("abc\ndef", ':S'))
    set shell=tcsh
    call assert_equal("'abc\\\ndef'",  fnamemodify("abc\ndef", ':S'))
!   set shell&
  endfunc
  
  func Test_expand()
--- 41,49 ----
    call assert_equal("'abc\ndef'", fnamemodify("abc\ndef", ':S'))
    set shell=tcsh
    call assert_equal("'abc\\\ndef'",  fnamemodify("abc\ndef", ':S'))
! 
!   let $HOME = save_home
!   let &shell = save_shell
  endfunc
  
  func Test_expand()
*** ../vim-8.0.0437/src/version.c	2017-03-09 13:57:58.283298820 +0100
--- src/version.c	2017-03-09 13:59:00.066870055 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     438,
  /**/

-- 
From "know your smileys":
 |-P	Reaction to unusually ugly C code

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0439
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0439
Problem:    Using ":%argdel" while the argument list is already empty gives an
            error. (Pavol Juhas)
Solution:   Don't give an error. (closes #1546)
Files:      src/ex_cmds2.c, src/testdir/test_arglist.vim


*** ../vim-8.0.0438/src/ex_cmds2.c	2017-02-05 16:07:50.287087674 +0100
--- src/ex_cmds2.c	2017-03-09 15:45:08.882302314 +0100
***************
*** 2832,2839 ****
  	if (eap->line2 > ARGCOUNT)
  	    eap->line2 = ARGCOUNT;
  	n = eap->line2 - eap->line1 + 1;
! 	if (*eap->arg != NUL || n <= 0)
  	    EMSG(_(e_invarg));
  	else
  	{
  	    for (i = eap->line1; i <= eap->line2; ++i)
--- 2832,2846 ----
  	if (eap->line2 > ARGCOUNT)
  	    eap->line2 = ARGCOUNT;
  	n = eap->line2 - eap->line1 + 1;
! 	if (*eap->arg != NUL)
! 	    /* Can't have both a range and an argument. */
  	    EMSG(_(e_invarg));
+ 	else if (n <= 0)
+ 	{
+ 	    /* Don't give an error for ":%argdel" if the list is empty. */
+ 	    if (eap->line1 != 1 || eap->line2 != 0)
+ 		EMSG(_(e_invrange));
+ 	}
  	else
  	{
  	    for (i = eap->line1; i <= eap->line2; ++i)
*** ../vim-8.0.0438/src/testdir/test_arglist.vim	2016-09-07 20:37:01.000000000 +0200
--- src/testdir/test_arglist.vim	2017-03-09 15:50:26.540057689 +0100
***************
*** 6,11 ****
--- 6,15 ----
    call assert_equal(2, argidx())
    %argdelete
    call assert_equal(0, argidx())
+   " doing it again doesn't result in an error
+   %argdelete
+   call assert_equal(0, argidx())
+   call assert_fails('2argdelete', 'E16:')
  
    args a b c
    call assert_equal(0, argidx())
*** ../vim-8.0.0438/src/version.c	2017-03-09 14:00:23.630289947 +0100
--- src/version.c	2017-03-09 15:48:59.268674220 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     439,
  /**/

-- 
From "know your smileys":
 :-{}	Too much lipstick

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0440
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0440
Problem:    Not enough test coverage in Insert mode.
Solution:   Add lots of tests.  Add test_override(). (Christian Brabandt,
            closes #1521)
Files:      runtime/doc/eval.txt, runtime/doc/usr_41.txt, src/edit.c,
            src/evalfunc.c, src/globals.h,  src/screen.c,
            src/testdir/Make_all.mak, src/testdir/test_cursor_func.vim,
            src/testdir/test_edit.vim, src/testdir/test_search.vim,
            src/testdir/test_assert.vim, src/Makefile, src/testdir/runtest.vim


*** ../vim-8.0.0439/runtime/doc/eval.txt	2017-03-04 14:37:14.649120059 +0100
--- runtime/doc/eval.txt	2017-03-09 17:24:24.028380217 +0100
***************
*** 2359,2365 ****
  test_alloc_fail({id}, {countdown}, {repeat})
  				none	make memory allocation fail
  test_autochdir()		none	enable 'autochdir' during startup
- test_disable_char_avail({expr}) none	test without typeahead
  test_garbagecollect_now()	none	free memory right now for testing
  test_ignore_error({expr})	none	ignore a specific error
  test_null_channel()		Channel	null value for testing
--- 2362,2367 ----
***************
*** 2368,2373 ****
--- 2370,2376 ----
  test_null_list()		List	null value for testing
  test_null_partial()		Funcref	null value for testing
  test_null_string()		String	null value for testing
+ test_override({expr}, {val})    none	test with Vim internal overrides
  test_settime({expr})		none	set current time for testing
  timer_info([{id}])		List	information about timers
  timer_pause({id}, {pause})	none	pause or unpause a timer
***************
*** 7826,7835 ****
--- 7834,7857 ----
  test_null_string()					*test_null_string()*
  		Return a String that is null. Only useful for testing.
  
+ test_override({name}, {val})				*test_override()*
+ 		Overrides certain parts of Vims internal processing to be able
+ 		to run tests. Only to be used for testing Vim!
+ 		The override is enabled when {val} is non-zero and removed
+ 		when {val} is zero.
+ 		Current supported values for name are: 
+ 
+ 		name	     effect when {val} is non-zero ~
+ 		redraw       disable the redrawing() function
+ 		char_avail   disable the char_avail() function
+ 		ALL	     clear all overrides ({val} is not used)
+ 
  test_settime({expr})					*test_settime()*
  		Set the time Vim uses internally.  Currently only used for
  		timestamps in the history, as they are used in viminfo, and
  		for undo.
+ 		Using a value of 1 makes Vim not sleep after a warning or
+ 		error message.
  		{expr} must evaluate to a number.  When the value is zero the
  		normal behavior is restored.
  
*** ../vim-8.0.0439/runtime/doc/usr_41.txt	2017-01-28 15:58:45.340197300 +0100
--- runtime/doc/usr_41.txt	2017-03-09 17:25:18.443999746 +0100
***************
*** 95,101 ****
  to the same variable.
  
  The example was given to explain the commands, but would you really want to
! make such a loop it can be written much more compact: >
  
  	:for i in range(1, 4)
  	:  echo "count is" i
--- 95,101 ----
  to the same variable.
  
  The example was given to explain the commands, but would you really want to
! make such a loop, it can be written much more compact: >
  
  	:for i in range(1, 4)
  	:  echo "count is" i
***************
*** 693,698 ****
--- 693,699 ----
  Variables:						*var-functions*
  	type()			type of a variable
  	islocked()		check if a variable is locked
+ 	funcref()		get a Funcref for a function reference
  	function()		get a Funcref for a function name
  	getbufvar()		get a variable value from a specific buffer
  	setbufvar()		set a variable in a specific buffer
***************
*** 884,889 ****
--- 885,891 ----
  	getfontname()		get name of current font being used
  	getwinposx()		X position of the GUI Vim window
  	getwinposy()		Y position of the GUI Vim window
+ 	balloon_show()		set the balloon content
  
  Vim server:					*server-functions*
  	serverlist()		return the list of server names
***************
*** 920,933 ****
  	assert_fails()		assert that a function call fails
  	test_alloc_fail()	make memory allocation fail
  	test_autochdir()	enable 'autochdir' during startup
! 	test_disable_char_avail()	test without typeahead
! 	test_garbagecollect_now()	free memory right now
  	test_null_channel()	return a null Channel
  	test_null_dict()	return a null Dict
  	test_null_job()		return a null Job
  	test_null_list()	return a null List
  	test_null_partial()	return a null Partial function
  	test_null_string()	return a null String
  
  Inter-process communication:		    *channel-functions*
  	ch_canread()		check if there is something to read
--- 922,937 ----
  	assert_fails()		assert that a function call fails
  	test_alloc_fail()	make memory allocation fail
  	test_autochdir()	enable 'autochdir' during startup
! 	test_override()		test with Vim internal overrides
! 	test_garbagecollect_now()   free memory right now
! 	test_ignore_error()	ignore a specific error message
  	test_null_channel()	return a null Channel
  	test_null_dict()	return a null Dict
  	test_null_job()		return a null Job
  	test_null_list()	return a null List
  	test_null_partial()	return a null Partial function
  	test_null_string()	return a null String
+ 	test_settime()		set the time Vim uses internally
  
  Inter-process communication:		    *channel-functions*
  	ch_canread()		check if there is something to read
*** ../vim-8.0.0439/src/edit.c	2017-03-05 21:18:21.877452188 +0100
--- src/edit.c	2017-03-09 17:17:07.567436001 +0100
***************
*** 2262,2268 ****
  	    vim_beep(BO_COMPL);
  	    setcursor();
  	    out_flush();
! 	    ui_delay(2000L, FALSE);
  	}
  	return FALSE;
      }
--- 2262,2271 ----
  	    vim_beep(BO_COMPL);
  	    setcursor();
  	    out_flush();
! #ifdef FEAT_EVAL
! 	    if (!get_vim_var_nr(VV_TESTING))
! #endif
! 		ui_delay(2000L, FALSE);
  	}
  	return FALSE;
      }
*** ../vim-8.0.0439/src/evalfunc.c	2017-03-02 22:11:28.479904237 +0100
--- src/evalfunc.c	2017-03-09 17:31:09.317546022 +0100
***************
*** 390,396 ****
  static void f_tempname(typval_T *argvars, typval_T *rettv);
  static void f_test_alloc_fail(typval_T *argvars, typval_T *rettv);
  static void f_test_autochdir(typval_T *argvars, typval_T *rettv);
! static void f_test_disable_char_avail(typval_T *argvars, typval_T *rettv);
  static void f_test_garbagecollect_now(typval_T *argvars, typval_T *rettv);
  static void f_test_ignore_error(typval_T *argvars, typval_T *rettv);
  #ifdef FEAT_JOB_CHANNEL
--- 390,396 ----
  static void f_tempname(typval_T *argvars, typval_T *rettv);
  static void f_test_alloc_fail(typval_T *argvars, typval_T *rettv);
  static void f_test_autochdir(typval_T *argvars, typval_T *rettv);
! static void f_test_override(typval_T *argvars, typval_T *rettv);
  static void f_test_garbagecollect_now(typval_T *argvars, typval_T *rettv);
  static void f_test_ignore_error(typval_T *argvars, typval_T *rettv);
  #ifdef FEAT_JOB_CHANNEL
***************
*** 828,834 ****
      {"tempname",	0, 0, f_tempname},
      {"test_alloc_fail",	3, 3, f_test_alloc_fail},
      {"test_autochdir",	0, 0, f_test_autochdir},
-     {"test_disable_char_avail", 1, 1, f_test_disable_char_avail},
      {"test_garbagecollect_now",	0, 0, f_test_garbagecollect_now},
      {"test_ignore_error",	1, 1, f_test_ignore_error},
  #ifdef FEAT_JOB_CHANNEL
--- 828,833 ----
***************
*** 841,846 ****
--- 840,846 ----
      {"test_null_list",	0, 0, f_test_null_list},
      {"test_null_partial", 0, 0, f_test_null_partial},
      {"test_null_string", 0, 0, f_test_null_string},
+     {"test_override",    2, 2, f_test_override},
      {"test_settime",	1, 1, f_test_settime},
  #ifdef FEAT_TIMERS
      {"timer_info",	0, 1, f_timer_info},
***************
*** 12326,12337 ****
  }
  
  /*
!  * "test_disable_char_avail({expr})" function
   */
      static void
! f_test_disable_char_avail(typval_T *argvars, typval_T *rettv UNUSED)
  {
!     disable_char_avail_for_testing = (int)get_tv_number(&argvars[0]);
  }
  
  /*
--- 12326,12359 ----
  }
  
  /*
!  * "test_disable({name}, {val})" function
   */
      static void
! f_test_override(typval_T *argvars, typval_T *rettv UNUSED)
  {
!     char_u *name = (char_u *)"";
!     int     val;
! 
!     if (argvars[0].v_type != VAR_STRING
! 	    || (argvars[1].v_type) != VAR_NUMBER)
! 	EMSG(_(e_invarg));
!     else
!     {
! 	name = get_tv_string_chk(&argvars[0]);
! 	val = (int)get_tv_number(&argvars[1]);
! 
! 	if (STRCMP(name, (char_u *)"redraw") == 0)
! 	    disable_redraw_for_testing = val;
! 	else if (STRCMP(name, (char_u *)"char_avail") == 0)
! 	    disable_char_avail_for_testing = val;
! 	else if (STRCMP(name, (char_u *)"ALL") == 0)
! 	{
! 	    disable_char_avail_for_testing = FALSE;
! 	    disable_redraw_for_testing = FALSE;
! 	}
! 	else
! 	    EMSG2(_(e_invarg2), name);
!     }
  }
  
  /*
*** ../vim-8.0.0439/src/globals.h	2017-02-17 16:31:16.921294136 +0100
--- src/globals.h	2017-03-09 17:38:48.158336203 +0100
***************
*** 1648,1654 ****
--- 1648,1656 ----
  /* set by alloc_fail(), number of times alloc() returns NULL */
  EXTERN int  alloc_fail_repeat INIT(= 0);
  
+ /* flags set by test_override() */
  EXTERN int  disable_char_avail_for_testing INIT(= 0);
+ EXTERN int  disable_redraw_for_testing INIT(= 0);
  
  EXTERN int  in_free_unref_items INIT(= FALSE);
  #endif
*** ../vim-8.0.0439/src/screen.c	2017-03-01 18:04:01.575277654 +0100
--- src/screen.c	2017-03-09 17:17:07.575435945 +0100
***************
*** 10580,10586 ****
      int
  redrawing(void)
  {
!     return (!RedrawingDisabled
  		       && !(p_lz && char_avail() && !KeyTyped && !do_redraw));
  }
  
--- 10580,10591 ----
      int
  redrawing(void)
  {
! #ifdef FEAT_EVAL
!     if (disable_redraw_for_testing)
! 	return 0;
!     else
! #endif
! 	return (!RedrawingDisabled
  		       && !(p_lz && char_avail() && !KeyTyped && !do_redraw));
  }
  
*** ../vim-8.0.0439/src/testdir/Make_all.mak	2017-03-08 00:01:31.489347798 +0100
--- src/testdir/Make_all.mak	2017-03-09 17:17:07.575435945 +0100
***************
*** 151,156 ****
--- 151,157 ----
  	    test_diffmode.res \
  	    test_digraph.res \
  	    test_display.res \
+ 	    test_edit.res \
  	    test_farsi.res \
  	    test_fnameescape.res \
  	    test_fold.res \
*** ../vim-8.0.0439/src/testdir/test_cursor_func.vim	2016-05-25 20:53:31.000000000 +0200
--- src/testdir/test_cursor_func.vim	2017-03-09 17:17:07.575435945 +0100
***************
*** 44,52 ****
    new
    call setline(1, ['func()', '{', '}', '----'])
    autocmd! CursorMovedI * call s:Highlight_Matching_Pair()
!   call test_disable_char_avail(1)
    exe "normal! 3Ga\<Down>X\<Esc>"
!   call test_disable_char_avail(0)
    call assert_equal('-X---', getline(4))
    autocmd! CursorMovedI *
    quit!
--- 44,52 ----
    new
    call setline(1, ['func()', '{', '}', '----'])
    autocmd! CursorMovedI * call s:Highlight_Matching_Pair()
!   call test_override("char_avail", 1)
    exe "normal! 3Ga\<Down>X\<Esc>"
!   call test_override("char_avail", 0)
    call assert_equal('-X---', getline(4))
    autocmd! CursorMovedI *
    quit!
*** ../vim-8.0.0439/src/testdir/test_edit.vim	2017-03-09 18:17:36.874092334 +0100
--- src/testdir/test_edit.vim	2017-03-09 17:17:07.575435945 +0100
***************
*** 0 ****
--- 1,1324 ----
+ " Test for edit functions
+ "
+ if exists("+t_kD")
+   let &t_kD="[3;*~"
+ endif
+ set belloff=
+ 
+ " Needed for testing basic rightleft: Test_edit_rightleft
+ source view_util.vim
+ 
+ " Needs to come first until the bug in getchar() is
+ " fixed: https://groups.google.com/d/msg/vim_dev/fXL9yme4H4c/bOR-U6_bAQAJ
+ func! Test_edit_00b()
+   new
+   call setline(1, ['abc '])
+   inoreabbr <buffer> h here some more
+   call cursor(1, 4)
+   " <c-l> expands the abbreviation and ends insertmode
+   call feedkeys(":set im\<cr> h\<c-l>:set noim\<cr>", 'tix')
+   call assert_equal(['abc here some more '], getline(1,'$'))
+   iunabbr <buffer> h
+   bw!
+ endfunc
+ 
+ func! Test_edit_01()
+   " set for Travis CI?
+   "  set nocp noesckeys
+   new
+   set belloff=backspace
+   " 1) empty buffer
+   call assert_equal([''], getline(1,'$'))
+   " 2) delete in an empty line
+   call feedkeys("i\<del>\<esc>", 'tnix')
+   call assert_equal([''], getline(1,'$'))
+   %d
+   " 3) delete one character
+   call setline(1, 'a')
+   call feedkeys("i\<del>\<esc>", 'tnix')
+   call assert_equal([''], getline(1,'$'))
+   %d
+   " 4) delete a multibyte character
+   if has("multi_byte")
+     call setline(1, "\u0401")
+     call feedkeys("i\<del>\<esc>", 'tnix')
+     call assert_equal([''], getline(1,'$'))
+     %d
+   endif
+   " 5.1) delete linebreak with 'bs' option containing eol
+   let _bs=&bs
+   set bs=eol
+   call setline(1, ["abc def", "ghi jkl"])
+   call cursor(1, 1)
+   call feedkeys("A\<del>\<esc>", 'tnix')
+   call assert_equal(['abc defghi jkl'], getline(1, 2))
+   %d
+   " 5.2) delete linebreak with backspace option w/out eol
+   set bs=
+   call setline(1, ["abc def", "ghi jkl"])
+   call cursor(1, 1)
+   call feedkeys("A\<del>\<esc>", 'tnix')
+   call assert_equal(["abc def", "ghi jkl"], getline(1, 2))
+   set belloff=
+   let &bs=_bs
+   bw!
+ endfunc
+ 
+ func! Test_edit_02()
+   " Change cursor position in InsertCharPre command
+   new
+   call setline(1, 'abc')
+   call cursor(1, 1)
+   fu! DoIt(...)
+     call cursor(1, 4)
+     if len(a:000)
+       let v:char=a:1
+     endif
+   endfu
+   au InsertCharPre <buffer> :call DoIt('y')
+   call feedkeys("ix\<esc>", 'tnix')
+   call assert_equal(['abcy'], getline(1, '$'))
+   " Setting <Enter> in InsertCharPre
+   au! InsertCharPre <buffer> :call DoIt("\n")
+   call setline(1, 'abc')
+   call cursor(1, 1)
+   call feedkeys("ix\<esc>", 'tnix')
+   call assert_equal(['abc', ''], getline(1, '$'))
+   %d
+   au! InsertCharPre
+   " Change cursor position in InsertEnter command
+   " 1) when setting v:char, keeps changed cursor position
+   au! InsertEnter <buffer> :call DoIt('y')
+   call setline(1, 'abc')
+   call cursor(1, 1)
+   call feedkeys("ix\<esc>", 'tnix')
+   call assert_equal(['abxc'], getline(1, '$'))
+   " 2) when not setting v:char, restores changed cursor position
+   au! InsertEnter <buffer> :call DoIt()
+   call setline(1, 'abc')
+   call cursor(1, 1)
+   call feedkeys("ix\<esc>", 'tnix')
+   call assert_equal(['xabc'], getline(1, '$'))
+   au! InsertEnter
+   delfu DoIt
+   bw!
+ endfunc
+ 
+ func! Test_edit_03()
+   " Change cursor after <c-o> command to end of line
+   new
+   call setline(1, 'abc')
+   call cursor(1, 1)
+   call feedkeys("i\<c-o>$y\<esc>", 'tnix')
+   call assert_equal(['abcy'], getline(1, '$'))
+   %d
+   call setline(1, 'abc')
+   call cursor(1, 1)
+   call feedkeys("i\<c-o>80|y\<esc>", 'tnix')
+   call assert_equal(['abcy'], getline(1, '$'))
+   %d
+   call setline(1, 'abc')
+   call feedkeys("Ad\<c-o>:s/$/efg/\<cr>hij", 'tnix')
+   call assert_equal(['hijabcdefg'], getline(1, '$'))
+   bw!
+ endfunc
+ 
+ func! Test_edit_04()
+   " test for :stopinsert
+   new
+   call setline(1, 'abc')
+   call cursor(1, 1)
+   call feedkeys("i\<c-o>:stopinsert\<cr>$", 'tnix')
+   call feedkeys("aX\<esc>", 'tnix')
+   call assert_equal(['abcX'], getline(1, '$'))
+   %d
+   bw!
+ endfunc
+ 
+ func! Test_edit_05()
+   " test for folds being opened
+   new
+   call setline(1, ['abcX', 'abcX', 'zzzZ'])
+   call cursor(1, 1)
+   set foldmethod=manual foldopen+=insert
+   " create fold for those two lines
+   norm! Vjzf
+   call feedkeys("$ay\<esc>", 'tnix')
+   call assert_equal(['abcXy', 'abcX', 'zzzZ'], getline(1, '$'))
+   %d
+   call setline(1, ['abcX', 'abcX', 'zzzZ'])
+   call cursor(1, 1)
+   set foldmethod=manual foldopen-=insert
+   " create fold for those two lines
+   norm! Vjzf
+   call feedkeys("$ay\<esc>", 'tnix')
+   call assert_equal(['abcXy', 'abcX', 'zzzZ'], getline(1, '$'))
+   %d
+   bw!
+ endfunc
+ 
+ func! Test_edit_06()
+   " Test in diff mode
+   if !has("diff") || !executable("diff")
+     return
+   endif
+   new
+   call setline(1, ['abc', 'xxx', 'yyy'])
+   vnew
+   call setline(1, ['abc', 'zzz', 'xxx', 'yyy'])
+   wincmd p
+   diffthis
+   wincmd p
+   diffthis
+   wincmd p
+   call cursor(2, 1)
+   norm! zt
+   call feedkeys("Ozzz\<esc>", 'tnix')
+   call assert_equal(['abc', 'zzz', 'xxx', 'yyy'], getline(1,'$'))
+   bw!
+   bw!
+ endfunc
+ 
+ func! Test_edit_07()
+   " 1) Test with completion <c-l> when popupmenu is visible
+   new
+   call setline(1, 'J')
+ 
+   func! ListMonths()
+     call complete(col('.')-1, ['January', 'February', 'March',
+     \ 'April', 'May', 'June', 'July', 'August', 'September',
+     \ 'October', 'November', 'December'])
+     return ''
+   endfunc
+   inoremap <buffer> <F5> <C-R>=ListMonths()<CR>
+ 
+   call feedkeys("A\<f5>\<c-p>". repeat("\<down>", 6)."\<c-l>\<down>\<c-l>\<cr>", 'tx')
+   call assert_equal(['July'], getline(1,'$'))
+   " 1) Test completion when InsertCharPre kicks in
+   %d
+   call setline(1, 'J')
+   fu! DoIt()
+     if v:char=='u'
+       let v:char='an'
+     endif
+   endfu
+   au InsertCharPre <buffer> :call DoIt()
+   call feedkeys("A\<f5>\<c-p>u\<cr>\<c-l>\<cr>", 'tx')
+   call assert_equal(["Jan\<c-l>",''], getline(1,'$'))
+   %d
+   call setline(1, 'J')
+   call feedkeys("A\<f5>\<c-p>u\<down>\<c-l>\<cr>", 'tx')
+   call assert_equal(["January"], getline(1,'$'))
+ 
+   delfu ListMonths
+   delfu DoIt
+   iunmap <buffer> <f5>
+   bw!
+ endfunc
+ 
+ func! Test_edit_08()
+   " reset insertmode from i_ctrl-r_=
+   new
+   call setline(1, ['abc'])
+   call cursor(1, 4)
+   call feedkeys(":set im\<cr>ZZZ\<c-r>=setbufvar(1,'&im', 0)\<cr>",'tnix')
+   call assert_equal(['abZZZc'], getline(1,'$'))
+   call assert_equal([0, 1, 1, 0], getpos('.'))
+   call assert_false(0, '&im')
+   bw!
+ endfunc
+ 
+ func! Test_edit_09()
+   " test i_CTRL-\ combinations
+   new
+   call setline(1, ['abc', 'def', 'ghi'])
+   call cursor(1, 1)
+   " 1) CTRL-\ CTLR-N
+   call feedkeys(":set im\<cr>\<c-\>\<c-n>ccABC\<c-l>", 'txin')
+   call assert_equal(['ABC', 'def', 'ghi'], getline(1,'$'))
+   call setline(1, ['ABC', 'def', 'ghi'])
+   " 2) CTRL-\ CTLR-G
+   call feedkeys("j0\<c-\>\<c-g>ZZZ\<cr>\<c-l>", 'txin')
+   call assert_equal(['ABC', 'ZZZ', 'def', 'ghi'], getline(1,'$'))
+   call feedkeys("I\<c-\>\<c-g>YYY\<c-l>", 'txin')
+   call assert_equal(['ABC', 'ZZZ', 'YYYdef', 'ghi'], getline(1,'$'))
+   set noinsertmode
+   " 3) CTRL-\ CTRL-O
+   call setline(1, ['ABC', 'ZZZ', 'def', 'ghi'])
+   call cursor(1, 1)
+   call feedkeys("A\<c-o>ix", 'txin')
+   call assert_equal(['ABxC', 'ZZZ', 'def', 'ghi'], getline(1,'$'))
+   call feedkeys("A\<c-\>\<c-o>ix", 'txin')
+   call assert_equal(['ABxCx', 'ZZZ', 'def', 'ghi'], getline(1,'$'))
+   " 4) CTRL-\ a (should be inserted literally, not special after <c-\>
+   call setline(1, ['ABC', 'ZZZ', 'def', 'ghi'])
+   call cursor(1, 1)
+   call feedkeys("A\<c-\>a", 'txin')
+   call assert_equal(["ABC\<c-\>a", 'ZZZ', 'def', 'ghi'], getline(1, '$'))
+   bw!
+ endfunc
+ 
+ func! Test_edit_10()
+   " Test for starting selectmode
+   new
+   set selectmode=key keymodel=startsel
+   call setline(1, ['abc', 'def', 'ghi'])
+   call cursor(1, 4)
+   call feedkeys("A\<s-home>start\<esc>", 'txin')
+   call assert_equal(['startdef', 'ghi'], getline(1, '$'))
+   set selectmode= keymodel=
+   bw!
+ endfunc
+ 
+ func! Test_edit_11()
+   " Test that indenting kicks in
+   new
+   set cindent
+   call setline(1, ['{', '', ''])
+   call cursor(2, 1)
+   call feedkeys("i\<c-f>int c;\<esc>", 'tnix')
+   call cursor(3, 1)
+   call feedkeys("i/* comment */", 'tnix')
+   call assert_equal(['{', "\<tab>int c;", "/* comment */"], getline(1, '$'))
+   " added changed cindentkeys slightly
+   set cindent cinkeys+=*/
+   call setline(1, ['{', '', ''])
+   call cursor(2, 1)
+   call feedkeys("i\<c-f>int c;\<esc>", 'tnix')
+   call cursor(3, 1)
+   call feedkeys("i/* comment */", 'tnix')
+   call assert_equal(['{', "\<tab>int c;", "\<tab>/* comment */"], getline(1, '$'))
+   set cindent cinkeys+==end
+   call feedkeys("oend\<cr>\<esc>", 'tnix')
+   call assert_equal(['{', "\<tab>int c;", "\<tab>/* comment */", "\tend", ''], getline(1, '$'))
+   set cinkeys-==end
+   %d
+   " Use indentexpr instead of cindenting
+   func! Do_Indent()
+     if v:lnum == 3
+       return 3*shiftwidth()
+     else
+       return 2*shiftwidth()
+     endif
+   endfunc
+   setl indentexpr=Do_Indent() indentkeys+=*/
+   call setline(1, ['{', '', ''])
+   call cursor(2, 1)
+   call feedkeys("i\<c-f>int c;\<esc>", 'tnix')
+   call cursor(3, 1)
+   call feedkeys("i/* comment */", 'tnix')
+   call assert_equal(['{', "\<tab>\<tab>int c;", "\<tab>\<tab>\<tab>/* comment */"], getline(1, '$'))
+   set cinkeys&vim indentkeys&vim
+   set nocindent indentexpr=
+   delfu Do_Indent
+   bw!
+ endfunc
+ 
+ func! Test_edit_12()
+   " Test changing indent in replace mode
+   new
+   call setline(1, ["\tabc", "\tdef"])
+   call cursor(2, 4)
+   call feedkeys("R^\<c-d>", 'tnix')
+   call assert_equal(["\tabc", "def"], getline(1, '$'))
+   call assert_equal([0, 2, 2, 0], getpos('.'))
+   %d
+   call setline(1, ["\tabc", "\t\tdef"])
+   call cursor(2, 2)
+   call feedkeys("R^\<c-d>", 'tnix')
+   call assert_equal(["\tabc", "def"], getline(1, '$'))
+   call assert_equal([0, 2, 1, 0], getpos('.'))
+   %d
+   call setline(1, ["\tabc", "\t\tdef"])
+   call cursor(2, 2)
+   call feedkeys("R\<c-t>", 'tnix')
+   call assert_equal(["\tabc", "\t\t\tdef"], getline(1, '$'))
+   call assert_equal([0, 2, 2, 0], getpos('.'))
+   bw!
+   10vnew
+   call setline(1, ["\tabc", "\t\tdef"])
+   call cursor(2, 2)
+   call feedkeys("R\<c-t>", 'tnix')
+   call assert_equal(["\tabc", "\t\t\tdef"], getline(1, '$'))
+   call assert_equal([0, 2, 2, 0], getpos('.'))
+   %d
+   set sw=4
+   call setline(1, ["\tabc", "\t\tdef"])
+   call cursor(2, 2)
+   call feedkeys("R\<c-t>\<c-t>", 'tnix')
+   call assert_equal(["\tabc", "\t\t\tdef"], getline(1, '$'))
+   call assert_equal([0, 2, 2, 0], getpos('.'))
+   %d
+   call setline(1, ["\tabc", "\t\tdef"])
+   call cursor(2, 2)
+   call feedkeys("R\<c-t>\<c-t>", 'tnix')
+   call assert_equal(["\tabc", "\t\t\tdef"], getline(1, '$'))
+   call assert_equal([0, 2, 2, 0], getpos('.'))
+   set et
+   set sw& et&
+   %d
+   call setline(1, ["\t/*"])
+   set formatoptions=croql
+   call cursor(1, 3)
+   call feedkeys("A\<cr>\<cr>/", 'tnix')
+   call assert_equal(["\t/*", " *", " */"], getline(1, '$'))
+   set formatoptions&
+   bw!
+ endfunc
+ 
+ func! Test_edit_13()
+   " Test smartindenting
+   if exists("+smartindent")
+     new
+     set smartindent autoindent
+     call setline(1, ["\tabc"])
+     call feedkeys("A {\<cr>more\<cr>}\<esc>", 'tnix')
+     call assert_equal(["\tabc {", "\t\tmore", "\t}"], getline(1, '$'))
+     set smartindent& autoindent&
+     bw!
+   endif
+ endfunc
+ 
+ func! Test_edit_CR()
+   " Test for <CR> in insert mode
+   " basically only in quickfix mode ist tested, the rest
+   " has been taken care of by other tests
+   if !has("quickfix")
+     return
+   endif
+   botright new
+   call writefile(range(1, 10), 'Xqflist.txt')
+   call setqflist([{'filename': 'Xqflist.txt', 'lnum': 2}])
+   copen
+   set modifiable
+   call feedkeys("A\<cr>", 'tnix')
+   call assert_equal('Xqflist.txt', bufname(''))
+   call assert_equal(2, line('.'))
+   cclose
+   botright new
+   call setloclist(0, [{'filename': 'Xqflist.txt', 'lnum': 10}])
+   lopen
+   set modifiable
+   call feedkeys("A\<cr>", 'tnix')
+   call assert_equal('Xqflist.txt', bufname(''))
+   call assert_equal(10, line('.'))
+   call feedkeys("A\<Enter>", 'tnix')
+   call feedkeys("A\<kEnter>", 'tnix')
+   call feedkeys("A\n", 'tnix')
+   call feedkeys("A\r", 'tnix')
+   call assert_equal(map(range(1, 10), 'string(v:val)') + ['', '', '', ''], getline(1, '$'))
+   bw!
+   lclose
+   call delete('Xqflist.txt')
+ endfunc
+ 
+ func! Test_edit_CTRL_()
+   " disabled for Windows builds, why?
+   if !has("multi_byte") || !has("rightleft") || has("win32")
+     return
+   endif
+   let _encoding=&encoding
+   set encoding=utf-8
+   " Test for CTRL-_
+   new
+   call setline(1, ['abc'])
+   call cursor(1, 1)
+   call feedkeys("i\<c-_>xyz\<esc>", 'tnix')
+   call assert_equal(["\<C-_>xyzabc"], getline(1, '$'))
+   call assert_false(&revins)
+   set ari
+   call setline(1, ['abc'])
+   call cursor(1, 1)
+   call feedkeys("i\<c-_>xyz\<esc>", 'tnix')
+   call assert_equal(["abc"], getline(1, '$'))
+   call assert_true(&revins)
+   call setline(1, ['abc'])
+   call cursor(1, 1)
+   call feedkeys("i\<c-_>xyz\<esc>", 'tnix')
+   call assert_equal(["xyzabc"], getline(1, '$'))
+   call assert_false(&revins)
+   set noari
+   let &encoding=_encoding
+   bw!
+ endfunc
+ 
+ " needs to come first, to have the @. register empty
+ func! Test_edit_00a_CTRL_A()
+   " Test pressing CTRL-A
+   new
+   call setline(1, repeat([''], 5))
+   call cursor(1, 1)
+   set belloff=all
+   try
+     call feedkeys("A\<NUL>", 'tnix')
+   catch /^Vim\%((\a\+)\)\=:E29/
+     call assert_true(1, 'E29 error caught')
+   endtry
+   set belloff=
+   call cursor(1, 1)
+   call feedkeys("Afoobar \<esc>", 'tnix')
+   call cursor(2, 1)
+   call feedkeys("A\<c-a>more\<esc>", 'tnix')
+   call cursor(3, 1)
+   call feedkeys("A\<NUL>and more\<esc>", 'tnix')
+   call assert_equal(['foobar ', 'foobar more', 'foobar morend more', '', ''], getline(1, '$'))
+   bw!
+ endfunc
+ 
+ func! Test_edit_CTRL_EY()
+   " Ctrl-E/ Ctrl-Y in insert mode completion to scroll
+   10new
+   call setline(1, range(1, 100))
+   call cursor(30, 1)
+   norm! z.
+   call feedkeys("A\<c-x>\<c-e>\<c-e>\<c-e>\<c-e>\<c-e>", 'tnix')
+   call assert_equal(30, winsaveview()['topline'])
+   call assert_equal([0, 30, 2, 0], getpos('.'))
+   call feedkeys("A\<c-x>\<c-e>\<c-e>\<c-e>\<c-e>\<c-e>", 'tnix')
+   call feedkeys("A\<c-x>".repeat("\<c-y>", 10), 'tnix')
+   call assert_equal(21, winsaveview()['topline'])
+   call assert_equal([0, 30, 2, 0], getpos('.'))
+   bw!
+ endfunc
+ 
+ func! Test_edit_CTRL_G()
+   new
+   set belloff=all
+   call setline(1, ['foobar', 'foobar', 'foobar'])
+   call cursor(2, 4)
+   call feedkeys("ioooooooo\<c-g>k\<c-r>.\<esc>", 'tnix')
+   call assert_equal(['foooooooooobar', 'foooooooooobar', 'foobar'], getline(1, '$'))
+   call assert_equal([0, 1, 11, 0], getpos('.'))
+   call feedkeys("i\<c-g>k\<esc>", 'tnix')
+   call assert_equal([0, 1, 10, 0], getpos('.'))
+   call cursor(2, 4)
+   call feedkeys("i\<c-g>jzzzz\<esc>", 'tnix')
+   call assert_equal(['foooooooooobar', 'foooooooooobar', 'foozzzzbar'], getline(1, '$'))
+   call assert_equal([0, 3, 7, 0], getpos('.'))
+   call feedkeys("i\<c-g>j\<esc>", 'tnix')
+   call assert_equal([0, 3, 6, 0], getpos('.'))
+   set belloff=
+   bw!
+ endfunc
+ 
+ func! Test_edit_CTRL_I()
+   " Tab in completion mode
+   let path=expand("%:p:h")
+   new
+   call setline(1, [path."/", ''])
+   call feedkeys("Ate\<c-x>\<c-f>\<tab>\<cr>\<esc>", 'tnix')
+   call assert_match('test1\.in', getline(1))
+   %d
+   call writefile(['one', 'two', 'three'], 'Xinclude.txt')
+   let include='#include Xinclude.txt'
+   call setline(1, [include, ''])
+   call cursor(2, 1)
+   call feedkeys("A\<c-x>\<tab>\<cr>\<esc>", 'tnix')
+   call assert_equal([include, 'one', ''], getline(1, '$'))
+   call feedkeys("2ggC\<c-x>\<tab>\<down>\<cr>\<esc>", 'tnix')
+   call assert_equal([include, 'two', ''], getline(1, '$'))
+   call feedkeys("2ggC\<c-x>\<tab>\<down>\<down>\<cr>\<esc>", 'tnix')
+   call assert_equal([include, 'three', ''], getline(1, '$'))
+   call feedkeys("2ggC\<c-x>\<tab>\<down>\<down>\<down>\<cr>\<esc>", 'tnix')
+   call assert_equal([include, '', ''], getline(1, '$'))
+   call delete("Xinclude.txt")
+   bw!
+ endfunc
+ 
+ func! Test_edit_CTRL_K()
+   " Test pressing CTRL-K (basically only dictionary completion and digraphs
+   " the rest is already covered
+   call writefile(['A', 'AA', 'AAA', 'AAAA'], 'Xdictionary.txt')
+   set dictionary=Xdictionary.txt
+   new
+   call setline(1, 'A')
+   call cursor(1, 1)
+   call feedkeys("A\<c-x>\<c-k>\<cr>\<esc>", 'tnix')
+   call assert_equal(['AA', ''], getline(1, '$'))
+   %d
+   call setline(1, 'A')
+   call cursor(1, 1)
+   call feedkeys("A\<c-x>\<c-k>\<down>\<cr>\<esc>", 'tnix')
+   call assert_equal(['AAA'], getline(1, '$'))
+   %d
+   call setline(1, 'A')
+   call cursor(1, 1)
+   call feedkeys("A\<c-x>\<c-k>\<down>\<down>\<cr>\<esc>", 'tnix')
+   call assert_equal(['AAAA'], getline(1, '$'))
+   %d
+   call setline(1, 'A')
+   call cursor(1, 1)
+   call feedkeys("A\<c-x>\<c-k>\<down>\<down>\<down>\<cr>\<esc>", 'tnix')
+   call assert_equal(['A'], getline(1, '$'))
+   %d
+   call setline(1, 'A')
+   call cursor(1, 1)
+   call feedkeys("A\<c-x>\<c-k>\<down>\<down>\<down>\<down>\<cr>\<esc>", 'tnix')
+   call assert_equal(['AA'], getline(1, '$'))
+ 
+   " press an unexecpted key after dictionary completion
+   %d
+   call setline(1, 'A')
+   call cursor(1, 1)
+   call feedkeys("A\<c-x>\<c-k>\<c-]>\<cr>\<esc>", 'tnix')
+   call assert_equal(['AA', ''], getline(1, '$'))
+   %d
+   call setline(1, 'A')
+   call cursor(1, 1)
+   call feedkeys("A\<c-x>\<c-k>\<c-s>\<cr>\<esc>", 'tnix')
+   call assert_equal(["AA\<c-s>", ''], getline(1, '$'))
+   %d
+   call setline(1, 'A')
+   call cursor(1, 1)
+   call feedkeys("A\<c-x>\<c-k>\<c-f>\<cr>\<esc>", 'tnix')
+   call assert_equal(["AA\<c-f>", ''], getline(1, '$'))
+ 
+   set dictionary=
+   %d
+   call setline(1, 'A')
+   call cursor(1, 1)
+   set belloff=all
+   let v:testing = 1
+   try
+     call feedkeys("A\<c-x>\<c-k>\<esc>", 'tnix')
+   catch
+     " error sleeps 2 seconds, when v:testing is not set
+     let v:testing = 0
+   endtry
+   set belloff=
+   call delete('Xdictionary.txt')
+ 
+   if has("multi_byte")
+     call test_override("char_avail", 1)
+     set showcmd
+     %d
+     call feedkeys("A\<c-k>a:\<esc>", 'tnix')
+     call assert_equal([''], getline(1, '$'))
+     call test_override("char_avail", 0)
+     set noshowcmd
+   endif
+   bw!
+ endfunc
+ 
+ func! Test_edit_CTRL_L()
+   " Test Ctrl-X Ctrl-L (line completion)
+   new
+   set complete=.
+   call setline(1, ['one', 'two', 'three', '', '', '', ''])
+   call cursor(4, 1)
+   call feedkeys("A\<c-x>\<c-l>\<esc>", 'tnix')
+   call assert_equal(['one', 'two', 'three', 'three', '', '', ''], getline(1, '$'))
+   call feedkeys("cct\<c-x>\<c-l>\<c-n>\<esc>", 'tnix')
+   call assert_equal(['one', 'two', 'three', 't', '', '', ''], getline(1, '$'))
+   call feedkeys("cct\<c-x>\<c-l>\<c-n>\<c-n>\<esc>", 'tnix')
+   call assert_equal(['one', 'two', 'three', 't', '', '', ''], getline(1, '$'))
+   call feedkeys("cct\<c-x>\<c-l>\<c-n>\<c-n>\<c-n>\<esc>", 'tnix')
+   call assert_equal(['one', 'two', 'three', 'two', '', '', ''], getline(1, '$'))
+   call feedkeys("cct\<c-x>\<c-l>\<c-n>\<c-n>\<c-n>\<c-n>\<esc>", 'tnix')
+   call assert_equal(['one', 'two', 'three', 'three', '', '', ''], getline(1, '$'))
+   call feedkeys("cct\<c-x>\<c-l>\<c-p>\<esc>", 'tnix')
+   call assert_equal(['one', 'two', 'three', 'two', '', '', ''], getline(1, '$'))
+   call feedkeys("cct\<c-x>\<c-l>\<c-p>\<c-p>\<esc>", 'tnix')
+   call assert_equal(['one', 'two', 'three', 't', '', '', ''], getline(1, '$'))
+   call feedkeys("cct\<c-x>\<c-l>\<c-p>\<c-p>\<c-p>\<esc>", 'tnix')
+   call assert_equal(['one', 'two', 'three', 'three', '', '', ''], getline(1, '$'))
+   set complete=
+   call cursor(5, 1)
+   call feedkeys("A\<c-x>\<c-l>\<c-p>\<c-n>\<esc>", 'tnix')
+   call assert_equal(['one', 'two', 'three', 'three', "\<c-l>\<c-p>\<c-n>", '', ''], getline(1, '$'))
+   set complete&
+   %d
+   if has("conceal") && has("syntax")
+     call setline(1, ['foo', 'bar', 'foobar'])
+     call test_override("char_avail", 1)
+     set conceallevel=2 concealcursor=n
+     syn on
+     syn match ErrorMsg "^bar"
+     call matchadd("Conceal", 'oo', 10, -1, {'conceal': 'X'})
+     func! DoIt()
+       let g:change=1
+     endfunc
+     au! TextChangedI <buffer> :call DoIt()
+ 
+     call cursor(2, 1)
+     call assert_false(exists("g:change"))
+     call feedkeys("A \<esc>", 'tnix')
+     call assert_equal(['foo', 'bar ', 'foobar'], getline(1, '$'))
+     call assert_equal(1, g:change)
+ 
+     call test_override("char_avail", 0)
+     call clearmatches()
+     syn off
+     au! TextChangedI
+     delfu DoIt
+     unlet! g:change
+   endif
+   bw!
+ endfunc
+ 
+ func! Test_edit_CTRL_N()
+   " Check keyword completion
+   new
+   set complete=.
+   call setline(1, ['INFER', 'loWER', '', '', ])
+   call cursor(3, 1)
+   call feedkeys("Ai\<c-n>\<cr>\<esc>", "tnix")
+   call feedkeys("ILO\<c-n>\<cr>\<esc>", 'tnix')
+   call assert_equal(['INFER', 'loWER', 'i', 'LO', '', ''], getline(1, '$'))
+   %d
+   call setline(1, ['INFER', 'loWER', '', '', ])
+   call cursor(3, 1)
+   set ignorecase infercase
+   call feedkeys("Ii\<c-n>\<cr>\<esc>", "tnix")
+   call feedkeys("ILO\<c-n>\<cr>\<esc>", 'tnix')
+   call assert_equal(['INFER', 'loWER', 'infer', 'LOWER', '', ''], getline(1, '$'))
+ 
+   set noignorecase noinfercase complete&
+   bw!
+ endfunc
+ 
+ func! Test_edit_CTRL_O()
+   " Check for CTRL-O in insert mode
+   new
+   inoreabbr <buffer> h here some more
+   call setline(1, ['abc', 'def'])
+   call cursor(1, 1)
+   " Ctrl-O after an abbreviation
+   exe "norm A h\<c-o>:set nu\<cr> text"
+   call assert_equal(['abc here some more text', 'def'], getline(1, '$'))
+   call assert_true(&nu)
+   set nonu
+   iunabbr <buffer> h
+   " Ctrl-O at end of line with 've'=onemore
+   call cursor(1, 1)
+   call feedkeys("A\<c-o>:let g:a=getpos('.')\<cr>\<esc>", 'tnix')
+   call assert_equal([0, 1, 23, 0], g:a)
+   call cursor(1, 1)
+   set ve=onemore
+   call feedkeys("A\<c-o>:let g:a=getpos('.')\<cr>\<esc>", 'tnix')
+   call assert_equal([0, 1, 24, 0], g:a)
+   set ve=
+   unlet! g:a
+   bw!
+ endfunc
+ 
+ func! Test_edit_CTRL_R()
+   " Insert Register
+   new
+   call test_override("ALL", 1)
+   set showcmd
+   call feedkeys("AFOOBAR eins zwei\<esc>", 'tnix')
+   call feedkeys("O\<c-r>.", 'tnix')
+   call feedkeys("O\<c-r>=10*500\<cr>\<esc>", 'tnix')
+   call feedkeys("O\<c-r>=getreg('=', 1)\<cr>\<esc>", 'tnix')
+   call assert_equal(["getreg('=', 1)", '5000', "FOOBAR eins zwei", "FOOBAR eins zwei"], getline(1, '$'))
+   call test_override("ALL", 0)
+   set noshowcmd
+   bw!
+ endfunc
+ 
+ func! Test_edit_CTRL_S()
+   " Test pressing CTRL-S (basically only spellfile completion)
+   " the rest is already covered
+   new
+   if !has("spell")
+     call setline(1, 'vim')
+     call feedkeys("A\<c-x>ss\<cr>\<esc>", 'tnix')
+     call assert_equal(['vims', ''], getline(1, '$'))
+     bw!
+     return
+   endif
+   call setline(1, 'vim')
+   " spell option not yet set
+   try
+     call feedkeys("A\<c-x>\<c-s>\<cr>\<esc>", 'tnix')
+   catch /^Vim\%((\a\+)\)\=:E756/
+     call assert_true(1, 'error caught')
+   endtry
+   call assert_equal(['vim', ''], getline(1, '$'))
+   %d
+   setl spell spelllang=en
+   call setline(1, 'vim')
+   call cursor(1, 1)
+   call feedkeys("A\<c-x>\<c-s>\<cr>\<esc>", 'tnix')
+   call assert_equal(['Vim', ''], getline(1, '$'))
+   %d
+   call setline(1, 'vim')
+   call cursor(1, 1)
+   call feedkeys("A\<c-x>\<c-s>\<down>\<cr>\<esc>", 'tnix')
+   call assert_equal(['Aim'], getline(1, '$'))
+   %d
+   call setline(1, 'vim')
+   call cursor(1, 1)
+   call feedkeys("A\<c-x>\<c-s>\<c-p>\<cr>\<esc>", 'tnix')
+   call assert_equal(['vim', ''], getline(1, '$'))
+   %d
+   " empty buffer
+   call cursor(1, 1)
+   call feedkeys("A\<c-x>\<c-s>\<c-p>\<cr>\<esc>", 'tnix')
+   call assert_equal(['', ''], getline(1, '$'))
+   setl nospell
+   bw!
+ endfunc
+ 
+ func! Test_edit_CTRL_T()
+   " Check for CTRL-T and CTRL-X CTRL-T in insert mode
+   " 1) increase indent
+   new
+   call setline(1, "abc")
+   call cursor(1, 1)
+   call feedkeys("A\<c-t>xyz", 'tnix')
+   call assert_equal(["\<tab>abcxyz"], getline(1, '$'))
+   " 2) also when paste option is set
+   set paste
+   call setline(1, "abc")
+   call cursor(1, 1)
+   call feedkeys("A\<c-t>xyz", 'tnix')
+   call assert_equal(["\<tab>abcxyz"], getline(1, '$'))
+   set nopaste
+   " CTRL-X CTRL-T (thesaurus complete)
+   call writefile(['angry furious mad enraged'], 'Xthesaurus')
+   set thesaurus=Xthesaurus
+   call setline(1, 'mad')
+   call cursor(1, 1)
+   call feedkeys("A\<c-x>\<c-t>\<cr>\<esc>", 'tnix')
+   call assert_equal(['mad', ''], getline(1, '$'))
+   %d
+   call setline(1, 'mad')
+   call cursor(1, 1)
+   call feedkeys("A\<c-x>\<c-t>\<c-n>\<cr>\<esc>", 'tnix')
+   call assert_equal(['angry', ''], getline(1, '$'))
+   %d
+   call setline(1, 'mad')
+   call cursor(1, 1)
+   call feedkeys("A\<c-x>\<c-t>\<c-n>\<c-n>\<cr>\<esc>", 'tnix')
+   call assert_equal(['furious', ''], getline(1, '$'))
+   %d
+   call setline(1, 'mad')
+   call cursor(1, 1)
+   call feedkeys("A\<c-x>\<c-t>\<c-n>\<c-n>\<c-n>\<cr>\<esc>", 'tnix')
+   call assert_equal(['enraged', ''], getline(1, '$'))
+   %d
+   call setline(1, 'mad')
+   call cursor(1, 1)
+   call feedkeys("A\<c-x>\<c-t>\<c-n>\<c-n>\<c-n>\<c-n>\<cr>\<esc>", 'tnix')
+   call assert_equal(['mad', ''], getline(1, '$'))
+   %d
+   call setline(1, 'mad')
+   call cursor(1, 1)
+   call feedkeys("A\<c-x>\<c-t>\<c-n>\<c-n>\<c-n>\<c-n>\<c-n>\<cr>\<esc>", 'tnix')
+   call assert_equal(['mad', ''], getline(1, '$'))
+   " Using <c-p> <c-n> when 'complete' is empty
+   set complete=
+   %d
+   call setline(1, 'mad')
+   call cursor(1, 1)
+   call feedkeys("A\<c-x>\<c-t>\<c-n>\<cr>\<esc>", 'tnix')
+   call assert_equal(['angry', ''], getline(1, '$'))
+   %d
+   call setline(1, 'mad')
+   call cursor(1, 1)
+   call feedkeys("A\<c-x>\<c-t>\<c-p>\<cr>\<esc>", 'tnix')
+   call assert_equal(['mad', ''], getline(1, '$'))
+   set complete&
+ 
+   set thesaurus=
+   %d
+   call setline(1, 'mad')
+   call cursor(1, 1)
+   set belloff=all
+   let v:testing = 1
+   try
+     call feedkeys("A\<c-x>\<c-t>\<esc>", 'tnix')
+   catch
+     " error sleeps 2 seconds, when v:testing is not set
+     let v:testing = 0
+   endtry
+   set belloff=
+   call assert_equal(['mad'], getline(1, '$'))
+   call delete('Xthesaurus')
+   bw!
+ endfunc
+ 
+ func! Test_edit_CTRL_U()
+   " Test 'completefunc'
+   new
+   " -1, -2 and -3 are special return values
+   let g:special=0
+   fun! CompleteMonths(findstart, base)
+     if a:findstart
+       " locate the start of the word
+       return g:special
+     else
+       " find months matching with "a:base"
+       let res = []
+       for m in split("Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec")
+         if m =~ '^\c'.a:base
+           call add(res, {'word': m, 'abbr': m.' Month', 'icase': 0})
+         endif
+       endfor
+       return {'words': res, 'refresh': 'always'}
+     endif
+   endfun
+   set completefunc=CompleteMonths
+   call setline(1, ['', ''])
+   call cursor(1, 1)
+   call feedkeys("AX\<c-x>\<c-u>\<cr>\<esc>", 'tnix')
+   call assert_equal(['X', '', ''], getline(1, '$'))
+   %d
+   let g:special=-1
+   call feedkeys("AX\<c-x>\<c-u>\<cr>\<esc>", 'tnix')
+   call assert_equal(['XJan', ''], getline(1, '$'))
+   %d
+   let g:special=-2
+   call feedkeys("AX\<c-x>\<c-u>\<cr>\<esc>", 'tnix')
+   call assert_equal(['X', ''], getline(1, '$'))
+   %d
+   let g:special=-3
+   call feedkeys("AX\<c-x>\<c-u>\<cr>\<esc>", 'tnix')
+   call assert_equal(['X', ''], getline(1, '$'))
+   %d
+   let g:special=0
+   call feedkeys("AM\<c-x>\<c-u>\<cr>\<esc>", 'tnix')
+   call assert_equal(['Mar', ''], getline(1, '$'))
+   %d
+   call feedkeys("AM\<c-x>\<c-u>\<c-n>\<cr>\<esc>", 'tnix')
+   call assert_equal(['May', ''], getline(1, '$'))
+   %d
+   call feedkeys("AM\<c-x>\<c-u>\<c-n>\<c-n>\<cr>\<esc>", 'tnix')
+   call assert_equal(['M', ''], getline(1, '$'))
+   delfu CompleteMonths
+   %d
+   try
+     call feedkeys("A\<c-x>\<c-u>", 'tnix')
+     call assert_fails(1, 'unknown completion function')
+   catch /^Vim\%((\a\+)\)\=:E117/
+     call assert_true(1, 'E117 error caught')
+   endtry
+   set completefunc=
+   bw!
+ endfunc
+ 
+ func! Test_edit_CTRL_Z()
+   " Ctrl-Z when insertmode is not set inserts it literally
+   new
+   call setline(1, 'abc')
+   call feedkeys("A\<c-z>\<esc>", 'tnix')
+   call assert_equal(["abc\<c-z>"], getline(1,'$'))
+   bw!
+   " TODO: How to Test Ctrl-Z in insert mode, e.g. suspend?
+ endfunc
+ 
+ func! Test_edit_DROP()
+   if !has("dnd")
+     return
+   endif
+   new
+   call setline(1, ['abc def ghi'])
+   call cursor(1, 1)
+   try
+     call feedkeys("i\<Drop>\<Esc>", 'tnix')
+     call assert_fails(1, 'Invalid register name')
+   catch /^Vim\%((\a\+)\)\=:E353/
+     call assert_true(1, 'error caught')
+   endtry
+   bw!
+ endfunc
+ 
+ func! Test_edit_CTRL_V()
+   if has("ebcdic")
+     return
+   endif
+   new
+   call setline(1, ['abc'])
+   call cursor(2, 1)
+   " force some redraws
+   set showmode showcmd
+   "call test_override_char_avail(1)
+   call test_override('ALL', 1)
+   call feedkeys("A\<c-v>\<c-n>\<c-v>\<c-l>\<c-v>\<c-b>\<esc>", 'tnix')
+   call assert_equal(["abc\x0e\x0c\x02"], getline(1, '$'))
+ 
+   if has("rightleft") && exists("+rl")
+     set rl
+     call setline(1, ['abc'])
+     call cursor(2, 1)
+     call feedkeys("A\<c-v>\<c-n>\<c-v>\<c-l>\<c-v>\<c-b>\<esc>", 'tnix')
+     call assert_equal(["abc\x0e\x0c\x02"], getline(1, '$'))
+     set norl
+   endif
+ 
+   call test_override('ALL', 0)
+   set noshowmode showcmd
+   bw!
+ endfunc
+ 
+ func! Test_edit_F1()
+   " Pressing <f1>
+   new
+   call feedkeys(":set im\<cr>\<f1>\<c-l>", 'tnix')
+   set noinsertmode
+   call assert_equal('help', &buftype)
+   bw
+   bw
+ endfunc
+ 
+ func! Test_edit_F21()
+   " Pressing <f21>
+   " sends a netbeans command
+   if has("netbeans_intg")
+     new
+     " I have no idea what this is supposed to do :)
+     call feedkeys("A\<F21>\<F1>\<esc>", 'tnix')
+     bw
+   endif
+ endfunc
+ 
+ func! Test_edit_HOME_END()
+   " Test Home/End Keys
+   new
+   set foldopen+=hor
+   call setline(1, ['abc', 'def'])
+   call cursor(1, 1)
+   call feedkeys("AX\<Home>Y\<esc>", 'tnix')
+   call cursor(2, 1)
+   call feedkeys("iZ\<End>Y\<esc>", 'tnix')
+   call assert_equal(['YabcX', 'ZdefY'], getline(1, '$'))
+ 
+   set foldopen-=hor
+   bw!
+ endfunc
+ 
+ func! Test_edit_INS()
+   " Test for Pressing <Insert>
+   new
+   call setline(1, ['abc', 'def'])
+   call cursor(1, 1)
+   call feedkeys("i\<Insert>ZYX>", 'tnix')
+   call assert_equal(['ZYX>', 'def'], getline(1, '$'))
+   call setline(1, ['abc', 'def'])
+   call cursor(1, 1)
+   call feedkeys("i\<Insert>Z\<Insert>YX>", 'tnix')
+   call assert_equal(['ZYX>bc', 'def'], getline(1, '$'))
+   bw!
+ endfunc
+ 
+ func! Test_edit_LEFT_RIGHT()
+   " Left, Shift-Left, Right, Shift-Right
+   new
+   set belloff=all
+   call setline(1, ['abc def ghi', 'ABC DEF GHI', 'ZZZ YYY XXX'])
+   let _ww=&ww
+   set ww=
+   call cursor(2, 1)
+   call feedkeys("i\<left>\<esc>", 'tnix')
+   call assert_equal([0, 2, 1, 0], getpos('.'))
+   " Is this a bug, <s-left> does not respect whichwrap option
+   call feedkeys("i\<s-left>\<esc>", 'tnix')
+   call assert_equal([0, 1, 8, 0], getpos('.'))
+   call feedkeys("i". repeat("\<s-left>", 3). "\<esc>", 'tnix')
+   call assert_equal([0, 1, 1, 0], getpos('.'))
+   call feedkeys("i\<right>\<esc>", 'tnix')
+   call assert_equal([0, 1, 1, 0], getpos('.'))
+   call feedkeys("i\<right>\<right>\<esc>", 'tnix')
+   call assert_equal([0, 1, 2, 0], getpos('.'))
+   call feedkeys("A\<right>\<esc>", 'tnix')
+   call assert_equal([0, 1, 11, 0], getpos('.'))
+   call feedkeys("A\<s-right>\<esc>", 'tnix')
+   call assert_equal([0, 2, 1, 0], getpos('.'))
+   call feedkeys("i\<s-right>\<esc>", 'tnix')
+   call assert_equal([0, 2, 4, 0], getpos('.'))
+   call cursor(3, 11)
+   call feedkeys("A\<right>\<esc>", 'tnix')
+   call feedkeys("A\<s-right>\<esc>", 'tnix')
+   call assert_equal([0, 3, 11, 0], getpos('.'))
+   call cursor(2, 11)
+   " <S-Right> does not respect 'whichwrap' option
+   call feedkeys("A\<s-right>\<esc>", 'tnix')
+   call assert_equal([0, 3, 1, 0], getpos('.'))
+   " Check motion when 'whichwrap' contains cursor keys for insert mode
+   set ww+=[,]
+   call cursor(2, 1)
+   call feedkeys("i\<left>\<esc>", 'tnix')
+   call assert_equal([0, 1, 11, 0], getpos('.'))
+   call cursor(2, 11)
+   call feedkeys("A\<right>\<esc>", 'tnix')
+   call assert_equal([0, 3, 1, 0], getpos('.'))
+   call cursor(2, 11)
+   call feedkeys("A\<s-right>\<esc>", 'tnix')
+   call assert_equal([0, 3, 1, 0], getpos('.'))
+   let &ww = _ww
+   set belloff=
+   bw!
+ endfunc
+ 
+ func! Test_edit_MOUSE()
+   " This is a simple test, since we not really using the mouse here
+   if !has("mouse")
+     return
+   endif
+   10new
+   call setline(1, range(1, 100))
+   call cursor(1, 1)
+   set mouse=a
+   call feedkeys("A\<ScrollWheelDown>\<esc>", 'tnix')
+   call assert_equal([0, 4, 1, 0], getpos('.'))
+   " This should move by one pageDown, but only moves
+   " by one line when the test is run...
+   call feedkeys("A\<S-ScrollWheelDown>\<esc>", 'tnix')
+   call assert_equal([0, 5, 1, 0], getpos('.'))
+   set nostartofline
+   call feedkeys("A\<C-ScrollWheelDown>\<esc>", 'tnix')
+   call assert_equal([0, 6, 1, 0], getpos('.'))
+   call feedkeys("A\<LeftMouse>\<esc>", 'tnix')
+   call assert_equal([0, 6, 1, 0], getpos('.'))
+   call feedkeys("A\<RightMouse>\<esc>", 'tnix')
+   call assert_equal([0, 6, 1, 0], getpos('.'))
+   call cursor(1, 100)
+   norm! zt
+   " this should move by a screen up, but when the test
+   " is run, it moves up to the top of the buffer...
+   call feedkeys("A\<ScrollWheelUp>\<esc>", 'tnix')
+   call assert_equal([0, 1, 1, 0], getpos('.'))
+   call cursor(1, 30)
+   norm! zt
+   call feedkeys("A\<S-ScrollWheelUp>\<esc>", 'tnix')
+   call assert_equal([0, 1, 1, 0], getpos('.'))
+   call cursor(1, 30)
+   norm! zt
+   call feedkeys("A\<C-ScrollWheelUp>\<esc>", 'tnix')
+   call assert_equal([0, 1, 1, 0], getpos('.'))
+   %d
+   call setline(1, repeat(["12345678901234567890"], 100))
+   call cursor(2, 1)
+   call feedkeys("A\<ScrollWheelRight>\<esc>", 'tnix')
+   call assert_equal([0, 2, 20, 0], getpos('.'))
+   call feedkeys("A\<ScrollWheelLeft>\<esc>", 'tnix')
+   call assert_equal([0, 2, 20, 0], getpos('.'))
+   call feedkeys("A\<S-ScrollWheelRight>\<esc>", 'tnix')
+   call assert_equal([0, 2, 20, 0], getpos('.'))
+   call feedkeys("A\<S-ScrollWheelLeft>\<esc>", 'tnix')
+   call assert_equal([0, 2, 20, 0], getpos('.'))
+   call feedkeys("A\<C-ScrollWheelRight>\<esc>", 'tnix')
+   call assert_equal([0, 2, 20, 0], getpos('.'))
+   call feedkeys("A\<C-ScrollWheelLeft>\<esc>", 'tnix')
+   call assert_equal([0, 2, 20, 0], getpos('.'))
+   set mouse& startofline
+   bw!
+ endfunc
+ 
+ func! Test_edit_PAGEUP_PAGEDOWN()
+   set belloff=all
+   10new
+   call setline(1, repeat(['abc def ghi'], 30))
+   call cursor(1, 1)
+   call feedkeys("i\<PageDown>\<esc>", 'tnix')
+   call assert_equal([0, 9, 1, 0], getpos('.'))
+   call feedkeys("i\<PageDown>\<esc>", 'tnix')
+   call assert_equal([0, 17, 1, 0], getpos('.'))
+   call feedkeys("i\<PageDown>\<esc>", 'tnix')
+   call assert_equal([0, 25, 1, 0], getpos('.'))
+   call feedkeys("i\<PageDown>\<esc>", 'tnix')
+   call assert_equal([0, 30, 1, 0], getpos('.'))
+   call feedkeys("i\<PageDown>\<esc>", 'tnix')
+   call assert_equal([0, 30, 1, 0], getpos('.'))
+   call feedkeys("A\<PageUp>\<esc>", 'tnix')
+   call assert_equal([0, 29, 1, 0], getpos('.'))
+   call feedkeys("A\<PageUp>\<esc>", 'tnix')
+   call assert_equal([0, 21, 1, 0], getpos('.'))
+   call feedkeys("A\<PageUp>\<esc>", 'tnix')
+   call assert_equal([0, 13, 1, 0], getpos('.'))
+   call feedkeys("A\<PageUp>\<esc>", 'tnix')
+   call assert_equal([0, 5, 1, 0], getpos('.'))
+   call feedkeys("A\<PageUp>\<esc>", 'tnix')
+   call assert_equal([0, 5, 11, 0], getpos('.'))
+   " <S-Up> is the same as <PageUp>
+   " <S-Down> is the same as <PageDown>
+   call cursor(1, 1)
+   call feedkeys("i\<S-Down>\<esc>", 'tnix')
+   call assert_equal([0, 9, 1, 0], getpos('.'))
+   call feedkeys("i\<S-Down>\<esc>", 'tnix')
+   call assert_equal([0, 17, 1, 0], getpos('.'))
+   call feedkeys("i\<S-Down>\<esc>", 'tnix')
+   call assert_equal([0, 25, 1, 0], getpos('.'))
+   call feedkeys("i\<S-Down>\<esc>", 'tnix')
+   call assert_equal([0, 30, 1, 0], getpos('.'))
+   call feedkeys("i\<S-Down>\<esc>", 'tnix')
+   call assert_equal([0, 30, 1, 0], getpos('.'))
+   call feedkeys("A\<S-Up>\<esc>", 'tnix')
+   call assert_equal([0, 29, 1, 0], getpos('.'))
+   call feedkeys("A\<S-Up>\<esc>", 'tnix')
+   call assert_equal([0, 21, 1, 0], getpos('.'))
+   call feedkeys("A\<S-Up>\<esc>", 'tnix')
+   call assert_equal([0, 13, 1, 0], getpos('.'))
+   call feedkeys("A\<S-Up>\<esc>", 'tnix')
+   call assert_equal([0, 5, 1, 0], getpos('.'))
+   call feedkeys("A\<S-Up>\<esc>", 'tnix')
+   call assert_equal([0, 5, 11, 0], getpos('.'))
+   set nostartofline
+   call cursor(30, 11)
+   norm! zt
+   call feedkeys("A\<PageUp>\<esc>", 'tnix')
+   call assert_equal([0, 29, 11, 0], getpos('.'))
+   call feedkeys("A\<PageUp>\<esc>", 'tnix')
+   call assert_equal([0, 21, 11, 0], getpos('.'))
+   call feedkeys("A\<PageUp>\<esc>", 'tnix')
+   call assert_equal([0, 13, 11, 0], getpos('.'))
+   call feedkeys("A\<PageUp>\<esc>", 'tnix')
+   call assert_equal([0, 5, 11, 0], getpos('.'))
+   call feedkeys("A\<PageUp>\<esc>", 'tnix')
+   call assert_equal([0, 5, 11, 0], getpos('.'))
+   call cursor(1, 1)
+   call feedkeys("A\<PageDown>\<esc>", 'tnix')
+   call assert_equal([0, 9, 11, 0], getpos('.'))
+   call feedkeys("A\<PageDown>\<esc>", 'tnix')
+   call assert_equal([0, 17, 11, 0], getpos('.'))
+   call feedkeys("A\<PageDown>\<esc>", 'tnix')
+   call assert_equal([0, 25, 11, 0], getpos('.'))
+   call feedkeys("A\<PageDown>\<esc>", 'tnix')
+   call assert_equal([0, 30, 11, 0], getpos('.'))
+   call feedkeys("A\<PageDown>\<esc>", 'tnix')
+   call assert_equal([0, 30, 11, 0], getpos('.'))
+   " <S-Up> is the same as <PageUp>
+   " <S-Down> is the same as <PageDown>
+   call cursor(30, 11)
+   norm! zt
+   call feedkeys("A\<S-Up>\<esc>", 'tnix')
+   call assert_equal([0, 29, 11, 0], getpos('.'))
+   call feedkeys("A\<S-Up>\<esc>", 'tnix')
+   call assert_equal([0, 21, 11, 0], getpos('.'))
+   call feedkeys("A\<S-Up>\<esc>", 'tnix')
+   call assert_equal([0, 13, 11, 0], getpos('.'))
+   call feedkeys("A\<S-Up>\<esc>", 'tnix')
+   call assert_equal([0, 5, 11, 0], getpos('.'))
+   call feedkeys("A\<S-Up>\<esc>", 'tnix')
+   call assert_equal([0, 5, 11, 0], getpos('.'))
+   call cursor(1, 1)
+   call feedkeys("A\<S-Down>\<esc>", 'tnix')
+   call assert_equal([0, 9, 11, 0], getpos('.'))
+   call feedkeys("A\<S-Down>\<esc>", 'tnix')
+   call assert_equal([0, 17, 11, 0], getpos('.'))
+   call feedkeys("A\<S-Down>\<esc>", 'tnix')
+   call assert_equal([0, 25, 11, 0], getpos('.'))
+   call feedkeys("A\<S-Down>\<esc>", 'tnix')
+   call assert_equal([0, 30, 11, 0], getpos('.'))
+   call feedkeys("A\<S-Down>\<esc>", 'tnix')
+   call assert_equal([0, 30, 11, 0], getpos('.'))
+   set startofline belloff=
+   bw!
+ endfunc
+ 
+ func! Test_edit_forbidden()
+   set belloff=error,esc
+   new
+   " 1) edit in the sandbox is not allowed
+   call setline(1, 'a')
+   com! Sandbox :sandbox call feedkeys("i\<del>\<esc>", 'tnix')
+   call assert_fails(':Sandbox', 'E48:')
+   com! Sandbox :sandbox exe "norm! i\<del>"
+   call assert_fails(':Sandbox', 'E48:')
+   delcom Sandbox
+   call assert_equal(['a'], getline(1,'$'))
+   " 2) edit with textlock set
+   fu! DoIt()
+     call feedkeys("i\<del>\<esc>", 'tnix')
+   endfu
+   au InsertCharPre <buffer> :call DoIt()
+   try
+     call feedkeys("ix\<esc>", 'tnix')
+     call assert_fails(1, 'textlock')
+   catch /^Vim\%((\a\+)\)\=:E523/ " catch E523: not allowed here
+   endtry
+   " TODO: Might be a bug: should x really be inserted here
+   call assert_equal(['xa'], getline(1, '$'))
+   delfu DoIt
+   try
+     call feedkeys("ix\<esc>", 'tnix')
+     call assert_fails(1, 'unknown function')
+   catch /^Vim\%((\a\+)\)\=:E117/ " catch E117: unknown function
+   endtry
+   au! InsertCharPre
+   " 3) edit when completion is shown
+   fun! Complete(findstart, base)
+     if a:findstart
+       return col('.')
+     else
+       call feedkeys("i\<del>\<esc>", 'tnix')
+       return []
+     endif
+   endfun
+   set completefunc=Complete
+   try
+     call feedkeys("i\<c-x>\<c-u>\<esc>", 'tnix')
+     call assert_fails(1, 'change in complete function')
+   catch /^Vim\%((\a\+)\)\=:E523/ " catch E523
+   endtry
+   delfu Complete
+   set completefunc=
+   if has("rightleft") && exists("+fkmap")
+     " 4) 'R' when 'fkmap' and 'revins' is set.
+     set revins fkmap
+     try
+       normal Ri
+       call assert_fails(1, "R with 'fkmap' and 'ri' set")
+     catch
+     finally
+       set norevins nofkmap
+     endtry
+   endif
+   set belloff=
+   bw!
+ endfunc
+ 
+ func! Test_edit_rightleft()
+   " Cursor in rightleft mode moves differently
+   if !exists("+rightleft")
+     return
+   endif
+   call NewWindow(10, 20)
+   call setline(1, ['abc', 'def', 'ghi'])
+   call cursor(1, 2)
+   set rightleft
+   " Screen looks as expected
+   let lines = ScreenLines([1, 4], winwidth(0))
+   let expect = [
+         \"                 cba",
+         \"                 fed",
+         \"                 ihg",
+         \"                   ~"]
+   call assert_equal(join(expect, "\n"), join(lines, "\n"))
+   " 2) right moves to the left
+   call feedkeys("i\<right>\<esc>x", 'txin')
+   call assert_equal(['bc', 'def', 'ghi'], getline(1,'$'))
+   call cursor(1, 2)
+   call feedkeys("i\<s-right>\<esc>", 'txin')
+   call cursor(1, 2)
+   call feedkeys("i\<c-right>\<esc>", 'txin')
+   " Screen looks as expected
+   let lines = ScreenLines([1, 4], winwidth(0))
+   let expect = [
+         \"                  cb",
+         \"                 fed",
+         \"                 ihg",
+         \"                   ~"]
+   call assert_equal(join(expect, "\n"), join(lines, "\n"))
+   " 2) left moves to the right
+   call setline(1, ['abc', 'def', 'ghi'])
+   call cursor(1, 2)
+   call feedkeys("i\<left>\<esc>x", 'txin')
+   call assert_equal(['ac', 'def', 'ghi'], getline(1,'$'))
+   call cursor(1, 2)
+   call feedkeys("i\<s-left>\<esc>", 'txin')
+   call cursor(1, 2)
+   call feedkeys("i\<c-left>\<esc>", 'txin')
+   " Screen looks as expected
+   let lines = ScreenLines([1, 4], winwidth(0))
+   let expect = [
+         \"                  ca",
+         \"                 fed",
+         \"                 ihg",
+         \"                   ~"]
+   call assert_equal(join(expect, "\n"), join(lines, "\n"))
+   set norightleft
+   bw!
+ endfunc
*** ../vim-8.0.0439/src/testdir/test_search.vim	2017-03-08 22:55:14.914181221 +0100
--- src/testdir/test_search.vim	2017-03-09 17:17:07.575435945 +0100
***************
*** 7,13 ****
    endif
    " need to disable char_avail,
    " so that expansion of commandline works
!   call test_disable_char_avail(1)
    new
    call setline(1, ['  1', '  2 these', '  3 the', '  4 their', '  5 there', '  6 their', '  7 the', '  8 them', '  9 these', ' 10 foobar'])
    " Test 1
--- 7,13 ----
    endif
    " need to disable char_avail,
    " so that expansion of commandline works
!   call test_override("char_avail", 1)
    new
    call setline(1, ['  1', '  2 these', '  3 the', '  4 their', '  5 there', '  6 their', '  7 the', '  8 them', '  9 these', ' 10 foobar'])
    " Test 1
***************
*** 194,200 ****
    call assert_equal('  3 the', getline('.'))
  
    " clean up
!   call test_disable_char_avail(0)
    bw!
  endfunc
  
--- 194,200 ----
    call assert_equal('  3 the', getline('.'))
  
    " clean up
!   call test_override("char_avail", 0)
    bw!
  endfunc
  
***************
*** 204,210 ****
    endif
    " need to disable char_avail,
    " so that expansion of commandline works
!   call test_disable_char_avail(1)
    new
    call setline(1, ['  1', '  2 these', '  3 the theother'])
    " Test 1
--- 204,210 ----
    endif
    " need to disable char_avail,
    " so that expansion of commandline works
!   call test_override("char_avail", 1)
    new
    call setline(1, ['  1', '  2 these', '  3 the theother'])
    " Test 1
***************
*** 266,272 ****
  
    " clean up
    set noincsearch
!   call test_disable_char_avail(0)
    bw!
  endfunc
  
--- 266,272 ----
  
    " clean up
    set noincsearch
!   call test_override("char_avail", 0)
    bw!
  endfunc
  
*** ../vim-8.0.0439/src/testdir/test_assert.vim	2017-01-28 18:08:08.155009961 +0100
--- src/testdir/test_assert.vim	2017-03-09 17:36:18.279384806 +0100
***************
*** 127,132 ****
--- 127,140 ----
    call remove(v:errors, 0)
  endfunc
  
+ func Test_override()
+   call test_override('char_avail', 1)
+   call test_override('redraw', 1)
+   call test_override('ALL', 0)
+   call assert_fails("call test_override('xxx', 1)", 'E475')
+   call assert_fails("call test_override('redraw', 'yes')", 'E474')
+ endfunc
+ 
  func Test_user_is_happy()
    smile
    sleep 300m
*** ../vim-8.0.0439/src/Makefile	2017-03-08 22:39:46.536941572 +0100
--- src/Makefile	2017-03-09 17:39:33.582018380 +0100
***************
*** 2111,2116 ****
--- 2110,2116 ----
  	test_digraph \
  	test_functions \
  	test_display \
+ 	test_edit \
  	test_ex_undo \
  	test_execute_func \
  	test_expand \
*** ../vim-8.0.0439/src/testdir/runtest.vim	2017-03-05 14:30:48.372572724 +0100
--- src/testdir/runtest.vim	2017-03-09 17:40:37.097573956 +0100
***************
*** 49,55 ****
  " This also enables use of line continuation.
  set nocp viminfo+=nviminfo
  
! " Use utf-8 or latin1 be default, instead of whatever the system default
  " happens to be.  Individual tests can overrule this at the top of the file.
  if has('multi_byte')
    set encoding=utf-8
--- 49,55 ----
  " This also enables use of line continuation.
  set nocp viminfo+=nviminfo
  
! " Use utf-8 or latin1 by default, instead of whatever the system default
  " happens to be.  Individual tests can overrule this at the top of the file.
  if has('multi_byte')
    set encoding=utf-8
***************
*** 96,101 ****
--- 96,104 ----
    " mode message.
    set noshowmode
  
+   " Clear any overrides.
+   call test_override('ALL', 0)
+ 
    if exists("*SetUp")
      try
        call SetUp()
*** ../vim-8.0.0439/src/version.c	2017-03-09 15:58:26.548668478 +0100
--- src/version.c	2017-03-09 17:18:40.966782129 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     440,
  /**/

-- 
From "know your smileys":
 <>:-)	Bishop

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0441
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0441
Problem:    Dead code in #ifdef.
Solution:   Remove the #ifdef and #else part.
Files:      src/option.c


*** ../vim-8.0.0440/src/option.c	2017-03-05 21:18:21.881452156 +0100
--- src/option.c	2017-03-09 18:56:56.009622726 +0100
***************
*** 4129,4135 ****
  	    options[idx3].def_val[VI_DEFAULT] = p_shcf;
  	}
  
- # ifdef WIN3264
  	/* Somehow Win32 requires the quotes around the redirection too */
  	idx3 = findoption((char_u *)"sxq");
  	if (idx3 >= 0 && !(options[idx3].flags & P_WAS_SET))
--- 4129,4134 ----
***************
*** 4137,4150 ****
  	    p_sxq = (char_u *)"\"";
  	    options[idx3].def_val[VI_DEFAULT] = p_sxq;
  	}
- # else
- 	idx3 = findoption((char_u *)"shq");
- 	if (idx3 >= 0 && !(options[idx3].flags & P_WAS_SET))
- 	{
- 	    p_shq = (char_u *)"\"";
- 	    options[idx3].def_val[VI_DEFAULT] = p_shq;
- 	}
- # endif
      }
      else if (strstr((char *)gettail(p_sh), "cmd.exe") != NULL)
      {
--- 4136,4141 ----
*** ../vim-8.0.0440/src/version.c	2017-03-09 18:19:58.165107821 +0100
--- src/version.c	2017-03-09 18:57:41.725301291 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     441,
  /**/

-- 
From "know your smileys":
 +<(:-) The Pope

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0442
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0442
Problem:    Patch shell command uses double quotes around the argument, which
            allows for $HOME to be expanded. (Etienne)
Solution:   Use single quotes on Unix. (closes #1543)
Files:      src/diff.c, src/testdir/test_diffmode.vim


*** ../vim-8.0.0441/src/diff.c	2017-03-05 21:18:21.877452188 +0100
--- src/diff.c	2017-03-09 19:16:13.365488797 +0100
***************
*** 977,983 ****
      {
  	/* Build the patch command and execute it.  Ignore errors.  Switch to
  	 * cooked mode to allow the user to respond to prompts. */
! 	vim_snprintf((char *)buf, buflen, "patch -o %s %s < \"%s\"",
  		tmp_new, tmp_orig,
  # ifdef UNIX
  		fullname != NULL ? fullname :
--- 977,988 ----
      {
  	/* Build the patch command and execute it.  Ignore errors.  Switch to
  	 * cooked mode to allow the user to respond to prompts. */
! 	vim_snprintf((char *)buf, buflen,
! #ifdef UNIX
! 		"patch -o %s %s < '%s'",
! #else
! 		"patch -o %s %s < \"%s\"",
! #endif
  		tmp_new, tmp_orig,
  # ifdef UNIX
  		fullname != NULL ? fullname :
*** ../vim-8.0.0441/src/testdir/test_diffmode.vim	2017-03-08 22:55:14.914181221 +0100
--- src/testdir/test_diffmode.vim	2017-03-09 19:13:26.878658438 +0100
***************
*** 318,326 ****
    bwipe!
    new
    call assert_fails('diffpatch Xpatch', 'E816:')
!   call setline(1, ['1', '2', '3'])
!   diffpatch Xpatch
!   call assert_equal(['1', '2x', '3', '4'], getline(1, '$'))
    call delete('Xpatch')
    bwipe!
  endfunc
--- 318,337 ----
    bwipe!
    new
    call assert_fails('diffpatch Xpatch', 'E816:')
! 
!   for name in ['Xpatch', 'Xpatch$HOME']
!     call setline(1, ['1', '2', '3'])
!     if name != 'Xpatch'
!       call rename('Xpatch', name)
!     endif
!     exe 'diffpatch ' . escape(name, '$')
!     call assert_equal(['1', '2x', '3', '4'], getline(1, '$'))
!     if name != 'Xpatch'
!       call rename(name, 'Xpatch')
!     endif
!     bwipe!
!   endfor
! 
    call delete('Xpatch')
    bwipe!
  endfunc
*** ../vim-8.0.0441/src/version.c	2017-03-09 18:59:05.660711160 +0100
--- src/version.c	2017-03-09 19:01:01.659895667 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     442,
  /**/

-- 
From "know your smileys":
 :-D	Big smile

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0443
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0443
Problem:    Terminal width is set to 80 in test3.
Solution:   Instead of setting 'columns' set 'wrapmargin' depending on
            'columns.
Files:      src/testdir/test3.in


*** ../vim-8.0.0442/src/testdir/test3.in	2017-03-05 19:43:44.549127317 +0100
--- src/testdir/test3.in	2017-03-11 18:39:25.284357641 +0100
***************
*** 970,976 ****
  /* end of AUTO */
  
  STARTTEST
! :set tw=0 wm=60 columns=80 noai fo=croq
  /serious/e
  a about life, the universe, and the rest
  ENDTEST
--- 970,977 ----
  /* end of AUTO */
  
  STARTTEST
! :set tw=0 noai fo=croq
! :let &wm = &columns - 20
  /serious/e
  a about life, the universe, and the rest
  ENDTEST
*** ../vim-8.0.0442/src/version.c	2017-03-09 19:21:25.871293655 +0100
--- src/version.c	2017-03-11 18:42:19.095153014 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     443,
  /**/

-- 
From "know your smileys":
 :-| :-|   Deja' vu!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0444
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0444 (after 8.0.0442)
Problem:    Diffpatch fails when the file name has a quote.
Solution:   Escape the name properly. (zetzei)
Files:      src/diff.c, src/testdir/test_diffmode.vim


*** ../vim-8.0.0443/src/diff.c	2017-03-09 19:21:25.867293683 +0100
--- src/diff.c	2017-03-11 19:18:29.732108381 +0100
***************
*** 906,911 ****
--- 906,912 ----
      int		browse_flag = cmdmod.browse;
  #endif
      stat_T	st;
+     char_u	*esc_name = NULL;
  
  #ifdef FEAT_BROWSE
      if (cmdmod.browse)
***************
*** 935,945 ****
      /* Get the absolute path of the patchfile, changing directory below. */
      fullname = FullName_save(eap->arg, FALSE);
  #endif
!     buflen = STRLEN(tmp_orig) + (
  # ifdef UNIX
! 		    fullname != NULL ? STRLEN(fullname) :
  # endif
! 		    STRLEN(eap->arg)) + STRLEN(tmp_new) + 16;
      buf = alloc((unsigned)buflen);
      if (buf == NULL)
  	goto theend;
--- 936,949 ----
      /* Get the absolute path of the patchfile, changing directory below. */
      fullname = FullName_save(eap->arg, FALSE);
  #endif
!     esc_name = vim_strsave_shellescape(
  # ifdef UNIX
! 		    fullname != NULL ? fullname :
  # endif
! 		    eap->arg, TRUE, TRUE);
!     if (esc_name == NULL)
! 	goto theend;
!     buflen = STRLEN(tmp_orig) + STRLEN(esc_name) + STRLEN(tmp_new) + 16;
      buf = alloc((unsigned)buflen);
      if (buf == NULL)
  	goto theend;
***************
*** 977,993 ****
      {
  	/* Build the patch command and execute it.  Ignore errors.  Switch to
  	 * cooked mode to allow the user to respond to prompts. */
! 	vim_snprintf((char *)buf, buflen,
! #ifdef UNIX
! 		"patch -o %s %s < '%s'",
! #else
! 		"patch -o %s %s < \"%s\"",
! #endif
! 		tmp_new, tmp_orig,
! # ifdef UNIX
! 		fullname != NULL ? fullname :
! # endif
! 		eap->arg);
  #ifdef FEAT_AUTOCMD
  	block_autocmds();	/* Avoid ShellCmdPost stuff */
  #endif
--- 981,988 ----
      {
  	/* Build the patch command and execute it.  Ignore errors.  Switch to
  	 * cooked mode to allow the user to respond to prompts. */
! 	vim_snprintf((char *)buf, buflen, "patch -o %s %s < %s",
! 						  tmp_new, tmp_orig, esc_name);
  #ifdef FEAT_AUTOCMD
  	block_autocmds();	/* Avoid ShellCmdPost stuff */
  #endif
***************
*** 1078,1083 ****
--- 1073,1079 ----
  #ifdef UNIX
      vim_free(fullname);
  #endif
+     vim_free(esc_name);
  #ifdef FEAT_BROWSE
      vim_free(browseFile);
      cmdmod.browse = browse_flag;
*** ../vim-8.0.0443/src/testdir/test_diffmode.vim	2017-03-09 19:21:25.871293655 +0100
--- src/testdir/test_diffmode.vim	2017-03-11 19:15:12.109479360 +0100
***************
*** 319,325 ****
    new
    call assert_fails('diffpatch Xpatch', 'E816:')
  
!   for name in ['Xpatch', 'Xpatch$HOME']
      call setline(1, ['1', '2', '3'])
      if name != 'Xpatch'
        call rename('Xpatch', name)
--- 319,325 ----
    new
    call assert_fails('diffpatch Xpatch', 'E816:')
  
!   for name in ['Xpatch', 'Xpatch$HOME', 'Xpa''tch']
      call setline(1, ['1', '2', '3'])
      if name != 'Xpatch'
        call rename('Xpatch', name)
*** ../vim-8.0.0443/src/version.c	2017-03-11 18:42:51.074931537 +0100
--- src/version.c	2017-03-11 19:21:38.110801169 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     444,
  /**/

-- 
From "know your smileys":
 |-(	Contact lenses, but has lost them

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0445
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0445
Problem:    Getpgid is not supported on all systems.
Solution:   Add a configure check.
Files:      src/configure.ac, src/auto/configure, src/config.h.in,
            src/os_unix.c


*** ../vim-8.0.0444/src/configure.ac	2017-03-09 11:58:35.437168385 +0100
--- src/configure.ac	2017-03-11 19:46:48.980301728 +0100
***************
*** 3609,3615 ****
  AC_CHECK_FUNCS(fchdir fchown fsync getcwd getpseudotty \
  	getpwent getpwnam getpwuid getrlimit gettimeofday getwd lstat \
  	memset mkdtemp nanosleep opendir putenv qsort readlink select setenv \
! 	setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction \
  	sigprocmask sigvec strcasecmp strerror strftime stricmp strncasecmp \
  	strnicmp strpbrk strtol tgetent towlower towupper iswupper \
  	usleep utime utimes)
--- 3609,3615 ----
  AC_CHECK_FUNCS(fchdir fchown fsync getcwd getpseudotty \
  	getpwent getpwnam getpwuid getrlimit gettimeofday getwd lstat \
  	memset mkdtemp nanosleep opendir putenv qsort readlink select setenv \
! 	getpgid setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction \
  	sigprocmask sigvec strcasecmp strerror strftime stricmp strncasecmp \
  	strnicmp strpbrk strtol tgetent towlower towupper iswupper \
  	usleep utime utimes)
*** ../vim-8.0.0444/src/auto/configure	2017-03-09 11:58:35.441168357 +0100
--- src/auto/configure	2017-03-11 19:47:15.332118442 +0100
***************
*** 12022,12028 ****
  for ac_func in fchdir fchown fsync getcwd getpseudotty \
  	getpwent getpwnam getpwuid getrlimit gettimeofday getwd lstat \
  	memset mkdtemp nanosleep opendir putenv qsort readlink select setenv \
! 	setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction \
  	sigprocmask sigvec strcasecmp strerror strftime stricmp strncasecmp \
  	strnicmp strpbrk strtol tgetent towlower towupper iswupper \
  	usleep utime utimes
--- 12022,12028 ----
  for ac_func in fchdir fchown fsync getcwd getpseudotty \
  	getpwent getpwnam getpwuid getrlimit gettimeofday getwd lstat \
  	memset mkdtemp nanosleep opendir putenv qsort readlink select setenv \
! 	getpgid setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction \
  	sigprocmask sigvec strcasecmp strerror strftime stricmp strncasecmp \
  	strnicmp strpbrk strtol tgetent towlower towupper iswupper \
  	usleep utime utimes
*** ../vim-8.0.0444/src/config.h.in	2016-12-01 17:25:16.787864672 +0100
--- src/config.h.in	2017-03-11 19:47:10.532151827 +0100
***************
*** 158,164 ****
--- 158,166 ----
  #undef HAVE_FCHOWN
  #undef HAVE_FSEEKO
  #undef HAVE_FSYNC
+ #undef HAVE_FLOAT_FUNCS
  #undef HAVE_GETCWD
+ #undef HAVE_GETPGID
  #undef HAVE_GETPSEUDOTTY
  #undef HAVE_GETPWENT
  #undef HAVE_GETPWNAM
***************
*** 167,179 ****
  #undef HAVE_GETTIMEOFDAY
  #undef HAVE_GETWD
  #undef HAVE_ICONV
- #undef HAVE_NL_LANGINFO_CODESET
  #undef HAVE_LSTAT
  #undef HAVE_MEMSET
  #undef HAVE_MKDTEMP
  #undef HAVE_NANOSLEEP
  #undef HAVE_OPENDIR
- #undef HAVE_FLOAT_FUNCS
  #undef HAVE_PUTENV
  #undef HAVE_QSORT
  #undef HAVE_READLINK
--- 169,180 ----
  #undef HAVE_GETTIMEOFDAY
  #undef HAVE_GETWD
  #undef HAVE_ICONV
  #undef HAVE_LSTAT
  #undef HAVE_MEMSET
  #undef HAVE_MKDTEMP
  #undef HAVE_NANOSLEEP
+ #undef HAVE_NL_LANGINFO_CODESET
  #undef HAVE_OPENDIR
  #undef HAVE_PUTENV
  #undef HAVE_QSORT
  #undef HAVE_READLINK
*** ../vim-8.0.0444/src/os_unix.c	2017-03-05 14:29:08.721325460 +0100
--- src/os_unix.c	2017-03-11 19:44:58.981066785 +0100
***************
*** 3081,3087 ****
  }
  
  /*
!  * Return 1 if "name" can be found in $PATH and executed, 0 if not.
   * If "use_path" is FALSE only check if "name" is executable.
   * Return -1 if unknown.
   */
--- 3081,3087 ----
  }
  
  /*
!  * Return TRUE if "name" can be found in $PATH and executed, FALSE if not.
   * If "use_path" is FALSE only check if "name" is executable.
   * Return -1 if unknown.
   */
***************
*** 5429,5436 ****
--- 5429,5438 ----
  
      /* TODO: have an option to only kill the process, not the group? */
      job_pid = job->jv_pid;
+ #ifdef HAVE_GETPGID
      if (job_pid == getpgid(job_pid))
  	job_pid = -job_pid;
+ #endif
  
      kill(job_pid, sig);
  
*** ../vim-8.0.0444/src/version.c	2017-03-11 19:21:49.230723995 +0100
--- src/version.c	2017-03-11 19:45:55.572673190 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     445,
  /**/

-- 
From "know your smileys":
 <|-) Chinese
 <|-( Chinese and doesn't like these kind of jokes

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0446
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0446
Problem:    The ";" command does not work after characters with a lower byte
            that is NUL.
Solution:   Properly check for not having a previous character. (Hirohito
            Higashi)
Files:      src/Makefile, src/search.c, src/testdir/test_alot_utf8.vim,
            src/testdir/test_charsearch_utf8.vim


*** ../vim-8.0.0445/src/Makefile	2017-03-09 18:19:58.165107821 +0100
--- src/Makefile	2017-03-12 16:16:51.097072348 +0100
***************
*** 2099,2104 ****
--- 2098,2104 ----
  	test_cdo \
  	test_channel \
  	test_charsearch \
+ 	test_charsearch_utf8 \
  	test_changedtick \
  	test_cindent \
  	test_cmdline \
*** ../vim-8.0.0445/src/search.c	2017-03-01 22:17:01.946120304 +0100
--- src/search.c	2017-03-12 16:16:51.101072319 +0100
***************
*** 1643,1649 ****
      }
      else		/* repeat previous search */
      {
! 	if (*lastc == NUL)
  	    return FAIL;
  	if (dir)	/* repeat in opposite direction */
  	    dir = -lastcdir;
--- 1643,1653 ----
      }
      else		/* repeat previous search */
      {
! 	if (*lastc == NUL
! #ifdef FEAT_MBYTE
! 		&& lastc_bytelen == 1
! #endif
! 		)
  	    return FAIL;
  	if (dir)	/* repeat in opposite direction */
  	    dir = -lastcdir;
*** ../vim-8.0.0445/src/testdir/test_alot_utf8.vim	2017-03-08 22:55:14.914181221 +0100
--- src/testdir/test_alot_utf8.vim	2017-03-12 16:16:51.101072319 +0100
***************
*** 6,11 ****
--- 6,12 ----
  " files, so that they can be run by themselves.
  
  set belloff=all
+ source test_charsearch_utf8.vim
  source test_expr_utf8.vim
  source test_matchadd_conceal_utf8.vim
  source test_regexp_utf8.vim
*** ../vim-8.0.0445/src/testdir/test_charsearch_utf8.vim	2017-03-12 16:32:04.946506262 +0100
--- src/testdir/test_charsearch_utf8.vim	2017-03-12 16:16:51.101072319 +0100
***************
*** 0 ****
--- 1,22 ----
+ " Tests for related f{char} and t{char} using utf-8.
+ if !has('multi_byte')
+   finish
+ endif
+ 
+ " Test for t,f,F,T movement commands
+ function! Test_search_cmds()
+   new!
+   call setline(1, "Vim")
+   1
+   normal! f
+   call assert_equal([0, 1, 4, 0], getpos('.'))
+   normal! ;
+   call assert_equal([0, 1, 16, 0], getpos('.'))
+   normal! 2;
+   call assert_equal([0, 1, 43, 0], getpos('.'))
+   normal! ,
+   call assert_equal([0, 1, 28, 0], getpos('.'))
+   bw!
+ endfunction
+ 
+ " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.0.0445/src/version.c	2017-03-11 20:03:37.845266804 +0100
--- src/version.c	2017-03-12 16:18:42.020286627 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     446,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
96. On Super Bowl Sunday, you followed the score by going to the
    Yahoo main page instead of turning on the TV.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0447
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0447
Problem:    Getting font name does not work on X11.
Solution:   Implement gui_mch_get_fontname() for X11.  Add more GUI tests.
            (Kazunobu Kuriyama)
Files:      src/gui_x11.c, src/syntax.c, src/testdir/Make_dos.mak,
            src/testdir/Make_ming.mak, src/testdir/Makefile,
            src/testdir/gui_init.vim, src/testdir/gui_preinit.vim,
            src/testdir/test_gui.vim, src/testdir/test_gui_init.vim,
            Filelist


*** ../vim-8.0.0446/src/gui_x11.c	2017-02-25 16:01:41.062484813 +0100
--- src/gui_x11.c	2017-03-12 16:47:26.975813581 +0100
***************
*** 1992,2005 ****
  #if defined(FEAT_EVAL) || defined(PROTO)
  /*
   * Return the name of font "font" in allocated memory.
-  * Don't know how to get the actual name, thus use the provided name.
   */
      char_u *
! gui_mch_get_fontname(GuiFont font UNUSED, char_u *name)
  {
!     if (name == NULL)
! 	return NULL;
!     return vim_strsave(name);
  }
  #endif
  
--- 1992,2031 ----
  #if defined(FEAT_EVAL) || defined(PROTO)
  /*
   * Return the name of font "font" in allocated memory.
   */
      char_u *
! gui_mch_get_fontname(GuiFont font, char_u *name)
  {
!     char_u *ret = NULL;
! 
!     if (name != NULL && font == NULL)
!     {
! 	/* In this case, there's no way other than doing this. */
! 	ret = vim_strsave(name);
!     }
!     else if (font != NULL)
!     {
! 	/* In this case, try to retrieve the XLFD corresponding to 'font'->fid;
! 	 * if failed, use 'name' unless it's NULL. */
! 	unsigned long value = 0L;
! 
! 	if (XGetFontProperty(font, XA_FONT, &value))
! 	{
! 	    char *xa_font_name = NULL;
! 
! 	    xa_font_name = XGetAtomName(gui.dpy, value);
! 	    if (xa_font_name != NULL)
! 	    {
! 		ret = vim_strsave((char_u *)xa_font_name);
! 		XFree(xa_font_name);
! 	    }
! 	    else if (name != NULL)
! 		ret = vim_strsave(name);
! 	}
! 	else if (name != NULL)
! 	    ret = vim_strsave(name);
!     }
!     return ret;
  }
  #endif
  
*** ../vim-8.0.0446/src/syntax.c	2017-03-05 21:18:21.885452125 +0100
--- src/syntax.c	2017-03-12 16:47:26.975813581 +0100
***************
*** 8169,8175 ****
  	    || HL_TABLE()[idx].sg_gui_fg_name != NULL
  	    || HL_TABLE()[idx].sg_gui_bg_name != NULL
  	    || HL_TABLE()[idx].sg_gui_sp_name != NULL
! 	    || HL_TABLE()[idx].sg_font_name != NUL
  #endif
  	    || (check_link && (HL_TABLE()[idx].sg_set & SG_LINK)));
  }
--- 8169,8175 ----
  	    || HL_TABLE()[idx].sg_gui_fg_name != NULL
  	    || HL_TABLE()[idx].sg_gui_bg_name != NULL
  	    || HL_TABLE()[idx].sg_gui_sp_name != NULL
! 	    || HL_TABLE()[idx].sg_font_name != NULL
  #endif
  	    || (check_link && (HL_TABLE()[idx].sg_set & SG_LINK)));
  }
*** ../vim-8.0.0446/src/testdir/Make_dos.mak	2017-03-08 00:01:31.489347798 +0100
--- src/testdir/Make_dos.mak	2017-03-12 16:47:26.975813581 +0100
***************
*** 126,132 ****
  
  test_gui_init.res: test_gui_init.vim
  	@echo "$(VIMPROG)" > vimcmd
! 	$(VIMPROG) -u NONE -U gui_init.vim $(NO_PLUGINS) -S runtest.vim $*.vim
  	@del vimcmd
  
  opt_test.vim: ../option.c gen_opt_test.vim
--- 126,132 ----
  
  test_gui_init.res: test_gui_init.vim
  	@echo "$(VIMPROG)" > vimcmd
! 	$(VIMPROG) -u gui_preinit.vim -U gui_init.vim $(NO_PLUGINS) -S runtest.vim $*.vim
  	@del vimcmd
  
  opt_test.vim: ../option.c gen_opt_test.vim
*** ../vim-8.0.0446/src/testdir/Make_ming.mak	2017-03-08 00:01:31.489347798 +0100
--- src/testdir/Make_ming.mak	2017-03-12 16:47:26.975813581 +0100
***************
*** 129,135 ****
  
  test_gui_init.res: test_gui_init.vim
  	@echo "$(VIMPROG)" > vimcmd
! 	$(VIMPROG) -u NONE -U gui_init.vim $(NO_PLUGINS) -S runtest.vim $<
  	@$(DEL) vimcmd
  
  opt_test.vim: ../option.c gen_opt_test.vim
--- 129,135 ----
  
  test_gui_init.res: test_gui_init.vim
  	@echo "$(VIMPROG)" > vimcmd
! 	$(VIMPROG) -u gui_preinit_vim -U gui_init.vim $(NO_PLUGINS) -S runtest.vim $<
  	@$(DEL) vimcmd
  
  opt_test.vim: ../option.c gen_opt_test.vim
*** ../vim-8.0.0446/src/testdir/Makefile	2017-03-08 00:01:31.489347798 +0100
--- src/testdir/Makefile	2017-03-12 16:47:26.975813581 +0100
***************
*** 138,144 ****
  
  test_gui_init.res: test_gui_init.vim
  	@echo "$(RUN_GVIMTEST_WITH_GVIMRC)" > vimcmd
! 	$(RUN_VIMTEST) -u NONE -U gui_init.vim $(NO_PLUGINS) -S runtest.vim $<
  	@rm vimcmd
  
  opt_test.vim: ../option.c gen_opt_test.vim
--- 138,144 ----
  
  test_gui_init.res: test_gui_init.vim
  	@echo "$(RUN_GVIMTEST_WITH_GVIMRC)" > vimcmd
! 	$(RUN_VIMTEST) -u gui_preinit.vim -U gui_init.vim $(NO_PLUGINS) -S runtest.vim $<
  	@rm vimcmd
  
  opt_test.vim: ../option.c gen_opt_test.vim
*** ../vim-8.0.0446/src/testdir/gui_init.vim	2017-02-23 19:32:18.068709554 +0100
--- src/testdir/gui_init.vim	2017-03-12 16:47:26.975813581 +0100
***************
*** 2,5 ****
--- 2,6 ----
  
  if has('gui_athena') || has('gui_motif') || has('gui_gtk2') || has('gui_gtk3')
    set guiheadroom=0
+   set guioptions+=p
  endif
*** ../vim-8.0.0446/src/testdir/gui_preinit.vim	2017-03-12 17:09:32.182230067 +0100
--- src/testdir/gui_preinit.vim	2017-03-12 16:47:26.975813581 +0100
***************
*** 0 ****
--- 1,7 ----
+ " vimrc for test_gui_init.vim
+ 
+ " Note that this flag must be added in the .vimrc file, before switching on
+ " syntax or filetype recognition (when the |gvimrc| file is sourced the system
+ " menu has already been loaded; the ":syntax on" and ":filetype on" commands
+ " load the menu too).
+ set guioptions+=M
*** ../vim-8.0.0446/src/testdir/test_gui.vim	2017-03-05 13:48:04.667867105 +0100
--- src/testdir/test_gui.vim	2017-03-12 16:47:26.975813581 +0100
***************
*** 30,35 ****
--- 30,47 ----
    endif
  endfunc
  
+ func Test_colorscheme()
+   let colorscheme_saved = exists('g:colors_name') ? g:colors_name : 'default'
+ 
+   colorscheme torte
+   redraw!
+   sleep 200m
+   call assert_equal('dark', &background)
+ 
+   exec 'colorscheme' colorscheme_saved
+   redraw!
+ endfunc
+ 
  func Test_getfontname_with_arg()
    let skipped = ''
  
***************
*** 40,47 ****
      call assert_equal('', getfontname('notexist'))
  
      " Valid font name. This is usually the real name of 7x13 by default.
!     let fname = '-misc-fixed-medium-r-normal--13-120-75-75-c-70-iso8859-1'
!     call assert_equal(fname, getfontname(fname))
  
    elseif has('gui_gtk2') || has('gui_gnome') || has('gui_gtk3')
      " Invalid font name. The result should be the name plus the default size.
--- 52,59 ----
      call assert_equal('', getfontname('notexist'))
  
      " Valid font name. This is usually the real name of 7x13 by default.
!     let fname = '-Misc-Fixed-Medium-R-Normal--13-120-75-75-C-70-ISO8859-1'
!     call assert_match(fname, getfontname(fname))
  
    elseif has('gui_gtk2') || has('gui_gnome') || has('gui_gtk3')
      " Invalid font name. The result should be the name plus the default size.
***************
*** 68,75 ****
      " 'expected' is the value specified by SetUp() above.
      call assert_equal('Courier 10 Pitch/8/-1/5/50/0/0/0/0/0', fname)
    elseif has('gui_athena') || has('gui_motif')
!     " 'expected' is DFLT_FONT of gui_x11.c.
!     call assert_equal('7x13', fname)
    elseif has('gui_gtk2') || has('gui_gnome') || has('gui_gtk3')
      " 'expected' is DEFAULT_FONT of gui_gtk_x11.c.
      call assert_equal('Monospace 10', fname)
--- 80,88 ----
      " 'expected' is the value specified by SetUp() above.
      call assert_equal('Courier 10 Pitch/8/-1/5/50/0/0/0/0/0', fname)
    elseif has('gui_athena') || has('gui_motif')
!     " 'expected' is DFLT_FONT of gui_x11.c or its real name.
!     let pat = '\(7x13\)\|\(\c-Misc-Fixed-Medium-R-Normal--13-120-75-75-C-70-ISO8859-1\)'
!     call assert_match(pat, fname)
    elseif has('gui_gtk2') || has('gui_gnome') || has('gui_gtk3')
      " 'expected' is DEFAULT_FONT of gui_gtk_x11.c.
      call assert_equal('Monospace 10', fname)
***************
*** 80,85 ****
--- 93,104 ----
    endif
  endfunc
  
+ func Test_getwinpos()
+   call assert_match('Window position: X \d\+, Y \d\+', execute('winpos'))
+   call assert_true(getwinposx() >= 0)
+   call assert_true(getwinposy() >= 0)
+ endfunc
+ 
  func Test_quoteplus()
    let skipped = ''
  
***************
*** 125,130 ****
--- 144,161 ----
    endif
  endfunc
  
+ func Test_set_background()
+   let background_saved = &background
+ 
+   set background&
+   call assert_equal('light', &background)
+ 
+   set background=dark
+   call assert_equal('dark', &background)
+ 
+   let &background = background_saved
+ endfunc
+ 
  func Test_set_balloondelay()
    if !exists('+balloondelay')
      return
***************
*** 248,253 ****
--- 279,324 ----
    let &balloonexpr = balloonexpr_saved
  endfunc
  
+ " Invalid arguments are tested with test_options in conjunction with segfaults
+ " caused by them (Patch 8.0.0357, 24922ec233).
+ func Test_set_guicursor()
+   let guicursor_saved = &guicursor
+ 
+   let default = [
+         \ "n-v-c:block-Cursor/lCursor",
+         \ "ve:ver35-Cursor",
+         \ "o:hor50-Cursor",
+         \ "i-ci:ver25-Cursor/lCursor",
+         \ "r-cr:hor20-Cursor/lCursor",
+         \ "sm:block-Cursor-blinkwait175-blinkoff150-blinkon175"
+         \ ]
+ 
+   " Default Value
+   set guicursor&
+   call assert_equal(join(default, ','), &guicursor)
+ 
+   " Argument List Example 1
+   let opt_list = copy(default)
+   let opt_list[0] = "n-c-v:block-nCursor"
+   exec "set guicursor=" . join(opt_list, ',')
+   call assert_equal(join(opt_list, ','), &guicursor)
+   unlet opt_list
+ 
+   " Argument List Example 2
+   let opt_list = copy(default)
+   let opt_list[3] = "i-ci:ver30-iCursor-blinkwait300-blinkon200-blinkoff150"
+   exec "set guicursor=" . join(opt_list, ',')
+   call assert_equal(join(opt_list, ','), &guicursor)
+   unlet opt_list
+ 
+   " 'a' Mode
+   set guicursor&
+   let &guicursor .= ',a:blinkon0'
+   call assert_equal(join(default, ',') . ",a:blinkon0", &guicursor)
+ 
+   let &guicursor = guicursor_saved
+ endfunc
+ 
  func Test_set_guifont()
    let skipped = ''
  
***************
*** 274,284 ****
      " Non-empty font list with a valid font name.  Should pick up the first
      " valid font.
      set guifont=-notexist1-*,fixed,-notexist2-*
!     call assert_equal('fixed', getfontname())
  
      " Empty list. Should fallback to the built-in default.
      set guifont=
!     call assert_equal('7x13', getfontname())
  
    elseif has('gui_gtk2') || has('gui_gnome') || has('gui_gtk3')
      " For GTK, what we refer to as 'font names' in our manual are actually
--- 345,357 ----
      " Non-empty font list with a valid font name.  Should pick up the first
      " valid font.
      set guifont=-notexist1-*,fixed,-notexist2-*
!     let pat = '\(fixed\)\|\(\c-Misc-Fixed-Medium-R-SemiCondensed--13-120-75-75-C-60-ISO8859-1\)'
!     call assert_match(pat, getfontname())
  
      " Empty list. Should fallback to the built-in default.
      set guifont=
!     let pat = '\(7x13\)\|\(\c-Misc-Fixed-Medium-R-Normal--13-120-75-75-C-70-ISO8859-1\)'
!     call assert_match(pat, getfontname())
  
    elseif has('gui_gtk2') || has('gui_gnome') || has('gui_gtk3')
      " For GTK, what we refer to as 'font names' in our manual are actually
***************
*** 477,486 ****
    endif
  endfunc
  
! func Test_getwinpos()
!   call assert_match('Window position: X \d\+, Y \d\+', execute('winpos'))
!   call assert_true(getwinposx() >= 0)
!   call assert_true(getwinposy() >= 0)
  endfunc
  
  func Test_shell_command()
--- 550,669 ----
    endif
  endfunc
  
! func Test_set_guioptions()
!   let guioptions_saved = &guioptions
!   let duration = '200m'
! 
!   if has('win32')
!     " Default Value
!     set guioptions&
!     call assert_equal('egmrLtT', &guioptions)
! 
!   else
!     " Default Value
!     set guioptions&
!     call assert_equal('aegimrLtT', &guioptions)
! 
!     " To activate scrollbars of type 'L' or 'R'.
!     wincmd v
!     redraw!
! 
!     " Remove all default GUI ornaments
!     set guioptions-=T
!     exec 'sleep' . duration
!     call assert_equal('aegimrLt', &guioptions)
!     set guioptions-=t
!     exec 'sleep' . duration
!     call assert_equal('aegimrL', &guioptions)
!     set guioptions-=L
!     exec 'sleep' . duration
!     call assert_equal('aegimr', &guioptions)
!     set guioptions-=r
!     exec 'sleep' . duration
!     call assert_equal('aegim', &guioptions)
!     set guioptions-=m
!     exec 'sleep' . duration
!     call assert_equal('aegi', &guioptions)
! 
!     " Try non-default GUI ornaments
!     set guioptions+=l
!     exec 'sleep' . duration
!     call assert_equal('aegil', &guioptions)
!     set guioptions-=l
!     exec 'sleep' . duration
!     call assert_equal('aegi', &guioptions)
! 
!     set guioptions+=R
!     exec 'sleep' . duration
!     call assert_equal('aegiR', &guioptions)
!     set guioptions-=R
!     exec 'sleep' . duration
!     call assert_equal('aegi', &guioptions)
! 
!     set guioptions+=b
!     exec 'sleep' . duration
!     call assert_equal('aegib', &guioptions)
!     set guioptions+=h
!     exec 'sleep' . duration
!     call assert_equal('aegibh', &guioptions)
!     set guioptions-=h
!     exec 'sleep' . duration
!     call assert_equal('aegib', &guioptions)
!     set guioptions-=b
!     exec 'sleep' . duration
!     call assert_equal('aegi', &guioptions)
! 
!     set guioptions+=v
!     exec 'sleep' . duration
!     call assert_equal('aegiv', &guioptions)
!     set guioptions-=v
!     exec 'sleep' . duration
!     call assert_equal('aegi', &guioptions)
! 
!     if has('gui_motif')
!       set guioptions+=F
!       exec 'sleep' . duration
!       call assert_equal('aegiF', &guioptions)
!       set guioptions-=F
!       exec 'sleep' . duration
!       call assert_equal('aegi', &guioptions)
!     endif
! 
!     " Restore GUI ornaments to the default state.
!     set guioptions+=m
!     exec 'sleep' . duration
!     call assert_equal('aegim', &guioptions)
!     set guioptions+=r
!     exec 'sleep' . duration
!     call assert_equal('aegimr', &guioptions)
!     set guioptions+=L
!     exec 'sleep' . duration
!     call assert_equal('aegimrL', &guioptions)
!     set guioptions+=t
!     exec 'sleep' . duration
!     call assert_equal('aegimrLt', &guioptions)
!     set guioptions+=T
!     exec 'sleep' . duration
!     call assert_equal("aegimrLtT", &guioptions)
! 
!     wincmd o
!     redraw!
!   endif
! 
!   let &guioptions = guioptions_saved
! endfunc
! 
! func Test_set_guipty()
!   let guipty_saved = &guipty
! 
!   " Default Value
!   set guipty&
!   call assert_equal(1, &guipty)
! 
!   set noguipty
!   call assert_equal(0, &guipty)
! 
!   let &guipty = guipty_saved
  endfunc
  
  func Test_shell_command()
***************
*** 490,495 ****
--- 673,691 ----
    bwipe!
  endfunc
  
+ func Test_syntax_colortest()
+   runtime syntax/colortest.vim
+   redraw!
+   sleep 200m
+   bwipe!
+ endfunc
+ 
+ func Test_set_term()
+   " It's enough to check the current value since setting 'term' to anything
+   " other than builtin_gui makes no sense at all.
+   call assert_equal('builtin_gui', &term)
+ endfunc
+ 
  func Test_windowid_variable()
    if g:x11_based_gui || has('win32')
      call assert_true(v:windowid > 0)
*** ../vim-8.0.0446/src/testdir/test_gui_init.vim	2017-03-04 13:32:06.967801328 +0100
--- src/testdir/test_gui_init.vim	2017-03-12 16:47:26.975813581 +0100
***************
*** 36,38 ****
--- 36,60 ----
      throw skipped
    endif
  endfunc
+ 
+ func Test_set_guioptions_for_M()
+   sleep 200ms
+   " Check if the 'M' option is included.
+   call assert_match('.*M.*', &guioptions)
+ endfunc
+ 
+ func Test_set_guioptions_for_p()
+   let skipped = ''
+ 
+   if !g:x11_based_gui
+     let skipped = g:not_supported . '''p'' of guioptions'
+   else
+     sleep 200ms
+     " Check if the 'p' option is included.
+     call assert_match('.*p.*', &guioptions)
+   endif
+ 
+   if !empty(skipped)
+     throw skipped
+   endif
+ endfunc
*** ../vim-8.0.0446/Filelist	2017-03-07 21:27:01.347786655 +0100
--- Filelist	2017-03-12 16:51:31.186046835 +0100
***************
*** 110,115 ****
--- 110,116 ----
  		src/testdir/setup.vim \
  		src/testdir/gui_init.vim \
  		src/testdir/setup_gui.vim \
+ 		src/testdir/gui_preinit.vim \
  		src/testdir/test[0-9]*.ok \
  		src/testdir/test[0-9]*a.ok \
  		src/testdir/test_[a-z]*.ok \
*** ../vim-8.0.0446/src/version.c	2017-03-12 16:37:50.623999577 +0100
--- src/version.c	2017-03-12 16:49:48.210791546 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     447,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
99. The hum of a cooling fan and the click of keys is comforting to you.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0448
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0448
Problem:    Some macros are in lower case, which can be confusing.
Solution:   Make a few lower case macros upper case.
Files:      src/macros.h, src/buffer.c, src/charset.c, src/ops.c, src/diff.c,
            src/edit.c, src/evalfunc.c, src/ex_cmds.c, src/ex_getln.c,
            src/fileio.c, src/fold.c, src/gui.c, src/gui_beval.c, src/main.c,
            src/mark.c, src/misc1.c, src/move.c, src/normal.c, src/ops.c,
            src/option.c, src/popupmnu.c, src/regexp.c, src/screen.c,
            src/search.c, src/spell.c, src/tag.c, src/ui.c, src/undo.c,
	    src/version.c, src/workshop.c, src/if_perl.xs



*** ../vim-8.0.0447/src/macros.h	2016-11-06 14:17:13.182972857 +0100
--- src/macros.h	2017-03-12 18:10:53.595395697 +0100
***************
*** 11,56 ****
   */
  
  /*
!  * pchar(lp, c) - put character 'c' at position 'lp'
   */
! #define pchar(lp, c) (*(ml_get_buf(curbuf, (lp).lnum, TRUE) + (lp).col) = (c))
  
  /*
   * Position comparisons
   */
  #ifdef FEAT_VIRTUALEDIT
! # define lt(a, b) (((a).lnum != (b).lnum) \
  		   ? (a).lnum < (b).lnum \
  		   : (a).col != (b).col \
  		       ? (a).col < (b).col \
  		       : (a).coladd < (b).coladd)
! # define ltp(a, b) (((a)->lnum != (b)->lnum) \
  		   ? (a)->lnum < (b)->lnum \
  		   : (a)->col != (b)->col \
  		       ? (a)->col < (b)->col \
  		       : (a)->coladd < (b)->coladd)
! # define equalpos(a, b) (((a).lnum == (b).lnum) && ((a).col == (b).col) && ((a).coladd == (b).coladd))
! # define clearpos(a) {(a)->lnum = 0; (a)->col = 0; (a)->coladd = 0;}
  #else
! # define lt(a, b) (((a).lnum != (b).lnum) \
  		   ? ((a).lnum < (b).lnum) : ((a).col < (b).col))
! # define ltp(a, b) (((a)->lnum != (b)->lnum) \
  		   ? ((a)->lnum < (b)->lnum) : ((a)->col < (b)->col))
! # define equalpos(a, b) (((a).lnum == (b).lnum) && ((a).col == (b).col))
! # define clearpos(a) {(a)->lnum = 0; (a)->col = 0;}
  #endif
  
! #define ltoreq(a, b) (lt(a, b) || equalpos(a, b))
  
  /*
!  * lineempty() - return TRUE if the line is empty
   */
! #define lineempty(p) (*ml_get(p) == NUL)
  
  /*
!  * bufempty() - return TRUE if the current buffer is empty
   */
! #define bufempty() (curbuf->b_ml.ml_line_count == 1 && *ml_get((linenr_T)1) == NUL)
  
  /*
   * toupper() and tolower() that use the current locale.
--- 11,56 ----
   */
  
  /*
!  * PCHAR(lp, c) - put character 'c' at position 'lp'
   */
! #define PCHAR(lp, c) (*(ml_get_buf(curbuf, (lp).lnum, TRUE) + (lp).col) = (c))
  
  /*
   * Position comparisons
   */
  #ifdef FEAT_VIRTUALEDIT
! # define LT_POS(a, b) (((a).lnum != (b).lnum) \
  		   ? (a).lnum < (b).lnum \
  		   : (a).col != (b).col \
  		       ? (a).col < (b).col \
  		       : (a).coladd < (b).coladd)
! # define LT_POSP(a, b) (((a)->lnum != (b)->lnum) \
  		   ? (a)->lnum < (b)->lnum \
  		   : (a)->col != (b)->col \
  		       ? (a)->col < (b)->col \
  		       : (a)->coladd < (b)->coladd)
! # define EQUAL_POS(a, b) (((a).lnum == (b).lnum) && ((a).col == (b).col) && ((a).coladd == (b).coladd))
! # define CLEAR_POS(a) {(a)->lnum = 0; (a)->col = 0; (a)->coladd = 0;}
  #else
! # define LT_POS(a, b) (((a).lnum != (b).lnum) \
  		   ? ((a).lnum < (b).lnum) : ((a).col < (b).col))
! # define LT_POSP(a, b) (((a)->lnum != (b)->lnum) \
  		   ? ((a)->lnum < (b)->lnum) : ((a)->col < (b)->col))
! # define EQUAL_POS(a, b) (((a).lnum == (b).lnum) && ((a).col == (b).col))
! # define CLEAR_POS(a) {(a)->lnum = 0; (a)->col = 0;}
  #endif
  
! #define LTOREQ_POS(a, b) (LT_POS(a, b) || EQUAL_POS(a, b))
  
  /*
!  * LINEEMPTY() - return TRUE if the line is empty
   */
! #define LINEEMPTY(p) (*ml_get(p) == NUL)
  
  /*
!  * BUFEMPTY() - return TRUE if the current buffer is empty
   */
! #define BUFEMPTY() (curbuf->b_ml.ml_line_count == 1 && *ml_get((linenr_T)1) == NUL)
  
  /*
   * toupper() and tolower() that use the current locale.
*** ../vim-8.0.0447/src/buffer.c	2017-03-05 17:43:10.616245604 +0100
--- src/buffer.c	2017-03-12 18:08:25.288475574 +0100
***************
*** 111,117 ****
      {
  	/* Set or reset 'modified' before executing autocommands, so that
  	 * it can be changed there. */
! 	if (!readonlymode && !bufempty())
  	    changed();
  	else if (retval == OK)
  	    unchanged(curbuf, FALSE);
--- 111,117 ----
      {
  	/* Set or reset 'modified' before executing autocommands, so that
  	 * it can be changed there. */
! 	if (!readonlymode && !BUFEMPTY())
  	    changed();
  	else if (retval == OK)
  	    unchanged(curbuf, FALSE);
***************
*** 1959,1965 ****
  	    && curbuf != NULL
  	    && curbuf->b_ffname == NULL
  	    && curbuf->b_nwindows <= 1
! 	    && (curbuf->b_ml.ml_mfp == NULL || bufempty()))
      {
  	buf = curbuf;
  #ifdef FEAT_AUTOCMD
--- 1959,1965 ----
  	    && curbuf != NULL
  	    && curbuf->b_ffname == NULL
  	    && curbuf->b_nwindows <= 1
! 	    && (curbuf->b_ml.ml_mfp == NULL || BUFEMPTY()))
      {
  	buf = curbuf;
  #ifdef FEAT_AUTOCMD
***************
*** 2334,2340 ****
  	/* If 'switchbuf' contains "split", "vsplit" or "newtab" and the
  	 * current buffer isn't empty: open new tab or window */
  	if (wp == NULL && (swb_flags & (SWB_VSPLIT | SWB_SPLIT | SWB_NEWTAB))
! 							       && !bufempty())
  	{
  	    if (swb_flags & SWB_NEWTAB)
  		tabpage_new();
--- 2334,2340 ----
  	/* If 'switchbuf' contains "split", "vsplit" or "newtab" and the
  	 * current buffer isn't empty: open new tab or window */
  	if (wp == NULL && (swb_flags & (SWB_VSPLIT | SWB_SPLIT | SWB_NEWTAB))
! 							       && !BUFEMPTY())
  	{
  	    if (swb_flags & SWB_NEWTAB)
  		tabpage_new();
***************
*** 5017,5023 ****
  #ifdef FEAT_WINDOWS
      /* ":drop all" should re-use an empty window to avoid "--remote-tab"
       * leaving an empty tab page when executed locally. */
!     if (keep_tabs && bufempty() && curbuf->b_nwindows == 1
  			    && curbuf->b_ffname == NULL && !curbuf->b_changed)
  	use_firstwin = TRUE;
  #endif
--- 5017,5023 ----
  #ifdef FEAT_WINDOWS
      /* ":drop all" should re-use an empty window to avoid "--remote-tab"
       * leaving an empty tab page when executed locally. */
!     if (keep_tabs && BUFEMPTY() && curbuf->b_nwindows == 1
  			    && curbuf->b_ffname == NULL && !curbuf->b_changed)
  	use_firstwin = TRUE;
  #endif
*** ../vim-8.0.0447/src/charset.c	2017-02-05 15:10:47.743484042 +0100
--- src/charset.c	2017-03-12 18:00:43.599849485 +0100
***************
*** 1403,1409 ****
  		&& (State & NORMAL)
  		&& !wp->w_p_list
  		&& !virtual_active()
! 		&& !(VIsual_active && (*p_sel == 'e' || ltoreq(*pos, VIsual)))
  		)
  	    *cursor = vcol + incr - 1;	    /* cursor at end */
  	else
--- 1403,1410 ----
  		&& (State & NORMAL)
  		&& !wp->w_p_list
  		&& !virtual_active()
! 		&& !(VIsual_active
! 				&& (*p_sel == 'e' || LTOREQ_POS(*pos, VIsual)))
  		)
  	    *cursor = vcol + incr - 1;	    /* cursor at end */
  	else
***************
*** 1496,1502 ****
  {
      colnr_T	from1, from2, to1, to2;
  
!     if (ltp(pos1, pos2))
      {
  	getvvcol(wp, pos1, &from1, NULL, &to1);
  	getvvcol(wp, pos2, &from2, NULL, &to2);
--- 1497,1503 ----
  {
      colnr_T	from1, from2, to1, to2;
  
!     if (LT_POSP(pos1, pos2))
      {
  	getvvcol(wp, pos1, &from1, NULL, &to1);
  	getvvcol(wp, pos2, &from2, NULL, &to2);
*** ../vim-8.0.0447/src/ops.c	2017-03-05 18:02:59.999101021 +0100
--- src/ops.c	2017-03-12 18:09:38.955939134 +0100
***************
*** 2190,2196 ****
  	else if (!oap->inclusive)
  	    dec(&(oap->end));
  
! 	while (ltoreq(curwin->w_cursor, oap->end))
  	{
  	    n = gchar_cursor();
  	    if (n != NUL)
--- 2190,2196 ----
  	else if (!oap->inclusive)
  	    dec(&(oap->end));
  
! 	while (LTOREQ_POS(curwin->w_cursor, oap->end))
  	{
  	    n = gchar_cursor();
  	    if (n != NUL)
***************
*** 2229,2235 ****
  			    getvpos(&oap->end, end_vcol);
  		    }
  #endif
! 		    pchar(curwin->w_cursor, c);
  		}
  	    }
  #ifdef FEAT_VIRTUALEDIT
--- 2229,2235 ----
  			    getvpos(&oap->end, end_vcol);
  		    }
  #endif
! 		    PCHAR(curwin->w_cursor, c);
  		}
  	    }
  #ifdef FEAT_VIRTUALEDIT
***************
*** 2248,2254 ****
  		curwin->w_cursor.col -= (virtcols + 1);
  		for (; virtcols >= 0; virtcols--)
  		{
! 		    pchar(curwin->w_cursor, c);
  		    if (inc(&curwin->w_cursor) == -1)
  			break;
  		}
--- 2248,2254 ----
  		curwin->w_cursor.col -= (virtcols + 1);
  		for (; virtcols >= 0; virtcols--)
  		{
! 		    PCHAR(curwin->w_cursor, c);
  		    if (inc(&curwin->w_cursor) == -1)
  			break;
  		}
***************
*** 2338,2344 ****
  		did_change |= swapchars(oap->op_type, &pos,
  				pos.lnum == oap->end.lnum ? oap->end.col + 1:
  					   (int)STRLEN(ml_get_pos(&pos)));
! 		if (ltoreq(oap->end, pos) || inc(&pos) == -1)
  		    break;
  	    }
  	if (did_change)
--- 2338,2344 ----
  		did_change |= swapchars(oap->op_type, &pos,
  				pos.lnum == oap->end.lnum ? oap->end.col + 1:
  					   (int)STRLEN(ml_get_pos(&pos)));
! 		if (LTOREQ_POS(oap->end, pos) || inc(&pos) == -1)
  		    break;
  	    }
  	if (did_change)
***************
*** 2490,2496 ****
  	}
  	else
  #endif
! 	    pchar(*pos, nc);
  	return TRUE;
      }
      return FALSE;
--- 2490,2496 ----
  	}
  	else
  #endif
! 	    PCHAR(*pos, nc);
  	return TRUE;
      }
      return FALSE;
***************
*** 2575,2581 ****
  	    check_cursor_col();
  
  	    /* Works just like an 'i'nsert on the next character. */
! 	    if (!lineempty(curwin->w_cursor.lnum)
  		    && oap->start_vcol != oap->end_vcol)
  		inc_cursor();
  	}
--- 2575,2581 ----
  	    check_cursor_col();
  
  	    /* Works just like an 'i'nsert on the next character. */
! 	    if (!LINEEMPTY(curwin->w_cursor.lnum)
  		    && oap->start_vcol != oap->end_vcol)
  		inc_cursor();
  	}
***************
*** 2588,2594 ****
       * have been converted to a tab as well, the column of the cursor
       * might have actually been reduced, so need to adjust here. */
      if (t1.lnum == curbuf->b_op_start_orig.lnum
! 	    && lt(curbuf->b_op_start_orig, t1))
  	oap->start = curbuf->b_op_start_orig;
  
      /* If user has moved off this line, we don't know what to do, so do
--- 2588,2594 ----
       * have been converted to a tab as well, the column of the cursor
       * might have actually been reduced, so need to adjust here. */
      if (t1.lnum == curbuf->b_op_start_orig.lnum
! 	    && LT_POS(curbuf->b_op_start_orig, t1))
  	oap->start = curbuf->b_op_start_orig;
  
      /* If user has moved off this line, we don't know what to do, so do
***************
*** 2735,2741 ****
      else if (op_delete(oap) == FAIL)
  	return FALSE;
  
!     if ((l > curwin->w_cursor.col) && !lineempty(curwin->w_cursor.lnum)
  							 && !virtual_op)
  	inc_cursor();
  
--- 2735,2741 ----
      else if (op_delete(oap) == FAIL)
  	return FALSE;
  
!     if ((l > curwin->w_cursor.col) && !LINEEMPTY(curwin->w_cursor.lnum)
  							 && !virtual_op)
  	inc_cursor();
  
***************
*** 3519,3525 ****
  	    ++lnum;
  	/* In an empty buffer the empty line is going to be replaced, include
  	 * it in the saved lines. */
! 	if ((bufempty() ? u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL)
  	    goto end;
  #ifdef FEAT_FOLDING
  	if (dir == FORWARD)
--- 3519,3525 ----
  	    ++lnum;
  	/* In an empty buffer the empty line is going to be replaced, include
  	 * it in the saved lines. */
! 	if ((BUFEMPTY() ? u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL)
  	    goto end;
  #ifdef FEAT_FOLDING
  	if (dir == FORWARD)
***************
*** 4936,4942 ****
  		    && prev_is_end_par
  		    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)
  	    {
! 		if (do_second_indent && !lineempty(curwin->w_cursor.lnum + 1))
  		{
  #ifdef FEAT_COMMENTS
  		    if (leader_len == 0 && next_leader_len == 0)
--- 4936,4942 ----
  		    && prev_is_end_par
  		    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)
  	    {
! 		if (do_second_indent && !LINEEMPTY(curwin->w_cursor.lnum + 1))
  		{
  #ifdef FEAT_COMMENTS
  		    if (leader_len == 0 && next_leader_len == 0)
***************
*** 7237,7243 ****
  
  	if (VIsual_active)
  	{
! 	    if (lt(VIsual, curwin->w_cursor))
  	    {
  		min_pos = VIsual;
  		max_pos = curwin->w_cursor;
--- 7237,7243 ----
  
  	if (VIsual_active)
  	{
! 	    if (LT_POS(VIsual, curwin->w_cursor))
  	    {
  		min_pos = VIsual;
  		max_pos = curwin->w_cursor;
*** ../vim-8.0.0447/src/diff.c	2017-03-11 19:21:49.230723995 +0100
--- src/diff.c	2017-03-12 18:08:48.364307530 +0100
***************
*** 2333,2339 ****
  		    end_skip = 0;
  	    }
  
! 	    buf_empty = bufempty();
  	    added = 0;
  	    for (i = 0; i < count; ++i)
  	    {
--- 2333,2339 ----
  		    end_skip = 0;
  	    }
  
! 	    buf_empty = BUFEMPTY();
  	    added = 0;
  	    for (i = 0; i < count; ++i)
  	    {
*** ../vim-8.0.0447/src/edit.c	2017-03-09 18:19:58.157107877 +0100
--- src/edit.c	2017-03-12 18:08:55.384256409 +0100
***************
*** 408,414 ****
  	 * the "A" command, thus set State to avoid that. Also check that the
  	 * line number is still valid (lines may have been deleted).
  	 * Do not restore if v:char was set to a non-empty string. */
! 	if (!equalpos(curwin->w_cursor, save_cursor)
  # ifdef FEAT_EVAL
  		&& *get_vim_var_str(VV_CHAR) == NUL
  # endif
--- 408,414 ----
  	 * the "A" command, thus set State to avoid that. Also check that the
  	 * line number is still valid (lines may have been deleted).
  	 * Do not restore if v:char was set to a non-empty string. */
! 	if (!EQUAL_POS(curwin->w_cursor, save_cursor)
  # ifdef FEAT_EVAL
  		&& *get_vim_var_str(VV_CHAR) == NUL
  # endif
***************
*** 1631,1637 ****
  # endif
  		)
  # ifdef FEAT_AUTOCMD
! 	&& !equalpos(last_cursormoved, curwin->w_cursor)
  # endif
  # ifdef FEAT_INS_EXPAND
  	&& !pum_visible()
--- 1631,1637 ----
  # endif
  		)
  # ifdef FEAT_AUTOCMD
! 	&& !EQUAL_POS(last_cursormoved, curwin->w_cursor)
  # endif
  # ifdef FEAT_INS_EXPAND
  	&& !pum_visible()
***************
*** 4130,4136 ****
      }
      curwin->w_cursor = pos;	/* restore the cursor position */
      validate_cursor();
!     if (!equalpos(curwin->w_cursor, pos))
      {
  	EMSG(_(e_compldel));
  	goto theend;
--- 4130,4136 ----
      }
      curwin->w_cursor = pos;	/* restore the cursor position */
      validate_cursor();
!     if (!EQUAL_POS(curwin->w_cursor, pos))
      {
  	EMSG(_(e_compldel));
  	goto theend;
***************
*** 5408,5414 ****
  	    }
  	    curwin->w_cursor = pos;	/* restore the cursor position */
  	    validate_cursor();
! 	    if (!equalpos(curwin->w_cursor, pos))
  	    {
  		EMSG(_(e_compldel));
  		return FAIL;
--- 5408,5414 ----
  	    }
  	    curwin->w_cursor = pos;	/* restore the cursor position */
  	    validate_cursor();
! 	    if (!EQUAL_POS(curwin->w_cursor, pos))
  	    {
  		EMSG(_(e_compldel));
  		return FAIL;
***************
*** 8947,8953 ****
       * can't backup past starting point unless 'backspace' > 1
       * can backup to a previous line if 'backspace' == 0
       */
!     if (       bufempty()
  	    || (
  #ifdef FEAT_RIGHTLEFT
  		!revins_on &&
--- 8947,8953 ----
       * can't backup past starting point unless 'backspace' > 1
       * can backup to a previous line if 'backspace' == 0
       */
!     if (       BUFEMPTY()
  	    || (
  #ifdef FEAT_RIGHTLEFT
  		!revins_on &&
***************
*** 9462,9468 ****
      }
  # endif
  
!     if (!equalpos(curwin->w_cursor, tpos))
      {
  	start_arrow(&tpos);
  # ifdef FEAT_CINDENT
--- 9462,9468 ----
      }
  # endif
  
!     if (!EQUAL_POS(curwin->w_cursor, tpos))
      {
  	start_arrow(&tpos);
  # ifdef FEAT_CINDENT
*** ../vim-8.0.0447/src/evalfunc.c	2017-03-09 18:19:58.161107848 +0100
--- src/evalfunc.c	2017-03-12 18:04:52.098030950 +0100
***************
*** 9552,9571 ****
  
      save_cursor = curwin->w_cursor;
      pos = curwin->w_cursor;
!     clearpos(&firstpos);
!     clearpos(&foundpos);
      pat = pat3;
      for (;;)
      {
  	n = searchit(curwin, curbuf, &pos, dir, pat, 1L,
  					   options, RE_SEARCH, lnum_stop, &tm);
! 	if (n == FAIL || (firstpos.lnum != 0 && equalpos(pos, firstpos)))
  	    /* didn't find it or found the first match again: FAIL */
  	    break;
  
  	if (firstpos.lnum == 0)
  	    firstpos = pos;
! 	if (equalpos(pos, foundpos))
  	{
  	    /* Found the same position again.  Can happen with a pattern that
  	     * has "\zs" at the end and searching backwards.  Advance one
--- 9552,9571 ----
  
      save_cursor = curwin->w_cursor;
      pos = curwin->w_cursor;
!     CLEAR_POS(&firstpos);
!     CLEAR_POS(&foundpos);
      pat = pat3;
      for (;;)
      {
  	n = searchit(curwin, curbuf, &pos, dir, pat, 1L,
  					   options, RE_SEARCH, lnum_stop, &tm);
! 	if (n == FAIL || (firstpos.lnum != 0 && EQUAL_POS(pos, firstpos)))
  	    /* didn't find it or found the first match again: FAIL */
  	    break;
  
  	if (firstpos.lnum == 0)
  	    firstpos = pos;
! 	if (EQUAL_POS(pos, foundpos))
  	{
  	    /* Found the same position again.  Can happen with a pattern that
  	     * has "\zs" at the end and searching backwards.  Advance one
*** ../vim-8.0.0447/src/ex_cmds.c	2017-02-26 14:00:03.852862844 +0100
--- src/ex_cmds.c	2017-03-12 17:57:57.817063790 +0100
***************
*** 851,874 ****
       * their final destination at the new text position -- webb
       */
      last_line = curbuf->b_ml.ml_line_count;
!     mark_adjust(line1, line2, last_line - line2, 0L);
!     changed_lines(last_line - num_lines + 1, 0, last_line + 1, num_lines);
      if (dest >= line2)
      {
! 	mark_adjust(line2 + 1, dest, -num_lines, 0L);
  	curbuf->b_op_start.lnum = dest - num_lines + 1;
  	curbuf->b_op_end.lnum = dest;
      }
      else
      {
! 	mark_adjust(dest + 1, line1 - 1, num_lines, 0L);
  	curbuf->b_op_start.lnum = dest + 1;
  	curbuf->b_op_end.lnum = dest + num_lines;
      }
      curbuf->b_op_start.col = curbuf->b_op_end.col = 0;
!     mark_adjust(last_line - num_lines + 1, last_line,
  					     -(last_line - dest - extra), 0L);
-     changed_lines(last_line - num_lines + 1, 0, last_line + 1, -extra);
  
      /*
       * Now we delete the original text -- webb
--- 851,891 ----
       * their final destination at the new text position -- webb
       */
      last_line = curbuf->b_ml.ml_line_count;
!     mark_adjust_nofold(line1, line2, last_line - line2, 0L);
      if (dest >= line2)
      {
! 	mark_adjust_nofold(line2 + 1, dest, -num_lines, 0L);
! #ifdef FEAT_FOLDING
! 	win_T	    *win;
! 	tabpage_T   *tp;
! 
! 	FOR_ALL_TAB_WINDOWS(tp, win) {
! 	    if (win->w_buffer == curbuf)
! 		foldSwapRange(&win->w_folds, line1, line2, dest + 1,
! 			dest + num_lines);
! 	}
! #endif
  	curbuf->b_op_start.lnum = dest - num_lines + 1;
  	curbuf->b_op_end.lnum = dest;
      }
      else
      {
! 	mark_adjust_nofold(dest + 1, line1 - 1, num_lines, 0L);
! #ifdef FEAT_FOLDING
! 	win_T	    *win;
! 	tabpage_T   *tp;
! 
! 	FOR_ALL_TAB_WINDOWS(tp, win) {
! 	    if (win->w_buffer == curbuf)
! 		foldSwapRange(&win->w_folds, dest + 1, line1 - 1, line1, line2);
! 	}
! #endif
  	curbuf->b_op_start.lnum = dest + 1;
  	curbuf->b_op_end.lnum = dest + num_lines;
      }
      curbuf->b_op_start.col = curbuf->b_op_end.col = 0;
!     mark_adjust_nofold(last_line - num_lines + 1, last_line,
  					     -(last_line - dest - extra), 0L);
  
      /*
       * Now we delete the original text -- webb
***************
*** 4211,4217 ****
  
  	/* If autocommands change the cursor position or topline, we should
  	 * keep it.  Also when it moves within a line. */
! 	if (!equalpos(curwin->w_cursor, orig_pos))
  	{
  	    newlnum = curwin->w_cursor.lnum;
  	    newcol = curwin->w_cursor.col;
--- 4228,4234 ----
  
  	/* If autocommands change the cursor position or topline, we should
  	 * keep it.  Also when it moves within a line. */
! 	if (!EQUAL_POS(curwin->w_cursor, orig_pos))
  	{
  	    newlnum = curwin->w_cursor.lnum;
  	    newcol = curwin->w_cursor.col;
*** ../vim-8.0.0447/src/ex_getln.c	2017-02-26 14:00:03.852862844 +0100
--- src/ex_getln.c	2017-03-12 18:04:55.590005409 +0100
***************
*** 234,240 ****
  
      ccline.overstrike = FALSE;		    /* always start in insert mode */
  #ifdef FEAT_SEARCH_EXTRA
!     clearpos(&match_end);
      save_cursor = curwin->w_cursor;	    /* may be restored later */
      search_start = curwin->w_cursor;
      old_curswant = curwin->w_curswant;
--- 234,240 ----
  
      ccline.overstrike = FALSE;		    /* always start in insert mode */
  #ifdef FEAT_SEARCH_EXTRA
!     CLEAR_POS(&match_end);
      save_cursor = curwin->w_cursor;	    /* may be restored later */
      search_start = curwin->w_cursor;
      old_curswant = curwin->w_curswant;
***************
*** 1479,1485 ****
  		    if (did_incsearch)
  		    {
  			curwin->w_cursor = match_end;
! 			if (!equalpos(curwin->w_cursor, search_start))
  			{
  			    c = gchar_cursor();
  			    /* If 'ignorecase' and 'smartcase' are set and the
--- 1479,1485 ----
  		    if (did_incsearch)
  		    {
  			curwin->w_cursor = match_end;
! 			if (!EQUAL_POS(curwin->w_cursor, search_start))
  			{
  			    c = gchar_cursor();
  			    /* If 'ignorecase' and 'smartcase' are set and the
***************
*** 1707,1713 ****
  			    search_start = t;
  			    (void)decl(&search_start);
  			}
! 			if (lt(t, search_start) && c == Ctrl_G)
  			{
  			    /* wrap around */
  			    search_start = t;
--- 1707,1713 ----
  			    search_start = t;
  			    (void)decl(&search_start);
  			}
! 			if (LT_POS(t, search_start) && c == Ctrl_G)
  			{
  			    /* wrap around */
  			    search_start = t;
***************
*** 2007,2013 ****
  	    curwin->w_cursor = save_cursor;
  	else
  	{
! 	    if (!equalpos(save_cursor, search_start))
  	    {
  		/* put the '" mark at the original position */
  		curwin->w_cursor = save_cursor;
--- 2007,2013 ----
  	    curwin->w_cursor = save_cursor;
  	else
  	{
! 	    if (!EQUAL_POS(save_cursor, search_start))
  	    {
  		/* put the '" mark at the original position */
  		curwin->w_cursor = save_cursor;
*** ../vim-8.0.0447/src/fileio.c	2017-02-25 14:59:29.906090427 +0100
--- src/fileio.c	2017-03-12 18:09:15.736108210 +0100
***************
*** 7118,7124 ****
  	 * the old contents.  Can't use memory only, the file might be
  	 * too big.  Use a hidden buffer to move the buffer contents to.
  	 */
! 	if (bufempty() || saved == FAIL)
  	    savebuf = NULL;
  	else
  	{
--- 7118,7124 ----
  	 * the old contents.  Can't use memory only, the file might be
  	 * too big.  Use a hidden buffer to move the buffer contents to.
  	 */
! 	if (BUFEMPTY() || saved == FAIL)
  	    savebuf = NULL;
  	else
  	{
***************
*** 7161,7167 ****
  		{
  		    /* Put the text back from the save buffer.  First
  		     * delete any lines that readfile() added. */
! 		    while (!bufempty())
  			if (ml_delete(buf->b_ml.ml_line_count, FALSE) == FAIL)
  			    break;
  		    (void)move_lines(savebuf, buf);
--- 7161,7167 ----
  		{
  		    /* Put the text back from the save buffer.  First
  		     * delete any lines that readfile() added. */
! 		    while (!BUFEMPTY())
  			if (ml_delete(buf->b_ml.ml_line_count, FALSE) == FAIL)
  			    break;
  		    (void)move_lines(savebuf, buf);
*** ../vim-8.0.0447/src/fold.c	2017-03-04 18:42:35.715691765 +0100
--- src/fold.c	2017-03-12 18:00:58.355741445 +0100
***************
*** 1039,1045 ****
      if (!VIsual_active || !hasAnyFolding(curwin))
  	return;
  
!     if (ltoreq(VIsual, curwin->w_cursor))
      {
  	start = &VIsual;
  	end = &curwin->w_cursor;
--- 1040,1046 ----
      if (!VIsual_active || !hasAnyFolding(curwin))
  	return;
  
!     if (LTOREQ_POS(VIsual, curwin->w_cursor))
      {
  	start = &VIsual;
  	end = &curwin->w_cursor;
*** ../vim-8.0.0447/src/gui.c	2017-02-03 22:01:43.938349448 +0100
--- src/gui.c	2017-03-12 17:58:08.268987207 +0100
***************
*** 4476,4482 ****
  	pum_redraw();
  #endif
  
!     return (wp == curwin && !equalpos(curwin->w_cursor, old_cursor));
  }
  
  
--- 4476,4482 ----
  	pum_redraw();
  #endif
  
!     return (wp == curwin && !EQUAL_POS(curwin->w_cursor, old_cursor));
  }
  
  
***************
*** 5118,5124 ****
  		curwin->w_p_cole > 0
  # endif
  		)
! 		     && !equalpos(last_cursormoved, curwin->w_cursor))
      {
  # ifdef FEAT_AUTOCMD
  	if (has_cursormoved())
--- 5118,5124 ----
  		curwin->w_p_cole > 0
  # endif
  		)
! 		     && !EQUAL_POS(last_cursormoved, curwin->w_cursor))
      {
  # ifdef FEAT_AUTOCMD
  	if (has_cursormoved())
*** ../vim-8.0.0447/src/gui_beval.c	2016-11-17 19:11:51.713378271 +0100
--- src/gui_beval.c	2017-03-12 17:54:45.174475990 +0100
***************
*** 84,90 ****
  	    result = eval_to_string(bexpr, NULL, TRUE);
  
  	    /* Remove one trailing newline, it is added when the result was a
! 	     * list and it's hardly every useful.  If the user really wants a
  	     * trailing newline he can add two and one remains. */
  	    if (result != NULL)
  	    {
--- 84,90 ----
  	    result = eval_to_string(bexpr, NULL, TRUE);
  
  	    /* Remove one trailing newline, it is added when the result was a
! 	     * list and it's hardly ever useful.  If the user really wants a
  	     * trailing newline he can add two and one remains. */
  	    if (result != NULL)
  	    {
***************
*** 366,372 ****
  
  		    if (VIsual_active)
  		    {
! 			if (lt(VIsual, curwin->w_cursor))
  			{
  			    spos = &VIsual;
  			    epos = &curwin->w_cursor;
--- 366,372 ----
  
  		    if (VIsual_active)
  		    {
! 			if (LT_POS(VIsual, curwin->w_cursor))
  			{
  			    spos = &VIsual;
  			    epos = &curwin->w_cursor;
*** ../vim-8.0.0447/src/main.c	2017-03-05 17:43:10.620245573 +0100
--- src/main.c	2017-03-12 17:58:11.256965313 +0100
***************
*** 1144,1150 ****
  # endif
  			)
  # ifdef FEAT_AUTOCMD
! 		 && !equalpos(last_cursormoved, curwin->w_cursor)
  # endif
  		 )
  	    {
--- 1144,1150 ----
  # endif
  			)
  # ifdef FEAT_AUTOCMD
! 		 && !EQUAL_POS(last_cursormoved, curwin->w_cursor)
  # endif
  		 )
  	    {
***************
*** 3557,3564 ****
--- 3568,3578 ----
  			   && vim_FullName(argv0, buf, MAXPATHL, TRUE) != FAIL)
  	    val = buf;
      }
+ #  endif
  # endif
+ 
      set_vim_var_string(VV_PROGPATH, val, -1);
+ 
  # ifdef WIN32
      vim_free(path);
  # endif
*** ../vim-8.0.0447/src/mark.c	2017-01-28 18:23:49.725039260 +0100
--- src/mark.c	2017-03-12 17:58:35.896784789 +0100
***************
*** 206,212 ****
  checkpcmark(void)
  {
      if (curwin->w_prev_pcmark.lnum != 0
! 	    && (equalpos(curwin->w_pcmark, curwin->w_cursor)
  		|| curwin->w_pcmark.lnum == 0))
      {
  	curwin->w_pcmark = curwin->w_prev_pcmark;
--- 208,214 ----
  checkpcmark(void)
  {
      if (curwin->w_prev_pcmark.lnum != 0
! 	    && (EQUAL_POS(curwin->w_pcmark, curwin->w_cursor)
  		|| curwin->w_pcmark.lnum == 0))
      {
  	curwin->w_pcmark = curwin->w_prev_pcmark;
***************
*** 401,407 ****
      {
  	startp = &buf->b_visual.vi_start;
  	endp = &buf->b_visual.vi_end;
! 	if (((c == '<') == lt(*startp, *endp) || endp->lnum == 0)
  							  && startp->lnum != 0)
  	    posp = startp;
  	else
--- 403,409 ----
      {
  	startp = &buf->b_visual.vi_start;
  	endp = &buf->b_visual.vi_end;
! 	if (((c == '<') == LT_POS(*startp, *endp) || endp->lnum == 0)
  							  && startp->lnum != 0)
  	    posp = startp;
  	else
***************
*** 497,510 ****
  	{
  	    if (dir == FORWARD)
  	    {
! 		if ((result == NULL || lt(curbuf->b_namedm[i], *result))
! 			&& lt(pos, curbuf->b_namedm[i]))
  		    result = &curbuf->b_namedm[i];
  	    }
  	    else
  	    {
! 		if ((result == NULL || lt(*result, curbuf->b_namedm[i]))
! 			&& lt(curbuf->b_namedm[i], pos))
  		    result = &curbuf->b_namedm[i];
  	    }
  	}
--- 499,512 ----
  	{
  	    if (dir == FORWARD)
  	    {
! 		if ((result == NULL || LT_POS(curbuf->b_namedm[i], *result))
! 			&& LT_POS(pos, curbuf->b_namedm[i]))
  		    result = &curbuf->b_namedm[i];
  	    }
  	    else
  	    {
! 		if ((result == NULL || LT_POS(*result, curbuf->b_namedm[i]))
! 			&& LT_POS(curbuf->b_namedm[i], pos))
  		    result = &curbuf->b_namedm[i];
  	    }
  	}
***************
*** 1063,1069 ****
  	one_adjust(&(curbuf->b_last_change.lnum));
  
  	/* last cursor position, if it was set */
! 	if (!equalpos(curbuf->b_last_cursor, initpos))
  	    one_adjust(&(curbuf->b_last_cursor.lnum));
  
  
--- 1086,1092 ----
  	one_adjust(&(curbuf->b_last_change.lnum));
  
  	/* last cursor position, if it was set */
! 	if (!EQUAL_POS(curbuf->b_last_cursor, initpos))
  	    one_adjust(&(curbuf->b_last_cursor.lnum));
  
  
***************
*** 1838,1844 ****
      for (i = 0; i < buf->b_changelistlen; ++i)
      {
  	/* skip duplicates */
! 	if (i == 0 || !equalpos(buf->b_changelist[i - 1], buf->b_changelist[i]))
  	    write_one_mark(fp_out, '+', &buf->b_changelist[i]);
      }
  #endif
--- 1862,1869 ----
      for (i = 0; i < buf->b_changelistlen; ++i)
      {
  	/* skip duplicates */
! 	if (i == 0 || !EQUAL_POS(buf->b_changelist[i - 1],
! 							 buf->b_changelist[i]))
  	    write_one_mark(fp_out, '+', &buf->b_changelist[i]);
      }
  #endif
*** ../vim-8.0.0447/src/misc1.c	2017-03-08 22:19:21.717870787 +0100
--- src/misc1.c	2017-03-12 17:59:51.080234077 +0100
***************
*** 5272,5278 ****
  
      /* If comment_pos is before rs_pos the raw string is inside the comment.
       * If rs_pos is before comment_pos the comment is inside the raw string. */
!     if (comment_pos == NULL || (rs_pos != NULL && lt(*rs_pos, *comment_pos)))
  	return rs_pos;
      return comment_pos;
  }
--- 5272,5279 ----
  
      /* If comment_pos is before rs_pos the raw string is inside the comment.
       * If rs_pos is before comment_pos the comment is inside the raw string. */
!     if (comment_pos == NULL || (rs_pos != NULL
! 					     && LT_POS(*rs_pos, *comment_pos)))
  	return rs_pos;
      return comment_pos;
  }
***************
*** 7217,7223 ****
  	comment_pos = &tryposCopy;
      }
      trypos = find_start_rawstring(curbuf->b_ind_maxcomment);
!     if (trypos != NULL && (comment_pos == NULL || lt(*trypos, *comment_pos)))
      {
  	amount = -1;
  	goto laterend;
--- 7218,7225 ----
  	comment_pos = &tryposCopy;
      }
      trypos = find_start_rawstring(curbuf->b_ind_maxcomment);
!     if (trypos != NULL && (comment_pos == NULL
! 					     || LT_POS(*trypos, *comment_pos)))
      {
  	amount = -1;
  	goto laterend;
***************
*** 9352,9358 ****
      {
  	paren = *pos;
  	pos = findmatch(NULL, '[');
! 	if (pos == NULL || ltp(pos, &paren))
  	    pos = &paren;
      }
      if (pos != NULL)
--- 9354,9360 ----
      {
  	paren = *pos;
  	pos = findmatch(NULL, '[');
! 	if (pos == NULL || LT_POSP(pos, &paren))
  	    pos = &paren;
      }
      if (pos != NULL)
*** ../vim-8.0.0447/src/move.c	2017-01-15 20:51:33.900962677 +0100
--- src/move.c	2017-03-12 18:09:32.059989347 +0100
***************
*** 210,216 ****
      /*
       * If the buffer is empty, always set topline to 1.
       */
!     if (bufempty())		/* special case - file is empty */
      {
  	if (curwin->w_topline != 1)
  	    redraw_later(NOT_VALID);
--- 210,216 ----
      /*
       * If the buffer is empty, always set topline to 1.
       */
!     if (BUFEMPTY())		/* special case - file is empty */
      {
  	if (curwin->w_topline != 1)
  	    redraw_later(NOT_VALID);
*** ../vim-8.0.0447/src/normal.c	2017-02-26 19:09:01.398217128 +0100
--- src/normal.c	2017-03-12 18:13:15.254364513 +0100
***************
*** 1540,1546 ****
  	    if (VIsual_select && VIsual_mode == 'V'
  					    && cap->oap->op_type != OP_DELETE)
  	    {
! 		if (lt(VIsual, curwin->w_cursor))
  		{
  		    VIsual.col = 0;
  		    curwin->w_cursor.col =
--- 1540,1546 ----
  	    if (VIsual_select && VIsual_mode == 'V'
  					    && cap->oap->op_type != OP_DELETE)
  	    {
! 		if (LT_POS(VIsual, curwin->w_cursor))
  		{
  		    VIsual.col = 0;
  		    curwin->w_cursor.col =
***************
*** 1572,1578 ****
  	 * Set oap->start to the first position of the operated text, oap->end
  	 * to the end of the operated text.  w_cursor is equal to oap->start.
  	 */
! 	if (lt(oap->start, curwin->w_cursor))
  	{
  #ifdef FEAT_FOLDING
  	    /* Include folded lines completely. */
--- 1572,1578 ----
  	 * Set oap->start to the first position of the operated text, oap->end
  	 * to the end of the operated text.  w_cursor is equal to oap->start.
  	 */
! 	if (LT_POS(oap->start, curwin->w_cursor))
  	{
  #ifdef FEAT_FOLDING
  	    /* Include folded lines completely. */
***************
*** 1776,1782 ****
  		    && (!oap->inclusive
  			|| (oap->op_type == OP_YANK
  			    && gchar_pos(&oap->end) == NUL))
! 		    && equalpos(oap->start, oap->end)
  #ifdef FEAT_VIRTUALEDIT
  		    && !(virtual_op && oap->start.coladd != oap->end.coladd)
  #endif
--- 1776,1782 ----
  		    && (!oap->inclusive
  			|| (oap->op_type == OP_YANK
  			    && gchar_pos(&oap->end) == NUL))
! 		    && EQUAL_POS(oap->start, oap->end)
  #ifdef FEAT_VIRTUALEDIT
  		    && !(virtual_op && oap->start.coladd != oap->end.coladd)
  #endif
***************
*** 2683,2694 ****
  			    jump_flags = MOUSE_MAY_STOP_VIS;
  			else
  			{
! 			    if ((lt(curwin->w_cursor, VIsual)
! 					&& (lt(m_pos, curwin->w_cursor)
! 					    || lt(VIsual, m_pos)))
! 				    || (lt(VIsual, curwin->w_cursor)
! 					&& (lt(m_pos, VIsual)
! 					    || lt(curwin->w_cursor, m_pos))))
  			    {
  				jump_flags = MOUSE_MAY_STOP_VIS;
  			    }
--- 2683,2694 ----
  			    jump_flags = MOUSE_MAY_STOP_VIS;
  			else
  			{
! 			    if ((LT_POS(curwin->w_cursor, VIsual)
! 					&& (LT_POS(m_pos, curwin->w_cursor)
! 					    || LT_POS(VIsual, m_pos)))
! 				    || (LT_POS(VIsual, curwin->w_cursor)
! 					&& (LT_POS(m_pos, VIsual)
! 					  || LT_POS(curwin->w_cursor, m_pos))))
  			    {
  				jump_flags = MOUSE_MAY_STOP_VIS;
  			    }
***************
*** 2754,2760 ****
  		 * Remember the start and end of visual before moving the
  		 * cursor.
  		 */
! 		if (lt(curwin->w_cursor, VIsual))
  		{
  		    start_visual = curwin->w_cursor;
  		    end_visual = VIsual;
--- 2754,2760 ----
  		 * Remember the start and end of visual before moving the
  		 * cursor.
  		 */
! 		if (LT_POS(curwin->w_cursor, VIsual))
  		{
  		    start_visual = curwin->w_cursor;
  		    end_visual = VIsual;
***************
*** 2891,2899 ****
  	     * If the click is after the end of visual, change the end.  If
  	     * the click is inside the visual, change the closest side.
  	     */
! 	    if (lt(curwin->w_cursor, start_visual))
  		VIsual = end_visual;
! 	    else if (lt(end_visual, curwin->w_cursor))
  		VIsual = start_visual;
  	    else
  	    {
--- 2891,2899 ----
  	     * If the click is after the end of visual, change the end.  If
  	     * the click is inside the visual, change the closest side.
  	     */
! 	    if (LT_POS(curwin->w_cursor, start_visual))
  		VIsual = end_visual;
! 	    else if (LT_POS(end_visual, curwin->w_cursor))
  		VIsual = start_visual;
  	    else
  	    {
***************
*** 3097,3103 ****
  		if (oap != NULL
  			&& VIsual_mode == 'v'
  			&& !vim_iswordc(gchar_pos(&end_visual))
! 			&& equalpos(curwin->w_cursor, VIsual)
  			&& (pos = findmatch(oap, NUL)) != NULL)
  		{
  		    curwin->w_cursor = *pos;
--- 3097,3103 ----
  		if (oap != NULL
  			&& VIsual_mode == 'v'
  			&& !vim_iswordc(gchar_pos(&end_visual))
! 			&& EQUAL_POS(curwin->w_cursor, VIsual)
  			&& (pos = findmatch(oap, NUL)) != NULL)
  		{
  		    curwin->w_cursor = *pos;
***************
*** 3105,3111 ****
  			VIsual_mode = 'V';
  		    else if (*p_sel == 'e')
  		    {
! 			if (lt(curwin->w_cursor, VIsual))
  			    ++VIsual.col;
  			else
  			    ++curwin->w_cursor.col;
--- 3105,3111 ----
  			VIsual_mode = 'V';
  		    else if (*p_sel == 'e')
  		    {
! 			if (LT_POS(curwin->w_cursor, VIsual))
  			    ++VIsual.col;
  			else
  			    ++curwin->w_cursor.col;
***************
*** 3117,3123 ****
  	    {
  		/* When not found a match or when dragging: extend to include
  		 * a word. */
! 		if (lt(curwin->w_cursor, orig_cursor))
  		{
  		    find_start_of_word(&curwin->w_cursor);
  		    find_end_of_word(&VIsual);
--- 3117,3123 ----
  	    {
  		/* When not found a match or when dragging: extend to include
  		 * a word. */
! 		if (LT_POS(curwin->w_cursor, orig_cursor))
  		{
  		    find_start_of_word(&curwin->w_cursor);
  		    find_end_of_word(&VIsual);
***************
*** 3745,3751 ****
  
      if (VIsual_active && !char_avail())
      {
! 	int		cursor_bot = lt(VIsual, curwin->w_cursor);
  	long		lines;
  	colnr_T		leftcol, rightcol;
  	linenr_T	top, bot;
--- 3745,3751 ----
  
      if (VIsual_active && !char_avail())
      {
! 	int		cursor_bot = LT_POS(VIsual, curwin->w_cursor);
  	long		lines;
  	colnr_T		leftcol, rightcol;
  	linenr_T	top, bot;
***************
*** 4353,4359 ****
      curwin->w_cursor.col = 0;
  
      /* Search forward for the identifier, ignore comment lines. */
!     clearpos(&found_pos);
      for (;;)
      {
  	valid = FALSE;
--- 4353,4359 ----
      curwin->w_cursor.col = 0;
  
      /* Search forward for the identifier, ignore comment lines. */
!     CLEAR_POS(&found_pos);
      for (;;)
      {
  	valid = FALSE;
***************
*** 4419,4431 ****
  	 * declarations this skips the function header without types. */
  	if (!valid)
  	{
! 	    /* Braces needed due to macro expansion of clearpos. */
! 	    clearpos(&found_pos);
  	}
  	else
- 	{
  	    found_pos = curwin->w_cursor;
- 	}
  	/* Remove SEARCH_START from flags to avoid getting stuck at one
  	 * position. */
  	searchflags &= ~SEARCH_START;
--- 4419,4428 ----
  	 * declarations this skips the function header without types. */
  	if (!valid)
  	{
! 	    CLEAR_POS(&found_pos);
  	}
  	else
  	    found_pos = curwin->w_cursor;
  	/* Remove SEARCH_START from flags to avoid getting stuck at one
  	 * position. */
  	searchflags &= ~SEARCH_START;
***************
*** 5834,5840 ****
      }
      else
      {
! 	if (lt(curwin->w_cursor, VIsual))
  	{
  	    *pp = ml_get_pos(&curwin->w_cursor);
  	    *lenp = VIsual.col - curwin->w_cursor.col + 1;
--- 5831,5837 ----
      }
      else
      {
! 	if (LT_POS(curwin->w_cursor, VIsual))
  	{
  	    *pp = ml_get_pos(&curwin->w_cursor);
  	    *lenp = VIsual.col - curwin->w_cursor.col + 1;
***************
*** 6020,6026 ****
  		 * included, move to next line after that */
  		if (	   cap->oap->op_type != OP_NOP
  			&& !cap->oap->inclusive
! 			&& !lineempty(curwin->w_cursor.lnum))
  		    cap->oap->inclusive = TRUE;
  		else
  		{
--- 6017,6023 ----
  		 * included, move to next line after that */
  		if (	   cap->oap->op_type != OP_NOP
  			&& !cap->oap->inclusive
! 			&& !LINEEMPTY(curwin->w_cursor.lnum))
  		    cap->oap->inclusive = TRUE;
  		else
  		{
***************
*** 6042,6048 ****
  	    }
  	    else
  	    {
! 		if (!lineempty(curwin->w_cursor.lnum))
  		    cap->oap->inclusive = TRUE;
  	    }
  	    break;
--- 6039,6045 ----
  	    }
  	    else
  	    {
! 		if (!LINEEMPTY(curwin->w_cursor.lnum))
  		    cap->oap->inclusive = TRUE;
  	    }
  	    break;
***************
*** 6121,6127 ****
  		 * Don't adjust op_end now, otherwise it won't work. */
  		if (	   (cap->oap->op_type == OP_DELETE
  			    || cap->oap->op_type == OP_CHANGE)
! 			&& !lineempty(curwin->w_cursor.lnum))
  		{
  		    char_u *cp = ml_get_cursor();
  
--- 6118,6124 ----
  		 * Don't adjust op_end now, otherwise it won't work. */
  		if (	   (cap->oap->op_type == OP_DELETE
  			    || cap->oap->op_type == OP_CHANGE)
! 			&& !LINEEMPTY(curwin->w_cursor.lnum))
  		{
  		    char_u *cp = ml_get_cursor();
  
***************
*** 6333,6339 ****
      }
  
      (void)normal_search(cap, cap->cmdchar, cap->searchbuf,
! 			(cap->arg || !equalpos(save_cursor, curwin->w_cursor))
  							   ? 0 : SEARCH_MARK);
  }
  
--- 6330,6336 ----
      }
  
      (void)normal_search(cap, cap->cmdchar, cap->searchbuf,
! 			(cap->arg || !EQUAL_POS(save_cursor, curwin->w_cursor))
  							   ? 0 : SEARCH_MARK);
  }
  
***************
*** 6347,6353 ****
      pos_T old = curwin->w_cursor;
      int   i = normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg);
  
!     if (i == 1 && equalpos(old, curwin->w_cursor))
      {
  	/* Avoid getting stuck on the current cursor position, which can
  	 * happen when an offset is given and the cursor is on the last char
--- 6344,6350 ----
      pos_T old = curwin->w_cursor;
      int   i = normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg);
  
!     if (i == 1 && EQUAL_POS(old, curwin->w_cursor))
      {
  	/* Avoid getting stuck on the current cursor position, which can
  	 * happen when an offset is given and the cursor is on the last char
***************
*** 6689,6697 ****
  
  	    if (VIsual_active)
  	    {
! 		start = ltoreq(VIsual, curwin->w_cursor)
  						  ? VIsual : curwin->w_cursor;
! 		end =  equalpos(start,VIsual) ? curwin->w_cursor : VIsual;
  		curwin->w_cursor = (dir == BACKWARD ? start : end);
  	    }
  # ifdef FEAT_CLIPBOARD
--- 6686,6694 ----
  
  	    if (VIsual_active)
  	    {
! 		start = LTOREQ_POS(VIsual, curwin->w_cursor)
  						  ? VIsual : curwin->w_cursor;
! 		end =  EQUAL_POS(start,VIsual) ? curwin->w_cursor : VIsual;
  		curwin->w_cursor = (dir == BACKWARD ? start : end);
  	    }
  # ifdef FEAT_CLIPBOARD
***************
*** 7315,7321 ****
      if (checkclearopq(cap->oap))
  	return;
  
!     if (lineempty(curwin->w_cursor.lnum) && vim_strchr(p_ww, '~') == NULL)
      {
  	clearopbeep(cap->oap);
  	return;
--- 7312,7318 ----
      if (checkclearopq(cap->oap))
  	return;
  
!     if (LINEEMPTY(curwin->w_cursor.lnum) && vim_strchr(p_ww, '~') == NULL)
      {
  	clearopbeep(cap->oap);
  	return;
***************
*** 7559,7565 ****
  #ifdef FEAT_FOLDING
      if (cap->oap->op_type == OP_NOP
  	    && pos != NULL
! 	    && (pos == (pos_T *)-1 || !equalpos(old_cursor, *pos))
  	    && (fdo_flags & FDO_MARK)
  	    && old_KeyTyped)
  	foldOpenCursor();
--- 7556,7562 ----
  #ifdef FEAT_FOLDING
      if (cap->oap->op_type == OP_NOP
  	    && pos != NULL
! 	    && (pos == (pos_T *)-1 || !EQUAL_POS(old_cursor, *pos))
  	    && (fdo_flags & FDO_MARK)
  	    && old_KeyTyped)
  	foldOpenCursor();
***************
*** 8763,8769 ****
  
      /* Don't leave the cursor on the NUL past the end of line. Unless we
       * didn't move it forward. */
!     if (lt(startpos, curwin->w_cursor))
  	adjust_cursor(cap->oap);
  
      if (n == FAIL && cap->oap->op_type == OP_NOP)
--- 8760,8766 ----
  
      /* Don't leave the cursor on the NUL past the end of line. Unless we
       * didn't move it forward. */
!     if (LT_POS(startpos, curwin->w_cursor))
  	adjust_cursor(cap->oap);
  
      if (n == FAIL && cap->oap->op_type == OP_NOP)
***************
*** 8833,8839 ****
  adjust_for_sel(cmdarg_T *cap)
  {
      if (VIsual_active && cap->oap->inclusive && *p_sel == 'e'
! 	    && gchar_cursor() != NUL && lt(VIsual, curwin->w_cursor))
      {
  #ifdef FEAT_MBYTE
  	if (has_mbyte)
--- 8830,8836 ----
  adjust_for_sel(cmdarg_T *cap)
  {
      if (VIsual_active && cap->oap->inclusive && *p_sel == 'e'
! 	    && gchar_cursor() != NUL && LT_POS(VIsual, curwin->w_cursor))
      {
  #ifdef FEAT_MBYTE
  	if (has_mbyte)
***************
*** 8855,8863 ****
  {
      pos_T	*pp;
  
!     if (*p_sel == 'e' && !equalpos(VIsual, curwin->w_cursor))
      {
! 	if (lt(VIsual, curwin->w_cursor))
  	    pp = &curwin->w_cursor;
  	else
  	    pp = &VIsual;
--- 8852,8860 ----
  {
      pos_T	*pp;
  
!     if (*p_sel == 'e' && !EQUAL_POS(VIsual, curwin->w_cursor))
      {
! 	if (LT_POS(VIsual, curwin->w_cursor))
  	    pp = &curwin->w_cursor;
  	else
  	    pp = &VIsual;
***************
*** 9071,9078 ****
  
  	/* When the last char in the line was deleted then append. Detect this
  	 * by checking if the cursor moved to before the Visual area. */
! 	if (*ml_get_cursor() != NUL && lt(curwin->w_cursor, old_pos)
! 					   && lt(curwin->w_cursor, old_visual))
  	    inc_cursor();
  
  	/* Insert to replace the deleted text with the pasted text. */
--- 9068,9075 ----
  
  	/* When the last char in the line was deleted then append. Detect this
  	 * by checking if the cursor moved to before the Visual area. */
! 	if (*ml_get_cursor() != NUL && LT_POS(curwin->w_cursor, old_pos)
! 				       && LT_POS(curwin->w_cursor, old_visual))
  	    inc_cursor();
  
  	/* Insert to replace the deleted text with the pasted text. */
*** ../vim-8.0.0447/src/option.c	2017-03-09 18:59:05.660711160 +0100
--- src/option.c	2017-03-12 18:09:54.567825462 +0100
***************
*** 4170,4176 ****
      }
  #endif
  
!     if (bufempty())
      {
  	int idx_ffs = findoption((char_u *)"ffs");
  
--- 4170,4176 ----
      }
  #endif
  
!     if (BUFEMPTY())
      {
  	int idx_ffs = findoption((char_u *)"ffs");
  
*** ../vim-8.0.0447/src/popupmnu.c	2016-11-24 17:47:03.865021031 +0100
--- src/popupmnu.c	2017-03-12 18:09:58.211798929 +0100
***************
*** 590,596 ****
  			&& curbuf->b_p_bh[0] == 'w')
  		{
  		    /* Already a "wipeout" buffer, make it empty. */
! 		    while (!bufempty())
  			ml_delete((linenr_T)1, FALSE);
  		}
  		else
--- 590,596 ----
  			&& curbuf->b_p_bh[0] == 'w')
  		{
  		    /* Already a "wipeout" buffer, make it empty. */
! 		    while (!BUFEMPTY())
  			ml_delete((linenr_T)1, FALSE);
  		}
  		else
*** ../vim-8.0.0447/src/regexp.c	2016-11-10 20:01:41.197582893 +0100
--- src/regexp.c	2017-03-12 17:56:40.025633901 +0100
***************
*** 4150,4156 ****
  
      if (VIsual_active)
      {
! 	if (lt(VIsual, wp->w_cursor))
  	{
  	    top = VIsual;
  	    bot = wp->w_cursor;
--- 4150,4156 ----
  
      if (VIsual_active)
      {
! 	if (LT_POS(VIsual, wp->w_cursor))
  	{
  	    top = VIsual;
  	    bot = wp->w_cursor;
***************
*** 4164,4170 ****
      }
      else
      {
! 	if (lt(curbuf->b_visual.vi_start, curbuf->b_visual.vi_end))
  	{
  	    top = curbuf->b_visual.vi_start;
  	    bot = curbuf->b_visual.vi_end;
--- 4164,4170 ----
      }
      else
      {
! 	if (LT_POS(curbuf->b_visual.vi_start, curbuf->b_visual.vi_end))
  	{
  	    top = curbuf->b_visual.vi_start;
  	    bot = curbuf->b_visual.vi_end;
*** ../vim-8.0.0447/src/screen.c	2017-03-09 18:19:58.161107848 +0100
--- src/screen.c	2017-03-12 18:01:53.231339720 +0100
***************
*** 2714,2720 ****
       */
      if (VIsual_active && wp->w_buffer == curwin->w_buffer)
      {
! 	if (ltoreq(curwin->w_cursor, VIsual))
  	{
  	    /* Visual is after curwin->w_cursor */
  	    top = &curwin->w_cursor;
--- 2714,2720 ----
       */
      if (VIsual_active && wp->w_buffer == curwin->w_buffer)
      {
! 	if (LTOREQ_POS(curwin->w_cursor, VIsual))
  	{
  	    /* Visual is after curwin->w_cursor */
  	    top = &curwin->w_cursor;
***************
*** 3170,3176 ****
      if (VIsual_active && wp->w_buffer == curwin->w_buffer)
      {
  					/* Visual is after curwin->w_cursor */
! 	if (ltoreq(curwin->w_cursor, VIsual))
  	{
  	    top = &curwin->w_cursor;
  	    bot = &VIsual;
--- 3170,3176 ----
      if (VIsual_active && wp->w_buffer == curwin->w_buffer)
      {
  					/* Visual is after curwin->w_cursor */
! 	if (LTOREQ_POS(curwin->w_cursor, VIsual))
  	{
  	    top = &curwin->w_cursor;
  	    bot = &VIsual;
*** ../vim-8.0.0447/src/search.c	2017-03-12 16:32:27.490343281 +0100
--- src/search.c	2017-03-12 18:13:25.858287335 +0100
***************
*** 2100,2106 ****
  
      do_quotes = -1;
      start_in_quotes = MAYBE;
!     clearpos(&match_pos);
  
      /* backward search: Check if this line contains a single-line comment */
      if ((backwards && comment_dir)
--- 2100,2106 ----
  
      do_quotes = -1;
      start_in_quotes = MAYBE;
!     CLEAR_POS(&match_pos);
  
      /* backward search: Check if this line contains a single-line comment */
      if ((backwards && comment_dir)
***************
*** 2720,2726 ****
  	    if (decl(&pos) == -1)
  		break;
  	    /* when going forward: Stop in front of empty line */
! 	    if (lineempty(pos.lnum) && dir == FORWARD)
  	    {
  		incl(&pos);
  		goto found;
--- 2720,2726 ----
  	    if (decl(&pos) == -1)
  		break;
  	    /* when going forward: Stop in front of empty line */
! 	    if (LINEEMPTY(pos.lnum) && dir == FORWARD)
  	    {
  		incl(&pos);
  		goto found;
***************
*** 3082,3088 ****
  	    while (cls() == 0)
  	    {
  		if (curwin->w_cursor.col == 0
! 				      && lineempty(curwin->w_cursor.lnum))
  		    goto finished;
  		if (dec_cursor() == -1) /* hit start of file, stop here */
  		    return OK;
--- 3082,3088 ----
  	    while (cls() == 0)
  	    {
  		if (curwin->w_cursor.col == 0
! 				      && LINEEMPTY(curwin->w_cursor.lnum))
  		    goto finished;
  		if (dec_cursor() == -1) /* hit start of file, stop here */
  		    return OK;
***************
*** 3163,3169 ****
  	    while (cls() == 0)
  	    {
  		if (empty && curwin->w_cursor.col == 0
! 					  && lineempty(curwin->w_cursor.lnum))
  		    goto finished;
  		if (inc_cursor() == -1)	    /* hit end of file, stop here */
  		    return FAIL;
--- 3163,3169 ----
  	    while (cls() == 0)
  	    {
  		if (empty && curwin->w_cursor.col == 0
! 					  && LINEEMPTY(curwin->w_cursor.lnum))
  		    goto finished;
  		if (inc_cursor() == -1)	    /* hit end of file, stop here */
  		    return FAIL;
***************
*** 3223,3229 ****
  	 */
  	while (cls() == 0)
  	{
! 	    if (curwin->w_cursor.col == 0 && lineempty(curwin->w_cursor.lnum))
  		break;
  	    if ((i = dec_cursor()) == -1 || (eol && i == 1))
  		return OK;
--- 3223,3229 ----
  	 */
  	while (cls() == 0)
  	{
! 	    if (curwin->w_cursor.col == 0 && LINEEMPTY(curwin->w_cursor.lnum))
  		break;
  	    if ((i = dec_cursor()) == -1 || (eol && i == 1))
  		return OK;
***************
*** 3320,3336 ****
      int		include_white = FALSE;
  
      cls_bigword = bigword;
!     clearpos(&start_pos);
  
      /* Correct cursor when 'selection' is exclusive */
!     if (VIsual_active && *p_sel == 'e' && lt(VIsual, curwin->w_cursor))
  	dec_cursor();
  
      /*
       * When Visual mode is not active, or when the VIsual area is only one
       * character, select the word and/or white space under the cursor.
       */
!     if (!VIsual_active || equalpos(curwin->w_cursor, VIsual))
      {
  	/*
  	 * Go to start of current word or white space.
--- 3320,3336 ----
      int		include_white = FALSE;
  
      cls_bigword = bigword;
!     CLEAR_POS(&start_pos);
  
      /* Correct cursor when 'selection' is exclusive */
!     if (VIsual_active && *p_sel == 'e' && LT_POS(VIsual, curwin->w_cursor))
  	dec_cursor();
  
      /*
       * When Visual mode is not active, or when the VIsual area is only one
       * character, select the word and/or white space under the cursor.
       */
!     if (!VIsual_active || EQUAL_POS(curwin->w_cursor, VIsual))
      {
  	/*
  	 * Go to start of current word or white space.
***************
*** 3387,3393 ****
      while (count > 0)
      {
  	inclusive = TRUE;
! 	if (VIsual_active && lt(curwin->w_cursor, VIsual))
  	{
  	    /*
  	     * In Visual mode, with cursor at start: move cursor back.
--- 3387,3393 ----
      while (count > 0)
      {
  	inclusive = TRUE;
! 	if (VIsual_active && LT_POS(curwin->w_cursor, VIsual))
  	{
  	    /*
  	     * In Visual mode, with cursor at start: move cursor back.
***************
*** 3463,3469 ****
  
      if (VIsual_active)
      {
! 	if (*p_sel == 'e' && inclusive && ltoreq(VIsual, curwin->w_cursor))
  	    inc_cursor();
  	if (VIsual_mode == 'V')
  	{
--- 3463,3469 ----
  
      if (VIsual_active)
      {
! 	if (*p_sel == 'e' && inclusive && LTOREQ_POS(VIsual, curwin->w_cursor))
  	    inc_cursor();
  	if (VIsual_mode == 'V')
  	{
***************
*** 3498,3507 ****
      /*
       * When the Visual area is bigger than one character: Extend it.
       */
!     if (VIsual_active && !equalpos(start_pos, VIsual))
      {
  extend:
! 	if (lt(start_pos, VIsual))
  	{
  	    /*
  	     * Cursor at start of Visual area.
--- 3498,3507 ----
      /*
       * When the Visual area is bigger than one character: Extend it.
       */
!     if (VIsual_active && !EQUAL_POS(start_pos, VIsual))
      {
  extend:
! 	if (LT_POS(start_pos, VIsual))
  	{
  	    /*
  	     * Cursor at start of Visual area.
***************
*** 3512,3518 ****
  	     */
  	    at_start_sent = TRUE;
  	    decl(&pos);
! 	    while (lt(pos, curwin->w_cursor))
  	    {
  		c = gchar_pos(&pos);
  		if (!vim_iswhite(c))
--- 3512,3518 ----
  	     */
  	    at_start_sent = TRUE;
  	    decl(&pos);
! 	    while (LT_POS(pos, curwin->w_cursor))
  	    {
  		c = gchar_pos(&pos);
  		if (!vim_iswhite(c))
***************
*** 3525,3531 ****
  	    if (!at_start_sent)
  	    {
  		findsent(BACKWARD, 1L);
! 		if (equalpos(curwin->w_cursor, start_pos))
  		    at_start_sent = TRUE;  /* exactly at start of sentence */
  		else
  		    /* inside a sentence, go to its end (start of next) */
--- 3525,3531 ----
  	    if (!at_start_sent)
  	    {
  		findsent(BACKWARD, 1L);
! 		if (EQUAL_POS(curwin->w_cursor, start_pos))
  		    at_start_sent = TRUE;  /* exactly at start of sentence */
  		else
  		    /* inside a sentence, go to its end (start of next) */
***************
*** 3554,3563 ****
  	     */
  	    incl(&pos);
  	    at_start_sent = TRUE;
! 	    if (!equalpos(pos, curwin->w_cursor)) /* not just before a sentence */
  	    {
  		at_start_sent = FALSE;
! 		while (lt(pos, curwin->w_cursor))
  		{
  		    c = gchar_pos(&pos);
  		    if (!vim_iswhite(c))
--- 3554,3564 ----
  	     */
  	    incl(&pos);
  	    at_start_sent = TRUE;
! 	    /* not just before a sentence */
! 	    if (!EQUAL_POS(pos, curwin->w_cursor))
  	    {
  		at_start_sent = FALSE;
! 		while (LT_POS(pos, curwin->w_cursor))
  		{
  		    c = gchar_pos(&pos);
  		    if (!vim_iswhite(c))
***************
*** 3588,3594 ****
       */
      while (c = gchar_pos(&pos), vim_iswhite(c))	/* vim_iswhite() is a macro */
  	incl(&pos);
!     if (equalpos(pos, curwin->w_cursor))
      {
  	start_blank = TRUE;
  	find_first_blank(&start_pos);	/* go back to first blank */
--- 3589,3595 ----
       */
      while (c = gchar_pos(&pos), vim_iswhite(c))	/* vim_iswhite() is a macro */
  	incl(&pos);
!     if (EQUAL_POS(pos, curwin->w_cursor))
      {
  	start_blank = TRUE;
  	find_first_blank(&start_pos);	/* go back to first blank */
***************
*** 3633,3639 ****
      if (VIsual_active)
      {
  	/* Avoid getting stuck with "is" on a single space before a sentence. */
! 	if (equalpos(start_pos, curwin->w_cursor))
  	    goto extend;
  	if (*p_sel == 'e')
  	    ++curwin->w_cursor.col;
--- 3634,3640 ----
      if (VIsual_active)
      {
  	/* Avoid getting stuck with "is" on a single space before a sentence. */
! 	if (EQUAL_POS(start_pos, curwin->w_cursor))
  	    goto extend;
  	if (*p_sel == 'e')
  	    ++curwin->w_cursor.col;
***************
*** 3682,3688 ****
      /*
       * If we start on '(', '{', ')', '}', etc., use the whole block inclusive.
       */
!     if (!VIsual_active || equalpos(VIsual, curwin->w_cursor))
      {
  	setpcmark();
  	if (what == '{')		/* ignore indent */
--- 3683,3689 ----
      /*
       * If we start on '(', '{', ')', '}', etc., use the whole block inclusive.
       */
!     if (!VIsual_active || EQUAL_POS(VIsual, curwin->w_cursor))
      {
  	setpcmark();
  	if (what == '{')		/* ignore indent */
***************
*** 3693,3699 ****
  	    /* cursor on '(' or '{', move cursor just after it */
  	    ++curwin->w_cursor.col;
      }
!     else if (lt(VIsual, curwin->w_cursor))
      {
  	old_start = VIsual;
  	curwin->w_cursor = VIsual;	    /* cursor at low end of Visual */
--- 3694,3700 ----
  	    /* cursor on '(' or '{', move cursor just after it */
  	    ++curwin->w_cursor.col;
      }
!     else if (LT_POS(VIsual, curwin->w_cursor))
      {
  	old_start = VIsual;
  	curwin->w_cursor = VIsual;	    /* cursor at low end of Visual */
***************
*** 3751,3757 ****
  	 * In Visual mode, when the resulting area is not bigger than what we
  	 * started with, extend it to the next block, and then exclude again.
  	 */
! 	if (!lt(start_pos, old_start) && !lt(old_end, curwin->w_cursor)
  		&& VIsual_active)
  	{
  	    curwin->w_cursor = old_start;
--- 3752,3758 ----
  	 * In Visual mode, when the resulting area is not bigger than what we
  	 * started with, extend it to the next block, and then exclude again.
  	 */
! 	if (!LT_POS(start_pos, old_start) && !LT_POS(old_end, curwin->w_cursor)
  		&& VIsual_active)
  	{
  	    curwin->w_cursor = old_start;
***************
*** 3792,3798 ****
  	oap->inclusive = FALSE;
  	if (sol)
  	    incl(&curwin->w_cursor);
! 	else if (ltoreq(start_pos, curwin->w_cursor))
  	    /* Include the character under the cursor. */
  	    oap->inclusive = TRUE;
  	else
--- 3793,3799 ----
  	oap->inclusive = FALSE;
  	if (sol)
  	    incl(&curwin->w_cursor);
! 	else if (LTOREQ_POS(start_pos, curwin->w_cursor))
  	    /* Include the character under the cursor. */
  	    oap->inclusive = TRUE;
  	else
***************
*** 3916,3922 ****
      /*
       * If we start on "<aaa>" select that block.
       */
!     if (!VIsual_active || equalpos(VIsual, curwin->w_cursor))
      {
  	setpcmark();
  
--- 3917,3923 ----
      /*
       * If we start on "<aaa>" select that block.
       */
!     if (!VIsual_active || EQUAL_POS(VIsual, curwin->w_cursor))
      {
  	setpcmark();
  
***************
*** 3942,3948 ****
  	    old_end = curwin->w_cursor;
  	}
      }
!     else if (lt(VIsual, curwin->w_cursor))
      {
  	old_start = VIsual;
  	curwin->w_cursor = VIsual;	    /* cursor at low end of Visual */
--- 3943,3949 ----
  	    old_end = curwin->w_cursor;
  	}
      }
!     else if (LT_POS(VIsual, curwin->w_cursor))
      {
  	old_start = VIsual;
  	curwin->w_cursor = VIsual;	    /* cursor at low end of Visual */
***************
*** 3999,4005 ****
      vim_free(spat);
      vim_free(epat);
  
!     if (r < 1 || lt(curwin->w_cursor, old_end))
      {
  	/* Can't find other end or it's before the previous end.  Could be a
  	 * HTML tag that doesn't have a matching end.  Search backwards for
--- 4000,4006 ----
      vim_free(spat);
      vim_free(epat);
  
!     if (r < 1 || LT_POS(curwin->w_cursor, old_end))
      {
  	/* Can't find other end or it's before the previous end.  Could be a
  	 * HTML tag that doesn't have a matching end.  Search backwards for
***************
*** 4046,4052 ****
  
  	/* If we now have the same text as before reset "do_include" and try
  	 * again. */
! 	if (equalpos(start_pos, old_start) && equalpos(end_pos, old_end))
  	{
  	    do_include = TRUE;
  	    curwin->w_cursor = old_start;
--- 4047,4053 ----
  
  	/* If we now have the same text as before reset "do_include" and try
  	 * again. */
! 	if (EQUAL_POS(start_pos, old_start) && EQUAL_POS(end_pos, old_end))
  	{
  	    do_include = TRUE;
  	    curwin->w_cursor = old_start;
***************
*** 4059,4065 ****
      {
  	/* If the end is before the start there is no text between tags, select
  	 * the char under the cursor. */
! 	if (lt(end_pos, start_pos))
  	    curwin->w_cursor = start_pos;
  	else if (*p_sel == 'e')
  	    inc_cursor();
--- 4060,4066 ----
      {
  	/* If the end is before the start there is no text between tags, select
  	 * the char under the cursor. */
! 	if (LT_POS(end_pos, start_pos))
  	    curwin->w_cursor = start_pos;
  	else if (*p_sel == 'e')
  	    inc_cursor();
***************
*** 4072,4078 ****
      {
  	oap->start = start_pos;
  	oap->motion_type = MCHAR;
! 	if (lt(end_pos, start_pos))
  	{
  	    /* End is before the start: there is no text between tags; operate
  	     * on an empty area. */
--- 4073,4079 ----
      {
  	oap->start = start_pos;
  	oap->motion_type = MCHAR;
! 	if (LT_POS(end_pos, start_pos))
  	{
  	    /* End is before the start: there is no text between tags; operate
  	     * on an empty area. */
***************
*** 4362,4371 ****
  	if (VIsual.lnum != curwin->w_cursor.lnum)
  	    return FALSE;
  
! 	vis_bef_curs = lt(VIsual, curwin->w_cursor);
  	if (*p_sel == 'e' && vis_bef_curs)
  	    dec_cursor();
! 	vis_empty = equalpos(VIsual, curwin->w_cursor);
      }
  
      if (!vis_empty)
--- 4363,4372 ----
  	if (VIsual.lnum != curwin->w_cursor.lnum)
  	    return FALSE;
  
! 	vis_bef_curs = LT_POS(VIsual, curwin->w_cursor);
  	if (*p_sel == 'e' && vis_bef_curs)
  	    dec_cursor();
! 	vis_empty = EQUAL_POS(VIsual, curwin->w_cursor);
      }
  
      if (!vis_empty)
***************
*** 4605,4611 ****
      p_ws = FALSE;
  
      /* Correct cursor when 'selection' is exclusive */
!     if (VIsual_active && *p_sel == 'e' && lt(VIsual, curwin->w_cursor))
  	dec_cursor();
  
      if (VIsual_active)
--- 4606,4612 ----
      p_ws = FALSE;
  
      /* Correct cursor when 'selection' is exclusive */
!     if (VIsual_active && *p_sel == 'e' && LT_POS(VIsual, curwin->w_cursor))
  	dec_cursor();
  
      if (VIsual_active)
***************
*** 4668,4679 ****
  	}
  	else if (!i && !result)
  	{
! 	    if (forward) /* try again from start of buffer */
  	    {
! 		clearpos(&pos);
  	    }
! 	    else /* try again from end of buffer */
  	    {
  		/* searching backwards, so set pos to last line and col */
  		pos.lnum = curwin->w_buffer->b_ml.ml_line_count;
  		pos.col  = (colnr_T)STRLEN(
--- 4669,4682 ----
  	}
  	else if (!i && !result)
  	{
! 	    if (forward)
  	    {
! 		/* try again from start of buffer */
! 		CLEAR_POS(&pos);
  	    }
! 	    else
  	    {
+ 		/* try again from end of buffer */
  		/* searching backwards, so set pos to last line and col */
  		pos.lnum = curwin->w_buffer->b_ml.ml_line_count;
  		pos.col  = (colnr_T)STRLEN(
***************
*** 4709,4717 ****
  	if (*p_sel == 'e')
  	{
  	    /* Correction for exclusive selection depends on the direction. */
! 	    if (forward && ltoreq(VIsual, curwin->w_cursor))
  		inc_cursor();
! 	    else if (!forward && ltoreq(curwin->w_cursor, VIsual))
  		inc(&VIsual);
  	}
  
--- 4712,4720 ----
  	if (*p_sel == 'e')
  	{
  	    /* Correction for exclusive selection depends on the direction. */
! 	    if (forward && LTOREQ_POS(VIsual, curwin->w_cursor))
  		inc_cursor();
! 	    else if (!forward && LTOREQ_POS(curwin->w_cursor, VIsual))
  		inc(&VIsual);
  	}
  
***************
*** 4764,4770 ****
      regmatch.startpos[0].col = -1;
      /* move to match */
      if (move)
! 	clearpos(&pos)
      else
      {
  	pos = curwin->w_cursor;
--- 4767,4775 ----
      regmatch.startpos[0].col = -1;
      /* move to match */
      if (move)
!     {
! 	CLEAR_POS(&pos);
!     }
      else
      {
  	pos = curwin->w_cursor;
*** ../vim-8.0.0447/src/spell.c	2017-02-25 14:20:56.780372194 +0100
--- src/spell.c	2017-03-12 18:10:15.023676521 +0100
***************
*** 1603,1609 ****
       * though...
       */
      lnum = wp->w_cursor.lnum;
!     clearpos(&found_pos);
  
      while (!got_int)
      {
--- 1603,1609 ----
       * though...
       */
      lnum = wp->w_cursor.lnum;
!     CLEAR_POS(&found_pos);
  
      while (!got_int)
      {
***************
*** 8545,8551 ****
      set_option_value((char_u*)"spl",  dummy, spl, OPT_LOCAL);
      vim_free(spl);
  
!     if (!bufempty())
  	return;
  
      spell_dump_compl(NULL, 0, NULL, eap->forceit ? DUMPFLAG_COUNT : 0);
--- 8545,8551 ----
      set_option_value((char_u*)"spl",  dummy, spl, OPT_LOCAL);
      vim_free(spl);
  
!     if (!BUFEMPTY())
  	return;
  
      spell_dump_compl(NULL, 0, NULL, eap->forceit ? DUMPFLAG_COUNT : 0);
*** ../vim-8.0.0447/src/tag.c	2017-03-01 15:45:01.410957865 +0100
--- src/tag.c	2017-03-12 18:05:14.813864808 +0100
***************
*** 178,184 ****
      free_string_option(nofile_fname);
      nofile_fname = NULL;
  
!     clearpos(&saved_fmark.mark);	/* shutup gcc 4.0 */
      saved_fmark.fnum = 0;
  
      /*
--- 178,184 ----
      free_string_option(nofile_fname);
      nofile_fname = NULL;
  
!     CLEAR_POS(&saved_fmark.mark);	/* shutup gcc 4.0 */
      saved_fmark.fnum = 0;
  
      /*
*** ../vim-8.0.0447/src/ui.c	2017-01-31 22:07:37.907625018 +0100
--- src/ui.c	2017-03-12 17:59:15.432495170 +0100
***************
*** 442,448 ****
      /* If visual mode is only due to a redo command ("."), then ignore it */
      if (!redo_VIsual_busy && VIsual_active && (State & NORMAL))
      {
! 	if (lt(VIsual, curwin->w_cursor))
  	{
  	    start = VIsual;
  	    end = curwin->w_cursor;
--- 442,448 ----
      /* If visual mode is only due to a redo command ("."), then ignore it */
      if (!redo_VIsual_busy && VIsual_active && (State & NORMAL))
      {
! 	if (LT_POS(VIsual, curwin->w_cursor))
  	{
  	    start = VIsual;
  	    end = curwin->w_cursor;
***************
*** 456,463 ****
  	    start = curwin->w_cursor;
  	    end = VIsual;
  	}
! 	if (!equalpos(clip->start, start)
! 		|| !equalpos(clip->end, end)
  		|| clip->vmode != VIsual_mode)
  	{
  	    clip_clear_selection(clip);
--- 456,463 ----
  	    start = curwin->w_cursor;
  	    end = VIsual;
  	}
! 	if (!EQUAL_POS(clip->start, start)
! 		|| !EQUAL_POS(clip->end, end)
  		|| clip->vmode != VIsual_mode)
  	{
  	    clip_clear_selection(clip);
*** ../vim-8.0.0447/src/undo.c	2017-02-26 18:17:05.855360711 +0100
--- src/undo.c	2017-03-12 18:10:20.043639973 +0100
***************
*** 2784,2790 ****
  
      curhead->uh_entry = newlist;
      curhead->uh_flags = new_flags;
!     if ((old_flags & UH_EMPTYBUF) && bufempty())
  	curbuf->b_ml.ml_flags |= ML_EMPTY;
      if (old_flags & UH_CHANGED)
  	changed();
--- 2784,2790 ----
  
      curhead->uh_entry = newlist;
      curhead->uh_flags = new_flags;
!     if ((old_flags & UH_EMPTYBUF) && BUFEMPTY())
  	curbuf->b_ml.ml_flags |= ML_EMPTY;
      if (old_flags & UH_CHANGED)
  	changed();
***************
*** 3175,3188 ****
  	if (STRCMP(ml_get_buf(curbuf, lnum, FALSE),
  						uep->ue_array[lnum - 1]) != 0)
  	{
! 	    clearpos(&(uhp->uh_cursor));
  	    uhp->uh_cursor.lnum = lnum;
  	    return;
  	}
      if (curbuf->b_ml.ml_line_count != uep->ue_size)
      {
  	/* lines added or deleted at the end, put the cursor there */
! 	clearpos(&(uhp->uh_cursor));
  	uhp->uh_cursor.lnum = lnum;
      }
  }
--- 3175,3188 ----
  	if (STRCMP(ml_get_buf(curbuf, lnum, FALSE),
  						uep->ue_array[lnum - 1]) != 0)
  	{
! 	    CLEAR_POS(&(uhp->uh_cursor));
  	    uhp->uh_cursor.lnum = lnum;
  	    return;
  	}
      if (curbuf->b_ml.ml_line_count != uep->ue_size)
      {
  	/* lines added or deleted at the end, put the cursor there */
! 	CLEAR_POS(&(uhp->uh_cursor));
  	uhp->uh_cursor.lnum = lnum;
      }
  }
*** ../vim-8.0.0447/src/version.c	2017-03-12 17:10:14.417925081 +0100
--- src/version.c	2017-03-12 18:14:04.110008941 +0100
***************
*** 2089,2095 ****
      void
  maybe_intro_message(void)
  {
!     if (bufempty()
  	    && curbuf->b_fname == NULL
  #ifdef FEAT_WINDOWS
  	    && firstwin->w_next == NULL
--- 2091,2097 ----
      void
  maybe_intro_message(void)
  {
!     if (BUFEMPTY()
  	    && curbuf->b_fname == NULL
  #ifdef FEAT_WINDOWS
  	    && firstwin->w_next == NULL
*** ../vim-8.0.0447/src/workshop.c	2016-09-25 21:44:59.445600117 +0200
--- src/workshop.c	2017-03-12 17:59:18.780470647 +0100
***************
*** 1087,1093 ****
      *curCol = curwin->w_cursor.col;
  
      if (curbuf->b_visual.vi_mode == 'v' &&
! 	    equalpos(curwin->w_cursor, curbuf->b_visual.vi_end))
      {
  	*selStartLine = curbuf->b_visual.vi_start.lnum;
  	*selStartCol = curbuf->b_visual.vi_start.col;
--- 1087,1093 ----
      *curCol = curwin->w_cursor.col;
  
      if (curbuf->b_visual.vi_mode == 'v' &&
! 	    EQUAL_POS(curwin->w_cursor, curbuf->b_visual.vi_end))
      {
  	*selStartLine = curbuf->b_visual.vi_start.lnum;
  	*selStartCol = curbuf->b_visual.vi_start.col;
*** ../vim-8.0.0447/src/if_perl.xs	2017-01-29 22:59:08.253373379 +0100
--- src/if_perl.xs	2017-03-12 18:10:38.615504757 +0100
***************
*** 1288,1294 ****
      linenr_T	i;
      buf_T	*was_curbuf = curbuf;
  
!     if (bufempty())
  	return;
  
      if (perl_interp == NULL)
--- 1288,1294 ----
      linenr_T	i;
      buf_T	*was_curbuf = curbuf;
  
!     if (BUFEMPTY())
  	return;
  
      if (perl_interp == NULL)
*** ../vim-8.0.0447/src/version.c	2017-03-12 17:10:14.417925081 +0100
--- src/version.c	2017-03-12 18:14:04.110008941 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     448,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
100. The most exciting sporting events you noticed during summer 1996
    was Netscape vs. Microsoft.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0449
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0449 (after 8.0.0448)
Problem:    Part of fold patch accidentally included.
Solution:   Revert that part of the patch.
Files:      src/ex_cmds.c


*** ../vim-8.0.0448/src/ex_cmds.c	2017-03-12 18:23:35.845850084 +0100
--- src/ex_cmds.c	2017-03-12 18:28:18.139822394 +0100
***************
*** 851,891 ****
       * their final destination at the new text position -- webb
       */
      last_line = curbuf->b_ml.ml_line_count;
!     mark_adjust_nofold(line1, line2, last_line - line2, 0L);
      if (dest >= line2)
      {
! 	mark_adjust_nofold(line2 + 1, dest, -num_lines, 0L);
! #ifdef FEAT_FOLDING
! 	win_T	    *win;
! 	tabpage_T   *tp;
! 
! 	FOR_ALL_TAB_WINDOWS(tp, win) {
! 	    if (win->w_buffer == curbuf)
! 		foldSwapRange(&win->w_folds, line1, line2, dest + 1,
! 			dest + num_lines);
! 	}
! #endif
  	curbuf->b_op_start.lnum = dest - num_lines + 1;
  	curbuf->b_op_end.lnum = dest;
      }
      else
      {
! 	mark_adjust_nofold(dest + 1, line1 - 1, num_lines, 0L);
! #ifdef FEAT_FOLDING
! 	win_T	    *win;
! 	tabpage_T   *tp;
! 
! 	FOR_ALL_TAB_WINDOWS(tp, win) {
! 	    if (win->w_buffer == curbuf)
! 		foldSwapRange(&win->w_folds, dest + 1, line1 - 1, line1, line2);
! 	}
! #endif
  	curbuf->b_op_start.lnum = dest + 1;
  	curbuf->b_op_end.lnum = dest + num_lines;
      }
      curbuf->b_op_start.col = curbuf->b_op_end.col = 0;
!     mark_adjust_nofold(last_line - num_lines + 1, last_line,
  					     -(last_line - dest - extra), 0L);
  
      /*
       * Now we delete the original text -- webb
--- 851,874 ----
       * their final destination at the new text position -- webb
       */
      last_line = curbuf->b_ml.ml_line_count;
!     mark_adjust(line1, line2, last_line - line2, 0L);
!     changed_lines(last_line - num_lines + 1, 0, last_line + 1, num_lines);
      if (dest >= line2)
      {
! 	mark_adjust(line2 + 1, dest, -num_lines, 0L);
  	curbuf->b_op_start.lnum = dest - num_lines + 1;
  	curbuf->b_op_end.lnum = dest;
      }
      else
      {
! 	mark_adjust(dest + 1, line1 - 1, num_lines, 0L);
  	curbuf->b_op_start.lnum = dest + 1;
  	curbuf->b_op_end.lnum = dest + num_lines;
      }
      curbuf->b_op_start.col = curbuf->b_op_end.col = 0;
!     mark_adjust(last_line - num_lines + 1, last_line,
  					     -(last_line - dest - extra), 0L);
+     changed_lines(last_line - num_lines + 1, 0, last_line + 1, -extra);
  
      /*
       * Now we delete the original text -- webb
*** ../vim-8.0.0448/src/version.c	2017-03-12 18:23:35.861849968 +0100
--- src/version.c	2017-03-12 18:32:02.622209986 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     449,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
101. U can read htis w/o ny porblm and cant figur eout Y its evn listd.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0450
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0450
Problem:    v:progpath is not reliably set.
Solution:   Read /proc/self/exe if possible. (idea by Michal Grochmal)
            Also fixes missing #if.
Files:      src/main.c, src/config.h.in


*** ../vim-8.0.0449/src/main.c	2017-03-12 18:23:35.849850055 +0100
--- src/main.c	2017-03-12 17:58:11.256965313 +0100
***************
*** 3539,3554 ****
  {
      char_u *val = argv0;
  
      /* A relative path containing a "/" will become invalid when using ":cd",
       * turn it into a full path.
       * On MS-Windows "vim" should be expanded to "vim.exe", thus always do
       * this. */
! # ifdef WIN32
      char_u *path = NULL;
  
      if (mch_can_exe(argv0, &path, FALSE) && path != NULL)
  	val = path;
! # else
      char_u buf[MAXPATHL];
  
      if (!mch_isFullName(argv0))
--- 3539,3565 ----
  {
      char_u *val = argv0;
  
+ # ifdef HAVE_PROC_SELF_EXE
+     char    buf[PATH_MAX + 1];
+     ssize_t len;
+ 
+     len = readlink("/proc/self/exe", buf, PATH_MAX);
+     if (len > 0)
+     {
+ 	buf[len] = NUL;
+ 	val = (char_u *)buf;
+     }
+ # else
      /* A relative path containing a "/" will become invalid when using ":cd",
       * turn it into a full path.
       * On MS-Windows "vim" should be expanded to "vim.exe", thus always do
       * this. */
! #  ifdef WIN32
      char_u *path = NULL;
  
      if (mch_can_exe(argv0, &path, FALSE) && path != NULL)
  	val = path;
! #  else
      char_u buf[MAXPATHL];
  
      if (!mch_isFullName(argv0))
*** ../vim-8.0.0449/src/config.h.in	2017-03-11 20:03:37.845266804 +0100
--- src/config.h.in	2017-03-11 19:47:10.532151827 +0100
***************
*** 446,451 ****
--- 446,454 ----
  /* Define if fcntl()'s F_SETFD command knows about FD_CLOEXEC */
  #undef HAVE_FD_CLOEXEC
  
+ /* Define if /proc/self/exe can be read */
+ #undef HAVE_PROC_SELF_EXE
+ 
  /* Define if you want Cygwin to use the WIN32 clipboard, not compatible with X11*/
  #undef FEAT_CYGWIN_WIN32_CLIPBOARD
  
*** ../vim-8.0.0449/src/version.c	2017-03-12 18:32:26.782036421 +0100
--- src/version.c	2017-03-12 18:37:13.351977299 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     450,
  /**/

-- 
Contrary to popular belief, Unix is user friendly.
It just happens to be selective about who it makes friends with.
                                               -- Dave Parnas

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0451
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0451
Problem:    Some macros are in lower case.
Solution:   Make a few more macros upper case. Avoid lower case macros use an
            argument twice.
Files:      src/macros.h, src/charset.c, src/misc2.c, src/proto/misc2.pro,
            src/edit.c, src/eval.c, src/ex_cmds.c, src/ex_cmds2.c,
            src/ex_docmd.c, src/ex_getln.c, src/fileio.c, src/fold.c,
            src/gui.c, src/gui_gtk.c, src/mark.c, src/memline.c, src/mbyte.c,
            src/menu.c, src/message.c, src/misc1.c, src/ops.c, src/option.c,
            src/os_amiga.c, src/os_mswin.c, src/os_unix.c, src/os_win32.c,
            src/popupmnu.c, src/regexp.c, src/regexp_nfa.c, src/screen.c,
            src/search.c, src/spell.c, src/spellfile.c, src/syntax.c,
            src/tag.c, src/ui.c, src/undo.c, src/window.c


*** ../vim-8.0.0450/src/macros.h	2017-03-12 18:23:35.833850172 +0100
--- src/macros.h	2017-03-12 19:10:15.801792902 +0100
***************
*** 8,13 ****
--- 8,16 ----
  
  /*
   * macros.h: macro definitions for often used code
+  *
+  * Macros should be ALL_CAPS.  An exception is for where a function is
+  * replaced and an argument is not used more than once.
   */
  
  /*
***************
*** 161,170 ****
  #endif
  
  /*
!  * vim_isbreak() is used very often if 'linebreak' is set, use a macro to make
!  * it work fast.
   */
! #define vim_isbreak(c) (breakat_flags[(char_u)(c)])
  
  /*
   * On VMS file names are different and require a translation.
--- 164,173 ----
  #endif
  
  /*
!  * VIM_ISBREAK() is used very often if 'linebreak' is set, use a macro to make
!  * it work fast.  Only works for single byte characters!
   */
! #define VIM_ISBREAK(c) ((c) < 256 && breakat_flags[(char_u)(c)])
  
  /*
   * On VMS file names are different and require a translation.
***************
*** 190,198 ****
  #  define mch_stat(n, p)	vim_stat((n), (p))
  # else
  #  ifdef STAT_IGNORES_SLASH
!     /* On Solaris stat() accepts "file/" as if it was "file".  Return -1 if
!      * the name ends in "/" and it's not a directory. */
! #   define mch_stat(n, p)	(illegal_slash(n) ? -1 : stat((n), (p)))
  #  else
  #   define mch_stat(n, p)	stat((n), (p))
  #  endif
--- 193,199 ----
  #  define mch_stat(n, p)	vim_stat((n), (p))
  # else
  #  ifdef STAT_IGNORES_SLASH
! #   define mch_stat(n, p)	vim_stat((n), (p))
  #  else
  #   define mch_stat(n, p)	stat((n), (p))
  #  endif
***************
*** 258,279 ****
  #endif
  
  /*
!  * mb_ptr_adv(): advance a pointer to the next character, taking care of
   * multi-byte characters if needed.
!  * mb_ptr_back(): backup a pointer to the previous character, taking care of
   * multi-byte characters if needed.
   * MB_COPY_CHAR(f, t): copy one char from "f" to "t" and advance the pointers.
   * PTR2CHAR(): get character from pointer.
   */
  #ifdef FEAT_MBYTE
  /* Get the length of the character p points to */
! # define MB_PTR2LEN(p)		(has_mbyte ? (*mb_ptr2len)(p) : 1)
  /* Advance multi-byte pointer, skip over composing chars. */
! # define mb_ptr_adv(p)	    p += has_mbyte ? (*mb_ptr2len)(p) : 1
  /* Advance multi-byte pointer, do not skip over composing chars. */
! # define mb_cptr_adv(p)	    p += enc_utf8 ? utf_ptr2len(p) : has_mbyte ? (*mb_ptr2len)(p) : 1
  /* Backup multi-byte pointer. Only use with "p" > "s" ! */
! # define mb_ptr_back(s, p)  p -= has_mbyte ? ((*mb_head_off)(s, p - 1) + 1) : 1
  /* get length of multi-byte char, not including composing chars */
  # define MB_CPTR2LEN(p)	    (enc_utf8 ? utf_ptr2len(p) : (*mb_ptr2len)(p))
  
--- 259,280 ----
  #endif
  
  /*
!  * MB_PTR_ADV(): advance a pointer to the next character, taking care of
   * multi-byte characters if needed.
!  * MB_PTR_BACK(): backup a pointer to the previous character, taking care of
   * multi-byte characters if needed.
   * MB_COPY_CHAR(f, t): copy one char from "f" to "t" and advance the pointers.
   * PTR2CHAR(): get character from pointer.
   */
  #ifdef FEAT_MBYTE
  /* Get the length of the character p points to */
! # define MB_PTR2LEN(p)	    (has_mbyte ? (*mb_ptr2len)(p) : 1)
  /* Advance multi-byte pointer, skip over composing chars. */
! # define MB_PTR_ADV(p)	    p += has_mbyte ? (*mb_ptr2len)(p) : 1
  /* Advance multi-byte pointer, do not skip over composing chars. */
! # define MB_CPTR_ADV(p)	    p += enc_utf8 ? utf_ptr2len(p) : has_mbyte ? (*mb_ptr2len)(p) : 1
  /* Backup multi-byte pointer. Only use with "p" > "s" ! */
! # define MB_PTR_BACK(s, p)  p -= has_mbyte ? ((*mb_head_off)(s, p - 1) + 1) : 1
  /* get length of multi-byte char, not including composing chars */
  # define MB_CPTR2LEN(p)	    (enc_utf8 ? utf_ptr2len(p) : (*mb_ptr2len)(p))
  
***************
*** 284,292 ****
  #else
  # define MB_PTR2LEN(p)		1
  # define MB_CPTR2LEN(p)		1
! # define mb_ptr_adv(p)		++p
! # define mb_cptr_adv(p)		++p
! # define mb_ptr_back(s, p)	--p
  # define MB_COPY_CHAR(f, t)	*t++ = *f++
  # define MB_CHARLEN(p)		STRLEN(p)
  # define MB_CHAR2LEN(c)		1
--- 285,293 ----
  #else
  # define MB_PTR2LEN(p)		1
  # define MB_CPTR2LEN(p)		1
! # define MB_PTR_ADV(p)		++p
! # define MB_CPTR_ADV(p)		++p
! # define MB_PTR_BACK(s, p)	--p
  # define MB_COPY_CHAR(f, t)	*t++ = *f++
  # define MB_CHARLEN(p)		STRLEN(p)
  # define MB_CHAR2LEN(c)		1
*** ../vim-8.0.0450/src/charset.c	2017-03-12 18:23:35.833850172 +0100
--- src/charset.c	2017-03-12 18:58:10.618935449 +0100
***************
*** 870,876 ****
      char_u	*s;
  
      for (s = line; *s != NUL && (len == MAXCOL || s < line + len);
! 								mb_ptr_adv(s))
  	col += win_lbr_chartabsize(wp, line, s, col, NULL);
      return (int)col;
  }
--- 870,876 ----
      char_u	*s;
  
      for (s = line; *s != NUL && (len == MAXCOL || s < line + len);
! 								MB_PTR_ADV(s))
  	col += win_lbr_chartabsize(wp, line, s, col, NULL);
      return (int)col;
  }
***************
*** 1026,1032 ****
      int		retval;
  
      retval = lbr_chartabsize(line, *s, col);
!     mb_ptr_adv(*s);
      return retval;
  }
  
--- 1026,1032 ----
      int		retval;
  
      retval = lbr_chartabsize(line, *s, col);
!     MB_PTR_ADV(*s);
      return retval;
  }
  
***************
*** 1089,1096 ****
       * needs a break here
       */
      if (wp->w_p_lbr
! 	    && vim_isbreak(c)
! 	    && !vim_isbreak(s[1])
  	    && wp->w_p_wrap
  # ifdef FEAT_WINDOWS
  	    && wp->w_width != 0
--- 1089,1096 ----
       * needs a break here
       */
      if (wp->w_p_lbr
! 	    && VIM_ISBREAK(c)
! 	    && !VIM_ISBREAK(s[1])
  	    && wp->w_p_wrap
  # ifdef FEAT_WINDOWS
  	    && wp->w_width != 0
***************
*** 1115,1126 ****
  	for (;;)
  	{
  	    ps = s;
! 	    mb_ptr_adv(s);
  	    c = *s;
  	    if (!(c != NUL
! 		    && (vim_isbreak(c)
! 			|| (!vim_isbreak(c)
! 			    && (col2 == col || !vim_isbreak(*ps))))))
  		break;
  
  	    col2 += win_chartabsize(wp, s, col2);
--- 1115,1126 ----
  	for (;;)
  	{
  	    ps = s;
! 	    MB_PTR_ADV(s);
  	    c = *s;
  	    if (!(c != NUL
! 		    && (VIM_ISBREAK(c)
! 			|| (!VIM_ISBREAK(c)
! 			    && (col2 == col || !VIM_ISBREAK(*ps))))))
  		break;
  
  	    col2 += win_chartabsize(wp, s, col2);
***************
*** 1369,1375 ****
  		break;
  
  	    vcol += incr;
! 	    mb_ptr_adv(ptr);
  	}
      }
      else
--- 1369,1375 ----
  		break;
  
  	    vcol += incr;
! 	    MB_PTR_ADV(ptr);
  	}
      }
      else
***************
*** 1390,1396 ****
  		break;
  
  	    vcol += incr;
! 	    mb_ptr_adv(ptr);
  	}
      }
      if (start != NULL)
--- 1390,1396 ----
  		break;
  
  	    vcol += incr;
! 	    MB_PTR_ADV(ptr);
  	}
      }
      if (start != NULL)
*** ../vim-8.0.0450/src/misc2.c	2017-03-01 20:40:35.623484230 +0100
--- src/misc2.c	2017-03-12 19:01:38.041461206 +0100
***************
*** 196,202 ****
  	    /* Count a tab for what it's worth (if list mode not on) */
  #ifdef FEAT_LINEBREAK
  	    csize = win_lbr_chartabsize(curwin, line, ptr, col, &head);
! 	    mb_ptr_adv(ptr);
  #else
  	    csize = lbr_chartabsize_adv(line, &ptr, col);
  #endif
--- 196,202 ----
  	    /* Count a tab for what it's worth (if list mode not on) */
  #ifdef FEAT_LINEBREAK
  	    csize = win_lbr_chartabsize(curwin, line, ptr, col, &head);
! 	    MB_PTR_ADV(ptr);
  #else
  	    csize = lbr_chartabsize_adv(line, &ptr, col);
  #endif
***************
*** 1418,1424 ****
  
      /* First count the number of extra bytes required. */
      length = (unsigned)STRLEN(string) + 3;  /* two quotes and a trailing NUL */
!     for (p = string; *p != NUL; mb_ptr_adv(p))
      {
  # ifdef WIN32
  	if (!p_ssl)
--- 1418,1424 ----
  
      /* First count the number of extra bytes required. */
      length = (unsigned)STRLEN(string) + 3;  /* two quotes and a trailing NUL */
!     for (p = string; *p != NUL; MB_PTR_ADV(p))
      {
  # ifdef WIN32
  	if (!p_ssl)
***************
*** 1950,1956 ****
      {
  	if (*p == c)
  	    retval = p;
! 	mb_ptr_adv(p);
      }
      return retval;
  }
--- 1950,1956 ----
      {
  	if (*p == c)
  	    retval = p;
! 	MB_PTR_ADV(p);
      }
      return retval;
  }
***************
*** 1971,1977 ****
      {
  	if (vim_strchr(charset, *s) != NULL)
  	    return s;
! 	mb_ptr_adv(s);
      }
      return NULL;
  }
--- 1971,1977 ----
      {
  	if (vim_strchr(charset, *s) != NULL)
  	    return s;
! 	MB_PTR_ADV(s);
      }
      return NULL;
  }
***************
*** 3364,3370 ****
   * Used for systems where stat() ignores a trailing slash on a file name.
   * The Vim code assumes a trailing slash is only ignored for a directory.
   */
!     int
  illegal_slash(char *name)
  {
      if (name[0] == NUL)
--- 3364,3370 ----
   * Used for systems where stat() ignores a trailing slash on a file name.
   * The Vim code assumes a trailing slash is only ignored for a directory.
   */
!     static int
  illegal_slash(char *name)
  {
      if (name[0] == NUL)
***************
*** 3375,3380 ****
--- 3375,3391 ----
  	return FALSE;	    /* trailing slash for a directory */
      return TRUE;
  }
+ 
+ /*
+  * Special implementation of mch_stat() for Solaris.
+  */
+     int
+ vim_stat(const char *name, stat_T *stp)
+ {
+     /* On Solaris stat() accepts "file/" as if it was "file".  Return -1 if
+      * the name ends in "/" and it's not a directory. */
+     return illegal_slash(n) ? -1 : stat(n, p);
+ }
  #endif
  
  #if defined(CURSOR_SHAPE) || defined(PROTO)
*** ../vim-8.0.0450/src/proto/misc2.pro	2017-01-26 22:51:51.997875762 +0100
--- src/proto/misc2.pro	2017-03-12 18:55:52.979925860 +0100
***************
*** 83,89 ****
  int after_pathsep(char_u *b, char_u *p);
  int same_directory(char_u *f1, char_u *f2);
  int vim_chdirfile(char_u *fname);
! int illegal_slash(char *name);
  char_u *parse_shape_opt(int what);
  int get_shape_idx(int mouse);
  void update_mouseshape(int shape_idx);
--- 83,89 ----
  int after_pathsep(char_u *b, char_u *p);
  int same_directory(char_u *f1, char_u *f2);
  int vim_chdirfile(char_u *fname);
! int vim_stat(const char *name, stat_T *stp);
  char_u *parse_shape_opt(int what);
  int get_shape_idx(int mouse);
  void update_mouseshape(int shape_idx);
*** ../vim-8.0.0450/src/edit.c	2017-03-12 18:23:35.841850113 +0100
--- src/edit.c	2017-03-12 19:07:47.134846783 +0100
***************
*** 857,863 ****
  
  		    if (str != NULL)
  		    {
! 			for (p = str; *p != NUL; mb_ptr_adv(p))
  			    ins_compl_addleader(PTR2CHAR(p));
  			vim_free(str);
  		    }
--- 857,863 ----
  
  		    if (str != NULL)
  		    {
! 			for (p = str; *p != NUL; MB_PTR_ADV(p))
  			    ins_compl_addleader(PTR2CHAR(p));
  			vim_free(str);
  		    }
***************
*** 1492,1498 ****
  		    if (*str != NUL && stop_arrow() != FAIL)
  		    {
  			/* Insert the new value of v:char literally. */
! 			for (p = str; *p != NUL; mb_ptr_adv(p))
  			{
  			    c = PTR2CHAR(p);
  			    if (c == CAR || c == K_KENTER || c == NL)
--- 1492,1498 ----
  		    if (*str != NUL && stop_arrow() != FAIL)
  		    {
  			/* Insert the new value of v:char literally. */
! 			for (p = str; *p != NUL; MB_PTR_ADV(p))
  			{
  			    c = PTR2CHAR(p);
  			    if (c == CAR || c == K_KENTER || c == NL)
***************
*** 2403,2409 ****
  	    actual_len = 0;
  	    while (*p != NUL)
  	    {
! 		mb_ptr_adv(p);
  		++actual_len;
  	    }
  	}
--- 2403,2409 ----
  	    actual_len = 0;
  	    while (*p != NUL)
  	    {
! 		MB_PTR_ADV(p);
  		++actual_len;
  	    }
  	}
***************
*** 2419,2425 ****
  	    actual_compl_length = 0;
  	    while (*p != NUL)
  	    {
! 		mb_ptr_adv(p);
  		++actual_compl_length;
  	    }
  	}
--- 2419,2425 ----
  	    actual_compl_length = 0;
  	    while (*p != NUL)
  	    {
! 		MB_PTR_ADV(p);
  		++actual_compl_length;
  	    }
  	}
***************
*** 2722,2729 ****
  #ifdef FEAT_MBYTE
  	    if (has_mbyte)
  	    {
! 		mb_ptr_adv(p);
! 		mb_ptr_adv(s);
  	    }
  	    else
  #endif
--- 2722,2729 ----
  #ifdef FEAT_MBYTE
  	    if (has_mbyte)
  	    {
! 		MB_PTR_ADV(p);
! 		MB_PTR_ADV(s);
  	    }
  	    else
  #endif
***************
*** 3474,3480 ****
  
      line = ml_get_curline();
      p = line + curwin->w_cursor.col;
!     mb_ptr_back(line, p);
  
      /* Stop completion when the whole word was deleted.  For Omni completion
       * allow the word to be deleted, we won't match everything.
--- 3474,3480 ----
  
      line = ml_get_curline();
      p = line + curwin->w_cursor.col;
!     MB_PTR_BACK(line, p);
  
      /* Stop completion when the whole word was deleted.  For Omni completion
       * allow the word to be deleted, we won't match everything.
***************
*** 4023,4029 ****
  	if (len > 0)
  	    len -= (*mb_head_off)(p, p + len);
  #endif
! 	for (p += len; *p != NUL; mb_ptr_adv(p))
  	    AppendCharToRedobuff(K_BS);
      }
      else
--- 4023,4029 ----
  	if (len > 0)
  	    len -= (*mb_head_off)(p, p + len);
  #endif
! 	for (p += len; *p != NUL; MB_PTR_ADV(p))
  	    AppendCharToRedobuff(K_BS);
      }
      else
***************
*** 5336,5344 ****
  	    {
  		char_u	*p = line + startcol;
  
! 		mb_ptr_back(line, p);
  		while (p > line && vim_isfilec(PTR2CHAR(p)))
! 		    mb_ptr_back(line, p);
  		if (p == line && vim_isfilec(PTR2CHAR(p)))
  		    startcol = 0;
  		else
--- 5336,5344 ----
  	    {
  		char_u	*p = line + startcol;
  
! 		MB_PTR_BACK(line, p);
  		while (p > line && vim_isfilec(PTR2CHAR(p)))
! 		    MB_PTR_BACK(line, p);
  		if (p == line && vim_isfilec(PTR2CHAR(p)))
  		    startcol = 0;
  		else
*** ../vim-8.0.0450/src/eval.c	2017-02-25 21:39:13.300021243 +0100
--- src/eval.c	2017-03-12 19:08:01.706743504 +0100
***************
*** 2551,2557 ****
  	    for (p = arg + STRLEN(arg); p >= arg; )
  	    {
  		xp->xp_pattern = p;
! 		mb_ptr_back(arg, p);
  		if (vim_iswhite(*p))
  		    break;
  	    }
--- 2551,2557 ----
  	    for (p = arg + STRLEN(arg); p >= arg; )
  	    {
  		xp->xp_pattern = p;
! 		MB_PTR_BACK(arg, p);
  		if (vim_iswhite(*p))
  		    break;
  	    }
***************
*** 4814,4820 ****
      /*
       * Find the end of the string, skipping backslashed characters.
       */
!     for (p = *arg + 1; *p != NUL && *p != '"'; mb_ptr_adv(p))
      {
  	if (*p == '\\' && p[1] != NUL)
  	{
--- 4814,4820 ----
      /*
       * Find the end of the string, skipping backslashed characters.
       */
!     for (p = *arg + 1; *p != NUL && *p != '"'; MB_PTR_ADV(p))
      {
  	if (*p == '\\' && p[1] != NUL)
  	{
***************
*** 4952,4958 ****
      /*
       * Find the end of the string, skipping ''.
       */
!     for (p = *arg + 1; *p != NUL; mb_ptr_adv(p))
      {
  	if (*p == '\'')
  	{
--- 4952,4958 ----
      /*
       * Find the end of the string, skipping ''.
       */
!     for (p = *arg + 1; *p != NUL; MB_PTR_ADV(p))
      {
  	if (*p == '\'')
  	{
***************
*** 5910,5916 ****
      if (str != NULL)
      {
  	len += (unsigned)STRLEN(str);
! 	for (p = str; *p != NUL; mb_ptr_adv(p))
  	    if (*p == '\'')
  		++len;
      }
--- 5910,5916 ----
      if (str != NULL)
      {
  	len += (unsigned)STRLEN(str);
! 	for (p = str; *p != NUL; MB_PTR_ADV(p))
  	    if (*p == '\'')
  		++len;
      }
***************
*** 6369,6380 ****
  			|| *p == '{'
  			|| ((flags & FNE_INCL_BR) && (*p == '[' || *p == '.'))
  			|| mb_nest != 0
! 			|| br_nest != 0); mb_ptr_adv(p))
      {
  	if (*p == '\'')
  	{
  	    /* skip over 'string' to avoid counting [ and ] inside it. */
! 	    for (p = p + 1; *p != NUL && *p != '\''; mb_ptr_adv(p))
  		;
  	    if (*p == NUL)
  		break;
--- 6369,6380 ----
  			|| *p == '{'
  			|| ((flags & FNE_INCL_BR) && (*p == '[' || *p == '.'))
  			|| mb_nest != 0
! 			|| br_nest != 0); MB_PTR_ADV(p))
      {
  	if (*p == '\'')
  	{
  	    /* skip over 'string' to avoid counting [ and ] inside it. */
! 	    for (p = p + 1; *p != NUL && *p != '\''; MB_PTR_ADV(p))
  		;
  	    if (*p == NUL)
  		break;
***************
*** 6382,6388 ****
  	else if (*p == '"')
  	{
  	    /* skip over "str\"ing" to avoid counting [ and ] inside it. */
! 	    for (p = p + 1; *p != NUL && *p != '"'; mb_ptr_adv(p))
  		if (*p == '\\' && p[1] != NUL)
  		    ++p;
  	    if (*p == NUL)
--- 6382,6388 ----
  	else if (*p == '"')
  	{
  	    /* skip over "str\"ing" to avoid counting [ and ] inside it. */
! 	    for (p = p + 1; *p != NUL && *p != '"'; MB_PTR_ADV(p))
  		if (*p == '\\' && p[1] != NUL)
  		    ++p;
  	    if (*p == NUL)
***************
*** 9410,9416 ****
      /* Count up the path separators from the RHS.. so we know which part
       * of the path to return. */
      sepcount = 0;
!     for (p = *fnamep; p < *fnamep + *fnamelen; mb_ptr_adv(p))
  	if (vim_ispathsep(*p))
  	    ++sepcount;
  
--- 9410,9416 ----
      /* Count up the path separators from the RHS.. so we know which part
       * of the path to return. */
      sepcount = 0;
!     for (p = *fnamep; p < *fnamep + *fnamelen; MB_PTR_ADV(p))
  	if (vim_ispathsep(*p))
  	    ++sepcount;
  
***************
*** 9528,9534 ****
  	}
  
  	/* When "/." or "/.." is used: force expansion to get rid of it. */
! 	for (p = *fnamep; *p != NUL; mb_ptr_adv(p))
  	{
  	    if (vim_ispathsep(*p)
  		    && p[1] == '.'
--- 9528,9534 ----
  	}
  
  	/* When "/." or "/.." is used: force expansion to get rid of it. */
! 	for (p = *fnamep; *p != NUL; MB_PTR_ADV(p))
  	{
  	    if (vim_ispathsep(*p)
  		    && p[1] == '.'
***************
*** 9658,9664 ****
  	*usedlen += 2;
  	s = get_past_head(*fnamep);
  	while (tail > s && after_pathsep(s, tail))
! 	    mb_ptr_back(*fnamep, tail);
  	*fnamelen = (int)(tail - *fnamep);
  #ifdef VMS
  	if (*fnamelen > 0)
--- 9658,9664 ----
  	*usedlen += 2;
  	s = get_past_head(*fnamep);
  	while (tail > s && after_pathsep(s, tail))
! 	    MB_PTR_BACK(*fnamep, tail);
  	*fnamelen = (int)(tail - *fnamep);
  #ifdef VMS
  	if (*fnamelen > 0)
***************
*** 9677,9683 ****
  	else
  	{
  	    while (tail > s && !after_pathsep(s, tail))
! 		mb_ptr_back(*fnamep, tail);
  	}
      }
  
--- 9677,9683 ----
  	else
  	{
  	    while (tail > s && !after_pathsep(s, tail))
! 		MB_PTR_BACK(*fnamep, tail);
  	}
      }
  
*** ../vim-8.0.0450/src/ex_cmds.c	2017-03-12 18:32:26.778036451 +0100
--- src/ex_cmds.c	2017-03-12 18:58:58.438591324 +0100
***************
*** 4863,4869 ****
  	    }
  	    if (cmd[0] == '\\' && cmd[1] != 0)	/* skip escaped characters */
  		++cmd;
! 	    mb_ptr_adv(cmd);
  	}
  
  	if (!eap->skip)
--- 4863,4869 ----
  	    }
  	    if (cmd[0] == '\\' && cmd[1] != 0)	/* skip escaped characters */
  		++cmd;
! 	    MB_PTR_ADV(cmd);
  	}
  
  	if (!eap->skip)
*** ../vim-8.0.0450/src/ex_cmds2.c	2017-03-09 15:58:26.548668478 +0100
--- src/ex_cmds2.c	2017-03-12 18:59:10.966502141 +0100
***************
*** 3526,3532 ****
      {
  	/* directory is not yet in 'runtimepath', add it */
  	p4 = p3 = p2 = p1 = get_past_head(ffname);
! 	for (p = p1; *p; mb_ptr_adv(p))
  	    if (vim_ispathsep_nocolon(*p))
  	    {
  		p4 = p3; p3 = p2; p2 = p1; p1 = p;
--- 3526,3532 ----
      {
  	/* directory is not yet in 'runtimepath', add it */
  	p4 = p3 = p2 = p1 = get_past_head(ffname);
! 	for (p = p1; *p; MB_PTR_ADV(p))
  	    if (vim_ispathsep_nocolon(*p))
  	    {
  		p4 = p3; p3 = p2; p2 = p1; p1 = p;
*** ../vim-8.0.0450/src/ex_docmd.c	2017-03-01 18:04:01.579277621 +0100
--- src/ex_docmd.c	2017-03-12 18:59:32.042353006 +0100
***************
*** 3696,3702 ****
  		    return NULL;    /* It's a comment */
  		}
  	    }
! 	    mb_ptr_adv(p);
  	}
      }
  
--- 3696,3702 ----
  		    return NULL;    /* It's a comment */
  		}
  	    }
! 	    MB_PTR_ADV(p);
  	}
      }
  
***************
*** 3720,3726 ****
  	{
  	    if (*p == '\\' && *(p + 1) != NUL)
  		++p; /* skip over escaped character */
! 	    mb_ptr_adv(p);
  	}
      }
  
--- 3720,3726 ----
  	{
  	    if (*p == '\\' && *(p + 1) != NUL)
  		++p; /* skip over escaped character */
! 	    MB_PTR_ADV(p);
  	}
      }
  
***************
*** 3780,3786 ****
  		    else
  #endif
  			len = 1;
! 		    mb_ptr_adv(p);
  		}
  		if (in_quote)
  		    bow = p;
--- 3780,3786 ----
  		    else
  #endif
  			len = 1;
! 		    MB_PTR_ADV(p);
  		}
  		if (in_quote)
  		    bow = p;
***************
*** 3788,3794 ****
  		    xp->xp_pattern = p;
  		p -= len;
  	    }
! 	    mb_ptr_adv(p);
  	}
  
  	/*
--- 3788,3794 ----
  		    xp->xp_pattern = p;
  		p -= len;
  	    }
! 	    MB_PTR_ADV(p);
  	}
  
  	/*
***************
*** 4204,4210 ****
  			    arg = p + 1;
  			else if (*p == '\\' && *(p + 1) != NUL)
  			    ++p; /* skip over escaped character */
! 			mb_ptr_adv(p);
  		    }
  		    xp->xp_pattern = arg;
  		}
--- 4204,4210 ----
  			    arg = p + 1;
  			else if (*p == '\\' && *(p + 1) != NUL)
  			    ++p; /* skip over escaped character */
! 			MB_PTR_ADV(p);
  		    }
  		    xp->xp_pattern = arg;
  		}
***************
*** 5280,5286 ****
      p = eap->arg;
  #endif
  
!     for ( ; *p; mb_ptr_adv(p))
      {
  	if (*p == Ctrl_V)
  	{
--- 5280,5286 ----
      p = eap->arg;
  #endif
  
!     for ( ; *p; MB_PTR_ADV(p))
      {
  	if (*p == Ctrl_V)
  	{
***************
*** 5380,5386 ****
  	    else
  		++p;
  	}
! 	mb_ptr_adv(p);
      }
      return p;
  }
--- 5380,5386 ----
  	    else
  		++p;
  	}
! 	MB_PTR_ADV(p);
      }
      return p;
  }
***************
*** 11861,11867 ****
      if (*flagp & SSOP_SLASH)
      {
  	/* change all backslashes to forward slashes */
! 	for (p = sname; *p != NUL; mb_ptr_adv(p))
  	    if (*p == '\\')
  		*p = '/';
      }
--- 11861,11867 ----
      if (*flagp & SSOP_SLASH)
      {
  	/* change all backslashes to forward slashes */
! 	for (p = sname; *p != NUL; MB_PTR_ADV(p))
  	    if (*p == '\\')
  		*p = '/';
      }
*** ../vim-8.0.0450/src/ex_getln.c	2017-03-12 18:23:35.845850084 +0100
--- src/ex_getln.c	2017-03-12 19:08:06.822707243 +0100
***************
*** 4296,4302 ****
  	    t = p;
  	    had_sep = FALSE;
  	}
! 	mb_ptr_adv(p);
      }
      return t;
  }
--- 4296,4302 ----
  	    t = p;
  	    had_sep = FALSE;
  	}
! 	MB_PTR_ADV(p);
      }
      return t;
  }
***************
*** 5370,5376 ****
  	if (e - 4 > s && STRNICMP(e - 4, ".vim", 4) == 0)
  	{
  	    e -= 4;
! 	    for (s = e; s > match; mb_ptr_back(match, s))
  		if (s < match || vim_ispathsep(*s))
  		    break;
  	    ++s;
--- 5370,5376 ----
  	if (e - 4 > s && STRNICMP(e - 4, ".vim", 4) == 0)
  	{
  	    e -= 4;
! 	    for (s = e; s > match; MB_PTR_BACK(match, s))
  		if (s < match || vim_ispathsep(*s))
  		    break;
  	    ++s;
*** ../vim-8.0.0450/src/fileio.c	2017-03-12 18:23:35.849850055 +0100
--- src/fileio.c	2017-03-12 19:08:17.354632595 +0100
***************
*** 6247,6253 ****
       * Then truncate what is after the '/', '\' or ':' to 8 characters for
       * MSDOS and 26 characters for AMIGA, a lot more for UNIX.
       */
!     for (ptr = retval + fnamelen; ptr > retval; mb_ptr_back(retval, ptr))
      {
  	if (*ext == '.'
  #ifdef USE_LONG_FNAME
--- 6247,6253 ----
       * Then truncate what is after the '/', '\' or ':' to 8 characters for
       * MSDOS and 26 characters for AMIGA, a lot more for UNIX.
       */
!     for (ptr = retval + fnamelen; ptr > retval; MB_PTR_BACK(retval, ptr))
      {
  	if (*ext == '.'
  #ifdef USE_LONG_FNAME
*** ../vim-8.0.0450/src/fold.c	2017-03-12 18:23:35.849850055 +0100
--- src/fold.c	2017-03-12 18:59:56.658178808 +0100
***************
*** 2064,2070 ****
  	}
  	else
  	{
! 	    mb_ptr_adv(s);
  	}
      }
  }
--- 2064,2070 ----
  	}
  	else
  	{
! 	    MB_PTR_ADV(s);
  	}
      }
  }
***************
*** 3249,3255 ****
  		--flp->lvl_next;
  	}
  	else
! 	    mb_ptr_adv(s);
      }
  
      /* The level can't go negative, must be missing a start marker. */
--- 3249,3255 ----
  		--flp->lvl_next;
  	}
  	else
! 	    MB_PTR_ADV(s);
      }
  
      /* The level can't go negative, must be missing a start marker. */
*** ../vim-8.0.0450/src/gui.c	2017-03-12 18:23:35.849850055 +0100
--- src/gui.c	2017-03-12 19:00:07.706100621 +0100
***************
*** 4500,4506 ****
  	for (;;)
  	{
  	    w = chartabsize(p, col);
! 	    mb_ptr_adv(p);
  	    if (*p == NUL)		/* don't count the last character */
  		break;
  	    col += w;
--- 4500,4506 ----
  	for (;;)
  	{
  	    w = chartabsize(p, col);
! 	    MB_PTR_ADV(p);
  	    if (*p == NUL)		/* don't count the last character */
  		break;
  	    col += w;
*** ../vim-8.0.0450/src/gui_gtk.c	2017-01-09 20:30:23.898717562 +0100
--- src/gui_gtk.c	2017-03-12 19:00:17.666030132 +0100
***************
*** 1522,1528 ****
  	    else if (*p == DLG_HOTKEY_CHAR)
  		*p++ = '_';
  	    else
! 		mb_ptr_adv(p);
  	}
  	array[count] = NULL; /* currently not relied upon, but doesn't hurt */
      }
--- 1522,1528 ----
  	    else if (*p == DLG_HOTKEY_CHAR)
  		*p++ = '_';
  	    else
! 		MB_PTR_ADV(p);
  	}
  	array[count] = NULL; /* currently not relied upon, but doesn't hurt */
      }
*** ../vim-8.0.0450/src/mark.c	2017-03-12 18:23:35.849850055 +0100
--- src/mark.c	2017-03-12 19:00:28.253955195 +0100
***************
*** 695,701 ****
  	return NULL;
      /* Truncate the line to fit it in the window */
      len = 0;
!     for (p = s; *p != NUL; mb_ptr_adv(p))
      {
  	len += ptr2cells(p);
  	if (len >= Columns - lead_len)
--- 695,701 ----
  	return NULL;
      /* Truncate the line to fit it in the window */
      len = 0;
!     for (p = s; *p != NUL; MB_PTR_ADV(p))
      {
  	len += ptr2cells(p);
  	if (len >= Columns - lead_len)
*** ../vim-8.0.0450/src/memline.c	2017-02-28 21:26:12.826899315 +0100
--- src/memline.c	2017-03-12 19:00:40.953865307 +0100
***************
*** 2028,2034 ****
  	if (s != NULL)
  	{
  	    STRCPY(s, f);
! 	    for (d = s; *d != NUL; mb_ptr_adv(d))
  		if (vim_ispathsep(*d))
  		    *d = '%';
  	    d = concat_fnames(dir, s, TRUE);
--- 2028,2034 ----
  	if (s != NULL)
  	{
  	    STRCPY(s, f);
! 	    for (d = s; *d != NUL; MB_PTR_ADV(d))
  		if (vim_ispathsep(*d))
  		    *d = '%';
  	    d = concat_fnames(dir, s, TRUE);
***************
*** 4015,4021 ****
  
  #ifdef WIN3264
      if (retval != NULL)
! 	for (t = gettail(retval); *t != NUL; mb_ptr_adv(t))
  	    if (*t == ':')
  		*t = '%';
  #endif
--- 4015,4021 ----
  
  #ifdef WIN3264
      if (retval != NULL)
! 	for (t = gettail(retval); *t != NUL; MB_PTR_ADV(t))
  	    if (*t == ':')
  		*t = '%';
  #endif
***************
*** 4154,4160 ****
  	if (buf_fname == NULL)
  	    buf_fname = buf->b_fname;
  	else
! 	    for (t = gettail(buf_fname); *t != NUL; mb_ptr_adv(t))
  		if (*t == ':')
  		    *t = '%';
      }
--- 4154,4160 ----
  	if (buf_fname == NULL)
  	    buf_fname = buf->b_fname;
  	else
! 	    for (t = gettail(buf_fname); *t != NUL; MB_PTR_ADV(t))
  		if (*t == ':')
  		    *t = '%';
      }
*** ../vim-8.0.0450/src/mbyte.c	2017-01-28 16:39:15.876735290 +0100
--- src/mbyte.c	2017-03-12 19:08:51.382391396 +0100
***************
*** 4047,4053 ****
      char_u *p)
  {
      if (p > line)
! 	mb_ptr_back(line, p);
      return p;
  }
  
--- 4047,4053 ----
      char_u *p)
  {
      if (p > line)
! 	MB_PTR_BACK(line, p);
      return p;
  }
  
***************
*** 5708,5714 ****
  
  
  #ifdef USE_X11R6_XIM
- static void xim_instantiate_cb(Display *display, XPointer client_data, XPointer	call_data);
  static void xim_destroy_cb(XIM im, XPointer client_data, XPointer call_data);
  
      static void
--- 5708,5713 ----
*** ../vim-8.0.0450/src/menu.c	2017-03-04 20:41:30.776854255 +0100
--- src/menu.c	2017-03-12 19:00:53.449776860 +0100
***************
*** 152,158 ****
  	{
  	    if (*arg == '\\')
  		STRMOVE(arg, arg + 1);
! 	    mb_ptr_adv(arg);
  	}
  	if (*arg != NUL)
  	{
--- 152,158 ----
  	{
  	    if (*arg == '\\')
  		STRMOVE(arg, arg + 1);
! 	    MB_PTR_ADV(arg);
  	}
  	if (*arg != NUL)
  	{
***************
*** 661,667 ****
  
  		    STRCPY(tearpath, menu_path);
  		    idx = (int)(next_name - path_name - 1);
! 		    for (s = tearpath; *s && s < tearpath + idx; mb_ptr_adv(s))
  		    {
  			if ((*s == '\\' || *s == Ctrl_V) && s[1])
  			{
--- 661,667 ----
  
  		    STRCPY(tearpath, menu_path);
  		    idx = (int)(next_name - path_name - 1);
! 		    for (s = tearpath; *s && s < tearpath + idx; MB_PTR_ADV(s))
  		    {
  			if ((*s == '\\' || *s == Ctrl_V) && s[1])
  			{
***************
*** 1472,1478 ****
  {
      char_u  *p;
  
!     for (p = name; *p && *p != '.'; mb_ptr_adv(p))
      {
  	if (*p == '\\' || *p == Ctrl_V)
  	{
--- 1472,1478 ----
  {
      char_u  *p;
  
!     for (p = name; *p && *p != '.'; MB_PTR_ADV(p))
      {
  	if (*p == '\\' || *p == Ctrl_V)
  	{
***************
*** 2485,2491 ****
  {
      char_u  *p;
  
!     for (p = name; *p && *p != '.'; mb_ptr_adv(p))
  	if (*p == '\\')
  	    STRMOVE(p, p + 1);
  }
--- 2485,2491 ----
  {
      char_u  *p;
  
!     for (p = name; *p && *p != '.'; MB_PTR_ADV(p))
  	if (*p == '\\')
  	    STRMOVE(p, p + 1);
  }
*** ../vim-8.0.0450/src/message.c	2017-03-01 20:40:35.623484230 +0100
--- src/message.c	2017-03-12 19:01:05.689690221 +0100
***************
*** 3746,3752 ****
  	    }
  
  	    /* advance to the next character */
! 	    mb_ptr_adv(r);
  	}
  
  	if (copy)
--- 3746,3752 ----
  	    }
  
  	    /* advance to the next character */
! 	    MB_PTR_ADV(r);
  	}
  
  	if (copy)
*** ../vim-8.0.0450/src/misc1.c	2017-03-12 18:23:35.853850026 +0100
--- src/misc1.c	2017-03-12 19:08:58.114343675 +0100
***************
*** 1140,1146 ****
  
  			    while (old_size < repl_size && p > leader)
  			    {
! 				mb_ptr_back(leader, p);
  				old_size += ptr2cells(p);
  			    }
  			    l = lead_repl_len - (int)(endp - p);
--- 1140,1146 ----
  
  			    while (old_size < repl_size && p > leader)
  			    {
! 				MB_PTR_BACK(leader, p);
  				old_size += ptr2cells(p);
  			    }
  			    l = lead_repl_len - (int)(endp - p);
***************
*** 2070,2076 ****
      while (*s != NUL && --column >= 0)
      {
  	col += win_lbr_chartabsize(wp, line, s, (colnr_T)col, NULL);
! 	mb_ptr_adv(s);
      }
  
      /*
--- 2070,2076 ----
      while (*s != NUL && --column >= 0)
      {
  	col += win_lbr_chartabsize(wp, line, s, (colnr_T)col, NULL);
! 	MB_PTR_ADV(s);
      }
  
      /*
***************
*** 4837,4843 ****
      {
  	if (vim_ispathsep_nocolon(*p2))
  	    p1 = p2 + 1;
! 	mb_ptr_adv(p2);
      }
      return p1;
  }
--- 4837,4843 ----
      {
  	if (vim_ispathsep_nocolon(*p2))
  	    p1 = p2 + 1;
! 	MB_PTR_ADV(p2);
      }
      return p1;
  }
***************
*** 4875,4881 ****
  		dir_end = next_dir_end;
  	    look_for_sep = TRUE;
  	}
! 	mb_ptr_adv(p);
      }
      return dir_end;
  }
--- 4875,4881 ----
  		dir_end = next_dir_end;
  	    look_for_sep = TRUE;
  	}
! 	MB_PTR_ADV(p);
      }
      return dir_end;
  }
***************
*** 4910,4916 ****
  getnextcomp(char_u *fname)
  {
      while (*fname && !vim_ispathsep(*fname))
! 	mb_ptr_adv(fname);
      if (*fname)
  	++fname;
      return fname;
--- 4910,4916 ----
  getnextcomp(char_u *fname)
  {
      while (*fname && !vim_ispathsep(*fname))
! 	MB_PTR_ADV(fname);
      if (*fname)
  	++fname;
      return fname;
***************
*** 10378,10384 ****
      {
  	if (vim_ispathsep(**psep))
  	    return OK;
! 	mb_ptr_back(path, *psep);
      }
  
      return FAIL;
--- 10378,10384 ----
      {
  	if (vim_ispathsep(**psep))
  	    return OK;
! 	MB_PTR_BACK(path, *psep);
      }
  
      return FAIL;
***************
*** 10533,10539 ****
      /* skip to the file or directory name */
      if (cutoff != NULL)
  	while (vim_ispathsep(*cutoff))
! 	    mb_ptr_adv(cutoff);
  
      return cutoff;
  }
--- 10533,10539 ----
      /* skip to the file or directory name */
      if (cutoff != NULL)
  	while (vim_ispathsep(*cutoff))
! 	    MB_PTR_ADV(cutoff);
  
      return cutoff;
  }
***************
*** 10790,10796 ****
      static int
  has_env_var(char_u *p)
  {
!     for ( ; *p; mb_ptr_adv(p))
      {
  	if (*p == '\\' && p[1] != NUL)
  	    ++p;
--- 10790,10796 ----
      static int
  has_env_var(char_u *p)
  {
!     for ( ; *p; MB_PTR_ADV(p))
      {
  	if (*p == '\\' && p[1] != NUL)
  	    ++p;
***************
*** 10816,10822 ****
      static int
  has_special_wildchar(char_u *p)
  {
!     for ( ; *p; mb_ptr_adv(p))
      {
  	/* Allow for escaping. */
  	if (*p == '\\' && p[1] != NUL)
--- 10816,10822 ----
      static int
  has_special_wildchar(char_u *p)
  {
!     for ( ; *p; MB_PTR_ADV(p))
      {
  	/* Allow for escaping. */
  	if (*p == '\\' && p[1] != NUL)
***************
*** 11293,11299 ****
  
  	/* Find the last path separator before the space. */
  	p1 = p_sh;
! 	for (p2 = p_sh; p2 < p; mb_ptr_adv(p2))
  	    if (vim_ispathsep(*p2))
  		p1 = p2 + 1;
  	p = vim_strnsave(p1, (int)(p - p1));
--- 11293,11299 ----
  
  	/* Find the last path separator before the space. */
  	p1 = p_sh;
! 	for (p2 = p_sh; p2 < p; MB_PTR_ADV(p2))
  	    if (vim_ispathsep(*p2))
  		p1 = p2 + 1;
  	p = vim_strnsave(p1, (int)(p - p1));
*** ../vim-8.0.0450/src/ops.c	2017-03-12 18:23:35.837850143 +0100
--- src/ops.c	2017-03-12 19:09:08.666268873 +0100
***************
*** 486,492 ****
  	 * the part of which is displayed at the block's beginning. Let's start
  	 * searching from the next character. */
  	if (bd.startspaces)
! 	    mb_ptr_adv(non_white);
  
  	/* The character's column is in "bd.start_vcol".  */
  	non_white_col = bd.start_vcol;
--- 486,492 ----
  	 * the part of which is displayed at the block's beginning. Let's start
  	 * searching from the next character. */
  	if (bd.startspaces)
! 	    MB_PTR_ADV(non_white);
  
  	/* The character's column is in "bd.start_vcol".  */
  	non_white_col = bd.start_vcol;
***************
*** 526,532 ****
  	    if (verbatim_copy_width + incr > destination_col)
  		break;
  	    verbatim_copy_width += incr;
! 	    mb_ptr_adv(verbatim_copy_end);
  	}
  
  	/* If "destination_col" is different from the width of the initial
--- 526,532 ----
  	    if (verbatim_copy_width + incr > destination_col)
  		break;
  	    verbatim_copy_width += incr;
! 	    MB_PTR_ADV(verbatim_copy_end);
  	}
  
  	/* If "destination_col" is different from the width of the initial
***************
*** 3458,3464 ****
  		goto end;
  	    p = ml_get_cursor();
  	    if (dir == FORWARD && *p != NUL)
! 		mb_ptr_adv(p);
  	    ptr = vim_strsave(p);
  	    if (ptr == NULL)
  		goto end;
--- 3458,3464 ----
  		goto end;
  	    p = ml_get_cursor();
  	    if (dir == FORWARD && *p != NUL)
! 		MB_PTR_ADV(p);
  	    ptr = vim_strsave(p);
  	    if (ptr == NULL)
  		goto end;
***************
*** 3468,3474 ****
  	    oldp = ml_get_curline();
  	    p = oldp + curwin->w_cursor.col;
  	    if (dir == FORWARD && *p != NUL)
! 		mb_ptr_adv(p);
  	    ptr = vim_strnsave(oldp, p - oldp);
  	    if (ptr == NULL)
  		goto end;
--- 3468,3474 ----
  	    oldp = ml_get_curline();
  	    p = oldp + curwin->w_cursor.col;
  	    if (dir == FORWARD && *p != NUL)
! 		MB_PTR_ADV(p);
  	    ptr = vim_strnsave(oldp, p - oldp);
  	    if (ptr == NULL)
  		goto end;
***************
*** 4489,4499 ****
  	    if (has_mbyte)
  	    {
  		cend = curr + currsize;
! 		mb_ptr_back(curr, cend);
  		endcurr1 = (*mb_ptr2char)(cend);
  		if (cend > curr)
  		{
! 		    mb_ptr_back(curr, cend);
  		    endcurr2 = (*mb_ptr2char)(cend);
  		}
  	    }
--- 4489,4499 ----
  	    if (has_mbyte)
  	    {
  		cend = curr + currsize;
! 		MB_PTR_BACK(curr, cend);
  		endcurr1 = (*mb_ptr2char)(cend);
  		if (cend > curr)
  		{
! 		    MB_PTR_BACK(curr, cend);
  		    endcurr2 = (*mb_ptr2char)(cend);
  		}
  	    }
***************
*** 5262,5268 ****
  	}
  #endif
  	prev_pstart = pstart;
! 	mb_ptr_adv(pstart);
      }
      bdp->start_char_vcols = incr;
      if (bdp->start_vcol < oap->start_vcol)	/* line too short */
--- 5262,5268 ----
  	}
  #endif
  	prev_pstart = pstart;
! 	MB_PTR_ADV(pstart);
      }
      bdp->start_char_vcols = incr;
      if (bdp->start_vcol < oap->start_vcol)	/* line too short */
*** ../vim-8.0.0450/src/option.c	2017-03-12 18:23:35.857849997 +0100
--- src/option.c	2017-03-12 19:02:01.857292599 +0100
***************
*** 6785,6791 ****
  	{
  	    if (ptr2cells(s) != 1)
  		errmsg = (char_u *)N_("E595: contains unprintable or wide character");
! 	    mb_ptr_adv(s);
  	}
      }
  #endif
--- 6785,6791 ----
  	{
  	    if (ptr2cells(s) != 1)
  		errmsg = (char_u *)N_("E595: contains unprintable or wide character");
! 	    MB_PTR_ADV(s);
  	}
      }
  #endif
***************
*** 11666,11672 ****
  #ifdef BACKSLASH_IN_FILENAME
      /* For MS-Windows et al. we don't double backslashes at the start and
       * before a file name character. */
!     for (var = buf; *var != NUL; mb_ptr_adv(var))
  	if (var[0] == '\\' && var[1] == '\\'
  		&& expand_option_idx >= 0
  		&& (options[expand_option_idx].flags & P_EXPAND)
--- 11666,11672 ----
  #ifdef BACKSLASH_IN_FILENAME
      /* For MS-Windows et al. we don't double backslashes at the start and
       * before a file name character. */
!     for (var = buf; *var != NUL; MB_PTR_ADV(var))
  	if (var[0] == '\\' && var[1] == '\\'
  		&& expand_option_idx >= 0
  		&& (options[expand_option_idx].flags & P_EXPAND)
***************
*** 11866,11872 ****
      for (p = p_langmap; p[0] != NUL; )
      {
  	for (p2 = p; p2[0] != NUL && p2[0] != ',' && p2[0] != ';';
! 							       mb_ptr_adv(p2))
  	{
  	    if (p2[0] == '\\' && p2[1] != NUL)
  		++p2;
--- 11866,11872 ----
      for (p = p_langmap; p[0] != NUL; )
      {
  	for (p2 = p; p2[0] != NUL && p2[0] != ',' && p2[0] != ';';
! 							       MB_PTR_ADV(p2))
  	{
  	    if (p2[0] == '\\' && p2[1] != NUL)
  		++p2;
***************
*** 11892,11898 ****
  	    to = NUL;
  	    if (p2 == NULL)
  	    {
! 		mb_ptr_adv(p);
  		if (p[0] != ',')
  		{
  		    if (p[0] == '\\')
--- 11892,11898 ----
  	    to = NUL;
  	    if (p2 == NULL)
  	    {
! 		MB_PTR_ADV(p);
  		if (p[0] != ',')
  		{
  		    if (p[0] == '\\')
***************
*** 11932,11941 ****
  		langmap_mapchar[from & 255] = to;
  
  	    /* Advance to next pair */
! 	    mb_ptr_adv(p);
  	    if (p2 != NULL)
  	    {
! 		mb_ptr_adv(p2);
  		if (*p == ';')
  		{
  		    p = p2;
--- 11932,11941 ----
  		langmap_mapchar[from & 255] = to;
  
  	    /* Advance to next pair */
! 	    MB_PTR_ADV(p);
  	    if (p2 != NULL)
  	    {
! 		MB_PTR_ADV(p2);
  		if (*p == ';')
  		{
  		    p = p2;
*** ../vim-8.0.0450/src/os_amiga.c	2017-02-05 15:10:47.747484014 +0100
--- src/os_amiga.c	2017-03-12 19:02:12.409217892 +0100
***************
*** 1567,1573 ****
      int
  mch_has_exp_wildcard(char_u *p)
  {
!     for ( ; *p; mb_ptr_adv(p))
      {
  	if (*p == '\\' && p[1] != NUL)
  	    ++p;
--- 1567,1573 ----
      int
  mch_has_exp_wildcard(char_u *p)
  {
!     for ( ; *p; MB_PTR_ADV(p))
      {
  	if (*p == '\\' && p[1] != NUL)
  	    ++p;
***************
*** 1580,1586 ****
      int
  mch_has_wildcard(char_u *p)
  {
!     for ( ; *p; mb_ptr_adv(p))
      {
  	if (*p == '\\' && p[1] != NUL)
  	    ++p;
--- 1580,1586 ----
      int
  mch_has_wildcard(char_u *p)
  {
!     for ( ; *p; MB_PTR_ADV(p))
      {
  	if (*p == '\\' && p[1] != NUL)
  	    ++p;
*** ../vim-8.0.0450/src/os_mswin.c	2017-02-05 15:10:47.743484042 +0100
--- src/os_mswin.c	2017-03-12 19:09:16.362214316 +0100
***************
*** 454,460 ****
      {
  	if (*p == psepcN)
  	    *p = psepc;
! 	mb_ptr_adv(p);
      }
  }
  
--- 454,460 ----
      {
  	if (*p == psepcN)
  	    *p = psepc;
! 	MB_PTR_ADV(p);
      }
  }
  
***************
*** 600,606 ****
      vim_strncpy((char_u *)buf, (char_u *)name, sizeof(buf) - 1);
      p = buf + STRLEN(buf);
      if (p > buf)
! 	mb_ptr_back(buf, p);
  
      /* Remove trailing '\\' except root path. */
      if (p > buf && (*p == '\\' || *p == '/') && p[-1] != ':')
--- 600,606 ----
      vim_strncpy((char_u *)buf, (char_u *)name, sizeof(buf) - 1);
      p = buf + STRLEN(buf);
      if (p > buf)
! 	MB_PTR_BACK(buf, p);
  
      /* Remove trailing '\\' except root path. */
      if (p > buf && (*p == '\\' || *p == '/') && p[-1] != ':')
***************
*** 720,726 ****
      int
  mch_has_exp_wildcard(char_u *p)
  {
!     for ( ; *p; mb_ptr_adv(p))
      {
  	if (vim_strchr((char_u *)"?*[", *p) != NULL
  		|| (*p == '~' && p[1] != NUL))
--- 720,726 ----
      int
  mch_has_exp_wildcard(char_u *p)
  {
!     for ( ; *p; MB_PTR_ADV(p))
      {
  	if (vim_strchr((char_u *)"?*[", *p) != NULL
  		|| (*p == '~' && p[1] != NUL))
***************
*** 736,742 ****
      int
  mch_has_wildcard(char_u *p)
  {
!     for ( ; *p; mb_ptr_adv(p))
      {
  	if (vim_strchr((char_u *)
  #  ifdef VIM_BACKTICK
--- 736,742 ----
      int
  mch_has_wildcard(char_u *p)
  {
!     for ( ; *p; MB_PTR_ADV(p))
      {
  	if (vim_strchr((char_u *)
  #  ifdef VIM_BACKTICK
*** ../vim-8.0.0450/src/os_unix.c	2017-03-11 20:03:37.845266804 +0100
--- src/os_unix.c	2017-03-12 19:02:35.037057679 +0100
***************
*** 6522,6528 ****
      int
  mch_has_exp_wildcard(char_u *p)
  {
!     for ( ; *p; mb_ptr_adv(p))
      {
  	if (*p == '\\' && p[1] != NUL)
  	    ++p;
--- 6522,6528 ----
      int
  mch_has_exp_wildcard(char_u *p)
  {
!     for ( ; *p; MB_PTR_ADV(p))
      {
  	if (*p == '\\' && p[1] != NUL)
  	    ++p;
***************
*** 6546,6552 ****
      int
  mch_has_wildcard(char_u *p)
  {
!     for ( ; *p; mb_ptr_adv(p))
      {
  	if (*p == '\\' && p[1] != NUL)
  	    ++p;
--- 6546,6552 ----
      int
  mch_has_wildcard(char_u *p)
  {
!     for ( ; *p; MB_PTR_ADV(p))
      {
  	if (*p == '\\' && p[1] != NUL)
  	    ++p;
*** ../vim-8.0.0450/src/os_win32.c	2017-03-05 19:49:09.402670667 +0100
--- src/os_win32.c	2017-03-12 19:06:41.107314695 +0100
***************
*** 5741,5747 ****
  	{
  	    char_u *p = pchBuf;
  	    for (n = 0; n < cchwritten; n++)
! 		mb_cptr_adv(p);
  	    written = p - pchBuf;
  	    g_coord.X += (SHORT)mb_string2cells(pchBuf, written);
  	}
--- 5741,5747 ----
  	{
  	    char_u *p = pchBuf;
  	    for (n = 0; n < cchwritten; n++)
! 		MB_CPTR_ADV(p);
  	    written = p - pchBuf;
  	    g_coord.X += (SHORT)mb_string2cells(pchBuf, written);
  	}
*** ../vim-8.0.0450/src/popupmnu.c	2017-03-12 18:23:35.857849997 +0100
--- src/popupmnu.c	2017-03-12 19:02:45.172985911 +0100
***************
*** 335,341 ****
  		case 3: p = pum_array[idx].pum_extra; break;
  	    }
  	    if (p != NULL)
! 		for ( ; ; mb_ptr_adv(p))
  		{
  		    if (s == NULL)
  			s = p;
--- 335,341 ----
  		case 3: p = pum_array[idx].pum_extra; break;
  	    }
  	    if (p != NULL)
! 		for ( ; ; MB_PTR_ADV(p))
  		{
  		    if (s == NULL)
  			s = p;
***************
*** 369,375 ****
  					{
  					    size -= has_mbyte
  						    ? (*mb_ptr2cells)(rt) : 1;
! 					    mb_ptr_adv(rt);
  					} while (size > pum_width);
  
  					if (size < pum_width)
--- 369,375 ----
  					{
  					    size -= has_mbyte
  						    ? (*mb_ptr2cells)(rt) : 1;
! 					    MB_PTR_ADV(rt);
  					} while (size > pum_width);
  
  					if (size < pum_width)
*** ../vim-8.0.0450/src/regexp.c	2017-03-12 18:23:35.857849997 +0100
--- src/regexp.c	2017-03-12 19:09:23.086166649 +0100
***************
*** 1205,1211 ****
  	    {
  		++p;
  		if (*p != ']' && *p != NUL)
! 		    mb_ptr_adv(p);
  	    }
  	else if (*p == '\\'
  		&& !reg_cpo_bsl
--- 1205,1211 ----
  	    {
  		++p;
  		if (*p != ']' && *p != NUL)
! 		    MB_PTR_ADV(p);
  	    }
  	else if (*p == '\\'
  		&& !reg_cpo_bsl
***************
*** 1252,1258 ****
  	mymagic = MAGIC_OFF;
      get_cpo_flags();
  
!     for (; p[0] != NUL; mb_ptr_adv(p))
      {
  	if (p[0] == dirc)	/* found end of regexp */
  	    break;
--- 1252,1258 ----
  	mymagic = MAGIC_OFF;
      get_cpo_flags();
  
!     for (; p[0] != NUL; MB_PTR_ADV(p))
      {
  	if (p[0] == dirc)	/* found end of regexp */
  	    break;
***************
*** 3864,3870 ****
  	    {
  		if (cstrncmp(s, prog->regmust, &prog->regmlen) == 0)
  		    break;		/* Found it. */
! 		mb_ptr_adv(s);
  	    }
  #endif
  	else
--- 3864,3870 ----
  	    {
  		if (cstrncmp(s, prog->regmust, &prog->regmlen) == 0)
  		    break;		/* Found it. */
! 		MB_PTR_ADV(s);
  	    }
  #endif
  	else
***************
*** 3872,3878 ****
  	    {
  		if (cstrncmp(s, prog->regmust, &prog->regmlen) == 0)
  		    break;		/* Found it. */
! 		mb_ptr_adv(s);
  	    }
  	if (s == NULL)		/* Not present. */
  	    goto theend;
--- 3872,3878 ----
  	    {
  		if (cstrncmp(s, prog->regmust, &prog->regmlen) == 0)
  		    break;		/* Found it. */
! 		MB_PTR_ADV(s);
  	    }
  	if (s == NULL)		/* Not present. */
  	    goto theend;
***************
*** 4204,4210 ****
      return TRUE;
  }
  
! #define ADVANCE_REGINPUT() mb_ptr_adv(reginput)
  
  /*
   * The arguments from BRACE_LIMITS are stored here.  They are actually local
--- 4204,4210 ----
      return TRUE;
  }
  
! #define ADVANCE_REGINPUT() MB_PTR_ADV(reginput)
  
  /*
   * The arguments from BRACE_LIMITS are stored here.  They are actually local
***************
*** 4775,4781 ****
  	    {
  		/* Skip composing characters. */
  		while (utf_iscomposing(utf_ptr2char(reginput)))
! 		    mb_cptr_adv(reginput);
  	    }
  #endif
  	    break;
--- 4775,4781 ----
  	    {
  		/* Skip composing characters. */
  		while (utf_iscomposing(utf_ptr2char(reginput)))
! 		    MB_CPTR_ADV(reginput);
  	    }
  #endif
  	    break;
***************
*** 5557,5563 ****
  			no = FAIL;
  		    else
  		    {
! 			mb_ptr_back(regline, rp->rs_un.regsave.rs_u.ptr);
  			if (limit > 0 && (long)(behind_pos.rs_u.ptr
  				     - rp->rs_un.regsave.rs_u.ptr) > limit)
  			    no = FAIL;
--- 5557,5563 ----
  			no = FAIL;
  		    else
  		    {
! 			MB_PTR_BACK(regline, rp->rs_un.regsave.rs_u.ptr);
  			if (limit > 0 && (long)(behind_pos.rs_u.ptr
  				     - rp->rs_un.regsave.rs_u.ptr) > limit)
  			    no = FAIL;
***************
*** 5644,5650 ****
  				fast_breakcheck();
  			    }
  			    else
! 				mb_ptr_back(regline, reginput);
  			}
  			else
  			{
--- 5644,5650 ----
  				fast_breakcheck();
  			    }
  			    else
! 				MB_PTR_BACK(regline, reginput);
  			}
  			else
  			{
***************
*** 5788,5794 ****
  	    while (*scan != NUL && count < maxcount)
  	    {
  		++count;
! 		mb_ptr_adv(scan);
  	    }
  	    if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > rex.reg_maxline
  				      || rex.reg_line_lbr || count == maxcount)
--- 5788,5794 ----
  	    while (*scan != NUL && count < maxcount)
  	    {
  		++count;
! 		MB_PTR_ADV(scan);
  	    }
  	    if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > rex.reg_maxline
  				      || rex.reg_line_lbr || count == maxcount)
***************
*** 5811,5817 ****
  	{
  	    if (vim_isIDc(PTR2CHAR(scan)) && (testval || !VIM_ISDIGIT(*scan)))
  	    {
! 		mb_ptr_adv(scan);
  	    }
  	    else if (*scan == NUL)
  	    {
--- 5811,5817 ----
  	{
  	    if (vim_isIDc(PTR2CHAR(scan)) && (testval || !VIM_ISDIGIT(*scan)))
  	    {
! 		MB_PTR_ADV(scan);
  	    }
  	    else if (*scan == NUL)
  	    {
***************
*** 5842,5848 ****
  	    if (vim_iswordp_buf(scan, rex.reg_buf)
  					  && (testval || !VIM_ISDIGIT(*scan)))
  	    {
! 		mb_ptr_adv(scan);
  	    }
  	    else if (*scan == NUL)
  	    {
--- 5842,5848 ----
  	    if (vim_iswordp_buf(scan, rex.reg_buf)
  					  && (testval || !VIM_ISDIGIT(*scan)))
  	    {
! 		MB_PTR_ADV(scan);
  	    }
  	    else if (*scan == NUL)
  	    {
***************
*** 5872,5878 ****
  	{
  	    if (vim_isfilec(PTR2CHAR(scan)) && (testval || !VIM_ISDIGIT(*scan)))
  	    {
! 		mb_ptr_adv(scan);
  	    }
  	    else if (*scan == NUL)
  	    {
--- 5872,5878 ----
  	{
  	    if (vim_isfilec(PTR2CHAR(scan)) && (testval || !VIM_ISDIGIT(*scan)))
  	    {
! 		MB_PTR_ADV(scan);
  	    }
  	    else if (*scan == NUL)
  	    {
***************
*** 5913,5919 ****
  	    else if (vim_isprintc(PTR2CHAR(scan)) == 1
  					  && (testval || !VIM_ISDIGIT(*scan)))
  	    {
! 		mb_ptr_adv(scan);
  	    }
  	    else if (rex.reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
--- 5913,5919 ----
  	    else if (vim_isprintc(PTR2CHAR(scan)) == 1
  					  && (testval || !VIM_ISDIGIT(*scan)))
  	    {
! 		MB_PTR_ADV(scan);
  	    }
  	    else if (rex.reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
***************
*** 7546,7552 ****
  	    {
  		int had_backslash = FALSE;
  
! 		for (s = eval_result; *s != NUL; mb_ptr_adv(s))
  		{
  		    /* Change NL to CR, so that it becomes a line break,
  		     * unless called from vim_regexec_nl().
--- 7546,7552 ----
  	    {
  		int had_backslash = FALSE;
  
! 		for (s = eval_result; *s != NUL; MB_PTR_ADV(s))
  		{
  		    /* Change NL to CR, so that it becomes a line break,
  		     * unless called from vim_regexec_nl().
*** ../vim-8.0.0450/src/regexp_nfa.c	2017-01-10 13:55:11.373452931 +0100
--- src/regexp_nfa.c	2017-03-12 19:09:28.994124764 +0100
***************
*** 1425,1431 ****
  		    EMSG(_(e_nopresub));
  		    return FAIL;
  		}
! 		for (lp = reg_prev_sub; *lp != NUL; mb_cptr_adv(lp))
  		{
  		    EMIT(PTR2CHAR(lp));
  		    if (lp != reg_prev_sub)
--- 1425,1431 ----
  		    EMSG(_(e_nopresub));
  		    return FAIL;
  		}
! 		for (lp = reg_prev_sub; *lp != NUL; MB_CPTR_ADV(lp))
  		{
  		    EMIT(PTR2CHAR(lp));
  		    if (lp != reg_prev_sub)
***************
*** 1672,1678 ****
  		    else
  			EMIT(result);
  		    regparse = endp;
! 		    mb_ptr_adv(regparse);
  		    return OK;
  		}
  		/*
--- 1672,1678 ----
  		    else
  			EMIT(result);
  		    regparse = endp;
! 		    MB_PTR_ADV(regparse);
  		    return OK;
  		}
  		/*
***************
*** 1684,1690 ****
  		if (*regparse == '^')			/* negated range */
  		{
  		    negated = TRUE;
! 		    mb_ptr_adv(regparse);
  		    EMIT(NFA_START_NEG_COLL);
  		}
  		else
--- 1684,1690 ----
  		if (*regparse == '^')			/* negated range */
  		{
  		    negated = TRUE;
! 		    MB_PTR_ADV(regparse);
  		    EMIT(NFA_START_NEG_COLL);
  		}
  		else
***************
*** 1694,1700 ****
  		    startc = '-';
  		    EMIT(startc);
  		    EMIT(NFA_CONCAT);
! 		    mb_ptr_adv(regparse);
  		}
  		/* Emit the OR branches for each character in the [] */
  		emit_range = FALSE;
--- 1694,1700 ----
  		    startc = '-';
  		    EMIT(startc);
  		    EMIT(NFA_CONCAT);
! 		    MB_PTR_ADV(regparse);
  		}
  		/* Emit the OR branches for each character in the [] */
  		emit_range = FALSE;
***************
*** 1797,1803 ****
  		    {
  			emit_range = TRUE;
  			startc = oldstartc;
! 			mb_ptr_adv(regparse);
  			continue;	    /* reading the end of the range */
  		    }
  
--- 1797,1803 ----
  		    {
  			emit_range = TRUE;
  			startc = oldstartc;
! 			MB_PTR_ADV(regparse);
  			continue;	    /* reading the end of the range */
  		    }
  
***************
*** 1817,1823 ****
  			    )
  			)
  		    {
! 			mb_ptr_adv(regparse);
  
  			if (*regparse == 'n')
  			    startc = reg_string ? NL : NFA_NEWL;
--- 1817,1823 ----
  			    )
  			)
  		    {
! 			MB_PTR_ADV(regparse);
  
  			if (*regparse == 'n')
  			    startc = reg_string ? NL : NFA_NEWL;
***************
*** 1832,1838 ****
  				/* TODO(RE) This needs more testing */
  				startc = coll_get_char();
  				got_coll_char = TRUE;
! 				mb_ptr_back(old_regparse, regparse);
  			    }
  			    else
  			    {
--- 1832,1838 ----
  				/* TODO(RE) This needs more testing */
  				startc = coll_get_char();
  				got_coll_char = TRUE;
! 				MB_PTR_BACK(old_regparse, regparse);
  			    }
  			    else
  			    {
***************
*** 1932,1941 ****
  			}
  		    }
  
! 		    mb_ptr_adv(regparse);
  		} /* while (p < endp) */
  
! 		mb_ptr_back(old_regparse, regparse);
  		if (*regparse == '-')	    /* if last, '-' is just a char */
  		{
  		    EMIT('-');
--- 1932,1941 ----
  			}
  		    }
  
! 		    MB_PTR_ADV(regparse);
  		} /* while (p < endp) */
  
! 		MB_PTR_BACK(old_regparse, regparse);
  		if (*regparse == '-')	    /* if last, '-' is just a char */
  		{
  		    EMIT('-');
***************
*** 1944,1950 ****
  
  		/* skip the trailing ] */
  		regparse = endp;
! 		mb_ptr_adv(regparse);
  
  		/* Mark end of the collection. */
  		if (negated == TRUE)
--- 1944,1950 ----
  
  		/* skip the trailing ] */
  		regparse = endp;
! 		MB_PTR_ADV(regparse);
  
  		/* Mark end of the collection. */
  		if (negated == TRUE)
*** ../vim-8.0.0450/src/screen.c	2017-03-12 18:23:35.857849997 +0100
--- src/screen.c	2017-03-12 19:03:48.628536549 +0100
***************
*** 3397,3403 ****
  #ifdef FEAT_MBYTE
  	    prev_ptr = ptr;
  #endif
! 	    mb_ptr_adv(ptr);
  	}
  
  	/* When:
--- 3397,3403 ----
  #ifdef FEAT_MBYTE
  	    prev_ptr = ptr;
  #endif
! 	    MB_PTR_ADV(ptr);
  	}
  
  	/* When:
***************
*** 4554,4560 ****
  		 * Found last space before word: check for line break.
  		 */
  		if (wp->w_p_lbr && c0 == c
! 				      && vim_isbreak(c) && !vim_isbreak(*ptr))
  		{
  # ifdef FEAT_MBYTE
  		    int mb_off = has_mbyte ? (*mb_head_off)(line, ptr - 1) : 0;
--- 4554,4560 ----
  		 * Found last space before word: check for line break.
  		 */
  		if (wp->w_p_lbr && c0 == c
! 				      && VIM_ISBREAK(c) && !VIM_ISBREAK(*ptr))
  		{
  # ifdef FEAT_MBYTE
  		    int mb_off = has_mbyte ? (*mb_head_off)(line, ptr - 1) : 0;
***************
*** 6408,6414 ****
      {
  	s += skip_status_match_char(xp, s);
  	len += ptr2cells(s);
! 	mb_ptr_adv(s);
      }
  
      return len;
--- 6408,6414 ----
      {
  	s += skip_status_match_char(xp, s);
  	len += ptr2cells(s);
! 	MB_PTR_ADV(s);
      }
  
      return len;
***************
*** 10469,10475 ****
  		    while (len > room)
  		    {
  			len -= ptr2cells(p);
! 			mb_ptr_adv(p);
  		    }
  		else
  #endif
--- 10469,10475 ----
  		    while (len > room)
  		    {
  			len -= ptr2cells(p);
! 			MB_PTR_ADV(p);
  		    }
  		else
  #endif
*** ../vim-8.0.0450/src/search.c	2017-03-12 18:23:35.857849997 +0100
--- src/search.c	2017-03-12 19:09:36.138074118 +0100
***************
*** 3828,3834 ****
  
  	/* We search forward until the cursor, because searching backwards is
  	 * very slow for DBCS encodings. */
! 	for (p = line; p < line + curwin->w_cursor.col; mb_ptr_adv(p))
  	    if (*p == '>' || *p == '<')
  	    {
  		lc = *p;
--- 3828,3834 ----
  
  	/* We search forward until the cursor, because searching backwards is
  	 * very slow for DBCS encodings. */
! 	for (p = line; p < line + curwin->w_cursor.col; MB_PTR_ADV(p))
  	    if (*p == '>' || *p == '<')
  	    {
  		lc = *p;
***************
*** 3848,3854 ****
  	{
  	    if (*p == '<')	/* find '<' under/before cursor */
  		break;
! 	    mb_ptr_back(line, p);
  	    if (*p == '>')	/* find '>' before cursor */
  		break;
  	}
--- 3848,3854 ----
  	{
  	    if (*p == '<')	/* find '<' under/before cursor */
  		break;
! 	    MB_PTR_BACK(line, p);
  	    if (*p == '>')	/* find '>' before cursor */
  		break;
  	}
***************
*** 3859,3865 ****
      pos.lnum = curwin->w_cursor.lnum;
      pos.col = (colnr_T)(p - line);
  
!     mb_ptr_adv(p);
      if (end_tag)
  	/* check that there is a '/' after the '<' */
  	return *p == '/';
--- 3859,3865 ----
      pos.lnum = curwin->w_cursor.lnum;
      pos.col = (colnr_T)(p - line);
  
!     MB_PTR_ADV(p);
      if (end_tag)
  	/* check that there is a '/' after the '<' */
  	return *p == '/';
***************
*** 3974,3980 ****
       */
      inc_cursor();
      p = ml_get_cursor();
!     for (cp = p; *cp != NUL && *cp != '>' && !vim_iswhite(*cp); mb_ptr_adv(cp))
  	;
      len = (int)(cp - p);
      if (len == 0)
--- 3974,3980 ----
       */
      inc_cursor();
      p = ml_get_cursor();
!     for (cp = p; *cp != NUL && *cp != '>' && !vim_iswhite(*cp); MB_PTR_ADV(cp))
  	;
      len = (int)(cp - p);
      if (len == 0)
*** ../vim-8.0.0450/src/spell.c	2017-03-12 18:23:35.861849968 +0100
--- src/spell.c	2017-03-12 19:09:51.161967602 +0100
***************
*** 468,474 ****
      {
  	do
  	{
! 	    mb_ptr_adv(mi.mi_fend);
  	} while (*mi.mi_fend != NUL && spell_iswordp(mi.mi_fend, wp));
  
  	if (capcol != NULL && *capcol == 0 && wp->w_s->b_cap_prog != NULL)
--- 468,474 ----
      {
  	do
  	{
! 	    MB_PTR_ADV(mi.mi_fend);
  	} while (*mi.mi_fend != NUL && spell_iswordp(mi.mi_fend, wp));
  
  	if (capcol != NULL && *capcol == 0 && wp->w_s->b_cap_prog != NULL)
***************
*** 494,500 ****
      /* case-fold the word with one non-word character, so that we can check
       * for the word end. */
      if (*mi.mi_fend != NUL)
! 	mb_ptr_adv(mi.mi_fend);
  
      (void)spell_casefold(ptr, (int)(mi.mi_fend - ptr), mi.mi_fword,
  							     MAXWLEN + 1);
--- 494,500 ----
      /* case-fold the word with one non-word character, so that we can check
       * for the word end. */
      if (*mi.mi_fend != NUL)
! 	MB_PTR_ADV(mi.mi_fend);
  
      (void)spell_casefold(ptr, (int)(mi.mi_fend - ptr), mi.mi_fword,
  							     MAXWLEN + 1);
***************
*** 582,588 ****
  	else if (mi.mi_end == ptr)
  	    /* Always include at least one character.  Required for when there
  	     * is a mixup in "midword". */
! 	    mb_ptr_adv(mi.mi_end);
  	else if (mi.mi_result == SP_BAD
  		&& LANGP_ENTRY(wp->w_s->b_langp, 0)->lp_slang->sl_nobreak)
  	{
--- 582,588 ----
  	else if (mi.mi_end == ptr)
  	    /* Always include at least one character.  Required for when there
  	     * is a mixup in "midword". */
! 	    MB_PTR_ADV(mi.mi_end);
  	else if (mi.mi_result == SP_BAD
  		&& LANGP_ENTRY(wp->w_s->b_langp, 0)->lp_slang->sl_nobreak)
  	{
***************
*** 598,605 ****
  		fp = mi.mi_fword;
  		for (;;)
  		{
! 		    mb_ptr_adv(p);
! 		    mb_ptr_adv(fp);
  		    if (p >= mi.mi_end)
  			break;
  		    mi.mi_compoff = (int)(fp - mi.mi_fword);
--- 598,605 ----
  		fp = mi.mi_fword;
  		for (;;)
  		{
! 		    MB_PTR_ADV(p);
! 		    MB_PTR_ADV(fp);
  		    if (p >= mi.mi_end)
  			break;
  		    mi.mi_compoff = (int)(fp - mi.mi_fword);
***************
*** 827,834 ****
  	    p = mip->mi_word;
  	    if (STRNCMP(ptr, p, wlen) != 0)
  	    {
! 		for (s = ptr; s < ptr + wlen; mb_ptr_adv(s))
! 		    mb_ptr_adv(p);
  		wlen = (int)(p - mip->mi_word);
  	    }
  	}
--- 827,834 ----
  	    p = mip->mi_word;
  	    if (STRNCMP(ptr, p, wlen) != 0)
  	    {
! 		for (s = ptr; s < ptr + wlen; MB_PTR_ADV(s))
! 		    MB_PTR_ADV(p);
  		wlen = (int)(p - mip->mi_word);
  	    }
  	}
***************
*** 952,959 ****
  		    {
  			/* case folding may have changed the length */
  			p = mip->mi_word;
! 			for (s = ptr; s < ptr + mip->mi_compoff; mb_ptr_adv(s))
! 			    mb_ptr_adv(p);
  		    }
  		    else
  #endif
--- 952,959 ----
  		    {
  			/* case folding may have changed the length */
  			p = mip->mi_word;
! 			for (s = ptr; s < ptr + mip->mi_compoff; MB_PTR_ADV(s))
! 			    MB_PTR_ADV(p);
  		    }
  		    else
  #endif
***************
*** 969,975 ****
  			 * character we do not accept a Onecap word.  We do
  			 * accept a no-caps word, even when the dictionary
  			 * word specifies ONECAP. */
! 			mb_ptr_back(mip->mi_word, p);
  			if (spell_iswordp_nmw(p, mip->mi_win)
  				? capflags == WF_ONECAP
  				: (flags & WF_ONECAP) != 0
--- 969,975 ----
  			 * character we do not accept a Onecap word.  We do
  			 * accept a no-caps word, even when the dictionary
  			 * word specifies ONECAP. */
! 			MB_PTR_BACK(mip->mi_word, p);
  			if (spell_iswordp_nmw(p, mip->mi_win)
  				? capflags == WF_ONECAP
  				: (flags & WF_ONECAP) != 0
***************
*** 1038,1045 ****
  		    p = mip->mi_fword;
  		    if (STRNCMP(ptr, p, wlen) != 0)
  		    {
! 			for (s = ptr; s < ptr + wlen; mb_ptr_adv(s))
! 			    mb_ptr_adv(p);
  			mip->mi_compoff = (int)(p - mip->mi_fword);
  		    }
  		}
--- 1038,1045 ----
  		    p = mip->mi_fword;
  		    if (STRNCMP(ptr, p, wlen) != 0)
  		    {
! 			for (s = ptr; s < ptr + wlen; MB_PTR_ADV(s))
! 			    MB_PTR_ADV(p);
  			mip->mi_compoff = (int)(p - mip->mi_fword);
  		    }
  		}
***************
*** 1506,1517 ****
      p = mip->mi_fend;
      do
      {
! 	mb_ptr_adv(mip->mi_fend);
      } while (*mip->mi_fend != NUL && spell_iswordp(mip->mi_fend, mip->mi_win));
  
      /* Include the non-word character so that we can check for the word end. */
      if (*mip->mi_fend != NUL)
! 	mb_ptr_adv(mip->mi_fend);
  
      (void)spell_casefold(p, (int)(mip->mi_fend - p),
  			     mip->mi_fword + mip->mi_fwordlen,
--- 1506,1517 ----
      p = mip->mi_fend;
      do
      {
! 	MB_PTR_ADV(mip->mi_fend);
      } while (*mip->mi_fend != NUL && spell_iswordp(mip->mi_fend, mip->mi_win));
  
      /* Include the non-word character so that we can check for the word end. */
      if (*mip->mi_fend != NUL)
! 	MB_PTR_ADV(mip->mi_fend);
  
      (void)spell_casefold(p, (int)(mip->mi_fend - p),
  			     mip->mi_fword + mip->mi_fwordlen,
***************
*** 2760,2766 ****
      int		past_second = FALSE;	/* past second word char */
  
      /* find first letter */
!     for (p = word; !spell_iswordp_nmw(p, curwin); mb_ptr_adv(p))
  	if (end == NULL ? *p == NUL : p >= end)
  	    return 0;	    /* only non-word characters, illegal word */
  #ifdef FEAT_MBYTE
--- 2760,2766 ----
      int		past_second = FALSE;	/* past second word char */
  
      /* find first letter */
!     for (p = word; !spell_iswordp_nmw(p, curwin); MB_PTR_ADV(p))
  	if (end == NULL ? *p == NUL : p >= end)
  	    return 0;	    /* only non-word characters, illegal word */
  #ifdef FEAT_MBYTE
***************
*** 2775,2781 ****
       * Need to check all letters to find a word with mixed upper/lower.
       * But a word with an upper char only at start is a ONECAP.
       */
!     for ( ; end == NULL ? *p != NUL : p < end; mb_ptr_adv(p))
  	if (spell_iswordp_nmw(p, curwin))
  	{
  	    c = PTR2CHAR(p);
--- 2775,2781 ----
       * Need to check all letters to find a word with mixed upper/lower.
       * But a word with an upper char only at start is a ONECAP.
       */
!     for ( ; end == NULL ? *p != NUL : p < end; MB_PTR_ADV(p))
  	if (spell_iswordp_nmw(p, curwin))
  	{
  	    c = PTR2CHAR(p);
***************
*** 2818,2824 ****
  	/* Count the number of UPPER and lower case letters. */
  	l = u = 0;
  	first = FALSE;
! 	for (p = word; p < end; mb_ptr_adv(p))
  	{
  	    c = PTR2CHAR(p);
  	    if (SPELL_ISUPPER(c))
--- 2818,2824 ----
  	/* Count the number of UPPER and lower case letters. */
  	l = u = 0;
  	first = FALSE;
! 	for (p = word; p < end; MB_PTR_ADV(p))
  	{
  	    c = PTR2CHAR(p);
  	    if (SPELL_ISUPPER(c))
***************
*** 3385,3394 ****
  	p = line + curwin->w_cursor.col;
  	/* Backup to before start of word. */
  	while (p > line && spell_iswordp_nmw(p, curwin))
! 	    mb_ptr_back(line, p);
  	/* Forward to start of word. */
  	while (*p != NUL && !spell_iswordp_nmw(p, curwin))
! 	    mb_ptr_adv(p);
  
  	if (!spell_iswordp_nmw(p, curwin))		/* No word found. */
  	{
--- 3385,3394 ----
  	p = line + curwin->w_cursor.col;
  	/* Backup to before start of word. */
  	while (p > line && spell_iswordp_nmw(p, curwin))
! 	    MB_PTR_BACK(line, p);
  	/* Forward to start of word. */
  	while (*p != NUL && !spell_iswordp_nmw(p, curwin))
! 	    MB_PTR_ADV(p);
  
  	if (!spell_iswordp_nmw(p, curwin))		/* No word found. */
  	{
***************
*** 3624,3630 ****
  	p = line + endcol;
  	for (;;)
  	{
! 	    mb_ptr_back(line, p);
  	    if (p == line || spell_iswordp_nmw(p, curwin))
  		break;
  	    if (vim_regexec(&regmatch, p, 0)
--- 3624,3630 ----
  	p = line + endcol;
  	for (;;)
  	{
! 	    MB_PTR_BACK(line, p);
  	    if (p == line || spell_iswordp_nmw(p, curwin))
  		break;
  	    if (vim_regexec(&regmatch, p, 0)
***************
*** 4644,4650 ****
  
  		    /* Get pointer to last char of previous word. */
  		    p = preword + sp->ts_prewordlen;
! 		    mb_ptr_back(preword, p);
  		}
  	    }
  
--- 4644,4650 ----
  
  		    /* Get pointer to last char of previous word. */
  		    p = preword + sp->ts_prewordlen;
! 		    MB_PTR_BACK(preword, p);
  		}
  	    }
  
***************
*** 4746,4756 ****
  		    /* Give a penalty when changing non-word char to word
  		     * char, e.g., "thes," -> "these". */
  		    p = fword + sp->ts_fidx;
! 		    mb_ptr_back(fword, p);
  		    if (!spell_iswordp(p, curwin))
  		    {
  			p = preword + STRLEN(preword);
! 			mb_ptr_back(preword, p);
  			if (spell_iswordp(p, curwin))
  			    newscore += SCORE_NONWORD;
  		    }
--- 4746,4756 ----
  		    /* Give a penalty when changing non-word char to word
  		     * char, e.g., "thes," -> "these". */
  		    p = fword + sp->ts_fidx;
! 		    MB_PTR_BACK(fword, p);
  		    if (!spell_iswordp(p, curwin))
  		    {
  			p = preword + STRLEN(preword);
! 			MB_PTR_BACK(preword, p);
  			if (spell_iswordp(p, curwin))
  			    newscore += SCORE_NONWORD;
  		    }
***************
*** 5157,5163 ****
  				     * to the score.  Also for the soundfold
  				     * tree (might seem illogical but does
  				     * give better scores). */
! 				    mb_ptr_back(tword, p);
  				    if (c == mb_ptr2char(p))
  					sp->ts_score -= SCORE_INS
  							       - SCORE_INSDUP;
--- 5157,5163 ----
  				     * to the score.  Also for the soundfold
  				     * tree (might seem illogical but does
  				     * give better scores). */
! 				    MB_PTR_BACK(tword, p);
  				    if (c == mb_ptr2char(p))
  					sp->ts_score -= SCORE_INS
  							       - SCORE_INSDUP;
***************
*** 5867,5875 ****
      char_u	*p;
      int		i = 0;
  
!     for (p = fword; p < fword + flen; mb_ptr_adv(p))
  	++i;
!     for (p = word; i > 0; mb_ptr_adv(p))
  	--i;
      return (int)(p - word);
  }
--- 5867,5875 ----
      char_u	*p;
      int		i = 0;
  
!     for (p = fword; p < fword + flen; MB_PTR_ADV(p))
  	++i;
!     for (p = word; i > 0; MB_PTR_ADV(p))
  	--i;
      return (int)(p - word);
  }
***************
*** 6745,6752 ****
  	badlen = (int)(pbad - su->su_badptr);
  	if (goodlen <= 0 || badlen <= 0)
  	    break;
! 	mb_ptr_back(goodword, pgood);
! 	mb_ptr_back(su->su_badptr, pbad);
  #ifdef FEAT_MBYTE
  	if (has_mbyte)
  	{
--- 6745,6752 ----
  	badlen = (int)(pbad - su->su_badptr);
  	if (goodlen <= 0 || badlen <= 0)
  	    break;
! 	MB_PTR_BACK(goodword, pgood);
! 	MB_PTR_BACK(su->su_badptr, pbad);
  #ifdef FEAT_MBYTE
  	if (has_mbyte)
  	{
***************
*** 8976,8982 ****
      char_u  *p = start;
  
      while (*p != NUL && spell_iswordp(p, win))
! 	mb_ptr_adv(p);
      return p;
  }
  
--- 8976,8982 ----
      char_u  *p = start;
  
      while (*p != NUL && spell_iswordp(p, win))
! 	MB_PTR_ADV(p);
      return p;
  }
  
***************
*** 9002,9008 ****
      line = ml_get_curline();
      for (p = line + startcol; p > line; )
      {
! 	mb_ptr_back(line, p);
  	if (spell_iswordp_nmw(p, curwin))
  	    break;
      }
--- 9002,9008 ----
      line = ml_get_curline();
      for (p = line + startcol; p > line; )
      {
! 	MB_PTR_BACK(line, p);
  	if (spell_iswordp_nmw(p, curwin))
  	    break;
      }
***************
*** 9011,9017 ****
      while (p > line)
      {
  	col = (int)(p - line);
! 	mb_ptr_back(line, p);
  	if (!spell_iswordp(p, curwin))
  	    break;
  	col = 0;
--- 9011,9017 ----
      while (p > line)
      {
  	col = (int)(p - line);
! 	MB_PTR_BACK(line, p);
  	if (!spell_iswordp(p, curwin))
  	    break;
  	col = 0;
*** ../vim-8.0.0450/src/spellfile.c	2017-02-26 15:27:18.463432807 +0100
--- src/spellfile.c	2017-03-12 19:09:56.837927360 +0100
***************
*** 1429,1435 ****
  	for (p = from, s = to; *p != NUL && *s != NUL; )
  	{
  	    c = mb_cptr2char_adv(&p);
! 	    mb_cptr_adv(s);
  	    if (c >= 256)
  		++lp->sl_sal_first[c & 0xff];
  	}
--- 1429,1435 ----
  	for (p = from, s = to; *p != NUL && *s != NUL; )
  	{
  	    c = mb_cptr2char_adv(&p);
! 	    MB_CPTR_ADV(s);
  	    if (c >= 256)
  		++lp->sl_sal_first[c & 0xff];
  	}
***************
*** 2802,2808 ****
  			    {
  				p = aff_entry->ae_add
  						  + STRLEN(aff_entry->ae_add);
! 				mb_ptr_back(aff_entry->ae_add, p);
  				if (PTR2CHAR(p) == c_up)
  				{
  				    upper = TRUE;
--- 2802,2808 ----
  			    {
  				p = aff_entry->ae_add
  						  + STRLEN(aff_entry->ae_add);
! 				MB_PTR_BACK(aff_entry->ae_add, p);
  				if (PTR2CHAR(p) == c_up)
  				{
  				    upper = TRUE;
***************
*** 2930,2939 ****
  		{
  		    /* Replace underscore with space (can't include a space
  		     * directly). */
! 		    for (p = items[1]; *p != NUL; mb_ptr_adv(p))
  			if (*p == '_')
  			    *p = ' ';
! 		    for (p = items[2]; *p != NUL; mb_ptr_adv(p))
  			if (*p == '_')
  			    *p = ' ';
  		    add_fromto(spin, items[0][3] == 'S'
--- 2930,2939 ----
  		{
  		    /* Replace underscore with space (can't include a space
  		     * directly). */
! 		    for (p = items[1]; *p != NUL; MB_PTR_ADV(p))
  			if (*p == '_')
  			    *p = ' ';
! 		    for (p = items[2]; *p != NUL; MB_PTR_ADV(p))
  			if (*p == '_')
  			    *p = ' ';
  		    add_fromto(spin, items[0][3] == 'S'
***************
*** 3624,3630 ****
  	/* Truncate the word at the "/", set "afflist" to what follows.
  	 * Replace "\/" by "/" and "\\" by "\". */
  	afflist = NULL;
! 	for (p = w; *p != NUL; mb_ptr_adv(p))
  	{
  	    if (*p == '\\' && (p[1] == '\\' || p[1] == '/'))
  		STRMOVE(p, p + 1);
--- 3624,3630 ----
  	/* Truncate the word at the "/", set "afflist" to what follows.
  	 * Replace "\/" by "/" and "\\" by "\". */
  	afflist = NULL;
! 	for (p = w; *p != NUL; MB_PTR_ADV(p))
  	{
  	    if (*p == '\\' && (p[1] == '\\' || p[1] == '/'))
  		STRMOVE(p, p + 1);
***************
*** 3947,3953 ****
  				{
  				    i = mb_charlen(ae->ae_chop);
  				    for ( ; i > 0; --i)
! 					mb_ptr_adv(p);
  				}
  				else
  #endif
--- 3947,3953 ----
  				{
  				    i = mb_charlen(ae->ae_chop);
  				    for ( ; i > 0; --i)
! 					MB_PTR_ADV(p);
  				}
  				else
  #endif
***************
*** 3965,3971 ****
  				p = newword + STRLEN(newword);
  				i = (int)MB_CHARLEN(ae->ae_chop);
  				for ( ; i > 0; --i)
! 				    mb_ptr_back(newword, p);
  				*p = NUL;
  			    }
  			    if (ae->ae_add != NULL)
--- 3965,3971 ----
  				p = newword + STRLEN(newword);
  				i = (int)MB_CHARLEN(ae->ae_chop);
  				for ( ; i > 0; --i)
! 				    MB_PTR_BACK(newword, p);
  				*p = NUL;
  			    }
  			    if (ae->ae_add != NULL)
*** ../vim-8.0.0450/src/syntax.c	2017-03-12 17:10:14.417925081 +0100
--- src/syntax.c	2017-03-12 19:10:03.361881106 +0100
***************
*** 3211,3222 ****
  	if (off > 0)
  	{
  	    while (off-- > 0 && *p != NUL)
! 		mb_ptr_adv(p);
  	}
  	else if (off < 0)
  	{
  	    while (off++ < 0 && base < p)
! 		mb_ptr_back(base, p);
  	}
  	col = (int)(p - base);
      }
--- 3211,3222 ----
  	if (off > 0)
  	{
  	    while (off-- > 0 && *p != NUL)
! 		MB_PTR_ADV(p);
  	}
  	else if (off < 0)
  	{
  	    while (off++ < 0 && base < p)
! 		MB_PTR_BACK(base, p);
  	}
  	col = (int)(p - base);
      }
***************
*** 3265,3276 ****
  	if (off > 0)
  	{
  	    while (off-- && *p != NUL)
! 		mb_ptr_adv(p);
  	}
  	else if (off < 0)
  	{
  	    while (off++ && base < p)
! 		mb_ptr_back(base, p);
  	}
  	col = (int)(p - base);
      }
--- 3265,3276 ----
  	if (off > 0)
  	{
  	    while (off-- && *p != NUL)
! 		MB_PTR_ADV(p);
  	}
  	else if (off < 0)
  	{
  	    while (off++ && base < p)
! 		MB_PTR_BACK(base, p);
  	}
  	col = (int)(p - base);
      }
*** ../vim-8.0.0450/src/tag.c	2017-03-12 18:23:35.861849968 +0100
--- src/tag.c	2017-03-12 19:10:08.953841457 +0100
***************
*** 3544,3550 ****
  		tail = p + 1;
  		if (p[1] != NUL)
  		    while (vim_ispathsep(*tail))
! 			mb_ptr_adv(tail);
  		else if (p > start)
  		    --p;		/* strip preceding path separator */
  		STRMOVE(p, tail);
--- 3544,3550 ----
  		tail = p + 1;
  		if (p[1] != NUL)
  		    while (vim_ispathsep(*tail))
! 			MB_PTR_ADV(tail);
  		else if (p > start)
  		    --p;		/* strip preceding path separator */
  		STRMOVE(p, tail);
***************
*** 3556,3562 ****
  	    /* Skip to after ".." or "../" or "..///". */
  	    tail = p + 2;
  	    while (vim_ispathsep(*tail))
! 		mb_ptr_adv(tail);
  
  	    if (components > 0)		/* strip one preceding component */
  	    {
--- 3556,3562 ----
  	    /* Skip to after ".." or "../" or "..///". */
  	    tail = p + 2;
  	    while (vim_ispathsep(*tail))
! 		MB_PTR_ADV(tail);
  
  	    if (components > 0)		/* strip one preceding component */
  	    {
***************
*** 3583,3589 ****
  		    --p;
  		    /* Skip back to after previous '/'. */
  		    while (p > start && !after_pathsep(start, p))
! 			mb_ptr_back(start, p);
  
  		    if (!do_strip)
  		    {
--- 3583,3589 ----
  		    --p;
  		    /* Skip back to after previous '/'. */
  		    while (p > start && !after_pathsep(start, p))
! 			MB_PTR_BACK(start, p);
  
  		    if (!do_strip)
  		    {
*** ../vim-8.0.0450/src/ui.c	2017-03-12 18:23:35.861849968 +0100
--- src/ui.c	2017-03-12 19:06:03.087584086 +0100
***************
*** 3192,3198 ****
      while (count < vcol && *ptr != NUL)
      {
  	count += win_lbr_chartabsize(wp, line, ptr, count, NULL);
! 	mb_ptr_adv(ptr);
      }
      return (int)(ptr - line);
  }
--- 3192,3198 ----
      while (count < vcol && *ptr != NUL)
      {
  	count += win_lbr_chartabsize(wp, line, ptr, count, NULL);
! 	MB_PTR_ADV(ptr);
      }
      return (int)(ptr - line);
  }
*** ../vim-8.0.0450/src/undo.c	2017-03-12 18:23:35.861849968 +0100
--- src/undo.c	2017-03-12 19:06:07.271554440 +0100
***************
*** 833,839 ****
  		    munged_name = vim_strsave(ffname);
  		    if (munged_name == NULL)
  			return NULL;
! 		    for (p = munged_name; *p != NUL; mb_ptr_adv(p))
  			if (vim_ispathsep(*p))
  			    *p = '%';
  		}
--- 833,839 ----
  		    munged_name = vim_strsave(ffname);
  		    if (munged_name == NULL)
  			return NULL;
! 		    for (p = munged_name; *p != NUL; MB_PTR_ADV(p))
  			if (vim_ispathsep(*p))
  			    *p = '%';
  		}
*** ../vim-8.0.0450/src/window.c	2017-02-17 12:04:35.843808317 +0100
--- src/window.c	2017-03-12 19:06:17.495482000 +0100
***************
*** 6127,6133 ****
       */
      ptr = line + col;
      while (*ptr != NUL && !vim_isfilec(*ptr))
! 	mb_ptr_adv(ptr);
      if (*ptr == NUL)		/* nothing found */
      {
  	if (options & FNAME_MESS)
--- 6127,6133 ----
       */
      ptr = line + col;
      while (*ptr != NUL && !vim_isfilec(*ptr))
! 	MB_PTR_ADV(ptr);
      if (*ptr == NUL)		/* nothing found */
      {
  	if (options & FNAME_MESS)
*** ../vim-8.0.0450/src/version.c	2017-03-12 18:37:58.375653719 +0100
--- src/version.c	2017-03-12 19:19:29.289872708 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     451,
  /**/

-- 
To be rich is not the end, but only a change of worries.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0452
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0452
Problem:    Some macros are in lower case.
Solution:   Make a few more macros upper case.
Files:      src/vim.h, src/macros.h, src/evalfunc.c, src/fold.c,
            src/gui_gtk.c, src/gui_gtk_x11.c, src/charset.c, src/diff.c,
            src/edit.c, src/eval.c, src/ex_cmds.c, src/ex_cmds2.c,
            src/ex_docmd.c, src/ex_getln.c, src/fileio.c, src/getchar.c,
            src/gui.c, src/gui_w32.c, src/if_cscope.c, src/mbyte.c,
            src/menu.c, src/message.c, src/misc1.c, src/misc2.c, src/normal.c,
            src/ops.c, src/option.c, src/os_unix.c, src/os_win32.c,
            src/quickfix.c, src/regexp.c, src/regexp_nfa.c, src/screen.c,
            src/search.c, src/spell.c, src/syntax.c, src/tag.c, src/userfunc.c


*** ../vim-8.0.0451/src/vim.h	2017-02-21 21:57:02.475629988 +0100
--- src/vim.h	2017-03-12 20:06:31.553941533 +0100
***************
*** 588,594 ****
  #ifdef FEAT_GETTEXT
  # ifdef DYNAMIC_GETTEXT
  #  define _(x) (*dyn_libintl_gettext)((char *)(x))
! #  define ngettext(x, xs, n) (*dyn_libintl_ngettext)((char *)(x), (char *)(xs), (n))
  #  define N_(x) x
  #  define bindtextdomain(domain, dir) (*dyn_libintl_bindtextdomain)((domain), (dir))
  #  define bind_textdomain_codeset(domain, codeset) (*dyn_libintl_bind_textdomain_codeset)((domain), (codeset))
--- 588,594 ----
  #ifdef FEAT_GETTEXT
  # ifdef DYNAMIC_GETTEXT
  #  define _(x) (*dyn_libintl_gettext)((char *)(x))
! #  define NGETTEXT(x, xs, n) (*dyn_libintl_ngettext)((char *)(x), (char *)(xs), (n))
  #  define N_(x) x
  #  define bindtextdomain(domain, dir) (*dyn_libintl_bindtextdomain)((domain), (dir))
  #  define bind_textdomain_codeset(domain, codeset) (*dyn_libintl_bind_textdomain_codeset)((domain), (codeset))
***************
*** 601,606 ****
--- 601,607 ----
  # else
  #  include <libintl.h>
  #  define _(x) gettext((char *)(x))
+ #  define NGETTEXT(x, xs, n) ngettext((x), (xs), (n))
  #  ifdef gettext_noop
  #   define N_(x) gettext_noop(x)
  #  else
***************
*** 609,615 ****
  # endif
  #else
  # define _(x) ((char *)(x))
! # define ngettext(x, xs, n) (((n) == 1) ? (char *)(x) : (char *)(xs))
  # define N_(x) x
  # ifdef bindtextdomain
  #  undef bindtextdomain
--- 610,616 ----
  # endif
  #else
  # define _(x) ((char *)(x))
! # define NGETTEXT(x, xs, n) (((n) == 1) ? (char *)(x) : (char *)(xs))
  # define N_(x) x
  # ifdef bindtextdomain
  #  undef bindtextdomain
***************
*** 1764,1775 ****
  #define term_str(n)	term_strings[(int)(n)]
  
  /*
-  * vim_iswhite() is used for "^" and the like. It differs from isspace()
-  * because it doesn't include <CR> and <LF> and the like.
-  */
- #define vim_iswhite(x)	((x) == ' ' || (x) == '\t')
- 
- /*
   * EXTERN is only defined in main.c.  That's where global variables are
   * actually defined and initialized.
   */
--- 1765,1770 ----
*** ../vim-8.0.0451/src/macros.h	2017-03-12 19:22:31.740585042 +0100
--- src/macros.h	2017-03-12 20:06:47.897825762 +0100
***************
*** 46,51 ****
--- 46,57 ----
  #define LTOREQ_POS(a, b) (LT_POS(a, b) || EQUAL_POS(a, b))
  
  /*
+  * VIM_ISWHITE() is used for "^" and the like. It differs from isspace()
+  * because it doesn't include <CR> and <LF> and the like.
+  */
+ #define VIM_ISWHITE(x)	((x) == ' ' || (x) == '\t')
+ 
+ /*
   * LINEEMPTY() - return TRUE if the line is empty
   */
  #define LINEEMPTY(p) (*ml_get(p) == NUL)
*** ../vim-8.0.0451/src/evalfunc.c	2017-03-12 18:23:35.841850113 +0100
--- src/evalfunc.c	2017-03-12 19:37:18.842319441 +0100
***************
*** 3534,3540 ****
  	    }
  	}
  	count = (long)(foldend - foldstart + 1);
! 	txt = ngettext("+-%s%3ld line: ", "+-%s%3ld lines: ", count);
  	r = alloc((unsigned)(STRLEN(txt)
  		    + STRLEN(dashes)	    /* for %s */
  		    + 20		    /* for %3ld */
--- 3534,3540 ----
  	    }
  	}
  	count = (long)(foldend - foldstart + 1);
! 	txt = NGETTEXT("+-%s%3ld line: ", "+-%s%3ld lines: ", count);
  	r = alloc((unsigned)(STRLEN(txt)
  		    + STRLEN(dashes)	    /* for %s */
  		    + 20		    /* for %3ld */
*** ../vim-8.0.0451/src/fold.c	2017-03-12 19:22:31.752584957 +0100
--- src/fold.c	2017-03-12 19:42:44.292027348 +0100
***************
*** 1970,1976 ****
  	long count = (long)(lnume - lnum + 1);
  
  	vim_snprintf((char *)buf, FOLD_TEXT_LEN,
! 		     ngettext("+--%3ld line folded ",
  					       "+--%3ld lines folded ", count),
  		     count);
  	text = buf;
--- 1970,1976 ----
  	long count = (long)(lnume - lnum + 1);
  
  	vim_snprintf((char *)buf, FOLD_TEXT_LEN,
! 		     NGETTEXT("+--%3ld line folded ",
  					       "+--%3ld lines folded ", count),
  		     count);
  	text = buf;
***************
*** 1998,2004 ****
      /* Ignore leading and trailing white space in 'commentstring'. */
      cms_start = skipwhite(curbuf->b_p_cms);
      cms_slen = (int)STRLEN(cms_start);
!     while (cms_slen > 0 && vim_iswhite(cms_start[cms_slen - 1]))
  	--cms_slen;
  
      /* locate "%s" in 'commentstring', use the part before and after it. */
--- 1998,2004 ----
      /* Ignore leading and trailing white space in 'commentstring'. */
      cms_start = skipwhite(curbuf->b_p_cms);
      cms_slen = (int)STRLEN(cms_start);
!     while (cms_slen > 0 && VIM_ISWHITE(cms_start[cms_slen - 1]))
  	--cms_slen;
  
      /* locate "%s" in 'commentstring', use the part before and after it. */
***************
*** 2009,2015 ****
  	cms_slen = (int)(cms_end - cms_start);
  
  	/* exclude white space before "%s" */
! 	while (cms_slen > 0 && vim_iswhite(cms_start[cms_slen - 1]))
  	    --cms_slen;
  
  	/* skip "%s" and white space after it */
--- 2009,2015 ----
  	cms_slen = (int)(cms_end - cms_start);
  
  	/* exclude white space before "%s" */
! 	while (cms_slen > 0 && VIM_ISWHITE(cms_start[cms_slen - 1]))
  	    --cms_slen;
  
  	/* skip "%s" and white space after it */
***************
*** 2033,2039 ****
  
  	    /* May remove 'commentstring' start.  Useful when it's a double
  	     * quote and we already removed a double quote. */
! 	    for (p = s; p > str && vim_iswhite(p[-1]); --p)
  		;
  	    if (p >= str + cms_slen
  			   && STRNCMP(p - cms_slen, cms_start, cms_slen) == 0)
--- 2033,2039 ----
  
  	    /* May remove 'commentstring' start.  Useful when it's a double
  	     * quote and we already removed a double quote. */
! 	    for (p = s; p > str && VIM_ISWHITE(p[-1]); --p)
  		;
  	    if (p >= str + cms_slen
  			   && STRNCMP(p - cms_slen, cms_start, cms_slen) == 0)
***************
*** 2058,2064 ****
  	}
  	if (len != 0)
  	{
! 	    while (vim_iswhite(s[len]))
  		++len;
  	    STRMOVE(s, s + len);
  	}
--- 2058,2064 ----
  	}
  	if (len != 0)
  	{
! 	    while (VIM_ISWHITE(s[len]))
  		++len;
  	    STRMOVE(s, s + len);
  	}
*** ../vim-8.0.0451/src/gui_gtk.c	2017-03-12 19:22:31.756584930 +0100
--- src/gui_gtk.c	2017-03-12 19:38:06.909981115 +0100
***************
*** 51,59 ****
  # ifdef _
  #  undef _
  # endif
- # ifdef ngettext
- #  undef ngettext
- # endif
  # ifdef N_
  #  undef N_
  # endif
--- 51,56 ----
*** ../vim-8.0.0451/src/gui_gtk_x11.c	2017-02-23 12:20:30.205696184 +0100
--- src/gui_gtk_x11.c	2017-03-12 19:38:23.781862343 +0100
***************
*** 35,43 ****
  # ifdef _
  #  undef _
  # endif
- # ifdef ngettext
- #  undef ngettext
- # endif
  # ifdef N_
  #  undef N_
  # endif
--- 35,40 ----
*** ../vim-8.0.0451/src/charset.c	2017-03-12 19:22:31.740585042 +0100
--- src/charset.c	2017-03-12 19:39:55.941213424 +0100
***************
*** 1530,1536 ****
  {
      char_u	*p = q;
  
!     while (vim_iswhite(*p)) /* skip to next non-white */
  	++p;
      return p;
  }
--- 1530,1536 ----
  {
      char_u	*p = q;
  
!     while (VIM_ISWHITE(*p)) /* skip to next non-white */
  	++p;
      return p;
  }
*** ../vim-8.0.0451/src/diff.c	2017-03-12 18:23:35.837850143 +0100
--- src/diff.c	2017-03-12 19:40:15.581075100 +0100
***************
*** 1667,1673 ****
      p2 = s2;
      while (*p1 != NUL && *p2 != NUL)
      {
! 	if (vim_iswhite(*p1) && vim_iswhite(*p2))
  	{
  	    p1 = skipwhite(p1);
  	    p2 = skipwhite(p2);
--- 1667,1673 ----
      p2 = s2;
      while (*p1 != NUL && *p2 != NUL)
      {
! 	if (VIM_ISWHITE(*p1) && VIM_ISWHITE(*p2))
  	{
  	    p1 = skipwhite(p1);
  	    p2 = skipwhite(p2);
***************
*** 1994,2001 ****
  	    while (line_org[si_org] != NUL)
  	    {
  		if ((diff_flags & DIFF_IWHITE)
! 			&& vim_iswhite(line_org[si_org])
! 			&& vim_iswhite(line_new[si_new]))
  		{
  		    si_org = (int)(skipwhite(line_org + si_org) - line_org);
  		    si_new = (int)(skipwhite(line_new + si_new) - line_new);
--- 1994,2001 ----
  	    while (line_org[si_org] != NUL)
  	    {
  		if ((diff_flags & DIFF_IWHITE)
! 			&& VIM_ISWHITE(line_org[si_org])
! 			&& VIM_ISWHITE(line_new[si_new]))
  		{
  		    si_org = (int)(skipwhite(line_org + si_org) - line_org);
  		    si_new = (int)(skipwhite(line_new + si_new) - line_new);
***************
*** 2029,2042 ****
  						&& ei_org >= 0 && ei_new >= 0)
  		{
  		    if ((diff_flags & DIFF_IWHITE)
! 			    && vim_iswhite(line_org[ei_org])
! 			    && vim_iswhite(line_new[ei_new]))
  		    {
  			while (ei_org >= *startp
! 					     && vim_iswhite(line_org[ei_org]))
  			    --ei_org;
  			while (ei_new >= si_new
! 					     && vim_iswhite(line_new[ei_new]))
  			    --ei_new;
  		    }
  		    else
--- 2029,2042 ----
  						&& ei_org >= 0 && ei_new >= 0)
  		{
  		    if ((diff_flags & DIFF_IWHITE)
! 			    && VIM_ISWHITE(line_org[ei_org])
! 			    && VIM_ISWHITE(line_new[ei_new]))
  		    {
  			while (ei_org >= *startp
! 					     && VIM_ISWHITE(line_org[ei_org]))
  			    --ei_org;
  			while (ei_new >= si_new
! 					     && VIM_ISWHITE(line_new[ei_new]))
  			    --ei_new;
  		    }
  		    else
***************
*** 2202,2208 ****
      {
  	/* Buffer number or pattern given.  Ignore trailing white space. */
  	p = eap->arg + STRLEN(eap->arg);
! 	while (p > eap->arg && vim_iswhite(p[-1]))
  	    --p;
  	for (i = 0; vim_isdigit(eap->arg[i]) && eap->arg + i < p; ++i)
  	    ;
--- 2202,2208 ----
      {
  	/* Buffer number or pattern given.  Ignore trailing white space. */
  	p = eap->arg + STRLEN(eap->arg);
! 	while (p > eap->arg && VIM_ISWHITE(p[-1]))
  	    --p;
  	for (i = 0; vim_isdigit(eap->arg[i]) && eap->arg + i < p; ++i)
  	    ;
*** ../vim-8.0.0451/src/edit.c	2017-03-12 19:22:31.744585014 +0100
--- src/edit.c	2017-03-12 19:40:49.220838148 +0100
***************
*** 2149,2155 ****
      int	    i;
  
      /* find start of trailing white space */
!     for (i = (int)STRLEN(line) - 1; i >= 0 && vim_iswhite(line[i]); i--)
      {
  	if (State & REPLACE_FLAG)
  	    replace_join(0);	    /* remove a NUL from the replace stack */
--- 2149,2155 ----
      int	    i;
  
      /* find start of trailing white space */
!     for (i = (int)STRLEN(line) - 1; i >= 0 && VIM_ISWHITE(line[i]); i--)
      {
  	if (State & REPLACE_FLAG)
  	    replace_join(0);	    /* remove a NUL from the replace stack */
***************
*** 2358,2364 ****
  	case CTRL_X_OMNI:
  	    /* Command line and Omni completion can work with just about any
  	     * printable character, but do stop at white space. */
! 	    return vim_isprintc(c) && !vim_iswhite(c);
  
  	case CTRL_X_WHOLE_LINE:
  	    /* For while line completion a space can be part of the line. */
--- 2358,2364 ----
  	case CTRL_X_OMNI:
  	    /* Command line and Omni completion can work with just about any
  	     * printable character, but do stop at white space. */
! 	    return vim_isprintc(c) && !VIM_ISWHITE(c);
  
  	case CTRL_X_WHOLE_LINE:
  	    /* For while line completion a space can be part of the line. */
***************
*** 5989,5997 ****
  #endif
  
  #ifdef FEAT_MBYTE
! # define WHITECHAR(cc) (vim_iswhite(cc) && (!enc_utf8 || !utf_iscomposing(utf_ptr2char(ml_get_cursor() + 1))))
  #else
! # define WHITECHAR(cc) vim_iswhite(cc)
  #endif
  
  /*
--- 5989,5997 ----
  #endif
  
  #ifdef FEAT_MBYTE
! # define WHITECHAR(cc) (VIM_ISWHITE(cc) && (!enc_utf8 || !utf_iscomposing(utf_ptr2char(ml_get_cursor() + 1))))
  #else
! # define WHITECHAR(cc) VIM_ISWHITE(cc)
  #endif
  
  /*
***************
*** 6037,6043 ****
       */
      if (textwidth > 0
  	    && (force_format
! 		|| (!vim_iswhite(c)
  		    && !((State & REPLACE_FLAG)
  #ifdef FEAT_VREPLACE
  			&& !(State & VREPLACE_FLAG)
--- 6037,6043 ----
       */
      if (textwidth > 0
  	    && (force_format
! 		|| (!VIM_ISWHITE(c)
  		    && !((State & REPLACE_FLAG)
  #ifdef FEAT_VREPLACE
  			&& !(State & VREPLACE_FLAG)
***************
*** 6094,6100 ****
  		++p;
  	    middle_len = copy_option_part(&p, lead_end, COM_MAX_LEN, ",");
  	    /* Don't count trailing white space for middle_len */
! 	    while (middle_len > 0 && vim_iswhite(lead_end[middle_len - 1]))
  		--middle_len;
  
  	    /* Find the end-comment string */
--- 6094,6100 ----
  		++p;
  	    middle_len = copy_option_part(&p, lead_end, COM_MAX_LEN, ",");
  	    /* Don't count trailing white space for middle_len */
! 	    while (middle_len > 0 && VIM_ISWHITE(lead_end[middle_len - 1]))
  		--middle_len;
  
  	    /* Find the end-comment string */
***************
*** 6104,6110 ****
  
  	    /* Skip white space before the cursor */
  	    i = curwin->w_cursor.col;
! 	    while (--i >= 0 && vim_iswhite(line[i]))
  		;
  	    i++;
  
--- 6104,6110 ----
  
  	    /* Skip white space before the cursor */
  	    i = curwin->w_cursor.col;
! 	    while (--i >= 0 && VIM_ISWHITE(line[i]))
  		;
  	    i++;
  
***************
*** 6293,6299 ****
  	    )
      {
  	cc = gchar_cursor();
! 	if (vim_iswhite(cc))
  	{
  	    save_char = cc;
  	    pchar_cursor('x');
--- 6293,6299 ----
  	    )
      {
  	cc = gchar_cursor();
! 	if (VIM_ISWHITE(cc))
  	{
  	    save_char = cc;
  	    pchar_cursor('x');
***************
*** 7031,7043 ****
  	    {
  		dec_cursor();
  		cc = gchar_cursor();
! 		if (!vim_iswhite(cc))
  		    curwin->w_cursor = tpos;
  	    }
  
  	    auto_format(TRUE, FALSE);
  
! 	    if (vim_iswhite(cc))
  	    {
  		if (gchar_cursor() != NUL)
  		    inc_cursor();
--- 7031,7043 ----
  	    {
  		dec_cursor();
  		cc = gchar_cursor();
! 		if (!VIM_ISWHITE(cc))
  		    curwin->w_cursor = tpos;
  	    }
  
  	    auto_format(TRUE, FALSE);
  
! 	    if (VIM_ISWHITE(cc))
  	    {
  		if (gchar_cursor() != NUL)
  		    inc_cursor();
***************
*** 7073,7079 ****
  		if (gchar_cursor() == NUL && curwin->w_cursor.col > 0)
  		    --curwin->w_cursor.col;
  		cc = gchar_cursor();
! 		if (!vim_iswhite(cc))
  		    break;
  		if (del_char(TRUE) == FAIL)
  		    break;  /* should not happen */
--- 7073,7079 ----
  		if (gchar_cursor() == NUL && curwin->w_cursor.col > 0)
  		    --curwin->w_cursor.col;
  		cc = gchar_cursor();
! 		if (!VIM_ISWHITE(cc))
  		    break;
  		if (del_char(TRUE) == FAIL)
  		    break;  /* should not happen */
***************
*** 7223,7229 ****
  	{
  	    char_u  *ptr;
  
! 	    for (ptr = ml_get_curline(); vim_iswhite(*ptr)
  			       && !((flags & BL_FIX) && ptr[1] == NUL); ++ptr)
  		++curwin->w_cursor.col;
  	}
--- 7223,7229 ----
  	{
  	    char_u  *ptr;
  
! 	    for (ptr = ml_get_curline(); VIM_ISWHITE(*ptr)
  			       && !((flags & BL_FIX) && ptr[1] == NUL); ++ptr)
  		++curwin->w_cursor.col;
  	}
***************
*** 9169,9175 ****
  
  	    /* delete characters until we are at or before want_vcol */
  	    while (vcol > want_vcol
! 		    && (cc = *(ml_get_cursor() - 1), vim_iswhite(cc)))
  		ins_bs_one(&vcol);
  
  	    /* insert extra spaces until we are at want_vcol */
--- 9169,9175 ----
  
  	    /* delete characters until we are at or before want_vcol */
  	    while (vcol > want_vcol
! 		    && (cc = *(ml_get_cursor() - 1), VIM_ISWHITE(cc)))
  		ins_bs_one(&vcol);
  
  	    /* insert extra spaces until we are at want_vcol */
***************
*** 10056,10062 ****
  
  	/* Find first white before the cursor */
  	fpos = curwin->w_cursor;
! 	while (fpos.col > 0 && vim_iswhite(ptr[-1]))
  	{
  	    --fpos.col;
  	    --ptr;
--- 10056,10062 ----
  
  	/* Find first white before the cursor */
  	fpos = curwin->w_cursor;
! 	while (fpos.col > 0 && VIM_ISWHITE(ptr[-1]))
  	{
  	    --fpos.col;
  	    --ptr;
***************
*** 10077,10083 ****
  
  	/* Use as many TABs as possible.  Beware of 'breakindent', 'showbreak'
  	 * and 'linebreak' adding extra virtual columns. */
! 	while (vim_iswhite(*ptr))
  	{
  	    i = lbr_chartabsize(NULL, (char_u *)"\t", vcol);
  	    if (vcol + i > want_vcol)
--- 10077,10083 ----
  
  	/* Use as many TABs as possible.  Beware of 'breakindent', 'showbreak'
  	 * and 'linebreak' adding extra virtual columns. */
! 	while (VIM_ISWHITE(*ptr))
  	{
  	    i = lbr_chartabsize(NULL, (char_u *)"\t", vcol);
  	    if (vcol + i > want_vcol)
***************
*** 10456,10462 ****
  	    ptr = ml_get(pos->lnum);
  	    i = pos->col;
  	    if (i > 0)		/* skip blanks before '{' */
! 		while (--i > 0 && vim_iswhite(ptr[i]))
  		    ;
  	    curwin->w_cursor.lnum = pos->lnum;
  	    curwin->w_cursor.col = i;
--- 10456,10462 ----
  	    ptr = ml_get(pos->lnum);
  	    i = pos->col;
  	    if (i > 0)		/* skip blanks before '{' */
! 		while (--i > 0 && VIM_ISWHITE(ptr[i]))
  		    ;
  	    curwin->w_cursor.lnum = pos->lnum;
  	    curwin->w_cursor.col = i;
*** ../vim-8.0.0451/src/eval.c	2017-03-12 19:22:31.744585014 +0100
--- src/eval.c	2017-03-12 19:41:04.900727690 +0100
***************
*** 1516,1522 ****
  	if (error || eap->skip)
  	{
  	    arg = find_name_end(arg, NULL, NULL, FNE_INCL_BR | FNE_CHECK_START);
! 	    if (!vim_iswhite(*arg) && !ends_excmd(*arg))
  	    {
  		emsg_severe = TRUE;
  		EMSG(_(e_trailing));
--- 1516,1522 ----
  	if (error || eap->skip)
  	{
  	    arg = find_name_end(arg, NULL, NULL, FNE_INCL_BR | FNE_CHECK_START);
! 	    if (!VIM_ISWHITE(*arg) && !ends_excmd(*arg))
  	    {
  		emsg_severe = TRUE;
  		EMSG(_(e_trailing));
***************
*** 1856,1862 ****
      if (expr_start != NULL)
      {
  	/* Don't expand the name when we already know there is an error. */
! 	if (unlet && !vim_iswhite(*p) && !ends_excmd(*p)
  						    && *p != '[' && *p != '.')
  	{
  	    EMSG(_(e_trailing));
--- 1856,1862 ----
      if (expr_start != NULL)
      {
  	/* Don't expand the name when we already know there is an error. */
! 	if (unlet && !VIM_ISWHITE(*p) && !ends_excmd(*p)
  						    && *p != '[' && *p != '.')
  	{
  	    EMSG(_(e_trailing));
***************
*** 2449,2455 ****
  	return fi;
  
      expr = skipwhite(expr);
!     if (expr[0] != 'i' || expr[1] != 'n' || !vim_iswhite(expr[2]))
      {
  	EMSG(_("E690: Missing \"in\" after :for"));
  	return fi;
--- 2449,2455 ----
  	return fi;
  
      expr = skipwhite(expr);
!     if (expr[0] != 'i' || expr[1] != 'n' || !VIM_ISWHITE(expr[2]))
      {
  	EMSG(_("E690: Missing \"in\" after :for"));
  	return fi;
***************
*** 2552,2558 ****
  	    {
  		xp->xp_pattern = p;
  		MB_PTR_BACK(arg, p);
! 		if (vim_iswhite(*p))
  		    break;
  	    }
  	    return;
--- 2552,2558 ----
  	    {
  		xp->xp_pattern = p;
  		MB_PTR_BACK(arg, p);
! 		if (VIM_ISWHITE(*p))
  		    break;
  	    }
  	    return;
***************
*** 2698,2704 ****
  							     FNE_CHECK_START);
  	if (lv.ll_name == NULL)
  	    error = TRUE;	    /* error but continue parsing */
! 	if (name_end == NULL || (!vim_iswhite(*name_end)
  						   && !ends_excmd(*name_end)))
  	{
  	    if (name_end != NULL)
--- 2698,2704 ----
  							     FNE_CHECK_START);
  	if (lv.ll_name == NULL)
  	    error = TRUE;	    /* error but continue parsing */
! 	if (name_end == NULL || (!VIM_ISWHITE(*name_end)
  						   && !ends_excmd(*name_end)))
  	{
  	    if (name_end != NULL)
***************
*** 6866,6872 ****
  		|| (**arg == '.' && rettv->v_type == VAR_DICT)
  		|| (**arg == '(' && (!evaluate || rettv->v_type == VAR_FUNC
  					    || rettv->v_type == VAR_PARTIAL)))
! 	    && !vim_iswhite(*(*arg - 1)))
      {
  	if (**arg == '(')
  	{
--- 6866,6872 ----
  		|| (**arg == '.' && rettv->v_type == VAR_DICT)
  		|| (**arg == '(' && (!evaluate || rettv->v_type == VAR_FUNC
  					    || rettv->v_type == VAR_PARTIAL)))
! 	    && !VIM_ISWHITE(*(*arg - 1)))
      {
  	if (**arg == '(')
  	{
*** ../vim-8.0.0451/src/ex_cmds.c	2017-03-12 19:22:31.748584985 +0100
--- src/ex_cmds.c	2017-03-12 19:41:20.520617646 +0100
***************
*** 256,262 ****
  
      /* find the character after the last non-blank character */
      for (last = first + STRLEN(first);
! 				last > first && vim_iswhite(last[-1]); --last)
  	;
      save = *last;
      *last = NUL;
--- 256,262 ----
  
      /* find the character after the last non-blank character */
      for (last = first + STRLEN(first);
! 				last > first && VIM_ISWHITE(last[-1]); --last)
  	;
      save = *last;
      *last = NUL;
***************
*** 400,406 ****
  
      for (p = eap->arg; *p != NUL; ++p)
      {
! 	if (vim_iswhite(*p))
  	    ;
  	else if (*p == 'i')
  	    sort_ic = TRUE;
--- 400,406 ----
  
      for (p = eap->arg; *p != NUL; ++p)
      {
! 	if (VIM_ISWHITE(*p))
  	    ;
  	else if (*p == 'i')
  	    sort_ic = TRUE;
***************
*** 683,689 ****
  	did_undo = FALSE;
  	for (;;)
  	{
! 	    if (vim_iswhite(ptr[col]))
  	    {
  		if (!got_tab && num_spaces == 0)
  		{
--- 683,689 ----
  	did_undo = FALSE;
  	for (;;)
  	{
! 	    if (VIM_ISWHITE(ptr[col]))
  	    {
  		if (!got_tab && num_spaces == 0)
  		{
***************
*** 4807,4813 ****
  	which_pat = RE_SUBST;	/* use last substitute regexp */
  
  				/* new pattern and substitution */
!     if (eap->cmd[0] == 's' && *cmd != NUL && !vim_iswhite(*cmd)
  		&& vim_strchr((char_u *)"0123456789cegriIp|\"", *cmd) == NULL)
      {
  				/* don't accept alphanumeric for separator */
--- 4807,4813 ----
  	which_pat = RE_SUBST;	/* use last substitute regexp */
  
  				/* new pattern and substitution */
!     if (eap->cmd[0] == 's' && *cmd != NUL && !VIM_ISWHITE(*cmd)
  		&& vim_strchr((char_u *)"0123456789cegriIp|\"", *cmd) == NULL)
      {
  				/* don't accept alphanumeric for separator */
***************
*** 6225,6231 ****
  
      /* remove trailing blanks */
      p = arg + STRLEN(arg) - 1;
!     while (p > arg && vim_iswhite(*p) && p[-1] != '\\')
  	*p-- = NUL;
  
  #ifdef FEAT_MULTI_LANG
--- 6225,6231 ----
  
      /* remove trailing blanks */
      p = arg + STRLEN(arg) - 1;
!     while (p > arg && VIM_ISWHITE(*p) && p[-1] != '\\')
  	*p-- = NUL;
  
  #ifdef FEAT_MULTI_LANG
***************
*** 6809,6815 ****
  	{
  	    line = ml_get_buf(curbuf, lnum, FALSE);
  	    len = (int)STRLEN(line);
! 	    if (in_example && len > 0 && !vim_iswhite(line[0]))
  	    {
  		/* End of example: non-white or '<' in first column. */
  		if (line[0] == '<')
--- 6809,6815 ----
  	{
  	    line = ml_get_buf(curbuf, lnum, FALSE);
  	    len = (int)STRLEN(line);
! 	    if (in_example && len > 0 && !VIM_ISWHITE(line[0]))
  	    {
  		/* End of example: non-white or '<' in first column. */
  		if (line[0] == '<')
***************
*** 7421,7427 ****
      int		add_help_tags = FALSE;
  
      /* Check for ":helptags ++t {dir}". */
!     if (STRNCMP(eap->arg, "++t", 3) == 0 && vim_iswhite(eap->arg[3]))
      {
  	add_help_tags = TRUE;
  	eap->arg = skipwhite(eap->arg + 3);
--- 7421,7427 ----
      int		add_help_tags = FALSE;
  
      /* Check for ":helptags ++t {dir}". */
!     if (STRNCMP(eap->arg, "++t", 3) == 0 && VIM_ISWHITE(eap->arg[3]))
      {
  	add_help_tags = TRUE;
  	eap->arg = skipwhite(eap->arg + 3);
***************
*** 7754,7760 ****
  	if (VIM_ISDIGIT(*arg))
  	{
  	    id = getdigits(&arg);
! 	    if (!vim_iswhite(*arg) && *arg != NUL)
  	    {
  		id = -1;
  		arg = arg1;
--- 7754,7760 ----
  	if (VIM_ISDIGIT(*arg))
  	{
  	    id = getdigits(&arg);
! 	    if (!VIM_ISWHITE(*arg) && *arg != NUL)
  	    {
  		id = -1;
  		arg = arg1;
*** ../vim-8.0.0451/src/ex_cmds2.c	2017-03-12 19:22:31.748584985 +0100
--- src/ex_cmds2.c	2017-03-12 19:41:30.540547052 +0100
***************
*** 5183,5189 ****
       * Allow abbreviation, but require at least 3 characters to avoid
       * confusion with a two letter language name "me" or "ct". */
      p = skiptowhite(eap->arg);
!     if ((*p == NUL || vim_iswhite(*p)) && p - eap->arg >= 3)
      {
  	if (STRNICMP(eap->arg, "messages", p - eap->arg) == 0)
  	{
--- 5183,5189 ----
       * Allow abbreviation, but require at least 3 characters to avoid
       * confusion with a two letter language name "me" or "ct". */
      p = skiptowhite(eap->arg);
!     if ((*p == NUL || VIM_ISWHITE(*p)) && p - eap->arg >= 3)
      {
  	if (STRNICMP(eap->arg, "messages", p - eap->arg) == 0)
  	{
*** ../vim-8.0.0451/src/ex_docmd.c	2017-03-12 19:22:31.748584985 +0100
--- src/ex_docmd.c	2017-03-12 19:41:57.552356727 +0100
***************
*** 2013,2019 ****
  			if (save_msg_silent == -1)
  			    save_msg_silent = msg_silent;
  			++msg_silent;
! 			if (*ea.cmd == '!' && !vim_iswhite(ea.cmd[-1]))
  			{
  			    /* ":silent!", but not "silent !cmd" */
  			    ea.cmd = skipwhite(ea.cmd + 1);
--- 2013,2019 ----
  			if (save_msg_silent == -1)
  			    save_msg_silent = msg_silent;
  			++msg_silent;
! 			if (*ea.cmd == '!' && !VIM_ISWHITE(ea.cmd[-1]))
  			{
  			    /* ":silent!", but not "silent !cmd" */
  			    ea.cmd = skipwhite(ea.cmd + 1);
***************
*** 2771,2777 ****
       */
      if ((ea.argt & COUNT) && VIM_ISDIGIT(*ea.arg)
  	    && (!(ea.argt & BUFNAME) || *(p = skipdigits(ea.arg)) == NUL
! 							  || vim_iswhite(*p)))
      {
  	n = getdigits(&ea.arg);
  	ea.arg = skipwhite(ea.arg);
--- 2771,2777 ----
       */
      if ((ea.argt & COUNT) && VIM_ISDIGIT(*ea.arg)
  	    && (!(ea.argt & BUFNAME) || *(p = skipdigits(ea.arg)) == NUL
! 							  || VIM_ISWHITE(*p)))
      {
  	n = getdigits(&ea.arg);
  	ea.arg = skipwhite(ea.arg);
***************
*** 2939,2945 ****
  	else
  	{
  	    p = ea.arg + STRLEN(ea.arg);
! 	    while (p > ea.arg && vim_iswhite(p[-1]))
  		--p;
  	}
  	ea.line2 = buflist_findpat(ea.arg, p, (ea.argt & BUFUNL) != 0,
--- 2939,2945 ----
  	else
  	{
  	    p = ea.arg + STRLEN(ea.arg);
! 	    while (p > ea.arg && VIM_ISWHITE(p[-1]))
  		--p;
  	}
  	ea.line2 = buflist_findpat(ea.arg, p, (ea.argt & BUFUNL) != 0,
***************
*** 3757,3763 ****
  	    }
  	    /* An argument can contain just about everything, except
  	     * characters that end the command and white space. */
! 	    else if (c == '|' || c == '\n' || c == '"' || (vim_iswhite(c)
  #ifdef SPACE_IN_FILENAME
  					 && (!(ea.argt & NOSPC) || usefilter)
  #endif
--- 3757,3763 ----
  	    }
  	    /* An argument can contain just about everything, except
  	     * characters that end the command and white space. */
! 	    else if (c == '|' || c == '\n' || c == '"' || (VIM_ISWHITE(c)
  #ifdef SPACE_IN_FILENAME
  					 && (!(ea.argt & NOSPC) || usefilter)
  #endif
***************
*** 5136,5142 ****
  			/* skip escaped characters */
  			if (p[1] && (*p == '\\' || *p == Ctrl_V))
  			    ++p;
! 			else if (vim_iswhite(*p))
  			{
  			    *errormsgp = (char_u *)_("E172: Only one file name allowed");
  			    return FAIL;
--- 5136,5142 ----
  			/* skip escaped characters */
  			if (p[1] && (*p == '\\' || *p == Ctrl_V))
  			    ++p;
! 			else if (VIM_ISWHITE(*p))
  			{
  			    *errormsgp = (char_u *)_("E172: Only one file name allowed");
  			    return FAIL;
***************
*** 6336,6342 ****
      if (ASCII_ISALPHA(*p))
  	while (ASCII_ISALNUM(*p))
  	    ++p;
!     if (!ends_excmd(*p) && !vim_iswhite(*p))
      {
  	EMSG(_("E182: Invalid command name"));
  	return;
--- 6336,6342 ----
      if (ASCII_ISALPHA(*p))
  	while (ASCII_ISALNUM(*p))
  	    ++p;
!     if (!ends_excmd(*p) && !VIM_ISWHITE(*p))
      {
  	EMSG(_("E182: Invalid command name"));
  	return;
***************
*** 6464,6470 ****
  	    len += 2;
  	    p += 2;
  	}
! 	else if (p[0] == '\\' && vim_iswhite(p[1]))
  	{
  	    len += 1;
  	    p += 2;
--- 6464,6470 ----
  	    len += 2;
  	    p += 2;
  	}
! 	else if (p[0] == '\\' && VIM_ISWHITE(p[1]))
  	{
  	    len += 1;
  	    p += 2;
***************
*** 6474,6480 ****
  	    len += 2;
  	    p += 1;
  	}
! 	else if (vim_iswhite(*p))
  	{
  	    p = skipwhite(p);
  	    if (*p == NUL)
--- 6474,6480 ----
  	    len += 2;
  	    p += 1;
  	}
! 	else if (VIM_ISWHITE(*p))
  	{
  	    p = skipwhite(p);
  	    if (*p == NUL)
***************
*** 6512,6518 ****
  	    *q++ = '\\';
  	    p += 2;
  	}
! 	else if (p[0] == '\\' && vim_iswhite(p[1]))
  	{
  	    *q++ = p[1];
  	    p += 2;
--- 6512,6518 ----
  	    *q++ = '\\';
  	    p += 2;
  	}
! 	else if (p[0] == '\\' && VIM_ISWHITE(p[1]))
  	{
  	    *q++ = p[1];
  	    p += 2;
***************
*** 6522,6528 ****
  	    *q++ = '\\';
  	    *q++ = *p++;
  	}
! 	else if (vim_iswhite(*p))
  	{
  	    p = skipwhite(p);
  	    if (*p == NUL)
--- 6522,6528 ----
  	    *q++ = '\\';
  	    *q++ = *p++;
  	}
! 	else if (VIM_ISWHITE(*p))
  	{
  	    p = skipwhite(p);
  	    if (*p == NUL)
***************
*** 7078,7084 ****
      {
  	char_u	*err = value;
  
! 	for (i = 0; err[i] != NUL && !vim_iswhite(err[i]); i++)
  	    ;
  	err[i] = NUL;
  	EMSG2(_("E180: Invalid address type value: %s"), err);
--- 7078,7084 ----
      {
  	char_u	*err = value;
  
! 	for (i = 0; err[i] != NUL && !VIM_ISWHITE(err[i]); i++)
  	    ;
  	err[i] = NUL;
  	EMSG2(_("E180: Invalid address type value: %s"), err);
***************
*** 12264,12270 ****
      if (ends_excmd(*eap->arg))
  	end = eap->arg;
      else if ((STRNICMP(eap->arg, "none", 4) == 0
! 		&& (vim_iswhite(eap->arg[4]) || ends_excmd(eap->arg[4]))))
  	end = eap->arg + 4;
      else
      {
--- 12264,12270 ----
      if (ends_excmd(*eap->arg))
  	end = eap->arg;
      else if ((STRNICMP(eap->arg, "none", 4) == 0
! 		&& (VIM_ISWHITE(eap->arg[4]) || ends_excmd(eap->arg[4]))))
  	end = eap->arg + 4;
      else
      {
*** ../vim-8.0.0451/src/ex_getln.c	2017-03-12 19:22:31.752584957 +0100
--- src/ex_getln.c	2017-03-12 19:42:14.276238880 +0100
***************
*** 6027,6033 ****
  		if (p == NULL)
  		    break;
  		++p;
! 		for (i = 0; p[i] && !vim_iswhite(p[i]); ++i)
  		    if (p[i] == '\\' && p[i + 1])
  			++i;
  		STRMOVE(p, p + i);
--- 6027,6033 ----
  		if (p == NULL)
  		    break;
  		++p;
! 		for (i = 0; p[i] && !VIM_ISWHITE(p[i]); ++i)
  		    if (p[i] == '\\' && p[i + 1])
  			++i;
  		STRMOVE(p, p + i);
*** ../vim-8.0.0451/src/fileio.c	2017-03-12 19:22:31.752584957 +0100
--- src/fileio.c	2017-03-12 19:42:32.656109355 +0100
***************
*** 8163,8169 ****
      int		len;
  
      /* the event name ends with end of line, '|', a blank or a comma */
!     for (p = start; *p && !vim_iswhite(*p) && *p != ',' && *p != '|'; ++p)
  	;
      for (i = 0; event_names[i].name != NULL; ++i)
      {
--- 8163,8169 ----
      int		len;
  
      /* the event name ends with end of line, '|', a blank or a comma */
!     for (p = start; *p && !VIM_ISWHITE(*p) && *p != ',' && *p != '|'; ++p)
  	;
      for (i = 0; event_names[i].name != NULL; ++i)
      {
***************
*** 8206,8212 ****
  
      if (*arg == '*')
      {
! 	if (arg[1] && !vim_iswhite(arg[1]))
  	{
  	    EMSG2(_("E215: Illegal character after *: %s"), arg);
  	    return NULL;
--- 8206,8212 ----
  
      if (*arg == '*')
      {
! 	if (arg[1] && !VIM_ISWHITE(arg[1]))
  	{
  	    EMSG2(_("E215: Illegal character after *: %s"), arg);
  	    return NULL;
***************
*** 8215,8221 ****
      }
      else
      {
! 	for (pat = arg; *pat && *pat != '|' && !vim_iswhite(*pat); pat = p)
  	{
  	    if ((int)event_name2nr(pat, &p) >= (int)NUM_EVENTS)
  	    {
--- 8215,8221 ----
      }
      else
      {
! 	for (pat = arg; *pat && *pat != '|' && !VIM_ISWHITE(*pat); pat = p)
  	{
  	    if ((int)event_name2nr(pat, &p) >= (int)NUM_EVENTS)
  	    {
***************
*** 8394,8400 ****
  	 * Scan over the pattern.  Put a NUL at the end.
  	 */
  	cmd = pat;
! 	while (*cmd && (!vim_iswhite(*cmd) || cmd[-1] == '\\'))
  	    cmd++;
  	if (*cmd)
  	    *cmd++ = NUL;
--- 8394,8400 ----
  	 * Scan over the pattern.  Put a NUL at the end.
  	 */
  	cmd = pat;
! 	while (*cmd && (!VIM_ISWHITE(*cmd) || cmd[-1] == '\\'))
  	    cmd++;
  	if (*cmd)
  	    *cmd++ = NUL;
***************
*** 8420,8426 ****
  	 * Check for "nested" flag.
  	 */
  	cmd = skipwhite(cmd);
! 	if (*cmd != NUL && STRNCMP(cmd, "nested", 6) == 0 && vim_iswhite(cmd[6]))
  	{
  	    nested = TRUE;
  	    cmd = skipwhite(cmd + 6);
--- 8420,8426 ----
  	 * Check for "nested" flag.
  	 */
  	cmd = skipwhite(cmd);
! 	if (*cmd != NUL && STRNCMP(cmd, "nested", 6) == 0 && VIM_ISWHITE(cmd[6]))
  	{
  	    nested = TRUE;
  	    cmd = skipwhite(cmd + 6);
***************
*** 8463,8469 ****
      }
      else
      {
! 	while (*arg && *arg != '|' && !vim_iswhite(*arg))
  	    if (do_autocmd_event(event_name2nr(arg, &arg), pat,
  					nested,	cmd, forceit, group) == FAIL)
  		break;
--- 8463,8469 ----
      }
      else
      {
! 	while (*arg && *arg != '|' && !VIM_ISWHITE(*arg))
  	    if (do_autocmd_event(event_name2nr(arg, &arg), pat,
  					nested,	cmd, forceit, group) == FAIL)
  		break;
***************
*** 8488,8494 ****
      char_u	*arg = *argp;
      int		group = AUGROUP_ALL;
  
!     for (p = arg; *p && !vim_iswhite(*p) && *p != '|'; ++p)
  	;
      if (p > arg)
      {
--- 8488,8494 ----
      char_u	*arg = *argp;
      int		group = AUGROUP_ALL;
  
!     for (p = arg; *p && !VIM_ISWHITE(*p) && *p != '|'; ++p)
  	;
      if (p > arg)
      {
***************
*** 8800,8806 ****
      /*
       * Loop over the events.
       */
!     while (*arg && !vim_iswhite(*arg))
  	if (apply_autocmds_group(event_name2nr(arg, &arg),
  				      fname, NULL, TRUE, group, curbuf, NULL))
  	    nothing_done = FALSE;
--- 8800,8806 ----
      /*
       * Loop over the events.
       */
!     while (*arg && !VIM_ISWHITE(*arg))
  	if (apply_autocmds_group(event_name2nr(arg, &arg),
  				      fname, NULL, TRUE, group, curbuf, NULL))
  	    nothing_done = FALSE;
***************
*** 9916,9929 ****
      if (group == AUGROUP_ERROR)
  	return NULL;
      /* If there only is a group name that's what we expand. */
!     if (*arg == NUL && group != AUGROUP_ALL && !vim_iswhite(arg[-1]))
      {
  	arg = p;
  	group = AUGROUP_ALL;
      }
  
      /* skip over event name */
!     for (p = arg; *p != NUL && !vim_iswhite(*p); ++p)
  	if (*p == ',')
  	    arg = p + 1;
      if (*p == NUL)
--- 9916,9929 ----
      if (group == AUGROUP_ERROR)
  	return NULL;
      /* If there only is a group name that's what we expand. */
!     if (*arg == NUL && group != AUGROUP_ALL && !VIM_ISWHITE(arg[-1]))
      {
  	arg = p;
  	group = AUGROUP_ALL;
      }
  
      /* skip over event name */
!     for (p = arg; *p != NUL && !VIM_ISWHITE(*p); ++p)
  	if (*p == ',')
  	    arg = p + 1;
      if (*p == NUL)
***************
*** 9937,9943 ****
  
      /* skip over pattern */
      arg = skipwhite(p);
!     while (*arg && (!vim_iswhite(*arg) || arg[-1] == '\\'))
  	arg++;
      if (*arg)
  	return arg;			    /* expand (next) command */
--- 9937,9943 ----
  
      /* skip over pattern */
      arg = skipwhite(p);
!     while (*arg && (!VIM_ISWHITE(*arg) || arg[-1] == '\\'))
  	arg++;
      if (*arg)
  	return arg;			    /* expand (next) command */
*** ../vim-8.0.0451/src/getchar.c	2017-03-02 23:05:45.545710576 +0100
--- src/getchar.c	2017-03-12 19:42:53.691961099 +0100
***************
*** 2651,2657 ****
  				ptr = ml_get_curline();
  				while (col < curwin->w_cursor.col)
  				{
! 				    if (!vim_iswhite(ptr[col]))
  					curwin->w_wcol = vcol;
  				    vcol += lbr_chartabsize(ptr, ptr + col,
  							       (colnr_T)vcol);
--- 2651,2657 ----
  				ptr = ml_get_curline();
  				while (col < curwin->w_cursor.col)
  				{
! 				    if (!VIM_ISWHITE(ptr[col]))
  					curwin->w_wcol = vcol;
  				    vcol += lbr_chartabsize(ptr, ptr + col,
  							       (colnr_T)vcol);
***************
*** 3324,3330 ****
       */
      p = keys;
      do_backslash = (vim_strchr(p_cpo, CPO_BSLASH) == NULL);
!     while (*p && (maptype == 1 || !vim_iswhite(*p)))
      {
  	if ((p[0] == Ctrl_V || (do_backslash && p[0] == '\\')) &&
  								  p[1] != NUL)
--- 3324,3330 ----
       */
      p = keys;
      do_backslash = (vim_strchr(p_cpo, CPO_BSLASH) == NULL);
!     while (*p && (maptype == 1 || !VIM_ISWHITE(*p)))
      {
  	if ((p[0] == Ctrl_V || (do_backslash && p[0] == '\\')) &&
  								  p[1] != NUL)
***************
*** 3429,3435 ****
  			}
  	    /* An abbreviation cannot contain white space. */
  	    for (n = 0; n < len; ++n)
! 		if (vim_iswhite(keys[n]))
  		{
  		    retval = 1;
  		    goto theend;
--- 3429,3435 ----
  			}
  	    /* An abbreviation cannot contain white space. */
  	    for (n = 0; n < len; ++n)
! 		if (VIM_ISWHITE(keys[n]))
  		{
  		    retval = 1;
  		    goto theend;
***************
*** 5043,5049 ****
  	 * interpreted as the start of a special key name.
  	 * A space in the lhs of a :map needs a CTRL-V.
  	 */
! 	if (what == 2 && (vim_iswhite(c) || c == '"' || c == '\\'))
  	{
  	    if (putc('\\', fd) < 0)
  		return FAIL;
--- 5043,5049 ----
  	 * interpreted as the start of a special key name.
  	 * A space in the lhs of a :map needs a CTRL-V.
  	 */
! 	if (what == 2 && (VIM_ISWHITE(c) || c == '"' || c == '\\'))
  	{
  	    if (putc('\\', fd) < 0)
  		return FAIL;
*** ../vim-8.0.0451/src/gui.c	2017-03-12 19:22:31.752584957 +0100
--- src/gui.c	2017-03-12 19:43:05.047881060 +0100
***************
*** 4967,4973 ****
       */
      if (arg[0] == '-'
  	    && (arg[1] == 'f' || arg[1] == 'b')
! 	    && (arg[2] == NUL || vim_iswhite(arg[2])))
      {
  	gui.dofork = (arg[1] == 'b');
  	eap->arg = skipwhite(eap->arg + 2);
--- 4967,4973 ----
       */
      if (arg[0] == '-'
  	    && (arg[1] == 'f' || arg[1] == 'b')
! 	    && (arg[2] == NUL || VIM_ISWHITE(arg[2])))
      {
  	gui.dofork = (arg[1] == 'b');
  	eap->arg = skipwhite(eap->arg + 2);
*** ../vim-8.0.0451/src/gui_w32.c	2017-02-01 13:43:32.530844971 +0100
--- src/gui_w32.c	2017-03-12 19:43:15.891804627 +0100
***************
*** 7112,7118 ****
  #else
  	    l = 1;
  #endif
! 	    if (l == 1 && vim_iswhite(*pend)
  					&& textWidth > maxDialogWidth * 3 / 4)
  		last_white = pend;
  	    textWidth += GetTextWidthEnc(hdc, pend, l);
--- 7112,7118 ----
  #else
  	    l = 1;
  #endif
! 	    if (l == 1 && VIM_ISWHITE(*pend)
  					&& textWidth > maxDialogWidth * 3 / 4)
  		last_white = pend;
  	    textWidth += GetTextWidthEnc(hdc, pend, l);
***************
*** 8581,8586 ****
--- 8581,8587 ----
  gui_mch_post_balloon(BalloonEval *beval, char_u *mesg)
  {
      POINT   pt;
+ 
      // TRACE0("gui_mch_post_balloon {{{");
      if (beval->showState == ShS_SHOWING)
  	return;
***************
*** 8588,8595 ****
      ScreenToClient(s_textArea, &pt);
  
      if (abs(beval->x - pt.x) < 3 && abs(beval->y - pt.y) < 3)
- 	/* cursor is still here */
      {
  	gui_mch_disable_beval_area(cur_beval);
  	beval->showState = ShS_SHOWING;
  	make_tooltip(beval, (char *)mesg, pt);
--- 8589,8596 ----
      ScreenToClient(s_textArea, &pt);
  
      if (abs(beval->x - pt.x) < 3 && abs(beval->y - pt.y) < 3)
      {
+ 	/* cursor is still here */
  	gui_mch_disable_beval_area(cur_beval);
  	beval->showState = ShS_SHOWING;
  	make_tooltip(beval, (char *)mesg, pt);
*** ../vim-8.0.0451/src/if_cscope.c	2017-03-05 17:43:10.616245604 +0100
--- src/if_cscope.c	2017-03-12 19:43:26.727728246 +0100
***************
*** 781,787 ****
       * they may want to use the leading white space. */
      pat = pattern;
      if (search != 4 && search != 6)
! 	while vim_iswhite(*pat)
  	    ++pat;
  
      if ((cmd = (char *)alloc((unsigned)(strlen(pat) + 2))) == NULL)
--- 781,787 ----
       * they may want to use the leading white space. */
      pat = pattern;
      if (search != 4 && search != 6)
! 	while VIM_ISWHITE(*pat)
  	    ++pat;
  
      if ((cmd = (char *)alloc((unsigned)(strlen(pat) + 2))) == NULL)
*** ../vim-8.0.0451/src/mbyte.c	2017-03-12 19:22:31.756584930 +0100
--- src/mbyte.c	2017-03-12 19:43:39.155640639 +0100
***************
*** 886,892 ****
  {
      if (MB_BYTE2LEN(p[0]) == 1)
      {
! 	if (p[0] == NUL || vim_iswhite(p[0]))
  	    return 0;
  	if (vim_iswordc_buf(p[0], buf))
  	    return 2;
--- 886,892 ----
  {
      if (MB_BYTE2LEN(p[0]) == 1)
      {
! 	if (p[0] == NUL || VIM_ISWHITE(p[0]))
  	    return 0;
  	if (vim_iswordc_buf(p[0], buf))
  	    return 2;
*** ../vim-8.0.0451/src/menu.c	2017-03-12 19:22:31.756584930 +0100
--- src/menu.c	2017-03-12 19:44:24.191323136 +0100
***************
*** 167,175 ****
      for (p = arg; *p; ++p)
  	if (!VIM_ISDIGIT(*p) && *p != '.')
  	    break;
!     if (vim_iswhite(*p))
      {
! 	for (i = 0; i < MENUDEPTH && !vim_iswhite(*arg); ++i)
  	{
  	    pri_tab[i] = getdigits(&arg);
  	    if (pri_tab[i] == 0)
--- 167,175 ----
      for (p = arg; *p; ++p)
  	if (!VIM_ISDIGIT(*p) && *p != '.')
  	    break;
!     if (VIM_ISWHITE(*p))
      {
! 	for (i = 0; i < MENUDEPTH && !VIM_ISWHITE(*arg); ++i)
  	{
  	    pri_tab[i] = getdigits(&arg);
  	    if (pri_tab[i] == 0)
***************
*** 193,204 ****
      /*
       * Check for "disable" or "enable" argument.
       */
!     if (STRNCMP(arg, "enable", 6) == 0 && vim_iswhite(arg[6]))
      {
  	enable = TRUE;
  	arg = skipwhite(arg + 6);
      }
!     else if (STRNCMP(arg, "disable", 7) == 0 && vim_iswhite(arg[7]))
      {
  	enable = FALSE;
  	arg = skipwhite(arg + 7);
--- 193,204 ----
      /*
       * Check for "disable" or "enable" argument.
       */
!     if (STRNCMP(arg, "enable", 6) == 0 && VIM_ISWHITE(arg[6]))
      {
  	enable = TRUE;
  	arg = skipwhite(arg + 6);
      }
!     else if (STRNCMP(arg, "disable", 7) == 0 && VIM_ISWHITE(arg[7]))
      {
  	enable = FALSE;
  	arg = skipwhite(arg + 7);
***************
*** 1219,1242 ****
  	if (!VIM_ISDIGIT(*p) && *p != '.')
  	    break;
  
!     if (!vim_iswhite(*p))
      {
  	if (STRNCMP(arg, "enable", 6) == 0
! 		&& (arg[6] == NUL ||  vim_iswhite(arg[6])))
  	    p = arg + 6;
  	else if (STRNCMP(arg, "disable", 7) == 0
! 		&& (arg[7] == NUL || vim_iswhite(arg[7])))
  	    p = arg + 7;
  	else
  	    p = arg;
      }
  
!     while (*p != NUL && vim_iswhite(*p))
  	++p;
  
      arg = after_dot = p;
  
!     for (; *p && !vim_iswhite(*p); ++p)
      {
  	if ((*p == '\\' || *p == Ctrl_V) && p[1] != NUL)
  	    p++;
--- 1219,1242 ----
  	if (!VIM_ISDIGIT(*p) && *p != '.')
  	    break;
  
!     if (!VIM_ISWHITE(*p))
      {
  	if (STRNCMP(arg, "enable", 6) == 0
! 		&& (arg[6] == NUL ||  VIM_ISWHITE(arg[6])))
  	    p = arg + 6;
  	else if (STRNCMP(arg, "disable", 7) == 0
! 		&& (arg[7] == NUL || VIM_ISWHITE(arg[7])))
  	    p = arg + 7;
  	else
  	    p = arg;
      }
  
!     while (*p != NUL && VIM_ISWHITE(*p))
  	++p;
  
      arg = after_dot = p;
  
!     for (; *p && !VIM_ISWHITE(*p); ++p)
      {
  	if ((*p == '\\' || *p == Ctrl_V) && p[1] != NUL)
  	    p++;
***************
*** 1247,1253 ****
      /* ":tearoff" and ":popup" only use menus, not entries */
      expand_menus = !((*cmd == 't' && cmd[1] == 'e') || *cmd == 'p');
      expand_emenu = (*cmd == 'e');
!     if (expand_menus && vim_iswhite(*p))
  	return NULL;	/* TODO: check for next command? */
      if (*p == NUL)		/* Complete the menu name */
      {
--- 1247,1253 ----
      /* ":tearoff" and ":popup" only use menus, not entries */
      expand_menus = !((*cmd == 't' && cmd[1] == 'e') || *cmd == 'p');
      expand_emenu = (*cmd == 'e');
!     if (expand_menus && VIM_ISWHITE(*p))
  	return NULL;	/* TODO: check for next command? */
      if (*p == NUL)		/* Complete the menu name */
      {
***************
*** 2432,2438 ****
      static char_u *
  menu_skip_part(char_u *p)
  {
!     while (*p != NUL && *p != '.' && !vim_iswhite(*p))
      {
  	if ((*p == '\\' || *p == Ctrl_V) && p[1] != NUL)
  	    ++p;
--- 2432,2438 ----
      static char_u *
  menu_skip_part(char_u *p)
  {
!     while (*p != NUL && *p != '.' && !VIM_ISWHITE(*p))
      {
  	if ((*p == '\\' || *p == Ctrl_V) && p[1] != NUL)
  	    ++p;
***************
*** 2500,2506 ****
  {
      char_u	*arg = arg_start;
  
!     while (*arg && !vim_iswhite(*arg))
      {
  	if ((*arg == '\\' || *arg == Ctrl_V) && arg[1] != NUL)
  	    arg++;
--- 2500,2506 ----
  {
      char_u	*arg = arg_start;
  
!     while (*arg && !VIM_ISWHITE(*arg))
      {
  	if ((*arg == '\\' || *arg == Ctrl_V) && arg[1] != NUL)
  	    arg++;
*** ../vim-8.0.0451/src/message.c	2017-03-12 19:22:31.756584930 +0100
--- src/message.c	2017-03-12 19:44:33.539257226 +0100
***************
*** 1789,1795 ****
      if (list && lcs_trail)
      {
  	trail = s + STRLEN(s);
! 	while (trail > s && vim_iswhite(trail[-1]))
  	    --trail;
      }
  
--- 1789,1795 ----
      if (list && lcs_trail)
      {
  	trail = s + STRLEN(s);
! 	while (trail > s && VIM_ISWHITE(trail[-1]))
  	    --trail;
      }
  
*** ../vim-8.0.0451/src/misc1.c	2017-03-12 19:22:31.760584901 +0100
--- src/misc1.c	2017-03-12 19:45:05.715030341 +0100
***************
*** 139,145 ****
  	    ind_done = 0;
  
  	    /* count as many characters as we can use */
! 	    while (todo > 0 && vim_iswhite(*p))
  	    {
  		if (*p == TAB)
  		{
--- 139,145 ----
  	    ind_done = 0;
  
  	    /* count as many characters as we can use */
! 	    while (todo > 0 && VIM_ISWHITE(*p))
  	    {
  		if (*p == TAB)
  		{
***************
*** 202,208 ****
      }
  
      /* Return if the indent is OK already. */
!     if (!doit && !vim_iswhite(*p) && !(flags & SIN_INSERT))
  	return FALSE;
  
      /* Allocate memory for the new line. */
--- 202,208 ----
      }
  
      /* Return if the indent is OK already. */
!     if (!doit && !VIM_ISWHITE(*p) && !(flags & SIN_INSERT))
  	return FALSE;
  
      /* Allocate memory for the new line. */
***************
*** 234,240 ****
  
  	/* Skip over any additional white space (useful when newindent is less
  	 * than old) */
! 	while (vim_iswhite(*p))
  	    ++p;
  
      }
--- 234,240 ----
  
  	/* Skip over any additional white space (useful when newindent is less
  	 * than old) */
! 	while (VIM_ISWHITE(*p))
  	    ++p;
  
      }
***************
*** 258,264 ****
  	    p = oldline;
  	    ind_done = 0;
  
! 	    while (todo > 0 && vim_iswhite(*p))
  	    {
  		if (*p == TAB)
  		{
--- 258,264 ----
  	    p = oldline;
  	    ind_done = 0;
  
! 	    while (todo > 0 && VIM_ISWHITE(*p))
  	    {
  		if (*p == TAB)
  		{
***************
*** 357,363 ****
  	s = src;
  
  	/* Count/copy the usable portion of the source line */
! 	while (todo > 0 && vim_iswhite(*s))
  	{
  	    if (*s == TAB)
  	    {
--- 357,363 ----
  	s = src;
  
  	/* Count/copy the usable portion of the source line */
! 	while (todo > 0 && VIM_ISWHITE(*s))
  	{
  	    if (*s == TAB)
  	    {
***************
*** 820,826 ****
  		{
  		    /* Find last non-blank in line */
  		    p = ptr + STRLEN(ptr) - 1;
! 		    while (p > ptr && vim_iswhite(*p))
  			--p;
  		    last_char = *p;
  
--- 820,826 ----
  		{
  		    /* Find last non-blank in line */
  		    p = ptr + STRLEN(ptr) - 1;
! 		    while (p > ptr && VIM_ISWHITE(*p))
  			--p;
  		    last_char = *p;
  
***************
*** 831,837 ****
  		    {
  			if (p > ptr)
  			    --p;
! 			while (p > ptr && vim_iswhite(*p))
  			    --p;
  		    }
  		    /*
--- 831,837 ----
  		    {
  			if (p > ptr)
  			    --p;
! 			while (p > ptr && VIM_ISWHITE(*p))
  			    --p;
  		    }
  		    /*
***************
*** 1020,1026 ****
  		     * comment leader, then put a space after the middle
  		     * comment leader on the next line.
  		     */
! 		    if (!vim_iswhite(saved_line[lead_len - 1])
  			    && ((p_extra != NULL
  				    && (int)curwin->w_cursor.col == lead_len)
  				|| (p_extra == NULL
--- 1020,1026 ----
  		     * comment leader, then put a space after the middle
  		     * comment leader on the next line.
  		     */
! 		    if (!VIM_ISWHITE(saved_line[lead_len - 1])
  			    && ((p_extra != NULL
  				    && (int)curwin->w_cursor.col == lead_len)
  				|| (p_extra == NULL
***************
*** 1124,1130 ****
  		    {
  			/* find last non-white in the leader to line up with */
  			for (p = leader + lead_len - 1; p > leader
! 						      && vim_iswhite(*p); --p)
  			    ;
  			++p;
  
--- 1124,1130 ----
  		    {
  			/* find last non-white in the leader to line up with */
  			for (p = leader + lead_len - 1; p > leader
! 						      && VIM_ISWHITE(*p); --p)
  			    ;
  			++p;
  
***************
*** 1180,1186 ****
  			    }
  			    else
  #endif
! 			    if (!vim_iswhite(*p))
  				*p = ' ';
  			}
  		    }
--- 1180,1186 ----
  			    }
  			    else
  #endif
! 			    if (!VIM_ISWHITE(*p))
  				*p = ' ';
  			}
  		    }
***************
*** 1217,1223 ****
  			 * leader by spaces.  Keep Tabs, the indent must
  			 * remain the same. */
  			for (p += lead_repl_len; p < leader + lead_len; ++p)
! 			    if (!vim_iswhite(*p))
  			    {
  				/* Don't put a space before a TAB. */
  				if (p + 1 < leader + lead_len && p[1] == TAB)
--- 1217,1223 ----
  			 * leader by spaces.  Keep Tabs, the indent must
  			 * remain the same. */
  			for (p += lead_repl_len; p < leader + lead_len; ++p)
! 			    if (!VIM_ISWHITE(*p))
  			    {
  				/* Don't put a space before a TAB. */
  				if (p + 1 < leader + lead_len && p[1] == TAB)
***************
*** 1282,1288 ****
  
  		    /* If the leader ends in white space, don't add an
  		     * extra space */
! 		    if (lead_len > 0 && vim_iswhite(leader[lead_len - 1]))
  			extra_space = FALSE;
  		    leader[lead_len] = NUL;
  		}
--- 1282,1288 ----
  
  		    /* If the leader ends in white space, don't add an
  		     * extra space */
! 		    if (lead_len > 0 && VIM_ISWHITE(leader[lead_len - 1]))
  			extra_space = FALSE;
  		    leader[lead_len] = NUL;
  		}
***************
*** 1305,1311 ****
  #endif
  					   )
  		{
! 		    while (lead_len && vim_iswhite(*leader))
  		    {
  			--lead_len;
  			--newcol;
--- 1305,1311 ----
  #endif
  					   )
  		{
! 		    while (lead_len && VIM_ISWHITE(*leader))
  		    {
  			--lead_len;
  			--newcol;
***************
*** 1680,1686 ****
      char_u	*saved_flags = NULL;
  
      result = i = 0;
!     while (vim_iswhite(line[i]))    /* leading white space is ignored */
  	++i;
  
      /*
--- 1680,1686 ----
      char_u	*saved_flags = NULL;
  
      result = i = 0;
!     while (VIM_ISWHITE(line[i]))    /* leading white space is ignored */
  	++i;
  
      /*
***************
*** 1725,1735 ****
  	     * When string starts with white space, must have some white space
  	     * (but the amount does not need to match, there might be a mix of
  	     * TABs and spaces). */
! 	    if (vim_iswhite(string[0]))
  	    {
! 		if (i == 0 || !vim_iswhite(line[i - 1]))
  		    continue;  /* missing white space */
! 		while (vim_iswhite(string[0]))
  		    ++string;
  	    }
  	    for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)
--- 1725,1735 ----
  	     * When string starts with white space, must have some white space
  	     * (but the amount does not need to match, there might be a mix of
  	     * TABs and spaces). */
! 	    if (VIM_ISWHITE(string[0]))
  	    {
! 		if (i == 0 || !VIM_ISWHITE(line[i - 1]))
  		    continue;  /* missing white space */
! 		while (VIM_ISWHITE(string[0]))
  		    ++string;
  	    }
  	    for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)
***************
*** 1740,1746 ****
  	    /* When 'b' flag used, there must be white space or an
  	     * end-of-line after the string in the line. */
  	    if (vim_strchr(part_buf, COM_BLANK) != NULL
! 			   && !vim_iswhite(line[i + j]) && line[i + j] != NUL)
  		continue;
  
  	    /* We have found a match, stop searching unless this is a middle
--- 1740,1746 ----
  	    /* When 'b' flag used, there must be white space or an
  	     * end-of-line after the string in the line. */
  	    if (vim_strchr(part_buf, COM_BLANK) != NULL
! 			   && !VIM_ISWHITE(line[i + j]) && line[i + j] != NUL)
  		continue;
  
  	    /* We have found a match, stop searching unless this is a middle
***************
*** 1785,1791 ****
  	result = i;
  
  	/* Include any trailing white space. */
! 	while (vim_iswhite(line[i]))
  	    ++i;
  
  	if (include_space)
--- 1785,1791 ----
  	result = i;
  
  	/* Include any trailing white space. */
! 	while (VIM_ISWHITE(line[i]))
  	    ++i;
  
  	if (include_space)
***************
*** 1853,1863 ****
  	     * (but the amount does not need to match, there might be a mix of
  	     * TABs and spaces).
  	     */
! 	    if (vim_iswhite(string[0]))
  	    {
! 		if (i == 0 || !vim_iswhite(line[i - 1]))
  		    continue;
! 		while (vim_iswhite(string[0]))
  		    ++string;
  	    }
  	    for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)
--- 1853,1863 ----
  	     * (but the amount does not need to match, there might be a mix of
  	     * TABs and spaces).
  	     */
! 	    if (VIM_ISWHITE(string[0]))
  	    {
! 		if (i == 0 || !VIM_ISWHITE(line[i - 1]))
  		    continue;
! 		while (VIM_ISWHITE(string[0]))
  		    ++string;
  	    }
  	    for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)
***************
*** 1870,1876 ****
  	     * end-of-line after the string in the line.
  	     */
  	    if (vim_strchr(part_buf, COM_BLANK) != NULL
! 		    && !vim_iswhite(line[i + j]) && line[i + j] != NUL)
  	    {
  		continue;
  	    }
--- 1870,1876 ----
  	     * end-of-line after the string in the line.
  	     */
  	    if (vim_strchr(part_buf, COM_BLANK) != NULL
! 		    && !VIM_ISWHITE(line[i + j]) && line[i + j] != NUL)
  	    {
  		continue;
  	    }
***************
*** 1907,1913 ****
  	     * the comment leader correctly.
  	     */
  
! 	    while (vim_iswhite(*com_leader))
  		++com_leader;
  	    len1 = (int)STRLEN(com_leader);
  
--- 1907,1913 ----
  	     * the comment leader correctly.
  	     */
  
! 	    while (VIM_ISWHITE(*com_leader))
  		++com_leader;
  	    len1 = (int)STRLEN(com_leader);
  
***************
*** 1920,1926 ****
  		    continue;
  		string = vim_strchr(part_buf2, ':');
  		++string;
! 		while (vim_iswhite(*string))
  		    ++string;
  		len2 = (int)STRLEN(string);
  		if (len2 == 0)
--- 1920,1926 ----
  		    continue;
  		string = vim_strchr(part_buf2, ':');
  		++string;
! 		while (VIM_ISWHITE(*string))
  		    ++string;
  		len2 = (int)STRLEN(string);
  		if (len2 == 0)
***************
*** 2694,2700 ****
      char_u	*ptr;
      colnr_T	col;
  
!     for (col = 0, ptr = ml_get_curline(); vim_iswhite(*ptr); ++col)
  	++ptr;
      if (col >= curwin->w_cursor.col + extra)
  	return TRUE;
--- 2694,2700 ----
      char_u	*ptr;
      colnr_T	col;
  
!     for (col = 0, ptr = ml_get_curline(); VIM_ISWHITE(*ptr); ++col)
  	++ptr;
      if (col >= curwin->w_cursor.col + extra)
  	return TRUE;
***************
*** 5777,5783 ****
  	p = cin_skipcomment(skipwhite(s + 9));
  	while (*p != NUL)
  	{
! 	    if (vim_iswhite(*p))
  	    {
  		has_name = TRUE; /* found end of a name */
  		p = cin_skipcomment(skipwhite(p));
--- 5777,5783 ----
  	p = cin_skipcomment(skipwhite(s + 9));
  	while (*p != NUL)
  	{
! 	    if (VIM_ISWHITE(*p))
  	    {
  		has_name = TRUE; /* found end of a name */
  		p = cin_skipcomment(skipwhite(p));
***************
*** 5825,5831 ****
  	p = cin_skipcomment(skipwhite(s + 6));
  	while (*p != NUL)
  	{
! 	    if (vim_iswhite(*p))
  	    {
  		p = cin_skipcomment(skipwhite(p));
  	    }
--- 5825,5831 ----
  	p = cin_skipcomment(skipwhite(s + 6));
  	while (*p != NUL)
  	{
! 	    if (VIM_ISWHITE(*p))
  	    {
  		p = cin_skipcomment(skipwhite(p));
  	    }
***************
*** 5976,5990 ****
  	    || (len == 6 && STRNCMP(p, "signed", 6) == 0))
      {
  	s = skipwhite(p + len);
! 	if ((STRNCMP(s, "int", 3) == 0 && vim_iswhite(s[3]))
! 		|| (STRNCMP(s, "long", 4) == 0 && vim_iswhite(s[4]))
! 		|| (STRNCMP(s, "short", 5) == 0 && vim_iswhite(s[5]))
! 		|| (STRNCMP(s, "char", 4) == 0 && vim_iswhite(s[4])))
  	    p = s;
      }
      for (len = 0; vim_isIDc(p[len]); ++len)
  	;
!     if (len == 0 || !vim_iswhite(p[len]) || cin_nocode(p))
  	return 0;
  
      p = skipwhite(p + len);
--- 5976,5990 ----
  	    || (len == 6 && STRNCMP(p, "signed", 6) == 0))
      {
  	s = skipwhite(p + len);
! 	if ((STRNCMP(s, "int", 3) == 0 && VIM_ISWHITE(s[3]))
! 		|| (STRNCMP(s, "long", 4) == 0 && VIM_ISWHITE(s[4]))
! 		|| (STRNCMP(s, "short", 5) == 0 && VIM_ISWHITE(s[5]))
! 		|| (STRNCMP(s, "char", 4) == 0 && VIM_ISWHITE(s[4])))
  	    p = s;
      }
      for (len = 0; vim_isIDc(p[len]); ++len)
  	;
!     if (len == 0 || !VIM_ISWHITE(p[len]) || cin_nocode(p))
  	return 0;
  
      p = skipwhite(p + len);
***************
*** 6356,6362 ****
  
      if (offset-- < 2)
  	return 0;
!     while (offset > 2 && vim_iswhite(line[offset]))
  	--offset;
  
      offset -= 1;
--- 6356,6362 ----
  
      if (offset-- < 2)
  	return 0;
!     while (offset > 2 && VIM_ISWHITE(line[offset]))
  	--offset;
  
      offset -= 1;
***************
*** 7602,7608 ****
  		    else
  		    {
  			col = our_paren_pos.col + 1;
! 			while (vim_iswhite(l[col]))
  			    col++;
  			if (l[col] != NUL)	/* In case of trailing space */
  			    our_paren_pos.col = col;
--- 7602,7608 ----
  		    else
  		    {
  			col = our_paren_pos.col + 1;
! 			while (VIM_ISWHITE(l[col]))
  			    col++;
  			if (l[col] != NUL)	/* In case of trailing space */
  			    our_paren_pos.col = col;
***************
*** 9449,9455 ****
  		    amount++;
  		    firsttry = amount;
  
! 		    while (vim_iswhite(*that))
  		    {
  			amount += lbr_chartabsize(line, that, (colnr_T)amount);
  			++that;
--- 9449,9455 ----
  		    amount++;
  		    firsttry = amount;
  
! 		    while (VIM_ISWHITE(*that))
  		    {
  			amount += lbr_chartabsize(line, that, (colnr_T)amount);
  			++that;
***************
*** 9472,9478 ****
  				    && (*that < '0' || *that > '9')))
  			{
  			    while (*that
! 				    && (!vim_iswhite(*that)
  					|| quotecount
  					|| parencount)
  				    && (!((*that == '(' || *that == '[')
--- 9472,9478 ----
  				    && (*that < '0' || *that > '9')))
  			{
  			    while (*that
! 				    && (!VIM_ISWHITE(*that)
  					|| quotecount
  					|| parencount)
  				    && (!((*that == '(' || *that == '[')
***************
*** 9495,9501 ****
  						line, &that, (colnr_T)amount);
  			    }
  			}
! 			while (vim_iswhite(*that))
  			{
  			    amount += lbr_chartabsize(
  						 line, that, (colnr_T)amount);
--- 9495,9501 ----
  						line, &that, (colnr_T)amount);
  			    }
  			}
! 			while (VIM_ISWHITE(*that))
  			{
  			    amount += lbr_chartabsize(
  						 line, that, (colnr_T)amount);
*** ../vim-8.0.0451/src/misc2.c	2017-03-12 19:22:31.740585042 +0100
--- src/misc2.c	2017-03-12 19:45:22.646910936 +0100
***************
*** 1702,1708 ****
      char_u	*q;
  
      q = ptr + STRLEN(ptr);
!     while (--q > ptr && vim_iswhite(q[0]) && q[-1] != '\\' && q[-1] != Ctrl_V)
  	*q = NUL;
  }
  
--- 1702,1708 ----
      char_u	*q;
  
      q = ptr + STRLEN(ptr);
!     while (--q > ptr && VIM_ISWHITE(q[0]) && q[-1] != '\\' && q[-1] != Ctrl_V)
  	*q = NUL;
  }
  
*** ../vim-8.0.0451/src/normal.c	2017-03-12 18:23:35.853850026 +0100
--- src/normal.c	2017-03-12 19:45:37.818803935 +0100
***************
*** 3090,3096 ****
  		 * not a word character, try finding a match and select a (),
  		 * {}, [], #if/#endif, etc. block. */
  		end_visual = curwin->w_cursor;
! 		while (gc = gchar_pos(&end_visual), vim_iswhite(gc))
  		    inc(&end_visual);
  		if (oap != NULL)
  		    oap->motion_type = MCHAR;
--- 3090,3096 ----
  		 * not a word character, try finding a match and select a (),
  		 * {}, [], #if/#endif, etc. block. */
  		end_visual = curwin->w_cursor;
! 		while (gc = gchar_pos(&end_visual), VIM_ISWHITE(gc))
  		    inc(&end_visual);
  		if (oap != NULL)
  		    oap->motion_type = MCHAR;
***************
*** 3467,3473 ****
  	else
  #endif
  	    while (ptr[col] != NUL
! 		    && (i == 0 ? !vim_iswordc(ptr[col]) : vim_iswhite(ptr[col]))
  # if defined(FEAT_BEVAL)
  		    && (!(find_type & FIND_EVAL) || ptr[col] != ']')
  # endif
--- 3467,3473 ----
  	else
  #endif
  	    while (ptr[col] != NUL
! 		    && (i == 0 ? !vim_iswordc(ptr[col]) : VIM_ISWHITE(ptr[col]))
  # if defined(FEAT_BEVAL)
  		    && (!(find_type & FIND_EVAL) || ptr[col] != ']')
  # endif
***************
*** 3524,3530 ****
  	    while (col > 0
  		    && ((i == 0
  			    ? vim_iswordc(ptr[col - 1])
! 			    : (!vim_iswhite(ptr[col - 1])
  				&& (!(find_type & FIND_IDENT)
  				    || !vim_iswordc(ptr[col - 1]))))
  #if defined(FEAT_BEVAL)
--- 3524,3530 ----
  	    while (col > 0
  		    && ((i == 0
  			    ? vim_iswordc(ptr[col - 1])
! 			    : (!VIM_ISWHITE(ptr[col - 1])
  				&& (!(find_type & FIND_IDENT)
  				    || !vim_iswordc(ptr[col - 1]))))
  #if defined(FEAT_BEVAL)
***************
*** 3588,3594 ****
      else
  #endif
  	while ((i == 0 ? vim_iswordc(ptr[col])
! 		       : (ptr[col] != NUL && !vim_iswhite(ptr[col])))
  # if defined(FEAT_BEVAL)
  		    || ((find_type & FIND_EVAL)
  			&& col <= (int)startcol
--- 3588,3594 ----
      else
  #endif
  	while ((i == 0 ? vim_iswordc(ptr[col])
! 		       : (ptr[col] != NUL && !VIM_ISWHITE(ptr[col])))
  # if defined(FEAT_BEVAL)
  		    || ((find_type & FIND_EVAL)
  			&& col <= (int)startcol
***************
*** 8109,8115 ****
  	{
  	    do
  		i = gchar_cursor();
! 	    while (vim_iswhite(i) && oneright() == OK);
  	}
  	curwin->w_set_curswant = TRUE;
  	break;
--- 8109,8115 ----
  	{
  	    do
  		i = gchar_cursor();
! 	    while (VIM_ISWHITE(i) && oneright() == OK);
  	}
  	curwin->w_set_curswant = TRUE;
  	break;
***************
*** 8133,8139 ****
  
  	    /* Decrease the cursor column until it's on a non-blank. */
  	    while (curwin->w_cursor.col > 0
! 				    && vim_iswhite(ptr[curwin->w_cursor.col]))
  		--curwin->w_cursor.col;
  	    curwin->w_set_curswant = TRUE;
  	    adjust_for_sel(cap);
--- 8133,8139 ----
  
  	    /* Decrease the cursor column until it's on a non-blank. */
  	    while (curwin->w_cursor.col > 0
! 				    && VIM_ISWHITE(ptr[curwin->w_cursor.col]))
  		--curwin->w_cursor.col;
  	    curwin->w_set_curswant = TRUE;
  	    adjust_for_sel(cap);
***************
*** 8716,8722 ****
  	n = gchar_cursor();
  	if (n != NUL)			/* not an empty line */
  	{
! 	    if (vim_iswhite(n))
  	    {
  		/*
  		 * Reproduce a funny Vi behaviour: "cw" on a blank only
--- 8716,8722 ----
  	n = gchar_cursor();
  	if (n != NUL)			/* not an empty line */
  	{
! 	    if (VIM_ISWHITE(n))
  	    {
  		/*
  		 * Reproduce a funny Vi behaviour: "cw" on a blank only
*** ../vim-8.0.0451/src/ops.c	2017-03-12 19:22:31.760584901 +0100
--- src/ops.c	2017-03-12 19:45:52.330701583 +0100
***************
*** 429,435 ****
  #endif
  		++bd.textstart;
  	}
! 	for ( ; vim_iswhite(*bd.textstart); )
  	{
  	    /* TODO: is passing bd.textstart for start of the line OK? */
  	    incr = lbr_chartabsize_adv(bd.textstart, &bd.textstart,
--- 429,435 ----
  #endif
  		++bd.textstart;
  	}
! 	for ( ; VIM_ISWHITE(*bd.textstart); )
  	{
  	    /* TODO: is passing bd.textstart for start of the line OK? */
  	    incr = lbr_chartabsize_adv(bd.textstart, &bd.textstart,
***************
*** 491,497 ****
  	/* The character's column is in "bd.start_vcol".  */
  	non_white_col = bd.start_vcol;
  
! 	while (vim_iswhite(*non_white))
  	{
  	    incr = lbr_chartabsize_adv(bd.textstart, &non_white, non_white_col);
  	    non_white_col += incr;
--- 491,497 ----
  	/* The character's column is in "bd.start_vcol".  */
  	non_white_col = bd.start_vcol;
  
! 	while (VIM_ISWHITE(*non_white))
  	{
  	    incr = lbr_chartabsize_adv(bd.textstart, &non_white, non_white_col);
  	    non_white_col += incr;
***************
*** 4655,4672 ****
      line1 = vim_strsave(ml_get(lnum));
      if (line1 != NULL)
      {
! 	for (idx1 = 0; vim_iswhite(line1[idx1]); ++idx1)
  	    ;
  	line2 = ml_get(lnum + 1);
  	for (idx2 = 0; idx2 < leader2_len; ++idx2)
  	{
! 	    if (!vim_iswhite(line2[idx2]))
  	    {
  		if (line1[idx1++] != line2[idx2])
  		    break;
  	    }
  	    else
! 		while (vim_iswhite(line1[idx1]))
  		    ++idx1;
  	}
  	vim_free(line1);
--- 4655,4672 ----
      line1 = vim_strsave(ml_get(lnum));
      if (line1 != NULL)
      {
! 	for (idx1 = 0; VIM_ISWHITE(line1[idx1]); ++idx1)
  	    ;
  	line2 = ml_get(lnum + 1);
  	for (idx2 = 0; idx2 < leader2_len; ++idx2)
  	{
! 	    if (!VIM_ISWHITE(line2[idx2]))
  	    {
  		if (line1[idx1++] != line2[idx2])
  		    break;
  	    }
  	    else
! 		while (VIM_ISWHITE(line1[idx1]))
  		    ++idx1;
  	}
  	vim_free(line1);
***************
*** 5092,5101 ****
  
      if (*s == NUL)
  	return FALSE;
!     /* Don't use STRLEN() inside vim_iswhite(), SAS/C complains: "macro
       * invocation may call function multiple times". */
      l = STRLEN(s) - 1;
!     return vim_iswhite(s[l]);
  }
  
  /*
--- 5092,5101 ----
  
      if (*s == NUL)
  	return FALSE;
!     /* Don't use STRLEN() inside VIM_ISWHITE(), SAS/C complains: "macro
       * invocation may call function multiple times". */
      l = STRLEN(s) - 1;
!     return VIM_ISWHITE(s[l]);
  }
  
  /*
***************
*** 5250,5256 ****
  	incr = lbr_chartabsize(line, pstart, (colnr_T)bdp->start_vcol);
  	bdp->start_vcol += incr;
  #ifdef FEAT_VISUALEXTRA
! 	if (vim_iswhite(*pstart))
  	{
  	    bdp->pre_whitesp += incr;
  	    bdp->pre_whitesp_c++;
--- 5250,5256 ----
  	incr = lbr_chartabsize(line, pstart, (colnr_T)bdp->start_vcol);
  	bdp->start_vcol += incr;
  #ifdef FEAT_VISUALEXTRA
! 	if (VIM_ISWHITE(*pstart))
  	{
  	    bdp->pre_whitesp += incr;
  	    bdp->pre_whitesp_c++;
*** ../vim-8.0.0451/src/option.c	2017-03-12 19:22:31.760584901 +0100
--- src/option.c	2017-03-12 19:46:25.118470310 +0100
***************
*** 4438,4444 ****
  	    afterchar = arg[len];
  
  	    /* skip white space, allow ":set ai  ?" */
! 	    while (vim_iswhite(arg[len]))
  		++len;
  
  	    adding = FALSE;
--- 4438,4444 ----
  	    afterchar = arg[len];
  
  	    /* skip white space, allow ":set ai  ?" */
! 	    while (VIM_ISWHITE(arg[len]))
  		++len;
  
  	    adding = FALSE;
***************
*** 4562,4568 ****
  		    }
  		}
  		if (vim_strchr((char_u *)"?!&<", nextchar) != NULL
! 			&& arg[1] != NUL && !vim_iswhite(arg[1]))
  		{
  		    errmsg = e_trailing;
  		    goto skip;
--- 4562,4568 ----
  		    }
  		}
  		if (vim_strchr((char_u *)"?!&<", nextchar) != NULL
! 			&& arg[1] != NUL && !VIM_ISWHITE(arg[1]))
  		{
  		    errmsg = e_trailing;
  		    goto skip;
***************
*** 4620,4626 ****
  			(void)show_one_termcode(key_name, p, TRUE);
  		}
  		if (nextchar != '?'
! 			&& nextchar != NUL && !vim_iswhite(afterchar))
  		    errmsg = e_trailing;
  	    }
  	    else
--- 4620,4626 ----
  			(void)show_one_termcode(key_name, p, TRUE);
  		}
  		if (nextchar != '?'
! 			&& nextchar != NUL && !VIM_ISWHITE(afterchar))
  		    errmsg = e_trailing;
  	    }
  	    else
***************
*** 4660,4666 ****
  			 * ":set invopt": invert
  			 * ":set opt" or ":set noopt": set or reset
  			 */
! 			if (nextchar != NUL && !vim_iswhite(afterchar))
  			{
  			    errmsg = e_trailing;
  			    goto skip;
--- 4660,4666 ----
  			 * ":set invopt": invert
  			 * ":set opt" or ":set noopt": set or reset
  			 */
! 			if (nextchar != NUL && !VIM_ISWHITE(afterchar))
  			{
  			    errmsg = e_trailing;
  			    goto skip;
***************
*** 4714,4720 ****
  				    || (long *)varp == &p_wcm)
  				&& (*arg == '<'
  				    || *arg == '^'
! 				    || (*arg != NUL && (!arg[1] || vim_iswhite(arg[1]))
  					&& !VIM_ISDIGIT(*arg))))
  			{
  			    value = string_to_key(arg);
--- 4714,4721 ----
  				    || (long *)varp == &p_wcm)
  				&& (*arg == '<'
  				    || *arg == '^'
! 				    || (*arg != NUL
! 					&& (!arg[1] || VIM_ISWHITE(arg[1]))
  					&& !VIM_ISDIGIT(*arg))))
  			{
  			    value = string_to_key(arg);
***************
*** 4730,4736 ****
  			     * hex numbers. */
  			    vim_str2nr(arg, NULL, &i, STR2NR_ALL,
  							     &value, NULL, 0);
! 			    if (arg[i] != NUL && !vim_iswhite(arg[i]))
  			    {
  				errmsg = e_invarg;
  				goto skip;
--- 4731,4737 ----
  			     * hex numbers. */
  			    vim_str2nr(arg, NULL, &i, STR2NR_ALL,
  							     &value, NULL, 0);
! 			    if (arg[i] != NUL && !VIM_ISWHITE(arg[i]))
  			    {
  				errmsg = e_invarg;
  				goto skip;
***************
*** 4922,4928 ****
  			     * do remove it for "\\\\machine\\path".
  			     * The reverse is found in ExpandOldSetting().
  			     */
! 			    while (*arg && !vim_iswhite(*arg))
  			    {
  				if (*arg == '\\' && arg[1] != NUL
  #ifdef BACKSLASH_IN_FILENAME
--- 4923,4929 ----
  			     * do remove it for "\\\\machine\\path".
  			     * The reverse is found in ExpandOldSetting().
  			     */
! 			    while (*arg && !VIM_ISWHITE(*arg))
  			    {
  				if (*arg == '\\' && arg[1] != NUL
  #ifdef BACKSLASH_IN_FILENAME
***************
*** 5162,5168 ****
  			else
  			{
  			    ++arg; /* jump to after the '=' or ':' */
! 			    for (p = arg; *p && !vim_iswhite(*p); ++p)
  				if (*p == '\\' && p[1] != NUL)
  				    ++p;
  			    nextchar = *p;
--- 5163,5169 ----
  			else
  			{
  			    ++arg; /* jump to after the '=' or ':' */
! 			    for (p = arg; *p && !VIM_ISWHITE(*p); ++p)
  				if (*p == '\\' && p[1] != NUL)
  				    ++p;
  			    nextchar = *p;
***************
*** 5190,5196 ****
  	     */
  	    for (i = 0; i < 2 ; ++i)
  	    {
! 		while (*arg != NUL && !vim_iswhite(*arg))
  		    if (*arg++ == '\\' && *arg != NUL)
  			++arg;
  		arg = skipwhite(arg);
--- 5191,5197 ----
  	     */
  	    for (i = 0; i < 2 ; ++i)
  	    {
! 		while (*arg != NUL && !VIM_ISWHITE(*arg))
  		    if (*arg++ == '\\' && *arg != NUL)
  			++arg;
  		arg = skipwhite(arg);
*** ../vim-8.0.0451/src/os_unix.c	2017-03-12 19:22:31.760584901 +0100
--- src/os_unix.c	2017-03-12 19:46:38.422376460 +0100
***************
*** 6139,6145 ****
  	STRCAT(command, pat[0] + 1);		/* exclude first backtick */
  	p = command + STRLEN(command) - 1;
  	*p-- = ')';				/* remove last backtick */
! 	while (p > command && vim_iswhite(*p))
  	    --p;
  	if (*p == '&')				/* remove trailing '&' */
  	{
--- 6139,6145 ----
  	STRCAT(command, pat[0] + 1);		/* exclude first backtick */
  	p = command + STRLEN(command) - 1;
  	*p-- = ')';				/* remove last backtick */
! 	while (p > command && VIM_ISWHITE(*p))
  	    --p;
  	if (*p == '&')				/* remove trailing '&' */
  	{
*** ../vim-8.0.0451/src/os_win32.c	2017-03-12 19:22:31.764584873 +0100
--- src/os_win32.c	2017-03-12 19:46:48.730303742 +0100
***************
*** 4706,4712 ****
  	if (*cmdbase == '(')
  	    ++cmdbase;
  
! 	if ((STRNICMP(cmdbase, "start", 5) == 0) && vim_iswhite(cmdbase[5]))
  	{
  	    STARTUPINFO		si;
  	    PROCESS_INFORMATION	pi;
--- 4706,4712 ----
  	if (*cmdbase == '(')
  	    ++cmdbase;
  
! 	if ((STRNICMP(cmdbase, "start", 5) == 0) && VIM_ISWHITE(cmdbase[5]))
  	{
  	    STARTUPINFO		si;
  	    PROCESS_INFORMATION	pi;
***************
*** 4724,4737 ****
  
  	    cmdbase = skipwhite(cmdbase + 5);
  	    if ((STRNICMP(cmdbase, "/min", 4) == 0)
! 		    && vim_iswhite(cmdbase[4]))
  	    {
  		cmdbase = skipwhite(cmdbase + 4);
  		si.dwFlags = STARTF_USESHOWWINDOW;
  		si.wShowWindow = SW_SHOWMINNOACTIVE;
  	    }
  	    else if ((STRNICMP(cmdbase, "/b", 2) == 0)
! 		    && vim_iswhite(cmdbase[2]))
  	    {
  		cmdbase = skipwhite(cmdbase + 2);
  		flags = CREATE_NO_WINDOW;
--- 4724,4737 ----
  
  	    cmdbase = skipwhite(cmdbase + 5);
  	    if ((STRNICMP(cmdbase, "/min", 4) == 0)
! 		    && VIM_ISWHITE(cmdbase[4]))
  	    {
  		cmdbase = skipwhite(cmdbase + 4);
  		si.dwFlags = STARTF_USESHOWWINDOW;
  		si.wShowWindow = SW_SHOWMINNOACTIVE;
  	    }
  	    else if ((STRNICMP(cmdbase, "/b", 2) == 0)
! 		    && VIM_ISWHITE(cmdbase[2]))
  	    {
  		cmdbase = skipwhite(cmdbase + 2);
  		flags = CREATE_NO_WINDOW;
*** ../vim-8.0.0451/src/quickfix.c	2017-03-05 17:43:10.624245543 +0100
--- src/quickfix.c	2017-03-12 19:47:01.534213411 +0100
***************
*** 2608,2614 ****
  	{
  	    buf[i] = ' ';
  	    while (*++p != NUL)
! 		if (!vim_iswhite(*p) && *p != '\n')
  		    break;
  	}
  	else
--- 2608,2614 ----
  	{
  	    buf[i] = ' ';
  	    while (*++p != NUL)
! 		if (!VIM_ISWHITE(*p) && *p != '\n')
  		    break;
  	}
  	else
*** ../vim-8.0.0451/src/regexp.c	2017-03-12 19:22:31.764584873 +0100
--- src/regexp.c	2017-03-12 19:47:11.222145059 +0100
***************
*** 4523,4536 ****
  	    break;
  
  	  case WHITE:
! 	    if (!vim_iswhite(c))
  		status = RA_NOMATCH;
  	    else
  		ADVANCE_REGINPUT();
  	    break;
  
  	  case NWHITE:
! 	    if (c == NUL || vim_iswhite(c))
  		status = RA_NOMATCH;
  	    else
  		ADVANCE_REGINPUT();
--- 4523,4536 ----
  	    break;
  
  	  case WHITE:
! 	    if (!VIM_ISWHITE(c))
  		status = RA_NOMATCH;
  	    else
  		ADVANCE_REGINPUT();
  	    break;
  
  	  case NWHITE:
! 	    if (c == NUL || VIM_ISWHITE(c))
  		status = RA_NOMATCH;
  	    else
  		ADVANCE_REGINPUT();
*** ../vim-8.0.0451/src/regexp_nfa.c	2017-03-12 19:22:31.764584873 +0100
--- src/regexp_nfa.c	2017-03-12 19:47:21.098075381 +0100
***************
*** 6351,6362 ****
  		break;
  
  	    case NFA_WHITE:	/*  \s	*/
! 		result = vim_iswhite(curc);
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
  	    case NFA_NWHITE:	/*  \S	*/
! 		result = curc != NUL && !vim_iswhite(curc);
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
--- 6351,6362 ----
  		break;
  
  	    case NFA_WHITE:	/*  \s	*/
! 		result = VIM_ISWHITE(curc);
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
  	    case NFA_NWHITE:	/*  \S	*/
! 		result = curc != NUL && !VIM_ISWHITE(curc);
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
*** ../vim-8.0.0451/src/screen.c	2017-03-12 19:22:31.768584844 +0100
--- src/screen.c	2017-03-12 19:47:32.297996356 +0100
***************
*** 3371,3377 ****
  	if (lcs_trail)
  	{
  	    trailcol = (colnr_T)STRLEN(ptr);
! 	    while (trailcol > (colnr_T)0 && vim_iswhite(ptr[trailcol - 1]))
  		--trailcol;
  	    trailcol += (colnr_T) (ptr - line);
  	}
--- 3371,3377 ----
  	if (lcs_trail)
  	{
  	    trailcol = (colnr_T)STRLEN(ptr);
! 	    while (trailcol > (colnr_T)0 && VIM_ISWHITE(ptr[trailcol - 1]))
  		--trailcol;
  	    trailcol += (colnr_T) (ptr - line);
  	}
***************
*** 4577,4583 ****
  # else
  		    c_extra = ' ';
  # endif
! 		    if (vim_iswhite(c))
  		    {
  #ifdef FEAT_CONCEAL
  			if (c == TAB)
--- 4577,4583 ----
  # else
  		    c_extra = ' ';
  # endif
! 		    if (VIM_ISWHITE(c))
  		    {
  #ifdef FEAT_CONCEAL
  			if (c == TAB)
*** ../vim-8.0.0451/src/search.c	2017-03-12 19:22:31.768584844 +0100
--- src/search.c	2017-03-12 19:47:52.145856304 +0100
***************
*** 3276,3282 ****
      while (decl(posp) != -1)
      {
  	c = gchar_pos(posp);
! 	if (!vim_iswhite(c))
  	{
  	    incl(posp);
  	    break;
--- 3276,3282 ----
      while (decl(posp) != -1)
      {
  	c = gchar_pos(posp);
! 	if (!VIM_ISWHITE(c))
  	{
  	    incl(posp);
  	    break;
***************
*** 3515,3521 ****
  	    while (LT_POS(pos, curwin->w_cursor))
  	    {
  		c = gchar_pos(&pos);
! 		if (!vim_iswhite(c))
  		{
  		    at_start_sent = FALSE;
  		    break;
--- 3515,3521 ----
  	    while (LT_POS(pos, curwin->w_cursor))
  	    {
  		c = gchar_pos(&pos);
! 		if (!VIM_ISWHITE(c))
  		{
  		    at_start_sent = FALSE;
  		    break;
***************
*** 3538,3544 ****
  		if (at_start_sent)
  		    find_first_blank(&curwin->w_cursor);
  		c = gchar_cursor();
! 		if (!at_start_sent || (!include && !vim_iswhite(c)))
  		    findsent(BACKWARD, 1L);
  		at_start_sent = !at_start_sent;
  	    }
--- 3538,3544 ----
  		if (at_start_sent)
  		    find_first_blank(&curwin->w_cursor);
  		c = gchar_cursor();
! 		if (!at_start_sent || (!include && !VIM_ISWHITE(c)))
  		    findsent(BACKWARD, 1L);
  		at_start_sent = !at_start_sent;
  	    }
***************
*** 3561,3567 ****
  		while (LT_POS(pos, curwin->w_cursor))
  		{
  		    c = gchar_pos(&pos);
! 		    if (!vim_iswhite(c))
  		    {
  			at_start_sent = TRUE;
  			break;
--- 3561,3567 ----
  		while (LT_POS(pos, curwin->w_cursor))
  		{
  		    c = gchar_pos(&pos);
! 		    if (!VIM_ISWHITE(c))
  		    {
  			at_start_sent = TRUE;
  			break;
***************
*** 3587,3593 ****
       * If the cursor started on a blank, check if it is just before the start
       * of the next sentence.
       */
!     while (c = gchar_pos(&pos), vim_iswhite(c))	/* vim_iswhite() is a macro */
  	incl(&pos);
      if (EQUAL_POS(pos, curwin->w_cursor))
      {
--- 3587,3593 ----
       * If the cursor started on a blank, check if it is just before the start
       * of the next sentence.
       */
!     while (c = gchar_pos(&pos), VIM_ISWHITE(c))	/* VIM_ISWHITE() is a macro */
  	incl(&pos);
      if (EQUAL_POS(pos, curwin->w_cursor))
      {
***************
*** 3623,3633 ****
  	if (start_blank)
  	{
  	    find_first_blank(&curwin->w_cursor);
! 	    c = gchar_pos(&curwin->w_cursor);	/* vim_iswhite() is a macro */
! 	    if (vim_iswhite(c))
  		decl(&curwin->w_cursor);
  	}
! 	else if (c = gchar_cursor(), !vim_iswhite(c))
  	    find_first_blank(&start_pos);
      }
  
--- 3623,3633 ----
  	if (start_blank)
  	{
  	    find_first_blank(&curwin->w_cursor);
! 	    c = gchar_pos(&curwin->w_cursor);	/* VIM_ISWHITE() is a macro */
! 	    if (VIM_ISWHITE(c))
  		decl(&curwin->w_cursor);
  	}
! 	else if (c = gchar_cursor(), !VIM_ISWHITE(c))
  	    find_first_blank(&start_pos);
      }
  
***************
*** 3974,3980 ****
       */
      inc_cursor();
      p = ml_get_cursor();
!     for (cp = p; *cp != NUL && *cp != '>' && !vim_iswhite(*cp); MB_PTR_ADV(cp))
  	;
      len = (int)(cp - p);
      if (len == 0)
--- 3974,3980 ----
       */
      inc_cursor();
      p = ml_get_cursor();
!     for (cp = p; *cp != NUL && *cp != '>' && !VIM_ISWHITE(*cp); MB_PTR_ADV(cp))
  	;
      len = (int)(cp - p);
      if (len == 0)
***************
*** 4496,4506 ****
       * the starting quote. */
      if (include)
      {
! 	if (vim_iswhite(line[col_end + 1]))
! 	    while (vim_iswhite(line[col_end + 1]))
  		++col_end;
  	else
! 	    while (col_start > 0 && vim_iswhite(line[col_start - 1]))
  		--col_start;
      }
  
--- 4496,4506 ----
       * the starting quote. */
      if (include)
      {
! 	if (VIM_ISWHITE(line[col_end + 1]))
! 	    while (VIM_ISWHITE(line[col_end + 1]))
  		++col_end;
  	else
! 	    while (col_start > 0 && VIM_ISWHITE(line[col_start - 1]))
  		--col_start;
      }
  
*** ../vim-8.0.0451/src/spell.c	2017-03-12 19:22:31.768584844 +0100
--- src/spell.c	2017-03-12 19:48:09.069736877 +0100
***************
*** 4528,4534 ****
  
  	    fword_ends = (fword[sp->ts_fidx] == NUL
  			   || (soundfold
! 			       ? vim_iswhite(fword[sp->ts_fidx])
  			       : !spell_iswordp(fword + sp->ts_fidx, curwin)));
  	    tword[sp->ts_twordlen] = NUL;
  
--- 4528,4534 ----
  
  	    fword_ends = (fword[sp->ts_fidx] == NUL
  			   || (soundfold
! 			       ? VIM_ISWHITE(fword[sp->ts_fidx])
  			       : !spell_iswordp(fword + sp->ts_fidx, curwin)));
  	    tword[sp->ts_twordlen] = NUL;
  
***************
*** 6231,6237 ****
  	 * sounds like "t h" while "the" sounds like "@".  Avoid that by
  	 * removing the space.  Don't do it when the good word also contains a
  	 * space. */
! 	if (vim_iswhite(su->su_badptr[su->su_badlen])
  					 && *skiptowhite(stp->st_word) == NUL)
  	    for (p = fword; *(p = skiptowhite(p)) != NUL; )
  		STRMOVE(p, p + 1);
--- 6231,6237 ----
  	 * sounds like "t h" while "the" sounds like "@".  Avoid that by
  	 * removing the space.  Don't do it when the good word also contains a
  	 * space. */
! 	if (VIM_ISWHITE(su->su_badptr[su->su_badlen])
  					 && *skiptowhite(stp->st_word) == NUL)
  	    for (p = fword; *(p = skiptowhite(p)) != NUL; )
  		STRMOVE(p, p + 1);
***************
*** 7106,7112 ****
  	for (s = inword; *s != NUL; )
  	{
  	    c = mb_cptr2char_adv(&s);
! 	    if (enc_utf8 ? utf_class(c) == 0 : vim_iswhite(c))
  		c = ' ';
  	    else if (c < 256)
  		c = slang->sl_sal_first[c];
--- 7106,7112 ----
  	for (s = inword; *s != NUL; )
  	{
  	    c = mb_cptr2char_adv(&s);
! 	    if (enc_utf8 ? utf_class(c) == 0 : VIM_ISWHITE(c))
  		c = ' ';
  	    else if (c < 256)
  		c = slang->sl_sal_first[c];
***************
*** 7147,7153 ****
  	/* The sl_sal_first[] table contains the translation. */
  	for (s = inword; (c = *s) != NUL; ++s)
  	{
! 	    if (vim_iswhite(c))
  		c = ' ';
  	    else
  		c = slang->sl_sal_first[c];
--- 7147,7153 ----
  	/* The sl_sal_first[] table contains the translation. */
  	for (s = inword; (c = *s) != NUL; ++s)
  	{
! 	    if (VIM_ISWHITE(c))
  		c = ' ';
  	    else
  		c = slang->sl_sal_first[c];
***************
*** 7185,7191 ****
  	t = word;
  	while (*s != NUL)
  	{
! 	    if (vim_iswhite(*s))
  	    {
  		*t++ = ' ';
  		s = skipwhite(s);
--- 7185,7191 ----
  	t = word;
  	while (*s != NUL)
  	{
! 	    if (VIM_ISWHITE(*s))
  	    {
  		*t++ = ' ';
  		s = skipwhite(s);
***************
*** 7409,7415 ****
  		}
  	    }
  	}
! 	else if (vim_iswhite(c))
  	{
  	    c = ' ';
  	    k = 1;
--- 7409,7415 ----
  		}
  	    }
  	}
! 	else if (VIM_ISWHITE(c))
  	{
  	    c = ' ';
  	    k = 1;
***************
*** 7474,7480 ****
  	c = mb_cptr2char_adv(&s);
  	if (slang->sl_rem_accents)
  	{
! 	    if (enc_utf8 ? utf_class(c) == 0 : vim_iswhite(c))
  	    {
  		if (did_white)
  		    continue;
--- 7474,7480 ----
  	c = mb_cptr2char_adv(&s);
  	if (slang->sl_rem_accents)
  	{
! 	    if (enc_utf8 ? utf_class(c) == 0 : VIM_ISWHITE(c))
  	    {
  		if (did_white)
  		    continue;
***************
*** 7715,7721 ****
  		}
  	    }
  	}
! 	else if (vim_iswhite(c))
  	{
  	    c = ' ';
  	    k = 1;
--- 7715,7721 ----
  		}
  	    }
  	}
! 	else if (VIM_ISWHITE(c))
  	{
  	    c = ' ';
  	    k = 1;
*** ../vim-8.0.0451/src/syntax.c	2017-03-12 19:22:31.772584816 +0100
--- src/syntax.c	2017-03-12 19:48:26.453614196 +0100
***************
*** 2308,2314 ****
  	    {
  		line = syn_getcurline();
  		if (((current_next_flags & HL_SKIPWHITE)
! 			    && vim_iswhite(line[current_col]))
  			|| ((current_next_flags & HL_SKIPEMPTY)
  			    && *line == NUL))
  		    break;
--- 2308,2314 ----
  	    {
  		line = syn_getcurline();
  		if (((current_next_flags & HL_SKIPWHITE)
! 			    && VIM_ISWHITE(line[current_col]))
  			|| ((current_next_flags & HL_SKIPEMPTY)
  			    && *line == NUL))
  		    break;
***************
*** 4631,4637 ****
  	    for (i = 0, len = 0; p[i] != NUL; i += 2, ++len)
  		if (arg[len] != p[i] && arg[len] != p[i + 1])
  		    break;
! 	    if (p[i] == NUL && (vim_iswhite(arg[len])
  				    || (flagtab[fidx].argtype > 0
  					 ? arg[len] == '='
  					 : ends_excmd(arg[len]))))
--- 4631,4637 ----
  	    for (i = 0, len = 0; p[i] != NUL; i += 2, ++len)
  		if (arg[len] != p[i] && arg[len] != p[i + 1])
  		    break;
! 	    if (p[i] == NUL && (VIM_ISWHITE(arg[len])
  				    || (flagtab[fidx].argtype > 0
  					 ? arg[len] == '='
  					 : ends_excmd(arg[len]))))
***************
*** 4905,4911 ****
  		if (rest == NULL || ends_excmd(*rest))
  		    break;
  		/* Copy the keyword, removing backslashes, and add a NUL. */
! 		while (*rest != NUL && !vim_iswhite(*rest))
  		{
  		    if (*rest == '\\' && rest[1] != NUL)
  			++rest;
--- 4905,4911 ----
  		if (rest == NULL || ends_excmd(*rest))
  		    break;
  		/* Copy the keyword, removing backslashes, and add a NUL. */
! 		while (*rest != NUL && !VIM_ISWHITE(*rest))
  		{
  		    if (*rest == '\\' && rest[1] != NUL)
  			++rest;
***************
*** 5156,5162 ****
  
  	/* must be a pattern or matchgroup then */
  	key_end = rest;
! 	while (*key_end && !vim_iswhite(*key_end) && *key_end != '=')
  	    ++key_end;
  	vim_free(key);
  	key = vim_strnsave_up(rest, (int)(key_end - rest));
--- 5156,5162 ----
  
  	/* must be a pattern or matchgroup then */
  	key_end = rest;
! 	while (*key_end && !VIM_ISWHITE(*key_end) && *key_end != '=')
  	    ++key_end;
  	vim_free(key);
  	key = vim_strnsave_up(rest, (int)(key_end - rest));
***************
*** 5640,5658 ****
  	for (;;)
  	{
  	    if (STRNICMP(rest, "add", 3) == 0
! 		    && (vim_iswhite(rest[3]) || rest[3] == '='))
  	    {
  		opt_len = 3;
  		list_op = CLUSTER_ADD;
  	    }
  	    else if (STRNICMP(rest, "remove", 6) == 0
! 		    && (vim_iswhite(rest[6]) || rest[6] == '='))
  	    {
  		opt_len = 6;
  		list_op = CLUSTER_SUBTRACT;
  	    }
  	    else if (STRNICMP(rest, "contains", 8) == 0
! 			&& (vim_iswhite(rest[8]) || rest[8] == '='))
  	    {
  		opt_len = 8;
  		list_op = CLUSTER_REPLACE;
--- 5640,5658 ----
  	for (;;)
  	{
  	    if (STRNICMP(rest, "add", 3) == 0
! 		    && (VIM_ISWHITE(rest[3]) || rest[3] == '='))
  	    {
  		opt_len = 3;
  		list_op = CLUSTER_ADD;
  	    }
  	    else if (STRNICMP(rest, "remove", 6) == 0
! 		    && (VIM_ISWHITE(rest[6]) || rest[6] == '='))
  	    {
  		opt_len = 6;
  		list_op = CLUSTER_SUBTRACT;
  	    }
  	    else if (STRNICMP(rest, "contains", 8) == 0
! 			&& (VIM_ISWHITE(rest[8]) || rest[8] == '='))
  	    {
  		opt_len = 8;
  		list_op = CLUSTER_REPLACE;
***************
*** 5793,5799 ****
  	}
      } while (idx >= 0);
  
!     if (!ends_excmd(*end) && !vim_iswhite(*end))
      {
  	EMSG2(_("E402: Garbage after pattern: %s"), arg);
  	return NULL;
--- 5793,5799 ----
  	}
      } while (idx >= 0);
  
!     if (!ends_excmd(*end) && !VIM_ISWHITE(*end))
      {
  	EMSG2(_("E402: Garbage after pattern: %s"), arg);
  	return NULL;
***************
*** 6014,6020 ****
  	count = 0;
  	while (!ends_excmd(*p))
  	{
! 	    for (end = p; *end && !vim_iswhite(*end) && *end != ','; ++end)
  		;
  	    name = alloc((int)(end - p + 3));	    /* leave room for "^$" */
  	    if (name == NULL)
--- 6014,6020 ----
  	count = 0;
  	while (!ends_excmd(*p))
  	{
! 	    for (end = p; *end && !VIM_ISWHITE(*end) && *end != ','; ++end)
  		;
  	    name = alloc((int)(end - p + 3));	    /* leave room for "^$" */
  	    if (name == NULL)
***************
*** 7466,7472 ****
  	 * Isolate the key ("term", "ctermfg", "ctermbg", "font", "guifg" or
  	 * "guibg").
  	 */
! 	while (*linep && !vim_iswhite(*linep) && *linep != '=')
  	    ++linep;
  	vim_free(key);
  	key = vim_strnsave_up(key_start, (int)(linep - key_start));
--- 7466,7472 ----
  	 * Isolate the key ("term", "ctermfg", "ctermbg", "font", "guifg" or
  	 * "guibg").
  	 */
! 	while (*linep && !VIM_ISWHITE(*linep) && *linep != '=')
  	    ++linep;
  	vim_free(key);
  	key = vim_strnsave_up(key_start, (int)(linep - key_start));
***************
*** 9721,9727 ****
  	    attr = 0;
  	    for ( ; *p && *p != ','; ++p)	    /* parse upto comma */
  	    {
! 		if (vim_iswhite(*p))		    /* ignore white space */
  		    continue;
  
  		if (attr > HL_ALL)  /* Combination with ':' is not allowed. */
--- 9721,9727 ----
  	    attr = 0;
  	    for ( ; *p && *p != ','; ++p)	    /* parse upto comma */
  	    {
! 		if (VIM_ISWHITE(*p))		    /* ignore white space */
  		    continue;
  
  		if (attr > HL_ALL)  /* Combination with ':' is not allowed. */
*** ../vim-8.0.0451/src/tag.c	2017-03-12 19:22:31.772584816 +0100
--- src/tag.c	2017-03-12 19:48:37.325537466 +0100
***************
*** 2005,2011 ****
  #endif
  			if (	   fnamencmp(lbuf, tagp.fname, p - lbuf) == 0
  #ifdef FEAT_TAG_ANYWHITE
! 				&& vim_iswhite(tagp.fname[p - lbuf])
  #else
  				&& tagp.fname[p - lbuf] == TAB
  #endif
--- 2005,2011 ----
  #endif
  			if (	   fnamencmp(lbuf, tagp.fname, p - lbuf) == 0
  #ifdef FEAT_TAG_ANYWHITE
! 				&& VIM_ISWHITE(tagp.fname[p - lbuf])
  #else
  				&& tagp.fname[p - lbuf] == TAB
  #endif
***************
*** 3932,3938 ****
  		    else if (STRNCMP(p, "file:", 5) == 0)
  			/* skip "file:" (static tag) */
  			p += 4;
! 		    else if (!vim_iswhite(*p))
  		    {
  			char_u	*s, *n;
  			int	len;
--- 3932,3938 ----
  		    else if (STRNCMP(p, "file:", 5) == 0)
  			/* skip "file:" (static tag) */
  			p += 4;
! 		    else if (!VIM_ISWHITE(*p))
  		    {
  			char_u	*s, *n;
  			int	len;
*** ../vim-8.0.0451/src/userfunc.c	2017-02-02 22:59:22.583226973 +0100
--- src/userfunc.c	2017-03-12 19:48:45.981476374 +0100
***************
*** 2104,2110 ****
  	else
  	{
  	    /* skip ':' and blanks*/
! 	    for (p = theline; vim_iswhite(*p) || *p == ':'; ++p)
  		;
  
  	    /* Check for "endfunction". */
--- 2104,2110 ----
  	else
  	{
  	    /* skip ':' and blanks*/
! 	    for (p = theline; VIM_ISWHITE(*p) || *p == ':'; ++p)
  		;
  
  	    /* Check for "endfunction". */
*** ../vim-8.0.0451/src/version.c	2017-03-12 19:22:31.772584816 +0100
--- src/version.c	2017-03-12 20:06:05.106128862 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     452,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
102. When filling out your driver's license application, you give
     your IP address.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0453
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0453
Problem:    Adding fold marker creates new comment.
Solution:   Use an existing comment if possible. (LemonBoy, closes #1549)
Files:      src/ops.c, src/proto/ops.pro, src/fold.c,
            src/testdir/test_fold.vim


*** ../vim-8.0.0452/src/ops.c	2017-03-12 20:09:59.480468291 +0100
--- src/ops.c	2017-03-12 20:19:41.504340010 +0100
***************
*** 113,121 ****
  static void	may_set_selection(void);
  #endif
  static void	dis_msg(char_u *p, int skip_esc);
- #if defined(FEAT_COMMENTS) || defined(PROTO)
- static char_u	*skip_comment(char_u *line, int process, int include_space, int *is_comment);
- #endif
  static void	block_prep(oparg_T *oap, struct block_def *, linenr_T, int);
  static int	do_addsub(int op_type, pos_T *pos, int length, linenr_T Prenum1);
  #if defined(FEAT_CLIPBOARD) || defined(FEAT_EVAL)
--- 113,118 ----
***************
*** 4301,4307 ****
   * is_comment - will indicate whether the current line ends with an unclosed
   *		comment.
   */
!     static char_u *
  skip_comment(
      char_u   *line,
      int      process,
--- 4298,4304 ----
   * is_comment - will indicate whether the current line ends with an unclosed
   *		comment.
   */
!     char_u *
  skip_comment(
      char_u   *line,
      int      process,
*** ../vim-8.0.0452/src/proto/ops.pro	2017-02-04 21:34:27.293529871 +0100
--- src/proto/ops.pro	2017-03-12 20:19:28.520432171 +0100
***************
*** 38,43 ****
--- 38,44 ----
  int preprocs_left(void);
  int get_register_name(int num);
  void ex_display(exarg_T *eap);
+ char_u *skip_comment(char_u *line, int process, int include_space, int *is_comment);
  int do_join(long count, int insert_space, int save_undo, int use_formatoptions, int setmark);
  void op_format(oparg_T *oap, int keep_cursor);
  void op_formatexpr(oparg_T *oap);
*** ../vim-8.0.0452/src/fold.c	2017-03-12 20:09:59.460468432 +0100
--- src/fold.c	2017-03-12 20:20:32.459978294 +0100
***************
*** 1760,1765 ****
--- 1760,1766 ----
      int		line_len;
      char_u	*newline;
      char_u	*p = (char_u *)strstr((char *)curbuf->b_p_cms, "%s");
+     int		line_is_comment = FALSE;
  
      /* Allocate a new line: old-line + 'cms'-start + marker + 'cms'-end */
      line = ml_get(lnum);
***************
*** 1767,1777 ****
  
      if (u_save(lnum - 1, lnum + 1) == OK)
      {
  	newline = alloc((unsigned)(line_len + markerlen + STRLEN(cms) + 1));
  	if (newline == NULL)
  	    return;
  	STRCPY(newline, line);
! 	if (p == NULL)
  	    vim_strncpy(newline + line_len, marker, markerlen);
  	else
  	{
--- 1768,1783 ----
  
      if (u_save(lnum - 1, lnum + 1) == OK)
      {
+ #if defined(FEAT_COMMENTS)
+ 	/* Check if the line ends with an unclosed comment */
+ 	(void)skip_comment(line, FALSE, FALSE, &line_is_comment);
+ #endif
  	newline = alloc((unsigned)(line_len + markerlen + STRLEN(cms) + 1));
  	if (newline == NULL)
  	    return;
  	STRCPY(newline, line);
! 	/* Append the marker to the end of the line */
! 	if (p == NULL || line_is_comment)
  	    vim_strncpy(newline + line_len, marker, markerlen);
  	else
  	{
*** ../vim-8.0.0452/src/testdir/test_fold.vim	2017-03-04 18:42:35.719691735 +0100
--- src/testdir/test_fold.vim	2017-03-12 20:20:44.139895375 +0100
***************
*** 168,173 ****
--- 168,189 ----
    bwipe!
  endfunc
  
+ func Test_folds_marker_in_comment()
+   new
+   call setline(1, ['" foo', 'bar', 'baz'])
+   setl fen fdm=marker
+   setl com=sO:\"\ -,mO:\"\ \ ,eO:\"\",:\" cms=\"%s
+   norm! zf2j
+   setl nofen
+   :1y
+   call assert_equal(['" foo{{{'], getreg(0,1,1))
+   :+2y
+   call assert_equal(['baz"}}}'], getreg(0,1,1))
+ 
+   set foldmethod&
+   bwipe!
+ endfunc
+ 
  func s:TestFoldExpr(lnum)
    let thisline = getline(a:lnum)
    if thisline == 'a'
*** ../vim-8.0.0452/src/version.c	2017-03-12 20:09:59.492468205 +0100
--- src/version.c	2017-03-12 20:21:56.931378565 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     453,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
103. When you find yourself in the "Computer" section of Barnes & Noble
     enjoying yourself.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0454
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0454
Problem:    Compiler warnings for comparing unsigned char with 256 always
            being true. (Manuel Ortega)
Solution:   Add type cast.
Files:      src/screen.c, src/charset.c


*** ../vim-8.0.0453/src/screen.c	2017-03-12 20:09:59.488468234 +0100
--- src/screen.c	2017-03-12 21:25:45.076533153 +0100
***************
*** 4554,4560 ****
  		 * Found last space before word: check for line break.
  		 */
  		if (wp->w_p_lbr && c0 == c
! 				      && VIM_ISBREAK(c) && !VIM_ISBREAK(*ptr))
  		{
  # ifdef FEAT_MBYTE
  		    int mb_off = has_mbyte ? (*mb_head_off)(line, ptr - 1) : 0;
--- 4554,4560 ----
  		 * Found last space before word: check for line break.
  		 */
  		if (wp->w_p_lbr && c0 == c
! 				  && VIM_ISBREAK(c) && !VIM_ISBREAK((int)*ptr))
  		{
  # ifdef FEAT_MBYTE
  		    int mb_off = has_mbyte ? (*mb_head_off)(line, ptr - 1) : 0;
*** ../vim-8.0.0453/src/charset.c	2017-03-12 20:09:59.460468432 +0100
--- src/charset.c	2017-03-12 21:28:28.355379917 +0100
***************
*** 1090,1096 ****
       */
      if (wp->w_p_lbr
  	    && VIM_ISBREAK(c)
! 	    && !VIM_ISBREAK(s[1])
  	    && wp->w_p_wrap
  # ifdef FEAT_WINDOWS
  	    && wp->w_width != 0
--- 1090,1096 ----
       */
      if (wp->w_p_lbr
  	    && VIM_ISBREAK(c)
! 	    && !VIM_ISBREAK((int)s[1])
  	    && wp->w_p_wrap
  # ifdef FEAT_WINDOWS
  	    && wp->w_width != 0
***************
*** 1120,1126 ****
  	    if (!(c != NUL
  		    && (VIM_ISBREAK(c)
  			|| (!VIM_ISBREAK(c)
! 			    && (col2 == col || !VIM_ISBREAK(*ps))))))
  		break;
  
  	    col2 += win_chartabsize(wp, s, col2);
--- 1120,1126 ----
  	    if (!(c != NUL
  		    && (VIM_ISBREAK(c)
  			|| (!VIM_ISBREAK(c)
! 			    && (col2 == col || !VIM_ISBREAK((int)*ps))))))
  		break;
  
  	    col2 += win_chartabsize(wp, s, col2);
*** ../vim-8.0.0453/src/version.c	2017-03-12 20:37:16.836943099 +0100
--- src/version.c	2017-03-12 21:29:05.263119204 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     454,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
105. When someone asks you for your address, you tell them your URL.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0455
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0455
Problem:    The mode test may hang in Test_mode(). (Michael Soyka)
Solution:   Set 'complete' to only search the current buffer (as suggested by
            Michael)
Files:      src/testdir/test_functions.vim


*** ../vim-8.0.0454/src/testdir/test_functions.vim	2017-03-09 12:09:27.188601005 +0100
--- src/testdir/test_functions.vim	2017-03-13 20:32:34.603704490 +0100
***************
*** 313,327 ****
  
  " Tests for the mode() function
  let current_modes = ''
! func! Save_mode()
    let g:current_modes = mode(0) . '-' . mode(1)
    return ''
  endfunc
  
! func! Test_mode()
    new
    call append(0, ["Blue Ball Black", "Brown Band Bowl", ""])
  
    inoremap <F2> <C-R>=Save_mode()<CR>
  
    normal! 3G
--- 313,330 ----
  
  " Tests for the mode() function
  let current_modes = ''
! func Save_mode()
    let g:current_modes = mode(0) . '-' . mode(1)
    return ''
  endfunc
  
! func Test_mode()
    new
    call append(0, ["Blue Ball Black", "Brown Band Bowl", ""])
  
+   " Only complete from the current buffer.
+   set complete=.
+ 
    inoremap <F2> <C-R>=Save_mode()<CR>
  
    normal! 3G
***************
*** 430,435 ****
--- 433,439 ----
  
    bwipe!
    iunmap <F2>
+   set complete&
  endfunc
  
  func Test_getbufvar()
*** ../vim-8.0.0454/src/version.c	2017-03-12 21:31:54.289925047 +0100
--- src/version.c	2017-03-13 20:33:43.347225643 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     455,
  /**/

-- 
In a world without walls and borders, who needs windows and gates?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0456
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0456
Problem:    Typo in MinGW test makefile.
Solution:   Change an underscore to a dot. (Michael Soyka)
Files:      src/testdir/Make_ming.mak


*** ../vim-8.0.0455/src/testdir/Make_ming.mak	2017-03-12 17:10:14.417925081 +0100
--- src/testdir/Make_ming.mak	2017-03-13 22:39:41.677563010 +0100
***************
*** 129,135 ****
  
  test_gui_init.res: test_gui_init.vim
  	@echo "$(VIMPROG)" > vimcmd
! 	$(VIMPROG) -u gui_preinit_vim -U gui_init.vim $(NO_PLUGINS) -S runtest.vim $<
  	@$(DEL) vimcmd
  
  opt_test.vim: ../option.c gen_opt_test.vim
--- 129,135 ----
  
  test_gui_init.res: test_gui_init.vim
  	@echo "$(VIMPROG)" > vimcmd
! 	$(VIMPROG) -u gui_preinit.vim -U gui_init.vim $(NO_PLUGINS) -S runtest.vim $<
  	@$(DEL) vimcmd
  
  opt_test.vim: ../option.c gen_opt_test.vim
*** ../vim-8.0.0455/src/version.c	2017-03-13 20:37:11.445776655 +0100
--- src/version.c	2017-03-13 22:40:38.393155148 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     456,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
118. You are on a first-name basis with your ISP's staff.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0457
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0457
Problem:    Using :move messes up manual folds.
Solution:   Split adjusting marks and folds.  Add foldMoveRange(). (neovim
            patch #6221)
Files:      src/ex_cmds.c, src/fold.c, src/mark.c, src/proto/fold.pro,
            src/proto/mark.pro src/testdir/test_fold.vim


*** ../vim-8.0.0456/src/ex_cmds.c	2017-03-12 20:09:59.468468376 +0100
--- src/ex_cmds.c	2017-03-14 21:38:54.972614770 +0100
***************
*** 800,805 ****
--- 800,807 ----
      linenr_T	last_line;  /* Last line in file after adding new text */
  #ifdef FEAT_FOLDING
      int		isFolded;
+     win_T	*win;
+     tabpage_T	*tp;
  
      /* Moving lines seems to corrupt the folds, delete folding info now
       * and recreate it when finished.  Don't do this for manual folding, it
***************
*** 851,874 ****
       * their final destination at the new text position -- webb
       */
      last_line = curbuf->b_ml.ml_line_count;
!     mark_adjust(line1, line2, last_line - line2, 0L);
!     changed_lines(last_line - num_lines + 1, 0, last_line + 1, num_lines);
      if (dest >= line2)
      {
! 	mark_adjust(line2 + 1, dest, -num_lines, 0L);
  	curbuf->b_op_start.lnum = dest - num_lines + 1;
  	curbuf->b_op_end.lnum = dest;
      }
      else
      {
! 	mark_adjust(dest + 1, line1 - 1, num_lines, 0L);
  	curbuf->b_op_start.lnum = dest + 1;
  	curbuf->b_op_end.lnum = dest + num_lines;
      }
      curbuf->b_op_start.col = curbuf->b_op_end.col = 0;
!     mark_adjust(last_line - num_lines + 1, last_line,
  					     -(last_line - dest - extra), 0L);
-     changed_lines(last_line - num_lines + 1, 0, last_line + 1, -extra);
  
      /*
       * Now we delete the original text -- webb
--- 853,886 ----
       * their final destination at the new text position -- webb
       */
      last_line = curbuf->b_ml.ml_line_count;
!     mark_adjust_nofold(line1, line2, last_line - line2, 0L);
      if (dest >= line2)
      {
! 	mark_adjust_nofold(line2 + 1, dest, -num_lines, 0L);
! #ifdef FEAT_FOLDING
! 	FOR_ALL_TAB_WINDOWS(tp, win) {
! 	    if (win->w_buffer == curbuf)
! 		foldMoveRange(&win->w_folds, line1, line2, dest);
! 	}
! #endif
  	curbuf->b_op_start.lnum = dest - num_lines + 1;
  	curbuf->b_op_end.lnum = dest;
      }
      else
      {
! 	mark_adjust_nofold(dest + 1, line1 - 1, num_lines, 0L);
! #ifdef FEAT_FOLDING
! 	FOR_ALL_TAB_WINDOWS(tp, win) {
! 	    if (win->w_buffer == curbuf)
! 		foldMoveRange(&win->w_folds, dest + 1, line1 - 1, line2);
! 	}
! #endif
  	curbuf->b_op_start.lnum = dest + 1;
  	curbuf->b_op_end.lnum = dest + num_lines;
      }
      curbuf->b_op_start.col = curbuf->b_op_end.col = 0;
!     mark_adjust_nofold(last_line - num_lines + 1, last_line,
  					     -(last_line - dest - extra), 0L);
  
      /*
       * Now we delete the original text -- webb
*** ../vim-8.0.0456/src/fold.c	2017-03-12 20:37:16.836943099 +0100
--- src/fold.c	2017-03-14 21:46:10.709460056 +0100
***************
*** 64,69 ****
--- 64,70 ----
  static void foldDelMarker(linenr_T lnum, char_u *marker, int markerlen);
  static void foldUpdateIEMS(win_T *wp, linenr_T top, linenr_T bot);
  static void parseMarker(win_T *wp);
+ static void foldMoveRange_int(garray_T *gap, linenr_T line1, linenr_T line2, linenr_T dest);
  
  static char *e_nofold = N_("E490: No fold found");
  
***************
*** 1075,1080 ****
--- 1076,1087 ----
      (void)hasFolding(curwin->w_cursor.lnum, &curwin->w_cursor.lnum, NULL);
  }
  
+ /* foldMoveRange() {{{2 */
+     void
+ foldMoveRange(garray_T *gap, linenr_T line1, linenr_T line2, linenr_T dest)
+ {
+     foldMoveRange_int(gap, line1, line2, dest);
+ }
  /* Internal functions for "fold_T" {{{1 */
  /* cloneFoldGrowArray() {{{2 */
  /*
***************
*** 2968,2973 ****
--- 2975,3156 ----
      }
  }
  
+ /* foldReverseOrder() {{{2 */
+     static void
+ foldReverseOrder(garray_T *gap, linenr_T start, linenr_T end)
+ {
+     fold_T *left, *right;
+     fold_T tmp;
+ 
+     for (; start < end; start++, end--)
+     {
+ 	left = (fold_T *)gap->ga_data + start;
+ 	right = (fold_T *)gap->ga_data + end;
+ 	tmp  = *left;
+ 	*left = *right;
+ 	*right = tmp;
+     }
+ }
+ 
+ /* foldMoveRange_int() {{{2 */
+ /*
+  * Move folds within the inclusive range "line1" to "line2" to after "dest"
+  * requires "line1" <= "line2" <= "dest"
+  *
+  * There are the following situations for the first fold at or below line1 - 1.
+  *       1  2  3  4
+  *       1  2  3  4
+  * line1    2  3  4
+  *          2  3  4  5  6  7
+  * line2       3  4  5  6  7
+  *             3  4     6  7  8  9
+  * dest           4        7  8  9
+  *                4        7  8    10
+  *                4        7  8    10
+  *
+  * In the following descriptions, "moved" means moving in the buffer, *and* in
+  * the fold array.
+  * Meanwhile, "shifted" just means moving in the buffer.
+  * 1. not changed
+  * 2. truncated above line1
+  * 3. length reduced by  line2 - line1, folds starting between the end of 3 and
+  *    dest are truncated and shifted up
+  * 4. internal folds moved (from [line1, line2] to dest)
+  * 5. moved to dest.
+  * 6. truncated below line2 and moved.
+  * 7. length reduced by line2 - dest, folds starting between line2 and dest are
+  *    removed, top is moved down by move_len.
+  * 8. truncated below dest and shifted up.
+  * 9. shifted up
+  * 10. not changed
+  */
+ 
+     static void
+ truncate_fold(fold_T *fp, linenr_T end)
+ {
+     foldRemove(&fp->fd_nested, end - fp->fd_top, MAXLNUM);
+     fp->fd_len = end - fp->fd_top + 1;
+ }
+ 
+ #define fold_end(fp) ((fp)->fd_top + (fp)->fd_len - 1)
+ #define valid_fold(fp, gap) ((fp) < ((fold_T *)(gap)->ga_data + (gap)->ga_len))
+ #define fold_index(fp, gap) ((size_t)(fp - ((fold_T *)(gap)->ga_data)))
+ 
+     static void
+ foldMoveRange_int(garray_T *gap, linenr_T line1, linenr_T line2, linenr_T dest)
+ {
+     fold_T *fp;
+     linenr_T range_len = line2 - line1 + 1;
+     linenr_T move_len = dest - line2;
+     int at_start = foldFind(gap, line1 - 1, &fp);
+     size_t move_start = 0, move_end = 0, dest_index = 0;
+ 
+     if (at_start)
+     {
+ 	if (fold_end(fp) > dest)
+ 	{
+ 	    /* Case 4
+ 	    * don't have to change this fold, but have to move nested folds.
+ 	    */
+ 	    foldMoveRange(&fp->fd_nested, line1 - fp->fd_top, line2 -
+ 		    fp->fd_top, dest - fp->fd_top);
+ 	    return;
+ 	}
+ 	else if (fold_end(fp) > line2)
+ 	{
+ 	    /* Case 3
+ 	     * Remove nested folds between line1 and line2 & reduce the
+ 	     * length of fold by "range_len".
+ 	     * Folds after this one must be dealt with.
+ 	     */
+ 	    foldMarkAdjustRecurse(&fp->fd_nested, line1 - fp->fd_top, line2 -
+ 		    fp->fd_top, MAXLNUM, -range_len);
+ 	    fp->fd_len -= range_len;
+ 	}
+ 	else
+ 	    /* Case 2 truncate fold, folds after this one must be dealt with. */
+ 	    truncate_fold(fp, line1);
+ 
+ 	/* Look at the next fold, and treat that one as if it were the first
+ 	 * after  "line1" (because now it is). */
+ 	fp = fp + 1;
+     }
+ 
+     if (!valid_fold(fp, gap) || fp->fd_top > dest)
+     {
+ 	/* Case 10
+ 	 * No folds after "line1" and before "dest"
+ 	 */
+ 	return;
+     }
+     else if (fp->fd_top > line2)
+     {
+ 	for (; valid_fold(fp, gap) && fold_end(fp) < dest; fp++)
+ 	/* Case 9. (for all case 9's) -- shift up. */
+ 	    fp->fd_top -= range_len;
+ 
+ 	if (valid_fold(fp, gap) && fp->fd_top < dest)
+ 	{
+ 	    /* Case 8. -- ensure truncated at dest, shift up */
+ 	    truncate_fold(fp, dest);
+ 	    fp->fd_top -= range_len;
+ 	}
+ 	return;
+     }
+     else if (fold_end(fp) > dest)
+     {
+ 	/* Case 7 -- remove nested folds and shrink */
+ 	foldMarkAdjustRecurse(&fp->fd_nested, line2 + 1 - fp->fd_top, dest -
+ 		fp->fd_top, MAXLNUM, -move_len);
+ 	fp->fd_len -= move_len;
+ 	fp->fd_top += move_len;
+ 	return;
+     }
+ 
+     /* Case 5 or 6
+      * changes rely on whether there are folds between the end of 
+      * this fold and "dest".
+      */
+     move_start = fold_index(fp, gap);
+ 
+     for (; valid_fold(fp, gap) && fp->fd_top <= dest; fp++)
+     {
+ 	if (fp->fd_top <= line2)
+ 	{
+ 	    /* 1. 2. or 3. */
+ 	    if (fold_end(fp) > line2)
+ 		/* 2. or 3., truncate before moving */
+ 		truncate_fold(fp, line2);
+ 
+ 	    fp->fd_top += move_len;
+ 	    continue;
+ 	}
+ 
+ 	/* Record index of the first fold after the moved range. */
+ 	if (move_end == 0)
+ 	    move_end = fold_index(fp, gap);
+ 
+ 	if (fold_end(fp) > dest)
+ 	    truncate_fold(fp, dest);
+ 
+ 	fp->fd_top -= range_len;
+     }
+ 
+     dest_index = fold_index(fp, gap);
+ 
+     /*
+      * All folds are now correct, but they are not necessarily in the correct
+      * order. We have to swap folds in the range [move_end, dest_index) with
+      * those in the range [move_start, move_end).
+      */
+     foldReverseOrder(gap, move_start, dest_index - 1);
+     foldReverseOrder(gap, move_start, move_start + dest_index - move_end - 1);
+     foldReverseOrder(gap, move_start + dest_index - move_end, dest_index - 1);
+ }
+ #undef fold_end
+ #undef valid_fold
+ #undef fold_index
+ 
  /* foldMerge() {{{2 */
  /*
   * Merge two adjacent folds (and the nested ones in them).
*** ../vim-8.0.0456/src/mark.c	2017-03-12 19:22:31.756584930 +0100
--- src/mark.c	2017-03-14 21:38:04.956977247 +0100
***************
*** 37,42 ****
--- 37,44 ----
  #ifdef FEAT_VIMINFO
  static void write_one_filemark(FILE *fp, xfmark_T *fm, int c1, int c2);
  #endif
+ static void mark_adjust_internal(linenr_T line1, linenr_T line2, long amount,
+     long amount_after, int adjust_folds);
  
  /*
   * Set named mark "c" at current cursor position.
***************
*** 1029,1034 ****
--- 1031,1057 ----
      long	amount,
      long	amount_after)
  {
+     mark_adjust_internal(line1, line2, amount, amount_after, TRUE);
+ }
+ 
+     void
+ mark_adjust_nofold(
+     linenr_T line1,
+     linenr_T line2,
+     long amount,
+     long amount_after)
+ {
+     mark_adjust_internal(line1, line2, amount, amount_after, FALSE);
+ }
+ 
+     static void
+ mark_adjust_internal(
+     linenr_T line1,
+     linenr_T line2,
+     long amount,
+     long amount_after,
+     int adjust_folds UNUSED)
+ {
      int		i;
      int		fnum = curbuf->b_fnum;
      linenr_T	*lp;
***************
*** 1174,1180 ****
  
  #ifdef FEAT_FOLDING
  	    /* adjust folds */
! 	    foldMarkAdjust(win, line1, line2, amount, amount_after);
  #endif
  	}
      }
--- 1197,1204 ----
  
  #ifdef FEAT_FOLDING
  	    /* adjust folds */
! 	    if (adjust_folds)
! 		foldMarkAdjust(win, line1, line2, amount, amount_after);
  #endif
  	}
      }
*** ../vim-8.0.0456/src/proto/fold.pro	2016-09-12 13:04:04.000000000 +0200
--- src/proto/fold.pro	2017-03-14 21:38:04.956977247 +0100
***************
*** 31,36 ****
--- 31,37 ----
  int find_wl_entry(win_T *win, linenr_T lnum);
  void foldAdjustVisual(void);
  void foldAdjustCursor(void);
+ void foldMoveRange(garray_T *gap, linenr_T line1, linenr_T line2, linenr_T dest);
  void cloneFoldGrowArray(garray_T *from, garray_T *to);
  void deleteFoldRecurse(garray_T *gap);
  void foldMarkAdjust(win_T *wp, linenr_T line1, linenr_T line2, long amount, long amount_after);
*** ../vim-8.0.0456/src/proto/mark.pro	2016-09-12 13:04:10.000000000 +0200
--- src/proto/mark.pro	2017-03-14 21:38:04.956977247 +0100
***************
*** 19,24 ****
--- 19,25 ----
  void ex_clearjumps(exarg_T *eap);
  void ex_changes(exarg_T *eap);
  void mark_adjust(linenr_T line1, linenr_T line2, long amount, long amount_after);
+ void mark_adjust_nofold(linenr_T line1, linenr_T line2, long amount, long amount_after);
  void mark_col_adjust(linenr_T lnum, colnr_T mincol, long lnum_amount, long col_amount);
  void copy_jumplist(win_T *from, win_T *to);
  void free_jumplist(win_T *wp);
*** ../vim-8.0.0456/src/testdir/test_fold.vim	2017-03-12 20:37:16.836943099 +0100
--- src/testdir/test_fold.vim	2017-03-14 21:33:43.970869978 +0100
***************
*** 1,5 ****
--- 1,9 ----
  " Test for folding
  
+ func! PrepIndent(arg)
+   return [a:arg] + repeat(["\t".a:arg], 5)
+ endfu
+ 
  func! Test_address_fold()
    new
    call setline(1, ['int FuncName() {/*{{{*/', 1, 2, 3, 4, 5, '}/*}}}*/',
***************
*** 219,221 ****
--- 223,343 ----
    bwipe!
    set foldmethod& foldexpr&
  endfunc
+ 
+ func! Test_move_folds_around_manual()
+   new
+   let input = PrepIndent("a") + PrepIndent("b") + PrepIndent("c")
+   call setline(1, PrepIndent("a") + PrepIndent("b") + PrepIndent("c"))
+   let folds=[-1, 2, 2, 2, 2, 2, -1, 8, 8, 8, 8, 8, -1, 14, 14, 14, 14, 14]
+   " all folds closed
+   set foldenable foldlevel=0 fdm=indent
+   " needs a forced redraw
+   redraw!
+   set fdm=manual
+   call assert_equal(folds, map(range(1, line('$')), 'foldclosed(v:val)'))
+   call assert_equal(input, getline(1, '$'))
+   7,12m0
+   call assert_equal(PrepIndent("b") + PrepIndent("a") + PrepIndent("c"), getline(1, '$'))
+   call assert_equal(folds, map(range(1, line('$')), 'foldclosed(v:val)'))
+   10,12m0
+   call assert_equal(PrepIndent("a")[1:] + PrepIndent("b") + ["a"] +  PrepIndent("c"), getline(1, '$'))
+   call assert_equal([1, 1, 1, 1, 1, -1, 7, 7, 7, 7, 7, -1, -1, 14, 14, 14, 14, 14], map(range(1, line('$')), 'foldclosed(v:val)'))
+   " moving should not close the folds
+   %d
+   call setline(1, PrepIndent("a") + PrepIndent("b") + PrepIndent("c"))
+   set fdm=indent
+   redraw!
+   set fdm=manual
+   call cursor(2, 1)
+   norm! zR
+   7,12m0
+   let folds=repeat([-1], 18)
+   call assert_equal(PrepIndent("b") + PrepIndent("a") + PrepIndent("c"), getline(1, '$'))
+   call assert_equal(folds, map(range(1, line('$')), 'foldclosed(v:val)'))
+   norm! zM
+   " folds are not corrupted and all have been closed
+   call assert_equal([-1, 2, 2, 2, 2, 2, -1, 8, 8, 8, 8, 8, -1, 14, 14, 14, 14, 14], map(range(1, line('$')), 'foldclosed(v:val)'))
+   %d
+   call setline(1, ["a", "\tb", "\tc", "\td", "\te"])
+   set fdm=indent
+   redraw!
+   set fdm=manual
+   %foldopen
+   3m4
+   %foldclose
+   call assert_equal(["a", "\tb", "\td", "\tc", "\te"], getline(1, '$'))
+   call assert_equal([-1, 5, 5, 5, 5], map(range(1, line('$')), 'foldclosedend(v:val)'))
+   %d
+   call setline(1, ["a", "\tb", "\tc", "\td", "\te", "z", "\ty", "\tx", "\tw", "\tv"])
+   set fdm=indent foldlevel=0
+   set fdm=manual
+   %foldopen
+   3m1
+   %foldclose
+   call assert_equal(["a", "\tc", "\tb", "\td", "\te", "z", "\ty", "\tx", "\tw", "\tv"], getline(1, '$'))
+   call assert_equal(0, foldlevel(2))
+   call assert_equal(5, foldclosedend(3))
+   call assert_equal([-1, -1, 3, 3, 3, -1, 7, 7, 7, 7], map(range(1, line('$')), 'foldclosed(v:val)'))
+   2,6m$
+   %foldclose
+   call assert_equal(5, foldclosedend(2))
+   call assert_equal(0, foldlevel(6))
+   call assert_equal(9, foldclosedend(7))
+   call assert_equal([-1, 2, 2, 2, 2, -1, 7, 7, 7, -1], map(range(1, line('$')), 'foldclosed(v:val)'))
+   bw!
+ endfunc
+ 
+ func! Test_move_folds_around_indent()
+   new
+   let input = PrepIndent("a") + PrepIndent("b") + PrepIndent("c")
+   call setline(1, PrepIndent("a") + PrepIndent("b") + PrepIndent("c"))
+   let folds=[-1, 2, 2, 2, 2, 2, -1, 8, 8, 8, 8, 8, -1, 14, 14, 14, 14, 14]
+   " all folds closed
+   set fdm=indent
+   call assert_equal(folds, map(range(1, line('$')), 'foldclosed(v:val)'))
+   call assert_equal(input, getline(1, '$'))
+   7,12m0
+   call assert_equal(PrepIndent("b") + PrepIndent("a") + PrepIndent("c"), getline(1, '$'))
+   call assert_equal(folds, map(range(1, line('$')), 'foldclosed(v:val)'))
+   10,12m0
+   call assert_equal(PrepIndent("a")[1:] + PrepIndent("b") + ["a"] +  PrepIndent("c"), getline(1, '$'))
+   call assert_equal([1, 1, 1, 1, 1, -1, 7, 7, 7, 7, 7, -1, -1, 14, 14, 14, 14, 14], map(range(1, line('$')), 'foldclosed(v:val)'))
+   " moving should not close the folds
+   %d
+   call setline(1, PrepIndent("a") + PrepIndent("b") + PrepIndent("c"))
+   set fdm=indent
+   call cursor(2, 1)
+   norm! zR
+   7,12m0
+   let folds=repeat([-1], 18)
+   call assert_equal(PrepIndent("b") + PrepIndent("a") + PrepIndent("c"), getline(1, '$'))
+   call assert_equal(folds, map(range(1, line('$')), 'foldclosed(v:val)'))
+   norm! zM
+   " folds are not corrupted and all have been closed
+   call assert_equal([-1, 2, 2, 2, 2, 2, -1, 8, 8, 8, 8, 8, -1, 14, 14, 14, 14, 14], map(range(1, line('$')), 'foldclosed(v:val)'))
+   %d
+   call setline(1, ["a", "\tb", "\tc", "\td", "\te"])
+   set fdm=indent
+   %foldopen
+   3m4
+   %foldclose
+   call assert_equal(["a", "\tb", "\td", "\tc", "\te"], getline(1, '$'))
+   call assert_equal([-1, 5, 5, 5, 5], map(range(1, line('$')), 'foldclosedend(v:val)'))
+   %d
+   call setline(1, ["a", "\tb", "\tc", "\td", "\te", "z", "\ty", "\tx", "\tw", "\tv"])
+   set fdm=indent foldlevel=0
+   %foldopen
+   3m1
+   %foldclose
+   call assert_equal(["a", "\tc", "\tb", "\td", "\te", "z", "\ty", "\tx", "\tw", "\tv"], getline(1, '$'))
+   call assert_equal(1, foldlevel(2))
+   call assert_equal(5, foldclosedend(3))
+   call assert_equal([-1, 2, 2, 2, 2, -1, 7, 7, 7, 7], map(range(1, line('$')), 'foldclosed(v:val)'))
+   2,6m$
+   %foldclose
+   call assert_equal(9, foldclosedend(2))
+   call assert_equal(1, foldlevel(6))
+   call assert_equal(9, foldclosedend(7))
+   call assert_equal([-1, 2, 2, 2, 2, 2, 2, 2, 2, -1], map(range(1, line('$')), 'foldclosed(v:val)'))
+   bw!
+ endfunc
*** ../vim-8.0.0456/src/version.c	2017-03-13 22:41:38.376723909 +0100
--- src/version.c	2017-03-14 21:37:42.305141436 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     457,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
123. You ask the car dealer to install an extra cigarette lighter
     on your new car to power your notebook.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0458
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0458
Problem:    Potential crash if adding list or dict to dict fails.
Solution:   Make sure the reference count is correct. (Nikolai Pavlov, closes
            #1555)
Files:      src/dict.c


*** ../vim-8.0.0457/src/dict.c	2017-02-25 14:59:29.898090477 +0100
--- src/dict.c	2017-03-14 22:09:48.527007348 +0100
***************
*** 356,367 ****
      item->di_tv.v_lock = 0;
      item->di_tv.v_type = VAR_LIST;
      item->di_tv.vval.v_list = list;
      if (dict_add(d, item) == FAIL)
      {
  	dictitem_free(item);
  	return FAIL;
      }
-     ++list->lv_refcount;
      return OK;
  }
  
--- 356,367 ----
      item->di_tv.v_lock = 0;
      item->di_tv.v_type = VAR_LIST;
      item->di_tv.vval.v_list = list;
+     ++list->lv_refcount;
      if (dict_add(d, item) == FAIL)
      {
  	dictitem_free(item);
  	return FAIL;
      }
      return OK;
  }
  
***************
*** 380,391 ****
      item->di_tv.v_lock = 0;
      item->di_tv.v_type = VAR_DICT;
      item->di_tv.vval.v_dict = dict;
      if (dict_add(d, item) == FAIL)
      {
  	dictitem_free(item);
  	return FAIL;
      }
-     ++dict->dv_refcount;
      return OK;
  }
  
--- 380,391 ----
      item->di_tv.v_lock = 0;
      item->di_tv.v_type = VAR_DICT;
      item->di_tv.vval.v_dict = dict;
+     ++dict->dv_refcount;
      if (dict_add(d, item) == FAIL)
      {
  	dictitem_free(item);
  	return FAIL;
      }
      return OK;
  }
  
*** ../vim-8.0.0457/src/version.c	2017-03-14 21:53:54.114075276 +0100
--- src/version.c	2017-03-14 22:11:29.090264816 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     458,
  /**/

-- 
I have a watch cat! Just break in and she'll watch.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0459
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0459 (after 8.0.0457)
Problem:    Old fix for :move messing up folding no longer needed, now that we
            have a proper solution.
Solution:   Revert patch 7.4.700. (Christian Brabandt)
Files:      src/ex_cmds.c


*** ../vim-8.0.0458/src/ex_cmds.c	2017-03-14 21:53:54.110075306 +0100
--- src/ex_cmds.c	2017-03-14 22:33:24.388499490 +0100
***************
*** 799,814 ****
      linenr_T	num_lines;  /* Num lines moved */
      linenr_T	last_line;  /* Last line in file after adding new text */
  #ifdef FEAT_FOLDING
-     int		isFolded;
      win_T	*win;
      tabpage_T	*tp;
- 
-     /* Moving lines seems to corrupt the folds, delete folding info now
-      * and recreate it when finished.  Don't do this for manual folding, it
-      * would delete all folds. */
-     isFolded = hasAnyFolding(curwin) && !foldmethodIsManual(curwin);
-     if (isFolded)
- 	deleteFoldRecurse(&curwin->w_folds);
  #endif
  
      if (dest >= line1 && dest < line2)
--- 799,806 ----
***************
*** 918,929 ****
      else
  	changed_lines(dest + 1, 0, line1 + num_lines, 0L);
  
- #ifdef FEAT_FOLDING
- 	/* recreate folds */
- 	if (isFolded)
- 	    foldUpdateAll(curwin);
- #endif
- 
      return OK;
  }
  
--- 910,915 ----
*** ../vim-8.0.0458/src/version.c	2017-03-14 22:17:10.675745424 +0100
--- src/version.c	2017-03-15 20:44:16.747986112 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     459,
  /**/

-- 
The difference between theory and practice, is that in theory, there
is no difference between theory and practice.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0460
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0460 (after 8.0.0452)
Problem:    Can't build on HPUX.
Solution:   Fix argument names in vim_stat(). (John Marriott)
Files:      src/misc2.c


*** ../vim-8.0.0459/src/misc2.c	2017-03-12 20:09:59.480468291 +0100
--- src/misc2.c	2017-03-16 12:20:24.700271060 +0100
***************
*** 3365,3371 ****
   * The Vim code assumes a trailing slash is only ignored for a directory.
   */
      static int
! illegal_slash(char *name)
  {
      if (name[0] == NUL)
  	return FALSE;	    /* no file name is not illegal */
--- 3365,3371 ----
   * The Vim code assumes a trailing slash is only ignored for a directory.
   */
      static int
! illegal_slash(const char *name)
  {
      if (name[0] == NUL)
  	return FALSE;	    /* no file name is not illegal */
***************
*** 3384,3390 ****
  {
      /* On Solaris stat() accepts "file/" as if it was "file".  Return -1 if
       * the name ends in "/" and it's not a directory. */
!     return illegal_slash(n) ? -1 : stat(n, p);
  }
  #endif
  
--- 3384,3390 ----
  {
      /* On Solaris stat() accepts "file/" as if it was "file".  Return -1 if
       * the name ends in "/" and it's not a directory. */
!     return illegal_slash(name) ? -1 : stat(name, stp);
  }
  #endif
  
*** ../vim-8.0.0459/src/version.c	2017-03-15 20:44:26.727915109 +0100
--- src/version.c	2017-03-16 12:20:56.416044592 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     460,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
127. You bring your laptop and cellular phone to church.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0461
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0461 (after 8.0.0457)
Problem:    Test 45 hangs on MS-Windows.
Solution:   Reset 'shiftwidth'.  Also remove redundent function.
Files:      src/fold.c, src/testdir/test45.in


*** ../vim-8.0.0460/src/fold.c	2017-03-14 21:53:54.110075306 +0100
--- src/fold.c	2017-03-16 12:28:19.440881398 +0100
***************
*** 64,70 ****
  static void foldDelMarker(linenr_T lnum, char_u *marker, int markerlen);
  static void foldUpdateIEMS(win_T *wp, linenr_T top, linenr_T bot);
  static void parseMarker(win_T *wp);
- static void foldMoveRange_int(garray_T *gap, linenr_T line1, linenr_T line2, linenr_T dest);
  
  static char *e_nofold = N_("E490: No fold found");
  
--- 64,69 ----
***************
*** 1076,1087 ****
      (void)hasFolding(curwin->w_cursor.lnum, &curwin->w_cursor.lnum, NULL);
  }
  
- /* foldMoveRange() {{{2 */
-     void
- foldMoveRange(garray_T *gap, linenr_T line1, linenr_T line2, linenr_T dest)
- {
-     foldMoveRange_int(gap, line1, line2, dest);
- }
  /* Internal functions for "fold_T" {{{1 */
  /* cloneFoldGrowArray() {{{2 */
  /*
--- 1075,1080 ----
***************
*** 2992,2998 ****
      }
  }
  
! /* foldMoveRange_int() {{{2 */
  /*
   * Move folds within the inclusive range "line1" to "line2" to after "dest"
   * requires "line1" <= "line2" <= "dest"
--- 2985,2991 ----
      }
  }
  
! /* foldMoveRange() {{{2 */
  /*
   * Move folds within the inclusive range "line1" to "line2" to after "dest"
   * requires "line1" <= "line2" <= "dest"
***************
*** 3036,3043 ****
  #define valid_fold(fp, gap) ((fp) < ((fold_T *)(gap)->ga_data + (gap)->ga_len))
  #define fold_index(fp, gap) ((size_t)(fp - ((fold_T *)(gap)->ga_data)))
  
!     static void
! foldMoveRange_int(garray_T *gap, linenr_T line1, linenr_T line2, linenr_T dest)
  {
      fold_T *fp;
      linenr_T range_len = line2 - line1 + 1;
--- 3029,3036 ----
  #define valid_fold(fp, gap) ((fp) < ((fold_T *)(gap)->ga_data + (gap)->ga_len))
  #define fold_index(fp, gap) ((size_t)(fp - ((fold_T *)(gap)->ga_data)))
  
!     void
! foldMoveRange(garray_T *gap, linenr_T line1, linenr_T line2, linenr_T dest)
  {
      fold_T *fp;
      linenr_T range_len = line2 - line1 + 1;
***************
*** 3108,3114 ****
      }
  
      /* Case 5 or 6
!      * changes rely on whether there are folds between the end of 
       * this fold and "dest".
       */
      move_start = fold_index(fp, gap);
--- 3101,3107 ----
      }
  
      /* Case 5 or 6
!      * changes rely on whether there are folds between the end of
       * this fold and "dest".
       */
      move_start = fold_index(fp, gap);
*** ../vim-8.0.0460/src/testdir/test45.in	2017-03-08 22:55:14.914181221 +0100
--- src/testdir/test45.in	2017-03-16 13:50:17.645242457 +0100
***************
*** 27,32 ****
--- 27,33 ----
  /^2 b
  i  jI    :call append("$", "indent " . foldlevel("."))
  k:call append("$", foldlevel("."))
+ :set sw&
  :" test syntax folding
  :set fdm=syntax fdl=0
  :syn region Hup start="dd" end="ii" fold contains=Fd1,Fd2,Fd3
*** ../vim-8.0.0460/src/version.c	2017-03-16 12:22:34.607343466 +0100
--- src/version.c	2017-03-16 13:50:32.917028779 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     461,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
128. You can access the Net -- via your portable and cellular phone.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0462
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0462
Problem:    If an MS-Windows tests succeeds at first and then fails in a way
            it does not produce a test.out file it looks like the test
            succeeded.
Solution:   Delete the previous output file.
Files:      src/testdir/Make_dos.mak


*** ../vim-8.0.0461/src/testdir/Make_dos.mak	2017-03-12 17:10:14.417925081 +0100
--- src/testdir/Make_dos.mak	2017-03-16 12:46:53.914176661 +0100
***************
*** 44,49 ****
--- 44,50 ----
  # This moves test99.in to test99.in.bak temporarily.
  $(TEST_OUTFILES): $(DOSTMP)\$(*B).in
  	-@if exist test.out DEL test.out
+ 	-@if exist $(DOSTMP)\$(*B).out DEL $(DOSTMP)\$(*B).out
  	move $(*B).in $(*B).in.bak > nul
  	copy $(DOSTMP)\$(*B).in $(*B).in > nul
  	copy $(*B).ok test.ok > nul
*** ../vim-8.0.0461/src/version.c	2017-03-16 13:54:03.515491515 +0100
--- src/version.c	2017-03-16 14:04:05.671096875 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     462,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
129. You cancel your newspaper subscription.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0463
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0463
Problem:    Resetting 'compatible' in defaults.vim has unexpected side
            effects. (David Fishburn)
Solution:   Only reset 'compatible' if it was set.
Files:      runtime/defaults.vim


*** ../vim-8.0.0462/runtime/defaults.vim	2016-09-02 22:57:51.000000000 +0200
--- runtime/defaults.vim	2017-03-08 22:31:18.304572393 +0100
***************
*** 1,7 ****
  " The default vimrc file.
  "
  " Maintainer:	Bram Moolenaar <Bram@vim.org>
! " Last change:	2016 Sep 02
  "
  " This is loaded if no vimrc file was found.
  " Except when Vim is run with "-u NONE" or "-C".
--- 1,7 ----
  " The default vimrc file.
  "
  " Maintainer:	Bram Moolenaar <Bram@vim.org>
! " Last change:	2017 Mar 08
  "
  " This is loaded if no vimrc file was found.
  " Except when Vim is run with "-u NONE" or "-C".
***************
*** 21,27 ****
  
  " Use Vim settings, rather than Vi settings (much better!).
  " This must be first, because it changes other options as a side effect.
! set nocompatible
  
  " Allow backspacing over everything in insert mode.
  set backspace=indent,eol,start
--- 21,30 ----
  
  " Use Vim settings, rather than Vi settings (much better!).
  " This must be first, because it changes other options as a side effect.
! " Avoid side effects when it was already reset.
! if &compatible
!   set nocompatible
! endif
  
  " Allow backspacing over everything in insert mode.
  set backspace=indent,eol,start
*** ../vim-8.0.0462/src/version.c	2017-03-16 14:04:47.690789247 +0100
--- src/version.c	2017-03-16 14:19:14.608448365 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     463,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
130. You can't get out of your desk even if it's time to eat or time
     to go to the bathroom.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0464
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0464
Problem:    Can't find executable name on Solaris and FreeBSD.
Solution:   Check for "/proc/self/path/a.out". (Danek Duvall) And for
            "/proc/curproc/file".
Files:      src/config.h.in, src/configure.ac, src/main.c,
            src/auto/configure


*** ../vim-8.0.0463/src/config.h.in	2017-03-12 18:37:58.375653719 +0100
--- src/config.h.in	2017-03-16 14:26:46.325148353 +0100
***************
*** 446,453 ****
  /* Define if fcntl()'s F_SETFD command knows about FD_CLOEXEC */
  #undef HAVE_FD_CLOEXEC
  
! /* Define if /proc/self/exe can be read */
! #undef HAVE_PROC_SELF_EXE
  
  /* Define if you want Cygwin to use the WIN32 clipboard, not compatible with X11*/
  #undef FEAT_CYGWIN_WIN32_CLIPBOARD
--- 446,453 ----
  /* Define if fcntl()'s F_SETFD command knows about FD_CLOEXEC */
  #undef HAVE_FD_CLOEXEC
  
! /* Define if /proc/self/exe or similar can be read */
! #undef PROC_EXE_LINK
  
  /* Define if you want Cygwin to use the WIN32 clipboard, not compatible with X11*/
  #undef FEAT_CYGWIN_WIN32_CLIPBOARD
*** ../vim-8.0.0463/src/configure.ac	2017-03-11 20:03:37.837266860 +0100
--- src/configure.ac	2017-03-16 14:32:04.578824782 +0100
***************
*** 3020,3031 ****
  dnl end of GUI-checking
  dnl ---------------------------------------------------------------------------
  
! AC_MSG_CHECKING([for /proc/self/exe])
  if test -L "/proc/self/exe"; then
!     AC_MSG_RESULT(yes)
!     AC_DEFINE(HAVE_PROC_SELF_EXE)
  else
!     AC_MSG_RESULT(no)
  fi
  
  dnl Check for Cygwin, which needs an extra source file if not using X11
--- 3020,3040 ----
  dnl end of GUI-checking
  dnl ---------------------------------------------------------------------------
  
! AC_MSG_CHECKING([for /proc link to executable])
  if test -L "/proc/self/exe"; then
!   dnl Linux
!   AC_MSG_RESULT([/proc/self/exe])
!   AC_DEFINE(PROC_EXE_LINK, "/proc/self/exe")
! elif test -L "/proc/self/path/a.out"; then
!   dnl Solaris
!   AC_MSG_RESULT([/proc/self/path/a.out])
!   AC_DEFINE(PROC_EXE_LINK, "/proc/self/path/a.out")
! elif test -L "/proc/curproc/file"; then
!   dnl FreeBSD
!   AC_MSG_RESULT([/proc/curproc/file])
!   AC_DEFINE(PROC_EXE_LINK, "/proc/curproc/file")
  else
!   AC_MSG_RESULT(no)
  fi
  
  dnl Check for Cygwin, which needs an extra source file if not using X11
*** ../vim-8.0.0463/src/main.c	2017-03-12 18:37:58.375653719 +0100
--- src/main.c	2017-03-16 14:32:36.842589285 +0100
***************
*** 3539,3549 ****
  {
      char_u *val = argv0;
  
! # ifdef HAVE_PROC_SELF_EXE
      char    buf[PATH_MAX + 1];
      ssize_t len;
  
!     len = readlink("/proc/self/exe", buf, PATH_MAX);
      if (len > 0)
      {
  	buf[len] = NUL;
--- 3539,3549 ----
  {
      char_u *val = argv0;
  
! # ifdef PROC_EXE_LINK
      char    buf[PATH_MAX + 1];
      ssize_t len;
  
!     len = readlink(PROC_EXE_LINK, buf, PATH_MAX);
      if (len > 0)
      {
  	buf[len] = NUL;
*** ../vim-8.0.0463/src/auto/configure	2017-03-11 20:03:37.841266833 +0100
--- src/auto/configure	2017-03-16 14:32:39.634568907 +0100
***************
*** 10101,10115 ****
  
  
  
! { $as_echo "$as_me:${as_lineno-$LINENO}: checking for /proc/self/exe" >&5
! $as_echo_n "checking for /proc/self/exe... " >&6; }
  if test -L "/proc/self/exe"; then
!     { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
! $as_echo "yes" >&6; }
!     $as_echo "#define HAVE_PROC_SELF_EXE 1" >>confdefs.h
  
  else
!     { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
  $as_echo "no" >&6; }
  fi
  
--- 10101,10125 ----
  
  
  
! { $as_echo "$as_me:${as_lineno-$LINENO}: checking for /proc link to executable" >&5
! $as_echo_n "checking for /proc link to executable... " >&6; }
  if test -L "/proc/self/exe"; then
!     { $as_echo "$as_me:${as_lineno-$LINENO}: result: /proc/self/exe" >&5
! $as_echo "/proc/self/exe" >&6; }
!   $as_echo "#define PROC_EXE_LINK \"/proc/self/exe\"" >>confdefs.h
! 
! elif test -L "/proc/self/path/a.out"; then
!     { $as_echo "$as_me:${as_lineno-$LINENO}: result: /proc/self/path/a.out" >&5
! $as_echo "/proc/self/path/a.out" >&6; }
!   $as_echo "#define PROC_EXE_LINK \"/proc/self/path/a.out\"" >>confdefs.h
! 
! elif test -L "/proc/curproc/file"; then
!     { $as_echo "$as_me:${as_lineno-$LINENO}: result: /proc/curproc/file" >&5
! $as_echo "/proc/curproc/file" >&6; }
!   $as_echo "#define PROC_EXE_LINK \"/proc/curproc/file\"" >>confdefs.h
  
  else
!   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
  $as_echo "no" >&6; }
  fi
  
*** ../vim-8.0.0463/src/version.c	2017-03-16 14:19:30.816329916 +0100
--- src/version.c	2017-03-16 14:28:24.752429616 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     464,
  /**/

-- 
Why is it called "Windows"?  "Gates" would be more appropriate...

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0465
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0465
Problem:    Off-by-one error in using :move with folding.
Solution:   Correct off-by-one mistakes and add more tests. (Matthew
            Malcomson)
Files:      src/fold.c, src/testdir/test_fold.vim


*** ../vim-8.0.0464/src/fold.c	2017-03-16 13:54:03.515491515 +0100
--- src/fold.c	2017-03-16 15:35:45.882771962 +0100
***************
*** 3021,3028 ****
      static void
  truncate_fold(fold_T *fp, linenr_T end)
  {
      foldRemove(&fp->fd_nested, end - fp->fd_top, MAXLNUM);
!     fp->fd_len = end - fp->fd_top + 1;
  }
  
  #define fold_end(fp) ((fp)->fd_top + (fp)->fd_len - 1)
--- 3021,3029 ----
      static void
  truncate_fold(fold_T *fp, linenr_T end)
  {
+     end += 1;
      foldRemove(&fp->fd_nested, end - fp->fd_top, MAXLNUM);
!     fp->fd_len = end - fp->fd_top;
  }
  
  #define fold_end(fp) ((fp)->fd_top + (fp)->fd_len - 1)
***************
*** 3062,3068 ****
  	}
  	else
  	    /* Case 2 truncate fold, folds after this one must be dealt with. */
! 	    truncate_fold(fp, line1);
  
  	/* Look at the next fold, and treat that one as if it were the first
  	 * after  "line1" (because now it is). */
--- 3063,3069 ----
  	}
  	else
  	    /* Case 2 truncate fold, folds after this one must be dealt with. */
! 	    truncate_fold(fp, line1 - 1);
  
  	/* Look at the next fold, and treat that one as if it were the first
  	 * after  "line1" (because now it is). */
***************
*** 3078,3088 ****
      }
      else if (fp->fd_top > line2)
      {
! 	for (; valid_fold(fp, gap) && fold_end(fp) < dest; fp++)
  	/* Case 9. (for all case 9's) -- shift up. */
  	    fp->fd_top -= range_len;
  
! 	if (valid_fold(fp, gap) && fp->fd_top < dest)
  	{
  	    /* Case 8. -- ensure truncated at dest, shift up */
  	    truncate_fold(fp, dest);
--- 3079,3089 ----
      }
      else if (fp->fd_top > line2)
      {
! 	for (; valid_fold(fp, gap) && fold_end(fp) <= dest; fp++)
  	/* Case 9. (for all case 9's) -- shift up. */
  	    fp->fd_top -= range_len;
  
! 	if (valid_fold(fp, gap) && fp->fd_top <= dest)
  	{
  	    /* Case 8. -- ensure truncated at dest, shift up */
  	    truncate_fold(fp, dest);
*** ../vim-8.0.0464/src/testdir/test_fold.vim	2017-03-14 21:53:54.114075276 +0100
--- src/testdir/test_fold.vim	2017-03-16 15:35:45.882771962 +0100
***************
*** 249,255 ****
    redraw!
    set fdm=manual
    call cursor(2, 1)
!   norm! zR
    7,12m0
    let folds=repeat([-1], 18)
    call assert_equal(PrepIndent("b") + PrepIndent("a") + PrepIndent("c"), getline(1, '$'))
--- 249,255 ----
    redraw!
    set fdm=manual
    call cursor(2, 1)
!   %foldopen
    7,12m0
    let folds=repeat([-1], 18)
    call assert_equal(PrepIndent("b") + PrepIndent("a") + PrepIndent("c"), getline(1, '$'))
***************
*** 284,289 ****
--- 284,299 ----
    call assert_equal(0, foldlevel(6))
    call assert_equal(9, foldclosedend(7))
    call assert_equal([-1, 2, 2, 2, 2, -1, 7, 7, 7, -1], map(range(1, line('$')), 'foldclosed(v:val)'))
+   %d
+   " Ensure moving around the edges still works.
+   call setline(1, PrepIndent("a") + repeat(["a"], 3) + ["\ta"])
+   set fdm=indent foldlevel=0
+   set fdm=manual
+   %foldopen
+   6m$
+   " The first fold has been truncated to the 5'th line.
+   " Second fold has been moved up because the moved line is now below it.
+   call assert_equal([0, 1, 1, 1, 1, 0, 0, 0, 1, 0], map(range(1, line('$')), 'foldlevel(v:val)'))
    bw!
  endfunc
  
***************
*** 307,313 ****
    call setline(1, PrepIndent("a") + PrepIndent("b") + PrepIndent("c"))
    set fdm=indent
    call cursor(2, 1)
!   norm! zR
    7,12m0
    let folds=repeat([-1], 18)
    call assert_equal(PrepIndent("b") + PrepIndent("a") + PrepIndent("c"), getline(1, '$'))
--- 317,323 ----
    call setline(1, PrepIndent("a") + PrepIndent("b") + PrepIndent("c"))
    set fdm=indent
    call cursor(2, 1)
!   %foldopen
    7,12m0
    let folds=repeat([-1], 18)
    call assert_equal(PrepIndent("b") + PrepIndent("a") + PrepIndent("c"), getline(1, '$'))
***************
*** 339,343 ****
--- 349,362 ----
    call assert_equal(1, foldlevel(6))
    call assert_equal(9, foldclosedend(7))
    call assert_equal([-1, 2, 2, 2, 2, 2, 2, 2, 2, -1], map(range(1, line('$')), 'foldclosed(v:val)'))
+   " Ensure moving around the edges still works.
+   %d
+   call setline(1, PrepIndent("a") + repeat(["a"], 3) + ["\ta"])
+   set fdm=indent foldlevel=0
+   %foldopen
+   6m$
+   " The first fold has been truncated to the 5'th line.
+   " Second fold has been moved up because the moved line is now below it.
+   call assert_equal([0, 1, 1, 1, 1, 0, 0, 0, 1, 1], map(range(1, line('$')), 'foldlevel(v:val)'))
    bw!
  endfunc
*** ../vim-8.0.0464/src/version.c	2017-03-16 15:13:41.928472168 +0100
--- src/version.c	2017-03-16 15:58:20.004901010 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     465,
  /**/

-- 
There are three kinds of persons: Those who can count and those who can't.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0466
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0466
Problem:    There are still a few macros that should be all-caps.
Solution:   Make a few more macros all-caps.
Files:      src/buffer.c, src/edit.c, src/ex_cmds.c, src/ex_cmds2.c,
	    src/ex_docmd.c, src/ex_getln.c, src/farsi.c, src/fileio.c,
	    src/getchar.c, src/gui_beval.c, src/hardcopy.c, src/if_cscope.c,
	    src/if_xcmdsrv.c, src/mark.c, src/memline.c, src/menu.c,
	    src/message.c, src/misc1.c, src/normal.c, src/ops.c, src/option.c,
	    src/quickfix.c, src/screen.c, src/search.c, src/syntax.c,
	    src/tag.c, src/term.c, src/term.h, src/ui.c, src/undo.c,
	    src/userfunc.c, src/version.c, src/vim.h


*** ../vim-8.0.0465/src/buffer.c	2017-03-12 18:23:35.833850172 +0100
--- src/buffer.c	2017-03-16 16:38:46.039311101 +0100
***************
*** 6021,6027 ****
  	if (buf->b_signlist != NULL)
  	{
  	    vim_snprintf(lbuf, BUFSIZ, _("Signs for %s:"), buf->b_fname);
! 	    MSG_PUTS_ATTR(lbuf, hl_attr(HLF_D));
  	    msg_putchar('\n');
  	}
  	for (p = buf->b_signlist; p != NULL && !got_int; p = p->next)
--- 6021,6027 ----
  	if (buf->b_signlist != NULL)
  	{
  	    vim_snprintf(lbuf, BUFSIZ, _("Signs for %s:"), buf->b_fname);
! 	    MSG_PUTS_ATTR(lbuf, HL_ATTR(HLF_D));
  	    msg_putchar('\n');
  	}
  	for (p = buf->b_signlist; p != NULL && !got_int; p = p->next)
*** ../vim-8.0.0465/src/edit.c	2017-03-12 20:09:59.464468404 +0100
--- src/edit.c	2017-03-16 16:39:17.531082609 +0100
***************
*** 1771,1777 ****
  	update_topline();	/* just in case w_topline isn't valid */
  	validate_cursor();
  	if (highlight)
! 	    attr = hl_attr(HLF_8);
  	else
  	    attr = 0;
  	pc_row = W_WINROW(curwin) + curwin->w_wrow;
--- 1771,1777 ----
  	update_topline();	/* just in case w_topline isn't valid */
  	validate_cursor();
  	if (highlight)
! 	    attr = HL_ATTR(HLF_8);
  	else
  	    attr = 0;
  	pc_row = W_WINROW(curwin) + curwin->w_wrow;
***************
*** 2256,2262 ****
  	edit_submode = NULL;
  	msg_attr(dict_opt ? (char_u *)_("'dictionary' option is empty")
  			  : (char_u *)_("'thesaurus' option is empty"),
! 							      hl_attr(HLF_E));
  	if (emsg_silent == 0)
  	{
  	    vim_beep(BO_COMPL);
--- 2256,2262 ----
  	edit_submode = NULL;
  	msg_attr(dict_opt ? (char_u *)_("'dictionary' option is empty")
  			  : (char_u *)_("'thesaurus' option is empty"),
! 							      HL_ATTR(HLF_E));
  	if (emsg_silent == 0)
  	{
  	    vim_beep(BO_COMPL);
***************
*** 3252,3258 ****
  	{
  	    vim_snprintf((char *)IObuff, IOSIZE,
  			      _("Scanning dictionary: %s"), (char *)files[i]);
! 	    (void)msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
  	}
  
  	if (fp != NULL)
--- 3252,3258 ----
  	{
  	    vim_snprintf((char *)IObuff, IOSIZE,
  			      _("Scanning dictionary: %s"), (char *)files[i]);
! 	    (void)msg_trunc_attr(IObuff, TRUE, HL_ATTR(HLF_R));
  	}
  
  	if (fp != NULL)
***************
*** 4344,4350 ****
  			    : ins_buf->b_sfname == NULL
  				? ins_buf->b_fname
  				: ins_buf->b_sfname);
! 		(void)msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
  	    }
  	    else if (*e_cpt == NUL)
  		break;
--- 4344,4350 ----
  			    : ins_buf->b_sfname == NULL
  				? ins_buf->b_fname
  				: ins_buf->b_sfname);
! 		(void)msg_trunc_attr(IObuff, TRUE, HL_ATTR(HLF_R));
  	    }
  	    else if (*e_cpt == NUL)
  		break;
***************
*** 4374,4380 ****
  		{
  		    type = CTRL_X_TAGS;
  		    vim_snprintf((char *)IObuff, IOSIZE, _("Scanning tags."));
! 		    (void)msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
  		}
  		else
  		    type = -1;
--- 4374,4380 ----
  		{
  		    type = CTRL_X_TAGS;
  		    vim_snprintf((char *)IObuff, IOSIZE, _("Scanning tags."));
! 		    (void)msg_trunc_attr(IObuff, TRUE, HL_ATTR(HLF_R));
  		}
  		else
  		    type = -1;
***************
*** 5693,5699 ****
  	    if (!p_smd)
  		msg_attr(edit_submode_extra,
  			edit_submode_highl < HLF_COUNT
! 			? hl_attr(edit_submode_highl) : 0);
  	}
  	else
  	    msg_clr_cmdline();	/* necessary for "noshowmode" */
--- 5693,5699 ----
  	    if (!p_smd)
  		msg_attr(edit_submode_extra,
  			edit_submode_highl < HLF_COUNT
! 			? HL_ATTR(edit_submode_highl) : 0);
  	}
  	else
  	    msg_clr_cmdline();	/* necessary for "noshowmode" */
*** ../vim-8.0.0465/src/ex_cmds.c	2017-03-15 20:44:26.727915109 +0100
--- src/ex_cmds.c	2017-03-16 16:39:33.954963440 +0100
***************
*** 2889,2895 ****
      {
  	vim_snprintf((char *)numbuf, sizeof(numbuf),
  				   "%*ld ", number_width(curwin), (long)lnum);
! 	msg_puts_attr(numbuf, hl_attr(HLF_N));	/* Highlight line nrs */
      }
      msg_prt_line(ml_get(lnum), list);
  }
--- 2889,2895 ----
      {
  	vim_snprintf((char *)numbuf, sizeof(numbuf),
  				   "%*ld ", number_width(curwin), (long)lnum);
! 	msg_puts_attr(numbuf, HL_ATTR(HLF_N));	/* Highlight line nrs */
      }
      msg_prt_line(ml_get(lnum), list);
  }
***************
*** 5379,5385 ****
  			    msg_no_more = TRUE;
  			    /* write message same highlighting as for
  			     * wait_return */
! 			    smsg_attr(hl_attr(HLF_R),
  				    (char_u *)_("replace with %s (y/n/a/q/l/^E/^Y)?"), sub);
  			    msg_no_more = FALSE;
  			    msg_scroll = i;
--- 5379,5385 ----
  			    msg_no_more = TRUE;
  			    /* write message same highlighting as for
  			     * wait_return */
! 			    smsg_attr(HL_ATTR(HLF_R),
  				    (char_u *)_("replace with %s (y/n/a/q/l/^E/^Y)?"), sub);
  			    msg_no_more = FALSE;
  			    msg_scroll = i;
***************
*** 8284,8290 ****
  	    else
  		for (n = *p++; n > 0; --n)
  		    if (*p == 'o' || *p == '$')
! 			msg_putchar_attr(*p, hl_attr(HLF_L));
  		    else
  			msg_putchar(*p);
      msg_clr_eos();
--- 8284,8290 ----
  	    else
  		for (n = *p++; n > 0; --n)
  		    if (*p == 'o' || *p == '$')
! 			msg_putchar_attr(*p, HL_ATTR(HLF_L));
  		    else
  			msg_putchar(*p);
      msg_clr_eos();
*** ../vim-8.0.0465/src/ex_cmds2.c	2017-03-12 20:09:59.468468376 +0100
--- src/ex_cmds2.c	2017-03-16 16:39:46.962869057 +0100
***************
*** 2230,2236 ****
  #ifdef FEAT_AUTOCMD
      if (curbuf != old_curbuf)
      {
! 	msg_source(hl_attr(HLF_W));
  	MSG(_("Warning: Entered other buffer unexpectedly (check autocommands)"));
      }
  #endif
--- 2230,2236 ----
  #ifdef FEAT_AUTOCMD
      if (curbuf != old_curbuf)
      {
! 	msg_source(HL_ATTR(HLF_W));
  	MSG(_("Warning: Entered other buffer unexpectedly (check autocommands)"));
      }
  #endif
***************
*** 4733,4739 ****
  		{
  		    if (!sp->error)
  		    {
! 			msg_source(hl_attr(HLF_W));
  			EMSG(_("W15: Warning: Wrong line separator, ^M may be missing"));
  		    }
  		    sp->error = TRUE;
--- 4733,4739 ----
  		{
  		    if (!sp->error)
  		    {
! 			msg_source(HL_ATTR(HLF_W));
  			EMSG(_("W15: Warning: Wrong line separator, ^M may be missing"));
  		    }
  		    sp->error = TRUE;
*** ../vim-8.0.0465/src/ex_docmd.c	2017-03-12 20:09:59.468468376 +0100
--- src/ex_docmd.c	2017-03-16 16:40:05.670733314 +0100
***************
*** 6032,6038 ****
  	    msg_putchar(gap != &ucmds ? 'b' : ' ');
  	    msg_putchar(' ');
  
! 	    msg_outtrans_attr(cmd->uc_name, hl_attr(HLF_D));
  	    len = (int)STRLEN(cmd->uc_name) + 4;
  
  	    do {
--- 6032,6038 ----
  	    msg_putchar(gap != &ucmds ? 'b' : ' ');
  	    msg_putchar(' ');
  
! 	    msg_outtrans_attr(cmd->uc_name, HL_ATTR(HLF_D));
  	    len = (int)STRLEN(cmd->uc_name) + 4;
  
  	    do {
***************
*** 8480,8486 ****
      {
  	msg_putchar('\n');
  	vim_snprintf((char *)IObuff, IOSIZE, _("Tab page %d"), tabcount++);
! 	msg_outtrans_attr(IObuff, hl_attr(HLF_T));
  	out_flush();	    /* output one line at a time */
  	ui_breakcheck();
  
--- 8480,8486 ----
      {
  	msg_putchar('\n');
  	vim_snprintf((char *)IObuff, IOSIZE, _("Tab page %d"), tabcount++);
! 	msg_outtrans_attr(IObuff, HL_ATTR(HLF_T));
  	out_flush();	    /* output one line at a time */
  	ui_breakcheck();
  
*** ../vim-8.0.0465/src/ex_getln.c	2017-03-12 20:09:59.472468347 +0100
--- src/ex_getln.c	2017-03-16 16:40:14.290670768 +0100
***************
*** 4178,4191 ****
  	    lines = (num_files + columns - 1) / columns;
  	}
  
! 	attr = hl_attr(HLF_D);	/* find out highlighting for directories */
  
  	if (xp->xp_context == EXPAND_TAGS_LISTFILES)
  	{
! 	    MSG_PUTS_ATTR(_("tagname"), hl_attr(HLF_T));
  	    msg_clr_eos();
  	    msg_advance(maxlen - 3);
! 	    MSG_PUTS_ATTR(_(" kind file\n"), hl_attr(HLF_T));
  	}
  
  	/* list the files line by line */
--- 4178,4191 ----
  	    lines = (num_files + columns - 1) / columns;
  	}
  
! 	attr = HL_ATTR(HLF_D);	/* find out highlighting for directories */
  
  	if (xp->xp_context == EXPAND_TAGS_LISTFILES)
  	{
! 	    MSG_PUTS_ATTR(_("tagname"), HL_ATTR(HLF_T));
  	    msg_clr_eos();
  	    msg_advance(maxlen - 3);
! 	    MSG_PUTS_ATTR(_(" kind file\n"), HL_ATTR(HLF_T));
  	}
  
  	/* list the files line by line */
***************
*** 4196,4207 ****
  	    {
  		if (xp->xp_context == EXPAND_TAGS_LISTFILES)
  		{
! 		    msg_outtrans_attr(files_found[k], hl_attr(HLF_D));
  		    p = files_found[k] + STRLEN(files_found[k]) + 1;
  		    msg_advance(maxlen + 1);
  		    msg_puts(p);
  		    msg_advance(maxlen + 3);
! 		    msg_puts_long_attr(p + 2, hl_attr(HLF_D));
  		    break;
  		}
  		for (j = maxlen - lastlen; --j >= 0; )
--- 4196,4207 ----
  	    {
  		if (xp->xp_context == EXPAND_TAGS_LISTFILES)
  		{
! 		    msg_outtrans_attr(files_found[k], HL_ATTR(HLF_D));
  		    p = files_found[k] + STRLEN(files_found[k]) + 1;
  		    msg_advance(maxlen + 1);
  		    msg_puts(p);
  		    msg_advance(maxlen + 3);
! 		    msg_puts_long_attr(p + 2, HL_ATTR(HLF_D));
  		    break;
  		}
  		for (j = maxlen - lastlen; --j >= 0; )
*** ../vim-8.0.0465/src/farsi.c	2017-01-29 19:59:35.961322877 +0100
--- src/farsi.c	2017-03-16 16:40:37.406503036 +0100
***************
*** 1719,1725 ****
  
      /* Assume the screen has been messed up: clear it and redraw. */
      redraw_later(CLEAR);
!     MSG_ATTR(farsi_text_1, hl_attr(HLF_S));
  }
  
  /*
--- 1719,1725 ----
  
      /* Assume the screen has been messed up: clear it and redraw. */
      redraw_later(CLEAR);
!     MSG_ATTR(farsi_text_1, HL_ATTR(HLF_S));
  }
  
  /*
***************
*** 1747,1753 ****
  
      /* Assume the screen has been messed up: clear it and redraw. */
      redraw_later(CLEAR);
!     MSG_ATTR(farsi_text_2, hl_attr(HLF_S));
  }
  
  /*
--- 1747,1753 ----
  
      /* Assume the screen has been messed up: clear it and redraw. */
      redraw_later(CLEAR);
!     MSG_ATTR(farsi_text_2, HL_ATTR(HLF_S));
  }
  
  /*
*** ../vim-8.0.0465/src/fileio.c	2017-03-12 20:09:59.472468347 +0100
--- src/fileio.c	2017-03-16 16:40:53.634385282 +0100
***************
*** 5044,5050 ****
      {
  	int numlen = errnum != NULL ? (int)STRLEN(errnum) : 0;
  
! 	attr = hl_attr(HLF_E);	/* set highlight for error messages */
  	msg_add_fname(buf,
  #ifndef UNIX
  		sfname
--- 5044,5050 ----
      {
  	int numlen = errnum != NULL ? (int)STRLEN(errnum) : 0;
  
! 	attr = HL_ATTR(HLF_E);	/* set highlight for error messages */
  	msg_add_fname(buf,
  #ifndef UNIX
  		sfname
***************
*** 5300,5306 ****
  	msg_silent = 0;		    /* must give this prompt */
  	/* don't use emsg() here, don't want to flush the buffers */
  	MSG_ATTR(_("WARNING: The file has been changed since reading it!!!"),
! 						       hl_attr(HLF_E));
  	if (ask_yesno((char_u *)_("Do you really want to write to it"),
  								 TRUE) == 'n')
  	    return FAIL;
--- 5300,5306 ----
  	msg_silent = 0;		    /* must give this prompt */
  	/* don't use emsg() here, don't want to flush the buffers */
  	MSG_ATTR(_("WARNING: The file has been changed since reading it!!!"),
! 						       HL_ATTR(HLF_E));
  	if (ask_yesno((char_u *)_("Do you really want to write to it"),
  								 TRUE) == 'n')
  	    return FAIL;
***************
*** 7011,7020 ****
  # endif
  		{
  		    msg_start();
! 		    msg_puts_attr(tbuf, hl_attr(HLF_E) + MSG_HIST);
  		    if (*mesg2 != NUL)
  			msg_puts_attr((char_u *)mesg2,
! 						   hl_attr(HLF_W) + MSG_HIST);
  		    msg_clr_eos();
  		    (void)msg_end();
  		    if (emsg_silent == 0)
--- 7011,7020 ----
  # endif
  		{
  		    msg_start();
! 		    msg_puts_attr(tbuf, HL_ATTR(HLF_E) + MSG_HIST);
  		    if (*mesg2 != NUL)
  			msg_puts_attr((char_u *)mesg2,
! 						   HL_ATTR(HLF_W) + MSG_HIST);
  		    msg_clr_eos();
  		    (void)msg_end();
  		    if (emsg_silent == 0)
***************
*** 7840,7851 ****
  	if (ap->group != AUGROUP_DEFAULT)
  	{
  	    if (AUGROUP_NAME(ap->group) == NULL)
! 		msg_puts_attr(get_deleted_augroup(), hl_attr(HLF_E));
  	    else
! 		msg_puts_attr(AUGROUP_NAME(ap->group), hl_attr(HLF_T));
  	    msg_puts((char_u *)"  ");
  	}
! 	msg_puts_attr(event_nr2name(event), hl_attr(HLF_T));
  	last_event = event;
  	last_group = ap->group;
  	msg_putchar('\n');
--- 7840,7851 ----
  	if (ap->group != AUGROUP_DEFAULT)
  	{
  	    if (AUGROUP_NAME(ap->group) == NULL)
! 		msg_puts_attr(get_deleted_augroup(), HL_ATTR(HLF_E));
  	    else
! 		msg_puts_attr(AUGROUP_NAME(ap->group), HL_ATTR(HLF_T));
  	    msg_puts((char_u *)"  ");
  	}
! 	msg_puts_attr(event_nr2name(event), HL_ATTR(HLF_T));
  	last_event = event;
  	last_group = ap->group;
  	msg_putchar('\n');
*** ../vim-8.0.0465/src/getchar.c	2017-03-12 20:09:59.472468347 +0100
--- src/getchar.c	2017-03-16 16:41:06.294293418 +0100
***************
*** 4022,4030 ****
      } while (len < 12);
  
      if (mp->m_noremap == REMAP_NONE)
! 	msg_puts_attr((char_u *)"*", hl_attr(HLF_8));
      else if (mp->m_noremap == REMAP_SCRIPT)
! 	msg_puts_attr((char_u *)"&", hl_attr(HLF_8));
      else
  	msg_putchar(' ');
  
--- 4022,4030 ----
      } while (len < 12);
  
      if (mp->m_noremap == REMAP_NONE)
! 	msg_puts_attr((char_u *)"*", HL_ATTR(HLF_8));
      else if (mp->m_noremap == REMAP_SCRIPT)
! 	msg_puts_attr((char_u *)"&", HL_ATTR(HLF_8));
      else
  	msg_putchar(' ');
  
***************
*** 4036,4042 ****
      /* Use FALSE below if we only want things like <Up> to show up as such on
       * the rhs, and not M-x etc, TRUE gets both -- webb */
      if (*mp->m_str == NUL)
! 	msg_puts_attr((char_u *)"<Nop>", hl_attr(HLF_8));
      else
      {
  	/* Remove escaping of CSI, because "m_str" is in a format to be used
--- 4036,4042 ----
      /* Use FALSE below if we only want things like <Up> to show up as such on
       * the rhs, and not M-x etc, TRUE gets both -- webb */
      if (*mp->m_str == NUL)
! 	msg_puts_attr((char_u *)"<Nop>", HL_ATTR(HLF_8));
      else
      {
  	/* Remove escaping of CSI, because "m_str" is in a format to be used
*** ../vim-8.0.0465/src/gui_beval.c	2017-03-12 18:23:35.849850055 +0100
--- src/gui_beval.c	2017-03-16 16:41:16.214221434 +0100
***************
*** 1054,1060 ****
  #endif
  
  	/* Look up the RGB values of the SpecialKey foreground color. */
! 	aep = syn_gui_attr2entry(hl_attr(HLF_8));
  	pixel = (aep != NULL) ? aep->ae_u.gui.fg_color : INVALCOLOR;
  	if (pixel != INVALCOLOR)
  # if GTK_CHECK_VERSION(3,0,0)
--- 1054,1060 ----
  #endif
  
  	/* Look up the RGB values of the SpecialKey foreground color. */
! 	aep = syn_gui_attr2entry(HL_ATTR(HLF_8));
  	pixel = (aep != NULL) ? aep->ae_u.gui.fg_color : INVALCOLOR;
  	if (pixel != INVALCOLOR)
  # if GTK_CHECK_VERSION(3,0,0)
*** ../vim-8.0.0465/src/hardcopy.c	2016-08-29 22:42:20.000000000 +0200
--- src/hardcopy.c	2017-03-16 16:45:20.596447906 +0100
***************
*** 569,575 ****
  prt_message(char_u *s)
  {
      screen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);
!     screen_puts(s, (int)Rows - 1, 0, hl_attr(HLF_R));
      out_flush();
  }
  
--- 569,575 ----
  prt_message(char_u *s)
  {
      screen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);
!     screen_puts(s, (int)Rows - 1, 0, HL_ATTR(HLF_R));
      out_flush();
  }
  
*** ../vim-8.0.0465/src/if_cscope.c	2017-03-12 20:09:59.476468319 +0100
--- src/if_cscope.c	2017-03-16 16:45:30.100378927 +0100
***************
*** 615,621 ****
  	if (p_csverbose)
  	{
  	    msg_clr_eos();
! 	    (void)smsg_attr(hl_attr(HLF_R),
  			    (char_u *)_("Added cscope database %s"),
  			    csinfo[i].fname);
  	}
--- 615,621 ----
  	if (p_csverbose)
  	{
  	    msg_clr_eos();
! 	    (void)smsg_attr(HL_ATTR(HLF_R),
  			    (char_u *)_("Added cscope database %s"),
  			    csinfo[i].fname);
  	}
***************
*** 1612,1618 ****
      if (p_csverbose)
      {
  	msg_clr_eos();
! 	(void)smsg_attr(hl_attr(HLF_R) | MSG_HIST,
  		(char_u *)_("cscope connection %s closed"), cname);
      }
      cs_release_csp(i, TRUE);
--- 1612,1618 ----
      if (p_csverbose)
      {
  	msg_clr_eos();
! 	(void)smsg_attr(HL_ATTR(HLF_R) | MSG_HIST,
  		(char_u *)_("cscope connection %s closed"), cname);
      }
      cs_release_csp(i, TRUE);
***************
*** 2020,2033 ****
      {
  	bufsize = newsize;
  	(void)sprintf(buf, cstag_msg, ptag);
! 	MSG_PUTS_ATTR(buf, hl_attr(HLF_T));
      }
  
      vim_free(tbuf);
  
!     MSG_PUTS_ATTR(_("\n   #   line"), hl_attr(HLF_T));    /* strlen is 7 */
      msg_advance(msg_col + 2);
!     MSG_PUTS_ATTR(_("filename / context / line\n"), hl_attr(HLF_T));
  
      num = 1;
      for (i = 0; i < num_matches; i++)
--- 2020,2033 ----
      {
  	bufsize = newsize;
  	(void)sprintf(buf, cstag_msg, ptag);
! 	MSG_PUTS_ATTR(buf, HL_ATTR(HLF_T));
      }
  
      vim_free(tbuf);
  
!     MSG_PUTS_ATTR(_("\n   #   line"), HL_ATTR(HLF_T));    /* strlen is 7 */
      msg_advance(msg_col + 2);
!     MSG_PUTS_ATTR(_("filename / context / line\n"), HL_ATTR(HLF_T));
  
      num = 1;
      for (i = 0; i < num_matches; i++)
***************
*** 2071,2079 ****
  	{
  	    /* csfmt_str = "%4d %6s  "; */
  	    (void)sprintf(buf, csfmt_str, num, lno);
! 	    MSG_PUTS_ATTR(buf, hl_attr(HLF_CM));
  	}
! 	MSG_PUTS_LONG_ATTR(cs_pathcomponents(fname), hl_attr(HLF_CM));
  
  	/* compute the required space for the context */
  	if (cntxts[idx] != NULL)
--- 2071,2079 ----
  	{
  	    /* csfmt_str = "%4d %6s  "; */
  	    (void)sprintf(buf, csfmt_str, num, lno);
! 	    MSG_PUTS_ATTR(buf, HL_ATTR(HLF_CM));
  	}
! 	MSG_PUTS_LONG_ATTR(cs_pathcomponents(fname), HL_ATTR(HLF_CM));
  
  	/* compute the required space for the context */
  	if (cntxts[idx] != NULL)
***************
*** 2399,2405 ****
  		 * "Added cscope database..."
  		 */
  		sprintf(buf, " (#%d)", i);
! 		MSG_PUTS_ATTR(buf, hl_attr(HLF_R));
  	    }
  	}
  	vim_free(dblist[i]);
--- 2399,2405 ----
  		 * "Added cscope database..."
  		 */
  		sprintf(buf, " (#%d)", i);
! 		MSG_PUTS_ATTR(buf, HL_ATTR(HLF_R));
  	    }
  	}
  	vim_free(dblist[i]);
***************
*** 2411,2417 ****
      vim_free(fllist);
  
      if (p_csverbose)
! 	MSG_ATTR(_("All cscope databases reset"), hl_attr(HLF_R) | MSG_HIST);
      return CSCOPE_SUCCESS;
  } /* cs_reset */
  
--- 2411,2417 ----
      vim_free(fllist);
  
      if (p_csverbose)
! 	MSG_ATTR(_("All cscope databases reset"), HL_ATTR(HLF_R) | MSG_HIST);
      return CSCOPE_SUCCESS;
  } /* cs_reset */
  
***************
*** 2497,2503 ****
      {
  	MSG_PUTS_ATTR(
  	    _(" # pid    database name                       prepend path\n"),
! 	    hl_attr(HLF_T));
  	for (i = 0; i < csinfo_size; i++)
  	{
  	    if (csinfo[i].fname == NULL)
--- 2497,2503 ----
      {
  	MSG_PUTS_ATTR(
  	    _(" # pid    database name                       prepend path\n"),
! 	    HL_ATTR(HLF_T));
  	for (i = 0; i < csinfo_size; i++)
  	{
  	    if (csinfo[i].fname == NULL)
*** ../vim-8.0.0465/src/if_xcmdsrv.c	2017-02-23 19:00:28.512904202 +0100
--- src/if_xcmdsrv.c	2017-03-16 16:45:34.216349054 +0100
***************
*** 231,237 ****
  	    if (res < -1 || i >= 1000)
  	    {
  		MSG_ATTR(_("Unable to register a command server name"),
! 							      hl_attr(HLF_W));
  		return FAIL;
  	    }
  	    if (p == NULL)
--- 231,237 ----
  	    if (res < -1 || i >= 1000)
  	    {
  		MSG_ATTR(_("Unable to register a command server name"),
! 							      HL_ATTR(HLF_W));
  		return FAIL;
  	    }
  	    if (p == NULL)
*** ../vim-8.0.0465/src/mark.c	2017-03-14 21:53:54.114075276 +0100
--- src/mark.c	2017-03-16 16:45:39.912307712 +0100
***************
*** 794,800 ****
  	    }
  	    if (name != NULL)
  	    {
! 		msg_outtrans_attr(name, current ? hl_attr(HLF_D) : 0);
  		if (mustfree)
  		    vim_free(name);
  	    }
--- 794,800 ----
  	    }
  	    if (name != NULL)
  	    {
! 		msg_outtrans_attr(name, current ? HL_ATTR(HLF_D) : 0);
  		if (mustfree)
  		    vim_free(name);
  	    }
***************
*** 926,932 ****
  	    msg_outtrans(IObuff);
  	    msg_outtrans_attr(name,
  			    curwin->w_jumplist[i].fmark.fnum == curbuf->b_fnum
! 							? hl_attr(HLF_D) : 0);
  	    vim_free(name);
  	    ui_breakcheck();
  	}
--- 926,932 ----
  	    msg_outtrans(IObuff);
  	    msg_outtrans_attr(name,
  			    curwin->w_jumplist[i].fmark.fnum == curbuf->b_fnum
! 							? HL_ATTR(HLF_D) : 0);
  	    vim_free(name);
  	    ui_breakcheck();
  	}
***************
*** 973,979 ****
  	    name = mark_line(&curbuf->b_changelist[i], 17);
  	    if (name == NULL)
  		break;
! 	    msg_outtrans_attr(name, hl_attr(HLF_D));
  	    vim_free(name);
  	    ui_breakcheck();
  	}
--- 973,979 ----
  	    name = mark_line(&curbuf->b_changelist[i], 17);
  	    if (name == NULL)
  		break;
! 	    msg_outtrans_attr(name, HL_ATTR(HLF_D));
  	    vim_free(name);
  	    ui_breakcheck();
  	}
*** ../vim-8.0.0465/src/memline.c	2017-03-12 19:22:31.756584930 +0100
--- src/memline.c	2017-03-16 16:45:46.796257749 +0100
***************
*** 1136,1142 ****
  
      recoverymode = TRUE;
      called_from_main = (curbuf->b_ml.ml_mfp == NULL);
!     attr = hl_attr(HLF_E);
  
      /*
       * If the file name ends in ".s[uvw][a-z]" we assume this is the swap file.
--- 1136,1142 ----
  
      recoverymode = TRUE;
      called_from_main = (curbuf->b_ml.ml_mfp == NULL);
!     attr = HL_ATTR(HLF_E);
  
      /*
       * If the file name ends in ".s[uvw][a-z]" we assume this is the swap file.
*** ../vim-8.0.0465/src/menu.c	2017-03-12 20:09:59.476468319 +0100
--- src/menu.c	2017-03-16 16:45:50.536230603 +0100
***************
*** 1132,1138 ****
  	    MSG_PUTS(" ");
  	}
  				/* Same highlighting as for directories!? */
! 	msg_outtrans_attr(menu->name, hl_attr(HLF_D));
      }
  
      if (menu != NULL && menu->children == NULL)
--- 1132,1138 ----
  	    MSG_PUTS(" ");
  	}
  				/* Same highlighting as for directories!? */
! 	msg_outtrans_attr(menu->name, HL_ATTR(HLF_D));
      }
  
      if (menu != NULL && menu->children == NULL)
***************
*** 1162,1168 ****
  		    msg_putchar(' ');
  		MSG_PUTS(" ");
  		if (*menu->strings[bit] == NUL)
! 		    msg_puts_attr((char_u *)"<Nop>", hl_attr(HLF_8));
  		else
  		    msg_outtrans_special(menu->strings[bit], FALSE);
  	    }
--- 1162,1168 ----
  		    msg_putchar(' ');
  		MSG_PUTS(" ");
  		if (*menu->strings[bit] == NUL)
! 		    msg_puts_attr((char_u *)"<Nop>", HL_ATTR(HLF_8));
  		else
  		    msg_outtrans_special(menu->strings[bit], FALSE);
  	    }
*** ../vim-8.0.0465/src/message.c	2017-03-12 20:09:59.476468319 +0100
--- src/message.c	2017-03-16 16:46:06.848112210 +0100
***************
*** 503,509 ****
      p = get_emsg_lnum();
      if (p != NULL)
      {
! 	msg_attr(p, hl_attr(HLF_N));
  	vim_free(p);
  	last_sourcing_lnum = sourcing_lnum;  /* only once for each line */
      }
--- 503,509 ----
      p = get_emsg_lnum();
      if (p != NULL)
      {
! 	msg_attr(p, HL_ATTR(HLF_N));
  	vim_free(p);
  	last_sourcing_lnum = sourcing_lnum;  /* only once for each line */
      }
***************
*** 690,696 ****
  
      emsg_on_display = TRUE;	/* remember there is an error message */
      ++msg_scroll;		/* don't overwrite a previous message */
!     attr = hl_attr(HLF_E);	/* set highlight mode for error messages */
      if (msg_scrolled != 0)
  	need_wait_return = TRUE;    /* needed in case emsg() is called after
  				     * wait_return has reset need_wait_return
--- 690,696 ----
  
      emsg_on_display = TRUE;	/* remember there is an error message */
      ++msg_scroll;		/* don't overwrite a previous message */
!     attr = HL_ATTR(HLF_E);	/* set highlight mode for error messages */
      if (msg_scrolled != 0)
  	need_wait_return = TRUE;    /* needed in case emsg() is called after
  				     * wait_return has reset need_wait_return
***************
*** 985,991 ****
  	if (s != NULL && *s != NUL)
  	    msg_attr((char_u *)
  		    _("Messages maintainer: Bram Moolenaar <Bram@vim.org>"),
! 		    hl_attr(HLF_T));
      }
  
      /* Display what was not skipped. */
--- 985,991 ----
  	if (s != NULL && *s != NUL)
  	    msg_attr((char_u *)
  		    _("Messages maintainer: Bram Moolenaar <Bram@vim.org>"),
! 		    HL_ATTR(HLF_T));
      }
  
      /* Display what was not skipped. */
***************
*** 1280,1286 ****
      if (got_int)
  	MSG_PUTS(_("Interrupt: "));
  
!     MSG_PUTS_ATTR(_("Press ENTER or type command to continue"), hl_attr(HLF_R));
      if (!msg_use_printf())
  	msg_clr_eos();
      p_more = save_p_more;
--- 1280,1286 ----
      if (got_int)
  	MSG_PUTS(_("Interrupt: "));
  
!     MSG_PUTS_ATTR(_("Press ENTER or type command to continue"), HL_ATTR(HLF_R));
      if (!msg_use_printf())
  	msg_clr_eos();
      p_more = save_p_more;
***************
*** 1431,1437 ****
      void
  msg_home_replace_hl(char_u *fname)
  {
!     msg_home_replace_attr(fname, hl_attr(HLF_D));
  }
  #endif
  
--- 1431,1437 ----
      void
  msg_home_replace_hl(char_u *fname)
  {
!     msg_home_replace_attr(fname, HL_ATTR(HLF_D));
  }
  #endif
  
***************
*** 1544,1550 ****
  		    msg_puts_attr_len(plain_start, (int)(str - plain_start),
  									attr);
  		plain_start = str + mb_l;
! 		msg_puts_attr(transchar(c), attr == 0 ? hl_attr(HLF_8) : attr);
  		retval += char2cells(c);
  	    }
  	    len -= mb_l - 1;
--- 1544,1550 ----
  		    msg_puts_attr_len(plain_start, (int)(str - plain_start),
  									attr);
  		plain_start = str + mb_l;
! 		msg_puts_attr(transchar(c), attr == 0 ? HL_ATTR(HLF_8) : attr);
  		retval += char2cells(c);
  	    }
  	    len -= mb_l - 1;
***************
*** 1562,1568 ****
  		    msg_puts_attr_len(plain_start, (int)(str - plain_start),
  									attr);
  		plain_start = str + 1;
! 		msg_puts_attr(s, attr == 0 ? hl_attr(HLF_8) : attr);
  		retval += (int)STRLEN(s);
  	    }
  	    else
--- 1562,1568 ----
  		    msg_puts_attr_len(plain_start, (int)(str - plain_start),
  									attr);
  		plain_start = str + 1;
! 		msg_puts_attr(s, attr == 0 ? HL_ATTR(HLF_8) : attr);
  		retval += (int)STRLEN(s);
  	    }
  	    else
***************
*** 1623,1629 ****
      int		attr;
      int		len;
  
!     attr = hl_attr(HLF_8);
      while (*str != NUL)
      {
  	/* Leading and trailing spaces need to be displayed in <> form. */
--- 1623,1629 ----
      int		attr;
      int		len;
  
!     attr = HL_ATTR(HLF_8);
      while (*str != NUL)
      {
  	/* Leading and trailing spaces need to be displayed in <> form. */
***************
*** 1846,1858 ****
  		{
  		    c = lcs_tab1;
  		    c_extra = lcs_tab2;
! 		    attr = hl_attr(HLF_8);
  		}
  	    }
  	    else if (c == 160 && list && lcs_nbsp != NUL)
  	    {
  		c = lcs_nbsp;
! 		attr = hl_attr(HLF_8);
  	    }
  	    else if (c == NUL && list && lcs_eol != NUL)
  	    {
--- 1846,1858 ----
  		{
  		    c = lcs_tab1;
  		    c_extra = lcs_tab2;
! 		    attr = HL_ATTR(HLF_8);
  		}
  	    }
  	    else if (c == 160 && list && lcs_nbsp != NUL)
  	    {
  		c = lcs_nbsp;
! 		attr = HL_ATTR(HLF_8);
  	    }
  	    else if (c == NUL && list && lcs_eol != NUL)
  	    {
***************
*** 1860,1866 ****
  		c_extra = NUL;
  		n_extra = 1;
  		c = lcs_eol;
! 		attr = hl_attr(HLF_AT);
  		--s;
  	    }
  	    else if (c != NUL && (n = byte2cells(c)) > 1)
--- 1860,1866 ----
  		c_extra = NUL;
  		n_extra = 1;
  		c = lcs_eol;
! 		attr = HL_ATTR(HLF_AT);
  		--s;
  	    }
  	    else if (c != NUL && (n = byte2cells(c)) > 1)
***************
*** 1871,1887 ****
  		c = *p_extra++;
  		/* Use special coloring to be able to distinguish <hex> from
  		 * the same in plain text. */
! 		attr = hl_attr(HLF_8);
  	    }
  	    else if (c == ' ' && trail != NULL && s > trail)
  	    {
  		c = lcs_trail;
! 		attr = hl_attr(HLF_8);
  	    }
  	    else if (c == ' ' && list && lcs_space != NUL)
  	    {
  		c = lcs_space;
! 		attr = hl_attr(HLF_8);
  	    }
  	}
  
--- 1871,1887 ----
  		c = *p_extra++;
  		/* Use special coloring to be able to distinguish <hex> from
  		 * the same in plain text. */
! 		attr = HL_ATTR(HLF_8);
  	    }
  	    else if (c == ' ' && trail != NULL && s > trail)
  	    {
  		c = lcs_trail;
! 		attr = HL_ATTR(HLF_8);
  	    }
  	    else if (c == ' ' && list && lcs_space != NUL)
  	    {
  		c = lcs_space;
! 		attr = HL_ATTR(HLF_8);
  	    }
  	}
  
***************
*** 1913,1919 ****
  		msg_col == Columns - 1))
      {
  	/* Doesn't fit, print a highlighted '>' to fill it up. */
! 	msg_screen_putchar('>', hl_attr(HLF_AT));
  	return s;
      }
  
--- 1913,1919 ----
  		msg_col == Columns - 1))
      {
  	/* Doesn't fit, print a highlighted '>' to fill it up. */
! 	msg_screen_putchar('>', HL_ATTR(HLF_AT));
  	return s;
      }
  
***************
*** 1956,1962 ****
  msg_puts_title(
      char_u	*s)
  {
!     msg_puts_attr(s, hl_attr(HLF_T));
  }
  
  /*
--- 1956,1962 ----
  msg_puts_title(
      char_u	*s)
  {
!     msg_puts_attr(s, HL_ATTR(HLF_T));
  }
  
  /*
***************
*** 1981,1987 ****
      {
  	slen = (room - 3) / 2;
  	msg_outtrans_len_attr(longstr, slen, attr);
! 	msg_puts_attr((char_u *)"...", hl_attr(HLF_8));
      }
      msg_outtrans_len_attr(longstr + len - slen, slen, attr);
  }
--- 1981,1987 ----
      {
  	slen = (room - 3) / 2;
  	msg_outtrans_len_attr(longstr, slen, attr);
! 	msg_puts_attr((char_u *)"...", HL_ATTR(HLF_8));
      }
      msg_outtrans_len_attr(longstr + len - slen, slen, attr);
  }
***************
*** 3067,3073 ****
      int		attr;
      char_u	*s = (char_u *)_("-- More --");
  
!     attr = hl_attr(HLF_M);
      screen_puts(s, (int)Rows - 1, 0, attr);
      if (full)
  	screen_puts((char_u *)
--- 3067,3073 ----
      int		attr;
      char_u	*s = (char_u *)_("-- More --");
  
!     attr = HL_ATTR(HLF_M);
      screen_puts(s, (int)Rows - 1, 0, attr);
      if (full)
  	screen_puts((char_u *)
***************
*** 3420,3426 ****
      vim_free(keep_msg);
      keep_msg = NULL;
      if (hl)
! 	keep_msg_attr = hl_attr(HLF_W);
      else
  	keep_msg_attr = 0;
      if (msg_attr(message, keep_msg_attr) && msg_scrolled == 0)
--- 3420,3426 ----
      vim_free(keep_msg);
      keep_msg = NULL;
      if (hl)
! 	keep_msg_attr = HL_ATTR(HLF_W);
      else
  	keep_msg_attr = 0;
      if (msg_attr(message, keep_msg_attr) && msg_scrolled == 0)
***************
*** 3812,3818 ****
      /* avoid that 'q' at the more prompt truncates the message here */
      ++confirm_msg_used;
      if (confirm_msg != NULL)
! 	msg_puts_attr(confirm_msg, hl_attr(HLF_M));
      --confirm_msg_used;
  }
  
--- 3812,3818 ----
      /* avoid that 'q' at the more prompt truncates the message here */
      ++confirm_msg_used;
      if (confirm_msg != NULL)
! 	msg_puts_attr(confirm_msg, HL_ATTR(HLF_M));
      --confirm_msg_used;
  }
  
*** ../vim-8.0.0465/src/misc1.c	2017-03-12 20:09:59.480468291 +0100
--- src/misc1.c	2017-03-16 16:46:15.392050196 +0100
***************
*** 3265,3272 ****
  	msg_start();
  	if (msg_row == Rows - 1)
  	    msg_col = col;
! 	msg_source(hl_attr(HLF_W));
! 	MSG_PUTS_ATTR(_(w_readonly), hl_attr(HLF_W) | MSG_HIST);
  #ifdef FEAT_EVAL
  	set_vim_var_string(VV_WARNINGMSG, (char_u *)_(w_readonly), -1);
  #endif
--- 3265,3272 ----
  	msg_start();
  	if (msg_row == Rows - 1)
  	    msg_col = col;
! 	msg_source(HL_ATTR(HLF_W));
! 	MSG_PUTS_ATTR(_(w_readonly), HL_ATTR(HLF_W) | MSG_HIST);
  #ifdef FEAT_EVAL
  	set_vim_var_string(VV_WARNINGMSG, (char_u *)_(w_readonly), -1);
  #endif
***************
*** 3319,3325 ****
      while (r != 'y' && r != 'n')
      {
  	/* same highlighting as for wait_return */
! 	smsg_attr(hl_attr(HLF_R), (char_u *)"%s (y/n)?", str);
  	if (direct)
  	    r = get_keystroke();
  	else
--- 3319,3325 ----
      while (r != 'y' && r != 'n')
      {
  	/* same highlighting as for wait_return */
! 	smsg_attr(HL_ATTR(HLF_R), (char_u *)"%s (y/n)?", str);
  	if (direct)
  	    r = get_keystroke();
  	else
***************
*** 3701,3708 ****
  	 * function give the user a hint where the beep comes from. */
  	if (vim_strchr(p_debug, 'e') != NULL)
  	{
! 	    msg_source(hl_attr(HLF_W));
! 	    msg_attr((char_u *)_("Beep!"), hl_attr(HLF_W));
  	}
      }
  }
--- 3701,3708 ----
  	 * function give the user a hint where the beep comes from. */
  	if (vim_strchr(p_debug, 'e') != NULL)
  	{
! 	    msg_source(HL_ATTR(HLF_W));
! 	    msg_attr((char_u *)_("Beep!"), HL_ATTR(HLF_W));
  	}
      }
  }
*** ../vim-8.0.0465/src/normal.c	2017-03-12 20:09:59.480468291 +0100
--- src/normal.c	2017-03-16 16:46:19.356021424 +0100
***************
*** 3266,3272 ****
  
      if (full_screen)
      {
! 	if (!did_check && hl_attr(HLF_V) == 0)
  	    MSG(_("Warning: terminal cannot highlight"));
  	did_check = TRUE;
      }
--- 3266,3272 ----
  
      if (full_screen)
      {
! 	if (!did_check && HL_ATTR(HLF_V) == 0)
  	    MSG(_("Warning: terminal cannot highlight"));
  	did_check = TRUE;
      }
*** ../vim-8.0.0465/src/ops.c	2017-03-12 20:37:16.836943099 +0100
--- src/ops.c	2017-03-16 16:46:22.939995411 +0100
***************
*** 4112,4118 ****
  
      if (arg != NULL && *arg == NUL)
  	arg = NULL;
!     attr = hl_attr(HLF_8);
  
      /* Highlight title */
      MSG_PUTS_TITLE(_("\n--- Registers ---"));
--- 4112,4118 ----
  
      if (arg != NULL && *arg == NUL)
  	arg = NULL;
!     attr = HL_ATTR(HLF_8);
  
      /* Highlight title */
      MSG_PUTS_TITLE(_("\n--- Registers ---"));
*** ../vim-8.0.0465/src/option.c	2017-03-12 20:09:59.484468262 +0100
--- src/option.c	2017-03-16 16:46:30.211942629 +0100
***************
*** 8556,8563 ****
  	    {
  		static char *w_arabic = N_("W17: Arabic requires UTF-8, do ':set encoding=utf-8'");
  
! 		msg_source(hl_attr(HLF_W));
! 		MSG_ATTR(_(w_arabic), hl_attr(HLF_W));
  #ifdef FEAT_EVAL
  		set_vim_var_string(VV_WARNINGMSG, (char_u *)_(w_arabic), -1);
  #endif
--- 8556,8563 ----
  	    {
  		static char *w_arabic = N_("W17: Arabic requires UTF-8, do ':set encoding=utf-8'");
  
! 		msg_source(HL_ATTR(HLF_W));
! 		MSG_ATTR(_(w_arabic), HL_ATTR(HLF_W));
  #ifdef FEAT_EVAL
  		set_vim_var_string(VV_WARNINGMSG, (char_u *)_(w_arabic), -1);
  #endif
*** ../vim-8.0.0465/src/quickfix.c	2017-03-12 20:09:59.484468262 +0100
--- src/quickfix.c	2017-03-16 16:46:36.847894464 +0100
***************
*** 2555,2561 ****
  		vim_snprintf((char *)IObuff, IOSIZE, "%2d %s",
  							    i, (char *)fname);
  	    msg_outtrans_attr(IObuff, i == qi->qf_lists[qi->qf_curlist].qf_index
! 					   ? hl_attr(HLF_L) : hl_attr(HLF_D));
  	    if (qfp->qf_lnum == 0)
  		IObuff[0] = NUL;
  	    else if (qfp->qf_col == 0)
--- 2555,2561 ----
  		vim_snprintf((char *)IObuff, IOSIZE, "%2d %s",
  							    i, (char *)fname);
  	    msg_outtrans_attr(IObuff, i == qi->qf_lists[qi->qf_curlist].qf_index
! 					   ? HL_ATTR(HLF_L) : HL_ATTR(HLF_D));
  	    if (qfp->qf_lnum == 0)
  		IObuff[0] = NUL;
  	    else if (qfp->qf_col == 0)
***************
*** 2565,2571 ****
  						   qfp->qf_lnum, qfp->qf_col);
  	    sprintf((char *)IObuff + STRLEN(IObuff), "%s:",
  				  (char *)qf_types(qfp->qf_type, qfp->qf_nr));
! 	    msg_puts_attr(IObuff, hl_attr(HLF_N));
  	    if (qfp->qf_pattern != NULL)
  	    {
  		qf_fmt_text(qfp->qf_pattern, IObuff, IOSIZE);
--- 2565,2571 ----
  						   qfp->qf_lnum, qfp->qf_col);
  	    sprintf((char *)IObuff + STRLEN(IObuff), "%s:",
  				  (char *)qf_types(qfp->qf_type, qfp->qf_nr));
! 	    msg_puts_attr(IObuff, HL_ATTR(HLF_N));
  	    if (qfp->qf_pattern != NULL)
  	    {
  		qf_fmt_text(qfp->qf_pattern, IObuff, IOSIZE);
*** ../vim-8.0.0465/src/screen.c	2017-03-12 21:31:54.289925047 +0100
--- src/screen.c	2017-03-16 16:47:27.155529306 +0100
***************
*** 2139,2148 ****
  	     * Last line isn't finished: Display "@@@" in the last screen line.
  	     */
  	    screen_puts_len((char_u *)"@@", 2, scr_row, W_WINCOL(wp),
! 							      hl_attr(HLF_AT));
  	    screen_fill(scr_row, scr_row + 1,
  		    (int)W_WINCOL(wp) + 2, (int)W_ENDCOL(wp),
! 		    '@', ' ', hl_attr(HLF_AT));
  	    set_empty_rows(wp, srow);
  	    wp->w_botline = lnum;
  	}
--- 2139,2148 ----
  	     * Last line isn't finished: Display "@@@" in the last screen line.
  	     */
  	    screen_puts_len((char_u *)"@@", 2, scr_row, W_WINCOL(wp),
! 							      HL_ATTR(HLF_AT));
  	    screen_fill(scr_row, scr_row + 1,
  		    (int)W_WINCOL(wp) + 2, (int)W_ENDCOL(wp),
! 		    '@', ' ', HL_ATTR(HLF_AT));
  	    set_empty_rows(wp, srow);
  	    wp->w_botline = lnum;
  	}
***************
*** 2154,2160 ****
  	    screen_fill(W_WINROW(wp) + wp->w_height - 1,
  		    W_WINROW(wp) + wp->w_height,
  		    (int)W_ENDCOL(wp) - 3, (int)W_ENDCOL(wp),
! 		    '@', '@', hl_attr(HLF_AT));
  	    set_empty_rows(wp, srow);
  	    wp->w_botline = lnum;
  	}
--- 2154,2160 ----
  	    screen_fill(W_WINROW(wp) + wp->w_height - 1,
  		    W_WINROW(wp) + wp->w_height,
  		    (int)W_ENDCOL(wp) - 3, (int)W_ENDCOL(wp),
! 		    '@', '@', HL_ATTR(HLF_AT));
  	    set_empty_rows(wp, srow);
  	    wp->w_botline = lnum;
  	}
***************
*** 2282,2288 ****
  		n = W_WIDTH(wp);
  	    screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
  		    W_ENDCOL(wp) - n, (int)W_ENDCOL(wp),
! 		    ' ', ' ', hl_attr(HLF_FC));
  	}
  # endif
  # ifdef FEAT_SIGNS
--- 2282,2288 ----
  		n = W_WIDTH(wp);
  	    screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
  		    W_ENDCOL(wp) - n, (int)W_ENDCOL(wp),
! 		    ' ', ' ', HL_ATTR(HLF_FC));
  	}
  # endif
  # ifdef FEAT_SIGNS
***************
*** 2295,2310 ****
  		nn = W_WIDTH(wp);
  	    screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
  		    W_ENDCOL(wp) - nn, (int)W_ENDCOL(wp) - n,
! 		    ' ', ' ', hl_attr(HLF_SC));
  	    n = nn;
  	}
  # endif
  	screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
  		W_WINCOL(wp), W_ENDCOL(wp) - 1 - FDC_OFF,
! 		c2, c2, hl_attr(hl));
  	screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
  		W_ENDCOL(wp) - 1 - FDC_OFF, W_ENDCOL(wp) - FDC_OFF,
! 		c1, c2, hl_attr(hl));
      }
      else
  #endif
--- 2295,2310 ----
  		nn = W_WIDTH(wp);
  	    screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
  		    W_ENDCOL(wp) - nn, (int)W_ENDCOL(wp) - n,
! 		    ' ', ' ', HL_ATTR(HLF_SC));
  	    n = nn;
  	}
  # endif
  	screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
  		W_WINCOL(wp), W_ENDCOL(wp) - 1 - FDC_OFF,
! 		c2, c2, HL_ATTR(hl));
  	screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
  		W_ENDCOL(wp) - 1 - FDC_OFF, W_ENDCOL(wp) - FDC_OFF,
! 		c1, c2, HL_ATTR(hl));
      }
      else
  #endif
***************
*** 2318,2324 ****
  		n = wp->w_width;
  	    screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
  		    W_WINCOL(wp), (int)W_WINCOL(wp) + n,
! 		    cmdwin_type, ' ', hl_attr(HLF_AT));
  	}
  #endif
  #ifdef FEAT_FOLDING
--- 2318,2324 ----
  		n = wp->w_width;
  	    screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
  		    W_WINCOL(wp), (int)W_WINCOL(wp) + n,
! 		    cmdwin_type, ' ', HL_ATTR(HLF_AT));
  	}
  #endif
  #ifdef FEAT_FOLDING
***************
*** 2331,2337 ****
  		nn = W_WIDTH(wp);
  	    screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
  		    W_WINCOL(wp) + n, (int)W_WINCOL(wp) + nn,
! 		    ' ', ' ', hl_attr(HLF_FC));
  	    n = nn;
  	}
  #endif
--- 2331,2337 ----
  		nn = W_WIDTH(wp);
  	    screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
  		    W_WINCOL(wp) + n, (int)W_WINCOL(wp) + nn,
! 		    ' ', ' ', HL_ATTR(HLF_FC));
  	    n = nn;
  	}
  #endif
***************
*** 2345,2357 ****
  		nn = W_WIDTH(wp);
  	    screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
  		    W_WINCOL(wp) + n, (int)W_WINCOL(wp) + nn,
! 		    ' ', ' ', hl_attr(HLF_SC));
  	    n = nn;
  	}
  #endif
  	screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
  		W_WINCOL(wp) + FDC_OFF, (int)W_ENDCOL(wp),
! 		c1, c2, hl_attr(hl));
      }
      set_empty_rows(wp, row);
  }
--- 2345,2357 ----
  		nn = W_WIDTH(wp);
  	    screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
  		    W_WINCOL(wp) + n, (int)W_WINCOL(wp) + nn,
! 		    ' ', ' ', HL_ATTR(HLF_SC));
  	    n = nn;
  	}
  #endif
  	screen_fill(W_WINROW(wp) + row, W_WINROW(wp) + endrow,
  		W_WINCOL(wp) + FDC_OFF, (int)W_ENDCOL(wp),
! 		c1, c2, HL_ATTR(hl));
      }
      set_empty_rows(wp, row);
  }
***************
*** 2428,2434 ****
      if (cmdwin_type != 0 && wp == curwin)
      {
  	ScreenLines[off] = cmdwin_type;
! 	ScreenAttrs[off] = hl_attr(HLF_AT);
  #ifdef FEAT_MBYTE
  	if (enc_utf8)
  	    ScreenLinesUC[off] = 0;
--- 2428,2434 ----
      if (cmdwin_type != 0 && wp == curwin)
      {
  	ScreenLines[off] = cmdwin_type;
! 	ScreenAttrs[off] = HL_ATTR(HLF_AT);
  #ifdef FEAT_MBYTE
  	if (enc_utf8)
  	    ScreenLinesUC[off] = 0;
***************
*** 2451,2464 ****
  	    int		i;
  
  	    copy_text_attr(off + W_WIDTH(wp) - fdc - col, buf, fdc,
! 							     hl_attr(HLF_FC));
  	    /* reverse the fold column */
  	    for (i = 0; i < fdc; ++i)
  		ScreenLines[off + W_WIDTH(wp) - i - 1 - col] = buf[i];
  	}
  	else
  #endif
! 	    copy_text_attr(off + col, buf, fdc, hl_attr(HLF_FC));
  	col += fdc;
      }
  
--- 2451,2464 ----
  	    int		i;
  
  	    copy_text_attr(off + W_WIDTH(wp) - fdc - col, buf, fdc,
! 							     HL_ATTR(HLF_FC));
  	    /* reverse the fold column */
  	    for (i = 0; i < fdc; ++i)
  		ScreenLines[off + W_WIDTH(wp) - i - 1 - col] = buf[i];
  	}
  	else
  #endif
! 	    copy_text_attr(off + col, buf, fdc, HL_ATTR(HLF_FC));
  	col += fdc;
      }
  
***************
*** 2476,2482 ****
  
      /* Set all attributes of the 'number' or 'relativenumber' column and the
       * text */
!     RL_MEMSET(col, hl_attr(HLF_FL), W_WIDTH(wp) - col);
  
  #ifdef FEAT_SIGNS
      /* If signs are being displayed, add two spaces. */
--- 2476,2482 ----
  
      /* Set all attributes of the 'number' or 'relativenumber' column and the
       * text */
!     RL_MEMSET(col, HL_ATTR(HLF_FL), W_WIDTH(wp) - col);
  
  #ifdef FEAT_SIGNS
      /* If signs are being displayed, add two spaces. */
***************
*** 2491,2500 ****
  	    if (wp->w_p_rl)
  		/* the line number isn't reversed */
  		copy_text_attr(off + W_WIDTH(wp) - len - col,
! 					(char_u *)"  ", len, hl_attr(HLF_FL));
  	    else
  # endif
! 		copy_text_attr(off + col, (char_u *)"  ", len, hl_attr(HLF_FL));
  	    col += len;
  	}
      }
--- 2491,2500 ----
  	    if (wp->w_p_rl)
  		/* the line number isn't reversed */
  		copy_text_attr(off + W_WIDTH(wp) - len - col,
! 					(char_u *)"  ", len, HL_ATTR(HLF_FL));
  	    else
  # endif
! 		copy_text_attr(off + col, (char_u *)"  ", len, HL_ATTR(HLF_FL));
  	    col += len;
  	}
      }
***************
*** 2536,2545 ****
  	    if (wp->w_p_rl)
  		/* the line number isn't reversed */
  		copy_text_attr(off + W_WIDTH(wp) - len - col, buf, len,
! 							     hl_attr(HLF_FL));
  	    else
  #endif
! 		copy_text_attr(off + col, buf, len, hl_attr(HLF_FL));
  	    col += len;
  	}
      }
--- 2536,2545 ----
  	    if (wp->w_p_rl)
  		/* the line number isn't reversed */
  		copy_text_attr(off + W_WIDTH(wp) - len - col, buf, len,
! 							     HL_ATTR(HLF_FL));
  	    else
  #endif
! 		copy_text_attr(off + col, buf, len, HL_ATTR(HLF_FL));
  	    col += len;
  	}
      }
***************
*** 2748,2761 ****
  			len = wp->w_old_cursor_lcol;
  		    else
  			len = W_WIDTH(wp) - txtcol;
! 		    RL_MEMSET(wp->w_old_cursor_fcol + txtcol, hl_attr(HLF_V),
  					    len - (int)wp->w_old_cursor_fcol);
  		}
  	    }
  	    else
  	    {
  		/* Set all attributes of the text */
! 		RL_MEMSET(txtcol, hl_attr(HLF_V), W_WIDTH(wp) - txtcol);
  	    }
  	}
      }
--- 2748,2761 ----
  			len = wp->w_old_cursor_lcol;
  		    else
  			len = W_WIDTH(wp) - txtcol;
! 		    RL_MEMSET(wp->w_old_cursor_fcol + txtcol, HL_ATTR(HLF_V),
  					    len - (int)wp->w_old_cursor_fcol);
  		}
  	    }
  	    else
  	    {
  		/* Set all attributes of the text */
! 		RL_MEMSET(txtcol, HL_ATTR(HLF_V), W_WIDTH(wp) - txtcol);
  	    }
  	}
      }
***************
*** 2777,2783 ****
  		txtcol -= wp->w_leftcol;
  	    if (txtcol >= 0 && txtcol < W_WIDTH(wp))
  		ScreenAttrs[off + txtcol] = hl_combine_attr(
! 				    ScreenAttrs[off + txtcol], hl_attr(HLF_MC));
  	    txtcol = old_txtcol;
  	    j = wp->w_p_cc_cols[++i];
  	}
--- 2777,2783 ----
  		txtcol -= wp->w_leftcol;
  	    if (txtcol >= 0 && txtcol < W_WIDTH(wp))
  		ScreenAttrs[off + txtcol] = hl_combine_attr(
! 				    ScreenAttrs[off + txtcol], HL_ATTR(HLF_MC));
  	    txtcol = old_txtcol;
  	    j = wp->w_p_cc_cols[++i];
  	}
***************
*** 2793,2799 ****
  	    txtcol -= wp->w_leftcol;
  	if (txtcol >= 0 && txtcol < W_WIDTH(wp))
  	    ScreenAttrs[off + txtcol] = hl_combine_attr(
! 				 ScreenAttrs[off + txtcol], hl_attr(HLF_CUC));
      }
  #endif
  
--- 2793,2799 ----
  	    txtcol -= wp->w_leftcol;
  	if (txtcol >= 0 && txtcol < W_WIDTH(wp))
  	    ScreenAttrs[off + txtcol] = hl_combine_attr(
! 				 ScreenAttrs[off + txtcol], HL_ATTR(HLF_CUC));
      }
  #endif
  
***************
*** 3063,3069 ****
      int		syntax_flags	= 0;
      int		syntax_seqnr	= 0;
      int		prev_syntax_id	= 0;
!     int		conceal_attr	= hl_attr(HLF_CONCEAL);
      int		is_concealing	= FALSE;
      int		boguscols	= 0;	/* nonexistent columns added to force
  					   wrapping */
--- 3063,3069 ----
      int		syntax_flags	= 0;
      int		syntax_seqnr	= 0;
      int		prev_syntax_id	= 0;
!     int		conceal_attr	= HL_ATTR(HLF_CONCEAL);
      int		is_concealing	= FALSE;
      int		boguscols	= 0;	/* nonexistent columns added to force
  					   wrapping */
***************
*** 3243,3255 ****
  	if (fromcol >= 0)
  	{
  	    area_highlighting = TRUE;
! 	    attr = hl_attr(HLF_V);
  #if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)
  	    if ((clip_star.available && !clip_star.owned
  						     && clip_isautosel_star())
  		    || (clip_plus.available && !clip_plus.owned
  						    && clip_isautosel_plus()))
! 		attr = hl_attr(HLF_VNC);
  #endif
  	}
      }
--- 3243,3255 ----
  	if (fromcol >= 0)
  	{
  	    area_highlighting = TRUE;
! 	    attr = HL_ATTR(HLF_V);
  #if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)
  	    if ((clip_star.available && !clip_star.owned
  						     && clip_isautosel_star())
  		    || (clip_plus.available && !clip_plus.owned
  						    && clip_isautosel_plus()))
! 		attr = HL_ATTR(HLF_VNC);
  #endif
  	}
      }
***************
*** 3279,3285 ****
  	if (fromcol == tocol)
  	    tocol = fromcol + 1;
  	area_highlighting = TRUE;
! 	attr = hl_attr(HLF_I);
      }
  
  #ifdef FEAT_DIFF
--- 3279,3285 ----
  	if (fromcol == tocol)
  	    tocol = fromcol + 1;
  	area_highlighting = TRUE;
! 	attr = HL_ATTR(HLF_I);
      }
  
  #ifdef FEAT_DIFF
***************
*** 3315,3321 ****
  # if defined(FEAT_QUICKFIX) && defined(FEAT_WINDOWS)
      /* Highlight the current line in the quickfix window. */
      if (bt_quickfix(wp->w_buffer) && qf_current_entry(wp) == lnum)
! 	line_attr = hl_attr(HLF_L);
  # endif
      if (line_attr != 0)
  	area_highlighting = TRUE;
--- 3315,3321 ----
  # if defined(FEAT_QUICKFIX) && defined(FEAT_WINDOWS)
      /* Highlight the current line in the quickfix window. */
      if (bt_quickfix(wp->w_buffer) && qf_current_entry(wp) == lnum)
! 	line_attr = HL_ATTR(HLF_L);
  # endif
      if (line_attr != 0)
  	area_highlighting = TRUE;
***************
*** 3592,3598 ****
      if (wp->w_p_cul && lnum == wp->w_cursor.lnum
  					 && !(wp == curwin && VIsual_active))
      {
! 	line_attr = hl_attr(HLF_CUL);
  	area_highlighting = TRUE;
      }
  #endif
--- 3592,3598 ----
      if (wp->w_p_cul && lnum == wp->w_cursor.lnum
  					 && !(wp == curwin && VIsual_active))
      {
! 	line_attr = HL_ATTR(HLF_CUL);
  	area_highlighting = TRUE;
      }
  #endif
***************
*** 3630,3636 ****
  		    /* Draw the cmdline character. */
  		    n_extra = 1;
  		    c_extra = cmdwin_type;
! 		    char_attr = hl_attr(HLF_AT);
  		}
  	    }
  #endif
--- 3630,3636 ----
  		    /* Draw the cmdline character. */
  		    n_extra = 1;
  		    c_extra = cmdwin_type;
! 		    char_attr = HL_ATTR(HLF_AT);
  		}
  	    }
  #endif
***************
*** 3655,3661 ****
  			p_extra_free[n_extra] = NUL;
  			p_extra = p_extra_free;
  			c_extra = NUL;
! 			char_attr = hl_attr(HLF_FC);
  		    }
  		}
  	    }
--- 3655,3661 ----
  			p_extra_free[n_extra] = NUL;
  			p_extra = p_extra_free;
  			c_extra = NUL;
! 			char_attr = HL_ATTR(HLF_FC);
  		    }
  		}
  	    }
***************
*** 3676,3682 ****
  
  		    /* Draw two cells with the sign value or blank. */
  		    c_extra = ' ';
! 		    char_attr = hl_attr(HLF_SC);
  		    n_extra = 2;
  
  		    if (row == startrow
--- 3676,3682 ----
  
  		    /* Draw two cells with the sign value or blank. */
  		    c_extra = ' ';
! 		    char_attr = HL_ATTR(HLF_SC);
  		    n_extra = 2;
  
  		    if (row == startrow
***************
*** 3769,3775 ****
  		    else
  			c_extra = ' ';
  		    n_extra = number_width(wp) + 1;
! 		    char_attr = hl_attr(HLF_N);
  #ifdef FEAT_SYN_HL
  		    /* When 'cursorline' is set highlight the line number of
  		     * the current line differently.
--- 3769,3775 ----
  		    else
  			c_extra = ' ';
  		    n_extra = number_width(wp) + 1;
! 		    char_attr = HL_ATTR(HLF_N);
  #ifdef FEAT_SYN_HL
  		    /* When 'cursorline' is set highlight the line number of
  		     * the current line differently.
***************
*** 3777,3783 ****
  		     * when CursorLineNr isn't set? */
  		    if ((wp->w_p_cul || wp->w_p_rnu)
  						 && lnum == wp->w_cursor.lnum)
! 			char_attr = hl_attr(HLF_CLN);
  #endif
  		}
  	    }
--- 3777,3783 ----
  		     * when CursorLineNr isn't set? */
  		    if ((wp->w_p_cul || wp->w_p_rnu)
  						 && lnum == wp->w_cursor.lnum)
! 			char_attr = HL_ATTR(HLF_CLN);
  #endif
  		}
  	    }
***************
*** 3807,3817 ****
  # ifdef FEAT_DIFF
  		    if (diff_hlf != (hlf_T)0)
  		    {
! 			char_attr = hl_attr(diff_hlf);
  #  ifdef FEAT_SYN_HL
  			if (wp->w_p_cul && lnum == wp->w_cursor.lnum)
  			    char_attr = hl_combine_attr(char_attr,
! 							    hl_attr(HLF_CUL));
  #  endif
  		    }
  # endif
--- 3807,3817 ----
  # ifdef FEAT_DIFF
  		    if (diff_hlf != (hlf_T)0)
  		    {
! 			char_attr = HL_ATTR(diff_hlf);
  #  ifdef FEAT_SYN_HL
  			if (wp->w_p_cul && lnum == wp->w_cursor.lnum)
  			    char_attr = hl_combine_attr(char_attr,
! 							    HL_ATTR(HLF_CUL));
  #  endif
  		    }
  # endif
***************
*** 3845,3851 ****
  		    else
  #  endif
  			n_extra = W_WIDTH(wp) - col;
! 		    char_attr = hl_attr(HLF_DED);
  		}
  # endif
  # ifdef FEAT_LINEBREAK
--- 3845,3851 ----
  		    else
  #  endif
  			n_extra = W_WIDTH(wp) - col;
! 		    char_attr = HL_ATTR(HLF_DED);
  		}
  # endif
  # ifdef FEAT_LINEBREAK
***************
*** 3855,3861 ****
  		    p_extra = p_sbr;
  		    c_extra = NUL;
  		    n_extra = (int)STRLEN(p_sbr);
! 		    char_attr = hl_attr(HLF_AT);
  		    need_showbreak = FALSE;
  		    vcol_sbr = vcol + MB_CHARLEN(p_sbr);
  		    /* Correct end of highlighted area for 'showbreak',
--- 3855,3861 ----
  		    p_extra = p_sbr;
  		    c_extra = NUL;
  		    n_extra = (int)STRLEN(p_sbr);
! 		    char_attr = HL_ATTR(HLF_AT);
  		    need_showbreak = FALSE;
  		    vcol_sbr = vcol + MB_CHARLEN(p_sbr);
  		    /* Correct end of highlighted area for 'showbreak',
***************
*** 3866,3872 ****
  		    /* combine 'showbreak' with 'cursorline' */
  		    if (wp->w_p_cul && lnum == wp->w_cursor.lnum)
  			char_attr = hl_combine_attr(char_attr,
! 							    hl_attr(HLF_CUL));
  #endif
  		}
  # endif
--- 3866,3872 ----
  		    /* combine 'showbreak' with 'cursorline' */
  		    if (wp->w_p_cul && lnum == wp->w_cursor.lnum)
  			char_attr = hl_combine_attr(char_attr,
! 							    HL_ATTR(HLF_CUL));
  #endif
  		}
  # endif
***************
*** 4061,4069 ****
  		if (diff_hlf == HLF_TXD && ptr - line > change_end
  							      && n_extra == 0)
  		    diff_hlf = HLF_CHD;		/* changed line */
! 		line_attr = hl_attr(diff_hlf);
  		if (wp->w_p_cul && lnum == wp->w_cursor.lnum)
! 		    line_attr = hl_combine_attr(line_attr, hl_attr(HLF_CUL));
  	    }
  #endif
  
--- 4061,4069 ----
  		if (diff_hlf == HLF_TXD && ptr - line > change_end
  							      && n_extra == 0)
  		    diff_hlf = HLF_CHD;		/* changed line */
! 		line_attr = HL_ATTR(diff_hlf);
  		if (wp->w_p_cul && lnum == wp->w_cursor.lnum)
! 		    line_attr = hl_combine_attr(line_attr, HL_ATTR(HLF_CUL));
  	    }
  #endif
  
***************
*** 4173,4179 ****
  			mb_c = c;
  			mb_l = 1;
  			mb_utf8 = FALSE;
! 			multi_attr = hl_attr(HLF_AT);
  			/* put the pointer back to output the double-width
  			 * character at the start of the next line. */
  			++n_extra;
--- 4173,4179 ----
  			mb_c = c;
  			mb_l = 1;
  			mb_utf8 = FALSE;
! 			multi_attr = HL_ATTR(HLF_AT);
  			/* put the pointer back to output the double-width
  			 * character at the start of the next line. */
  			++n_extra;
***************
*** 4284,4290 ****
  			if (area_attr == 0 && search_attr == 0)
  			{
  			    n_attr = n_extra + 1;
! 			    extra_attr = hl_attr(HLF_8);
  			    saved_attr2 = char_attr; /* save current attr */
  			}
  		    }
--- 4284,4290 ----
  			if (area_attr == 0 && search_attr == 0)
  			{
  			    n_attr = n_extra + 1;
! 			    extra_attr = HL_ATTR(HLF_8);
  			    saved_attr2 = char_attr; /* save current attr */
  			}
  		    }
***************
*** 4353,4359 ****
  			    if (area_attr == 0 && search_attr == 0)
  			    {
  				n_attr = n_extra + 1;
! 				extra_attr = hl_attr(HLF_8);
  				saved_attr2 = char_attr; /* save current attr */
  			    }
  			    mb_c = c;
--- 4353,4359 ----
  			    if (area_attr == 0 && search_attr == 0)
  			    {
  				n_attr = n_extra + 1;
! 				extra_attr = HL_ATTR(HLF_8);
  				saved_attr2 = char_attr; /* save current attr */
  			    }
  			    mb_c = c;
***************
*** 4374,4380 ****
  		    mb_c = c;
  		    mb_utf8 = FALSE;
  		    mb_l = 1;
! 		    multi_attr = hl_attr(HLF_AT);
  		    /* Put pointer back so that the character will be
  		     * displayed at the start of the next line. */
  		    --ptr;
--- 4374,4380 ----
  		    mb_c = c;
  		    mb_utf8 = FALSE;
  		    mb_l = 1;
! 		    multi_attr = HL_ATTR(HLF_AT);
  		    /* Put pointer back so that the character will be
  		     * displayed at the start of the next line. */
  		    --ptr;
***************
*** 4393,4399 ****
  		    if (area_attr == 0 && search_attr == 0)
  		    {
  			n_attr = n_extra + 1;
! 			extra_attr = hl_attr(HLF_AT);
  			saved_attr2 = char_attr; /* save current attr */
  		    }
  		    mb_c = c;
--- 4393,4399 ----
  		    if (area_attr == 0 && search_attr == 0)
  		    {
  			n_attr = n_extra + 1;
! 			extra_attr = HL_ATTR(HLF_AT);
  			saved_attr2 = char_attr; /* save current attr */
  		    }
  		    mb_c = c;
***************
*** 4604,4610 ****
  		    if (area_attr == 0 && search_attr == 0)
  		    {
  			n_attr = 1;
! 			extra_attr = hl_attr(HLF_8);
  			saved_attr2 = char_attr; /* save current attr */
  		    }
  #ifdef FEAT_MBYTE
--- 4604,4610 ----
  		    if (area_attr == 0 && search_attr == 0)
  		    {
  			n_attr = 1;
! 			extra_attr = HL_ATTR(HLF_8);
  			saved_attr2 = char_attr; /* save current attr */
  		    }
  #ifdef FEAT_MBYTE
***************
*** 4626,4632 ****
  		    if (!attr_pri)
  		    {
  			n_attr = 1;
! 			extra_attr = hl_attr(HLF_8);
  			saved_attr2 = char_attr; /* save current attr */
  		    }
  #ifdef FEAT_MBYTE
--- 4626,4632 ----
  		    if (!attr_pri)
  		    {
  			n_attr = 1;
! 			extra_attr = HL_ATTR(HLF_8);
  			saved_attr2 = char_attr; /* save current attr */
  		    }
  #ifdef FEAT_MBYTE
***************
*** 4758,4764 ****
  #endif
  			    c_extra = lcs_tab2;
  			n_attr = tab_len + 1;
! 			extra_attr = hl_attr(HLF_8);
  			saved_attr2 = char_attr; /* save current attr */
  #ifdef FEAT_MBYTE
  			mb_c = c;
--- 4758,4764 ----
  #endif
  			    c_extra = lcs_tab2;
  			n_attr = tab_len + 1;
! 			extra_attr = HL_ATTR(HLF_8);
  			saved_attr2 = char_attr; /* save current attr */
  #ifdef FEAT_MBYTE
  			mb_c = c;
***************
*** 4831,4837 ****
  		    --ptr;	    /* put it back at the NUL */
  		    if (!attr_pri)
  		    {
! 			extra_attr = hl_attr(HLF_AT);
  			n_attr = 1;
  		    }
  #ifdef FEAT_MBYTE
--- 4831,4837 ----
  		    --ptr;	    /* put it back at the NUL */
  		    if (!attr_pri)
  		    {
! 			extra_attr = HL_ATTR(HLF_AT);
  			n_attr = 1;
  		    }
  #ifdef FEAT_MBYTE
***************
*** 4878,4884 ****
  		    if (!attr_pri)
  		    {
  			n_attr = n_extra + 1;
! 			extra_attr = hl_attr(HLF_8);
  			saved_attr2 = char_attr; /* save current attr */
  		    }
  #ifdef FEAT_MBYTE
--- 4878,4884 ----
  		    if (!attr_pri)
  		    {
  			n_attr = n_extra + 1;
! 			extra_attr = HL_ATTR(HLF_8);
  			saved_attr2 = char_attr; /* save current attr */
  		    }
  #ifdef FEAT_MBYTE
***************
*** 4934,4943 ****
  			diff_hlf = HLF_CHD;
  			if (attr == 0 || char_attr != attr)
  			{
! 			    char_attr = hl_attr(diff_hlf);
  			    if (wp->w_p_cul && lnum == wp->w_cursor.lnum)
  				char_attr = hl_combine_attr(char_attr,
! 							    hl_attr(HLF_CUL));
  			}
  		    }
  # endif
--- 4934,4943 ----
  			diff_hlf = HLF_CHD;
  			if (attr == 0 || char_attr != attr)
  			{
! 			    char_attr = HL_ATTR(diff_hlf);
  			    if (wp->w_p_cul && lnum == wp->w_cursor.lnum)
  				char_attr = hl_combine_attr(char_attr,
! 							    HL_ATTR(HLF_CUL));
  			}
  		    }
  # endif
***************
*** 5104,5110 ****
  		c_extra = MB_FILLER_CHAR;
  		n_extra = 1;
  		n_attr = 2;
! 		extra_attr = hl_attr(HLF_AT);
  	    }
  	    mb_c = c;
  	    if (enc_utf8 && (*mb_char2len)(c) > 1)
--- 5104,5110 ----
  		c_extra = MB_FILLER_CHAR;
  		n_extra = 1;
  		n_attr = 2;
! 		extra_attr = HL_ATTR(HLF_AT);
  	    }
  	    mb_c = c;
  	    if (enc_utf8 && (*mb_char2len)(c) > 1)
***************
*** 5119,5125 ****
  	    if (!attr_pri)
  	    {
  		saved_attr3 = char_attr; /* save current attr */
! 		char_attr = hl_attr(HLF_AT); /* later copied to char_attr */
  		n_attr3 = 1;
  	    }
  	}
--- 5119,5125 ----
  	    if (!attr_pri)
  	    {
  		saved_attr3 = char_attr; /* save current attr */
! 		char_attr = HL_ATTR(HLF_AT); /* later copied to char_attr */
  		n_attr3 = 1;
  	    }
  	}
***************
*** 5326,5334 ****
  								 &color_cols);
  
  		    if (wp->w_p_cuc && VCOL_HLC == (long)wp->w_virtcol)
! 			ScreenAttrs[off++] = hl_attr(HLF_CUC);
  		    else if (draw_color_col && VCOL_HLC == *color_cols)
! 			ScreenAttrs[off++] = hl_attr(HLF_MC);
  		    else
  			ScreenAttrs[off++] = 0;
  
--- 5326,5334 ----
  								 &color_cols);
  
  		    if (wp->w_p_cuc && VCOL_HLC == (long)wp->w_virtcol)
! 			ScreenAttrs[off++] = HL_ATTR(HLF_CUC);
  		    else if (draw_color_col && VCOL_HLC == *color_cols)
! 			ScreenAttrs[off++] = HL_ATTR(HLF_MC);
  		    else
  			ScreenAttrs[off++] = 0;
  
***************
*** 5377,5383 ****
  		    || (n_extra && (c_extra != NUL || *p_extra != NUL))))
  	{
  	    c = lcs_ext;
! 	    char_attr = hl_attr(HLF_AT);
  #ifdef FEAT_MBYTE
  	    mb_c = c;
  	    if (enc_utf8 && (*mb_char2len)(c) > 1)
--- 5377,5383 ----
  		    || (n_extra && (c_extra != NUL || *p_extra != NUL))))
  	{
  	    c = lcs_ext;
! 	    char_attr = HL_ATTR(HLF_AT);
  #ifdef FEAT_MBYTE
  	    mb_c = c;
  	    if (enc_utf8 && (*mb_char2len)(c) > 1)
***************
*** 5407,5418 ****
  						 && lnum != wp->w_cursor.lnum)
  	    {
  		vcol_save_attr = char_attr;
! 		char_attr = hl_combine_attr(char_attr, hl_attr(HLF_CUC));
  	    }
  	    else if (draw_color_col && VCOL_HLC == *color_cols)
  	    {
  		vcol_save_attr = char_attr;
! 		char_attr = hl_combine_attr(char_attr, hl_attr(HLF_MC));
  	    }
  	}
  #endif
--- 5407,5418 ----
  						 && lnum != wp->w_cursor.lnum)
  	    {
  		vcol_save_attr = char_attr;
! 		char_attr = hl_combine_attr(char_attr, HL_ATTR(HLF_CUC));
  	    }
  	    else if (draw_color_col && VCOL_HLC == *color_cols)
  	    {
  		vcol_save_attr = char_attr;
! 		char_attr = hl_combine_attr(char_attr, HL_ATTR(HLF_MC));
  	    }
  	}
  #endif
***************
*** 6649,6655 ****
  	if (selstart != NULL && highlight)
  	{
  	    *selend = NUL;
! 	    screen_puts(selstart, row, selstart_col, hl_attr(HLF_WM));
  	}
  
  	screen_fill(row, row + 1, clen, (int)Columns, fillchar, fillchar, attr);
--- 6649,6655 ----
  	if (selstart != NULL && highlight)
  	{
  	    *selend = NUL;
! 	    screen_puts(selstart, row, selstart_col, HL_ATTR(HLF_WM));
  	}
  
  	screen_fill(row, row + 1, clen, (int)Columns, fillchar, fillchar, attr);
***************
*** 6975,6981 ****
  	stl = p_tal;
  	row = 0;
  	fillchar = ' ';
! 	attr = hl_attr(HLF_TPF);
  	maxwidth = Columns;
  # ifdef FEAT_EVAL
  	use_sandbox = was_set_insecurely((char_u *)"tabline", 0);
--- 6975,6981 ----
  	stl = p_tal;
  	row = 0;
  	fillchar = ' ';
! 	attr = HL_ATTR(HLF_TPF);
  	maxwidth = Columns;
  # ifdef FEAT_EVAL
  	use_sandbox = was_set_insecurely((char_u *)"tabline", 0);
***************
*** 7322,7328 ****
  		{
  		    u8c = (mbyte_cells == 2) ? 0xff1f : (int)'?';
  		    if (attr == 0)
! 			attr = hl_attr(HLF_8);
  		}
  # endif
  # ifdef FEAT_ARABIC
--- 7322,7328 ----
  		{
  		    u8c = (mbyte_cells == 2) ? 0xff1f : (int)'?';
  		    if (attr == 0)
! 			attr = HL_ATTR(HLF_8);
  		}
  # endif
  # ifdef FEAT_ARABIC
***************
*** 7525,7531 ****
      if (p_hls && !no_hlsearch)
      {
  	last_pat_prog(&search_hl.rm);
! 	search_hl.attr = hl_attr(HLF_L);
  # ifdef FEAT_RELTIME
  	/* Set the time limit to 'redrawtime'. */
  	profile_setlimit(p_rdt, &search_hl.tm);
--- 7525,7531 ----
      if (p_hls && !no_hlsearch)
      {
  	last_pat_prog(&search_hl.rm);
! 	search_hl.attr = HL_ATTR(HLF_L);
  # ifdef FEAT_RELTIME
  	/* Set the time limit to 'redrawtime'. */
  	profile_setlimit(p_rdt, &search_hl.tm);
***************
*** 10095,10101 ****
  	/* Position on the last line in the window, column 0 */
  	msg_pos_mode();
  	cursor_off();
! 	attr = hl_attr(HLF_CM);			/* Highlight mode */
  	if (do_mode)
  	{
  	    MSG_PUTS_ATTR("--", attr);
--- 10095,10101 ----
  	/* Position on the last line in the window, column 0 */
  	msg_pos_mode();
  	cursor_off();
! 	attr = HL_ATTR(HLF_CM);			/* Highlight mode */
  	if (do_mode)
  	{
  	    MSG_PUTS_ATTR("--", attr);
***************
*** 10149,10155 ****
  		    {
  			MSG_PUTS_ATTR(" ", attr);  /* add a space in between */
  			if ((int)edit_submode_highl < (int)HLF_COUNT)
! 			    sub_attr = hl_attr(edit_submode_highl);
  			else
  			    sub_attr = attr;
  			msg_puts_attr(edit_submode_extra, sub_attr);
--- 10149,10155 ----
  		    {
  			MSG_PUTS_ATTR(" ", attr);  /* add a space in between */
  			if ((int)edit_submode_highl < (int)HLF_COUNT)
! 			    sub_attr = HL_ATTR(edit_submode_highl);
  			else
  			    sub_attr = attr;
  			msg_puts_attr(edit_submode_extra, sub_attr);
***************
*** 10306,10312 ****
  {
      msg_pos_mode();
      if (Recording)
! 	recording_mode(hl_attr(HLF_CM));
      msg_clr_eos();
  }
  
--- 10306,10312 ----
  {
      msg_pos_mode();
      if (Recording)
! 	recording_mode(HL_ATTR(HLF_CM));
      msg_clr_eos();
  }
  
***************
*** 10341,10349 ****
      int		modified;
      int		c;
      int		len;
!     int		attr_sel = hl_attr(HLF_TPS);
!     int		attr_nosel = hl_attr(HLF_TP);
!     int		attr_fill = hl_attr(HLF_TPF);
      char_u	*p;
      int		room;
      int		use_sep_chars = (t_colors < 8
--- 10341,10349 ----
      int		modified;
      int		c;
      int		len;
!     int		attr_sel = HL_ATTR(HLF_TPS);
!     int		attr_nosel = HL_ATTR(HLF_TP);
!     int		attr_fill = HL_ATTR(HLF_TPF);
      char_u	*p;
      int		room;
      int		use_sep_chars = (t_colors < 8
***************
*** 10444,10450 ****
  			break;
  		    screen_puts_len(NameBuff, len, 0, col,
  #if defined(FEAT_SYN_HL)
! 					 hl_combine_attr(attr, hl_attr(HLF_T))
  #else
  					 attr
  #endif
--- 10444,10450 ----
  			break;
  		    screen_puts_len(NameBuff, len, 0, col,
  #if defined(FEAT_SYN_HL)
! 					 hl_combine_attr(attr, HL_ATTR(HLF_T))
  #else
  					 attr
  #endif
***************
*** 10537,10554 ****
      int fill;
      if (is_curwin)
      {
! 	*attr = hl_attr(HLF_S);
  	fill = fill_stl;
      }
      else
      {
! 	*attr = hl_attr(HLF_SNC);
  	fill = fill_stlnc;
      }
      /* Use fill when there is highlighting, and highlighting of current
       * window differs, or the fillchars differ, or this is not the
       * current window */
!     if (*attr != 0 && ((hl_attr(HLF_S) != hl_attr(HLF_SNC)
  			|| !is_curwin || ONE_WINDOW)
  		    || (fill_stl != fill_stlnc)))
  	return fill;
--- 10537,10554 ----
      int fill;
      if (is_curwin)
      {
! 	*attr = HL_ATTR(HLF_S);
  	fill = fill_stl;
      }
      else
      {
! 	*attr = HL_ATTR(HLF_SNC);
  	fill = fill_stlnc;
      }
      /* Use fill when there is highlighting, and highlighting of current
       * window differs, or the fillchars differ, or this is not the
       * current window */
!     if (*attr != 0 && ((HL_ATTR(HLF_S) != HL_ATTR(HLF_SNC)
  			|| !is_curwin || ONE_WINDOW)
  		    || (fill_stl != fill_stlnc)))
  	return fill;
***************
*** 10566,10572 ****
      static int
  fillchar_vsep(int *attr)
  {
!     *attr = hl_attr(HLF_C);
      if (*attr == 0 && fill_vert == ' ')
  	return '|';
      else
--- 10566,10572 ----
      static int
  fillchar_vsep(int *attr)
  {
!     *attr = HL_ATTR(HLF_C);
      if (*attr == 0 && fill_vert == ' ')
  	return '|';
      else
*** ../vim-8.0.0465/src/search.c	2017-03-12 20:09:59.488468234 +0100
--- src/search.c	2017-03-16 16:47:34.299477433 +0100
***************
*** 5013,5019 ****
  		    {
  			/* using "new_fname" is more reliable, e.g., when
  			 * 'includeexpr' is set. */
! 			msg_outtrans_attr(new_fname, hl_attr(HLF_D));
  		    }
  		    else
  		    {
--- 5013,5019 ----
  		    {
  			/* using "new_fname" is more reliable, e.g., when
  			 * 'includeexpr' is set. */
! 			msg_outtrans_attr(new_fname, HL_ATTR(HLF_D));
  		    }
  		    else
  		    {
***************
*** 5059,5065 ****
  			}
  			save_char = p[i];
  			p[i] = NUL;
! 			msg_outtrans_attr(p, hl_attr(HLF_D));
  			p[i] = save_char;
  		    }
  
--- 5059,5065 ----
  			}
  			save_char = p[i];
  			p[i] = NUL;
! 			msg_outtrans_attr(p, HL_ATTR(HLF_D));
  			p[i] = save_char;
  		    }
  
***************
*** 5124,5130 ****
  			vim_snprintf((char*)IObuff, IOSIZE,
  				_("Scanning included file: %s"),
  				(char *)new_fname);
! 			msg_trunc_attr(IObuff, TRUE, hl_attr(HLF_R));
  		    }
  		    else
  #endif
--- 5124,5130 ----
  			vim_snprintf((char*)IObuff, IOSIZE,
  				_("Scanning included file: %s"),
  				(char *)new_fname);
! 			msg_trunc_attr(IObuff, TRUE, HL_ATTR(HLF_R));
  		    }
  		    else
  #endif
***************
*** 5572,5578 ****
  	    msg_puts(IObuff);
  	    sprintf((char *)IObuff, "%4ld", *lnum);	/* show line nr */
  						/* Highlight line numbers */
! 	    msg_puts_attr(IObuff, hl_attr(HLF_N));
  	    MSG_PUTS(" ");
  	}
  	msg_prt_line(line, FALSE);
--- 5572,5578 ----
  	    msg_puts(IObuff);
  	    sprintf((char *)IObuff, "%4ld", *lnum);	/* show line nr */
  						/* Highlight line numbers */
! 	    msg_puts_attr(IObuff, HL_ATTR(HLF_N));
  	    MSG_PUTS(" ");
  	}
  	msg_prt_line(line, FALSE);
*** ../vim-8.0.0465/src/syntax.c	2017-03-12 20:09:59.492468205 +0100
--- src/syntax.c	2017-03-16 16:47:43.919407472 +0100
***************
*** 4070,4076 ****
  		    {0, NULL}
  		};
  
!     attr = hl_attr(HLF_D);		/* highlight like directories */
  
      /* list the keywords for "id" */
      if (!syncing)
--- 4070,4076 ----
  		    {0, NULL}
  		};
  
!     attr = HL_ATTR(HLF_D);		/* highlight like directories */
  
      /* list the keywords for "id" */
      if (!syncing)
***************
*** 4181,4191 ****
      if (SYN_CLSTR(curwin->w_s)[id].scl_list != NULL)
      {
  	put_id_list((char_u *)"cluster", SYN_CLSTR(curwin->w_s)[id].scl_list,
! 		    hl_attr(HLF_D));
      }
      else
      {
! 	msg_puts_attr((char_u *)"cluster", hl_attr(HLF_D));
  	msg_puts((char_u *)"=NONE");
      }
  }
--- 4181,4191 ----
      if (SYN_CLSTR(curwin->w_s)[id].scl_list != NULL)
      {
  	put_id_list((char_u *)"cluster", SYN_CLSTR(curwin->w_s)[id].scl_list,
! 		    HL_ATTR(HLF_D));
      }
      else
      {
! 	msg_puts_attr((char_u *)"cluster", HL_ATTR(HLF_D));
  	msg_puts((char_u *)"=NONE");
      }
  }
***************
*** 8999,9005 ****
      {
  	(void)syn_list_header(didh, 9999, id);
  	didh = TRUE;
! 	msg_puts_attr((char_u *)"links to", hl_attr(HLF_D));
  	msg_putchar(' ');
  	msg_outtrans(HL_TABLE()[HL_TABLE()[id - 1].sg_link - 1].sg_name);
      }
--- 8999,9005 ----
      {
  	(void)syn_list_header(didh, 9999, id);
  	didh = TRUE;
! 	msg_puts_attr((char_u *)"links to", HL_ATTR(HLF_D));
  	msg_putchar(' ');
  	msg_outtrans(HL_TABLE()[HL_TABLE()[id - 1].sg_link - 1].sg_name);
      }
***************
*** 9056,9063 ****
  	{
  	    if (*name != NUL)
  	    {
! 		MSG_PUTS_ATTR(name, hl_attr(HLF_D));
! 		MSG_PUTS_ATTR("=", hl_attr(HLF_D));
  	    }
  	    msg_outtrans(ts);
  	}
--- 9056,9063 ----
  	{
  	    if (*name != NUL)
  	    {
! 		MSG_PUTS_ATTR(name, HL_ATTR(HLF_D));
! 		MSG_PUTS_ATTR("=", HL_ATTR(HLF_D));
  	    }
  	    msg_outtrans(ts);
  	}
***************
*** 9457,9463 ****
  	{
  	    /* This is an error, but since there previously was no check only
  	     * give a warning. */
! 	    msg_source(hl_attr(HLF_W));
  	    MSG(_("W18: Invalid character in group name"));
  	    break;
  	}
--- 9457,9463 ----
  	{
  	    /* This is an error, but since there previously was no check only
  	     * give a warning. */
! 	    msg_source(HL_ATTR(HLF_W));
  	    MSG(_("W18: Invalid character in group name"));
  	    break;
  	}
***************
*** 9932,9938 ****
      int		i;
  
      for (i = 10; --i >= 0; )
! 	highlight_list_two(i, hl_attr(HLF_D));
      for (i = 40; --i >= 0; )
  	highlight_list_two(99, 0);
  }
--- 9932,9938 ----
      int		i;
  
      for (i = 10; --i >= 0; )
! 	highlight_list_two(i, HL_ATTR(HLF_D));
      for (i = 40; --i >= 0; )
  	highlight_list_two(99, 0);
  }
*** ../vim-8.0.0465/src/tag.c	2017-03-12 20:09:59.492468205 +0100
--- src/tag.c	2017-03-16 16:47:51.703350864 +0100
***************
*** 605,614 ****
  		if (msg_col == 0)
  		    msg_didout = FALSE;	/* overwrite previous message */
  		msg_start();
! 		MSG_PUTS_ATTR(_("  # pri kind tag"), hl_attr(HLF_T));
  		msg_clr_eos();
  		taglen_advance(taglen);
! 		MSG_PUTS_ATTR(_("file\n"), hl_attr(HLF_T));
  
  		for (i = 0; i < num_matches && !got_int; ++i)
  		{
--- 605,614 ----
  		if (msg_col == 0)
  		    msg_didout = FALSE;	/* overwrite previous message */
  		msg_start();
! 		MSG_PUTS_ATTR(_("  # pri kind tag"), HL_ATTR(HLF_T));
  		msg_clr_eos();
  		taglen_advance(taglen);
! 		MSG_PUTS_ATTR(_("file\n"), HL_ATTR(HLF_T));
  
  		for (i = 0; i < num_matches && !got_int; ++i)
  		{
***************
*** 633,639 ****
  		    msg_advance(13);
  		    msg_outtrans_len_attr(tagp.tagname,
  				       (int)(tagp.tagname_end - tagp.tagname),
! 							      hl_attr(HLF_T));
  		    msg_putchar(' ');
  		    taglen_advance(taglen);
  
--- 633,639 ----
  		    msg_advance(13);
  		    msg_outtrans_len_attr(tagp.tagname,
  				       (int)(tagp.tagname_end - tagp.tagname),
! 							      HL_ATTR(HLF_T));
  		    msg_putchar(' ');
  		    taglen_advance(taglen);
  
***************
*** 642,648 ****
  		    p = tag_full_fname(&tagp);
  		    if (p != NULL)
  		    {
! 			msg_puts_long_attr(p, hl_attr(HLF_D));
  			vim_free(p);
  		    }
  		    if (msg_col > 0)
--- 642,648 ----
  		    p = tag_full_fname(&tagp);
  		    if (p != NULL)
  		    {
! 			msg_puts_long_attr(p, HL_ATTR(HLF_D));
  			vim_free(p);
  		    }
  		    if (msg_col > 0)
***************
*** 677,683 ****
  				continue;
  			    }
  			    /* print all other extra fields */
! 			    attr = hl_attr(HLF_CM);
  			    while (*p && *p != '\r' && *p != '\n')
  			    {
  				if (msg_col + ptr2cells(p) >= Columns)
--- 677,683 ----
  				continue;
  			    }
  			    /* print all other extra fields */
! 			    attr = HL_ATTR(HLF_CM);
  			    while (*p && *p != '\r' && *p != '\n')
  			    {
  				if (msg_col + ptr2cells(p) >= Columns)
***************
*** 1003,1009 ****
  							   && num_matches > 1)
  		{
  		    if (ic)
! 			msg_attr(IObuff, hl_attr(HLF_W));
  		    else
  			msg(IObuff);
  		    msg_scroll = TRUE;	/* don't overwrite this message */
--- 1003,1009 ----
  							   && num_matches > 1)
  		{
  		    if (ic)
! 			msg_attr(IObuff, HL_ATTR(HLF_W));
  		    else
  			msg(IObuff);
  		    msg_scroll = TRUE;	/* don't overwrite this message */
***************
*** 1140,1146 ****
  		tagstack[i].fmark.mark.lnum);
  	    msg_outtrans(IObuff);
  	    msg_outtrans_attr(name, tagstack[i].fmark.fnum == curbuf->b_fnum
! 							? hl_attr(HLF_D) : 0);
  	    vim_free(name);
  	}
  	out_flush();		    /* show one line at a time */
--- 1140,1146 ----
  		tagstack[i].fmark.mark.lnum);
  	    msg_outtrans(IObuff);
  	    msg_outtrans_attr(name, tagstack[i].fmark.fnum == curbuf->b_fnum
! 							? HL_ATTR(HLF_D) : 0);
  	    vim_free(name);
  	}
  	out_flush();		    /* show one line at a time */
*** ../vim-8.0.0465/src/term.c	2017-01-24 15:57:51.494922147 +0100
--- src/term.c	2017-03-16 17:07:41.734694525 +0100
***************
*** 1565,1573 ****
  	    /* get output strings */
  		for (i = 0; string_names[i].name != NULL; ++i)
  		{
! 		    if (term_str(string_names[i].dest) == NULL
! 			    || term_str(string_names[i].dest) == empty_option)
! 			term_str(string_names[i].dest) =
  					   TGETSTR(string_names[i].name, &tp);
  		}
  
--- 1565,1573 ----
  	    /* get output strings */
  		for (i = 0; string_names[i].name != NULL; ++i)
  		{
! 		    if (TERM_STR(string_names[i].dest) == NULL
! 			    || TERM_STR(string_names[i].dest) == empty_option)
! 			TERM_STR(string_names[i].dest) =
  					   TGETSTR(string_names[i].name, &tp);
  		}
  
***************
*** 1619,1626 ****
  		/*
  		 * Get number of colors (if not done already).
  		 */
! 		if (term_str(KS_CCO) == NULL
! 			|| term_str(KS_CCO) == empty_option)
  		    set_color_count(tgetnum("Co"));
  
  # ifndef hpux
--- 1619,1626 ----
  		/*
  		 * Get number of colors (if not done already).
  		 */
! 		if (TERM_STR(KS_CCO) == NULL
! 			|| TERM_STR(KS_CCO) == empty_option)
  		    set_color_count(tgetnum("Co"));
  
  # ifndef hpux
*** ../vim-8.0.0465/src/term.h	2017-01-21 20:04:17.558757844 +0100
--- src/term.h	2017-03-16 17:08:04.474529026 +0100
***************
*** 92,99 ****
      KS_8B,	/* set background color (RGB) */
      KS_CBE,	/* enable bracketed paste mode */
      KS_CBD,	/* disable bracketed paste mode */
!     KS_CPS,	/* start of brackted paste */
!     KS_CPE	/* end of brackted paste */
  };
  
  #define KS_LAST	    KS_CPE
--- 92,99 ----
      KS_8B,	/* set background color (RGB) */
      KS_CBE,	/* enable bracketed paste mode */
      KS_CBD,	/* disable bracketed paste mode */
!     KS_CPS,	/* start of bracketed paste */
!     KS_CPE	/* end of bracketed paste */
  };
  
  #define KS_LAST	    KS_CPE
***************
*** 111,183 ****
  /*
   * strings used for terminal
   */
! #define T_NAME	(term_str(KS_NAME))	/* terminal name */
! #define T_CE	(term_str(KS_CE))	/* clear to end of line */
! #define T_AL	(term_str(KS_AL))	/* add new blank line */
! #define T_CAL	(term_str(KS_CAL))	/* add number of blank lines */
! #define T_DL	(term_str(KS_DL))	/* delete line */
! #define T_CDL	(term_str(KS_CDL))	/* delete number of lines */
! #define T_CS	(term_str(KS_CS))	/* scroll region */
! #define T_CSV	(term_str(KS_CSV))	/* scroll region vertical */
! #define T_CL	(term_str(KS_CL))	/* clear screen */
! #define T_CD	(term_str(KS_CD))	/* clear to end of display */
! #define T_UT	(term_str(KS_UT))	/* clearing uses background color */
! #define T_DA	(term_str(KS_DA))	/* text may be scrolled down from up */
! #define T_DB	(term_str(KS_DB))	/* text may be scrolled up from down */
! #define T_VI	(term_str(KS_VI))	/* cursor invisible */
! #define T_VE	(term_str(KS_VE))	/* cursor visible */
! #define T_VS	(term_str(KS_VS))	/* cursor very visible */
! #define T_ME	(term_str(KS_ME))	/* normal mode */
! #define T_MR	(term_str(KS_MR))	/* reverse mode */
! #define T_MD	(term_str(KS_MD))	/* bold mode */
! #define T_SE	(term_str(KS_SE))	/* normal mode */
! #define T_SO	(term_str(KS_SO))	/* standout mode */
! #define T_CZH	(term_str(KS_CZH))	/* italic mode start */
! #define T_CZR	(term_str(KS_CZR))	/* italic mode end */
! #define T_UE	(term_str(KS_UE))	/* exit underscore (underline) mode */
! #define T_US	(term_str(KS_US))	/* underscore (underline) mode */
! #define T_UCE	(term_str(KS_UCE))	/* exit undercurl mode */
! #define T_UCS	(term_str(KS_UCS))	/* undercurl mode */
! #define T_MS	(term_str(KS_MS))	/* save to move cur in reverse mode */
! #define T_CM	(term_str(KS_CM))	/* cursor motion */
! #define T_SR	(term_str(KS_SR))	/* scroll reverse (backward) */
! #define T_CRI	(term_str(KS_CRI))	/* cursor number of chars right */
! #define T_VB	(term_str(KS_VB))	/* visual bell */
! #define T_KS	(term_str(KS_KS))	/* put term in "keypad transmit" mode */
! #define T_KE	(term_str(KS_KE))	/* out of "keypad transmit" mode */
! #define T_TI	(term_str(KS_TI))	/* put terminal in termcap mode */
! #define T_TE	(term_str(KS_TE))	/* out of termcap mode */
! #define T_BC	(term_str(KS_BC))	/* backspace character */
! #define T_CCS	(term_str(KS_CCS))	/* cur is relative to scroll region */
! #define T_CCO	(term_str(KS_CCO))	/* number of colors */
! #define T_CSF	(term_str(KS_CSF))	/* set foreground color */
! #define T_CSB	(term_str(KS_CSB))	/* set background color */
! #define T_XS	(term_str(KS_XS))	/* standout not erased by overwriting */
! #define T_XN	(term_str(KS_XN))	/* newline glitch */
! #define T_MB	(term_str(KS_MB))	/* blink mode */
! #define T_CAF	(term_str(KS_CAF))	/* set foreground color (ANSI) */
! #define T_CAB	(term_str(KS_CAB))	/* set background color (ANSI) */
! #define T_LE	(term_str(KS_LE))	/* cursor left */
! #define T_ND	(term_str(KS_ND))	/* cursor right */
! #define T_CIS	(term_str(KS_CIS))	/* set icon text start */
! #define T_CIE	(term_str(KS_CIE))	/* set icon text end */
! #define T_TS	(term_str(KS_TS))	/* set window title start */
! #define T_FS	(term_str(KS_FS))	/* set window title end */
! #define T_CWP	(term_str(KS_CWP))	/* window position */
! #define T_CWS	(term_str(KS_CWS))	/* window size */
! #define T_CSI	(term_str(KS_CSI))	/* start insert mode */
! #define T_CEI	(term_str(KS_CEI))	/* end insert mode */
! #define T_CSR	(term_str(KS_CSR))	/* start replace mode */
! #define T_CRV	(term_str(KS_CRV))	/* request version string */
! #define T_RBG	(term_str(KS_RBG))	/* request background RGB */
! #define T_OP	(term_str(KS_OP))	/* original color pair */
! #define T_U7	(term_str(KS_U7))	/* request cursor position */
! #define T_8F	(term_str(KS_8F))	/* set foreground color (RGB) */
! #define T_8B	(term_str(KS_8B))	/* set background color (RGB) */
! #define T_BE	(term_str(KS_CBE))	/* enable bracketed paste mode */
! #define T_BD	(term_str(KS_CBD))	/* disable bracketed paste mode */
! #define T_PS	(term_str(KS_CPS))	/* start of bracketed paste */
! #define T_PE	(term_str(KS_CPE))	/* end of bracketed paste */
  
  #define TMODE_COOK  0	/* terminal mode for external cmds and Ex mode */
  #define TMODE_SLEEP 1	/* terminal mode for sleeping (cooked but no echo) */
--- 111,183 ----
  /*
   * strings used for terminal
   */
! #define T_NAME	(TERM_STR(KS_NAME))	/* terminal name */
! #define T_CE	(TERM_STR(KS_CE))	/* clear to end of line */
! #define T_AL	(TERM_STR(KS_AL))	/* add new blank line */
! #define T_CAL	(TERM_STR(KS_CAL))	/* add number of blank lines */
! #define T_DL	(TERM_STR(KS_DL))	/* delete line */
! #define T_CDL	(TERM_STR(KS_CDL))	/* delete number of lines */
! #define T_CS	(TERM_STR(KS_CS))	/* scroll region */
! #define T_CSV	(TERM_STR(KS_CSV))	/* scroll region vertical */
! #define T_CL	(TERM_STR(KS_CL))	/* clear screen */
! #define T_CD	(TERM_STR(KS_CD))	/* clear to end of display */
! #define T_UT	(TERM_STR(KS_UT))	/* clearing uses background color */
! #define T_DA	(TERM_STR(KS_DA))	/* text may be scrolled down from up */
! #define T_DB	(TERM_STR(KS_DB))	/* text may be scrolled up from down */
! #define T_VI	(TERM_STR(KS_VI))	/* cursor invisible */
! #define T_VE	(TERM_STR(KS_VE))	/* cursor visible */
! #define T_VS	(TERM_STR(KS_VS))	/* cursor very visible */
! #define T_ME	(TERM_STR(KS_ME))	/* normal mode */
! #define T_MR	(TERM_STR(KS_MR))	/* reverse mode */
! #define T_MD	(TERM_STR(KS_MD))	/* bold mode */
! #define T_SE	(TERM_STR(KS_SE))	/* normal mode */
! #define T_SO	(TERM_STR(KS_SO))	/* standout mode */
! #define T_CZH	(TERM_STR(KS_CZH))	/* italic mode start */
! #define T_CZR	(TERM_STR(KS_CZR))	/* italic mode end */
! #define T_UE	(TERM_STR(KS_UE))	/* exit underscore (underline) mode */
! #define T_US	(TERM_STR(KS_US))	/* underscore (underline) mode */
! #define T_UCE	(TERM_STR(KS_UCE))	/* exit undercurl mode */
! #define T_UCS	(TERM_STR(KS_UCS))	/* undercurl mode */
! #define T_MS	(TERM_STR(KS_MS))	/* save to move cur in reverse mode */
! #define T_CM	(TERM_STR(KS_CM))	/* cursor motion */
! #define T_SR	(TERM_STR(KS_SR))	/* scroll reverse (backward) */
! #define T_CRI	(TERM_STR(KS_CRI))	/* cursor number of chars right */
! #define T_VB	(TERM_STR(KS_VB))	/* visual bell */
! #define T_KS	(TERM_STR(KS_KS))	/* put term in "keypad transmit" mode */
! #define T_KE	(TERM_STR(KS_KE))	/* out of "keypad transmit" mode */
! #define T_TI	(TERM_STR(KS_TI))	/* put terminal in termcap mode */
! #define T_TE	(TERM_STR(KS_TE))	/* out of termcap mode */
! #define T_BC	(TERM_STR(KS_BC))	/* backspace character */
! #define T_CCS	(TERM_STR(KS_CCS))	/* cur is relative to scroll region */
! #define T_CCO	(TERM_STR(KS_CCO))	/* number of colors */
! #define T_CSF	(TERM_STR(KS_CSF))	/* set foreground color */
! #define T_CSB	(TERM_STR(KS_CSB))	/* set background color */
! #define T_XS	(TERM_STR(KS_XS))	/* standout not erased by overwriting */
! #define T_XN	(TERM_STR(KS_XN))	/* newline glitch */
! #define T_MB	(TERM_STR(KS_MB))	/* blink mode */
! #define T_CAF	(TERM_STR(KS_CAF))	/* set foreground color (ANSI) */
! #define T_CAB	(TERM_STR(KS_CAB))	/* set background color (ANSI) */
! #define T_LE	(TERM_STR(KS_LE))	/* cursor left */
! #define T_ND	(TERM_STR(KS_ND))	/* cursor right */
! #define T_CIS	(TERM_STR(KS_CIS))	/* set icon text start */
! #define T_CIE	(TERM_STR(KS_CIE))	/* set icon text end */
! #define T_TS	(TERM_STR(KS_TS))	/* set window title start */
! #define T_FS	(TERM_STR(KS_FS))	/* set window title end */
! #define T_CWP	(TERM_STR(KS_CWP))	/* window position */
! #define T_CWS	(TERM_STR(KS_CWS))	/* window size */
! #define T_CSI	(TERM_STR(KS_CSI))	/* start insert mode */
! #define T_CEI	(TERM_STR(KS_CEI))	/* end insert mode */
! #define T_CSR	(TERM_STR(KS_CSR))	/* start replace mode */
! #define T_CRV	(TERM_STR(KS_CRV))	/* request version string */
! #define T_RBG	(TERM_STR(KS_RBG))	/* request background RGB */
! #define T_OP	(TERM_STR(KS_OP))	/* original color pair */
! #define T_U7	(TERM_STR(KS_U7))	/* request cursor position */
! #define T_8F	(TERM_STR(KS_8F))	/* set foreground color (RGB) */
! #define T_8B	(TERM_STR(KS_8B))	/* set background color (RGB) */
! #define T_BE	(TERM_STR(KS_CBE))	/* enable bracketed paste mode */
! #define T_BD	(TERM_STR(KS_CBD))	/* disable bracketed paste mode */
! #define T_PS	(TERM_STR(KS_CPS))	/* start of bracketed paste */
! #define T_PE	(TERM_STR(KS_CPE))	/* end of bracketed paste */
  
  #define TMODE_COOK  0	/* terminal mode for external cmds and Ex mode */
  #define TMODE_SLEEP 1	/* terminal mode for sleeping (cooked but no echo) */
*** ../vim-8.0.0465/src/ui.c	2017-03-12 19:22:31.772584816 +0100
--- src/ui.c	2017-03-16 16:47:57.015312233 +0100
***************
*** 496,502 ****
  					    || get_real_state() == SELECTMODE)
  		    && (cbd == &clip_star ? clip_isautosel_star()
  						      : clip_isautosel_plus())
! 		    && hl_attr(HLF_V) != hl_attr(HLF_VNC))
  		redraw_curbuf_later(INVERTED_ALL);
  	}
      }
--- 496,502 ----
  					    || get_real_state() == SELECTMODE)
  		    && (cbd == &clip_star ? clip_isautosel_star()
  						      : clip_isautosel_plus())
! 		    && HL_ATTR(HLF_V) != HL_ATTR(HLF_VNC))
  		redraw_curbuf_later(INVERTED_ALL);
  	}
      }
***************
*** 534,540 ****
  					    || get_real_state() == SELECTMODE)
  		&& (cbd == &clip_star ?
  				clip_isautosel_star() : clip_isautosel_plus())
! 		&& hl_attr(HLF_V) != hl_attr(HLF_VNC))
  	{
  	    update_curbuf(INVERTED_ALL);
  	    setcursor();
--- 534,540 ----
  					    || get_real_state() == SELECTMODE)
  		&& (cbd == &clip_star ?
  				clip_isautosel_star() : clip_isautosel_plus())
! 		&& HL_ATTR(HLF_V) != HL_ATTR(HLF_VNC))
  	{
  	    update_curbuf(INVERTED_ALL);
  	    setcursor();
*** ../vim-8.0.0465/src/undo.c	2017-03-12 19:22:31.772584816 +0100
--- src/undo.c	2017-03-16 16:48:01.663278431 +0100
***************
*** 3079,3085 ****
  
  	msg_start();
  	msg_puts_attr((char_u *)_("number changes  when               saved"),
! 							      hl_attr(HLF_T));
  	for (i = 0; i < ga.ga_len && !got_int; ++i)
  	{
  	    msg_putchar('\n');
--- 3079,3085 ----
  
  	msg_start();
  	msg_puts_attr((char_u *)_("number changes  when               saved"),
! 							      HL_ATTR(HLF_T));
  	for (i = 0; i < ga.ga_len && !got_int; ++i)
  	{
  	    msg_putchar('\n');
*** ../vim-8.0.0465/src/userfunc.c	2017-03-12 20:09:59.492468205 +0100
--- src/userfunc.c	2017-03-16 16:48:05.695249108 +0100
***************
*** 1494,1500 ****
      MSG_PUTS("function ");
      if (fp->uf_name[0] == K_SPECIAL)
      {
! 	MSG_PUTS_ATTR("<SNR>", hl_attr(HLF_8));
  	msg_puts(fp->uf_name + 3);
      }
      else
--- 1494,1500 ----
      MSG_PUTS("function ");
      if (fp->uf_name[0] == K_SPECIAL)
      {
! 	MSG_PUTS_ATTR("<SNR>", HL_ATTR(HLF_8));
  	msg_puts(fp->uf_name + 3);
      }
      else
*** ../vim-8.0.0465/src/version.c	2017-03-16 15:59:10.688531362 +0100
--- src/version.c	2017-03-16 17:22:24.388270315 +0100
***************
*** 2321,2327 ****
  #endif
  		clen += byte2cells(p[l]);
  	}
! 	screen_puts_len(p, l, row, col, *p == '<' ? hl_attr(HLF_8) : attr);
  	col += clen;
      }
  
--- 2323,2329 ----
  #endif
  		clen += byte2cells(p[l]);
  	}
! 	screen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);
  	col += clen;
      }
  
*** ../vim-8.0.0465/src/vim.h	2017-03-12 20:09:59.456468461 +0100
--- src/vim.h	2017-03-16 17:09:43.229810284 +0100
***************
*** 1761,1768 ****
  /*
   * Enums need a typecast to be used as array index (for Ultrix).
   */
! #define hl_attr(n)	highlight_attr[(int)(n)]
! #define term_str(n)	term_strings[(int)(n)]
  
  /*
   * EXTERN is only defined in main.c.  That's where global variables are
--- 1761,1768 ----
  /*
   * Enums need a typecast to be used as array index (for Ultrix).
   */
! #define HL_ATTR(n)	highlight_attr[(int)(n)]
! #define TERM_STR(n)	term_strings[(int)(n)]
  
  /*
   * EXTERN is only defined in main.c.  That's where global variables are
***************
*** 2076,2088 ****
  typedef int VimClipboard;	/* This is required for the prototypes. */
  #endif
  
- #ifdef __BORLANDC__
- /* work around a bug in the Borland 'stat' function: */
- # include <io.h>	    /* for access() */
- 
- # define stat(a,b) (access(a,0) ? -1 : stat(a,b))
- #endif
- 
  /* Use 64-bit stat structure if available. */
  #if (defined(_MSC_VER) && (_MSC_VER >= 1300)) || defined(__MINGW32__)
  # define HAVE_STAT64
--- 2076,2081 ----
***************
*** 2140,2146 ****
  #include "globals.h"	    /* global variables and messages */
  
  #ifndef FEAT_VIRTUALEDIT
! # define getvvcol(w, p, s, c, e) getvcol(w, p, s, c, e)
  # define virtual_active() FALSE
  # define virtual_op FALSE
  #endif
--- 2133,2139 ----
  #include "globals.h"	    /* global variables and messages */
  
  #ifndef FEAT_VIRTUALEDIT
! # define getvvcol(w, p, s, c, e) getvcol((w), (p), (s), (c), (e))
  # define virtual_active() FALSE
  # define virtual_op FALSE
  #endif
*** ../vim-8.0.0465/src/version.c	2017-03-16 15:59:10.688531362 +0100
--- src/version.c	2017-03-16 17:22:24.388270315 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     466,
  /**/

-- 
Birthdays are healthy.  The more you have them, the longer you live.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0467
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0467
Problem:    Using g< after :for does not show the right output. (Marcin
            Szamotulski)
Solution:   Call msg_sb_eol() in :echomsg.
Files:      src/eval.c


*** ../vim-8.0.0466/src/eval.c	2017-03-12 20:09:59.464468404 +0100
--- src/eval.c	2017-03-16 17:49:42.396314850 +0100
***************
*** 8319,8324 ****
--- 8319,8333 ----
  
      if (ret != FAIL && ga.ga_data != NULL)
      {
+ 	if (eap->cmdidx == CMD_echomsg || eap->cmdidx == CMD_echoerr)
+ 	{
+ 	    /* Mark the already saved text as finishing the line, so that what
+ 	     * follows is displayed on a new line when scrolling back at the
+ 	     * more prompt. */
+ 	    msg_sb_eol();
+ 	    msg_start();
+ 	}
+ 
  	if (eap->cmdidx == CMD_echomsg)
  	{
  	    MSG_ATTR(ga.ga_data, echo_attr);
*** ../vim-8.0.0466/src/version.c	2017-03-16 17:23:26.839815753 +0100
--- src/version.c	2017-03-16 19:03:27.183967172 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     467,
  /**/

-- 
"The sun oozed over the horizon, shoved aside darkness, crept along the
greensward, and, with sickly fingers, pushed through the castle window,
revealing the pillaged princess, hand at throat, crown asunder, gaping
in frenzied horror at the sated, sodden amphibian lying beside her,
disbelieving the magnitude of the frog's deception, screaming madly,
"You lied!"
    - Winner of the Bulwer-Lytton contest (San Jose State University),
      wherein one writes only the first line of a bad novel

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0468
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0468
Problem:    After aborting an Ex command g< does not work. (Marcin
            Szamotulski)
Solution:   Postpone clearing scrollback messages to until the command line
            has been entered.  Also fix that the screen isn't redrawn if after
            g< the command line is cancelled.
Files:      src/message.c, src/proto/message.pro, src/ex_getln.c, src/misc2.c,
            src/gui.c


*** ../vim-8.0.0467/src/message.c	2017-03-16 17:23:26.827815840 +0100
--- src/message.c	2017-03-16 19:52:22.070812779 +0100
***************
*** 2146,2153 ****
  
  	    inc_msg_scrolled();
  	    need_wait_return = TRUE; /* may need wait_return in main() */
- 	    if (must_redraw < VALID)
- 		must_redraw = VALID;
  	    redraw_cmdline = TRUE;
  	    if (cmdline_row > 0 && !exmode_active)
  		--cmdline_row;
--- 2146,2151 ----
***************
*** 2367,2372 ****
--- 2365,2372 ----
      }
  #endif
      ++msg_scrolled;
+     if (must_redraw < VALID)
+ 	must_redraw = VALID;
  }
  
  /*
***************
*** 2389,2395 ****
  static msgchunk_T *msg_sb_start(msgchunk_T *mps);
  static msgchunk_T *disp_sb_line(int row, msgchunk_T *smp);
  
! static int do_clear_sb_text = FALSE;	/* clear text on next msg */
  
  /*
   * Store part of a printed message for displaying when scrolling back.
--- 2389,2403 ----
  static msgchunk_T *msg_sb_start(msgchunk_T *mps);
  static msgchunk_T *disp_sb_line(int row, msgchunk_T *smp);
  
! typedef enum {
!     SB_CLEAR_NONE = 0,
!     SB_CLEAR_ALL,
!     SB_CLEAR_CMDLINE_BUSY,
!     SB_CLEAR_CMDLINE_DONE
! } sb_clear_T;
! 
! /* When to clear text on next msg. */
! static sb_clear_T do_clear_sb_text = SB_CLEAR_NONE;
  
  /*
   * Store part of a printed message for displaying when scrolling back.
***************
*** 2404,2413 ****
  {
      msgchunk_T	*mp;
  
!     if (do_clear_sb_text)
      {
! 	clear_sb_text();
! 	do_clear_sb_text = FALSE;
      }
  
      if (s > *sb_str)
--- 2412,2422 ----
  {
      msgchunk_T	*mp;
  
!     if (do_clear_sb_text == SB_CLEAR_ALL
! 	    || do_clear_sb_text == SB_CLEAR_CMDLINE_DONE)
      {
! 	clear_sb_text(do_clear_sb_text == SB_CLEAR_ALL);
! 	do_clear_sb_text = SB_CLEAR_NONE;
      }
  
      if (s > *sb_str)
***************
*** 2447,2469 ****
      void
  may_clear_sb_text(void)
  {
!     do_clear_sb_text = TRUE;
  }
  
  /*
   * Clear any text remembered for scrolling back.
   * Called when redrawing the screen.
   */
      void
! clear_sb_text(void)
  {
      msgchunk_T	*mp;
  
!     while (last_msgchunk != NULL)
      {
! 	mp = last_msgchunk->sb_prev;
! 	vim_free(last_msgchunk);
! 	last_msgchunk = mp;
      }
  }
  
--- 2456,2508 ----
      void
  may_clear_sb_text(void)
  {
!     do_clear_sb_text = SB_CLEAR_ALL;
! }
! 
! /*
!  * Starting to edit the command line, do not clear messages now.
!  */
!     void
! sb_text_start_cmdline(void)
! {
!     do_clear_sb_text = SB_CLEAR_CMDLINE_BUSY;
!     msg_sb_eol();
! }
! 
! /*
!  * Ending to edit the command line.  Clear old lines but the last one later.
!  */
!     void
! sb_text_end_cmdline(void)
! {
!     do_clear_sb_text = SB_CLEAR_CMDLINE_DONE;
  }
  
  /*
   * Clear any text remembered for scrolling back.
+  * When "all" is FALSE keep the last line.
   * Called when redrawing the screen.
   */
      void
! clear_sb_text(int all)
  {
      msgchunk_T	*mp;
+     msgchunk_T	**lastp;
+ 
+     if (all)
+ 	lastp = &last_msgchunk;
+     else
+     {
+ 	if (last_msgchunk == NULL)
+ 	    return;
+ 	lastp = &last_msgchunk->sb_prev;
+     }
  
!     while (*lastp != NULL)
      {
! 	mp = (*lastp)->sb_prev;
! 	vim_free(*lastp);
! 	*lastp = mp;
      }
  }
  
*** ../vim-8.0.0467/src/proto/message.pro	2017-03-01 15:07:01.337622045 +0100
--- src/proto/message.pro	2017-03-16 19:30:23.568273613 +0100
***************
*** 52,58 ****
  void msg_puts_attr(char_u *s, int attr);
  int message_filtered(char_u *msg);
  void may_clear_sb_text(void);
! void clear_sb_text(void);
  void show_sb_text(void);
  void msg_sb_eol(void);
  int msg_use_printf(void);
--- 52,60 ----
  void msg_puts_attr(char_u *s, int attr);
  int message_filtered(char_u *msg);
  void may_clear_sb_text(void);
! void sb_text_start_cmdline(void);
! void sb_text_end_cmdline(void);
! void clear_sb_text(int all);
  void show_sb_text(void);
  void msg_sb_eol(void);
  int msg_use_printf(void);
*** ../vim-8.0.0467/src/ex_getln.c	2017-03-16 17:23:26.819815897 +0100
--- src/ex_getln.c	2017-03-16 19:23:12.683362213 +0100
***************
*** 258,263 ****
--- 258,264 ----
  	return NULL;			    /* out of memory */
      ccline.cmdlen = ccline.cmdpos = 0;
      ccline.cmdbuff[0] = NUL;
+     sb_text_start_cmdline();
  
      /* autoindent for :insert and :append */
      if (firstc <= 0)
***************
*** 2083,2088 ****
--- 2084,2090 ----
  #ifdef CURSOR_SHAPE
      ui_cursor_shape();		/* may show different cursor shape */
  #endif
+     sb_text_end_cmdline();
  
      {
  	char_u *p = ccline.cmdbuff;
*** ../vim-8.0.0467/src/misc2.c	2017-03-16 12:22:34.607343466 +0100
--- src/misc2.c	2017-03-16 19:30:07.200391008 +0100
***************
*** 970,976 ****
  	    break;
  	releasing = TRUE;
  
! 	clear_sb_text();	      /* free any scrollback text */
  	try_again = mf_release_all(); /* release as many blocks as possible */
  
  	releasing = FALSE;
--- 970,976 ----
  	    break;
  	releasing = TRUE;
  
! 	clear_sb_text(TRUE);	      /* free any scrollback text */
  	try_again = mf_release_all(); /* release as many blocks as possible */
  
  	releasing = FALSE;
***************
*** 1148,1154 ****
  # ifdef FEAT_DIFF
      diff_clear(curtab);
  # endif
!     clear_sb_text();	      /* free any scrollback text */
  
      /* Free some global vars. */
      vim_free(username);
--- 1148,1154 ----
  # ifdef FEAT_DIFF
      diff_clear(curtab);
  # endif
!     clear_sb_text(TRUE);	      /* free any scrollback text */
  
      /* Free some global vars. */
      vim_free(username);
*** ../vim-8.0.0467/src/gui.c	2017-03-12 20:09:59.472468347 +0100
--- src/gui.c	2017-03-16 19:25:08.930529331 +0100
***************
*** 630,636 ****
       * where Vim was started. */
      emsg_on_display = FALSE;
      msg_scrolled = 0;
!     clear_sb_text();
      need_wait_return = FALSE;
      msg_didany = FALSE;
  
--- 630,636 ----
       * where Vim was started. */
      emsg_on_display = FALSE;
      msg_scrolled = 0;
!     clear_sb_text(TRUE);
      need_wait_return = FALSE;
      msg_didany = FALSE;
  
*** ../vim-8.0.0467/src/version.c	2017-03-16 19:04:15.271616151 +0100
--- src/version.c	2017-03-16 19:55:52.261307187 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     468,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
134. You consider bandwidth to be more important than carats.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0469
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0469
Problem:    Compiler warnings on MS-Windows.
Solution:   Add type casts. (Christian Brabandt)
Files:      src/fold.c


*** ../vim-8.0.0468/src/fold.c	2017-03-16 15:59:10.684531392 +0100
--- src/fold.c	2017-03-16 22:06:37.872827685 +0100
***************
*** 3137,3145 ****
       * order. We have to swap folds in the range [move_end, dest_index) with
       * those in the range [move_start, move_end).
       */
!     foldReverseOrder(gap, move_start, dest_index - 1);
!     foldReverseOrder(gap, move_start, move_start + dest_index - move_end - 1);
!     foldReverseOrder(gap, move_start + dest_index - move_end, dest_index - 1);
  }
  #undef fold_end
  #undef valid_fold
--- 3137,3147 ----
       * order. We have to swap folds in the range [move_end, dest_index) with
       * those in the range [move_start, move_end).
       */
!     foldReverseOrder(gap, (linenr_T)move_start, (linenr_T)dest_index - 1);
!     foldReverseOrder(gap, (linenr_T)move_start,
! 			   (linenr_T)(move_start + dest_index - move_end - 1));
!     foldReverseOrder(gap, (linenr_T)(move_start + dest_index - move_end),
! 						   (linenr_T)(dest_index - 1));
  }
  #undef fold_end
  #undef valid_fold
*** ../vim-8.0.0468/src/version.c	2017-03-16 19:58:19.420253384 +0100
--- src/version.c	2017-03-16 22:05:56.789124414 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     469,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
136. You decide to stay in a low-paying job teaching just for the
     free Internet access.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0470
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0470
Problem:    Not enough testing for help commands.
Solution:   Add a few more help tests. (Dominique Pelle, closes #1565)
Files:      src/testdir/test_help.vim, src/testdir/test_help_tagjump.vim


*** ../vim-8.0.0469/src/testdir/test_help.vim	2017-02-17 12:04:35.843808317 +0100
--- src/testdir/test_help.vim	2017-03-16 22:15:33.452954315 +0100
***************
*** 8,10 ****
--- 8,15 ----
    help
    helpclose
  endfunc
+ 
+ func Test_help_errors()
+   call assert_fails('help doesnotexist', 'E149:')
+   call assert_fails('help!', 'E478:')
+ endfunc
*** ../vim-8.0.0469/src/testdir/test_help_tagjump.vim	2016-12-01 21:32:28.678025257 +0100
--- src/testdir/test_help_tagjump.vim	2017-03-16 22:15:33.452954315 +0100
***************
*** 6,11 ****
--- 6,57 ----
    call assert_true(getline('.') =~ '\*help.txt\*')
    helpclose
  
+   help |
+   call assert_equal("help", &filetype)
+   call assert_true(getline('.') =~ '\*bar\*')
+   helpclose
+ 
+   help "*
+   call assert_equal("help", &filetype)
+   call assert_true(getline('.') =~ '\*quotestar\*')
+   helpclose
+ 
+   help sm?le
+   call assert_equal("help", &filetype)
+   call assert_true(getline('.') =~ '\*:smile\*')
+   helpclose
+ 
+   help :?
+   call assert_equal("help", &filetype)
+   call assert_true(getline('.') =~ '\*:?\*')
+   helpclose
+ 
+   help FileW*Post
+   call assert_equal("help", &filetype)
+   call assert_true(getline('.') =~ '\*FileWritePost\*')
+   helpclose
+ 
+   help `ls`
+   call assert_equal("help", &filetype)
+   call assert_true(getline('.') =~ '\*:ls\*')
+   helpclose
+ 
+   help ^X
+   call assert_equal("help", &filetype)
+   call assert_true(getline('.') =~ '\*CTRL-X\*')
+   helpclose
+ 
+   help i_^_CTRL-D
+   call assert_equal("help", &filetype)
+   call assert_true(getline('.') =~ '\*i_^_CTRL-D\*')
+   helpclose
+ 
+   exec "help \<C-V>"
+   call assert_equal("help", &filetype)
+   call assert_true(getline('.') =~ '\*CTRL-V\*')
+   helpclose
+ 
+ 
    exec "help! ('textwidth'"
    call assert_equal("help", &filetype)
    call assert_true(getline('.') =~ "\\*'textwidth'\\*")
***************
*** 35,40 ****
--- 81,96 ----
    call assert_equal("help", &filetype)
    call assert_true(getline('.') =~ '\*{address}\*')
    helpclose
+ 
+   exusage
+   call assert_equal("help", &filetype)
+   call assert_true(getline('.') =~ '\*:index\*')
+   helpclose
+ 
+   viusage
+   call assert_equal("help", &filetype)
+   call assert_true(getline('.') =~ '\*normal-index\*')
+   helpclose
  endfunc
  
  let s:langs = ['en', 'ab', 'ja']
*** ../vim-8.0.0469/src/version.c	2017-03-16 22:06:51.824726916 +0100
--- src/version.c	2017-03-16 22:16:36.076499048 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     470,
  /**/

-- 
The coffee just wasn't strong enough to defend itself -- Tom Waits

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0471
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0471
Problem:    Exit callback test sometimes fails.
Solution:   Add it to the list of flaky tests.
Files:      src/testdir/runtest.vim


*** ../vim-8.0.0470/src/testdir/runtest.vim	2017-03-09 18:19:58.165107821 +0100
--- src/testdir/runtest.vim	2017-03-16 22:28:38.287251297 +0100
***************
*** 167,172 ****
--- 167,173 ----
        \ 'Test_close_and_exit_cb()',
        \ 'Test_collapse_buffers()',
        \ 'Test_communicate()',
+       \ 'Test_exit_callback_interval()',
        \ 'Test_nb_basic()',
        \ 'Test_oneshot()',
        \ 'Test_pipe_through_sort_all()',
*** ../vim-8.0.0470/src/version.c	2017-03-16 22:26:40.088109843 +0100
--- src/version.c	2017-03-16 22:29:29.350880429 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     471,
  /**/

-- 
Amazing but true: If all the salmon caught in Canada in one year were laid
end to end across the Sahara Desert, the smell would be absolutely awful.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0472
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0472
Problem:    When a test fails and test.log is created, Test_edit_CTRL_I
            matches it instead of test1.in.
Solution:   Match with runtest.vim instead.
Files:      src/testdir/test_edit.vim


*** ../vim-8.0.0471/src/testdir/test_edit.vim	2017-03-09 18:19:58.165107821 +0100
--- src/testdir/test_edit.vim	2017-03-16 22:35:31.440251220 +0100
***************
*** 506,513 ****
    let path=expand("%:p:h")
    new
    call setline(1, [path."/", ''])
!   call feedkeys("Ate\<c-x>\<c-f>\<tab>\<cr>\<esc>", 'tnix')
!   call assert_match('test1\.in', getline(1))
    %d
    call writefile(['one', 'two', 'three'], 'Xinclude.txt')
    let include='#include Xinclude.txt'
--- 506,513 ----
    let path=expand("%:p:h")
    new
    call setline(1, [path."/", ''])
!   call feedkeys("Arunt\<c-x>\<c-f>\<tab>\<cr>\<esc>", 'tnix')
!   call assert_match('runtest\.vim', getline(1))
    %d
    call writefile(['one', 'two', 'three'], 'Xinclude.txt')
    let include='#include Xinclude.txt'
*** ../vim-8.0.0471/src/version.c	2017-03-16 22:30:33.662413374 +0100
--- src/version.c	2017-03-16 22:37:21.639451238 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     472,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
138. You develop a liking for cold coffee.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0473
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0473
Problem:    No test covering arg_all().
Solution:   Add a test expanding ##.
Files:      src/testdir/test_arglist.vim


*** ../vim-8.0.0472/src/testdir/test_arglist.vim	2017-03-09 15:58:26.548668478 +0100
--- src/testdir/test_arglist.vim	2017-03-16 22:52:19.640901511 +0100
***************
*** 90,96 ****
  
  " Test for [count]argument and [count]argdelete commands
  " Ported from the test_argument_count.in test script
! function Test_argument()
    " Clean the argument list
    arga a | %argd
  
--- 90,96 ----
  
  " Test for [count]argument and [count]argdelete commands
  " Ported from the test_argument_count.in test script
! func Test_argument()
    " Clean the argument list
    arga a | %argd
  
***************
*** 162,172 ****
  
    %argdelete
    call assert_fails('argument', 'E163:')
! endfunction
  
  " Test for 0argadd and 0argedit
  " Ported from the test_argument_0count.in test script
! function Test_zero_argadd()
    " Clean the argument list
    arga a | %argd
  
--- 162,172 ----
  
    %argdelete
    call assert_fails('argument', 'E163:')
! endfunc
  
  " Test for 0argadd and 0argedit
  " Ported from the test_argument_0count.in test script
! func Test_zero_argadd()
    " Clean the argument list
    arga a | %argd
  
***************
*** 188,209 ****
    2argu
    arga third
    call assert_equal(['edited', 'a', 'third', 'b', 'c', 'd'], argv())
! endfunction
  
! function Reset_arglist()
    args a | %argd
! endfunction
  
  " Test for argc()
! function Test_argc()
    call Reset_arglist()
    call assert_equal(0, argc())
    argadd a b
    call assert_equal(2, argc())
! endfunction
  
  " Test for arglistid()
! function Test_arglistid()
    call Reset_arglist()
    arga a b
    call assert_equal(0, arglistid())
--- 188,209 ----
    2argu
    arga third
    call assert_equal(['edited', 'a', 'third', 'b', 'c', 'd'], argv())
! endfunc
  
! func Reset_arglist()
    args a | %argd
! endfunc
  
  " Test for argc()
! func Test_argc()
    call Reset_arglist()
    call assert_equal(0, argc())
    argadd a b
    call assert_equal(2, argc())
! endfunc
  
  " Test for arglistid()
! func Test_arglistid()
    call Reset_arglist()
    arga a b
    call assert_equal(0, arglistid())
***************
*** 218,236 ****
    tabonly | only | enew!
    argglobal
    call assert_equal(0, arglistid())
! endfunction
  
  " Test for argv()
! function Test_argv()
    call Reset_arglist()
    call assert_equal([], argv())
    call assert_equal("", argv(2))
    argadd a b c d
    call assert_equal('c', argv(2))
! endfunction
  
  " Test for the :argedit command
! function Test_argedit()
    call Reset_arglist()
    argedit a
    call assert_equal(['a'], argv())
--- 218,236 ----
    tabonly | only | enew!
    argglobal
    call assert_equal(0, arglistid())
! endfunc
  
  " Test for argv()
! func Test_argv()
    call Reset_arglist()
    call assert_equal([], argv())
    call assert_equal("", argv(2))
    argadd a b c d
    call assert_equal('c', argv(2))
! endfunc
  
  " Test for the :argedit command
! func Test_argedit()
    call Reset_arglist()
    argedit a
    call assert_equal(['a'], argv())
***************
*** 254,263 ****
    argedit! y
    call assert_equal(['x', 'y', 'a', 'c', 'b'], argv())
    %argd
! endfunction
  
  " Test for the :argdelete command
! function Test_argdelete()
    call Reset_arglist()
    args aa a aaa b bb
    argdelete a*
--- 254,263 ----
    argedit! y
    call assert_equal(['x', 'y', 'a', 'c', 'b'], argv())
    %argd
! endfunc
  
  " Test for the :argdelete command
! func Test_argdelete()
    call Reset_arglist()
    args aa a aaa b bb
    argdelete a*
***************
*** 269,278 ****
    call assert_fails('argdelete', 'E471:')
    call assert_fails('1,100argdelete', 'E16:')
    %argd
! endfunction
  
  " Tests for the :next, :prev, :first, :last, :rewind commands
! function Test_argpos()
    call Reset_arglist()
    args a b c d
    last
--- 269,278 ----
    call assert_fails('argdelete', 'E471:')
    call assert_fails('1,100argdelete', 'E16:')
    %argd
! endfunc
  
  " Tests for the :next, :prev, :first, :last, :rewind commands
! func Test_argpos()
    call Reset_arglist()
    args a b c d
    last
***************
*** 290,299 ****
    rewind
    call assert_equal(0, argidx())
    %argd
! endfunction
  
  " Test for autocommand that redefines the argument list, when doing ":all".
! function Test_arglist_autocmd()
    autocmd BufReadPost Xxx2 next Xxx2 Xxx1
    call writefile(['test file Xxx1'], 'Xxx1')
    call writefile(['test file Xxx2'], 'Xxx2')
--- 290,299 ----
    rewind
    call assert_equal(0, argidx())
    %argd
! endfunc
  
  " Test for autocommand that redefines the argument list, when doing ":all".
! func Test_arglist_autocmd()
    autocmd BufReadPost Xxx2 next Xxx2 Xxx1
    call writefile(['test file Xxx1'], 'Xxx1')
    call writefile(['test file Xxx2'], 'Xxx2')
***************
*** 319,322 ****
    call delete('Xxx3')
    argdelete Xxx*
    bwipe! Xxx1 Xxx2 Xxx3
! endfunction
--- 319,329 ----
    call delete('Xxx3')
    argdelete Xxx*
    bwipe! Xxx1 Xxx2 Xxx3
! endfunc
! 
! func Test_arg_all_expand()
!   call writefile(['test file Xxx1'], 'Xx x')
!   next notexist Xx\ x runtest.vim
!   call assert_equal('notexist Xx\ x runtest.vim', expand('##'))
!   call delete('Xx x')
! endfunc
*** ../vim-8.0.0472/src/version.c	2017-03-16 22:37:55.995201853 +0100
--- src/version.c	2017-03-16 22:51:08.545427501 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     473,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
139. You down your lunch in five minutes, at your desk, so you can
     spend the rest of the hour surfing the Net.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0474
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0474
Problem:    The client-server feature is not tested.
Solution:   Add a test.
Files:      src/Makefile, src/testdir/Make_all.mak, src/testdir/shared.vim,
            src/testdir/test_clientserver.vim, src/os_mswin.c


*** ../vim-8.0.0473/src/Makefile	2017-03-12 16:32:27.490343281 +0100
--- src/Makefile	2017-03-18 15:16:07.258504429 +0100
***************
*** 2097,2107 ****
  	test_breakindent \
  	test_bufwintabinfo \
  	test_cdo \
  	test_channel \
  	test_charsearch \
  	test_charsearch_utf8 \
- 	test_changedtick \
  	test_cindent \
  	test_cmdline \
  	test_command_count \
  	test_crypt \
--- 2096,2107 ----
  	test_breakindent \
  	test_bufwintabinfo \
  	test_cdo \
+ 	test_changedtick \
  	test_channel \
  	test_charsearch \
  	test_charsearch_utf8 \
  	test_cindent \
+ 	test_clientserver \
  	test_cmdline \
  	test_command_count \
  	test_crypt \
*** ../vim-8.0.0473/src/testdir/Make_all.mak	2017-03-09 18:19:58.161107848 +0100
--- src/testdir/Make_all.mak	2017-03-18 15:16:19.070420050 +0100
***************
*** 144,149 ****
--- 144,150 ----
  	    test_channel.res \
  	    test_charsearch.res \
  	    test_cindent.res \
+ 	    test_clientserver.res \
  	    test_cmdline.res \
  	    test_command_count.res \
  	    test_crypt.res \
*** ../vim-8.0.0473/src/testdir/shared.vim	2017-03-02 22:42:56.944691932 +0100
--- src/testdir/shared.vim	2017-03-18 15:24:58.030713075 +0100
***************
*** 164,169 ****
--- 164,185 ----
    call feedkeys('x', 'nt')
  endfunc
  
+ " Get the command to run Vim, with -u NONE and --not-a-term arguments.
+ " Returns an empty string on error.
+ func GetVimCommand()
+   if !filereadable('vimcmd')
+     return ''
+   endif
+   let cmd = readfile('vimcmd')[0]
+   let cmd = substitute(cmd, '-u \f\+', '-u NONE', '')
+   if cmd !~ '-u NONE'
+     let cmd = cmd . ' -u NONE'
+   endif
+   let cmd .= ' --not-a-term'
+   let cmd = substitute(cmd, 'VIMRUNTIME=.*VIMRUNTIME;', '', '')
+   return cmd
+ endfunc
+ 
  " Run Vim, using the "vimcmd" file and "-u NORC".
  " "before" is a list of Vim commands to be executed before loading plugins.
  " "after" is a list of Vim commands to be executed after loading plugins.
***************
*** 174,180 ****
  endfunc
  
  func RunVimPiped(before, after, arguments, pipecmd)
!   if !filereadable('vimcmd')
      return 0
    endif
    let args = ''
--- 190,197 ----
  endfunc
  
  func RunVimPiped(before, after, arguments, pipecmd)
!   let cmd = GetVimCommand()
!   if cmd == ''
      return 0
    endif
    let args = ''
***************
*** 187,204 ****
      let args .= ' -S Xafter.vim'
    endif
  
-   let cmd = readfile('vimcmd')[0]
-   let cmd = substitute(cmd, '-u \f\+', '-u NONE', '')
-   if cmd !~ '-u NONE'
-     let cmd = cmd . ' -u NONE'
-   endif
-   let cmd .= ' --not-a-term'
- 
-   " With pipecmd we can't set VIMRUNTIME.
-   if a:pipecmd != ''
-     let cmd = substitute(cmd, 'VIMRUNTIME=.*VIMRUNTIME;', '', '')
-   endif
- 
    exe "silent !" . a:pipecmd . cmd . args . ' ' . a:arguments
  
    if len(a:before) > 0
--- 204,209 ----
*** ../vim-8.0.0473/src/testdir/test_clientserver.vim	2017-03-18 16:17:23.104139345 +0100
--- src/testdir/test_clientserver.vim	2017-03-18 16:14:06.214630521 +0100
***************
*** 0 ****
--- 1,42 ----
+ " Tests for the +clientserver feature.
+ 
+ if !has('job') || !has('clientserver')
+   finish
+ endif
+ 
+ source shared.vim
+ 
+ func Test_client_server()
+   let cmd = GetVimCommand()
+   if cmd == ''
+     return
+   endif
+   let name = 'XVIMTEXT'
+   let cmd .= ' --servername ' . name
+   let g:job = job_start(cmd, {'stoponexit': 'kill', 'out_io': 'null'})
+   call WaitFor('job_status(g:job) == "run"')
+   if job_status(g:job) != 'run'
+     call assert_true(0, 'Cannot run the Vim server')
+     return
+   endif
+ 
+   " Takes a short while for the server to be active.
+   call WaitFor('serverlist() =~ "' . name . '"')
+   call assert_match(name, serverlist())
+ 
+   call remote_foreground(name)
+ 
+   call remote_send(name, ":let testvar = 'yes'\<CR>")
+   call WaitFor('remote_expr("' . name . '", "testvar") == "yes"')
+   call assert_equal('yes', remote_expr(name, "testvar"))
+ 
+   call remote_send(name, ":qa!\<CR>")
+   call WaitFor('job_status(g:job) == "dead"')
+   if job_status(g:job) != 'dead'
+     call assert_true(0, 'Server did not exit')
+     call job_stop(g:job, 'kill')
+   endif
+ endfunc
+ 
+ " Uncomment this line to get a debugging log
+ " call ch_logfile('channellog', 'w')
*** ../vim-8.0.0473/src/os_mswin.c	2017-03-12 19:22:31.760584901 +0100
--- src/os_mswin.c	2017-03-18 16:07:12.472529228 +0100
***************
*** 2105,2115 ****
  
  	    str = serverConvert(client_enc, (char_u *)data->lpData, &tofree);
  	    res = eval_client_expr_to_string(str);
- 	    vim_free(tofree);
  
  	    if (res == NULL)
  	    {
! 		res = vim_strsave((char_u *)_(e_invexprmsg));
  		reply.dwData = COPYDATA_ERROR_RESULT;
  	    }
  	    else
--- 2105,2119 ----
  
  	    str = serverConvert(client_enc, (char_u *)data->lpData, &tofree);
  	    res = eval_client_expr_to_string(str);
  
  	    if (res == NULL)
  	    {
! 		char	*err = _(e_invexprmsg);
! 		size_t	len = STRLEN(str) + STRLEN(err) + 5;
! 
! 		res = alloc(len);
! 		if (res != NULL)
! 		    vim_snprintf((char *)res, len, "%s: \"%s\"", err, str);
  		reply.dwData = COPYDATA_ERROR_RESULT;
  	    }
  	    else
***************
*** 2120,2125 ****
--- 2124,2130 ----
  	    serverSendEnc(sender);
  	    retval = (int)SendMessage(sender, WM_COPYDATA,
  				    (WPARAM)message_window, (LPARAM)(&reply));
+ 	    vim_free(tofree);
  	    vim_free(res);
  	    return retval;
  
*** ../vim-8.0.0473/src/version.c	2017-03-16 22:52:28.508835911 +0100
--- src/version.c	2017-03-18 16:17:08.400245018 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     474,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
145. You e-mail your boss, informing him you'll be late.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0475
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0475
Problem:    Not enough testing for the client-server feature.
Solution:   Add more tests.  Add the remote_startserver() function.  Fix that
            a locally evaluated expression uses function-local variables.
Files:      src/if_xcmdsrv.c, src/evalfunc.c, src/os_mswin.c,
            src/proto/main.pro, src/testdir/test_clientserver.vim,
            runtime/doc/eval.txt


*** ../vim-8.0.0474/src/if_xcmdsrv.c	2017-03-16 17:23:26.823815869 +0100
--- src/if_xcmdsrv.c	2017-03-18 18:00:48.479701197 +0100
***************
*** 399,425 ****
  
      /* Execute locally if no display or target is ourselves */
      if (dpy == NULL || (serverName != NULL && STRICMP(name, serverName) == 0))
!     {
! 	if (asExpr)
! 	{
! 	    char_u *ret;
! 
! 	    ret = eval_client_expr_to_string(cmd);
! 	    if (result != NULL)
! 	    {
! 		if (ret == NULL)
! 		    *result = vim_strsave((char_u *)_(e_invexprmsg));
! 		else
! 		    *result = ret;
! 	    }
! 	    else
! 		vim_free(ret);
! 	    return ret == NULL ? -1 : 0;
! 	}
! 	else
! 	    server_to_input_buf(cmd);
! 	return 0;
!     }
  
      /*
       * Bind the server name to a communication window.
--- 399,405 ----
  
      /* Execute locally if no display or target is ourselves */
      if (dpy == NULL || (serverName != NULL && STRICMP(name, serverName) == 0))
! 	return sendToLocalVim(cmd, asExpr, result);
  
      /*
       * Bind the server name to a communication window.
***************
*** 800,805 ****
--- 780,786 ----
  WaitForReply(void *p)
  {
      Window  *w = (Window *) p;
+ 
      return ServerReplyFind(*w, SROP_Find) != NULL;
  }
  
*** ../vim-8.0.0474/src/evalfunc.c	2017-03-12 20:09:59.460468432 +0100
--- src/evalfunc.c	2017-03-18 17:19:11.629583419 +0100
***************
*** 307,312 ****
--- 307,313 ----
  static void f_remote_peek(typval_T *argvars, typval_T *rettv);
  static void f_remote_read(typval_T *argvars, typval_T *rettv);
  static void f_remote_send(typval_T *argvars, typval_T *rettv);
+ static void f_remote_startserver(typval_T *argvars, typval_T *rettv);
  static void f_remove(typval_T *argvars, typval_T *rettv);
  static void f_rename(typval_T *argvars, typval_T *rettv);
  static void f_repeat(typval_T *argvars, typval_T *rettv);
***************
*** 741,746 ****
--- 742,748 ----
      {"remote_peek",	1, 2, f_remote_peek},
      {"remote_read",	1, 1, f_remote_read},
      {"remote_send",	2, 3, f_remote_send},
+     {"remote_startserver", 1, 1, f_remote_startserver},
      {"remove",		2, 3, f_remove},
      {"rename",		2, 2, f_rename},
      {"repeat",		2, 2, f_repeat},
***************
*** 8487,8493 ****
      make_connection();
      if (X_DISPLAY == NULL)
      {
! 	EMSG(_("E240: No connection to Vim server"));
  	return FAIL;
      }
      return OK;
--- 8489,8495 ----
      make_connection();
      if (X_DISPLAY == NULL)
      {
! 	EMSG(_("E240: No connection to the X server"));
  	return FAIL;
      }
      return OK;
***************
*** 8689,8694 ****
--- 8691,8723 ----
  #endif
  }
  
+ /*
+  * "remote_startserver()" function
+  */
+     static void
+ f_remote_startserver(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
+ {
+ #ifdef FEAT_CLIENTSERVER
+     char_u	*server = get_tv_string_chk(&argvars[0]);
+ 
+     if (server == NULL)
+ 	return;		/* type error; errmsg already given */
+     if (serverName != NULL)
+ 	EMSG(_("E941: already started a server"));
+     else
+     {
+ # ifdef FEAT_X11
+ 	if (check_connection() == OK)
+ 	    serverRegisterName(X_DISPLAY, server);
+ # else
+ 	serverSetName(server);
+ # endif
+     }
+ #else
+     EMSG(_("E942: +clientserver feature not available"));
+ #endif
+ }
+ 
  /*
   * "remove()" function
   */
*** ../vim-8.0.0474/src/os_mswin.c	2017-03-18 16:18:25.103693785 +0100
--- src/os_mswin.c	2017-03-18 18:01:05.019583007 +0100
***************
*** 2409,2414 ****
--- 2409,2418 ----
      int		retcode = 0;
      char_u	altname_buf[MAX_PATH];
  
+     /* Execute locally if no display or target is ourselves */
+     if (serverName != NULL && STRICMP(name, serverName) == 0)
+ 	return sendToLocalVim(cmd, asExpr, result);
+ 
      /* If the server name does not end in a digit then we look for an
       * alternate name.  e.g. when "name" is GVIM the we may find GVIM2. */
      if (STRLEN(name) > 1 && !vim_isdigit(name[STRLEN(name) - 1]))
*** ../vim-8.0.0474/src/proto/main.pro	2016-09-12 13:04:10.000000000 +0200
--- src/proto/main.pro	2017-03-18 17:59:50.252117273 +0100
***************
*** 11,15 ****
--- 11,16 ----
  void time_msg(char *mesg, void *tv_start);
  void server_to_input_buf(char_u *str);
  char_u *eval_client_expr_to_string(char_u *expr);
+ int sendToLocalVim(char_u *cmd, int asExpr, char_u **result);
  char_u *serverConvert(char_u *client_enc, char_u *data, char_u **tofree);
  /* vim: set ft=c : */
*** ../vim-8.0.0474/src/testdir/test_clientserver.vim	2017-03-18 16:18:25.099693814 +0100
--- src/testdir/test_clientserver.vim	2017-03-18 17:45:24.702325840 +0100
***************
*** 30,35 ****
--- 30,60 ----
    call WaitFor('remote_expr("' . name . '", "testvar") == "yes"')
    call assert_equal('yes', remote_expr(name, "testvar"))
  
+   if has('unix') && has('gui') && !has('gui_running')
+     " Running in a terminal and the GUI is avaiable: Tell the server to open
+     " the GUI and check that the remote command still works.
+     " Need to wait for the GUI to start up, otherwise the send hangs in trying
+     " to send to the terminal window.
+     call remote_send(name, ":gui -f\<CR>")
+     sleep 500m
+     call remote_send(name, ":let testvar = 'maybe'\<CR>")
+     call WaitFor('remote_expr("' . name . '", "testvar") == "maybe"')
+     call assert_equal('maybe', remote_expr(name, "testvar"))
+   endif
+ 
+   call assert_fails('call remote_send("XXX", ":let testvar = ''yes''\<CR>")', 'E241')
+ 
+   " Expression evaluated locally.
+   if v:servername == ''
+     call remote_startserver('MYSELF')
+     call assert_equal('MYSELF', v:servername)
+   endif
+   let g:testvar = 'myself'
+   call assert_equal('myself', remote_expr(v:servername, 'testvar'))
+ 
+   call remote_send(name, ":call server2client(expand('<client>'), 'got it')\<CR>", 'g:myserverid')
+   call assert_equal('got it', remote_read(g:myserverid))
+ 
    call remote_send(name, ":qa!\<CR>")
    call WaitFor('job_status(g:job) == "dead"')
    if job_status(g:job) != 'dead'
*** ../vim-8.0.0474/runtime/doc/eval.txt	2017-03-09 18:19:58.153107904 +0100
--- runtime/doc/eval.txt	2017-03-18 18:05:48.361558128 +0100
***************
*** 2259,2264 ****
--- 2262,2269 ----
  remote_read({serverid})		String	read reply string
  remote_send({server}, {string} [, {idvar}])
  				String	send key sequence
+ remote_startserver({name})	none	become server {name}
+ 				String	send key sequence
  remove({list}, {idx} [, {end}])	any	remove items {idx}-{end} from {list}
  remove({dict}, {key})		any	remove entry {key} from {dict}
  rename({from}, {to})		Number	rename (move) file from {from} to {to}
***************
*** 6357,6362 ****
--- 6377,6383 ----
  		See also |clientserver| |RemoteReply|.
  		This function is not available in the |sandbox|.
  		{only available when compiled with the |+clientserver| feature}
+ 
  		Note: Any errors will be reported in the server and may mess
  		up the display.
  		Examples: >
***************
*** 6368,6373 ****
--- 6389,6400 ----
  		:echo remote_send("gvim", ":sleep 10 | echo ".
  		 \ 'server2client(expand("<client>"), "HELLO")<CR>')
  <
+ 					*remote_startserver()* *E941* *E942*
+ remote_startserver({name})
+ 		Become the server {name}.  This fails if already running as a
+ 		server, when |v:servername| is not empty.
+ 		{only available when compiled with the |+clientserver| feature}
+ 
  remove({list}, {idx} [, {end}])				*remove()*
  		Without {end}: Remove the item at {idx} from |List| {list} and
  		return the item.
*** ../vim-8.0.0474/src/version.c	2017-03-18 16:18:25.103693785 +0100
--- src/version.c	2017-03-18 17:01:15.061284034 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     475,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
146. You experience ACTUAL physical withdrawal symptoms when away
     from your 'puter and the net.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0476
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0476 (after 8.0.0475)
Problem:    Missing change to main.c.
Solution:   Add new function.
Files:      src/main.c


*** ../vim-8.0.0475/src/main.c	2017-03-16 15:13:41.924472198 +0100
--- src/main.c	2017-03-18 17:59:29.844263098 +0100
***************
*** 4140,4145 ****
--- 4140,4150 ----
      char_u	*res;
      int		save_dbl = debug_break_level;
      int		save_ro = redir_off;
+     void	*fc;
+ 
+     /* Evaluate the expression at the toplevel, don't use variables local to
+      * the calling function. */
+     fc = clear_current_funccal();
  
       /* Disable debugging, otherwise Vim hangs, waiting for "cont" to be
        * typed. */
***************
*** 4156,4161 ****
--- 4161,4167 ----
      --emsg_silent;
      if (emsg_silent < 0)
  	emsg_silent = 0;
+     restore_current_funccal(fc);
  
      /* A client can tell us to redraw, but not to display the cursor, so do
       * that here. */
***************
*** 4170,4175 ****
--- 4176,4216 ----
  }
  
  /*
+  * Evaluate a command or expression sent to ourselves.
+  */
+     int
+ sendToLocalVim(char_u *cmd, int asExpr, char_u **result)
+ {
+     if (asExpr)
+     {
+ 	char_u *ret;
+ 
+ 	ret = eval_client_expr_to_string(cmd);
+ 	if (result != NULL)
+ 	{
+ 	    if (ret == NULL)
+ 	    {
+ 		char	*err = _(e_invexprmsg);
+ 		size_t	len = STRLEN(cmd) + STRLEN(err) + 5;
+ 		char_u	*msg;
+ 
+ 		msg = alloc(len);
+ 		if (msg != NULL)
+ 		    vim_snprintf((char *)msg, len, "%s: \"%s\"", err, cmd);
+ 		*result = msg;
+ 	    }
+ 	    else
+ 		*result = ret;
+ 	}
+ 	else
+ 	    vim_free(ret);
+ 	return ret == NULL ? -1 : 0;
+     }
+     server_to_input_buf(cmd);
+     return 0;
+ }
+ 
+ /*
   * If conversion is needed, convert "data" from "client_enc" to 'encoding' and
   * return an allocated string.  Otherwise return "data".
   * "*tofree" is set to the result when it needs to be freed later.
*** ../vim-8.0.0475/src/version.c	2017-03-18 18:10:08.771696859 +0100
--- src/version.c	2017-03-18 18:14:21.389891053 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     476,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
147. You finally give up smoking...because it made the monitor dirty.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0477
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0477
Problem:    The client-server test may hang when failing.
Solution:   Set a timer.  Add assert_report()
Files:      src/testdir/test_clientserver.vim, src/testdir/runtest.vim,
            src/eval.c, src/evalfunc.c, src/proto/eval.pro, src/if_xcmdsrv.c,
            src/os_mswin.c, runtime/doc/eval.txt


*** ../vim-8.0.0476/src/testdir/test_clientserver.vim	2017-03-18 18:10:08.771696859 +0100
--- src/testdir/test_clientserver.vim	2017-03-18 19:31:27.544556146 +0100
***************
*** 6,34 ****
  
  source shared.vim
  
  func Test_client_server()
    let cmd = GetVimCommand()
    if cmd == ''
      return
    endif
!   let name = 'XVIMTEXT'
    let cmd .= ' --servername ' . name
    let g:job = job_start(cmd, {'stoponexit': 'kill', 'out_io': 'null'})
    call WaitFor('job_status(g:job) == "run"')
    if job_status(g:job) != 'run'
!     call assert_true(0, 'Cannot run the Vim server')
      return
    endif
  
    " Takes a short while for the server to be active.
    call WaitFor('serverlist() =~ "' . name . '"')
    call assert_match(name, serverlist())
  
    call remote_foreground(name)
  
    call remote_send(name, ":let testvar = 'yes'\<CR>")
    call WaitFor('remote_expr("' . name . '", "testvar") == "yes"')
    call assert_equal('yes', remote_expr(name, "testvar"))
  
    if has('unix') && has('gui') && !has('gui_running')
      " Running in a terminal and the GUI is avaiable: Tell the server to open
--- 6,51 ----
  
  source shared.vim
  
+ let s:where = 0
+ func Abort(id)
+   call assert_report('Test timed out at ' . s:where)
+   call FinishTesting()
+ endfunc
+ 
  func Test_client_server()
    let cmd = GetVimCommand()
    if cmd == ''
      return
    endif
! 
!   " Some of these commands may hang when failing.
!   call timer_start(10000, 'Abort')
! 
!   let s:where = 1
!   let name = 'XVIMTEST'
    let cmd .= ' --servername ' . name
    let g:job = job_start(cmd, {'stoponexit': 'kill', 'out_io': 'null'})
    call WaitFor('job_status(g:job) == "run"')
    if job_status(g:job) != 'run'
!     call assert_report('Cannot run the Vim server')
      return
    endif
+   let s:where = 2
  
    " Takes a short while for the server to be active.
    call WaitFor('serverlist() =~ "' . name . '"')
    call assert_match(name, serverlist())
+   let s:where = 3
  
    call remote_foreground(name)
+   let s:where = 4
  
    call remote_send(name, ":let testvar = 'yes'\<CR>")
+   let s:where = 5
    call WaitFor('remote_expr("' . name . '", "testvar") == "yes"')
+   let s:where = 6
    call assert_equal('yes', remote_expr(name, "testvar"))
+   let s:where = 7
  
    if has('unix') && has('gui') && !has('gui_running')
      " Running in a terminal and the GUI is avaiable: Tell the server to open
***************
*** 36,64 ****
      " Need to wait for the GUI to start up, otherwise the send hangs in trying
      " to send to the terminal window.
      call remote_send(name, ":gui -f\<CR>")
      sleep 500m
      call remote_send(name, ":let testvar = 'maybe'\<CR>")
      call WaitFor('remote_expr("' . name . '", "testvar") == "maybe"')
      call assert_equal('maybe', remote_expr(name, "testvar"))
    endif
  
    call assert_fails('call remote_send("XXX", ":let testvar = ''yes''\<CR>")', 'E241')
  
    " Expression evaluated locally.
    if v:servername == ''
      call remote_startserver('MYSELF')
      call assert_equal('MYSELF', v:servername)
    endif
    let g:testvar = 'myself'
    call assert_equal('myself', remote_expr(v:servername, 'testvar'))
  
    call remote_send(name, ":call server2client(expand('<client>'), 'got it')\<CR>", 'g:myserverid')
    call assert_equal('got it', remote_read(g:myserverid))
  
    call remote_send(name, ":qa!\<CR>")
    call WaitFor('job_status(g:job) == "dead"')
    if job_status(g:job) != 'dead'
!     call assert_true(0, 'Server did not exit')
      call job_stop(g:job, 'kill')
    endif
  endfunc
--- 53,92 ----
      " Need to wait for the GUI to start up, otherwise the send hangs in trying
      " to send to the terminal window.
      call remote_send(name, ":gui -f\<CR>")
+     let s:where = 8
      sleep 500m
      call remote_send(name, ":let testvar = 'maybe'\<CR>")
+     let s:where = 9
      call WaitFor('remote_expr("' . name . '", "testvar") == "maybe"')
+     let s:where = 10
      call assert_equal('maybe', remote_expr(name, "testvar"))
+     let s:where = 11
    endif
  
    call assert_fails('call remote_send("XXX", ":let testvar = ''yes''\<CR>")', 'E241')
+   let s:where = 12
  
    " Expression evaluated locally.
    if v:servername == ''
      call remote_startserver('MYSELF')
+     let s:where = 13
      call assert_equal('MYSELF', v:servername)
    endif
    let g:testvar = 'myself'
    call assert_equal('myself', remote_expr(v:servername, 'testvar'))
+   let s:where = 14
  
    call remote_send(name, ":call server2client(expand('<client>'), 'got it')\<CR>", 'g:myserverid')
+   let s:where = 15
    call assert_equal('got it', remote_read(g:myserverid))
+   let s:where = 16
  
    call remote_send(name, ":qa!\<CR>")
+   let s:where = 17
    call WaitFor('job_status(g:job) == "dead"')
+   let s:where = 18
    if job_status(g:job) != 'dead'
!     call assert_report('Server did not exit')
      call job_stop(g:job, 'kill')
    endif
  endfunc
*** ../vim-8.0.0476/src/testdir/runtest.vim	2017-03-16 22:30:33.658413403 +0100
--- src/testdir/runtest.vim	2017-03-18 19:31:56.276347722 +0100
***************
*** 86,92 ****
    return lnum - top - 1
  endfunc
  
! function RunTheTest(test)
    echo 'Executing ' . a:test
  
    " Avoid stopping at the "hit enter" prompt
--- 86,92 ----
    return lnum - top - 1
  endfunc
  
! func RunTheTest(test)
    echo 'Executing ' . a:test
  
    " Avoid stopping at the "hit enter" prompt
***************
*** 142,147 ****
--- 142,201 ----
    set nomodified
  endfunc
  
+ func AfterTheTest()
+   if len(v:errors) > 0
+     let s:fail += 1
+     call add(s:errors, 'Found errors in ' . s:test . ':')
+     call extend(s:errors, v:errors)
+     let v:errors = []
+   endif
+ endfunc
+ 
+ " This function can be called by a test if it wants to abort testing.
+ func FinishTesting()
+   call AfterTheTest()
+ 
+   " Don't write viminfo on exit.
+   set viminfo=
+ 
+   if s:fail == 0
+     " Success, create the .res file so that make knows it's done.
+     exe 'split ' . fnamemodify(g:testname, ':r') . '.res'
+     write
+   endif
+ 
+   if len(s:errors) > 0
+     " Append errors to test.log
+     split test.log
+     call append(line('$'), '')
+     call append(line('$'), 'From ' . g:testname . ':')
+     call append(line('$'), s:errors)
+     write
+   endif
+ 
+   let message = 'Executed ' . s:done . (s:done > 1 ? ' tests' : ' test')
+   echo message
+   call add(s:messages, message)
+   if s:fail > 0
+     let message = s:fail . ' FAILED:'
+     echo message
+     call add(s:messages, message)
+     call extend(s:messages, s:errors)
+   endif
+ 
+   " Add SKIPPED messages
+   call extend(s:messages, s:skipped)
+ 
+   " Append messages to the file "messages"
+   split messages
+   call append(line('$'), '')
+   call append(line('$'), 'From ' . g:testname . ':')
+   call append(line('$'), s:messages)
+   write
+ 
+   qall!
+ endfunc
+ 
  " Source the test script.  First grab the file name, in case the script
  " navigates away.  g:testname can be used by the tests.
  let g:testname = expand('%')
***************
*** 164,169 ****
--- 218,224 ----
  
  " Names of flaky tests.
  let s:flaky = [
+       \ 'Test_client_server()',
        \ 'Test_close_and_exit_cb()',
        \ 'Test_collapse_buffers()',
        \ 'Test_communicate()',
***************
*** 197,248 ****
      call RunTheTest(s:test)
    endif
  
!   if len(v:errors) > 0
!     let s:fail += 1
!     call add(s:errors, 'Found errors in ' . s:test . ':')
!     call extend(s:errors, v:errors)
!     let v:errors = []
!   endif
  endfor
  
! " Don't write viminfo on exit.
! set viminfo=
! 
! if s:fail == 0
!   " Success, create the .res file so that make knows it's done.
!   exe 'split ' . fnamemodify(g:testname, ':r') . '.res'
!   write
! endif
! 
! if len(s:errors) > 0
!   " Append errors to test.log
!   split test.log
!   call append(line('$'), '')
!   call append(line('$'), 'From ' . g:testname . ':')
!   call append(line('$'), s:errors)
!   write
! endif
! 
! let message = 'Executed ' . s:done . (s:done > 1 ? ' tests' : ' test')
! echo message
! call add(s:messages, message)
! if s:fail > 0
!   let message = s:fail . ' FAILED:'
!   echo message
!   call add(s:messages, message)
!   call extend(s:messages, s:errors)
! endif
! 
! " Add SKIPPED messages
! call extend(s:messages, s:skipped)
! 
! " Append messages to the file "messages"
! split messages
! call append(line('$'), '')
! call append(line('$'), 'From ' . g:testname . ':')
! call append(line('$'), s:messages)
! write
! 
! qall!
  
  " vim: shiftwidth=2 sts=2 expandtab
--- 252,260 ----
      call RunTheTest(s:test)
    endif
  
!   call AfterTheTest()
  endfor
  
! call FinishTesting()
  
  " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.0.0476/src/eval.c	2017-03-16 19:04:15.271616151 +0100
--- src/eval.c	2017-03-18 19:12:54.036634715 +0100
***************
*** 9084,9089 ****
--- 9084,9100 ----
  }
  
      void
+ assert_report(typval_T *argvars)
+ {
+     garray_T	ga;
+ 
+     prepare_assert_error(&ga);
+     ga_concat(&ga, get_tv_string(&argvars[0]));
+     assert_error(&ga);
+     ga_clear(&ga);
+ }
+ 
+     void
  assert_exception(typval_T *argvars)
  {
      garray_T	ga;
*** ../vim-8.0.0476/src/evalfunc.c	2017-03-18 18:10:08.767696888 +0100
--- src/evalfunc.c	2017-03-18 19:10:16.969775345 +0100
***************
*** 52,57 ****
--- 52,58 ----
  static void f_assert_match(typval_T *argvars, typval_T *rettv);
  static void f_assert_notequal(typval_T *argvars, typval_T *rettv);
  static void f_assert_notmatch(typval_T *argvars, typval_T *rettv);
+ static void f_assert_report(typval_T *argvars, typval_T *rettv);
  static void f_assert_true(typval_T *argvars, typval_T *rettv);
  #ifdef FEAT_FLOAT
  static void f_asin(typval_T *argvars, typval_T *rettv);
***************
*** 483,488 ****
--- 484,490 ----
      {"assert_match",	2, 3, f_assert_match},
      {"assert_notequal",	2, 3, f_assert_notequal},
      {"assert_notmatch",	2, 3, f_assert_notmatch},
+     {"assert_report",	1, 1, f_assert_report},
      {"assert_true",	1, 2, f_assert_true},
  #ifdef FEAT_FLOAT
      {"atan",		1, 1, f_atan},
***************
*** 1314,1319 ****
--- 1316,1330 ----
  }
  
  /*
+  * "assert_report(msg)" function
+  */
+     static void
+ f_assert_report(typval_T *argvars, typval_T *rettv UNUSED)
+ {
+     assert_report(argvars);
+ }
+ 
+ /*
   * "assert_true(actual[, msg])" function
   */
      static void
*** ../vim-8.0.0476/src/proto/eval.pro	2017-02-17 16:31:16.929294079 +0100
--- src/proto/eval.pro	2017-03-18 19:08:31.066544037 +0100
***************
*** 123,128 ****
--- 123,129 ----
  void assert_match_common(typval_T *argvars, assert_type_T atype);
  void assert_inrange(typval_T *argvars);
  void assert_bool(typval_T *argvars, int isTrue);
+ void assert_report(typval_T *argvars);
  void assert_exception(typval_T *argvars);
  void assert_fails(typval_T *argvars);
  void fill_assert_error(garray_T *gap, typval_T *opt_msg_tv, char_u *exp_str, typval_T *exp_tv, typval_T *got_tv, assert_type_T atype);
*** ../vim-8.0.0476/src/if_xcmdsrv.c	2017-03-18 18:10:08.763696917 +0100
--- src/if_xcmdsrv.c	2017-03-18 19:28:50.833693143 +0100
***************
*** 596,601 ****
--- 596,605 ----
  	if (seconds >= 0 && (now - start) >= seconds)
  	    break;
  
+ #ifdef FEAT_TIMERS
+ 	check_due_timer();
+ #endif
+ 
  	/* Just look out for the answer without calling back into Vim */
  	if (localLoop)
  	{
*** ../vim-8.0.0476/src/os_mswin.c	2017-03-18 18:10:08.767696888 +0100
--- src/os_mswin.c	2017-03-18 19:30:54.676794586 +0100
***************
*** 2570,2575 ****
--- 2570,2578 ----
  	/* Loop until we receive a reply */
  	while (reply_received == 0)
  	{
+ #ifdef FEAT_TIMERS
+ 	    check_due_timer();
+ #endif
  	    /* Wait for a SendMessage() call to us.  This could be the reply
  	     * we are waiting for.  Use a timeout of a second, to catch the
  	     * situation that the server died unexpectedly. */
*** ../vim-8.0.0476/runtime/doc/eval.txt	2017-03-18 18:10:08.771696859 +0100
--- runtime/doc/eval.txt	2017-03-18 19:40:20.068694890 +0100
***************
*** 1983,1998 ****
  arglistid([{winnr} [, {tabnr}]]) Number	argument list id
  argv({nr})			String	{nr} entry of the argument list
  argv()				List	the argument list
! assert_equal({exp}, {act} [, {msg}])  none  assert {exp} is equal to {act}
! assert_exception({error} [, {msg}])   none  assert {error} is in v:exception
! assert_fails({cmd} [, {error}])	      none  assert {cmd} fails
! assert_false({actual} [, {msg}])      none  assert {actual} is false
  assert_inrange({lower}, {upper}, {actual} [, {msg}])
  				none	assert {actual} is inside the range
! assert_match({pat}, {text} [, {msg}])	 none  assert {pat} matches {text}
! assert_notequal({exp}, {act} [, {msg}])  none  assert {exp} is not equal {act}
! assert_notmatch({pat}, {text} [, {msg}]) none  assert {pat} not matches {text}
! assert_true({actual} [, {msg}])		 none  assert {actual} is true
  asin({expr})			Float	arc sine of {expr}
  atan({expr})			Float	arc tangent of {expr}
  atan2({expr1}, {expr2})		Float	arc tangent of {expr1} / {expr2}
--- 1986,2008 ----
  arglistid([{winnr} [, {tabnr}]]) Number	argument list id
  argv({nr})			String	{nr} entry of the argument list
  argv()				List	the argument list
! assert_equal({exp}, {act} [, {msg}])
! 				none	assert {exp} is equal to {act}
! assert_exception({error} [, {msg}])
! 				none	assert {error} is in v:exception
! assert_fails({cmd} [, {error}])	none	assert {cmd} fails
! assert_false({actual} [, {msg}])
! 				none	assert {actual} is false
  assert_inrange({lower}, {upper}, {actual} [, {msg}])
  				none	assert {actual} is inside the range
! assert_match({pat}, {text} [, {msg}])
! 				none	assert {pat} matches {text}
! assert_notequal({exp}, {act} [, {msg}])
! 				none	assert {exp} is not equal {act}
! assert_notmatch({pat}, {text} [, {msg}])
! 				none	assert {pat} not matches {text}
! assert_report({msg})		none	report a test failure
! assert_true({actual} [, {msg}])	none	assert {actual} is true
  asin({expr})			Float	arc sine of {expr}
  atan({expr})			Float	arc tangent of {expr}
  atan2({expr1}, {expr2})		Float	arc tangent of {expr1} / {expr2}
***************
*** 2580,2586 ****
  		The opposite of `assert_match()`: add an error message to
  		|v:errors| when {pattern} matches {actual}.
  
! assert_true({actual} [, {msg}])					*assert_true()*
  		When {actual} is not true an error message is added to
  		|v:errors|, like with |assert_equal()|.
  		A value is TRUE when it is a non-zero number.  When {actual}
--- 2590,2599 ----
  		The opposite of `assert_match()`: add an error message to
  		|v:errors| when {pattern} matches {actual}.
  
! assert_report({msg})					*assert_report()*
! 		Report a test failure directly, using {msg}.
! 
! assert_true({actual} [, {msg}])				*assert_true()*
  		When {actual} is not true an error message is added to
  		|v:errors|, like with |assert_equal()|.
  		A value is TRUE when it is a non-zero number.  When {actual}
*** ../vim-8.0.0476/src/version.c	2017-03-18 18:15:12.681524375 +0100
--- src/version.c	2017-03-18 19:37:05.370106207 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     477,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
150. You find yourself counting emoticons to get to sleep.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0478
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0478
Problem:    Tests use assert_true(0) and assert_false(1) to report errors.
Solution:   Use assert_report().
Files:      src/testdir/test_cscope.vim, src/testdir/test_expr.vim,
            src/testdir/test_perl.vim, src/testdir/test_channel.vim,
            src/testdir/test_cursor_func.vim, src/testdir/test_gui.vim,
            src/testdir/test_menu.vim, src/testdir/test_popup.vim,
            src/testdir/test_viminfo.vim, src/testdir/test_vimscript.vim,
            src/testdir/test_assert.vim


*** ../vim-8.0.0477/src/testdir/test_cscope.vim	2016-08-30 10:54:57.000000000 +0200
--- src/testdir/test_cscope.vim	2017-03-18 19:45:22.050506789 +0100
***************
*** 28,34 ****
        cscope add Xcscope.out
        set cscopeverbose
      catch
!       call assert_true(0)
      endtry
      call assert_fails('cscope add', 'E560')
      call assert_fails('cscope add Xcscope.out', 'E568')
--- 28,34 ----
        cscope add Xcscope.out
        set cscopeverbose
      catch
!       call assert_report('exception thrown')
      endtry
      call assert_fails('cscope add', 'E560')
      call assert_fails('cscope add Xcscope.out', 'E568')
*** ../vim-8.0.0477/src/testdir/test_expr.vim	2017-02-23 13:50:34.935755831 +0100
--- src/testdir/test_expr.vim	2017-03-18 19:45:35.178411690 +0100
***************
*** 87,93 ****
  func Test_loop_over_null_list()
    let null_list = test_null_list()
    for i in null_list
!     call assert_true(0, 'should not get here')
    endfor
  endfunc
  
--- 87,93 ----
  func Test_loop_over_null_list()
    let null_list = test_null_list()
    for i in null_list
!     call assert_report('should not get here')
    endfor
  endfunc
  
*** ../vim-8.0.0477/src/testdir/test_perl.vim	2017-02-23 13:45:54.173548198 +0100
--- src/testdir/test_perl.vim	2017-03-18 19:45:55.742262728 +0100
***************
*** 132,138 ****
    catch
      return v:exception
    endtry
!   call assert_true(0, 'no exception for `perleval("'.a:expr.'")`')
    return ''
  endfunc
  
--- 132,138 ----
    catch
      return v:exception
    endtry
!   call assert_report('no exception for `perleval("'.a:expr.'")`')
    return ''
  endfunc
  
*** ../vim-8.0.0477/src/testdir/test_channel.vim	2017-02-06 21:56:04.996335436 +0100
--- src/testdir/test_channel.vim	2017-03-18 19:48:16.813240955 +0100
***************
*** 8,17 ****
  
  let s:python = PythonProg()
  if s:python == ''
!   " Can't run this test.
    finish
  endif
  
  let s:chopt = {}
  
  " Run "testfunc" after sarting the server and stop the server afterwards.
--- 8,21 ----
  
  let s:python = PythonProg()
  if s:python == ''
!   " Can't run this test without Python.
    finish
  endif
  
+ " Uncomment the next line to see what happens. Output is in
+ " src/testdir/channellog.
+ " call ch_logfile('channellog', 'w')
+ 
  let s:chopt = {}
  
  " Run "testfunc" after sarting the server and stop the server afterwards.
***************
*** 31,37 ****
    let handle = ch_open('localhost:' . a:port, s:chopt)
    unlet s:chopt.drop
    if ch_status(handle) == "fail"
!     call assert_false(1, "Can't open channel")
      return
    endif
    if has('job')
--- 35,41 ----
    let handle = ch_open('localhost:' . a:port, s:chopt)
    unlet s:chopt.drop
    if ch_status(handle) == "fail"
!     call assert_report("Can't open channel")
      return
    endif
    if has('job')
***************
*** 93,99 ****
    call ch_sendexpr(handle, 'hello!', {'callback': 'Ch_requestHandler'})
    call WaitFor('exists("g:Ch_responseHandle")')
    if !exists('g:Ch_responseHandle')
!     call assert_false(1, 'g:Ch_responseHandle was not set')
    else
      call assert_equal(handle, g:Ch_responseHandle)
      unlet g:Ch_responseHandle
--- 97,103 ----
    call ch_sendexpr(handle, 'hello!', {'callback': 'Ch_requestHandler'})
    call WaitFor('exists("g:Ch_responseHandle")')
    if !exists('g:Ch_responseHandle')
!     call assert_report('g:Ch_responseHandle was not set')
    else
      call assert_equal(handle, g:Ch_responseHandle)
      unlet g:Ch_responseHandle
***************
*** 104,110 ****
    call ch_sendexpr(handle, 'hello!', {'callback': function('Ch_requestHandler')})
    call WaitFor('exists("g:Ch_responseHandle")')
    if !exists('g:Ch_responseHandle')
!     call assert_false(1, 'g:Ch_responseHandle was not set')
    else
      call assert_equal(handle, g:Ch_responseHandle)
      unlet g:Ch_responseHandle
--- 108,114 ----
    call ch_sendexpr(handle, 'hello!', {'callback': function('Ch_requestHandler')})
    call WaitFor('exists("g:Ch_responseHandle")')
    if !exists('g:Ch_responseHandle')
!     call assert_report('g:Ch_responseHandle was not set')
    else
      call assert_equal(handle, g:Ch_responseHandle)
      unlet g:Ch_responseHandle
***************
*** 116,122 ****
    call ch_sendexpr(handle, 'hello!', {'callback': {a, b -> Ch_requestHandler(a, b)}})
    call WaitFor('exists("g:Ch_responseHandle")')
    if !exists('g:Ch_responseHandle')
!     call assert_false(1, 'g:Ch_responseHandle was not set')
    else
      call assert_equal(handle, g:Ch_responseHandle)
      unlet g:Ch_responseHandle
--- 120,126 ----
    call ch_sendexpr(handle, 'hello!', {'callback': {a, b -> Ch_requestHandler(a, b)}})
    call WaitFor('exists("g:Ch_responseHandle")')
    if !exists('g:Ch_responseHandle')
!     call assert_report('g:Ch_responseHandle was not set')
    else
      call assert_equal(handle, g:Ch_responseHandle)
      unlet g:Ch_responseHandle
***************
*** 209,215 ****
    let handle = ch_open('localhost:' . a:port, s:chopt)
    call assert_equal(v:t_channel, type(handle))
    if ch_status(handle) == "fail"
!     call assert_false(1, "Can't open channel")
      return
    endif
  
--- 213,219 ----
    let handle = ch_open('localhost:' . a:port, s:chopt)
    call assert_equal(v:t_channel, type(handle))
    if ch_status(handle) == "fail"
!     call assert_report("Can't open channel")
      return
    endif
  
***************
*** 217,223 ****
  
    let newhandle = ch_open('localhost:' . a:port, s:chopt)
    if ch_status(newhandle) == "fail"
!     call assert_false(1, "Can't open second channel")
      return
    endif
    call assert_equal('got it', ch_evalexpr(newhandle, 'hello!'))
--- 221,227 ----
  
    let newhandle = ch_open('localhost:' . a:port, s:chopt)
    if ch_status(newhandle) == "fail"
!     call assert_report("Can't open second channel")
      return
    endif
    call assert_equal('got it', ch_evalexpr(newhandle, 'hello!'))
***************
*** 238,244 ****
  func Ch_server_crash(port)
    let handle = ch_open('localhost:' . a:port, s:chopt)
    if ch_status(handle) == "fail"
!     call assert_false(1, "Can't open channel")
      return
    endif
  
--- 242,248 ----
  func Ch_server_crash(port)
    let handle = ch_open('localhost:' . a:port, s:chopt)
    if ch_status(handle) == "fail"
!     call assert_report("Can't open channel")
      return
    endif
  
***************
*** 263,269 ****
  func Ch_channel_handler(port)
    let handle = ch_open('localhost:' . a:port, s:chopt)
    if ch_status(handle) == "fail"
!     call assert_false(1, "Can't open channel")
      return
    endif
  
--- 267,273 ----
  func Ch_channel_handler(port)
    let handle = ch_open('localhost:' . a:port, s:chopt)
    if ch_status(handle) == "fail"
!     call assert_report("Can't open channel")
      return
    endif
  
***************
*** 306,312 ****
  func Ch_channel_zero(port)
    let handle = ch_open('localhost:' . a:port, s:chopt)
    if ch_status(handle) == "fail"
!     call assert_false(1, "Can't open channel")
      return
    endif
  
--- 310,316 ----
  func Ch_channel_zero(port)
    let handle = ch_open('localhost:' . a:port, s:chopt)
    if ch_status(handle) == "fail"
!     call assert_report("Can't open channel")
      return
    endif
  
***************
*** 373,379 ****
  func Ch_raw_one_time_callback(port)
    let handle = ch_open('localhost:' . a:port, s:chopt)
    if ch_status(handle) == "fail"
!     call assert_false(1, "Can't open channel")
      return
    endif
    call ch_setoptions(handle, {'mode': 'raw'})
--- 377,383 ----
  func Ch_raw_one_time_callback(port)
    let handle = ch_open('localhost:' . a:port, s:chopt)
    if ch_status(handle) == "fail"
!     call assert_report("Can't open channel")
      return
    endif
    call ch_setoptions(handle, {'mode': 'raw'})
***************
*** 429,435 ****
      endif
    catch
      if v:exception !~ 'Connection reset by peer'
!       call assert_false(1, "Caught exception: " . v:exception)
      endif
    endtry
  endfunc
--- 433,439 ----
      endif
    catch
      if v:exception !~ 'Connection reset by peer'
!       call assert_report("Caught exception: " . v:exception)
      endif
    endtry
  endfunc
***************
*** 1343,1349 ****
    let channel = ch_open('localhost:' . a:port, s:chopt)
    unlet s:chopt.waittime
    if ch_status(channel) == "fail"
!     call assert_false(1, "Can't open channel")
      return
    endif
    call assert_equal('got it', ch_evalexpr(channel, 'hello!'))
--- 1347,1353 ----
    let channel = ch_open('localhost:' . a:port, s:chopt)
    unlet s:chopt.waittime
    if ch_status(channel) == "fail"
!     call assert_report("Can't open channel")
      return
    endif
    call assert_equal('got it', ch_evalexpr(channel, 'hello!'))
***************
*** 1365,1371 ****
  function Ch_test_call(port)
    let handle = ch_open('localhost:' . a:port, s:chopt)
    if ch_status(handle) == "fail"
!     call assert_false(1, "Can't open channel")
      return
    endif
  
--- 1369,1375 ----
  function Ch_test_call(port)
    let handle = ch_open('localhost:' . a:port, s:chopt)
    if ch_status(handle) == "fail"
!     call assert_report("Can't open channel")
      return
    endif
  
***************
*** 1463,1469 ****
  function Ch_test_close_callback(port)
    let handle = ch_open('localhost:' . a:port, s:chopt)
    if ch_status(handle) == "fail"
!     call assert_false(1, "Can't open channel")
      return
    endif
    call ch_setoptions(handle, {'close_cb': 'MyCloseCb'})
--- 1467,1473 ----
  function Ch_test_close_callback(port)
    let handle = ch_open('localhost:' . a:port, s:chopt)
    if ch_status(handle) == "fail"
!     call assert_report("Can't open channel")
      return
    endif
    call ch_setoptions(handle, {'close_cb': 'MyCloseCb'})
***************
*** 1481,1487 ****
  function Ch_test_close_partial(port)
    let handle = ch_open('localhost:' . a:port, s:chopt)
    if ch_status(handle) == "fail"
!     call assert_false(1, "Can't open channel")
      return
    endif
    let g:Ch_d = {}
--- 1485,1491 ----
  function Ch_test_close_partial(port)
    let handle = ch_open('localhost:' . a:port, s:chopt)
    if ch_status(handle) == "fail"
!     call assert_report("Can't open channel")
      return
    endif
    let g:Ch_d = {}
***************
*** 1631,1637 ****
  function Ch_test_close_lambda(port)
    let handle = ch_open('localhost:' . a:port, s:chopt)
    if ch_status(handle) == "fail"
!     call assert_false(1, "Can't open channel")
      return
    endif
    let g:Ch_close_ret = ''
--- 1635,1641 ----
  function Ch_test_close_lambda(port)
    let handle = ch_open('localhost:' . a:port, s:chopt)
    if ch_status(handle) == "fail"
!     call assert_report("Can't open channel")
      return
    endif
    let g:Ch_close_ret = ''
***************
*** 1646,1651 ****
    call ch_log('Test_close_lambda()')
    call s:run_server('Ch_test_close_lambda')
  endfunc
- 
- " Uncomment this to see what happens, output is in src/testdir/channellog.
- " call ch_logfile('channellog', 'w')
--- 1650,1652 ----
*** ../vim-8.0.0477/src/testdir/test_cursor_func.vim	2017-03-09 18:19:58.161107848 +0100
--- src/testdir/test_cursor_func.vim	2017-03-18 19:49:16.440809138 +0100
***************
*** 1,13 ****
  " Tests for cursor().
  
  func Test_wrong_arguments()
!   try
!     call cursor(1. 3)
!     " not reached
!     call assert_false(1)
!   catch
!     call assert_exception('E474:')
!   endtry
  endfunc
  
  func Test_move_cursor()
--- 1,7 ----
  " Tests for cursor().
  
  func Test_wrong_arguments()
!   call assert_fails('call cursor(1. 3)', 'E474:')
  endfunc
  
  func Test_move_cursor()
*** ../vim-8.0.0477/src/testdir/test_gui.vim	2017-03-12 17:10:14.417925081 +0100
--- src/testdir/test_gui.vim	2017-03-18 19:49:25.036746891 +0100
***************
*** 505,511 ****
        " Case 2: guifontset is invalid
        try
          set guifontset=-*-notexist-*
!         call assert_false(1, "'set guifontset=-*-notexist-*' should have failed")
        catch
          call assert_exception('E598')
        endtry
--- 505,511 ----
        " Case 2: guifontset is invalid
        try
          set guifontset=-*-notexist-*
!         call assert_report("'set guifontset=-*-notexist-*' should have failed")
        catch
          call assert_exception('E598')
        endtry
*** ../vim-8.0.0477/src/testdir/test_menu.vim	2017-03-04 21:40:56.393176702 +0100
--- src/testdir/test_menu.vim	2017-03-18 20:09:29.675990125 +0100
***************
*** 8,14 ****
    try
      source $VIMRUNTIME/menu.vim
    catch
!     call assert_false(1, 'error while loading menus: ' . v:exception)
    endtry
    call assert_match('browse confirm w', execute(':menu File.Save'))
    source $VIMRUNTIME/delmenu.vim
--- 8,14 ----
    try
      source $VIMRUNTIME/menu.vim
    catch
!     call assert_report('error while loading menus: ' . v:exception)
    endtry
    call assert_match('browse confirm w', execute(':menu File.Save'))
    source $VIMRUNTIME/delmenu.vim
*** ../vim-8.0.0477/src/testdir/test_popup.vim	2017-02-21 23:00:32.779008036 +0100
--- src/testdir/test_popup.vim	2017-03-18 20:09:46.351868087 +0100
***************
*** 562,568 ****
    %d
    try
      call feedkeys("o/*\<cr>\<cr>\<c-x>\<c-u>/\<esc>", 'tx')
!     call assert_false(1, 'completefunc not set, should have failed')
    catch
      call assert_exception('E764:')
    endtry
--- 562,568 ----
    %d
    try
      call feedkeys("o/*\<cr>\<cr>\<c-x>\<c-u>/\<esc>", 'tx')
!     call assert_report('completefunc not set, should have failed')
    catch
      call assert_exception('E764:')
    endtry
*** ../vim-8.0.0477/src/testdir/test_viminfo.vim	2016-10-15 20:46:13.580656069 +0200
--- src/testdir/test_viminfo.vim	2017-03-18 20:10:20.411618845 +0100
***************
*** 450,462 ****
    let lnum = line('.')
    while 1
      if lnum == line('$')
!       call assert_false(1, 'mark not found in Xtestfileintab')
        break
      endif
      let lnum += 1
      let line = getline(lnum)
      if line == ''
!       call assert_false(1, 'mark not found in Xtestfileintab')
        break
      endif
      if line =~ "^\t\""
--- 450,462 ----
    let lnum = line('.')
    while 1
      if lnum == line('$')
!       call assert_report('mark not found in Xtestfileintab')
        break
      endif
      let lnum += 1
      let line = getline(lnum)
      if line == ''
!       call assert_report('mark not found in Xtestfileintab')
        break
      endif
      if line =~ "^\t\""
*** ../vim-8.0.0477/src/testdir/test_vimscript.vim	2017-02-23 19:00:28.516904176 +0100
--- src/testdir/test_vimscript.vim	2017-03-18 20:11:23.239159142 +0100
***************
*** 1256,1269 ****
                      \ '.',
                      \ ])
      catch
!         call assert_false(1, "Can't define function")
      endtry
      try
          call DefineFunction('T_Append', [
                      \ 'append',
                      \ 'abc',
                      \ ])
!         call assert_false(1, "Shouldn't be able to define function")
      catch
          call assert_exception('Vim(function):E126: Missing :endfunction')
      endtry
--- 1256,1269 ----
                      \ '.',
                      \ ])
      catch
!         call assert_report("Can't define function")
      endtry
      try
          call DefineFunction('T_Append', [
                      \ 'append',
                      \ 'abc',
                      \ ])
!         call assert_report("Shouldn't be able to define function")
      catch
          call assert_exception('Vim(function):E126: Missing :endfunction')
      endtry
***************
*** 1276,1289 ****
                      \ '.',
                      \ ])
      catch
!         call assert_false(1, "Can't define function")
      endtry
      try
          call DefineFunction('T_Change', [
                      \ 'change',
                      \ 'abc',
                      \ ])
!         call assert_false(1, "Shouldn't be able to define function")
      catch
          call assert_exception('Vim(function):E126: Missing :endfunction')
      endtry
--- 1276,1289 ----
                      \ '.',
                      \ ])
      catch
!         call assert_report("Can't define function")
      endtry
      try
          call DefineFunction('T_Change', [
                      \ 'change',
                      \ 'abc',
                      \ ])
!         call assert_report("Shouldn't be able to define function")
      catch
          call assert_exception('Vim(function):E126: Missing :endfunction')
      endtry
***************
*** 1296,1309 ****
                      \ '.',
                      \ ])
      catch
!         call assert_false(1, "Can't define function")
      endtry
      try
          call DefineFunction('T_Insert', [
                      \ 'insert',
                      \ 'abc',
                      \ ])
!         call assert_false(1, "Shouldn't be able to define function")
      catch
          call assert_exception('Vim(function):E126: Missing :endfunction')
      endtry
--- 1296,1309 ----
                      \ '.',
                      \ ])
      catch
!         call assert_report("Can't define function")
      endtry
      try
          call DefineFunction('T_Insert', [
                      \ 'insert',
                      \ 'abc',
                      \ ])
!         call assert_report("Shouldn't be able to define function")
      catch
          call assert_exception('Vim(function):E126: Missing :endfunction')
      endtry
*** ../vim-8.0.0477/src/testdir/test_assert.vim	2017-03-09 18:19:58.165107821 +0100
--- src/testdir/test_assert.vim	2017-03-18 20:12:22.898722685 +0100
***************
*** 36,41 ****
--- 36,47 ----
    call remove(v:errors, 0)
  endfunc
  
+ func Test_assert_report()
+   call assert_report('something is wrong')
+   call assert_match('something is wrong', v:errors[0])
+   call remove(v:errors, 0)
+ endfunc
+ 
  func Test_assert_exception()
    try
      nocommand
*** ../vim-8.0.0477/src/version.c	2017-03-18 19:41:45.904072837 +0100
--- src/version.c	2017-03-18 20:15:56.241162424 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     478,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
151. You find yourself engaged to someone you've never actually met,
     except through e-mail.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0479
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0479
Problem:    remote_peek() is not tested.
Solution:   Add a test.
Files:      src/testdir/test_clientserver.vim, src/testdir/runtest.vim


*** ../vim-8.0.0478/src/testdir/test_clientserver.vim	2017-03-18 19:41:45.892072924 +0100
--- src/testdir/test_clientserver.vim	2017-03-18 20:43:20.869118167 +0100
***************
*** 81,86 ****
--- 81,107 ----
    call assert_equal('got it', remote_read(g:myserverid))
    let s:where = 16
  
+   call remote_send(name, ":call server2client(expand('<client>'), 'another')\<CR>", 'g:myserverid')
+   let s:where = 151
+   let peek_result = 'nothing'
+   let r = remote_peek(g:myserverid, 'peek_result')
+   let s:where = 161
+   " unpredictable whether the result is already avaialble.
+   if r > 0
+     call assert_equal('another', peek_result)
+   elseif r == 0
+     call assert_equal('nothing', peek_result)
+   else
+     call assert_report('remote_peek() failed')
+   endif
+   let g:peek_result = 'empty'
+   call WaitFor('remote_peek(g:myserverid, "g:peek_result") > 0')
+   let s:where = 171
+   call assert_equal('another', g:peek_result)
+   let s:where = 181
+   call assert_equal('another', remote_read(g:myserverid))
+   let s:where = 191
+ 
    call remote_send(name, ":qa!\<CR>")
    let s:where = 17
    call WaitFor('job_status(g:job) == "dead"')
*** ../vim-8.0.0478/src/testdir/runtest.vim	2017-03-18 19:41:45.892072924 +0100
--- src/testdir/runtest.vim	2017-03-18 20:39:37.154760934 +0100
***************
*** 247,252 ****
--- 247,254 ----
    call RunTheTest(s:test)
  
    if len(v:errors) > 0 && index(s:flaky, s:test) >= 0
+     call add(s:messages, 'Found errors in ' . s:test . ':')
+     call extend(s:messages, v:errors)
      call add(s:messages, 'Flaky test failed, running it again')
      let v:errors = []
      call RunTheTest(s:test)
*** ../vim-8.0.0478/src/version.c	2017-03-18 20:18:42.067950195 +0100
--- src/version.c	2017-03-18 20:33:24.689489915 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     479,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
152. You find yourself falling for someone you've never seen or hardly
     know, but, boy can he/she TYPE!!!!!!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0480
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0480
Problem:    The remote_peek() test fails on MS-Windows.
Solution:   Check for pending messages. Also report errors in the first run if
            a flaky test fails twice.
Files:      src/os_mswin.c, src/testdir/runtest.vim


*** ../vim-8.0.0479/src/os_mswin.c	2017-03-18 19:41:45.900072865 +0100
--- src/os_mswin.c	2017-03-18 21:19:54.912999825 +0100
***************
*** 2526,2531 ****
--- 2526,2532 ----
      int		i;
      char_u	*reply;
      reply_T	*rep;
+     int		did_process = FALSE;
  
      /* When waiting, loop until the message waiting for is received. */
      for (;;)
***************
*** 2562,2568 ****
--- 2563,2579 ----
  	/* If we got here, we didn't find a reply. Return immediately if the
  	 * "wait" parameter isn't set.  */
  	if (!wait)
+ 	{
+ 	    /* Process pending messages once. Without this, looping on
+ 	     * remote_peek() would never get the reply. */
+ 	    if (!did_process)
+ 	    {
+ 		did_process = TRUE;
+ 		serverProcessPendingMessages();
+ 		continue;
+ 	    }
  	    break;
+ 	}
  
  	/* We need to wait for a reply. Enter a message loop until the
  	 * "reply_received" flag gets set. */
*** ../vim-8.0.0479/src/testdir/runtest.vim	2017-03-18 20:45:01.292381125 +0100
--- src/testdir/runtest.vim	2017-03-18 21:00:05.293746820 +0100
***************
*** 250,257 ****
--- 250,266 ----
      call add(s:messages, 'Found errors in ' . s:test . ':')
      call extend(s:messages, v:errors)
      call add(s:messages, 'Flaky test failed, running it again')
+     let first_run = v:errors
+ 
      let v:errors = []
      call RunTheTest(s:test)
+     if len(v:errors) > 0
+       let second_run = v:errors
+       let v:errors = ['First run:']
+       call extend(v:errors, first_run)
+       call add(v:errors, 'Second run:')
+       call extend(v:errors, second_run)
+     endif
    endif
  
    call AfterTheTest()
*** ../vim-8.0.0479/src/version.c	2017-03-18 20:45:01.292381125 +0100
--- src/version.c	2017-03-18 21:13:47.387709891 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     480,
  /**/

-- 
Although the scythe isn't pre-eminent among the weapons of war, anyone who
has been on the wrong end of, say, a peasants' revolt will know that in
skilled hands it is fearsome.
					-- (Terry Pratchett, Mort)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0481
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0481
Problem:    Unnecessary if statement.
Solution:   Remove the statement.  Fix "it's" vs "its" mistakes. (Dominique
            Pelle, closes #1568)
Files:      src/syntax.c


*** ../vim-8.0.0480/src/syntax.c	2017-03-16 17:23:26.835815782 +0100
--- src/syntax.c	2017-03-18 21:35:17.182207503 +0100
***************
*** 1782,1817 ****
      stateitem_T	*cur_si;
      colnr_T	prev_current_col;
  
!     if (!current_finished)
      {
! 	while (!current_finished)
  	{
- 	    (void)syn_current_attr(syncing, FALSE, NULL, FALSE);
  	    /*
! 	     * When syncing, and found some item, need to check the item.
  	     */
! 	    if (syncing && current_state.ga_len)
! 	    {
! 		/*
! 		 * Check for match with sync item.
! 		 */
! 		cur_si = &CUR_STATE(current_state.ga_len - 1);
! 		if (cur_si->si_idx >= 0
! 			&& (SYN_ITEMS(syn_block)[cur_si->si_idx].sp_flags
! 					      & (HL_SYNC_HERE|HL_SYNC_THERE)))
! 		    return TRUE;
! 
! 		/* syn_current_attr() will have skipped the check for an item
! 		 * that ends here, need to do that now.  Be careful not to go
! 		 * past the NUL. */
! 		prev_current_col = current_col;
! 		if (syn_getcurline()[current_col] != NUL)
! 		    ++current_col;
! 		check_state_ends();
! 		current_col = prev_current_col;
! 	    }
! 	    ++current_col;
  	}
      }
      return FALSE;
  }
--- 1782,1814 ----
      stateitem_T	*cur_si;
      colnr_T	prev_current_col;
  
!     while (!current_finished)
      {
! 	(void)syn_current_attr(syncing, FALSE, NULL, FALSE);
! 	/*
! 	 * When syncing, and found some item, need to check the item.
! 	 */
! 	if (syncing && current_state.ga_len)
  	{
  	    /*
! 	     * Check for match with sync item.
  	     */
! 	    cur_si = &CUR_STATE(current_state.ga_len - 1);
! 	    if (cur_si->si_idx >= 0
! 		    && (SYN_ITEMS(syn_block)[cur_si->si_idx].sp_flags
! 					  & (HL_SYNC_HERE|HL_SYNC_THERE)))
! 		return TRUE;
! 
! 	    /* syn_current_attr() will have skipped the check for an item
! 	     * that ends here, need to do that now.  Be careful not to go
! 	     * past the NUL. */
! 	    prev_current_col = current_col;
! 	    if (syn_getcurline()[current_col] != NUL)
! 		++current_col;
! 	    check_state_ends();
! 	    current_col = prev_current_col;
  	}
+ 	++current_col;
      }
      return FALSE;
  }
***************
*** 3333,3339 ****
  /*
   * Check one position in a line for a matching keyword.
   * The caller must check if a keyword can start at startcol.
!  * Return it's ID if found, 0 otherwise.
   */
      static int
  check_keyword_id(
--- 3330,3336 ----
  /*
   * Check one position in a line for a matching keyword.
   * The caller must check if a keyword can start at startcol.
!  * Return its ID if found, 0 otherwise.
   */
      static int
  check_keyword_id(
***************
*** 5495,5501 ****
  }
  
  /*
!  * Lookup a syntax cluster name and return it's ID.
   * If it is not found, 0 is returned.
   */
      static int
--- 5492,5498 ----
  }
  
  /*
!  * Lookup a syntax cluster name and return its ID.
   * If it is not found, 0 is returned.
   */
      static int
***************
*** 5535,5541 ****
  }
  
  /*
!  * Find syntax cluster name in the table and return it's ID.
   * The argument is a pointer to the name and the length of the name.
   * If it doesn't exist yet, a new entry is created.
   * Return 0 for failure.
--- 5532,5538 ----
  }
  
  /*
!  * Find syntax cluster name in the table and return its ID.
   * The argument is a pointer to the name and the length of the name.
   * If it doesn't exist yet, a new entry is created.
   * Return 0 for failure.
***************
*** 5559,5565 ****
  }
  
  /*
!  * Add new syntax cluster and return it's ID.
   * "name" must be an allocated string, it will be consumed.
   * Return 0 for failure.
   */
--- 5556,5562 ----
  }
  
  /*
!  * Add new syntax cluster and return its ID.
   * "name" must be an allocated string, it will be consumed.
   * Return 0 for failure.
   */
***************
*** 7752,7758 ****
  		    break;
  		}
  
! 		/* Use the _16 table to check if its a valid color name. */
  		color = color_numbers_16[i];
  		if (color >= 0)
  		{
--- 7749,7755 ----
  		    break;
  		}
  
! 		/* Use the _16 table to check if it's a valid color name. */
  		color = color_numbers_16[i];
  		if (color >= 0)
  		{
***************
*** 9346,9352 ****
  }
  
  /*
!  * Lookup a highlight group name and return it's ID.
   * If it is not found, 0 is returned.
   */
      int
--- 9343,9349 ----
  }
  
  /*
!  * Lookup a highlight group name and return its ID.
   * If it is not found, 0 is returned.
   */
      int
***************
*** 9411,9417 ****
  }
  
  /*
!  * Find highlight group name in the table and return it's ID.
   * The argument is a pointer to the name and the length of the name.
   * If it doesn't exist yet, a new entry is created.
   * Return 0 for failure.
--- 9408,9414 ----
  }
  
  /*
!  * Find highlight group name in the table and return its ID.
   * The argument is a pointer to the name and the length of the name.
   * If it doesn't exist yet, a new entry is created.
   * Return 0 for failure.
***************
*** 9435,9441 ****
  }
  
  /*
!  * Add new highlight group and return it's ID.
   * "name" must be an allocated string, it will be consumed.
   * Return 0 for failure.
   */
--- 9432,9438 ----
  }
  
  /*
!  * Add new highlight group and return its ID.
   * "name" must be an allocated string, it will be consumed.
   * Return 0 for failure.
   */
*** ../vim-8.0.0480/src/version.c	2017-03-18 21:22:42.503765361 +0100
--- src/version.c	2017-03-18 21:36:49.201529374 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     481,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
154. You fondle your mouse.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0482
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0482
Problem:    The setbufvar() function may mess up the window layout. (Kay Z.)
Solution:   Do not check the window to be valid if it is NULL.
Files:      src/window.c, src/testdir/test_functions.vim


*** ../vim-8.0.0481/src/window.c	2017-03-12 19:22:31.772584816 +0100
--- src/window.c	2017-03-18 22:32:29.032748508 +0100
***************
*** 6563,6569 ****
  		&& check_snapshot_rec(sn->fr_next, fr->fr_next) == FAIL)
  	    || (sn->fr_child != NULL
  		&& check_snapshot_rec(sn->fr_child, fr->fr_child) == FAIL)
! 	    || !win_valid(sn->fr_win))
  	return FAIL;
      return OK;
  }
--- 6563,6569 ----
  		&& check_snapshot_rec(sn->fr_next, fr->fr_next) == FAIL)
  	    || (sn->fr_child != NULL
  		&& check_snapshot_rec(sn->fr_child, fr->fr_child) == FAIL)
! 	    || (sn->fr_win != NULL && !win_valid(sn->fr_win)))
  	return FAIL;
      return OK;
  }
*** ../vim-8.0.0481/src/testdir/test_functions.vim	2017-03-13 20:37:11.445776655 +0100
--- src/testdir/test_functions.vim	2017-03-18 22:29:35.742040736 +0100
***************
*** 725,727 ****
--- 725,758 ----
      call balloon_show('hi!')
    endif
  endfunc
+ 
+ func Test_setbufvar_options()
+   " This tests that aucmd_prepbuf() and aucmd_restbuf() properly restore the
+   " window layout.
+   call assert_equal(1, winnr('$'))
+   split dummy_preview
+   resize 2
+   set winfixheight winfixwidth
+   let prev_id = win_getid()
+ 
+   wincmd j
+   let wh = winheight('.')
+   let dummy_buf = bufnr('dummy_buf1', v:true)
+   call setbufvar(dummy_buf, '&buftype', 'nofile')
+   execute 'belowright vertical split #' . dummy_buf
+   call assert_equal(wh, winheight('.'))
+   let dum1_id = win_getid()
+ 
+   wincmd h
+   let wh = winheight('.')
+   let dummy_buf = bufnr('dummy_buf2', v:true)
+   call setbufvar(dummy_buf, '&buftype', 'nofile')
+   execute 'belowright vertical split #' . dummy_buf
+   call assert_equal(wh, winheight('.'))
+ 
+   bwipe!
+   call win_gotoid(prev_id)
+   bwipe!
+   call win_gotoid(dum1_id)
+   bwipe!
+ endfunc
*** ../vim-8.0.0481/src/version.c	2017-03-18 21:37:23.865273985 +0100
--- src/version.c	2017-03-18 22:31:58.340977178 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     482,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
157. You fum through a magazine, you first check to see if it has a web
     address.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0483
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0483
Problem:    Illegal memory access when using :all. (Dominique Pelle)
Solution:   Adjust the cursor position right after setting "curwin".
Files:      src/window.c, src/testdir/test_window_cmd.vim


*** ../vim-8.0.0482/src/window.c	2017-03-18 22:35:26.027431378 +0100
--- src/window.c	2017-03-18 23:03:53.418468208 +0100
***************
*** 2450,2455 ****
--- 2450,2459 ----
  #endif
  	curbuf = curwin->w_buffer;
  	close_curwin = TRUE;
+ 
+ 	/* The cursor position may be invalid if the buffer changed after last
+ 	 * using the window. */
+ 	check_cursor();
      }
      if (p_ea && (*p_ead == 'b' || *p_ead == dir))
  	win_equal(curwin, TRUE, dir);
*** ../vim-8.0.0482/src/testdir/test_window_cmd.vim	2016-08-18 23:02:41.000000000 +0200
--- src/testdir/test_window_cmd.vim	2017-03-18 22:52:42.719737614 +0100
***************
*** 67,70 ****
--- 67,82 ----
    augroup! test_window_cmd_wincmd_gf
  endfunc
  
+ func Test_next_split_all()
+   " This was causing an illegal memory access.
+   n x
+   norm axxx
+   split
+   split
+   s/x
+   s/x
+   all
+   bwipe!
+ endfunc
+ 
  " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.0.0482/src/version.c	2017-03-18 22:35:26.031431348 +0100
--- src/version.c	2017-03-18 23:07:15.224847150 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     483,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
160. You get in the elevator and double-click the button for the floor
     you want.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0484
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0484
Problem:    Using :lhelpgrep with an argument that should fail does not
            produce an error if the previous :helpgrep worked.
Solution:   Use another way to detect that autocommands made the quickfix info
            invalid. (Yegappan Lakshmanan)
Files:      src/quickfix.c, src/testdir/test_quickfix.vim


*** ../vim-8.0.0483/src/quickfix.c	2017-03-16 17:23:26.831815811 +0100
--- src/quickfix.c	2017-03-19 14:16:01.003265351 +0100
***************
*** 5077,5082 ****
--- 5077,5083 ----
      char_u	*lang;
  #endif
      qf_info_T	*qi = &ql_info;
+     qf_info_T	*save_qi;
      int		new_qi = FALSE;
      win_T	*wp;
  #ifdef FEAT_AUTOCMD
***************
*** 5130,5135 ****
--- 5131,5139 ----
  	}
      }
  
+     /* Autocommands may change the list. Save it for later comparison */
+     save_qi = qi;
+ 
      regmatch.regprog = vim_regcomp(eap->arg, RE_MAGIC + RE_STRING);
      regmatch.rm_ic = FALSE;
      if (regmatch.regprog != NULL)
***************
*** 5262,5268 ****
      {
  	apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,
  					       curbuf->b_fname, TRUE, curbuf);
! 	if (!new_qi && qi != &ql_info && qf_find_buf(qi) == NULL)
  	    /* autocommands made "qi" invalid */
  	    return;
      }
--- 5266,5272 ----
      {
  	apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,
  					       curbuf->b_fname, TRUE, curbuf);
! 	if (!new_qi && qi != save_qi && qf_find_buf(qi) == NULL)
  	    /* autocommands made "qi" invalid */
  	    return;
      }
*** ../vim-8.0.0483/src/testdir/test_quickfix.vim	2017-03-04 13:47:08.244946882 +0100
--- src/testdir/test_quickfix.vim	2017-03-19 14:15:38.795424912 +0100
***************
*** 31,37 ****
      command! -nargs=* -bang Xnfile <mods>cnfile<bang> <args>
      command! -nargs=* -bang Xpfile <mods>cpfile<bang> <args>
      command! -nargs=* Xexpr <mods>cexpr <args>
!     command! -nargs=* Xvimgrep <mods>vimgrep <args>
      command! -nargs=* Xgrep <mods> grep <args>
      command! -nargs=* Xgrepadd <mods> grepadd <args>
      command! -nargs=* Xhelpgrep helpgrep <args>
--- 31,38 ----
      command! -nargs=* -bang Xnfile <mods>cnfile<bang> <args>
      command! -nargs=* -bang Xpfile <mods>cpfile<bang> <args>
      command! -nargs=* Xexpr <mods>cexpr <args>
!     command! -range -nargs=* Xvimgrep <mods><count>vimgrep <args>
!     command! -nargs=* Xvimgrepadd <mods>vimgrepadd <args>
      command! -nargs=* Xgrep <mods> grep <args>
      command! -nargs=* Xgrepadd <mods> grepadd <args>
      command! -nargs=* Xhelpgrep helpgrep <args>
***************
*** 61,67 ****
      command! -nargs=* -bang Xnfile <mods>lnfile<bang> <args>
      command! -nargs=* -bang Xpfile <mods>lpfile<bang> <args>
      command! -nargs=* Xexpr <mods>lexpr <args>
!     command! -nargs=* Xvimgrep <mods>lvimgrep <args>
      command! -nargs=* Xgrep <mods> lgrep <args>
      command! -nargs=* Xgrepadd <mods> lgrepadd <args>
      command! -nargs=* Xhelpgrep lhelpgrep <args>
--- 62,69 ----
      command! -nargs=* -bang Xnfile <mods>lnfile<bang> <args>
      command! -nargs=* -bang Xpfile <mods>lpfile<bang> <args>
      command! -nargs=* Xexpr <mods>lexpr <args>
!     command! -range -nargs=* Xvimgrep <mods><count>lvimgrep <args>
!     command! -nargs=* Xvimgrepadd <mods>lvimgrepadd <args>
      command! -nargs=* Xgrep <mods> lgrep <args>
      command! -nargs=* Xgrepadd <mods> lgrepadd <args>
      command! -nargs=* Xhelpgrep lhelpgrep <args>
***************
*** 85,141 ****
  		  \ 'non-error 3', 'Xtestfile3:3:1:Line3']
  
    " List only valid entries
!   redir => result
!   Xlist
!   redir END
!   let l = split(result, "\n")
    call assert_equal([' 2 Xtestfile1:1 col 3: Line1',
  		   \ ' 4 Xtestfile2:2 col 2: Line2',
  		   \ ' 6 Xtestfile3:3 col 1: Line3'], l)
  
    " List all the entries
!   redir => result
!   Xlist!
!   redir END
!   let l = split(result, "\n")
    call assert_equal([' 1: non-error 1', ' 2 Xtestfile1:1 col 3: Line1',
  		   \ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2',
  		   \ ' 5: non-error 3', ' 6 Xtestfile3:3 col 1: Line3'], l)
  
    " List a range of errors
!   redir => result
!   Xlist 3,6
!   redir END
!   let l = split(result, "\n")
    call assert_equal([' 4 Xtestfile2:2 col 2: Line2',
  		   \ ' 6 Xtestfile3:3 col 1: Line3'], l)
  
!   redir => result
!   Xlist! 3,4
!   redir END
!   let l = split(result, "\n")
    call assert_equal([' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)
  
!   redir => result
!   Xlist -6,-4
!   redir END
!   let l = split(result, "\n")
    call assert_equal([' 2 Xtestfile1:1 col 3: Line1'], l)
  
!   redir => result
!   Xlist! -5,-3
!   redir END
!   let l = split(result, "\n")
    call assert_equal([' 2 Xtestfile1:1 col 3: Line1',
  		   \ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)
  
    " Test for '+'
!   redir => result
!   Xlist! +2
!   redir END
!   let l = split(result, "\n")
    call assert_equal([' 2 Xtestfile1:1 col 3: Line1',
  		   \ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)
  endfunc
  
  func Test_clist()
--- 87,138 ----
  		  \ 'non-error 3', 'Xtestfile3:3:1:Line3']
  
    " List only valid entries
!   let l = split(execute('Xlist', ''), "\n")
    call assert_equal([' 2 Xtestfile1:1 col 3: Line1',
  		   \ ' 4 Xtestfile2:2 col 2: Line2',
  		   \ ' 6 Xtestfile3:3 col 1: Line3'], l)
  
    " List all the entries
!   let l = split(execute('Xlist!', ''), "\n")
    call assert_equal([' 1: non-error 1', ' 2 Xtestfile1:1 col 3: Line1',
  		   \ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2',
  		   \ ' 5: non-error 3', ' 6 Xtestfile3:3 col 1: Line3'], l)
  
    " List a range of errors
!   let l = split(execute('Xlist 3,6', ''), "\n")
    call assert_equal([' 4 Xtestfile2:2 col 2: Line2',
  		   \ ' 6 Xtestfile3:3 col 1: Line3'], l)
  
!   let l = split(execute('Xlist! 3,4', ''), "\n")
    call assert_equal([' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)
  
!   let l = split(execute('Xlist -6,-4', ''), "\n")
    call assert_equal([' 2 Xtestfile1:1 col 3: Line1'], l)
  
!   let l = split(execute('Xlist! -5,-3', ''), "\n")
    call assert_equal([' 2 Xtestfile1:1 col 3: Line1',
  		   \ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)
  
    " Test for '+'
!   let l = split(execute('Xlist! +2', ''), "\n")
    call assert_equal([' 2 Xtestfile1:1 col 3: Line1',
  		   \ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)
+ 
+   " Different types of errors
+   call g:Xsetlist([{'lnum':10,'col':5,'type':'W', 'text':'Warning','nr':11},
+ 	      \ {'lnum':20,'col':10,'type':'e','text':'Error','nr':22},
+ 	      \ {'lnum':30,'col':15,'type':'i','text':'Info','nr':33},
+ 	      \ {'lnum':40,'col':20,'type':'x', 'text':'Other','nr':44},
+ 	      \ {'lnum':50,'col':25,'type':"\<C-A>",'text':'one','nr':55}])
+   let l = split(execute('Xlist', ""), "\n")
+   call assert_equal([' 1:10 col 5 warning  11: Warning',
+ 	      \ ' 2:20 col 10 error  22: Error',
+ 	      \ ' 3:30 col 15 info  33: Info',
+ 	      \ ' 4:40 col 20 x  44: Other',
+ 	      \ ' 5:50 col 25  55: one'], l)
+ 
+   " Error cases
+   call assert_fails('Xlist abc', 'E488:')
  endfunc
  
  func Test_clist()
***************
*** 324,329 ****
--- 321,343 ----
  	\ l[3].lnum == 750 && l[3].col == 25 && l[3].text ==# 'Line 750')
    enew!
  
+   " Check for invalid buffer
+   call assert_fails('Xbuffer 199', 'E474:')
+ 
+   " Check for unloaded buffer
+   edit Xtestfile1
+   let bnr = bufnr('%')
+   enew!
+   call assert_fails('Xbuffer ' . bnr, 'E681:')
+ 
+   " Check for invalid range
+   " Using Xbuffer will not run the range check in the cbuffer/lbuffer
+   " commands. So directly call the commands.
+   if (a:cchar == 'c')
+       call assert_fails('900,999cbuffer', 'E16:')
+   else
+       call assert_fails('900,999lbuffer', 'E16:')
+   endif
  endfunc
  
  func Test_cbuffer()
***************
*** 372,377 ****
--- 386,394 ----
    call assert_equal('Xqftestfile1', bufname('%'))
    call assert_equal(5, line('.'))
  
+   Xexpr ""
+   call assert_fails('Xnext', 'E42:')
+ 
    call delete('Xqftestfile1')
    call delete('Xqftestfile2')
  endfunc
***************
*** 411,416 ****
--- 428,436 ----
    call assert_true(w:quickfix_title =~ title_text, w:quickfix_title)
    " This wipes out the buffer, make sure that doesn't cause trouble.
    Xclose
+ 
+   " Search for non existing help string
+   call assert_fails('Xhelpgrep a1b2c3', 'E480:')
  endfunc
  
  func Test_helpgrep()
***************
*** 604,610 ****
      wincmd n | only
  
      augroup! testgroup
!   endfunc
  
  func Test_locationlist_curwin_was_closed()
      augroup testgroup
--- 624,630 ----
      wincmd n | only
  
      augroup! testgroup
! endfunc
  
  func Test_locationlist_curwin_was_closed()
      augroup testgroup
***************
*** 623,629 ****
      call assert_fails('lrewind', 'E924:')
  
      augroup! testgroup
!   endfunc
  
  func Test_locationlist_cross_tab_jump()
    call writefile(['loclistfoo'], 'loclistfoo')
--- 643,649 ----
      call assert_fails('lrewind', 'E924:')
  
      augroup! testgroup
! endfunc
  
  func Test_locationlist_cross_tab_jump()
    call writefile(['loclistfoo'], 'loclistfoo')
***************
*** 760,766 ****
      call delete('Xerrorfile1')
      call delete('Xerrorfile2')
      call delete('Xtestfile')
!   endfunc
  
  " Test for quickfix directory stack support
  func s:dir_stack_tests(cchar)
--- 780,786 ----
      call delete('Xerrorfile1')
      call delete('Xerrorfile2')
      call delete('Xtestfile')
! endfunc
  
  " Test for quickfix directory stack support
  func s:dir_stack_tests(cchar)
***************
*** 919,938 ****
    call assert_equal(l[0].pattern, '^\VLine search text\$')
    call assert_equal(l[0].lnum, 0)
  
    " Test for %P, %Q and %t format specifiers
    let lines=["[Xtestfile1]",
  	      \ "(1,17)  error: ';' missing",
  	      \ "(21,2)  warning: variable 'z' not defined",
  	      \ "(67,3)  error: end of file found before string ended",
  	      \ "",
  	      \ "[Xtestfile2]",
  	      \ "",
  	      \ "[Xtestfile3]",
  	      \ "NEW compiler v1.1",
  	      \ "(2,2)   warning: variable 'x' not defined",
! 	      \ "(67,3)  warning: 's' already defined"
  	      \]
!   set efm=%+P[%f],(%l\\,%c)%*[\ ]%t%*[^:]:\ %m,%-Q
    " To exercise the push/pop file functionality in quickfix, the test files
    " need to be created.
    call writefile(['Line1'], 'Xtestfile1')
--- 939,964 ----
    call assert_equal(l[0].pattern, '^\VLine search text\$')
    call assert_equal(l[0].lnum, 0)
  
+   let l = split(execute('clist', ''), "\n")
+   call assert_equal([' 1 Xtestfile:^\VLine search text\$:  '], l)
+ 
    " Test for %P, %Q and %t format specifiers
    let lines=["[Xtestfile1]",
  	      \ "(1,17)  error: ';' missing",
  	      \ "(21,2)  warning: variable 'z' not defined",
  	      \ "(67,3)  error: end of file found before string ended",
+ 	      \ "--",
  	      \ "",
  	      \ "[Xtestfile2]",
+ 	      \ "--",
  	      \ "",
  	      \ "[Xtestfile3]",
  	      \ "NEW compiler v1.1",
  	      \ "(2,2)   warning: variable 'x' not defined",
! 	      \ "(67,3)  warning: 's' already defined",
! 	      \ "--"
  	      \]
!   set efm=%+P[%f]%r,(%l\\,%c)%*[\ ]%t%*[^:]:\ %m,%+Q--%r
    " To exercise the push/pop file functionality in quickfix, the test files
    " need to be created.
    call writefile(['Line1'], 'Xtestfile1')
***************
*** 943,949 ****
        caddexpr l
    endfor
    let l = getqflist()
!   call assert_equal(9, len(l))
    call assert_equal(21, l[2].lnum)
    call assert_equal(2, l[2].col)
    call assert_equal('w', l[2].type)
--- 969,975 ----
        caddexpr l
    endfor
    let l = getqflist()
!   call assert_equal(12, len(l))
    call assert_equal(21, l[2].lnum)
    call assert_equal(2, l[2].col)
    call assert_equal('w', l[2].type)
***************
*** 1098,1103 ****
--- 1124,1136 ----
    call g:Xsetlist([])
    let l = g:Xgetlist()
    call assert_equal(0, len(l))
+ 
+   " Error cases:
+   " Refer to a non-existing buffer and pass a non-dictionary type
+   call assert_fails("call g:Xsetlist([{'bufnr':998, 'lnum':4}," .
+ 	      \ " {'bufnr':999, 'lnum':5}])", 'E92:')
+   call g:Xsetlist([[1, 2,3]])
+   call assert_equal(0, len(g:Xgetlist()))
  endfunc
  
  func Test_setqflist()
***************
*** 1116,1122 ****
    call s:setup_commands(a:cchar)
  
    " create three quickfix lists
!   Xvimgrep Test_ test_quickfix.vim
    let testlen = len(g:Xgetlist())
    call assert_true(testlen > 0)
    Xvimgrep empty test_quickfix.vim
--- 1149,1156 ----
    call s:setup_commands(a:cchar)
  
    " create three quickfix lists
!   let @/ = 'Test_'
!   Xvimgrep // test_quickfix.vim
    let testlen = len(g:Xgetlist())
    call assert_true(testlen > 0)
    Xvimgrep empty test_quickfix.vim
***************
*** 1609,1614 ****
--- 1643,1664 ----
      call g:Xsetlist([], ' ', {'title' : 'N3'})
      call assert_equal('N2', g:Xgetlist({'nr':2, 'title':1}).title)
  
+     " Changing the title of an earlier quickfix list
+     call g:Xsetlist([], ' ', {'title' : 'NewTitle', 'nr' : 2})
+     call assert_equal('NewTitle', g:Xgetlist({'nr':2, 'title':1}).title)
+ 
+     " Changing the title of an invalid quickfix list
+     call assert_equal(-1, g:Xsetlist([], ' ',
+ 		\ {'title' : 'SomeTitle', 'nr' : 99}))
+     call assert_equal(-1, g:Xsetlist([], ' ',
+ 		\ {'title' : 'SomeTitle', 'nr' : 'abc'}))
+ 
+     if a:cchar == 'c'
+ 	copen
+ 	call assert_equal({'winid':win_getid()}, getqflist({'winid':1}))
+ 	cclose
+     endif
+ 
      " Invalid arguments
      call assert_fails('call g:Xgetlist([])', 'E715')
      call assert_fails('call g:Xsetlist([], "a", [])', 'E715')
***************
*** 1616,1631 ****
      call assert_equal(-1, s)
  
      call assert_equal({}, g:Xgetlist({'abc':1}))
  
      if a:cchar == 'l'
  	call assert_equal({}, getloclist(99, {'title': 1}))
      endif
!   endfunc
  
  func Test_qf_property()
      call Xproperty_tests('c')
      call Xproperty_tests('l')
!   endfunc
  
  " Tests for the QuickFixCmdPre/QuickFixCmdPost autocommands
  func QfAutoCmdHandler(loc, cmd)
--- 1666,1683 ----
      call assert_equal(-1, s)
  
      call assert_equal({}, g:Xgetlist({'abc':1}))
+     call assert_equal({}, g:Xgetlist({'nr':99, 'title':1}))
+     call assert_equal({}, g:Xgetlist({'nr':[], 'title':1}))
  
      if a:cchar == 'l'
  	call assert_equal({}, getloclist(99, {'title': 1}))
      endif
! endfunc
  
  func Test_qf_property()
      call Xproperty_tests('c')
      call Xproperty_tests('l')
! endfunc
  
  " Tests for the QuickFixCmdPre/QuickFixCmdPost autocommands
  func QfAutoCmdHandler(loc, cmd)
***************
*** 1774,1776 ****
--- 1826,1880 ----
    enew | only
    set efm&vim
  endfunc
+ 
+ func XvimgrepTests(cchar)
+   call s:setup_commands(a:cchar)
+ 
+   call writefile(['Editor:VIM vim',
+ 	      \ 'Editor:Emacs EmAcS',
+ 	      \ 'Editor:Notepad NOTEPAD'], 'Xtestfile1')
+   call writefile(['Linux', 'MacOS', 'MS-Windows'], 'Xtestfile2')
+ 
+   " Error cases
+   call assert_fails('Xvimgrep /abc *', 'E682:')
+ 
+   let @/=''
+   call assert_fails('Xvimgrep // *', 'E35:')
+ 
+   call assert_fails('Xvimgrep abc', 'E683:')
+   call assert_fails('Xvimgrep a1b2c3 Xtestfile1', 'E480:')
+   call assert_fails('Xvimgrep pat Xa1b2c3', 'E480:')
+ 
+   Xexpr ""
+   Xvimgrepadd Notepad Xtestfile1
+   Xvimgrepadd MacOS Xtestfile2
+   let l = g:Xgetlist()
+   call assert_equal(2, len(l))
+   call assert_equal('Editor:Notepad NOTEPAD', l[0].text)
+ 
+   Xvimgrep #\cvim#g Xtestfile?
+   let l = g:Xgetlist()
+   call assert_equal(2, len(l))
+   call assert_equal(8, l[0].col)
+   call assert_equal(12, l[1].col)
+ 
+   1Xvimgrep ?Editor? Xtestfile*
+   let l = g:Xgetlist()
+   call assert_equal(1, len(l))
+   call assert_equal('Editor:VIM vim', l[0].text)
+ 
+   edit +3 Xtestfile2
+   Xvimgrep +\cemacs+j Xtestfile1
+   let l = g:Xgetlist()
+   call assert_equal('Xtestfile2', bufname(''))
+   call assert_equal('Editor:Emacs EmAcS', l[0].text)
+ 
+   call delete('Xtestfile1')
+   call delete('Xtestfile2')
+ endfunc
+ 
+ " Tests for the :vimgrep command
+ func Test_vimgrep()
+   call XvimgrepTests('c')
+   call XvimgrepTests('l')
+ endfunc
*** ../vim-8.0.0483/src/version.c	2017-03-18 23:11:00.287000094 +0100
--- src/version.c	2017-03-19 14:18:27.450213230 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     484,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
162. You go outside and look for a brightness knob to turn down the sun.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0485
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0485
Problem:    Not all windows commands are tested.
Solution:   Add more tests for windows commands. (Dominique Pelle,
            closes #1575) Run test_autocmd separately, it interferes with
            other tests.  Fix tests that depended on side effects.
Files:      src/testdir/test_window_cmd.vim, src/testdir/test_alot.vim,
            src/testdir/test_autocmd.vim, src/testdir/test_fnamemodify.vim,
            src/testdir/test_functions.vim, src/testdir/test_delete.vim,
            src/testdir/Make_all.mak


*** ../vim-8.0.0484/src/testdir/test_window_cmd.vim	2017-03-18 23:11:00.287000094 +0100
--- src/testdir/test_window_cmd.vim	2017-03-19 15:52:52.509005390 +0100
***************
*** 67,72 ****
--- 67,371 ----
    augroup! test_window_cmd_wincmd_gf
  endfunc
  
+ func Test_window_quit()
+   e Xa
+   split Xb
+   call assert_equal(2, winnr('$'))
+   call assert_equal('Xb', bufname(winbufnr(1)))
+   call assert_equal('Xa', bufname(winbufnr(2)))
+ 
+   wincmd q
+   call assert_equal(1, winnr('$'))
+   call assert_equal('Xa', bufname(winbufnr(1)))
+ 
+   bw Xa Xb
+ endfunc
+ 
+ func Test_window_horizontal_split()
+   call assert_equal(1, winnr('$'))
+   3wincmd s
+   call assert_equal(2, winnr('$'))
+   call assert_equal(3, winheight(0))
+   call assert_equal(winwidth(1), winwidth(2))
+ 
+   call assert_fails('botright topleft wincmd s', 'E442:')
+   bw
+ endfunc
+ 
+ func Test_window_vertical_split()
+   call assert_equal(1, winnr('$'))
+   3wincmd v
+   call assert_equal(2, winnr('$'))
+   call assert_equal(3, winwidth(0))
+   call assert_equal(winheight(1), winheight(2))
+ 
+   call assert_fails('botright topleft wincmd v', 'E442:')
+   bw
+ endfunc
+ 
+ func Test_window_split_edit_alternate()
+   e Xa
+   e Xb
+ 
+   wincmd ^
+   call assert_equal('Xa', bufname(winbufnr(1)))
+   call assert_equal('Xb', bufname(winbufnr(2)))
+ 
+   bw Xa Xb
+ endfunc
+ 
+ func Test_window_preview()
+   " Open a preview window
+   pedit Xa
+   call assert_equal(2, winnr('$'))
+   call assert_equal(0, &previewwindow)
+ 
+   " Go to the preview window
+   wincmd P
+   call assert_equal(1, &previewwindow)
+ 
+   " Close preview window
+   wincmd z
+   call assert_equal(1, winnr('$'))
+   call assert_equal(0, &previewwindow)
+ 
+   call assert_fails('wincmd P', 'E441:')
+ endfunc
+ 
+ func Test_window_exchange()
+   e Xa
+ 
+   " Nothing happens with window exchange when there is 1 window
+   wincmd x
+   call assert_equal(1, winnr('$'))
+ 
+   split Xb
+   split Xc
+ 
+   call assert_equal('Xc', bufname(winbufnr(1)))
+   call assert_equal('Xb', bufname(winbufnr(2)))
+   call assert_equal('Xa', bufname(winbufnr(3)))
+ 
+   " Exchange current window 1 with window 3
+   3wincmd x
+   call assert_equal('Xa', bufname(winbufnr(1)))
+   call assert_equal('Xb', bufname(winbufnr(2)))
+   call assert_equal('Xc', bufname(winbufnr(3)))
+ 
+   " Exchange window with next when at the top window
+   wincmd x
+   call assert_equal('Xb', bufname(winbufnr(1)))
+   call assert_equal('Xa', bufname(winbufnr(2)))
+   call assert_equal('Xc', bufname(winbufnr(3)))
+ 
+   " Exchange window with next when at the middle window
+   wincmd j
+   wincmd x
+   call assert_equal('Xb', bufname(winbufnr(1)))
+   call assert_equal('Xc', bufname(winbufnr(2)))
+   call assert_equal('Xa', bufname(winbufnr(3)))
+ 
+   " Exchange window with next when at the bottom window.
+   " When there is no next window, it exchanges with the previous window.
+   wincmd j
+   wincmd x
+   call assert_equal('Xb', bufname(winbufnr(1)))
+   call assert_equal('Xa', bufname(winbufnr(2)))
+   call assert_equal('Xc', bufname(winbufnr(3)))
+ 
+   bw Xa Xb Xc
+ endfunc
+ 
+ func Test_window_rotate()
+   e Xa
+   split Xb
+   split Xc
+   call assert_equal('Xc', bufname(winbufnr(1)))
+   call assert_equal('Xb', bufname(winbufnr(2)))
+   call assert_equal('Xa', bufname(winbufnr(3)))
+ 
+   " Rotate downwards
+   wincmd r
+   call assert_equal('Xa', bufname(winbufnr(1)))
+   call assert_equal('Xc', bufname(winbufnr(2)))
+   call assert_equal('Xb', bufname(winbufnr(3)))
+ 
+   2wincmd r
+   call assert_equal('Xc', bufname(winbufnr(1)))
+   call assert_equal('Xb', bufname(winbufnr(2)))
+   call assert_equal('Xa', bufname(winbufnr(3)))
+ 
+   " Rotate upwards
+   wincmd R
+   call assert_equal('Xb', bufname(winbufnr(1)))
+   call assert_equal('Xa', bufname(winbufnr(2)))
+   call assert_equal('Xc', bufname(winbufnr(3)))
+ 
+   2wincmd R
+   call assert_equal('Xc', bufname(winbufnr(1)))
+   call assert_equal('Xb', bufname(winbufnr(2)))
+   call assert_equal('Xa', bufname(winbufnr(3)))
+ 
+   bot vsplit
+   call assert_fails('wincmd R', 'E443:')
+ 
+   bw Xa Xb Xc
+ endfunc
+ 
+ func Test_window_height()
+   e Xa
+   split Xb
+ 
+   let [wh1, wh2] = [winheight(1), winheight(2)]
+   " Active window (1) should have the same height or 1 more
+   " than the other window.
+   call assert_inrange(wh2, wh2 + 1, wh1)
+ 
+   wincmd -
+   call assert_equal(wh1 - 1, winheight(1))
+   call assert_equal(wh2 + 1, winheight(2))
+ 
+   wincmd +
+   call assert_equal(wh1, winheight(1))
+   call assert_equal(wh2, winheight(2))
+ 
+   2wincmd _
+   call assert_equal(2, winheight(1))
+   call assert_equal(wh1 + wh2 - 2, winheight(2))
+ 
+   wincmd =
+   call assert_equal(wh1, winheight(1))
+   call assert_equal(wh2, winheight(2))
+ 
+   2wincmd _
+   set winfixheight
+   split Xc
+   let [wh1, wh2, wh3] = [winheight(1), winheight(2), winheight(3)]
+   call assert_equal(2, winheight(2))
+   call assert_inrange(wh3, wh3 + 1, wh1)
+   3wincmd +
+   call assert_equal(2,       winheight(2))
+   call assert_equal(wh1 + 3, winheight(1))
+   call assert_equal(wh3 - 3, winheight(3))
+   wincmd =
+   call assert_equal(2,   winheight(2))
+   call assert_equal(wh1, winheight(1))
+   call assert_equal(wh3, winheight(3))
+ 
+   wincmd j
+   set winfixheight&
+ 
+   wincmd =
+   let [wh1, wh2, wh3] = [winheight(1), winheight(2), winheight(3)]
+   " Current window (2) should have the same height or 1 more
+   " than the other windows.
+   call assert_inrange(wh1, wh1 + 1, wh2)
+   call assert_inrange(wh3, wh3 + 1, wh2)
+ 
+   bw Xa Xb Xc
+ endfunc
+ 
+ func Test_window_width()
+   e Xa
+   vsplit Xb
+ 
+   let [ww1, ww2] = [winwidth(1), winwidth(2)]
+   " Active window (1) should have the same width or 1 more
+   " than the other window.
+   call assert_inrange(ww2, ww2 + 1, ww1)
+ 
+   wincmd <
+   call assert_equal(ww1 - 1, winwidth(1))
+   call assert_equal(ww2 + 1, winwidth(2))
+ 
+   wincmd >
+   call assert_equal(ww1, winwidth(1))
+   call assert_equal(ww2, winwidth(2))
+ 
+   2wincmd |
+   call assert_equal(2, winwidth(1))
+   call assert_equal(ww1 + ww2 - 2, winwidth(2))
+ 
+   wincmd =
+   call assert_equal(ww1, winwidth(1))
+   call assert_equal(ww2, winwidth(2))
+ 
+   2wincmd |
+   set winfixwidth
+   vsplit Xc
+   let [ww1, ww2, ww3] = [winwidth(1), winwidth(2), winwidth(3)]
+   " FIXME: commented out: I would expect the width of 2nd window to 
+   " remain 2 but it's actually 1?!
+   "call assert_equal(2, winwidth(2))
+   call assert_inrange(ww3, ww3 + 1, ww1)
+   3wincmd >
+   " FIXME: commented out: I would expect the width of 2nd window to 
+   " remain 2 but it's actually 1?!
+   "call assert_equal(2,       winwidth(2))
+   call assert_equal(ww1 + 3, winwidth(1))
+   call assert_equal(ww3 - 3, winwidth(3))
+   wincmd =
+   " FIXME: commented out: I would expect the width of 2nd window to 
+   " remain 2 but it's actually 1?!
+   "call assert_equal(2,   winwidth(2))
+   call assert_equal(ww1, winwidth(1))
+   call assert_equal(ww3, winwidth(3))
+ 
+   wincmd l
+   set winfixwidth&
+ 
+   wincmd =
+   let [ww1, ww2, ww3] = [winwidth(1), winwidth(2), winwidth(3)]
+   " Current window (2) should have the same width or 1 more
+   " than the other windows.
+   call assert_inrange(ww1, ww1 + 1, ww2)
+   call assert_inrange(ww3, ww3 + 1, ww2)
+ 
+   bw Xa Xb Xc
+ endfunc
+ 
+ func Test_window_jump_tag()
+   help
+   /iccf
+   call assert_match('^|iccf|',  getline('.'))
+   call assert_equal(2, winnr('$'))
+   2wincmd }
+   call assert_equal(3, winnr('$'))
+   call assert_match('^|iccf|',  getline('.'))
+   wincmd k
+   call assert_match('\*iccf\*',  getline('.'))
+   call assert_equal(2, winheight(0))
+ 
+   wincmd z
+   set previewheight=4
+   help
+   /bugs
+   wincmd }
+   wincmd k
+   call assert_match('\*bugs\*',  getline('.'))
+   call assert_equal(4, winheight(0))
+   set previewheight&
+ 
+   %bw!
+ endfunc
+ 
+ func Test_window_newtab()
+   e Xa
+ 
+   call assert_equal(1, tabpagenr('$'))
+   call assert_equal("\nAlready only one window", execute('wincmd T'))
+ 
+   split Xb
+   split Xc
+ 
+   wincmd T
+   call assert_equal(2, tabpagenr('$'))
+   call assert_equal(['Xb', 'Xa'], map(tabpagebuflist(1), 'bufname(v:val)'))
+   call assert_equal(['Xc'      ], map(tabpagebuflist(2), 'bufname(v:val)'))
+ 
+   %bw!
+ endfunc
+ 
  func Test_next_split_all()
    " This was causing an illegal memory access.
    n x
*** ../vim-8.0.0484/src/testdir/test_alot.vim	2017-03-08 22:55:14.914181221 +0100
--- src/testdir/test_alot.vim	2017-03-19 15:54:58.392088259 +0100
***************
*** 3,9 ****
  
  set belloff=all
  source test_assign.vim
- source test_autocmd.vim
  source test_changedtick.vim
  source test_cursor_func.vim
  source test_delete.vim
--- 3,8 ----
*** ../vim-8.0.0484/src/testdir/test_autocmd.vim	2017-01-13 22:03:30.797494622 +0100
--- src/testdir/test_autocmd.vim	2017-03-19 15:44:28.980677610 +0100
***************
*** 1,5 ****
--- 1,7 ----
  " Tests for autocommands
  
+ set belloff=all
+ 
  function! s:cleanup_buffers() abort
    for bnr in range(1, bufnr('$'))
      if bufloaded(bnr) && bufnr('%') != bnr
***************
*** 318,323 ****
--- 320,327 ----
    call assert_equal('Xanother', expand('%'))
  
    au!
+   enew
+   bwipe! Xtestje1
    call delete('Xtestje1')
    call delete('Xtestje2')
    call delete('Xtestje3')
*** ../vim-8.0.0484/src/testdir/test_fnamemodify.vim	2017-03-09 14:00:23.630289947 +0100
--- src/testdir/test_fnamemodify.vim	2017-03-19 15:48:35.446879371 +0100
***************
*** 33,40 ****
    call assert_equal('''abc"%"def''', fnamemodify('abc"%"def', ':S'))
    call assert_equal('''abc''\'''' ''\''''def''', fnamemodify('abc'' ''def', ':S'))
    call assert_equal('''abc''\''''%''\''''def''', fnamemodify('abc''%''def', ':S'))
-   call assert_equal(expand('%:r:S'), shellescape(expand('%:r')))
    sp test_alot.vim
    call assert_equal('test_alot,''test_alot'',test_alot.vim', join([expand('%:r'), expand('%:r:S'), expand('%')], ','))
    quit
  
--- 33,40 ----
    call assert_equal('''abc"%"def''', fnamemodify('abc"%"def', ':S'))
    call assert_equal('''abc''\'''' ''\''''def''', fnamemodify('abc'' ''def', ':S'))
    call assert_equal('''abc''\''''%''\''''def''', fnamemodify('abc''%''def', ':S'))
    sp test_alot.vim
+   call assert_equal(expand('%:r:S'), shellescape(expand('%:r')))
    call assert_equal('test_alot,''test_alot'',test_alot.vim', join([expand('%:r'), expand('%:r:S'), expand('%')], ','))
    quit
  
*** ../vim-8.0.0484/src/testdir/test_functions.vim	2017-03-18 22:35:26.031431348 +0100
--- src/testdir/test_functions.vim	2017-03-19 15:51:14.593719010 +0100
***************
*** 460,467 ****
    let bd = getbufvar(bnr, '',def_num)
    call assert_equal(1, len(bd))
  
!   call assert_equal('', getbufvar(9, ''))
!   call assert_equal(def_num, getbufvar(9, '', def_num))
    unlet def_num
  
    call assert_equal(0, getbufvar(bnr, '&autoindent'))
--- 460,467 ----
    let bd = getbufvar(bnr, '',def_num)
    call assert_equal(1, len(bd))
  
!   call assert_equal('', getbufvar(9999, ''))
!   call assert_equal(def_num, getbufvar(9999, '', def_num))
    unlet def_num
  
    call assert_equal(0, getbufvar(bnr, '&autoindent'))
*** ../vim-8.0.0484/src/testdir/test_delete.vim	2016-01-17 18:11:30.000000000 +0100
--- src/testdir/test_delete.vim	2017-03-19 15:57:08.187142023 +0100
***************
*** 8,13 ****
--- 8,14 ----
    call assert_equal(0, delete('Xfile'))
    call assert_fails('call readfile("Xfile")', 'E484:')
    call assert_equal(-1, delete('Xfile'))
+   bwipe Xfile
  endfunc
  
  func Test_dir_delete()
***************
*** 35,40 ****
--- 36,43 ----
    call assert_equal(0, delete('Xdir1', 'rf'))
    call assert_false(isdirectory('Xdir1'))
    call assert_equal(-1, delete('Xdir1', 'd'))
+   bwipe Xdir1/Xfile
+   bwipe Xdir1/subdir/Xfile
  endfunc
  
  func Test_symlink_delete()
***************
*** 49,54 ****
--- 52,58 ----
    call assert_equal(0, delete('Xlink'))
    call assert_equal(-1, delete('Xlink'))
    call assert_equal(0, delete('Xfile'))
+   bwipe Xfile
  endfunc
  
  func Test_symlink_dir_delete()
***************
*** 96,99 ****
--- 100,107 ----
    call assert_equal(['a', 'b'], readfile('Xdir4/Xfile'))
    call assert_equal(0, delete('Xdir4/Xfile'))
    call assert_equal(0, delete('Xdir4', 'd'))
+ 
+   bwipe Xdir3/Xfile
+   bwipe Xdir3/subdir/Xfile
+   bwipe Xdir4/Xfile
  endfunc
*** ../vim-8.0.0484/src/testdir/Make_all.mak	2017-03-18 16:18:25.099693814 +0100
--- src/testdir/Make_all.mak	2017-03-19 15:39:23.478908756 +0100
***************
*** 137,142 ****
--- 137,143 ----
  	    test_arglist.res \
  	    test_assert.res \
  	    test_autochdir.res \
+ 	    test_autocmd.res \
  	    test_backspace_opt.res \
  	    test_breakindent.res \
  	    test_bufwintabinfo.res \
*** ../vim-8.0.0484/src/version.c	2017-03-19 14:19:46.493645414 +0100
--- src/version.c	2017-03-19 14:50:57.368092700 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     485,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
164. You got out to buy software, instead of going out for a beer.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0486
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0486
Problem:    Crash and endless loop when closing windows in a SessionLoadPost
            autocommand.
Solution:   Check for valid tabpage.  (partly neovim #6308)
Files:      src/testdir/test_autocmd.vim, src/fileio.c, src/proto/window.pro,
            src/window.c


*** ../vim-8.0.0485/src/testdir/test_autocmd.vim	2017-03-19 16:09:41.157653918 +0100
--- src/testdir/test_autocmd.vim	2017-03-19 16:12:55.492239467 +0100
***************
*** 345,347 ****
--- 345,410 ----
    call delete('Xdir', 'd')
    au! BufEnter
  endfunc
+ 
+ " Closing a window might cause an endless loop
+ " E814 for older Vims
+ function Test_autocmd_bufwipe_in_SessLoadPost()
+   tabnew
+   set noswapfile
+   let g:bufnr=bufnr('%')
+   mksession!
+ 
+   let content=['set nocp noswapfile',
+         \ 'let v:swapchoice="e"',
+         \ 'augroup test_autocmd_sessionload',
+         \ 'autocmd!',
+         \ 'autocmd SessionLoadPost * 4bw!',
+         \ 'augroup END'
+         \ ]
+   call writefile(content, 'Xvimrc')
+   let a=system(v:progpath. ' -u Xvimrc --noplugins -S Session.vim')
+   call assert_match('E814', a)
+ 
+   unlet! g:bufnr
+   set swapfile
+   for file in ['Session.vim', 'Xvimrc']
+     call delete(file)
+   endfor
+ endfunc
+ 
+ " SEGV occurs in older versions.
+ function Test_autocmd_bufwipe_in_SessLoadPost2()
+   tabnew
+   set noswapfile
+   let g:bufnr=bufnr('%')
+   mksession!
+ 
+   let content = ['set nocp noswapfile',
+       \ 'function! DeleteInactiveBufs()',
+       \ '  tabfirst',
+       \ '  let tabblist = []',
+       \ '  for i in range(1, tabpagenr(''$''))',
+       \ '    call extend(tabblist, tabpagebuflist(i))',
+       \ '  endfor',
+       \ '  for b in range(1, bufnr(''$''))',
+       \ '    if bufexists(b) && buflisted(b) && (index(tabblist, b) == -1 || bufname(b) =~# ''^$'')',
+       \ '      exec ''bwipeout '' . b',
+       \ '    endif',
+       \ '  endfor',
+       \ 'call append("1", "SessionLoadPost DONE")',
+       \ 'endfunction',
+       \ 'au SessionLoadPost * call DeleteInactiveBufs()']
+   call writefile(content, 'Xvimrc')
+   let a=system(v:progpath. ' -u Xvimrc --noplugins -S Session.vim')
+   " this probably only matches on unix
+   if has("unix")
+     call assert_notmatch('Caught deadly signal SEGV', a)
+   endif
+   call assert_match('SessionLoadPost DONE', a)
+ 
+   unlet! g:bufnr
+   set swapfile
+   for file in ['Session.vim', 'Xvimrc']
+     call delete(file)
+   endfor
+ endfunc
*** ../vim-8.0.0485/src/fileio.c	2017-03-16 17:23:26.823815869 +0100
--- src/fileio.c	2017-03-19 16:16:23.954716288 +0100
***************
*** 9033,9038 ****
--- 9033,9043 ----
  	win_remove(curwin, NULL);
  	aucmd_win_used = FALSE;
  	last_status(FALSE);	    /* may need to remove last status line */
+ 
+ 	if (!valid_tabpage_win(curtab))
+ 	    /* no valid window in current tabpage */
+ 	    close_tabpage(curtab);
+ 
  	restore_snapshot(SNAP_AUCMD_IDX, FALSE);
  	(void)win_comp_pos();   /* recompute window positions */
  	unblock_autocmds();
*** ../vim-8.0.0485/src/proto/window.pro	2016-09-12 13:04:23.000000000 +0200
--- src/proto/window.pro	2017-03-19 16:15:41.091029969 +0100
***************
*** 26,31 ****
--- 26,33 ----
  int may_open_tabpage(void);
  int make_tabpages(int maxcount);
  int valid_tabpage(tabpage_T *tpc);
+ int valid_tabpage_win(tabpage_T *tpc);
+ void close_tabpage(tabpage_T *tpc);
  tabpage_T *find_tabpage(int n);
  int tabpage_index(tabpage_T *ftp);
  void goto_tabpage(int n);
*** ../vim-8.0.0485/src/window.c	2017-03-18 23:11:00.287000094 +0100
--- src/window.c	2017-03-19 17:05:27.709065597 +0100
***************
*** 2107,2113 ****
  }
  
  /*
!  * close all windows for buffer 'buf'
   */
      void
  close_windows(
--- 2107,2113 ----
  }
  
  /*
!  * Close all windows for buffer "buf".
   */
      void
  close_windows(
***************
*** 2131,2137 ****
  #endif
  		)
  	{
! 	    win_close(wp, FALSE);
  
  	    /* Start all over, autocommands may change the window layout. */
  	    wp = firstwin;
--- 2131,2140 ----
  #endif
  		)
  	{
! 	    if (win_close(wp, FALSE) == FAIL)
! 		/* If closing the window fails give up, to avoid looping
! 		 * forever. */
! 		break;
  
  	    /* Start all over, autocommands may change the window layout. */
  	    wp = firstwin;
***************
*** 3759,3764 ****
--- 3762,3819 ----
  }
  
  /*
+  * Return TRUE when "tpc" points to a valid tab page and at least one window is
+  * valid.
+  */
+     int
+ valid_tabpage_win(tabpage_T *tpc)
+ {
+     tabpage_T	*tp;
+     win_T	*wp;
+ 
+     FOR_ALL_TABPAGES(tp)
+     {
+ 	if (tp == tpc)
+ 	{
+ 	    FOR_ALL_WINDOWS_IN_TAB(tp, wp)
+ 	    {
+ 		if (win_valid_any_tab(wp))
+ 		    return TRUE;
+ 	    }
+ 	    return FALSE;
+ 	}
+     }
+     /* shouldn't happen */
+     return FALSE;
+ }
+ 
+ /*
+  * Close tabpage "tab", assuming it has no windows in it.
+  * There must be another tabpage or this will crash.
+  */
+     void
+ close_tabpage(tabpage_T *tab)
+ {
+     tabpage_T	*ptp;
+ 
+     if (tab == first_tabpage)
+     {
+ 	first_tabpage = tab->tp_next;
+ 	ptp = first_tabpage;
+     }
+     else
+     {
+ 	for (ptp = first_tabpage; ptp != NULL && ptp->tp_next != tab;
+ 							    ptp = ptp->tp_next)
+ 	    ;
+ 	ptp->tp_next = tab->tp_next;
+     }
+ 
+     goto_tabpage_tp(ptp, FALSE, FALSE);
+     free_tabpage(tab);
+ }
+ 
+ /*
   * Find tab page "n" (first one is 1).  Returns NULL when not found.
   */
      tabpage_T *
*** ../vim-8.0.0485/src/version.c	2017-03-19 16:09:41.157653918 +0100
--- src/version.c	2017-03-19 17:08:47.315564870 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     486,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
165. You have a web page burned into your glasses

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0487
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0487
Problem:    The autocmd test hangs on MS-Windows.
Solution:   Skip the hanging tests for now.
Files:      src/testdir/test_autocmd.vim


*** ../vim-8.0.0486/src/testdir/test_autocmd.vim	2017-03-19 17:09:51.831080752 +0100
--- src/testdir/test_autocmd.vim	2017-03-19 18:28:21.652364742 +0100
***************
*** 349,354 ****
--- 349,357 ----
  " Closing a window might cause an endless loop
  " E814 for older Vims
  function Test_autocmd_bufwipe_in_SessLoadPost()
+   if has('win32')
+     throw 'Skipped: test hangs on MS-Windows'
+   endif
    tabnew
    set noswapfile
    let g:bufnr=bufnr('%')
***************
*** 374,379 ****
--- 377,385 ----
  
  " SEGV occurs in older versions.
  function Test_autocmd_bufwipe_in_SessLoadPost2()
+   if has('win32')
+     throw 'Skipped: test hangs on MS-Windows'
+   endif
    tabnew
    set noswapfile
    let g:bufnr=bufnr('%')
*** ../vim-8.0.0486/src/version.c	2017-03-19 17:09:51.835080722 +0100
--- src/version.c	2017-03-19 18:34:06.961862601 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     487,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
167. You have more than 200 websites bookmarked.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0488
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0488
Problem:    Running tests leaves an "xxx" file behind.
Solution:   Delete the 'verbosefile' after resetting the option.
Files:      src/testdir/gen_opt_test.vim


*** ../vim-8.0.0487/src/testdir/gen_opt_test.vim	2017-03-09 13:54:56.228561435 +0100
--- src/testdir/gen_opt_test.vim	2017-03-19 19:07:38.919197994 +0100
***************
*** 175,184 ****
        for val in a[0]
  	call add(script, 'set ' . name . '=' . val)
  	call add(script, 'set ' . shortname . '=' . val)
- 
- 	if name == 'verbosefile' && !empty(val)
- 	  call add(script, 'call delete("'. val. '")')
- 	endif
        endfor
  
        " setting an option can only fail when it's implemented.
--- 175,180 ----
***************
*** 192,197 ****
--- 188,196 ----
  
      call add(script, 'set ' . name . '&')
      call add(script, 'set ' . shortname . '&')
+     if name == 'verbosefile'
+       call add(script, 'call delete("xxx")')
+     endif
  
      if name == 'more'
        call add(script, 'set nomore')
*** ../vim-8.0.0487/src/version.c	2017-03-19 18:34:42.585604297 +0100
--- src/version.c	2017-03-19 19:09:30.650382255 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     488,
  /**/

-- 
Microsoft says that MS-Windows is much better for you than Linux.
That's like the Pope saying that catholicism is much better for
you than protestantism.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0489
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0489
Problem:    Clipboard and "* register is not tested.
Solution:   Add a test for Mac and X11. (Kazunobu Kuriyama)
Files:      src/Makefile, src/testdir/Make_all.mak,
            src/testdir/test_quotestar.vim, src/testdir/runtest.vim


*** ../vim-8.0.0488/src/Makefile	2017-03-18 16:18:25.099693814 +0100
--- src/Makefile	2017-03-19 14:32:03.788320557 +0100
***************
*** 2185,2190 ****
--- 2184,2190 ----
  	test_pyx2 \
  	test_pyx3 \
  	test_quickfix \
+ 	test_quotestar \
  	test_recover \
  	test_regexp_latin \
  	test_regexp_utf8 \
*** ../vim-8.0.0488/src/testdir/Make_all.mak	2017-03-19 16:09:41.157653918 +0100
--- src/testdir/Make_all.mak	2017-03-19 19:59:31.144621542 +0100
***************
*** 194,199 ****
--- 194,200 ----
  	    test_pyx2.res \
  	    test_pyx3.res \
  	    test_quickfix.res \
+ 	    test_quotestar.res \
  	    test_retab.res \
  	    test_ruby.res \
  	    test_search.res \
*** ../vim-8.0.0488/src/testdir/test_quotestar.vim	2017-03-19 20:03:29.302891676 +0100
--- src/testdir/test_quotestar.vim	2017-03-19 19:31:31.808815319 +0100
***************
*** 0 ****
--- 1,139 ----
+ " *-register (quotestar) tests
+ 
+ if !has('clipboard')
+   finish
+ endif
+ 
+ source shared.vim
+ 
+ let s:where = 0
+ func Abort(id)
+   call assert_report('Test timed out at ' . s:where)
+   call FinishTesting()
+ endfunc
+ 
+ func Do_test_quotestar_for_macunix()
+   if empty(exepath('pbcopy')) || empty(exepath('pbpaste'))
+     return 'Test requires pbcopy(1) and pbpaste(1)'
+   endif
+ 
+   let @* = ''
+ 
+   " Test #1: Pasteboard to Vim
+   let test_msg = "text from pasteboard to vim via quotestar"
+   " Write a piece of text to the pasteboard.
+   call system('/bin/echo -n "' . test_msg . '" | pbcopy')
+   " See if the *-register is changed as expected.
+   call assert_equal(test_msg, @*)
+ 
+   " Test #2: Vim to Pasteboard
+   let test_msg = "text from vim to pasteboard via quotestar"
+   " Write a piece of text to the *-register.
+   let @* = test_msg
+   " See if the pasteboard is changed as expected.
+   call assert_equal(test_msg, system('pbpaste'))
+ 
+   return ''
+ endfunc
+ 
+ func Do_test_quotestar_for_x11()
+   if !has('clientserver') || !has('job')
+     return 'Test requires the client-server and job features'
+   endif
+ 
+   let cmd = GetVimCommand()
+   if cmd == ''
+     return 'GetVimCommand() failed'
+   endif
+ 
+   " Some of these commands may hang when failing.
+   call timer_start(10000, 'Abort')
+ 
+   let s:where = 1
+   let name = 'XVIMCLIPBOARD'
+   let cmd .= ' --servername ' . name
+   let g:job = job_start(cmd, {'stoponexit': 'kill', 'out_io': 'null'})
+   call WaitFor('job_status(g:job) == "run"')
+   if job_status(g:job) != 'run'
+     call assert_report('Cannot run the Vim server')
+     return ''
+   endif
+   let s:where = 2
+ 
+   " Takes a short while for the server to be active.
+   call WaitFor('serverlist() =~ "' . name . '"')
+   call assert_match(name, serverlist())
+   let s:where = 3
+ 
+   " Clear the *-register of this vim instance.
+   let @* = ''
+ 
+   " Try to change the *-register of the server.
+   call remote_foreground(name)
+   let s:where = 4
+   call remote_send(name, ":let @* = 'yes'\<CR>")
+   let s:where = 5
+   call WaitFor('remote_expr("' . name . '", "@*") == "yes"')
+   let s:where = 6
+   call assert_equal('yes', remote_expr(name, "@*"))
+   let s:where = 7
+ 
+   " Check that the *-register of this vim instance is changed as expected.
+   call assert_equal('yes', @*)
+ 
+   if has('unix') && has('gui') && !has('gui_running')
+     let @* = ''
+ 
+     " Running in a terminal and the GUI is avaiable: Tell the server to open
+     " the GUI and check that the remote command still works.
+     " Need to wait for the GUI to start up, otherwise the send hangs in trying
+     " to send to the terminal window.
+     if has('gui_athena') || has('gui_motif')
+       " For those GUIs, ignore the 'failed to create input context' error.
+       call remote_send(name, ":call test_ignore_error('E285') | gui -f\<CR>")
+     else
+       call remote_send(name, ":gui -f\<CR>")
+     endif
+     let s:where = 8
+     sleep 500m
+     call remote_send(name, ":let @* = 'maybe'\<CR>")
+     let s:where = 9
+     call WaitFor('remote_expr("' . name . '", "@*") == "maybe"')
+     let s:where = 10
+     call assert_equal('maybe', remote_expr(name, "@*"))
+     let s:where = 11
+ 
+     call assert_equal('maybe', @*)
+   endif
+ 
+   call remote_send(name, ":qa!\<CR>")
+   let s:where = 12
+   call WaitFor('job_status(g:job) == "dead"')
+   let s:where = 13
+   if job_status(g:job) != 'dead'
+     call assert_report('Server did not exit')
+     call job_stop(g:job, 'kill')
+   endif
+ 
+   return ''
+ endfunc
+ 
+ func Test_quotestar()
+   let skipped = ''
+ 
+   let quotestar_saved = @*
+ 
+   if has('macunix')
+     let skipped = Do_test_quotestar_for_macunix()
+   elseif !empty("$DISPLAY")
+     let skipped = Do_test_quotestar_for_x11()
+   else
+     let skipped = "Test is not implemented yet for this platform."
+   endif
+ 
+   let @* = quotestar_saved
+ 
+   if !empty(skipped)
+     throw skipped
+   endif
+ endfunc
*** ../vim-8.0.0488/src/testdir/runtest.vim	2017-03-18 21:22:42.503765361 +0100
--- src/testdir/runtest.vim	2017-03-19 19:41:26.584496992 +0100
***************
*** 228,233 ****
--- 228,234 ----
        \ 'Test_pipe_through_sort_all()',
        \ 'Test_pipe_through_sort_some()',
        \ 'Test_quoteplus()',
+       \ 'Test_quotestar()',
        \ 'Test_reltime()',
        \ ]
  
*** ../vim-8.0.0488/src/version.c	2017-03-19 19:11:31.049503241 +0100
--- src/version.c	2017-03-19 19:58:02.057268489 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     489,
  /**/

-- 
"Hit any key to continue" does _not_ mean you can hit the on/off button!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0490
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0490
Problem:    Splitting a 'winfixwidth' window vertically makes it one column
            smaller. (Dominique Pelle)
Solution:   Add one to the width for the separator.
Files:      src/window.c, src/testdir/test_window_cmd.vim


*** ../vim-8.0.0489/src/window.c	2017-03-19 17:09:51.835080722 +0100
--- src/window.c	2017-03-19 20:13:37.414467919 +0100
***************
*** 870,878 ****
  
  	/* We don't like to take lines for the new window from a
  	 * 'winfixwidth' window.  Take them from a window to the left or right
! 	 * instead, if possible. */
  	if (oldwin->w_p_wfw)
! 	    win_setwidth_win(oldwin->w_width + new_size, oldwin);
  
  	/* Only make all windows the same width if one of them (except oldwin)
  	 * is wider than one of the split windows. */
--- 870,878 ----
  
  	/* We don't like to take lines for the new window from a
  	 * 'winfixwidth' window.  Take them from a window to the left or right
! 	 * instead, if possible. Add one for the separator. */
  	if (oldwin->w_p_wfw)
! 	    win_setwidth_win(oldwin->w_width + new_size + 1, oldwin);
  
  	/* Only make all windows the same width if one of them (except oldwin)
  	 * is wider than one of the split windows. */
*** ../vim-8.0.0489/src/testdir/test_window_cmd.vim	2017-03-19 16:09:41.153653947 +0100
--- src/testdir/test_window_cmd.vim	2017-03-19 20:16:24.817250219 +0100
***************
*** 294,313 ****
    set winfixwidth
    vsplit Xc
    let [ww1, ww2, ww3] = [winwidth(1), winwidth(2), winwidth(3)]
!   " FIXME: commented out: I would expect the width of 2nd window to 
!   " remain 2 but it's actually 1?!
!   "call assert_equal(2, winwidth(2))
    call assert_inrange(ww3, ww3 + 1, ww1)
    3wincmd >
!   " FIXME: commented out: I would expect the width of 2nd window to 
!   " remain 2 but it's actually 1?!
!   "call assert_equal(2,       winwidth(2))
    call assert_equal(ww1 + 3, winwidth(1))
    call assert_equal(ww3 - 3, winwidth(3))
    wincmd =
!   " FIXME: commented out: I would expect the width of 2nd window to 
!   " remain 2 but it's actually 1?!
!   "call assert_equal(2,   winwidth(2))
    call assert_equal(ww1, winwidth(1))
    call assert_equal(ww3, winwidth(3))
  
--- 294,307 ----
    set winfixwidth
    vsplit Xc
    let [ww1, ww2, ww3] = [winwidth(1), winwidth(2), winwidth(3)]
!   call assert_equal(2, winwidth(2))
    call assert_inrange(ww3, ww3 + 1, ww1)
    3wincmd >
!   call assert_equal(2,       winwidth(2))
    call assert_equal(ww1 + 3, winwidth(1))
    call assert_equal(ww3 - 3, winwidth(3))
    wincmd =
!   call assert_equal(2,   winwidth(2))
    call assert_equal(ww1, winwidth(1))
    call assert_equal(ww3, winwidth(3))
  
*** ../vim-8.0.0489/src/version.c	2017-03-19 20:04:05.534628090 +0100
--- src/version.c	2017-03-19 20:22:18.270679285 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     490,
  /**/

-- 
"Hit any key to continue" it said, but nothing happened after F sharp.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0491
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0491
Problem:    The quotestar test fails when a required feature is missing.
Solution:   Prepend "Skipped" to the thrown exception.
Files:      src/testdir/test_quotestar.vim


*** ../vim-8.0.0490/src/testdir/test_quotestar.vim	2017-03-19 20:04:05.534628090 +0100
--- src/testdir/test_quotestar.vim	2017-03-19 20:58:02.519025987 +0100
***************
*** 134,139 ****
    let @* = quotestar_saved
  
    if !empty(skipped)
!     throw skipped
    endif
  endfunc
--- 134,139 ----
    let @* = quotestar_saved
  
    if !empty(skipped)
!     throw 'Skipped: ' . skipped
    endif
  endfunc
*** ../vim-8.0.0490/src/version.c	2017-03-19 20:22:31.210585166 +0100
--- src/version.c	2017-03-19 20:59:23.446433274 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     491,
  /**/

-- 
"The question of whether computers can think is just like the question
of whether submarines can swim."      -- Edsger W. Dijkstra

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0492
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0492
Problem:    A failing client-server request can make Vim hang.
Solution:   Add a timeout argument to functions that wait.
Files:      src/evalfunc.c, src/if_xcmdsrv.c, src/proto/if_xcmdsrv.pro,
            src/main.c, src/os_mswin.c, src/proto/os_mswin.pro,
            src/vim.h, runtime/doc/eval.txt, src/testdir/test_clientserver.vim


*** ../vim-8.0.0491/src/evalfunc.c	2017-03-18 19:41:45.900072865 +0100
--- src/evalfunc.c	2017-03-19 20:52:20.393531213 +0100
***************
*** 739,748 ****
      {"reltimefloat",	1, 1, f_reltimefloat},
  #endif
      {"reltimestr",	1, 1, f_reltimestr},
!     {"remote_expr",	2, 3, f_remote_expr},
      {"remote_foreground", 1, 1, f_remote_foreground},
      {"remote_peek",	1, 2, f_remote_peek},
!     {"remote_read",	1, 1, f_remote_read},
      {"remote_send",	2, 3, f_remote_send},
      {"remote_startserver", 1, 1, f_remote_startserver},
      {"remove",		2, 3, f_remove},
--- 739,748 ----
      {"reltimefloat",	1, 1, f_reltimefloat},
  #endif
      {"reltimestr",	1, 1, f_reltimestr},
!     {"remote_expr",	2, 4, f_remote_expr},
      {"remote_foreground", 1, 1, f_remote_foreground},
      {"remote_peek",	1, 2, f_remote_peek},
!     {"remote_read",	1, 2, f_remote_read},
      {"remote_send",	2, 3, f_remote_send},
      {"remote_startserver", 1, 1, f_remote_startserver},
      {"remove",		2, 3, f_remove},
***************
*** 8515,8520 ****
--- 8515,8521 ----
      char_u	*keys;
      char_u	*r = NULL;
      char_u	buf[NUMBUFLEN];
+     int		timeout = 0;
  # ifdef WIN32
      HWND	w;
  # else
***************
*** 8528,8543 ****
      if (check_connection() == FAIL)
  	return;
  # endif
  
      server_name = get_tv_string_chk(&argvars[0]);
      if (server_name == NULL)
  	return;		/* type error; errmsg already given */
      keys = get_tv_string_buf(&argvars[1], buf);
  # ifdef WIN32
!     if (serverSendToVim(server_name, keys, &r, &w, expr, TRUE) < 0)
  # else
!     if (serverSendToVim(X_DISPLAY, server_name, keys, &r, &w, expr, 0, TRUE)
! 									  < 0)
  # endif
      {
  	if (r != NULL)
--- 8529,8547 ----
      if (check_connection() == FAIL)
  	return;
  # endif
+     if (argvars[2].v_type != VAR_UNKNOWN
+ 	    && argvars[3].v_type != VAR_UNKNOWN)
+ 	timeout = get_tv_number(&argvars[3]);
  
      server_name = get_tv_string_chk(&argvars[0]);
      if (server_name == NULL)
  	return;		/* type error; errmsg already given */
      keys = get_tv_string_buf(&argvars[1], buf);
  # ifdef WIN32
!     if (serverSendToVim(server_name, keys, &r, &w, expr, timeout, TRUE) < 0)
  # else
!     if (serverSendToVim(X_DISPLAY, server_name, keys, &r, &w, expr, timeout,
! 								  0, TRUE) < 0)
  # endif
      {
  	if (r != NULL)
***************
*** 8555,8567 ****
  	char_u		str[30];
  	char_u		*idvar;
  
- 	sprintf((char *)str, PRINTF_HEX_LONG_U, (long_u)w);
- 	v.di_tv.v_type = VAR_STRING;
- 	v.di_tv.vval.v_string = vim_strsave(str);
  	idvar = get_tv_string_chk(&argvars[2]);
! 	if (idvar != NULL)
  	    set_var(idvar, &v.di_tv, FALSE);
! 	vim_free(v.di_tv.vval.v_string);
      }
  }
  #endif
--- 8559,8573 ----
  	char_u		str[30];
  	char_u		*idvar;
  
  	idvar = get_tv_string_chk(&argvars[2]);
! 	if (idvar != NULL && *idvar != NUL)
! 	{
! 	    sprintf((char *)str, PRINTF_HEX_LONG_U, (long_u)w);
! 	    v.di_tv.v_type = VAR_STRING;
! 	    v.di_tv.vval.v_string = vim_strsave(str);
  	    set_var(idvar, &v.di_tv, FALSE);
! 	    vim_free(v.di_tv.vval.v_string);
! 	}
      }
  }
  #endif
***************
*** 8633,8639 ****
  	rettv->vval.v_number = -1;
      else
      {
! 	s = serverGetReply((HWND)n, FALSE, FALSE, FALSE);
  	rettv->vval.v_number = (s != NULL);
      }
  # else
--- 8639,8645 ----
  	rettv->vval.v_number = -1;
      else
      {
! 	s = serverGetReply((HWND)n, FALSE, FALSE, FALSE, 0);
  	rettv->vval.v_number = (s != NULL);
      }
  # else
***************
*** 8670,8686 ****
  
      if (serverid != NULL && !check_restricted() && !check_secure())
      {
  # ifdef WIN32
  	/* The server's HWND is encoded in the 'id' parameter */
  	long_u		n = 0;
  
  	sscanf((char *)serverid, SCANF_HEX_LONG_U, &n);
  	if (n != 0)
! 	    r = serverGetReply((HWND)n, FALSE, TRUE, TRUE);
  	if (r == NULL)
  # else
! 	if (check_connection() == FAIL || serverReadReply(X_DISPLAY,
! 		serverStrToWin(serverid), &r, FALSE) < 0)
  # endif
  	    EMSG(_("E277: Unable to read a server reply"));
      }
--- 8676,8698 ----
  
      if (serverid != NULL && !check_restricted() && !check_secure())
      {
+ 	int timeout = 0;
+ 
+ 	if (argvars[1].v_type != VAR_UNKNOWN)
+ 	    timeout = get_tv_number(&argvars[1]);
+ 
  # ifdef WIN32
  	/* The server's HWND is encoded in the 'id' parameter */
  	long_u		n = 0;
  
  	sscanf((char *)serverid, SCANF_HEX_LONG_U, &n);
  	if (n != 0)
! 	    r = serverGetReply((HWND)n, FALSE, TRUE, TRUE, timeout);
  	if (r == NULL)
  # else
! 	if (check_connection() == FAIL
! 		|| serverReadReply(X_DISPLAY, serverStrToWin(serverid),
! 						       &r, FALSE, timeout) < 0)
  # endif
  	    EMSG(_("E277: Unable to read a server reply"));
      }
*** ../vim-8.0.0491/src/if_xcmdsrv.c	2017-03-18 19:41:45.900072865 +0100
--- src/if_xcmdsrv.c	2017-03-19 20:45:35.012499137 +0100
***************
*** 373,378 ****
--- 373,379 ----
      char_u	**result,		/* Result of eval'ed expression */
      Window	*server,		/* Actual ID of receiving app */
      Bool	asExpr,			/* Interpret as keystrokes or expr ? */
+     int		timeout,		/* seconds to wait or zero */
      Bool	localLoop,		/* Throw away everything but result */
      int		silent)			/* don't complain about no server */
  {
***************
*** 485,491 ****
      pending.nextPtr = pendingCommands;
      pendingCommands = &pending;
  
!     ServerWait(dpy, w, WaitForPend, &pending, localLoop, 600);
  
      /*
       * Unregister the information about the pending command
--- 486,493 ----
      pending.nextPtr = pendingCommands;
      pendingCommands = &pending;
  
!     ServerWait(dpy, w, WaitForPend, &pending, localLoop,
! 						  timeout > 0 ? timeout : 600);
  
      /*
       * Unregister the information about the pending command
***************
*** 790,795 ****
--- 792,798 ----
  
  /*
   * Wait for replies from id (win)
+  * When "timeout" is non-zero wait up to this many seconds.
   * Return 0 and the malloc'ed string when a reply is available.
   * Return -1 if the window becomes invalid while waiting.
   */
***************
*** 798,810 ****
      Display	*dpy,
      Window	win,
      char_u	**str,
!     int		localLoop)
  {
      int		len;
      char_u	*s;
      struct	ServerReply *p;
  
!     ServerWait(dpy, win, WaitForReply, &win, localLoop, -1);
  
      if ((p = ServerReplyFind(win, SROP_Find)) != NULL && p->strings.ga_len > 0)
      {
--- 801,815 ----
      Display	*dpy,
      Window	win,
      char_u	**str,
!     int		localLoop,
!     int		timeout)
  {
      int		len;
      char_u	*s;
      struct	ServerReply *p;
  
!     ServerWait(dpy, win, WaitForReply, &win, localLoop,
! 						   timeout > 0 ? timeout : -1);
  
      if ((p = ServerReplyFind(win, SROP_Find)) != NULL && p->strings.ga_len > 0)
      {
*** ../vim-8.0.0491/src/proto/if_xcmdsrv.pro	2016-09-12 13:04:09.000000000 +0200
--- src/proto/if_xcmdsrv.pro	2017-03-19 20:45:03.084732948 +0100
***************
*** 1,11 ****
  /* if_xcmdsrv.c */
  int serverRegisterName(Display *dpy, char_u *name);
  void serverChangeRegisteredWindow(Display *dpy, Window newwin);
! int serverSendToVim(Display *dpy, char_u *name, char_u *cmd, char_u **result, Window *server, int asExpr, int localLoop, int silent);
  char_u *serverGetVimNames(Display *dpy);
  Window serverStrToWin(char_u *str);
  int serverSendReply(char_u *name, char_u *str);
! int serverReadReply(Display *dpy, Window win, char_u **str, int localLoop);
  int serverPeekReply(Display *dpy, Window win, char_u **str);
  void serverEventProc(Display *dpy, XEvent *eventPtr, int immediate);
  void server_parse_messages(void);
--- 1,11 ----
  /* if_xcmdsrv.c */
  int serverRegisterName(Display *dpy, char_u *name);
  void serverChangeRegisteredWindow(Display *dpy, Window newwin);
! int serverSendToVim(Display *dpy, char_u *name, char_u *cmd, char_u **result, Window *server, int asExpr, int timeout, int localLoop, int silent);
  char_u *serverGetVimNames(Display *dpy);
  Window serverStrToWin(char_u *str);
  int serverSendReply(char_u *name, char_u *str);
! int serverReadReply(Display *dpy, Window win, char_u **str, int localLoop, int timeout);
  int serverPeekReply(Display *dpy, Window win, char_u **str);
  void serverEventProc(Display *dpy, XEvent *eventPtr, int immediate);
  void server_parse_messages(void);
*** ../vim-8.0.0491/src/main.c	2017-03-18 18:15:12.681524375 +0100
--- src/main.c	2017-03-19 20:52:58.173254682 +0100
***************
*** 3791,3800 ****
  	    }
  	    else
  		ret = serverSendToVim(xterm_dpy, sname, *serverStr,
! 						    NULL, &srv, 0, 0, silent);
  # else
  	    /* Win32 always works? */
! 	    ret = serverSendToVim(sname, *serverStr, NULL, &srv, 0, silent);
  # endif
  	    if (ret < 0)
  	    {
--- 3791,3800 ----
  	    }
  	    else
  		ret = serverSendToVim(xterm_dpy, sname, *serverStr,
! 						  NULL, &srv, 0, 0, 0, silent);
  # else
  	    /* Win32 always works? */
! 	    ret = serverSendToVim(sname, *serverStr, NULL, &srv, 0, 0, silent);
  # endif
  	    if (ret < 0)
  	    {
***************
*** 3854,3864 ****
  		while (memchr(done, 0, numFiles) != NULL)
  		{
  # ifdef WIN32
! 		    p = serverGetReply(srv, NULL, TRUE, TRUE);
  		    if (p == NULL)
  			break;
  # else
! 		    if (serverReadReply(xterm_dpy, srv, &p, TRUE) < 0)
  			break;
  # endif
  		    j = atoi((char *)p);
--- 3854,3864 ----
  		while (memchr(done, 0, numFiles) != NULL)
  		{
  # ifdef WIN32
! 		    p = serverGetReply(srv, NULL, TRUE, TRUE, 0);
  		    if (p == NULL)
  			break;
  # else
! 		    if (serverReadReply(xterm_dpy, srv, &p, TRUE, -1) < 0)
  			break;
  # endif
  		    j = atoi((char *)p);
***************
*** 3885,3896 ****
  # ifdef WIN32
  	    /* Win32 always works? */
  	    if (serverSendToVim(sname, (char_u *)argv[i + 1],
! 						    &res, NULL, 1, FALSE) < 0)
  # else
  	    if (xterm_dpy == NULL)
  		mch_errmsg(_("No display: Send expression failed.\n"));
  	    else if (serverSendToVim(xterm_dpy, sname, (char_u *)argv[i + 1],
! 						 &res, NULL, 1, 1, FALSE) < 0)
  # endif
  	    {
  		if (res != NULL && *res != NUL)
--- 3885,3896 ----
  # ifdef WIN32
  	    /* Win32 always works? */
  	    if (serverSendToVim(sname, (char_u *)argv[i + 1],
! 						  &res, NULL, 1, 0, FALSE) < 0)
  # else
  	    if (xterm_dpy == NULL)
  		mch_errmsg(_("No display: Send expression failed.\n"));
  	    else if (serverSendToVim(xterm_dpy, sname, (char_u *)argv[i + 1],
! 					       &res, NULL, 1, 0, 1, FALSE) < 0)
  # endif
  	    {
  		if (res != NULL && *res != NUL)
*** ../vim-8.0.0491/src/os_mswin.c	2017-03-18 21:22:42.503765361 +0100
--- src/os_mswin.c	2017-03-19 20:51:53.601727325 +0100
***************
*** 2401,2406 ****
--- 2401,2407 ----
      char_u	 **result,		/* Result of eval'ed expression */
      void	 *ptarget,		/* HWND of server */
      int		 asExpr,		/* Expression or keys? */
+     int		 timeout,		/* timeout in seconds or zero */
      int		 silent)		/* don't complain about no server */
  {
      HWND	target;
***************
*** 2444,2450 ****
  	return -1;
  
      if (asExpr)
! 	retval = serverGetReply(target, &retcode, TRUE, TRUE);
  
      if (result == NULL)
  	vim_free(retval);
--- 2445,2451 ----
  	return -1;
  
      if (asExpr)
! 	retval = serverGetReply(target, &retcode, TRUE, TRUE, timeout);
  
      if (result == NULL)
  	vim_free(retval);
***************
*** 2521,2534 ****
   * if "wait" is TRUE block until a message arrives (or the server exits).
   */
      char_u *
! serverGetReply(HWND server, int *expr_res, int remove, int wait)
  {
      int		i;
      char_u	*reply;
      reply_T	*rep;
      int		did_process = FALSE;
  
      /* When waiting, loop until the message waiting for is received. */
      for (;;)
      {
  	/* Reset this here, in case a message arrives while we are going
--- 2522,2538 ----
   * if "wait" is TRUE block until a message arrives (or the server exits).
   */
      char_u *
! serverGetReply(HWND server, int *expr_res, int remove, int wait, int timeout)
  {
      int		i;
      char_u	*reply;
      reply_T	*rep;
      int		did_process = FALSE;
+     time_t	start;
+     time_t	now;
  
      /* When waiting, loop until the message waiting for is received. */
+     time(&start);
      for (;;)
      {
  	/* Reset this here, in case a message arrives while we are going
***************
*** 2584,2589 ****
--- 2588,2597 ----
  #ifdef FEAT_TIMERS
  	    check_due_timer();
  #endif
+ 	    time(&now);
+ 	    if (timeout > 0 && (now - start) >= timeout)
+ 		break;
+ 
  	    /* Wait for a SendMessage() call to us.  This could be the reply
  	     * we are waiting for.  Use a timeout of a second, to catch the
  	     * situation that the server died unexpectedly. */
*** ../vim-8.0.0491/src/proto/os_mswin.pro	2016-10-12 14:19:55.754357695 +0200
--- src/proto/os_mswin.pro	2017-03-19 20:55:50.259994775 +0100
***************
*** 43,51 ****
  void serverSetName(char_u *name);
  char_u *serverGetVimNames(void);
  int serverSendReply(char_u *name, char_u *reply);
! int serverSendToVim(char_u *name, char_u *cmd, char_u **result, void *ptarget, int asExpr, int silent);
  void serverForeground(char_u *name);
! char_u *serverGetReply(HWND server, int *expr_res, int remove, int wait);
  void serverProcessPendingMessages(void);
  char *charset_id2name(int id);
  char *quality_id2name(DWORD id);
--- 43,51 ----
  void serverSetName(char_u *name);
  char_u *serverGetVimNames(void);
  int serverSendReply(char_u *name, char_u *reply);
! int serverSendToVim(char_u *name, char_u *cmd, char_u **result, void *ptarget, int asExpr, int timeout, int silent);
  void serverForeground(char_u *name);
! char_u *serverGetReply(HWND server, int *expr_res, int remove, int wait, int timeout);
  void serverProcessPendingMessages(void);
  char *charset_id2name(int id);
  char *quality_id2name(DWORD id);
*** ../vim-8.0.0491/src/vim.h	2017-03-16 17:23:26.839815753 +0100
--- src/vim.h	2017-03-19 20:55:40.456066595 +0100
***************
*** 2506,2512 ****
  #  define ELAPSED_INIT(v) v = GetTickCount()
  #  define ELAPSED_FUNC(v) elapsed(v)
  #  define ELAPSED_TYPE DWORD
!     long elapsed(DWORD start_tick);
  # endif
  #endif
  
--- 2506,2514 ----
  #  define ELAPSED_INIT(v) v = GetTickCount()
  #  define ELAPSED_FUNC(v) elapsed(v)
  #  define ELAPSED_TYPE DWORD
! #   ifndef PROTO
!      long elapsed(DWORD start_tick);
! #   endif
  # endif
  #endif
  
*** ../vim-8.0.0491/runtime/doc/eval.txt	2017-03-18 19:41:45.904072837 +0100
--- runtime/doc/eval.txt	2017-03-19 20:40:19.934806870 +0100
***************
*** 6302,6316 ****
  		{only available when compiled with the |+reltime| feature}
  
  							*remote_expr()* *E449*
! remote_expr({server}, {string} [, {idvar}])
  		Send the {string} to {server}.  The string is sent as an
  		expression and the result is returned after evaluation.
  		The result must be a String or a |List|.  A |List| is turned
  		into a String by joining the items with a line break in
  		between (not at the end), like with join(expr, "\n").
! 		If {idvar} is present, it is taken as the name of a
! 		variable and a {serverid} for later use with
  		remote_read() is stored there.
  		See also |clientserver| |RemoteReply|.
  		This function is not available in the |sandbox|.
  		{only available when compiled with the |+clientserver| feature}
--- 6320,6336 ----
  		{only available when compiled with the |+reltime| feature}
  
  							*remote_expr()* *E449*
! remote_expr({server}, {string} [, {idvar} [, {timeout}]])
  		Send the {string} to {server}.  The string is sent as an
  		expression and the result is returned after evaluation.
  		The result must be a String or a |List|.  A |List| is turned
  		into a String by joining the items with a line break in
  		between (not at the end), like with join(expr, "\n").
! 		If {idvar} is present and not empty, it is taken as the name
! 		of a variable and a {serverid} for later use with
  		remote_read() is stored there.
+ 		If {timeout} is given the read times out after this many
+ 		seconds.  Otherwise a timeout of 600 seconds is used.
  		See also |clientserver| |RemoteReply|.
  		This function is not available in the |sandbox|.
  		{only available when compiled with the |+clientserver| feature}
***************
*** 6349,6357 ****
  			:let repl = ""
  			:echo "PEEK: ".remote_peek(id, "repl").": ".repl
  
! remote_read({serverid})				*remote_read()*
  		Return the oldest available reply from {serverid} and consume
! 		it.  It blocks until a reply is available.
  		See also |clientserver|.
  		This function is not available in the |sandbox|.
  		{only available when compiled with the |+clientserver| feature}
--- 6369,6378 ----
  			:let repl = ""
  			:echo "PEEK: ".remote_peek(id, "repl").": ".repl
  
! remote_read({serverid}, [{timeout}])			*remote_read()*
  		Return the oldest available reply from {serverid} and consume
! 		it.  Unless a {timeout} in seconds is given, it blocks until a
! 		reply is available.
  		See also |clientserver|.
  		This function is not available in the |sandbox|.
  		{only available when compiled with the |+clientserver| feature}
*** ../vim-8.0.0491/src/testdir/test_clientserver.vim	2017-03-18 20:45:01.288381154 +0100
--- src/testdir/test_clientserver.vim	2017-03-19 21:16:35.586870697 +0100
***************
*** 6,27 ****
  
  source shared.vim
  
- let s:where = 0
- func Abort(id)
-   call assert_report('Test timed out at ' . s:where)
-   call FinishTesting()
- endfunc
- 
  func Test_client_server()
    let cmd = GetVimCommand()
    if cmd == ''
      return
    endif
  
-   " Some of these commands may hang when failing.
-   call timer_start(10000, 'Abort')
- 
-   let s:where = 1
    let name = 'XVIMTEST'
    let cmd .= ' --servername ' . name
    let g:job = job_start(cmd, {'stoponexit': 'kill', 'out_io': 'null'})
--- 6,17 ----
***************
*** 30,91 ****
      call assert_report('Cannot run the Vim server')
      return
    endif
-   let s:where = 2
  
    " Takes a short while for the server to be active.
    call WaitFor('serverlist() =~ "' . name . '"')
    call assert_match(name, serverlist())
-   let s:where = 3
  
    call remote_foreground(name)
-   let s:where = 4
  
    call remote_send(name, ":let testvar = 'yes'\<CR>")
!   let s:where = 5
!   call WaitFor('remote_expr("' . name . '", "testvar") == "yes"')
!   let s:where = 6
!   call assert_equal('yes', remote_expr(name, "testvar"))
!   let s:where = 7
  
    if has('unix') && has('gui') && !has('gui_running')
      " Running in a terminal and the GUI is avaiable: Tell the server to open
      " the GUI and check that the remote command still works.
      " Need to wait for the GUI to start up, otherwise the send hangs in trying
      " to send to the terminal window.
!     call remote_send(name, ":gui -f\<CR>")
!     let s:where = 8
!     sleep 500m
      call remote_send(name, ":let testvar = 'maybe'\<CR>")
!     let s:where = 9
!     call WaitFor('remote_expr("' . name . '", "testvar") == "maybe"')
!     let s:where = 10
!     call assert_equal('maybe', remote_expr(name, "testvar"))
!     let s:where = 11
    endif
  
    call assert_fails('call remote_send("XXX", ":let testvar = ''yes''\<CR>")', 'E241')
-   let s:where = 12
  
    " Expression evaluated locally.
    if v:servername == ''
      call remote_startserver('MYSELF')
!     let s:where = 13
!     call assert_equal('MYSELF', v:servername)
    endif
    let g:testvar = 'myself'
    call assert_equal('myself', remote_expr(v:servername, 'testvar'))
-   let s:where = 14
  
    call remote_send(name, ":call server2client(expand('<client>'), 'got it')\<CR>", 'g:myserverid')
!   let s:where = 15
!   call assert_equal('got it', remote_read(g:myserverid))
!   let s:where = 16
  
    call remote_send(name, ":call server2client(expand('<client>'), 'another')\<CR>", 'g:myserverid')
-   let s:where = 151
    let peek_result = 'nothing'
    let r = remote_peek(g:myserverid, 'peek_result')
-   let s:where = 161
    " unpredictable whether the result is already avaialble.
    if r > 0
      call assert_equal('another', peek_result)
--- 20,72 ----
      call assert_report('Cannot run the Vim server')
      return
    endif
  
    " Takes a short while for the server to be active.
    call WaitFor('serverlist() =~ "' . name . '"')
    call assert_match(name, serverlist())
  
    call remote_foreground(name)
  
    call remote_send(name, ":let testvar = 'yes'\<CR>")
!   call WaitFor('remote_expr("' . name . '", "testvar", "", 1) == "yes"')
!   call assert_equal('yes', remote_expr(name, "testvar", "", 2))
  
    if has('unix') && has('gui') && !has('gui_running')
      " Running in a terminal and the GUI is avaiable: Tell the server to open
      " the GUI and check that the remote command still works.
      " Need to wait for the GUI to start up, otherwise the send hangs in trying
      " to send to the terminal window.
!     if has('gui_athena') || has('gui_motif')
!       " For those GUIs, ignore the 'failed to create input context' error.
!       call remote_send(name, ":call test_ignore_error('E285') | gui -f\<CR>")
!     else
!       call remote_send(name, ":gui -f\<CR>")
!     endif
!     " Wait for the server to be up and answering requests.
!     call WaitFor('remote_expr("' . name . '", "v:version", "", 1) != ""')
! 
      call remote_send(name, ":let testvar = 'maybe'\<CR>")
!     call WaitFor('remote_expr("' . name . '", "testvar", "", 1) == "maybe"')
!     call assert_equal('maybe', remote_expr(name, "testvar", "", 2))
    endif
  
    call assert_fails('call remote_send("XXX", ":let testvar = ''yes''\<CR>")', 'E241')
  
    " Expression evaluated locally.
    if v:servername == ''
      call remote_startserver('MYSELF')
!     " May get MYSELF1 when running the test again.
!     call assert_match('MYSELF', v:servername)
    endif
    let g:testvar = 'myself'
    call assert_equal('myself', remote_expr(v:servername, 'testvar'))
  
    call remote_send(name, ":call server2client(expand('<client>'), 'got it')\<CR>", 'g:myserverid')
!   call assert_equal('got it', remote_read(g:myserverid, 2))
  
    call remote_send(name, ":call server2client(expand('<client>'), 'another')\<CR>", 'g:myserverid')
    let peek_result = 'nothing'
    let r = remote_peek(g:myserverid, 'peek_result')
    " unpredictable whether the result is already avaialble.
    if r > 0
      call assert_equal('another', peek_result)
***************
*** 96,111 ****
    endif
    let g:peek_result = 'empty'
    call WaitFor('remote_peek(g:myserverid, "g:peek_result") > 0')
-   let s:where = 171
    call assert_equal('another', g:peek_result)
!   let s:where = 181
!   call assert_equal('another', remote_read(g:myserverid))
!   let s:where = 191
  
    call remote_send(name, ":qa!\<CR>")
-   let s:where = 17
    call WaitFor('job_status(g:job) == "dead"')
-   let s:where = 18
    if job_status(g:job) != 'dead'
      call assert_report('Server did not exit')
      call job_stop(g:job, 'kill')
--- 77,87 ----
    endif
    let g:peek_result = 'empty'
    call WaitFor('remote_peek(g:myserverid, "g:peek_result") > 0')
    call assert_equal('another', g:peek_result)
!   call assert_equal('another', remote_read(g:myserverid, 2))
  
    call remote_send(name, ":qa!\<CR>")
    call WaitFor('job_status(g:job) == "dead"')
    if job_status(g:job) != 'dead'
      call assert_report('Server did not exit')
      call job_stop(g:job, 'kill')
*** ../vim-8.0.0491/src/version.c	2017-03-19 21:01:09.721654997 +0100
--- src/version.c	2017-03-19 21:04:48.628052187 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     492,
  /**/

-- 
Keep America beautiful.  Swallow your beer cans.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0493
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0493
Problem:    Crash with cd command with very long argument.
Solution:   Check for running out of space. (Dominique pending, closes #1576)
Files:      src/testdir/test_alot.vim, src/testdir/test_cd.vim, src/Makefile,
            src/misc2.c


*** ../vim-8.0.0492/src/testdir/test_alot.vim	2017-03-19 16:09:41.157653918 +0100
--- src/testdir/test_alot.vim	2017-03-19 21:28:46.113515367 +0100
***************
*** 3,8 ****
--- 3,9 ----
  
  set belloff=all
  source test_assign.vim
+ source test_cd.vim
  source test_changedtick.vim
  source test_cursor_func.vim
  source test_delete.vim
*** ../vim-8.0.0492/src/testdir/test_cd.vim	2017-03-19 21:35:57.194342899 +0100
--- src/testdir/test_cd.vim	2017-03-19 21:32:54.723687379 +0100
***************
*** 0 ****
--- 1,13 ----
+ " Test for :cd
+ 
+ func Test_cd_large_path()
+   " This used to crash with a heap write overflow.
+   call assert_fails('cd ' . repeat('x', 5000), 'E472:')
+ endfunc
+ 
+ func Test_cd_up_and_down()
+   let path = getcwd()
+   cd ..
+   exe 'cd ' . path
+   call assert_equal(path, getcwd())
+ endfunc
*** ../vim-8.0.0492/src/Makefile	2017-03-19 20:04:05.534628090 +0100
--- src/Makefile	2017-03-19 21:30:40.968673319 +0100
***************
*** 2096,2101 ****
--- 2095,2101 ----
  	test_backspace_opt \
  	test_breakindent \
  	test_bufwintabinfo \
+ 	test_cd \
  	test_cdo \
  	test_changedtick \
  	test_channel \
*** ../vim-8.0.0492/src/misc2.c	2017-03-16 19:58:19.420253384 +0100
--- src/misc2.c	2017-03-19 21:31:13.644432427 +0100
***************
*** 4637,4649 ****
  		if (!vim_isAbsName(stackp->ffs_fix_path)
  						&& search_ctx->ffsc_start_dir)
  		{
! 		    STRCPY(file_path, search_ctx->ffsc_start_dir);
! 		    add_pathsep(file_path);
  		}
  
  		/* append the fix part of the search path */
! 		STRCAT(file_path, stackp->ffs_fix_path);
! 		add_pathsep(file_path);
  
  #ifdef FEAT_PATH_EXTRA
  		rest_of_wildcards = stackp->ffs_wc_path;
--- 4637,4659 ----
  		if (!vim_isAbsName(stackp->ffs_fix_path)
  						&& search_ctx->ffsc_start_dir)
  		{
! 		    if (STRLEN(search_ctx->ffsc_start_dir) + 1 < MAXPATHL)
! 		    {
! 			STRCPY(file_path, search_ctx->ffsc_start_dir);
! 			add_pathsep(file_path);
! 		    }
! 		    else
! 			goto fail;
  		}
  
  		/* append the fix part of the search path */
! 		if (STRLEN(file_path) + STRLEN(stackp->ffs_fix_path) + 1 < MAXPATHL)
! 		{
! 		    STRCAT(file_path, stackp->ffs_fix_path);
! 		    add_pathsep(file_path);
! 		}
! 		else
! 		    goto fail;
  
  #ifdef FEAT_PATH_EXTRA
  		rest_of_wildcards = stackp->ffs_wc_path;
***************
*** 4660,4666 ****
  			if (*p > 0)
  			{
  			    (*p)--;
! 			    file_path[len++] = '*';
  			}
  
  			if (*p == 0)
--- 4670,4679 ----
  			if (*p > 0)
  			{
  			    (*p)--;
! 			    if (len + 1 < MAXPATHL)
! 				file_path[len++] = '*';
! 			    else
! 				goto fail;
  			}
  
  			if (*p == 0)
***************
*** 4688,4694 ****
  		     */
  		    while (*rest_of_wildcards
  			    && !vim_ispathsep(*rest_of_wildcards))
! 			file_path[len++] = *rest_of_wildcards++;
  
  		    file_path[len] = NUL;
  		    if (vim_ispathsep(*rest_of_wildcards))
--- 4701,4710 ----
  		     */
  		    while (*rest_of_wildcards
  			    && !vim_ispathsep(*rest_of_wildcards))
! 			if (len + 1 < MAXPATHL)
! 			    file_path[len++] = *rest_of_wildcards++;
! 			else
! 			    goto fail;
  
  		    file_path[len] = NUL;
  		    if (vim_ispathsep(*rest_of_wildcards))
***************
*** 4749,4757 ****
  
  			/* prepare the filename to be checked for existence
  			 * below */
! 			STRCPY(file_path, stackp->ffs_filearray[i]);
! 			add_pathsep(file_path);
! 			STRCAT(file_path, search_ctx->ffsc_file_to_search);
  
  			/*
  			 * Try without extra suffix and then with suffixes
--- 4765,4779 ----
  
  			/* prepare the filename to be checked for existence
  			 * below */
! 			if (STRLEN(stackp->ffs_filearray[i]) + 1
! 				+ STRLEN(search_ctx->ffsc_file_to_search) < MAXPATHL)
! 			{
! 			    STRCPY(file_path, stackp->ffs_filearray[i]);
! 			    add_pathsep(file_path);
! 			    STRCAT(file_path, search_ctx->ffsc_file_to_search);
! 			}
! 			else
! 			    goto fail;
  
  			/*
  			 * Try without extra suffix and then with suffixes
***************
*** 4924,4932 ****
  	    if (*search_ctx->ffsc_start_dir == 0)
  		break;
  
! 	    STRCPY(file_path, search_ctx->ffsc_start_dir);
! 	    add_pathsep(file_path);
! 	    STRCAT(file_path, search_ctx->ffsc_fix_path);
  
  	    /* create a new stack entry */
  	    sptr = ff_create_stack_element(file_path,
--- 4946,4960 ----
  	    if (*search_ctx->ffsc_start_dir == 0)
  		break;
  
! 	    if (STRLEN(search_ctx->ffsc_start_dir) + 1
! 		    + STRLEN(search_ctx->ffsc_fix_path) < MAXPATHL)
! 	    {
! 		STRCPY(file_path, search_ctx->ffsc_start_dir);
! 		add_pathsep(file_path);
! 		STRCAT(file_path, search_ctx->ffsc_fix_path);
! 	    }
! 	    else
! 		goto fail;
  
  	    /* create a new stack entry */
  	    sptr = ff_create_stack_element(file_path,
***************
*** 4940,4945 ****
--- 4968,4974 ----
      }
  #endif
  
+ fail:
      vim_free(file_path);
      return NULL;
  }
*** ../vim-8.0.0492/src/version.c	2017-03-19 21:20:45.893034321 +0100
--- src/version.c	2017-03-19 21:36:06.614273508 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     493,
  /**/

-- 
Apathy Error: Don't bother striking any key.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0494
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0494
Problem:    Build failure with older compiler on MS-Windows.
Solution:   Move declaration to start of block.
Files:      src/evalfunc.c, src/main.c, src/os_mswin.c


*** ../vim-8.0.0493/src/evalfunc.c	2017-03-19 21:20:45.885034380 +0100
--- src/evalfunc.c	2017-03-19 21:43:55.051160771 +0100
***************
*** 8677,8690 ****
      if (serverid != NULL && !check_restricted() && !check_secure())
      {
  	int timeout = 0;
  
  	if (argvars[1].v_type != VAR_UNKNOWN)
  	    timeout = get_tv_number(&argvars[1]);
  
  # ifdef WIN32
- 	/* The server's HWND is encoded in the 'id' parameter */
- 	long_u		n = 0;
- 
  	sscanf((char *)serverid, SCANF_HEX_LONG_U, &n);
  	if (n != 0)
  	    r = serverGetReply((HWND)n, FALSE, TRUE, TRUE, timeout);
--- 8677,8691 ----
      if (serverid != NULL && !check_restricted() && !check_secure())
      {
  	int timeout = 0;
+ # ifdef WIN32
+ 	/* The server's HWND is encoded in the 'id' parameter */
+ 	long_u		n = 0;
+ # endif
  
  	if (argvars[1].v_type != VAR_UNKNOWN)
  	    timeout = get_tv_number(&argvars[1]);
  
  # ifdef WIN32
  	sscanf((char *)serverid, SCANF_HEX_LONG_U, &n);
  	if (n != 0)
  	    r = serverGetReply((HWND)n, FALSE, TRUE, TRUE, timeout);
*** ../vim-8.0.0493/src/main.c	2017-03-19 21:20:45.885034380 +0100
--- src/main.c	2017-03-19 21:46:16.621783244 +0100
***************
*** 4194,4200 ****
  		size_t	len = STRLEN(cmd) + STRLEN(err) + 5;
  		char_u	*msg;
  
! 		msg = alloc(len);
  		if (msg != NULL)
  		    vim_snprintf((char *)msg, len, "%s: \"%s\"", err, cmd);
  		*result = msg;
--- 4194,4200 ----
  		size_t	len = STRLEN(cmd) + STRLEN(err) + 5;
  		char_u	*msg;
  
! 		msg = alloc((unsigned)len);
  		if (msg != NULL)
  		    vim_snprintf((char *)msg, len, "%s: \"%s\"", err, cmd);
  		*result = msg;
*** ../vim-8.0.0493/src/os_mswin.c	2017-03-19 21:20:45.889034350 +0100
--- src/os_mswin.c	2017-03-19 21:46:33.873656342 +0100
***************
*** 2111,2117 ****
  		char	*err = _(e_invexprmsg);
  		size_t	len = STRLEN(str) + STRLEN(err) + 5;
  
! 		res = alloc(len);
  		if (res != NULL)
  		    vim_snprintf((char *)res, len, "%s: \"%s\"", err, str);
  		reply.dwData = COPYDATA_ERROR_RESULT;
--- 2111,2117 ----
  		char	*err = _(e_invexprmsg);
  		size_t	len = STRLEN(str) + STRLEN(err) + 5;
  
! 		res = alloc((unsigned)len);
  		if (res != NULL)
  		    vim_snprintf((char *)res, len, "%s: \"%s\"", err, str);
  		reply.dwData = COPYDATA_ERROR_RESULT;
*** ../vim-8.0.0493/src/version.c	2017-03-19 21:36:52.825933116 +0100
--- src/version.c	2017-03-19 21:47:27.897258987 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     494,
  /**/

-- 
An error has occurred.  Hit any user to continue.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0495
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0495
Problem:    The quotestar test uses a timer instead of a timeout, thus it
            cannot be rerun like a flaky test.
Solution:   Remove the timer and add a timeout. (Kazunobu Kuriyama)
Files:      src/testdir/test_quotestar.vim


*** ../vim-8.0.0494/src/testdir/test_quotestar.vim	2017-03-19 21:01:09.721654997 +0100
--- src/testdir/test_quotestar.vim	2017-03-20 21:39:23.183541069 +0100
***************
*** 6,17 ****
  
  source shared.vim
  
- let s:where = 0
- func Abort(id)
-   call assert_report('Test timed out at ' . s:where)
-   call FinishTesting()
- endfunc
- 
  func Do_test_quotestar_for_macunix()
    if empty(exepath('pbcopy')) || empty(exepath('pbpaste'))
      return 'Test requires pbcopy(1) and pbpaste(1)'
--- 6,11 ----
***************
*** 46,55 ****
      return 'GetVimCommand() failed'
    endif
  
-   " Some of these commands may hang when failing.
-   call timer_start(10000, 'Abort')
- 
-   let s:where = 1
    let name = 'XVIMCLIPBOARD'
    let cmd .= ' --servername ' . name
    let g:job = job_start(cmd, {'stoponexit': 'kill', 'out_io': 'null'})
--- 40,45 ----
***************
*** 58,82 ****
      call assert_report('Cannot run the Vim server')
      return ''
    endif
-   let s:where = 2
  
    " Takes a short while for the server to be active.
    call WaitFor('serverlist() =~ "' . name . '"')
    call assert_match(name, serverlist())
-   let s:where = 3
  
    " Clear the *-register of this vim instance.
    let @* = ''
  
    " Try to change the *-register of the server.
    call remote_foreground(name)
-   let s:where = 4
    call remote_send(name, ":let @* = 'yes'\<CR>")
!   let s:where = 5
!   call WaitFor('remote_expr("' . name . '", "@*") == "yes"')
!   let s:where = 6
!   call assert_equal('yes', remote_expr(name, "@*"))
!   let s:where = 7
  
    " Check that the *-register of this vim instance is changed as expected.
    call assert_equal('yes', @*)
--- 48,66 ----
      call assert_report('Cannot run the Vim server')
      return ''
    endif
  
    " Takes a short while for the server to be active.
    call WaitFor('serverlist() =~ "' . name . '"')
    call assert_match(name, serverlist())
  
    " Clear the *-register of this vim instance.
    let @* = ''
  
    " Try to change the *-register of the server.
    call remote_foreground(name)
    call remote_send(name, ":let @* = 'yes'\<CR>")
!   call WaitFor('remote_expr("' . name . '", "@*", "", 1) == "yes"')
!   call assert_equal('yes', remote_expr(name, "@*", "", 2))
  
    " Check that the *-register of this vim instance is changed as expected.
    call assert_equal('yes', @*)
***************
*** 94,115 ****
      else
        call remote_send(name, ":gui -f\<CR>")
      endif
!     let s:where = 8
!     sleep 500m
      call remote_send(name, ":let @* = 'maybe'\<CR>")
!     let s:where = 9
!     call WaitFor('remote_expr("' . name . '", "@*") == "maybe"')
!     let s:where = 10
!     call assert_equal('maybe', remote_expr(name, "@*"))
!     let s:where = 11
  
      call assert_equal('maybe', @*)
    endif
  
    call remote_send(name, ":qa!\<CR>")
-   let s:where = 12
    call WaitFor('job_status(g:job) == "dead"')
-   let s:where = 13
    if job_status(g:job) != 'dead'
      call assert_report('Server did not exit')
      call job_stop(g:job, 'kill')
--- 78,95 ----
      else
        call remote_send(name, ":gui -f\<CR>")
      endif
!     " Wait for the server to be up and answering requests.
!     call WaitFor('remote_expr("' . name . '", "v:version", "", 1) != ""')
! 
      call remote_send(name, ":let @* = 'maybe'\<CR>")
!     call WaitFor('remote_expr("' . name . '", "@*", "", 1) == "maybe"')
!     call assert_equal('maybe', remote_expr(name, "@*", "", 2))
  
      call assert_equal('maybe', @*)
    endif
  
    call remote_send(name, ":qa!\<CR>")
    call WaitFor('job_status(g:job) == "dead"')
    if job_status(g:job) != 'dead'
      call assert_report('Server did not exit')
      call job_stop(g:job, 'kill')
*** ../vim-8.0.0494/src/version.c	2017-03-19 21:47:46.897119250 +0100
--- src/version.c	2017-03-20 21:41:15.442714338 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     495,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
171. You invent another person and chat with yourself in empty chat rooms.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0496
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0496
Problem:    Insufficient testing for folding.
Solution:   Add a couple more fold tests. (Dominique Pelle, closes #1579)
Files:      src/testdir/test_fold.vim


*** ../vim-8.0.0495/src/testdir/test_fold.vim	2017-03-16 15:59:10.688531362 +0100
--- src/testdir/test_fold.vim	2017-03-21 11:35:19.672233835 +0100
***************
*** 9,16 ****
    call setline(1, ['int FuncName() {/*{{{*/', 1, 2, 3, 4, 5, '}/*}}}*/',
  	      \ 'after fold 1', 'after fold 2', 'after fold 3'])
    setl fen fdm=marker
!   " The next ccommands should all copy the same part of the buffer,
!   " regardless of the adressing type, since the part to be copied
    " is folded away
    :1y
    call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/'], getreg(0,1,1))
--- 9,16 ----
    call setline(1, ['int FuncName() {/*{{{*/', 1, 2, 3, 4, 5, '}/*}}}*/',
  	      \ 'after fold 1', 'after fold 2', 'after fold 3'])
    setl fen fdm=marker
!   " The next commands should all copy the same part of the buffer,
!   " regardless of the addressing type, since the part to be copied
    " is folded away
    :1y
    call assert_equal(['int FuncName() {/*{{{*/', '1', '2', '3', '4', '5', '}/*}}}*/'], getreg(0,1,1))
***************
*** 360,362 ****
--- 360,415 ----
    call assert_equal([0, 1, 1, 1, 1, 0, 0, 0, 1, 1], map(range(1, line('$')), 'foldlevel(v:val)'))
    bw!
  endfunc
+ 
+ func Test_folddoopen_folddoclosed()
+   new
+   call setline(1, range(1, 9))
+   set foldmethod=manual
+   1,3 fold
+   6,8 fold
+ 
+   " Test without range.
+   folddoopen   s/$/o/
+   folddoclosed s/$/c/
+   call assert_equal(['1c', '2c', '3c',
+   \                  '4o', '5o',
+   \                  '6c', '7c', '8c',
+   \                  '9o'], getline(1, '$'))
+ 
+   " Test with range.
+   call setline(1, range(1, 9))
+   1,8 folddoopen   s/$/o/
+   4,$ folddoclosed s/$/c/
+   call assert_equal(['1',  '2', '3',
+   \                  '4o', '5o',
+   \                  '6c', '7c', '8c',
+   \                  '9'], getline(1, '$'))
+ 
+   set foldmethod&
+   bw!
+ endfunc
+ 
+ func Test_fold_error()
+   new
+   call setline(1, [1, 2])
+ 
+   for fm in ['indent', 'expr', 'syntax', 'diff']
+     exe 'set foldmethod=' . fm
+     call assert_fails('norm zf', 'E350:')
+     call assert_fails('norm zd', 'E351:')
+     call assert_fails('norm zE', 'E352:')
+   endfor
+ 
+   set foldmethod=manual
+   call assert_fails('norm zd', 'E490:')
+   call assert_fails('norm zo', 'E490:')
+   call assert_fails('3fold',   'E16:')
+ 
+   set foldmethod=marker
+   set nomodifiable
+   call assert_fails('1,2fold', 'E21:')
+ 
+   set modifiable&
+   set foldmethod&
+   bw!
+ endfunc
*** ../vim-8.0.0495/src/version.c	2017-03-20 21:47:12.064090779 +0100
--- src/version.c	2017-03-21 11:48:08.766652920 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     496,
  /**/

-- 
If Microsoft would build a car...
... the oil, water temperature, and alternator warning lights would
all be replaced by a single "General Protection Fault" warning light.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0497
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0497
Problem:    Arabic support is not fully tested.
Solution:   Add more tests for the untested functions.  Comment out
            unreachable code.
Files:      src/arabic.c, src/testdir/test_arabic.vim


*** ../vim-8.0.0496/src/arabic.c	2017-03-04 14:50:15.279549901 +0100
--- src/arabic.c	2017-03-21 12:31:49.015640530 +0100
***************
*** 24,30 ****
--- 24,32 ----
  static int  chg_c_a2i(int cur_c);
  static int  chg_c_a2m(int cur_c);
  static int  chg_c_a2f(int cur_c);
+ #if 0
  static int  chg_c_i2m(int cur_c);
+ #endif
  static int  chg_c_f2m(int cur_c);
  static int  chg_c_laa2i(int hid_c);
  static int  chg_c_laa2f(int hid_c);
***************
*** 418,424 ****
--- 420,429 ----
  
  /*
   * Change shape - from Initial to Medial
+  * This code is unreachable, because for the relevant characters ARABIC_CHAR()
+  * is FALSE;
   */
+ #if 0
      static int
  chg_c_i2m(int cur_c)
  {
***************
*** 450,455 ****
--- 455,461 ----
      }
      return 0;
  }
+ #endif
  
  
  /*
***************
*** 608,614 ****
--- 614,624 ----
      else if (!shape_c || A_is_f(shape_c) || A_is_s(shape_c) || prev_laa)
  	curr_c = A_is_valid(next_c) ? chg_c_a2i(c) : chg_c_a2s(c);
      else if (A_is_valid(next_c))
+ #if 0
  	curr_c = A_is_iso(c) ? chg_c_a2m(c) : chg_c_i2m(c);
+ #else
+ 	curr_c = A_is_iso(c) ? chg_c_a2m(c) : 0;
+ #endif
      else if (A_is_valid(prev_c))
  	curr_c = chg_c_a2f(c);
      else
*** ../vim-8.0.0496/src/testdir/test_arabic.vim	2017-03-01 14:02:25.554677542 +0100
--- src/testdir/test_arabic.vim	2017-03-21 13:15:36.192542191 +0100
***************
*** 1,4 ****
--- 1,6 ----
  " Simplistic testing of Arabic mode.
+ " NOTE: This just checks if the code works. If you know Arabic please add
+ " functional tests that check the shaping works with real text.
  
  if !has('arabic') || !has('multi_byte')
    finish
***************
*** 417,423 ****
    bwipe!
  endfunc
  
! func Test_shape_medial()
    new
    set arabicshape
  
--- 419,425 ----
    bwipe!
  endfunc
  
! func Test_shape_iso_to_medial()
    new
    set arabicshape
  
***************
*** 470,472 ****
--- 472,613 ----
    bwipe!
  endfunc
  
+ func Test_shape_final()
+   new
+   set arabicshape
+ 
+   " Shaping arabic {testchar} arabic   Tests chg_c_a2f().
+   " pair[0] = testchar,  pair[1] = current-result, pair[2] = previous-result
+   for pair in [[s:a_HAMZA, s:a_s_HAMZA, s:a_s_BEH],
+ 	\[s:a_ALEF_MADDA, s:a_f_ALEF_MADDA, s:a_i_BEH],
+ 	\[s:a_ALEF_HAMZA_ABOVE, s:a_f_ALEF_HAMZA_ABOVE, s:a_i_BEH],
+ 	\[s:a_WAW_HAMZA, s:a_f_WAW_HAMZA, s:a_i_BEH],
+ 	\[s:a_ALEF_HAMZA_BELOW, s:a_f_ALEF_HAMZA_BELOW, s:a_i_BEH],
+ 	\[s:a_YEH_HAMZA, s:a_f_YEH_HAMZA, s:a_i_BEH],
+ 	\[s:a_ALEF, s:a_f_ALEF, s:a_i_BEH],
+ 	\[s:a_BEH, s:a_f_BEH, s:a_i_BEH],
+ 	\[s:a_TEH_MARBUTA, s:a_f_TEH_MARBUTA, s:a_i_BEH],
+ 	\[s:a_TEH, s:a_f_TEH, s:a_i_BEH],
+ 	\[s:a_THEH, s:a_f_THEH, s:a_i_BEH],
+ 	\[s:a_JEEM, s:a_f_JEEM, s:a_i_BEH],
+ 	\[s:a_HAH, s:a_f_HAH, s:a_i_BEH],
+ 	\[s:a_KHAH, s:a_f_KHAH, s:a_i_BEH],
+ 	\[s:a_DAL, s:a_f_DAL, s:a_i_BEH],
+ 	\[s:a_THAL, s:a_f_THAL, s:a_i_BEH],
+ 	\[s:a_REH, s:a_f_REH, s:a_i_BEH],
+ 	\[s:a_ZAIN, s:a_f_ZAIN, s:a_i_BEH],
+ 	\[s:a_SEEN, s:a_f_SEEN, s:a_i_BEH],
+ 	\[s:a_SHEEN, s:a_f_SHEEN, s:a_i_BEH],
+ 	\[s:a_SAD, s:a_f_SAD, s:a_i_BEH],
+ 	\[s:a_DAD, s:a_f_DAD, s:a_i_BEH],
+ 	\[s:a_TAH, s:a_f_TAH, s:a_i_BEH],
+ 	\[s:a_ZAH, s:a_f_ZAH, s:a_i_BEH],
+ 	\[s:a_AIN, s:a_f_AIN, s:a_i_BEH],
+ 	\[s:a_GHAIN, s:a_f_GHAIN, s:a_i_BEH],
+ 	\[s:a_TATWEEL, s:a_TATWEEL, s:a_i_BEH],
+ 	\[s:a_FEH, s:a_f_FEH, s:a_i_BEH],
+ 	\[s:a_QAF, s:a_f_QAF, s:a_i_BEH],
+ 	\[s:a_KAF, s:a_f_KAF, s:a_i_BEH],
+ 	\[s:a_LAM, s:a_f_LAM, s:a_i_BEH],
+ 	\[s:a_MEEM, s:a_f_MEEM, s:a_i_BEH],
+ 	\[s:a_NOON, s:a_f_NOON, s:a_i_BEH],
+ 	\[s:a_HEH, s:a_f_HEH, s:a_i_BEH],
+ 	\[s:a_WAW, s:a_f_WAW, s:a_i_BEH],
+ 	\[s:a_ALEF_MAKSURA, s:a_f_ALEF_MAKSURA, s:a_i_BEH],
+ 	\[s:a_YEH, s:a_f_YEH, s:a_i_BEH],
+ 	\ ]
+     call setline(1, ' ' . pair[0] . s:a_BEH)
+     call assert_equal([' ' . pair[1] . pair[2]], ScreenLines(1, 3))
+   endfor
+ 
+   set arabicshape&
+   bwipe!
+ endfunc
+ 
+ func Test_shape_final_to_medial()
+   new
+   set arabicshape
+ 
+   " Shaping arabic {testchar} arabic   Tests chg_c_f2m().
+   " This does not test much...
+   " pair[0] = testchar,  pair[1] = current-result
+   for pair in [[s:a_f_YEH_HAMZA, s:a_f_BEH],
+ 	\[s:a_f_WAW_HAMZA, s:a_s_BEH],
+ 	\[s:a_f_ALEF, s:a_s_BEH],
+ 	\[s:a_f_TEH_MARBUTA, s:a_s_BEH],
+ 	\[s:a_f_DAL, s:a_s_BEH],
+ 	\[s:a_f_THAL, s:a_s_BEH],
+ 	\[s:a_f_REH, s:a_s_BEH],
+ 	\[s:a_f_ZAIN, s:a_s_BEH],
+ 	\[s:a_f_WAW, s:a_s_BEH],
+ 	\[s:a_f_ALEF_MAKSURA, s:a_s_BEH],
+ 	\[s:a_f_BEH, s:a_f_BEH],
+ 	\[s:a_f_TEH, s:a_f_BEH],
+ 	\[s:a_f_THEH, s:a_f_BEH],
+ 	\[s:a_f_JEEM, s:a_f_BEH],
+ 	\[s:a_f_HAH, s:a_f_BEH],
+ 	\[s:a_f_KHAH, s:a_f_BEH],
+ 	\[s:a_f_SEEN, s:a_f_BEH],
+ 	\[s:a_f_SHEEN, s:a_f_BEH],
+ 	\[s:a_f_SAD, s:a_f_BEH],
+ 	\[s:a_f_DAD, s:a_f_BEH],
+ 	\[s:a_f_TAH, s:a_f_BEH],
+ 	\[s:a_f_ZAH, s:a_f_BEH],
+ 	\[s:a_f_AIN, s:a_f_BEH],
+ 	\[s:a_f_GHAIN, s:a_f_BEH],
+ 	\[s:a_f_FEH, s:a_f_BEH],
+ 	\[s:a_f_QAF, s:a_f_BEH],
+ 	\[s:a_f_KAF, s:a_f_BEH],
+ 	\[s:a_f_LAM, s:a_f_BEH],
+ 	\[s:a_f_MEEM, s:a_f_BEH],
+ 	\[s:a_f_NOON, s:a_f_BEH],
+ 	\[s:a_f_HEH, s:a_f_BEH],
+ 	\[s:a_f_YEH, s:a_f_BEH],
+ 	\ ]
+     call setline(1, ' ' . s:a_BEH . pair[0])
+     call assert_equal([' ' . pair[1] . pair[0]], ScreenLines(1, 3))
+   endfor
+ 
+   set arabicshape&
+   bwipe!
+ endfunc
+ 
+ func Test_shape_combination_final()
+   new
+   set arabicshape
+ 
+   " Shaping arabic {testchar} arabic   Tests chg_c_laa2f().
+   " pair[0] = testchar,  pair[1] = current-result
+   for pair in [[s:a_ALEF_MADDA, s:a_f_LAM_ALEF_MADDA_ABOVE],
+ 	\ [s:a_ALEF_HAMZA_ABOVE, s:a_f_LAM_ALEF_HAMZA_ABOVE],
+ 	\ [s:a_ALEF_HAMZA_BELOW, s:a_f_LAM_ALEF_HAMZA_BELOW],
+ 	\ [s:a_ALEF, s:a_f_LAM_ALEF],
+ 	\ ]
+     " The test char is a composing char, put on s:a_LAM.
+     call setline(1, ' ' . s:a_LAM . pair[0] . s:a_BEH)
+     call assert_equal([' ' . pair[1] . s:a_i_BEH], ScreenLines(1, 3))
+   endfor
+ 
+   set arabicshape&
+   bwipe!
+ endfunc
+ 
+ func Test_shape_combination_isolated()
+   new
+   set arabicshape
+ 
+   " Shaping arabic {testchar} arabic   Tests chg_c_laa2i().
+   " pair[0] = testchar,  pair[1] = current-result
+   for pair in [[s:a_ALEF_MADDA, s:a_s_LAM_ALEF_MADDA_ABOVE],
+ 	\ [s:a_ALEF_HAMZA_ABOVE, s:a_s_LAM_ALEF_HAMZA_ABOVE],
+ 	\ [s:a_ALEF_HAMZA_BELOW, s:a_s_LAM_ALEF_HAMZA_BELOW],
+ 	\ [s:a_ALEF, s:a_s_LAM_ALEF],
+ 	\ ]
+     " The test char is a composing char, put on s:a_LAM.
+     call setline(1, ' ' . s:a_LAM . pair[0] . ' ')
+     call assert_equal([' ' . pair[1] . ' '], ScreenLines(1, 3))
+   endfor
+ 
+   set arabicshape&
+   bwipe!
+ endfunc
*** ../vim-8.0.0496/src/version.c	2017-03-21 11:48:33.634472613 +0100
--- src/version.c	2017-03-21 13:21:57.541780872 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     497,
  /**/

-- 
If Apple would build a car...
... it would be powered by the sun, be reliable, five times
as fast and twice as easy to drive; but would only run on
five percent of the roads.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0498
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0498
Problem:    Two autocmd tests are skipped on MS-Windows.
Solution:   Make the test pass on MS-Windows. Write the messages in a file
            instead of getting the output of system().
Files:      src/testdir/test_autocmd.vim


*** ../vim-8.0.0497/src/testdir/test_autocmd.vim	2017-03-19 18:34:42.585604297 +0100
--- src/testdir/test_autocmd.vim	2017-03-21 15:47:48.670132892 +0100
***************
*** 340,346 ****
    call mkdir('Xdir')
    split Xdir
    call assert_equal('+++', g:val)
!   bwipe!
  
    call delete('Xdir', 'd')
    au! BufEnter
--- 340,349 ----
    call mkdir('Xdir')
    split Xdir
    call assert_equal('+++', g:val)
! 
!   " On MS-Windows we can't edit the directory, make sure we wipe the right
!   " buffer.
!   bwipe! Xdir
  
    call delete('Xdir', 'd')
    au! BufEnter
***************
*** 349,388 ****
  " Closing a window might cause an endless loop
  " E814 for older Vims
  function Test_autocmd_bufwipe_in_SessLoadPost()
-   if has('win32')
-     throw 'Skipped: test hangs on MS-Windows'
-   endif
    tabnew
    set noswapfile
-   let g:bufnr=bufnr('%')
    mksession!
  
!   let content=['set nocp noswapfile',
          \ 'let v:swapchoice="e"',
          \ 'augroup test_autocmd_sessionload',
          \ 'autocmd!',
          \ 'autocmd SessionLoadPost * 4bw!',
!         \ 'augroup END'
          \ ]
    call writefile(content, 'Xvimrc')
!   let a=system(v:progpath. ' -u Xvimrc --noplugins -S Session.vim')
!   call assert_match('E814', a)
  
-   unlet! g:bufnr
    set swapfile
!   for file in ['Session.vim', 'Xvimrc']
      call delete(file)
    endfor
  endfunc
  
  " SEGV occurs in older versions.
  function Test_autocmd_bufwipe_in_SessLoadPost2()
-   if has('win32')
-     throw 'Skipped: test hangs on MS-Windows'
-   endif
    tabnew
    set noswapfile
-   let g:bufnr=bufnr('%')
    mksession!
  
    let content = ['set nocp noswapfile',
--- 352,388 ----
  " Closing a window might cause an endless loop
  " E814 for older Vims
  function Test_autocmd_bufwipe_in_SessLoadPost()
    tabnew
    set noswapfile
    mksession!
  
!   let content = ['set nocp noswapfile',
          \ 'let v:swapchoice="e"',
          \ 'augroup test_autocmd_sessionload',
          \ 'autocmd!',
          \ 'autocmd SessionLoadPost * 4bw!',
!         \ 'augroup END',
! 	\ '',
! 	\ 'func WriteErrors()',
! 	\ '  call writefile([execute("messages")], "Xerrors")',
! 	\ 'endfunc',
! 	\ 'au VimLeave * call WriteErrors()',
          \ ]
    call writefile(content, 'Xvimrc')
!   call system(v:progpath. ' -u Xvimrc --not-a-term --noplugins -S Session.vim -c cq')
!   let errors = join(readfile('Xerrors'))
!   call assert_match('E814', errors)
  
    set swapfile
!   for file in ['Session.vim', 'Xvimrc', 'Xerrors']
      call delete(file)
    endfor
  endfunc
  
  " SEGV occurs in older versions.
  function Test_autocmd_bufwipe_in_SessLoadPost2()
    tabnew
    set noswapfile
    mksession!
  
    let content = ['set nocp noswapfile',
***************
*** 397,416 ****
        \ '      exec ''bwipeout '' . b',
        \ '    endif',
        \ '  endfor',
!       \ 'call append("1", "SessionLoadPost DONE")',
        \ 'endfunction',
!       \ 'au SessionLoadPost * call DeleteInactiveBufs()']
    call writefile(content, 'Xvimrc')
!   let a=system(v:progpath. ' -u Xvimrc --noplugins -S Session.vim')
!   " this probably only matches on unix
!   if has("unix")
!     call assert_notmatch('Caught deadly signal SEGV', a)
!   endif
!   call assert_match('SessionLoadPost DONE', a)
  
-   unlet! g:bufnr
    set swapfile
!   for file in ['Session.vim', 'Xvimrc']
      call delete(file)
    endfor
  endfunc
--- 397,420 ----
        \ '      exec ''bwipeout '' . b',
        \ '    endif',
        \ '  endfor',
!       \ '  echomsg "SessionLoadPost DONE"',
        \ 'endfunction',
!       \ 'au SessionLoadPost * call DeleteInactiveBufs()',
!       \ '',
!       \ 'func WriteErrors()',
!       \ '  call writefile([execute("messages")], "Xerrors")',
!       \ 'endfunc',
!       \ 'au VimLeave * call WriteErrors()',
!       \ ]
    call writefile(content, 'Xvimrc')
!   call system(v:progpath. ' -u Xvimrc --not-a-term --noplugins -S Session.vim -c cq')
!   let errors = join(readfile('Xerrors'))
!   " This probably only ever matches on unix.
!   call assert_notmatch('Caught deadly signal SEGV', errors)
!   call assert_match('SessionLoadPost DONE', errors)
  
    set swapfile
!   for file in ['Session.vim', 'Xvimrc', 'Xerrors']
      call delete(file)
    endfor
  endfunc
*** ../vim-8.0.0497/src/version.c	2017-03-21 13:22:40.681468530 +0100
--- src/version.c	2017-03-21 15:49:08.677553417 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     498,
  /**/

-- 
If Microsoft would build a car...
... You'd have to press the "Start" button to turn the engine off.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0499
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0499
Problem:    taglist() does not prioritize tags for a buffer.
Solution:   Add an optional buffer argument. (Duncan McDougall, closes #1194) 
Files:      runtime/doc/eval.txt, src/evalfunc.c, src/proto/tag.pro,
            src/Makefile, src/tag.c, src/testdir/test_alot.vim,
            src/testdir/test_taglist.vim


*** ../vim-8.0.0498/runtime/doc/eval.txt	2017-03-19 21:20:45.893034321 +0100
--- runtime/doc/eval.txt	2017-03-21 16:57:32.247841355 +0100
***************
*** 2360,2366 ****
  tabpagebuflist([{arg}])		List	list of buffer numbers in tab page
  tabpagenr([{arg}])		Number	number of current or last tab page
  tabpagewinnr({tabarg}[, {arg}]) Number	number of current window in tab page
! taglist({expr})			List	list of tags matching {expr}
  tagfiles()			List	tags files used
  tan({expr})			Float	tangent of {expr}
  tanh({expr})			Float	hyperbolic tangent of {expr}
--- 2364,2370 ----
  tabpagebuflist([{arg}])		List	list of buffer numbers in tab page
  tabpagenr([{arg}])		Number	number of current or last tab page
  tabpagewinnr({tabarg}[, {arg}]) Number	number of current window in tab page
! taglist({expr}[, {filename}])	List	list of tags matching {expr}
  tagfiles()			List	tags files used
  tan({expr})			Float	tangent of {expr}
  tanh({expr})			Float	hyperbolic tangent of {expr}
***************
*** 7722,7729 ****
  		for the current buffer.  This is the 'tags' option expanded.
  
  
! taglist({expr})							*taglist()*
  		Returns a list of tags matching the regular expression {expr}.
  		Each list item is a dictionary with at least the following
  		entries:
  			name		Name of the tag.
--- 7742,7754 ----
  		for the current buffer.  This is the 'tags' option expanded.
  
  
! taglist({expr}[, {filename}])				*taglist()*
  		Returns a list of tags matching the regular expression {expr}.
+ 
+ 		If {filename} is passed it is used to prioritize the results
+ 		in the same way that |:tselect| does. See |tag-priority|.
+ 		{filename} should be the full path of the file.
+ 
  		Each list item is a dictionary with at least the following
  		entries:
  			name		Name of the tag.
*** ../vim-8.0.0498/src/evalfunc.c	2017-03-19 21:47:46.897119250 +0100
--- src/evalfunc.c	2017-03-21 16:56:27.592313015 +0100
***************
*** 824,830 ****
      {"tabpagenr",	0, 1, f_tabpagenr},
      {"tabpagewinnr",	1, 2, f_tabpagewinnr},
      {"tagfiles",	0, 0, f_tagfiles},
!     {"taglist",		1, 1, f_taglist},
  #ifdef FEAT_FLOAT
      {"tan",		1, 1, f_tan},
      {"tanh",		1, 1, f_tanh},
--- 824,830 ----
      {"tabpagenr",	0, 1, f_tabpagenr},
      {"tabpagewinnr",	1, 2, f_tabpagewinnr},
      {"tagfiles",	0, 0, f_tagfiles},
!     {"taglist",		1, 2, f_taglist},
  #ifdef FEAT_FLOAT
      {"tan",		1, 1, f_tan},
      {"tanh",		1, 1, f_tanh},
***************
*** 3589,3595 ****
      fold_count = foldedCount(curwin, lnum, &foldinfo);
      if (fold_count > 0)
      {
! 	text = get_foldtext(curwin, lnum, lnum + fold_count - 1, &foldinfo, buf);
  	if (text == buf)
  	    text = vim_strsave(text);
  	rettv->vval.v_string = text;
--- 3589,3596 ----
      fold_count = foldedCount(curwin, lnum, &foldinfo);
      if (fold_count > 0)
      {
! 	text = get_foldtext(curwin, lnum, lnum + fold_count - 1,
! 							       &foldinfo, buf);
  	if (text == buf)
  	    text = vim_strsave(text);
  	rettv->vval.v_string = text;
***************
*** 12267,12272 ****
--- 12268,12274 ----
      static void
  f_taglist(typval_T *argvars, typval_T *rettv)
  {
+     char_u  *fname = NULL;
      char_u  *tag_pattern;
  
      tag_pattern = get_tv_string(&argvars[0]);
***************
*** 12275,12282 ****
      if (*tag_pattern == NUL)
  	return;
  
      if (rettv_list_alloc(rettv) == OK)
! 	(void)get_tags(rettv->vval.v_list, tag_pattern);
  }
  
  /*
--- 12277,12286 ----
      if (*tag_pattern == NUL)
  	return;
  
+     if (argvars[1].v_type != VAR_UNKNOWN)
+ 	fname = get_tv_string(&argvars[1]);
      if (rettv_list_alloc(rettv) == OK)
! 	(void)get_tags(rettv->vval.v_list, tag_pattern, fname);
  }
  
  /*
*** ../vim-8.0.0498/src/proto/tag.pro	2016-09-12 13:04:20.000000000 +0200
--- src/proto/tag.pro	2017-03-21 16:59:54.218805832 +0100
***************
*** 8,12 ****
  void tagname_free(tagname_T *tnp);
  void simplify_filename(char_u *filename);
  int expand_tags(int tagnames, char_u *pat, int *num_file, char_u ***file);
! int get_tags(list_T *list, char_u *pat);
  /* vim: set ft=c : */
--- 8,12 ----
  void tagname_free(tagname_T *tnp);
  void simplify_filename(char_u *filename);
  int expand_tags(int tagnames, char_u *pat, int *num_file, char_u ***file);
! int get_tags(list_T *list, char_u *pat, char_u *buf_fname);
  /* vim: set ft=c : */
*** ../vim-8.0.0498/src/Makefile	2017-03-19 21:36:52.825933116 +0100
--- src/Makefile	2017-03-21 17:02:01.857875019 +0100
***************
*** 2213,2218 ****
--- 2212,2218 ----
  	test_tabpage \
  	test_tagcase \
  	test_tagjump \
+ 	test_taglist \
  	test_tcl \
  	test_textobjects \
  	test_timers \
*** ../vim-8.0.0498/src/tag.c	2017-03-16 17:23:26.835815782 +0100
--- src/tag.c	2017-03-21 17:00:47.610416452 +0100
***************
*** 3876,3886 ****
  }
  
  /*
!  * Add the tags matching the specified pattern to the list "list"
!  * as a dictionary
   */
      int
! get_tags(list_T *list, char_u *pat)
  {
      int		num_matches, i, ret;
      char_u	**matches, *p;
--- 3876,3886 ----
  }
  
  /*
!  * Add the tags matching the specified pattern "pat" to the list "list"
!  * as a dictionary. Use "buf_fname" for priority, unless NULL.
   */
      int
! get_tags(list_T *list, char_u *pat, char_u *buf_fname)
  {
      int		num_matches, i, ret;
      char_u	**matches, *p;
***************
*** 3890,3896 ****
      long	is_static;
  
      ret = find_tags(pat, &num_matches, &matches,
! 				    TAG_REGEXP | TAG_NOIC, (int)MAXCOL, NULL);
      if (ret == OK && num_matches > 0)
      {
  	for (i = 0; i < num_matches; ++i)
--- 3890,3896 ----
      long	is_static;
  
      ret = find_tags(pat, &num_matches, &matches,
! 				TAG_REGEXP | TAG_NOIC, (int)MAXCOL, buf_fname);
      if (ret == OK && num_matches > 0)
      {
  	for (i = 0; i < num_matches; ++i)
*** ../vim-8.0.0498/src/testdir/test_alot.vim	2017-03-19 21:36:52.821933145 +0100
--- src/testdir/test_alot.vim	2017-03-21 17:01:20.210178718 +0100
***************
*** 47,52 ****
--- 47,53 ----
  source test_tabpage.vim
  source test_tagcase.vim
  source test_tagjump.vim
+ source test_taglist.vim
  source test_timers.vim
  source test_true_false.vim
  source test_unlet.vim
*** ../vim-8.0.0498/src/testdir/test_taglist.vim	2017-03-21 17:07:32.199466722 +0100
--- src/testdir/test_taglist.vim	2017-03-21 17:03:54.725052065 +0100
***************
*** 0 ****
--- 1,21 ----
+ " test 'taglist' function
+ 
+ func Test_taglist()
+   call writefile([
+ 	\ "FFoo\tXfoo\t1",
+ 	\ "FBar\tXfoo\t2",
+ 	\ "BFoo\tXbar\t1",
+ 	\ "BBar\tXbar\t2"
+ 	\ ], 'Xtags')
+   set tags=Xtags
+   split Xtext
+ 
+   call assert_equal(['FFoo', 'BFoo'], map(taglist("Foo"), {i, v -> v.name}))
+   call assert_equal(['FFoo', 'BFoo'], map(taglist("Foo", "Xtext"), {i, v -> v.name}))
+   call assert_equal(['FFoo', 'BFoo'], map(taglist("Foo", "Xfoo"), {i, v -> v.name}))
+   call assert_equal(['BFoo', 'FFoo'], map(taglist("Foo", "Xbar"), {i, v -> v.name}))
+ 
+   call delete('Xtags')
+   bwipe
+ endfunc
+ 
*** ../vim-8.0.0498/src/version.c	2017-03-21 15:50:03.713154799 +0100
--- src/version.c	2017-03-21 16:47:49.012075577 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     499,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
178. You look for an icon to double-click to open your bedroom window.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0500
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0500
Problem:    Quotestar test is still a bit flaky.
Solution:   Add a slower check for v:version.
Files:      src/testdir/test_quotestar.vim


*** ../vim-8.0.0499/src/testdir/test_quotestar.vim	2017-03-20 21:47:12.064090779 +0100
--- src/testdir/test_quotestar.vim	2017-03-21 18:01:58.587617523 +0100
***************
*** 53,58 ****
--- 53,62 ----
    call WaitFor('serverlist() =~ "' . name . '"')
    call assert_match(name, serverlist())
  
+   " Wait for the server to be up and answering requests.  One second is not
+   " always sufficient.
+   call WaitFor('remote_expr("' . name . '", "v:version", "", 2) != ""')
+ 
    " Clear the *-register of this vim instance.
    let @* = ''
  
***************
*** 78,85 ****
      else
        call remote_send(name, ":gui -f\<CR>")
      endif
!     " Wait for the server to be up and answering requests.
!     call WaitFor('remote_expr("' . name . '", "v:version", "", 1) != ""')
  
      call remote_send(name, ":let @* = 'maybe'\<CR>")
      call WaitFor('remote_expr("' . name . '", "@*", "", 1) == "maybe"')
--- 82,89 ----
      else
        call remote_send(name, ":gui -f\<CR>")
      endif
!     " Wait for the server in the GUI to be up and answering requests.
!     call WaitFor('remote_expr("' . name . '", "has(\"gui_running\")", "", 1) =~ "1"')
  
      call remote_send(name, ":let @* = 'maybe'\<CR>")
      call WaitFor('remote_expr("' . name . '", "@*", "", 1) == "maybe"')
*** ../vim-8.0.0499/src/version.c	2017-03-21 17:08:46.678923883 +0100
--- src/version.c	2017-03-21 18:00:01.576472526 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     500,
  /**/

-- 
Rule #1: Don't give somebody a tool that he's going to hurt himself with.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0501
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0501
Problem:    On MS-Windows ":!start" does not work as expected.
Solution:   When creating a process fails try passing the argument to
            ShellExecute().  (Katsuya Hino, closes #1570)
Files:      runtime/doc/os_win32.txt, src/os_win32.c


*** ../vim-8.0.0500/runtime/doc/os_win32.txt	2016-10-12 14:19:55.734357838 +0200
--- runtime/doc/os_win32.txt	2017-03-21 19:27:35.298117488 +0100
***************
*** 212,221 ****
     be able to set the blink rate for all console windows at the same time.
  
  							*:!start*
! Q. How can I run an external command or program asynchronously?
! A. When using :! to run an external command, you can run it with "start": >
! 	:!start winfile.exe<CR>
! <  Using "start" stops Vim switching to another screen, opening a new console,
     or waiting for the program to complete; it indicates that you are running a
     program that does not affect the files you are editing.  Programs begun
     with :!start do not get passed Vim's open file handles, which means they do
--- 212,230 ----
     be able to set the blink rate for all console windows at the same time.
  
  							*:!start*
! Q. How can I asynchronously run an external command or program, or open a
!    document or URL with its default program?
! A. When using :! to run an external command, you can run it with "start". For
!    example, to run notepad: >
! 	:!start notepad
! <   To open "image.jpg" with the default image viewer: >
!         :!start image.jpg
! <   To open the folder of the current file in Windows Explorer: >
!         :!start %:h
! <   To open the Vim home page with the default browser: >
!         :!start http://www.vim.org/
! <
!    Using "start" stops Vim switching to another screen, opening a new console,
     or waiting for the program to complete; it indicates that you are running a
     program that does not affect the files you are editing.  Programs begun
     with :!start do not get passed Vim's open file handles, which means they do
*** ../vim-8.0.0500/src/os_win32.c	2017-03-12 20:09:59.484468262 +0100
--- src/os_win32.c	2017-03-21 19:23:31.979892320 +0100
***************
*** 4008,4013 ****
--- 4008,4035 ----
  }
  
  
+     static HINSTANCE
+ vim_shell_execute(
+     char *cmd,
+     INT	 n_show_cmd)
+ {
+ #ifdef FEAT_MBYTE
+     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
+     {
+ 	WCHAR *wcmd = enc_to_utf16((char_u *)cmd, NULL);
+ 	if (wcmd != NULL)
+ 	{
+ 	    HINSTANCE ret;
+ 	    ret = ShellExecuteW(NULL, NULL, wcmd, NULL, NULL, n_show_cmd);
+ 	    vim_free(wcmd);
+ 	    return ret;
+ 	}
+     }
+ #endif
+     return ShellExecute(NULL, NULL, cmd, NULL, NULL, n_show_cmd);
+ }
+ 
+ 
  #if defined(FEAT_GUI_W32) || defined(PROTO)
  
  /*
***************
*** 4711,4716 ****
--- 4733,4739 ----
  	    STARTUPINFO		si;
  	    PROCESS_INFORMATION	pi;
  	    DWORD		flags = CREATE_NEW_CONSOLE;
+ 	    INT			n_show_cmd = SW_SHOWNORMAL;
  	    char_u		*p;
  
  	    ZeroMemory(&si, sizeof(si));
***************
*** 4729,4734 ****
--- 4752,4758 ----
  		cmdbase = skipwhite(cmdbase + 4);
  		si.dwFlags = STARTF_USESHOWWINDOW;
  		si.wShowWindow = SW_SHOWMINNOACTIVE;
+ 		n_show_cmd = SW_SHOWMINNOACTIVE;
  	    }
  	    else if ((STRNICMP(cmdbase, "/b", 2) == 0)
  		    && VIM_ISWHITE(cmdbase[2]))
***************
*** 4800,4805 ****
--- 4824,4832 ----
  	     */
  	    if (vim_create_process((char *)newcmd, FALSE, flags, &si, &pi))
  		x = 0;
+ 	    else if (vim_shell_execute((char *)newcmd, n_show_cmd)
+ 							       > (HINSTANCE)32)
+ 		x = 0;
  	    else
  	    {
  		x = -1;
*** ../vim-8.0.0500/src/version.c	2017-03-21 18:02:35.475348003 +0100
--- src/version.c	2017-03-21 19:23:14.480019973 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     501,
  /**/

-- 
Wizards had always known that the act of observation changed the thing that
was observed, and sometimes forgot that it also changed the observer too.
			Terry Pratchett  -  Interesting times

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0502
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0502
Problem:    Coverity complains about possible NULL pointer.
Solution:   Add an assert(), let's see if this works on all systems.
Files:      src/window.c


*** ../vim-8.0.0501/src/window.c	2017-03-19 20:22:31.210585166 +0100
--- src/window.c	2017-03-21 21:51:24.317409884 +0100
***************
*** 3806,3811 ****
--- 3806,3812 ----
  	for (ptp = first_tabpage; ptp != NULL && ptp->tp_next != tab;
  							    ptp = ptp->tp_next)
  	    ;
+ 	assert(ptp != NULL);
  	ptp->tp_next = tab->tp_next;
      }
  
*** ../vim-8.0.0501/src/version.c	2017-03-21 19:29:22.053338817 +0100
--- src/version.c	2017-03-21 21:54:24.176016365 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     502,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
184. You no longer ask prospective dates what their sign is, instead
     your line is "Hi, what's your URL?"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0503
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0503
Problem:    Endless loop in updating folds with 32 bit ints.
Solution:   Subtract from LHS instead of add to the RHS. (Matthew Malcomson)
Files:      src/fold.c


*** ../vim-8.0.0502/src/fold.c	2017-03-16 22:06:51.824726916 +0100
--- src/fold.c	2017-03-23 21:19:13.084212797 +0100
***************
*** 2755,2761 ****
  	/* End of fold found, update the length when it got shorter. */
  	if (fp->fd_len != flp->lnum - fp->fd_top)
  	{
! 	    if (fp->fd_top + fp->fd_len > bot + 1)
  	    {
  		/* fold continued below bot */
  		if (getlevel == foldlevelMarker
--- 2755,2761 ----
  	/* End of fold found, update the length when it got shorter. */
  	if (fp->fd_len != flp->lnum - fp->fd_top)
  	{
! 	    if (fp->fd_top + fp->fd_len - 1 > bot)
  	    {
  		/* fold continued below bot */
  		if (getlevel == foldlevelMarker
*** ../vim-8.0.0502/src/version.c	2017-03-21 21:57:51.338404174 +0100
--- src/version.c	2017-03-23 21:20:47.115523702 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     503,
  /**/

-- 
Press any key to continue, press any other key to quit.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0504
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0504
Problem:    Looking up an Ex command is a bit slow.
Solution:   Instead of just using the first letter, also use the second letter
            to skip ahead in the list of commands. Generate the table with a
            Perl script. (Dominique Pelle, closes #1589)
Files:      src/Makefile, src/create_cmdidxs.pl, src/ex_docmd.c, Filelist


*** ../vim-8.0.0503/src/Makefile	2017-03-21 17:08:46.678923883 +0100
--- src/Makefile	2017-03-25 14:11:14.611853538 +0100
***************
*** 1884,1889 ****
--- 1883,1898 ----
  	-rm -rf autom4te.cache
  	-rm -f auto/config.status auto/config.cache
  
+ # Run Perl to generate the Ex command lookup table.  This only needs to be run
+ # when a command name has been added or changed.
+ # NOTE: Only works when perl and vim executables are available
+ cmdidxs: ex_cmds.h
+ 	if test X`perl -e "print 123"` = "X123"; then \
+ 	   vim ex_docmd.c -c '/Beginning.*create_cmdidxs/,/End.*create_cmdidxs/! perl create_cmdidxs.pl' -c wq; \
+ 	else \
+ 	   echo Cannot run Perl; \
+ 	fi
+ 
  # Re-execute this Makefile to include the new auto/config.mk produced by
  # configure Only used when typing "make" with a fresh auto/config.mk.
  myself:
*** ../vim-8.0.0503/src/create_cmdidxs.pl	2017-03-25 14:49:46.422380577 +0100
--- src/create_cmdidxs.pl	2017-03-25 14:44:17.276864694 +0100
***************
*** 0 ****
--- 1,74 ----
+ #!/usr/bin/perl -w
+ #
+ # This script generates the tables cmdidxs1[] and cmdidxs2[][] which,
+ # given a Ex command, determine the first value to probe to find
+ # a matching command in cmdnames[] based on the first character
+ # and the first 2 characters of the command.
+ # This is used to speed up lookup in cmdnames[].
+ #
+ # Script should be run every time new Ex commands are added in Vim,
+ # from the src/vim directory, since it reads commands from "ex_cmds.h".
+ 
+ # Find the list of Vim commands from cmdnames[] table in ex_cmds.h
+ my @cmds;
+ my @skipped;
+ open(IN, "< ex_cmds.h") or die "can't open ex_cmds.h: $!\n";
+ while (<IN>) {
+   if (/^EX\(CMD_\S*,\s*"([a-z][^"]*)"/) {
+     push (@cmds, $1);
+   } elsif (/^EX\(CMD_/) {
+     push (@skipped, $1);
+   }
+ }
+ 
+ my %cmdidxs1;
+ my %cmdidxs2;
+ 
+ for (my $i = $#cmds; $i >= 0; --$i) {
+   my $cmd = $cmds[$i];
+   my $c1 = substr($cmd, 0, 1); # First character of command.
+ 
+   $cmdidxs1{$c1} = $i;
+ 
+   if (length($cmd) > 1) {
+     my $c2 = substr($cmd, 1, 1); # Second character of command.
+     $cmdidxs2{$c1}{$c2} = $i if (('a' lt $c2) and ($c2 lt 'z'));
+   }
+ }
+ 
+ print "/* Beginning of automatically generated code by create_cmdidxs.pl\n",
+       " *\n",
+       " * Table giving the index of the first command in cmdnames[] to lookup\n",
+       " * based on the first letter of a command.\n",
+       " */\n",
+       "static const unsigned short cmdidxs1[26] =\n{\n",
+       join(",\n", map("  /* $_ */ $cmdidxs1{$_}", ('a' .. 'z'))),
+       "\n};\n",
+       "\n",
+       "/*\n",
+       " * Table giving the index of the first command in cmdnames[] to lookup\n",
+       " * based on the first 2 letters of a command.\n",
+       " * Values in cmdidxs2[c1][c2] are relative to cmdidxs1[c1] so that they\n",
+       " * fit in a byte.\n",
+       " */\n",
+       "static const unsigned char cmdidxs2[26][26] =\n",
+       "{ /*         a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z */\n";
+ for my $c1 ('a' .. 'z') {
+   print "  /* $c1 */ {";
+   for my $c2 ('a' .. 'z') {
+     if (exists $cmdidxs2{$c1}{$c2}) {
+       printf "%3d,", $cmdidxs2{$c1}{$c2} - $cmdidxs1{$c1};
+     } else {
+       printf "  0,";
+     }
+   }
+   print " }";
+   print "," unless ($c1 eq 'z');
+   print "\n";
+ }
+ print "};\n",
+       "\n",
+       "static int command_count = ", $#cmds + $#skipped + 2 , ";\n",
+       "\n",
+       "/* End of automatically generated code by create_cmdidxs.pl */\n";
+ 
*** ../vim-8.0.0503/src/ex_docmd.c	2017-03-16 17:23:26.819815897 +0100
--- src/ex_docmd.c	2017-03-25 14:44:23.248819614 +0100
***************
*** 495,534 ****
  #define DO_DECLARE_EXCMD
  #include "ex_cmds.h"
  
! /*
!  * Table used to quickly search for a command, based on its first character.
   */
! static cmdidx_T cmdidxs[27] =
  {
! 	CMD_append,
! 	CMD_buffer,
! 	CMD_change,
! 	CMD_delete,
! 	CMD_edit,
! 	CMD_file,
! 	CMD_global,
! 	CMD_help,
! 	CMD_insert,
! 	CMD_join,
! 	CMD_k,
! 	CMD_list,
! 	CMD_move,
! 	CMD_next,
! 	CMD_open,
! 	CMD_print,
! 	CMD_quit,
! 	CMD_read,
! 	CMD_substitute,
! 	CMD_t,
! 	CMD_undo,
! 	CMD_vglobal,
! 	CMD_write,
! 	CMD_xit,
! 	CMD_yank,
! 	CMD_z,
! 	CMD_bang
  };
  
  static char_u dollar_command[2] = {'$', 0};
  
  
--- 495,575 ----
  #define DO_DECLARE_EXCMD
  #include "ex_cmds.h"
  
! /* Beginning of automatically generated code by create_cmdidxs.pl
!  *
!  * Table giving the index of the first command in cmdnames[] to lookup
!  * based on the first letter of a command.
   */
! static const unsigned short cmdidxs1[26] =
  {
!   /* a */ 0,
!   /* b */ 19,
!   /* c */ 42,
!   /* d */ 103,
!   /* e */ 125,
!   /* f */ 145,
!   /* g */ 161,
!   /* h */ 167,
!   /* i */ 176,
!   /* j */ 194,
!   /* k */ 196,
!   /* l */ 201,
!   /* m */ 259,
!   /* n */ 277,
!   /* o */ 297,
!   /* p */ 309,
!   /* q */ 348,
!   /* r */ 351,
!   /* s */ 370,
!   /* t */ 437,
!   /* u */ 472,
!   /* v */ 483,
!   /* w */ 501,
!   /* x */ 516,
!   /* y */ 525,
!   /* z */ 526
  };
  
+ /*
+  * Table giving the index of the first command in cmdnames[] to lookup
+  * based on the first 2 letters of a command.
+  * Values in cmdidxs2[c1][c2] are relative to cmdidxs1[c1] so that they
+  * fit in a byte.
+  */
+ static const unsigned char cmdidxs2[26][26] =
+ { /*         a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z */
+   /* a */ {  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  4,  5,  6,  0,  0,  0,  7, 15,  0, 16,  0,  0,  0,  0,  0, },
+   /* b */ {  0,  0,  0,  4,  5,  7,  0,  0,  0,  0,  0,  8,  9, 10, 11, 12,  0, 13,  0,  0,  0,  0, 22,  0,  0,  0, },
+   /* c */ {  0, 10, 12, 14, 16, 18, 21,  0,  0,  0,  0, 29, 33, 36, 42, 51, 53, 54, 55,  0, 57,  0, 60,  0,  0,  0, },
+   /* d */ {  0,  0,  0,  0,  0,  0,  0,  0,  6, 15,  0, 16,  0,  0, 17,  0,  0, 19, 20,  0,  0,  0,  0,  0,  0,  0, },
+   /* e */ {  0,  0,  2,  0,  0,  0,  0,  0,  0,  0,  0,  7,  9, 10,  0,  0,  0,  0,  0,  0,  0,  0,  0, 16,  0,  0, },
+   /* f */ {  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  9,  0,  0,  0,  0,  0, 15,  0,  0,  0,  0,  0, },
+   /* g */ {  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  2,  0,  0,  4,  5,  0,  0,  0,  0, },
+   /* h */ {  0,  0,  0,  0,  0,  0,  0,  0,  6,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, },
+   /* i */ {  0,  0,  0,  0,  0,  3,  0,  0,  0,  4,  0,  5,  6,  0,  0,  0,  0,  0, 13,  0, 15,  0,  0,  0,  0,  0, },
+   /* j */ {  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0, },
+   /* k */ {  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, },
+   /* l */ {  0,  9, 11, 15, 16, 20, 23, 28,  0,  0,  0, 30, 33, 36, 40, 46,  0, 48, 57, 49, 50, 54, 56,  0,  0,  0, },
+   /* m */ {  0,  0,  0,  0,  7,  0,  0,  0,  0,  0, 10,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, },
+   /* n */ {  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  8, 10,  0,  0,  0,  0,  0, 17,  0,  0,  0,  0,  0, },
+   /* o */ {  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  5,  0,  0,  0,  0,  0,  0,  9,  0, 11,  0,  0,  0, },
+   /* p */ {  0,  0,  3,  0,  4,  0,  0,  0,  0,  0,  0,  0,  0,  0,  7,  9,  0,  0, 16, 17, 26,  0, 27,  0, 28,  0, },
+   /* q */ {  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, },
+   /* r */ {  0,  0,  0,  0,  0,  0,  0,  0, 11,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 13, 18,  0,  0,  0,  0, },
+   /* s */ {  0,  6, 15,  0, 18, 22,  0, 24, 25,  0,  0, 28, 30, 34, 38, 40,  0, 48,  0, 49,  0, 61, 62,  0, 63,  0, },
+   /* t */ {  0,  0, 19,  0, 22, 23,  0, 24,  0, 25,  0, 26, 27, 28, 29, 30,  0, 31, 33,  0, 34,  0,  0,  0,  0,  0, },
+   /* u */ {  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 10,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, },
+   /* v */ {  0,  0,  0,  0,  1,  0,  0,  0,  4,  0,  0,  0,  9, 12,  0,  0,  0,  0, 15,  0, 16,  0,  0,  0,  0,  0, },
+   /* w */ {  0,  0,  0,  0,  0,  0,  0,  3,  4,  0,  0,  0,  0,  8,  0,  9, 10,  0, 12,  0, 13, 14,  0,  0,  0,  0, },
+   /* x */ {  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  5,  0,  0,  0,  0,  0,  0,  7,  0,  0,  0,  0,  0, },
+   /* y */ {  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, },
+   /* z */ {  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, }
+ };
+ 
+ static int command_count = 539;
+ 
+ /* End of automatically generated code by create_cmdidxs.pl */
+ 
  static char_u dollar_command[2] = {'$', 0};
  
  
***************
*** 614,620 ****
  }
  #endif
  
- 
  /*
   * do_exmode(): Repeatedly get commands for the "Ex" mode, until the ":vi"
   * command is given.
--- 655,660 ----
***************
*** 3208,3217 ****
  	    }
  	}
  
! 	if (ASCII_ISLOWER(*eap->cmd))
! 	    eap->cmdidx = cmdidxs[CharOrdLow(*eap->cmd)];
  	else
! 	    eap->cmdidx = cmdidxs[26];
  
  	for ( ; (int)eap->cmdidx < (int)CMD_SIZE;
  			       eap->cmdidx = (cmdidx_T)((int)eap->cmdidx + 1))
--- 3248,3271 ----
  	    }
  	}
  
! 	if (ASCII_ISLOWER(eap->cmd[0]))
! 	{
! 	    if (command_count != (int)CMD_SIZE)
! 	    {
! 		iemsg((char_u *)_("E943: Command table needs to be updated, run 'make cmdidxs'"));
! 		getout(1);
! 	    }
! 
! 	    /* Use a precomputed index for fast look-up in cmdnames[]
! 	     * taking into account the first 2 letters of eap->cmd. */
! 	    int c1 = eap->cmd[0];
! 	    int c2 = eap->cmd[1];
! 	    eap->cmdidx = cmdidxs1[CharOrdLow(c1)];
! 	    if (ASCII_ISLOWER(c2))
! 		eap->cmdidx += cmdidxs2[CharOrdLow(c1)][CharOrdLow(c2)];
! 	}
  	else
! 	    eap->cmdidx = CMD_bang;
  
  	for ( ; (int)eap->cmdidx < (int)CMD_SIZE;
  			       eap->cmdidx = (cmdidx_T)((int)eap->cmdidx + 1))
*** ../vim-8.0.0503/Filelist	2017-03-12 17:10:14.417925081 +0100
--- Filelist	2017-03-25 14:49:07.770672237 +0100
***************
*** 215,220 ****
--- 215,221 ----
  		src/config.mk.in \
  		src/configure \
  		src/configure.ac \
+ 		src/create_cmdidxs.pl \
  		src/gui_at_fs.c \
  		src/gui_at_sb.c \
  		src/gui_at_sb.h \
*** ../vim-8.0.0503/src/version.c	2017-03-23 21:53:31.045117492 +0100
--- src/version.c	2017-03-25 13:55:04.375213595 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     504,
  /**/

-- 
$ echo pizza > /dev/oven

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0505
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0505
Problem:    Failed window split for :stag not handled. (Coverity CID 99204)
Solution:   If the split fails skip to the end. (bstaletic, closes #1577)
Files:      src/tag.c


*** ../vim-8.0.0504/src/tag.c	2017-03-21 17:08:46.678923883 +0100
--- src/tag.c	2017-03-25 14:58:59.126199223 +0100
***************
*** 3203,3210 ****
       * open a new tab page. */
      if (postponed_split || cmdmod.tab != 0)
      {
! 	win_split(postponed_split > 0 ? postponed_split : 0,
! 						       postponed_split_flags);
  	RESET_BINDING(curwin);
      }
  #endif
--- 3203,3214 ----
       * open a new tab page. */
      if (postponed_split || cmdmod.tab != 0)
      {
! 	if (win_split(postponed_split > 0 ? postponed_split : 0,
! 						postponed_split_flags) == FAIL)
! 	{
! 	    --RedrawingDisabled;
! 	    goto erret;
! 	}
  	RESET_BINDING(curwin);
      }
  #endif
*** ../vim-8.0.0504/src/version.c	2017-03-25 14:50:37.925991956 +0100
--- src/version.c	2017-03-25 15:00:00.273735027 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     505,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
203. You're an active member of more than 20 newsgroups.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0506
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0506 (after 8.0.0504)
Problem:    Can't build with ANSI C.
Solution:   Move declarations to start of block.
Files:      src/ex_docmd.c


*** ../vim-8.0.0505/src/ex_docmd.c	2017-03-25 14:50:37.925991956 +0100
--- src/ex_docmd.c	2017-03-25 15:06:01.182996203 +0100
***************
*** 3250,3255 ****
--- 3250,3258 ----
  
  	if (ASCII_ISLOWER(eap->cmd[0]))
  	{
+ 	    int c1 = eap->cmd[0];
+ 	    int c2 = eap->cmd[1];
+ 
  	    if (command_count != (int)CMD_SIZE)
  	    {
  		iemsg((char_u *)_("E943: Command table needs to be updated, run 'make cmdidxs'"));
***************
*** 3258,3265 ****
  
  	    /* Use a precomputed index for fast look-up in cmdnames[]
  	     * taking into account the first 2 letters of eap->cmd. */
- 	    int c1 = eap->cmd[0];
- 	    int c2 = eap->cmd[1];
  	    eap->cmdidx = cmdidxs1[CharOrdLow(c1)];
  	    if (ASCII_ISLOWER(c2))
  		eap->cmdidx += cmdidxs2[CharOrdLow(c1)][CharOrdLow(c2)];
--- 3261,3266 ----
*** ../vim-8.0.0505/src/version.c	2017-03-25 15:03:41.376056956 +0100
--- src/version.c	2017-03-25 15:06:48.658636046 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     506,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
204. You're being audited because you mailed your tax return to the IRC.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0507
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0507
Problem:    Client-server tests fail when $DISPLAY is not set.
Solution:   Check for E240 before running the test.
Files:      src/testdir/test_quotestar.vim, src/testdir/test_clientserver.vim


*** ../vim-8.0.0506/src/testdir/test_quotestar.vim	2017-03-21 18:02:35.471348032 +0100
--- src/testdir/test_quotestar.vim	2017-03-23 22:21:50.636592399 +0100
***************
*** 39,44 ****
--- 39,53 ----
    if cmd == ''
      return 'GetVimCommand() failed'
    endif
+   try
+     call remote_send('xxx', '')
+   catch
+     if v:exception =~ 'E240:'
+       " No connection to the X server, give up.
+       return
+     endif
+     " ignore other errors
+   endtry
  
    let name = 'XVIMCLIPBOARD'
    let cmd .= ' --servername ' . name
*** ../vim-8.0.0506/src/testdir/test_clientserver.vim	2017-03-19 21:20:45.893034321 +0100
--- src/testdir/test_clientserver.vim	2017-03-23 22:21:35.816702652 +0100
***************
*** 11,16 ****
--- 11,27 ----
    if cmd == ''
      return
    endif
+   if has('unix')
+     try
+       call remote_send('xxx', '')
+     catch
+       if v:exception =~ 'E240:'
+ 	" No connection to the X server, give up.
+ 	return
+       endif
+       " ignore other errors
+     endtry
+   endif
  
    let name = 'XVIMTEST'
    let cmd .= ' --servername ' . name
*** ../vim-8.0.0506/src/version.c	2017-03-25 15:07:38.750256076 +0100
--- src/version.c	2017-03-25 15:18:47.021189608 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     507,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
205. You're constantly yelling at your spouse, family, roommate, whatever,
     for using the phone for stupid things...like talking.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0508
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0508
Problem:    Coveralls no longer shows per-file coverage.
Solution:   Add coverage from codecov.io. (Christian Brabandt)
Files:      .travis.yml


*** ../vim-8.0.0507/.travis.yml	2017-03-05 14:56:03.597083350 +0100
--- .travis.yml	2017-03-25 17:45:10.522594325 +0100
***************
*** 99,103 ****
--- 99,104 ----
  
  after_success:
    - if [ "$COVERAGE" = "yes" ]; then ~/.local/bin/coveralls -b $SRCDIR -x .xs -e ${SRCDIR}/xxd -e ${SRCDIR}/if_perl.c --encodings utf-8 latin-1 EUC-KR; fi
+   - if [ "$COVERAGE" = "yes" ]; then  cd $SRCDIR && bash <(curl -s https://codecov.io/bash) ; fi
  
  # vim:set sts=2 sw=2 tw=0 et:
*** ../vim-8.0.0507/src/version.c	2017-03-25 15:20:01.792623027 +0100
--- src/version.c	2017-03-25 17:46:06.058175652 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     508,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
209. Your house stinks because you haven't cleaned it in a week.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0509
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0509
Problem:    No link to codecov.io results.
Solution:   Add a badge to the readme file.
Files:      README.md


*** ../vim-8.0.0508/README.md	2016-09-12 12:46:32.000000000 +0200
--- README.md	2017-03-25 17:59:04.908340137 +0100
***************
*** 1,5 ****
--- 1,6 ----
  `README.md` for version 8.0 of Vim: Vi IMproved.
  [![Build Status](https://travis-ci.org/vim/vim.svg?branch=master)](https://travis-ci.org/vim/vim)
+ [![Coverage Status](https://https://codecov.io/gh/vim/vim/coverage.svg?branch=master)](https://codecov.io/gh/vim/vim?branch=master)
  [![Coverage Status](https://coveralls.io/repos/vim/vim/badge.svg?branch=master&service=github)](https://coveralls.io/github/vim/vim?branch=master)
  [![Appveyor Build status](https://ci.appveyor.com/api/projects/status/o2qht2kjm02sgghk?svg=true)](https://ci.appveyor.com/project/chrisbra/vim)
  [![Coverity Scan](https://scan.coverity.com/projects/241/badge.svg)](https://scan.coverity.com/projects/vim)
*** ../vim-8.0.0508/src/version.c	2017-03-25 17:46:52.605824725 +0100
--- src/version.c	2017-03-25 18:03:51.274200960 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     509,
  /**/

-- 
    "You mean there really is an answer?"
    "Yes! But you're not going to like it!"
    "Oh do please tell us!"
    "You're really not going to like it!"
    "but we MUST know - tell us"
    "Alright, the answer is...."
    "yes..."
    "... is ..."
    "yes... come on!"
    "is 42!"
		(Douglas Adams - The Hitchhiker's Guide to the Galaxy)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0510
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0510 (after 8.0.0509)
Problem:    Typo in link to codecov.io results.
Solution:   Remove duplicate https:.
Files:      README.md


*** ../vim-8.0.0509/README.md	2017-03-25 18:04:26.617936822 +0100
--- README.md	2017-03-25 18:08:41.648031195 +0100
***************
*** 1,6 ****
  `README.md` for version 8.0 of Vim: Vi IMproved.
  [![Build Status](https://travis-ci.org/vim/vim.svg?branch=master)](https://travis-ci.org/vim/vim)
! [![Coverage Status](https://https://codecov.io/gh/vim/vim/coverage.svg?branch=master)](https://codecov.io/gh/vim/vim?branch=master)
  [![Coverage Status](https://coveralls.io/repos/vim/vim/badge.svg?branch=master&service=github)](https://coveralls.io/github/vim/vim?branch=master)
  [![Appveyor Build status](https://ci.appveyor.com/api/projects/status/o2qht2kjm02sgghk?svg=true)](https://ci.appveyor.com/project/chrisbra/vim)
  [![Coverity Scan](https://scan.coverity.com/projects/241/badge.svg)](https://scan.coverity.com/projects/vim)
--- 1,6 ----
  `README.md` for version 8.0 of Vim: Vi IMproved.
  [![Build Status](https://travis-ci.org/vim/vim.svg?branch=master)](https://travis-ci.org/vim/vim)
! [![Coverage Status](https://codecov.io/gh/vim/vim/coverage.svg?branch=master)](https://codecov.io/gh/vim/vim?branch=master)
  [![Coverage Status](https://coveralls.io/repos/vim/vim/badge.svg?branch=master&service=github)](https://coveralls.io/github/vim/vim?branch=master)
  [![Appveyor Build status](https://ci.appveyor.com/api/projects/status/o2qht2kjm02sgghk?svg=true)](https://ci.appveyor.com/project/chrisbra/vim)
  [![Coverity Scan](https://scan.coverity.com/projects/241/badge.svg)](https://scan.coverity.com/projects/vim)
*** ../vim-8.0.0509/src/version.c	2017-03-25 18:04:26.617936822 +0100
--- src/version.c	2017-03-25 18:09:52.939501214 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     510,
  /**/

-- 
Your mouse has moved.  Windows must be restarted for the change
to take effect.  Reboot now?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0511
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0511
Problem:    Menuage for skipping client-server tests is unclear.
Solution:   Be more specific about what's missing (Hirohito Higashi, Kazunobu
            Kuriyama)
Files:      src/testdir/test_quotestar.vim, src/testdir/test_clientserver.vim


*** ../vim-8.0.0510/src/testdir/test_quotestar.vim	2017-03-25 15:20:01.788623057 +0100
--- src/testdir/test_quotestar.vim	2017-03-25 18:20:29.106765718 +0100
***************
*** 118,125 ****
  
    if has('macunix')
      let skipped = Do_test_quotestar_for_macunix()
!   elseif !empty("$DISPLAY")
!     let skipped = Do_test_quotestar_for_x11()
    else
      let skipped = "Test is not implemented yet for this platform."
    endif
--- 118,129 ----
  
    if has('macunix')
      let skipped = Do_test_quotestar_for_macunix()
!   elseif has('x11')
!     if empty($DISPLAY)
!       let skipped = "Test can only run when $DISPLAY is set."
!     else
!       let skipped = Do_test_quotestar_for_x11()
!     endif
    else
      let skipped = "Test is not implemented yet for this platform."
    endif
*** ../vim-8.0.0510/src/testdir/test_clientserver.vim	2017-03-25 15:20:01.788623057 +0100
--- src/testdir/test_clientserver.vim	2017-03-25 20:13:32.761848466 +0100
***************
*** 11,23 ****
    if cmd == ''
      return
    endif
!   if has('unix')
      try
        call remote_send('xxx', '')
      catch
        if v:exception =~ 'E240:'
! 	" No connection to the X server, give up.
! 	return
        endif
        " ignore other errors
      endtry
--- 11,25 ----
    if cmd == ''
      return
    endif
!   if has('x11')
!     if empty($DISPLAY)
!       throw 'Skipped: $DISPLAY is not set'
!     endif
      try
        call remote_send('xxx', '')
      catch
        if v:exception =~ 'E240:'
! 	throw 'Skipped: no connection to the X server'
        endif
        " ignore other errors
      endtry
*** ../vim-8.0.0510/src/version.c	2017-03-25 18:10:26.871248913 +0100
--- src/version.c	2017-03-25 20:11:57.782519710 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     511,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
214. Your MCI "Circle of Friends" are all Hayes-compatible.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0512
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0512
Problem:    Check for available characters takes too long.
Solution:   Only check did_start_blocking if wtime is negative. (Daisuke
            Suzuki, closes #1591)
Files:      src/os_unix.c


*** ../vim-8.0.0511/src/os_unix.c	2017-03-12 20:09:59.484468262 +0100
--- src/os_unix.c	2017-03-25 20:08:32.223982419 +0100
***************
*** 511,517 ****
  		|| interrupted
  #endif
  		|| wait_time > 0
! 		|| !did_start_blocking)
  	    continue;
  
  	/* no character available or interrupted */
--- 511,517 ----
  		|| interrupted
  #endif
  		|| wait_time > 0
! 		|| (wtime < 0 && !did_start_blocking))
  	    continue;
  
  	/* no character available or interrupted */
*** ../vim-8.0.0511/src/version.c	2017-03-25 20:14:28.053457561 +0100
--- src/version.c	2017-03-25 20:15:01.265222708 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     512,
  /**/

-- 
msdn.microsoft.com:
ERROR_SUCCESS 0 (0x0) The operation completed successfully.
I have always suspected that for Microsoft success is an error.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0513
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0513 (after 8.0.0201)
Problem:    Getting name of cleared highlight group is wrong. (Matt Wozniski)
Solution:   Only skip over cleared names for completion. (closes #1592)
            Also fix that a cleared group causes duplicate completions.
Files:      src/syntax.c, src/proto/syntax.pro, src/evalfunc.c,
            src/ex_cmds.c, src/testdir/test_syntax.vim,
            src/testdir/test_cmdline.vim


*** ../vim-8.0.0512/src/syntax.c	2017-03-18 21:37:23.865273985 +0100
--- src/syntax.c	2017-03-26 13:39:29.389387004 +0200
***************
*** 9949,9965 ****
      || defined(FEAT_SIGNS) || defined(PROTO)
  /*
   * Function given to ExpandGeneric() to obtain the list of group names.
-  * Also used for synIDattr() function.
   */
      char_u *
  get_highlight_name(expand_T *xp UNUSED, int idx)
  {
      if (idx < 0)
  	return NULL;
!     /* Items are never removed from the table, skip the ones that were cleared.
!      */
!     while (idx < highlight_ga.ga_len && HL_TABLE()[idx].sg_cleared)
! 	++idx;
  
  #ifdef FEAT_CMDL_COMPL
      if (idx == highlight_ga.ga_len && include_none != 0)
--- 9949,9975 ----
      || defined(FEAT_SIGNS) || defined(PROTO)
  /*
   * Function given to ExpandGeneric() to obtain the list of group names.
   */
      char_u *
  get_highlight_name(expand_T *xp UNUSED, int idx)
  {
+     return get_highlight_name_ext(xp, idx, TRUE);
+ }
+ 
+ /*
+  * Obtain a highlight group name.
+  * When "skip_cleared" is TRUE don't return a cleared entry.
+  */
+     char_u *
+ get_highlight_name_ext(expand_T *xp UNUSED, int idx, int skip_cleared)
+ {
      if (idx < 0)
  	return NULL;
! 
!     /* Items are never removed from the table, skip the ones that were
!      * cleared. */
!     if (skip_cleared && idx < highlight_ga.ga_len && HL_TABLE()[idx].sg_cleared)
! 	return (char_u *)"";
  
  #ifdef FEAT_CMDL_COMPL
      if (idx == highlight_ga.ga_len && include_none != 0)
*** ../vim-8.0.0512/src/proto/syntax.pro	2016-09-12 13:04:20.000000000 +0200
--- src/proto/syntax.pro	2017-03-26 13:36:05.610812928 +0200
***************
*** 52,56 ****
--- 52,57 ----
  int highlight_changed(void);
  void set_context_in_highlight_cmd(expand_T *xp, char_u *arg);
  char_u *get_highlight_name(expand_T *xp, int idx);
+ char_u *get_highlight_name_ext(expand_T *xp, int idx, int skip_cleared);
  void free_highlight_fonts(void);
  /* vim: set ft=c : */
*** ../vim-8.0.0512/src/evalfunc.c	2017-03-21 17:08:46.678923883 +0100
--- src/evalfunc.c	2017-03-26 13:35:21.707120035 +0200
***************
*** 11746,11752 ****
  		break;
  
  	case 'n':					/* name */
! 		p = get_highlight_name(NULL, id - 1);
  		break;
  
  	case 'r':					/* reverse */
--- 11746,11752 ----
  		break;
  
  	case 'n':					/* name */
! 		p = get_highlight_name_ext(NULL, id - 1, FALSE);
  		break;
  
  	case 'r':					/* reverse */
*** ../vim-8.0.0512/src/ex_cmds.c	2017-03-16 17:23:26.815815927 +0100
--- src/ex_cmds.c	2017-03-26 13:35:28.495072555 +0200
***************
*** 7962,7968 ****
      if (sp->sn_line_hl > 0)
      {
  	MSG_PUTS(" linehl=");
! 	p = get_highlight_name(NULL, sp->sn_line_hl - 1);
  	if (p == NULL)
  	    MSG_PUTS("NONE");
  	else
--- 7962,7968 ----
      if (sp->sn_line_hl > 0)
      {
  	MSG_PUTS(" linehl=");
! 	p = get_highlight_name_ext(NULL, sp->sn_line_hl - 1, FALSE);
  	if (p == NULL)
  	    MSG_PUTS("NONE");
  	else
***************
*** 7971,7977 ****
      if (sp->sn_text_hl > 0)
      {
  	MSG_PUTS(" texthl=");
! 	p = get_highlight_name(NULL, sp->sn_text_hl - 1);
  	if (p == NULL)
  	    MSG_PUTS("NONE");
  	else
--- 7971,7977 ----
      if (sp->sn_text_hl > 0)
      {
  	MSG_PUTS(" texthl=");
! 	p = get_highlight_name_ext(NULL, sp->sn_text_hl - 1, FALSE);
  	if (p == NULL)
  	    MSG_PUTS("NONE");
  	else
*** ../vim-8.0.0512/src/testdir/test_syntax.vim	2017-01-17 18:14:50.666847164 +0100
--- src/testdir/test_syntax.vim	2017-03-26 13:28:32.021983864 +0200
***************
*** 326,338 ****
--- 326,341 ----
    syntax keyword Bar tar
    call assert_match('Foo', execute('syntax'))
    call assert_match('Bar', execute('syntax'))
+   call assert_equal('Foo', synIDattr(hlID("Foo"), "name"))
    syn clear Foo
    call assert_notmatch('Foo', execute('syntax'))
    call assert_match('Bar', execute('syntax'))
+   call assert_equal('Foo', synIDattr(hlID("Foo"), "name"))
    syn clear Foo Bar
    call assert_notmatch('Foo', execute('syntax'))
    call assert_notmatch('Bar', execute('syntax'))
    hi clear Foo
+   call assert_equal('Foo', synIDattr(hlID("Foo"), "name"))
    hi clear Bar
  endfunc
  
*** ../vim-8.0.0512/src/testdir/test_cmdline.vim	2017-03-08 22:55:14.914181221 +0100
--- src/testdir/test_cmdline.vim	2017-03-26 13:46:08.250580277 +0200
***************
*** 71,76 ****
--- 71,84 ----
    call assert_equal('"hi default', getreg(':'))
    call feedkeys(":hi c\<S-Tab>\<Home>\"\<CR>", 'xt')
    call assert_equal('"hi clear', getreg(':'))
+ 
+   " A cleared group does not show up in completions.
+   hi Anders ctermfg=green
+   call assert_equal(['Aardig', 'Anders'], getcompletion('A', 'highlight'))
+   hi clear Aardig
+   call assert_equal(['Anders'], getcompletion('A', 'highlight'))
+   hi clear Anders
+   call assert_equal([], getcompletion('A', 'highlight'))
  endfunc
  
  func Test_expr_completion()
*** ../vim-8.0.0512/src/version.c	2017-03-25 20:16:23.656639924 +0100
--- src/version.c	2017-03-26 13:30:01.601357981 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     513,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
216. Your pet rock leaves home.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0514
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0514
Problem:    Script for creating cmdidxs can be improved.
Solution:   Count skipped lines instead of collecting the lines.  Add "const".
            (Dominique Pelle, closes #1594)
Files:      src/create_cmdidxs.pl, src/ex_docmd.c


*** ../vim-8.0.0513/src/create_cmdidxs.pl	2017-03-25 14:50:37.921991987 +0100
--- src/create_cmdidxs.pl	2017-03-26 21:42:57.447046140 +0200
***************
*** 9,23 ****
  # Script should be run every time new Ex commands are added in Vim,
  # from the src/vim directory, since it reads commands from "ex_cmds.h".
  
  # Find the list of Vim commands from cmdnames[] table in ex_cmds.h
  my @cmds;
! my @skipped;
  open(IN, "< ex_cmds.h") or die "can't open ex_cmds.h: $!\n";
  while (<IN>) {
    if (/^EX\(CMD_\S*,\s*"([a-z][^"]*)"/) {
!     push (@cmds, $1);
    } elsif (/^EX\(CMD_/) {
!     push (@skipped, $1);
    }
  }
  
--- 9,25 ----
  # Script should be run every time new Ex commands are added in Vim,
  # from the src/vim directory, since it reads commands from "ex_cmds.h".
  
+ use strict;
+ 
  # Find the list of Vim commands from cmdnames[] table in ex_cmds.h
  my @cmds;
! my $skipped_cmds;
  open(IN, "< ex_cmds.h") or die "can't open ex_cmds.h: $!\n";
  while (<IN>) {
    if (/^EX\(CMD_\S*,\s*"([a-z][^"]*)"/) {
!     push @cmds, $1;
    } elsif (/^EX\(CMD_/) {
!     ++$skipped_cmds;
    }
  }
  
***************
*** 68,74 ****
  }
  print "};\n",
        "\n",
!       "static int command_count = ", $#cmds + $#skipped + 2 , ";\n",
        "\n",
        "/* End of automatically generated code by create_cmdidxs.pl */\n";
- 
--- 70,75 ----
  }
  print "};\n",
        "\n",
!       "static const int command_count = ", scalar(@cmds) + $skipped_cmds, ";\n",
        "\n",
        "/* End of automatically generated code by create_cmdidxs.pl */\n";
*** ../vim-8.0.0513/src/ex_docmd.c	2017-03-25 15:07:38.750256076 +0100
--- src/ex_docmd.c	2017-03-26 21:44:58.934091555 +0200
***************
*** 566,572 ****
    /* z */ {  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, }
  };
  
! static int command_count = 539;
  
  /* End of automatically generated code by create_cmdidxs.pl */
  
--- 566,572 ----
    /* z */ {  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, }
  };
  
! static const int command_count = 539;
  
  /* End of automatically generated code by create_cmdidxs.pl */
  
*** ../vim-8.0.0513/src/version.c	2017-03-26 13:50:02.536929400 +0200
--- src/version.c	2017-03-26 21:44:11.590463183 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     514,
  /**/

-- 
I noticed my daughter's Disney-net password on a sticky note:
"MickeyMinnieGoofyPluto".  I asked her why it was so long.
"Because they say it has to have at least four characters."

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0515
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0515
Problem:    ml_get errors in silent Ex mode. (Dominique Pelle)
Solution:   Clear valid flags when setting the cursor.  Set the topline when
            not in full screen mode.
Files:      src/ex_docmd.c, src/testdir/test_startup.vim


*** ../vim-8.0.0514/src/ex_docmd.c	2017-03-26 21:46:23.353430049 +0200
--- src/ex_docmd.c	2017-03-27 22:39:20.852928005 +0200
***************
*** 10361,10366 ****
--- 10361,10367 ----
  	    {
  		curwin->w_cursor.lnum = eap->line1++;
  		curwin->w_cursor.col = 0;
+ 		check_cursor_moved(curwin);
  	    }
  
  	    exec_normal_cmd(
*** ../vim-8.0.0514/src/move.c	2017-03-12 18:23:35.853850026 +0100
--- src/move.c	2017-03-27 22:53:22.227398947 +0200
***************
*** 177,187 ****
      int		save_so = p_so;
  #endif
  
!     if (!screen_valid(TRUE))
! 	return;
! 
!     /* If the window height is zero just use the cursor line. */
!     if (curwin->w_height == 0)
      {
  	curwin->w_topline = curwin->w_cursor.lnum;
  	curwin->w_botline = curwin->w_topline;
--- 177,185 ----
      int		save_so = p_so;
  #endif
  
!     /* If there is no valid screen and when the window height is zero just use
!      * the cursor line. */
!     if (!screen_valid(TRUE) || curwin->w_height == 0)
      {
  	curwin->w_topline = curwin->w_cursor.lnum;
  	curwin->w_botline = curwin->w_topline;
***************
*** 2592,2597 ****
--- 2590,2596 ----
      n = (curwin->w_p_scr <= curwin->w_height) ?
  				    curwin->w_p_scr : curwin->w_height;
  
+     update_topline();
      validate_botline();
      room = curwin->w_empty_rows;
  #ifdef FEAT_DIFF
*** ../vim-8.0.0514/src/testdir/test_startup.vim	2017-03-04 14:37:14.649120059 +0100
--- src/testdir/test_startup.vim	2017-03-27 22:59:47.917072616 +0200
***************
*** 197,199 ****
--- 197,210 ----
    " Only expect "vim" to appear in v:progname.
    call assert_match('vim\c', v:progname)
  endfunc
+ 
+ func Test_silent_ex_mode()
+   if !has('unix') || has('gui_running')
+     " can't get output of Vim.
+     return
+   endif
+ 
+   " This caused an ml_get error.
+   let out = system(GetVimCommand() . '-u NONE -es -c''set verbose=1|h|exe "%norm\<c-y>\<c-d>"'' -c cq')
+   call assert_notmatch('E315:', out)
+ endfunc
*** ../vim-8.0.0514/src/version.c	2017-03-26 21:46:23.353430049 +0200
--- src/version.c	2017-03-27 23:01:16.796591740 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     515,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
221. Your wife melts your keyboard in the oven.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0516
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0516
Problem:    A large count on a normal command causes trouble. (Dominique
            Pelle)
Solution:   Make "opcount" long.
Files:      src/globals.h, src/testdir/test_normal.vim


*** ../vim-8.0.0515/src/globals.h	2017-03-09 18:19:58.161107848 +0100
--- src/globals.h	2017-03-29 13:07:30.300236242 +0200
***************
*** 932,941 ****
  					 * command interpreter. */
  
  EXTERN int	finish_op INIT(= FALSE);/* TRUE while an operator is pending */
! EXTERN int	opcount INIT(= 0);	/* count for pending operator */
  
  /*
!  * ex mode (Q) state
   */
  EXTERN int exmode_active INIT(= 0);	/* zero, EXMODE_NORMAL or EXMODE_VIM */
  EXTERN int ex_no_reprint INIT(= FALSE); /* no need to print after z or p */
--- 932,941 ----
  					 * command interpreter. */
  
  EXTERN int	finish_op INIT(= FALSE);/* TRUE while an operator is pending */
! EXTERN long	opcount INIT(= 0);	/* count for pending operator */
  
  /*
!  * Ex mode (Q) state
   */
  EXTERN int exmode_active INIT(= 0);	/* zero, EXMODE_NORMAL or EXMODE_VIM */
  EXTERN int ex_no_reprint INIT(= FALSE); /* no need to print after z or p */
*** ../vim-8.0.0515/src/testdir/test_normal.vim	2017-03-08 22:55:14.914181221 +0100
--- src/testdir/test_normal.vim	2017-03-29 13:05:45.400865091 +0200
***************
*** 2259,2284 ****
    bw!
  endfunc
  
! func! Test_normal54_Ctrl_bsl()
! 	new
! 	call setline(1, 'abcdefghijklmn')
! 	exe "norm! df\<c-\>\<c-n>"
! 	call assert_equal(['abcdefghijklmn'], getline(1,'$'))
! 	exe "norm! df\<c-\>\<c-g>"
! 	call assert_equal(['abcdefghijklmn'], getline(1,'$'))
! 	exe "norm! df\<c-\>m"
! 	call assert_equal(['abcdefghijklmn'], getline(1,'$'))
    if !has("multi_byte")
      return
    endif
! 	call setline(2, 'abcdefghijklmnf')
! 	norm! 2gg0
! 	exe "norm! df\<Char-0x101>"
! 	call assert_equal(['abcdefghijklmn', 'f'], getline(1,'$'))
! 	norm! 1gg0
! 	exe "norm! df\<esc>"
! 	call assert_equal(['abcdefghijklmn', 'f'], getline(1,'$'))
  
! 	" clean up
! 	bw!
  endfunc
--- 2259,2292 ----
    bw!
  endfunc
  
! func Test_normal54_Ctrl_bsl()
!   new
!   call setline(1, 'abcdefghijklmn')
!   exe "norm! df\<c-\>\<c-n>"
!   call assert_equal(['abcdefghijklmn'], getline(1,'$'))
!   exe "norm! df\<c-\>\<c-g>"
!   call assert_equal(['abcdefghijklmn'], getline(1,'$'))
!   exe "norm! df\<c-\>m"
!   call assert_equal(['abcdefghijklmn'], getline(1,'$'))
    if !has("multi_byte")
      return
    endif
!   call setline(2, 'abcdefghijklmnf')
!   norm! 2gg0
!   exe "norm! df\<Char-0x101>"
!   call assert_equal(['abcdefghijklmn', 'f'], getline(1,'$'))
!   norm! 1gg0
!   exe "norm! df\<esc>"
!   call assert_equal(['abcdefghijklmn', 'f'], getline(1,'$'))
  
!   " clean up
!   bw!
! endfunc
! 
! func Test_normal_large_count()
!   " This may fail with 32bit long, how do we detect that?
!   new
!   normal o
!   normal 6666666666dL
!   bwipe!
  endfunc
*** ../vim-8.0.0515/src/version.c	2017-03-27 23:02:03.396337294 +0200
--- src/version.c	2017-03-29 13:03:49.977557036 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     516,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
225. You sign up for free subscriptions for all the computer magazines

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0517
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0517
Problem:    There is no way to remove quickfix lists (for testing).
Solution:   Add the 'f' action to setqflist(). Add tests. (Yegappan
            Lakshmanan)
Files:      runtime/doc/eval.txt, src/evalfunc.c, src/quickfix.c,
            src/testdir/test_quickfix.vim


*** ../vim-8.0.0516/runtime/doc/eval.txt	2017-03-21 17:08:46.674923913 +0100
--- runtime/doc/eval.txt	2017-03-29 13:54:21.043320416 +0200
***************
*** 6917,6932 ****
  		Note that the list is not exactly the same as what
  		|getqflist()| returns.
  
! 							*E927*
! 		If {action} is set to 'a', then the items from {list} are
! 		added to the existing quickfix list. If there is no existing
! 		list, then a new list is created.
  		
! 		If {action} is set to 'r', then the items from the current
! 		quickfix list are replaced with the items from {list}.  This
! 		can also be used to clear the list: >
! 			:call setqflist([], 'r')
  <	
  		If {action} is not present or is set to ' ', then a new list
  		is created.
  
--- 6936,6954 ----
  		Note that the list is not exactly the same as what
  		|getqflist()| returns.
  
! 		{action} values:				*E927*
! 		'a'	The items from {list} are added to the existing
! 			quickfix list. If there is no existing list, then a
! 			new list is created.
  		
! 		'r'	The items from the current quickfix list are replaced
! 			with the items from {list}.  This can also be used to
! 			clear the list: >
! 				:call setqflist([], 'r')
  <	
+ 		'f'	All the quickfix lists in the quickfix stack are
+ 			freed.
+ 
  		If {action} is not present or is set to ' ', then a new list
  		is created.
  
*** ../vim-8.0.0516/src/evalfunc.c	2017-03-26 13:50:02.532929428 +0200
--- src/evalfunc.c	2017-03-29 13:51:18.160429885 +0200
***************
*** 10038,10044 ****
  	    act = get_tv_string_chk(action_arg);
  	    if (act == NULL)
  		return;		/* type error; errmsg already given */
! 	    if ((*act == 'a' || *act == 'r' || *act == ' ') && act[1] == NUL)
  		action = *act;
  	    else
  		EMSG2(_(e_invact), act);
--- 10038,10045 ----
  	    act = get_tv_string_chk(action_arg);
  	    if (act == NULL)
  		return;		/* type error; errmsg already given */
! 	    if ((*act == 'a' || *act == 'r' || *act == ' ' || *act == 'f') &&
! 		    act[1] == NUL)
  		action = *act;
  	    else
  		EMSG2(_(e_invact), act);
*** ../vim-8.0.0516/src/quickfix.c	2017-03-19 14:19:46.489645443 +0100
--- src/quickfix.c	2017-03-29 14:18:44.998423072 +0200
***************
*** 717,723 ****
  
  #ifdef FEAT_MBYTE
      /* Convert a line if it contains a non-ASCII character. */
!     if (state->vc.vc_type != CONV_NONE && has_non_ascii(state->linebuf)) {
  	char_u	*line;
  
  	line = string_convert(&state->vc, state->linebuf, &state->linelen);
--- 717,724 ----
  
  #ifdef FEAT_MBYTE
      /* Convert a line if it contains a non-ASCII character. */
!     if (state->vc.vc_type != CONV_NONE && has_non_ascii(state->linebuf))
!     {
  	char_u	*line;
  
  	line = string_convert(&state->vc, state->linebuf, &state->linelen);
***************
*** 917,923 ****
  	    }
  	    if (fmt_ptr->flags == '+' && !qi->qf_multiscan)	/* %+ */
  	    {
! 		if (linelen > fields->errmsglen) {
  		    /* linelen + null terminator */
  		    if ((fields->errmsg = vim_realloc(fields->errmsg,
  				    linelen + 1)) == NULL)
--- 918,925 ----
  	    }
  	    if (fmt_ptr->flags == '+' && !qi->qf_multiscan)	/* %+ */
  	    {
! 		if (linelen > fields->errmsglen)
! 		{
  		    /* linelen + null terminator */
  		    if ((fields->errmsg = vim_realloc(fields->errmsg,
  				    linelen + 1)) == NULL)
***************
*** 931,937 ****
  		if (regmatch.startp[i] == NULL || regmatch.endp[i] == NULL)
  		    continue;
  		len = (int)(regmatch.endp[i] - regmatch.startp[i]);
! 		if (len > fields->errmsglen) {
  		    /* len + null terminator */
  		    if ((fields->errmsg = vim_realloc(fields->errmsg, len + 1))
  			    == NULL)
--- 933,940 ----
  		if (regmatch.startp[i] == NULL || regmatch.endp[i] == NULL)
  		    continue;
  		len = (int)(regmatch.endp[i] - regmatch.startp[i]);
! 		if (len > fields->errmsglen)
! 		{
  		    /* len + null terminator */
  		    if ((fields->errmsg = vim_realloc(fields->errmsg, len + 1))
  			    == NULL)
***************
*** 1013,1019 ****
  	fields->namebuf[0] = NUL;	/* no match found, remove file name */
  	fields->lnum = 0;			/* don't jump to this line */
  	fields->valid = FALSE;
! 	if (linelen > fields->errmsglen) {
  	    /* linelen + null terminator */
  	    if ((fields->errmsg = vim_realloc(fields->errmsg,
  			    linelen + 1)) == NULL)
--- 1016,1023 ----
  	fields->namebuf[0] = NUL;	/* no match found, remove file name */
  	fields->lnum = 0;			/* don't jump to this line */
  	fields->valid = FALSE;
! 	if (linelen > fields->errmsglen)
! 	{
  	    /* linelen + null terminator */
  	    if ((fields->errmsg = vim_realloc(fields->errmsg,
  			    linelen + 1)) == NULL)
***************
*** 4798,4804 ****
  	qi->qf_lists[qi->qf_curlist].qf_nonevalid = TRUE;
      else
  	qi->qf_lists[qi->qf_curlist].qf_nonevalid = FALSE;
!     if (action != 'a') {
  	qi->qf_lists[qi->qf_curlist].qf_ptr =
  	    qi->qf_lists[qi->qf_curlist].qf_start;
  	if (qi->qf_lists[qi->qf_curlist].qf_count > 0)
--- 4802,4809 ----
  	qi->qf_lists[qi->qf_curlist].qf_nonevalid = TRUE;
      else
  	qi->qf_lists[qi->qf_curlist].qf_nonevalid = FALSE;
!     if (action != 'a')
!     {
  	qi->qf_lists[qi->qf_curlist].qf_ptr =
  	    qi->qf_lists[qi->qf_curlist].qf_start;
  	if (qi->qf_lists[qi->qf_curlist].qf_count > 0)
***************
*** 4861,4866 ****
--- 4866,4883 ----
      return retval;
  }
  
+     static void
+ qf_free_stack(win_T *wp, qf_info_T *qi)
+ {
+     qf_free_all(wp);
+     if (wp == NULL)
+     {
+ 	/* quickfix list */
+ 	qi->qf_curlist = 0;
+ 	qi->qf_listcount = 0;
+     }
+ }
+ 
  /*
   * Populate the quickfix list with the items supplied in the list
   * of dictionaries. "title" will be copied to w:quickfix_title.
***************
*** 4884,4890 ****
  	    return FAIL;
      }
  
!     if (what != NULL)
  	retval = qf_set_properties(qi, what, action);
      else
  	retval = qf_add_entries(qi, list, title, action);
--- 4901,4912 ----
  	    return FAIL;
      }
  
!     if (action == 'f')
!     {
! 	/* Free the entire quickfix or location list stack */
! 	qf_free_stack(wp, qi);
!     }
!     else if (what != NULL)
  	retval = qf_set_properties(qi, what, action);
      else
  	retval = qf_add_entries(qi, list, title, action);
***************
*** 5187,5193 ****
  			    /* Convert a line if 'encoding' is not utf-8 and
  			     * the line contains a non-ASCII character. */
  			    if (vc.vc_type != CONV_NONE
! 						   && has_non_ascii(IObuff)) {
  				line = string_convert(&vc, IObuff, NULL);
  				if (line == NULL)
  				    line = IObuff;
--- 5209,5216 ----
  			    /* Convert a line if 'encoding' is not utf-8 and
  			     * the line contains a non-ASCII character. */
  			    if (vc.vc_type != CONV_NONE
! 						   && has_non_ascii(IObuff))
! 			    {
  				line = string_convert(&vc, IObuff, NULL);
  				if (line == NULL)
  				    line = IObuff;
*** ../vim-8.0.0516/src/testdir/test_quickfix.vim	2017-03-19 14:19:46.493645414 +0100
--- src/testdir/test_quickfix.vim	2017-03-29 13:51:18.160429885 +0200
***************
*** 38,43 ****
--- 38,44 ----
      command! -nargs=* Xhelpgrep helpgrep <args>
      let g:Xgetlist = function('getqflist')
      let g:Xsetlist = function('setqflist')
+     call setqflist([], 'f')
    else
      command! -nargs=* -bang Xlist <mods>llist<bang> <args>
      command! -nargs=* Xgetexpr <mods>lgetexpr <args>
***************
*** 69,74 ****
--- 70,76 ----
      command! -nargs=* Xhelpgrep lhelpgrep <args>
      let g:Xgetlist = function('getloclist', [0])
      let g:Xsetlist = function('setloclist', [0])
+     call setloclist(0, [], 'f')
    endif
  endfunc
  
***************
*** 76,81 ****
--- 78,86 ----
  func XlistTests(cchar)
    call s:setup_commands(a:cchar)
  
+   if a:cchar == 'l'
+       call assert_fails('llist', 'E776:')
+   endif
    " With an empty list, command should return error
    Xgetexpr []
    silent! Xlist
***************
*** 146,151 ****
--- 151,159 ----
  func XageTests(cchar)
    call s:setup_commands(a:cchar)
  
+   let list = [{'bufnr': 1, 'lnum': 1}]
+   call g:Xsetlist(list)
+ 
    " Jumping to a non existent list should return error
    silent! Xolder 99
    call assert_true(v:errmsg ==# 'E380: At bottom of quickfix stack')
***************
*** 179,189 ****
  endfunc
  
  func Test_cage()
-   let list = [{'bufnr': 1, 'lnum': 1}]
-   call setqflist(list)
    call XageTests('c')
- 
-   call setloclist(0, list)
    call XageTests('l')
  endfunc
  
--- 187,193 ----
***************
*** 192,197 ****
--- 196,206 ----
  func XwindowTests(cchar)
    call s:setup_commands(a:cchar)
  
+   " Opening the location list window without any errors should fail
+   if a:cchar == 'l'
+       call assert_fails('lopen', 'E776:')
+   endif
+ 
    " Create a list with no valid entries
    Xgetexpr ['non-error 1', 'non-error 2', 'non-error 3']
  
***************
*** 232,237 ****
--- 241,259 ----
    " Calling cwindow should close the quickfix window with no valid errors
    Xwindow
    call assert_true(winnr('$') == 1)
+ 
+   if a:cchar == 'c'
+       " Opening the quickfix window in multiple tab pages should reuse the
+       " quickfix buffer
+       Xgetexpr ['Xtestfile1:1:3:Line1', 'Xtestfile2:2:2:Line2',
+ 		  \ 'Xtestfile3:3:1:Line3']
+       Xopen
+       let qfbufnum = bufnr('%')
+       tabnew
+       Xopen
+       call assert_equal(qfbufnum, bufnr('%'))
+       new | only | tabonly
+   endif
  endfunc
  
  func Test_cwindow()
***************
*** 360,365 ****
--- 382,394 ----
  func Xtest_browse(cchar)
    call s:setup_commands(a:cchar)
  
+   " Jumping to first or next location list entry without any error should
+   " result in failure
+   if a:cchar == 'l'
+       call assert_fails('lfirst', 'E776:')
+       call assert_fails('lnext', 'E776:')
+   endif
+ 
    call s:create_test_file('Xqftestfile1')
    call s:create_test_file('Xqftestfile2')
  
***************
*** 1550,1555 ****
--- 1579,1589 ----
  func XbottomTests(cchar)
    call s:setup_commands(a:cchar)
  
+   " Calling lbottom without any errors should fail
+   if a:cchar == 'l'
+       call assert_fails('lbottom', 'E776:')
+   endif
+ 
    call g:Xsetlist([{'filename': 'foo', 'lnum': 42}]) 
    Xopen
    let wid = win_getid()
***************
*** 1571,1580 ****
  func HistoryTest(cchar)
    call s:setup_commands(a:cchar)
  
-   call assert_fails(a:cchar . 'older 99', 'E380:')
    " clear all lists after the first one, then replace the first one.
    call g:Xsetlist([])
!   Xolder
    let entry = {'filename': 'foo', 'lnum': 42}
    call g:Xsetlist([entry], 'r')
    call g:Xsetlist([entry, entry])
--- 1605,1613 ----
  func HistoryTest(cchar)
    call s:setup_commands(a:cchar)
  
    " clear all lists after the first one, then replace the first one.
    call g:Xsetlist([])
!   call assert_fails('Xolder 99', 'E380:')
    let entry = {'filename': 'foo', 'lnum': 42}
    call g:Xsetlist([entry], 'r')
    call g:Xsetlist([entry, entry])
***************
*** 1617,1622 ****
--- 1650,1656 ----
      call assert_fails('call g:Xsetlist([], "a", [])', 'E715:')
  
      " Set and get the title
+     call g:Xsetlist([])
      Xopen
      wincmd p
      call g:Xsetlist([{'filename':'foo', 'lnum':27}])
*** ../vim-8.0.0516/src/version.c	2017-03-29 13:08:31.011872289 +0200
--- src/version.c	2017-03-29 13:51:00.056539735 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     517,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
230. You spend your Friday nights typing away at your keyboard

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0518
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0518
Problem:    Storing a zero byte from a multi-byte character causes fold text
            to show up wrong.
Solution:   Avoid putting zero in ScreenLines. (Christian Brabandt,
            closes #1567)
Files:      src/screen.c, src/testdir/test_display.vim


*** ../vim-8.0.0517/src/screen.c	2017-03-16 17:23:26.835815782 +0100
--- src/screen.c	2017-03-29 14:35:40.360222232 +0200
***************
*** 2697,2708 ****
  	    {
  		ScreenLinesUC[off + col] = fill_fold;
  		ScreenLinesC[0][off + col] = 0;
  	    }
  	    else
  		ScreenLinesUC[off + col] = 0;
  	}
  #endif
! 	ScreenLines[off + col++] = fill_fold;
      }
  
      if (text != buf)
--- 2697,2711 ----
  	    {
  		ScreenLinesUC[off + col] = fill_fold;
  		ScreenLinesC[0][off + col] = 0;
+                 ScreenLines[off + col] = 0x80; /* avoid storing zero */
  	    }
  	    else
  		ScreenLinesUC[off + col] = 0;
+ 	    col++;
  	}
+ 	else
  #endif
! 	    ScreenLines[off + col++] = fill_fold;
      }
  
      if (text != buf)
*** ../vim-8.0.0517/src/testdir/test_display.vim	2016-12-09 19:51:45.715697789 +0100
--- src/testdir/test_display.vim	2017-03-29 14:35:40.360222232 +0200
***************
*** 3,20 ****
    set term=ansi
  endif
  
! function! s:screenline(lnum, nr) abort
!   let line = []
!   for j in range(a:nr)
!     for c in range(1, winwidth(0))
!         call add(line, nr2char(screenchar(a:lnum+j, c)))
!     endfor
!     call add(line, "\n")
!   endfor
!   return join(line, '')
! endfunction
  
! function! Test_display_foldcolumn()
    new
    vnew
    vert resize 25
--- 3,14 ----
    set term=ansi
  endif
  
! source view_util.vim
  
! func! Test_display_foldcolumn()
!   if !has("folding")
!     return
!   endif
    new
    vnew
    vert resize 25
***************
*** 23,39 ****
  
    1put='e more noise blah blah more stuff here'
  
!   let expect = "e more noise blah blah<82\n> more stuff here        \n"
  
    call cursor(2, 1)
    norm! zt
!   redraw!
!   call assert_equal(expect, s:screenline(1,2))
    set fdc=2
!   redraw!
!   let expect = "  e more noise blah blah<\n  82> more stuff here    \n"
!   call assert_equal(expect, s:screenline(1,2))
  
    quit!
    quit!
! endfunction
--- 17,59 ----
  
    1put='e more noise blah blah more stuff here'
  
!   let expect = [
!         \ "e more noise blah blah<82",
!         \ "> more stuff here        "
!         \ ]
  
    call cursor(2, 1)
    norm! zt
!   let lines=ScreenLines([1,2], winwidth(0))
!   call assert_equal(expect, lines)
    set fdc=2
!   let lines=ScreenLines([1,2], winwidth(0))
!   let expect = [
!         \ "  e more noise blah blah<",
!         \ "  82> more stuff here    "
!         \ ]
!   call assert_equal(expect, lines)
  
    quit!
    quit!
! endfunc
! 
! func! Test_display_foldtext_mbyte()
!   if !has("folding") || !has("multi_byte")
!     return
!   endif
!   call NewWindow(10, 40)
!   call append(0, range(1,20))
!   exe "set foldmethod=manual foldtext=foldtext() fillchars=fold:\u2500,vert:\u2502 fdc=2"
!   call cursor(2, 1)
!   norm! zf13G
!   let lines=ScreenLines([1,3], winwidth(0)+1)
!   let expect=[
!         \ "  1                                     \u2502",
!         \ "+ +-- 12 lines: 2". repeat("\u2500", 23). "\u2502",
!         \ "  14                                    \u2502",
!         \ ]
!   call assert_equal(expect, lines)
!   set foldtext& fillchars& foldmethod& fdc&
!   bw!
! endfunc
*** ../vim-8.0.0517/src/version.c	2017-03-29 14:19:21.886199149 +0200
--- src/version.c	2017-03-29 14:39:51.506650519 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     518,
  /**/

-- 
A computer without Windows is like a fish without a bicycle.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0519
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0519
Problem:    Character classes are not well tested. They can differ between
            platforms.
Solution:   Add tests.  In the documentation make clear which classes depend
            on what library function.  Only use :cntrl: and :graph: for ASCII.
            (Kazunobu Kuriyama, Dominique Pelle, closes #1560)
            Update the documentation.
Files:      src/regexp.c, src/regexp_nfa.c, runtime/doc/pattern.txt,
            src/testdir/test_regexp_utf8.vim


*** ../vim-8.0.0518/src/regexp.c	2017-03-12 20:09:59.488468234 +0100
--- src/regexp.c	2017-03-29 15:19:23.207812438 +0200
***************
*** 2555,2571 ****
  				regc('\t');
  				break;
  			    case CLASS_CNTRL:
! 				for (cu = 1; cu <= 255; cu++)
  				    if (iscntrl(cu))
  					regmbc(cu);
  				break;
  			    case CLASS_DIGIT:
! 				for (cu = 1; cu <= 255; cu++)
  				    if (VIM_ISDIGIT(cu))
  					regmbc(cu);
  				break;
  			    case CLASS_GRAPH:
! 				for (cu = 1; cu <= 255; cu++)
  				    if (isgraph(cu))
  					regmbc(cu);
  				break;
--- 2555,2571 ----
  				regc('\t');
  				break;
  			    case CLASS_CNTRL:
! 				for (cu = 1; cu <= 127; cu++)
  				    if (iscntrl(cu))
  					regmbc(cu);
  				break;
  			    case CLASS_DIGIT:
! 				for (cu = 1; cu <= 127; cu++)
  				    if (VIM_ISDIGIT(cu))
  					regmbc(cu);
  				break;
  			    case CLASS_GRAPH:
! 				for (cu = 1; cu <= 127; cu++)
  				    if (isgraph(cu))
  					regmbc(cu);
  				break;
*** ../vim-8.0.0518/src/regexp_nfa.c	2017-03-12 20:09:59.488468234 +0100
--- src/regexp_nfa.c	2017-03-29 15:19:38.743715954 +0200
***************
*** 4871,4877 ****
  		return OK;
  	    break;
  	case NFA_CLASS_CNTRL:
! 	    if (c >= 1 && c <= 255 && iscntrl(c))
  		return OK;
  	    break;
  	case NFA_CLASS_DIGIT:
--- 4871,4877 ----
  		return OK;
  	    break;
  	case NFA_CLASS_CNTRL:
! 	    if (c >= 1 && c <= 127 && iscntrl(c))
  		return OK;
  	    break;
  	case NFA_CLASS_DIGIT:
***************
*** 4879,4885 ****
  		return OK;
  	    break;
  	case NFA_CLASS_GRAPH:
! 	    if (c >= 1 && c <= 255 && isgraph(c))
  		return OK;
  	    break;
  	case NFA_CLASS_LOWER:
--- 4879,4885 ----
  		return OK;
  	    break;
  	case NFA_CLASS_GRAPH:
! 	    if (c >= 1 && c <= 127 && isgraph(c))
  		return OK;
  	    break;
  	case NFA_CLASS_LOWER:
*** ../vim-8.0.0518/runtime/doc/pattern.txt	2016-09-12 12:45:26.000000000 +0200
--- runtime/doc/pattern.txt	2017-03-29 15:18:47.300035463 +0200
***************
*** 1082,1106 ****
  	- A character class expression is evaluated to the set of characters
  	  belonging to that character class.  The following character classes
  	  are supported:
! 			  Name		Contents ~
! *[:alnum:]*		  [:alnum:]     ASCII letters and digits
! *[:alpha:]*		  [:alpha:]     ASCII letters
! *[:blank:]*		  [:blank:]     space and tab characters
! *[:cntrl:]*		  [:cntrl:]     control characters
! *[:digit:]*		  [:digit:]     decimal digits
! *[:graph:]*		  [:graph:]     printable characters excluding space
! *[:lower:]*		  [:lower:]     lowercase letters (all letters when
  					'ignorecase' is used)
! *[:print:]*		  [:print:]     printable characters including space
! *[:punct:]*		  [:punct:]     ASCII punctuation characters
! *[:space:]*		  [:space:]     whitespace characters
! *[:upper:]*		  [:upper:]     uppercase letters (all letters when
  					'ignorecase' is used)
! *[:xdigit:]*		  [:xdigit:]    hexadecimal digits
! *[:return:]*		  [:return:]	the <CR> character
! *[:tab:]*		  [:tab:]	the <Tab> character
! *[:escape:]*		  [:escape:]	the <Esc> character
! *[:backspace:]*		  [:backspace:]	the <BS> character
  	  The brackets in character class expressions are additional to the
  	  brackets delimiting a collection.  For example, the following is a
  	  plausible pattern for a UNIX filename: "[-./[:alnum:]_~]\+" That is,
--- 1085,1111 ----
  	- A character class expression is evaluated to the set of characters
  	  belonging to that character class.  The following character classes
  	  are supported:
! 		  Name	      Func	Contents ~
! *[:alnum:]*	  [:alnum:]   isalnum	ASCII letters and digits
! *[:alpha:]*	  [:alpha:]   isalpha  	ASCII letters
! *[:blank:]*	  [:blank:]     	space and tab
! *[:cntrl:]*	  [:cntrl:]   iscntrl 	ASCII control characters
! *[:digit:]*	  [:digit:]     	decimal digits '0' to '9'
! *[:graph:]*	  [:graph:]   isgraph	ASCII printable characters excluding
! 					space
! *[:lower:]*	  [:lower:]   (1)	lowercase letters (all letters when
  					'ignorecase' is used)
! *[:print:]*	  [:print:]   (2) 	printable characters including space
! *[:punct:]*	  [:punct:]   ispunct	ASCII punctuation characters
! *[:space:]*	  [:space:]     	whitespace characters: space, tab, CR,
! 					NL, vertical tab, form feed
! *[:upper:]*	  [:upper:]   (3)	uppercase letters (all letters when
  					'ignorecase' is used)
! *[:xdigit:]*	  [:xdigit:]    	hexadecimal digits: 0-9, a-f, A-F
! *[:return:]*	  [:return:]		the <CR> character
! *[:tab:]*	  [:tab:]		the <Tab> character
! *[:escape:]*	  [:escape:]		the <Esc> character
! *[:backspace:]*	  [:backspace:]		the <BS> character
  	  The brackets in character class expressions are additional to the
  	  brackets delimiting a collection.  For example, the following is a
  	  plausible pattern for a UNIX filename: "[-./[:alnum:]_~]\+" That is,
***************
*** 1111,1116 ****
--- 1116,1128 ----
  	  regexp engine.  See |two-engines|.  In the future these items may
  	  work for multi-byte characters.  For now, to get all "alpha"
  	  characters you can use: [[:lower:][:upper:]].
+ 
+ 	  The "Func" column shows what library function is used.  The
+ 	  implementation depends on the system.  Otherwise:
+ 	  (1) Uses islower() for ASCII and Vim builtin rules for other
+ 	  characters when built with the |+multi_byte| feature.
+ 	  (2) Uses Vim builtin rules
+ 	  (3) As with (1) but using isupper()
  							*/[[=* *[==]*
  	- An equivalence class.  This means that characters are matched that
  	  have almost the same meaning, e.g., when ignoring accents.  This
*** ../vim-8.0.0518/src/testdir/test_regexp_utf8.vim	2016-08-17 20:17:41.000000000 +0200
--- src/testdir/test_regexp_utf8.vim	2017-03-29 15:22:28.294663344 +0200
***************
*** 38,49 ****
    set isprint=@,161-255
    call assert_equal('Motrhead', matchstr('Motrhead', '[[:print:]]\+'))
  
    let alphachars = ''
    let lowerchars = ''
-   let upperchars = ''
-   let alnumchars = ''
    let printchars = ''
    let punctchars = ''
    let xdigitchars = ''
    let i = 1
    while i <= 255
--- 38,58 ----
    set isprint=@,161-255
    call assert_equal('Motrhead', matchstr('Motrhead', '[[:print:]]\+'))
  
+   let alnumchars = ''
    let alphachars = ''
+   let backspacechar = ''
+   let blankchars = ''
+   let cntrlchars = ''
+   let digitchars = ''
+   let escapechar = ''
+   let graphchars = ''
    let lowerchars = ''
    let printchars = ''
    let punctchars = ''
+   let returnchar = ''
+   let spacechars = ''
+   let tabchar = ''
+   let upperchars = ''
    let xdigitchars = ''
    let i = 1
    while i <= 255
***************
*** 51,71 ****
      if c =~ '[[:alpha:]]'
        let alphachars .= c
      endif
-     if c =~ '[[:lower:]]'
-       let lowerchars .= c
-     endif
-     if c =~ '[[:upper:]]'
-       let upperchars .= c
-     endif
      if c =~ '[[:alnum:]]'
        let alnumchars .= c
      endif
      if c =~ '[[:print:]]'
        let printchars .= c
      endif
      if c =~ '[[:punct:]]'
        let punctchars .= c
      endif
      if c =~ '[[:xdigit:]]'
        let xdigitchars .= c
      endif
--- 60,107 ----
      if c =~ '[[:alpha:]]'
        let alphachars .= c
      endif
      if c =~ '[[:alnum:]]'
        let alnumchars .= c
      endif
+     if c =~ '[[:backspace:]]'
+       let backspacechar .= c
+     endif
+     if c =~ '[[:blank:]]'
+       let blankchars .= c
+     endif
+     if c =~ '[[:cntrl:]]'
+       let cntrlchars .= c
+     endif
+     if c =~ '[[:digit:]]'
+       let digitchars .= c
+     endif
+     if c =~ '[[:escape:]]'
+       let escapechar .= c
+     endif
+     if c =~ '[[:graph:]]'
+       let graphchars .= c
+     endif
+     if c =~ '[[:lower:]]'
+       let lowerchars .= c
+     endif
      if c =~ '[[:print:]]'
        let printchars .= c
      endif
      if c =~ '[[:punct:]]'
        let punctchars .= c
      endif
+     if c =~ '[[:return:]]'
+       let returnchar .= c
+     endif
+     if c =~ '[[:space:]]'
+       let spacechars .= c
+     endif
+     if c =~ '[[:tab:]]'
+       let tabchar .= c
+     endif
+     if c =~ '[[:upper:]]'
+       let upperchars .= c
+     endif
      if c =~ '[[:xdigit:]]'
        let xdigitchars .= c
      endif
***************
*** 73,83 ****
    endwhile
  
    call assert_equal('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', alphachars)
-   call assert_equal('abcdefghijklmnopqrstuvwxyz', lowerchars)
-   call assert_equal('ABCDEFGHIJKLMNOPQRSTUVWXYZ', upperchars)
    call assert_equal('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', alnumchars)
    call assert_equal(' !"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~', printchars)
    call assert_equal('!"#$%&''()*+,-./:;<=>?@[\]^_`{|}~', punctchars)
    call assert_equal('0123456789ABCDEFabcdef', xdigitchars)
  endfunc
  
--- 109,130 ----
    endwhile
  
    call assert_equal('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', alphachars)
    call assert_equal('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', alnumchars)
+   call assert_equal("\b", backspacechar)
+   call assert_equal("\t ", blankchars)
+   " Commented out: it succeeds on Linux and Windows, but fails on macOs in Travis.
+   " call assert_equal("\x01\x02\x03\x04\x05\x06\x07\b\t\n\x0b\f\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\e\x1c\x1d\x1e\x1f\x7f", cntrlchars)
+   call assert_equal("0123456789", digitchars)
+   call assert_equal("\<Esc>", escapechar)
+   " Commented out: it succeeds on Linux and Windows, but fails on macOs in Travis.
+   " call assert_equal('!"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~', graphchars)
+   call assert_equal('abcdefghijklmnopqrstuvwxyz', lowerchars)
    call assert_equal(' !"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~', printchars)
    call assert_equal('!"#$%&''()*+,-./:;<=>?@[\]^_`{|}~', punctchars)
+   call assert_equal('ABCDEFGHIJKLMNOPQRSTUVWXYZ', upperchars)
+   call assert_equal("\r", returnchar)
+   call assert_equal("\t\n\x0b\f\r ", spacechars)
+   call assert_equal("\t", tabchar)
    call assert_equal('0123456789ABCDEFabcdef', xdigitchars)
  endfunc
  
*** ../vim-8.0.0518/src/version.c	2017-03-29 14:40:38.342357669 +0200
--- src/version.c	2017-03-29 15:23:59.134099666 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     519,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
231. You sprinkle Carpet Fresh on the rugs and put your vacuum cleaner
     in the front doorway permanently so it always looks like you are
     actually attempting to do something about that mess that has amassed
     since you discovered the Internet.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0520
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0520
Problem:    Using a function pointer instead of the actual function, which we
            know.
Solution:   Change mb_ functions to utf_ functions when already checked for
            Unicode. (Dominique Pelle, closes #1582)
Files:      src/message.c, src/misc2.c, src/regexp.c, src/regexp_nfa.c,
            src/screen.c, src/spell.c


*** ../vim-8.0.0519/src/message.c	2017-03-16 19:58:19.416253412 +0100
--- src/message.c	2017-03-29 17:29:30.108452015 +0200
***************
*** 315,321 ****
  	for (;;)
  	{
  	    do
! 		half = half - (*mb_head_off)(s, s + half - 1) - 1;
  	    while (half > 0 && utf_iscomposing(utf_ptr2char(s + half)));
  	    n = ptr2cells(s + half);
  	    if (len + n > room || half == 0)
--- 315,321 ----
  	for (;;)
  	{
  	    do
! 		half = half - utf_head_off(s, s + half - 1) - 1;
  	    while (half > 0 && utf_iscomposing(utf_ptr2char(s + half)));
  	    n = ptr2cells(s + half);
  	    if (len + n > room || half == 0)
*** ../vim-8.0.0519/src/misc2.c	2017-03-19 21:36:52.825933116 +0100
--- src/misc2.c	2017-03-29 17:21:00.895473402 +0200
***************
*** 1874,1880 ****
      {
  	while (*p != NUL)
  	{
! 	    int l = (*mb_ptr2len)(p);
  
  	    /* Avoid matching an illegal byte here. */
  	    if (utf_ptr2char(p) == c && l > 1)
--- 1874,1880 ----
      {
  	while (*p != NUL)
  	{
! 	    int l = utfc_ptr2len(p);
  
  	    /* Avoid matching an illegal byte here. */
  	    if (utf_ptr2char(p) == c && l > 1)
*** ../vim-8.0.0519/src/regexp.c	2017-03-29 15:31:15.031397364 +0200
--- src/regexp.c	2017-03-29 17:21:00.895473402 +0200
***************
*** 4732,4738 ****
  		    break;
  		}
  		if (enc_utf8)
! 		    opndc = mb_ptr2char(opnd);
  		if (enc_utf8 && utf_iscomposing(opndc))
  		{
  		    /* When only a composing char is given match at any
--- 4732,4738 ----
  		    break;
  		}
  		if (enc_utf8)
! 		    opndc = utf_ptr2char(opnd);
  		if (enc_utf8 && utf_iscomposing(opndc))
  		{
  		    /* When only a composing char is given match at any
***************
*** 4741,4747 ****
  		    for (i = 0; reginput[i] != NUL;
  						i += utf_ptr2len(reginput + i))
  		    {
! 			inpc = mb_ptr2char(reginput + i);
  			if (!utf_iscomposing(inpc))
  			{
  			    if (i > 0)
--- 4741,4747 ----
  		    for (i = 0; reginput[i] != NUL;
  						i += utf_ptr2len(reginput + i))
  		    {
! 			inpc = utf_ptr2char(reginput + i);
  			if (!utf_iscomposing(inpc))
  			{
  			    if (i > 0)
***************
*** 4750,4756 ****
  			else if (opndc == inpc)
  			{
  			    /* Include all following composing chars. */
! 			    len = i + mb_ptr2len(reginput + i);
  			    status = RA_MATCH;
  			    break;
  			}
--- 4750,4756 ----
  			else if (opndc == inpc)
  			{
  			    /* Include all following composing chars. */
! 			    len = i + utfc_ptr2len(reginput + i);
  			    status = RA_MATCH;
  			    break;
  			}
*** ../vim-8.0.0519/src/regexp_nfa.c	2017-03-29 15:31:15.031397364 +0200
--- src/regexp_nfa.c	2017-03-29 17:21:00.899473378 +0200
***************
*** 1974,1980 ****
  nfa_do_multibyte:
  		/* plen is length of current char with composing chars */
  		if (enc_utf8 && ((*mb_char2len)(c)
! 			    != (plen = (*mb_ptr2len)(old_regparse))
  						       || utf_iscomposing(c)))
  		{
  		    int i = 0;
--- 1974,1980 ----
  nfa_do_multibyte:
  		/* plen is length of current char with composing chars */
  		if (enc_utf8 && ((*mb_char2len)(c)
! 			    != (plen = utfc_ptr2len(old_regparse))
  						       || utf_iscomposing(c)))
  		{
  		    int i = 0;
*** ../vim-8.0.0519/src/screen.c	2017-03-29 14:40:38.342357669 +0200
--- src/screen.c	2017-03-29 17:21:00.899473378 +0200
***************
*** 4119,4125 ****
  		c = c_extra;
  #ifdef FEAT_MBYTE
  		mb_c = c;	/* doesn't handle non-utf-8 multi-byte! */
! 		if (enc_utf8 && (*mb_char2len)(c) > 1)
  		{
  		    mb_utf8 = TRUE;
  		    u8cc[0] = 0;
--- 4119,4125 ----
  		c = c_extra;
  #ifdef FEAT_MBYTE
  		mb_c = c;	/* doesn't handle non-utf-8 multi-byte! */
! 		if (enc_utf8 && utf_char2len(c) > 1)
  		{
  		    mb_utf8 = TRUE;
  		    u8cc[0] = 0;
***************
*** 4140,4146 ****
  		    {
  			/* If the UTF-8 character is more than one byte:
  			 * Decode it into "mb_c". */
! 			mb_l = (*mb_ptr2len)(p_extra);
  			mb_utf8 = FALSE;
  			if (mb_l > n_extra)
  			    mb_l = 1;
--- 4140,4146 ----
  		    {
  			/* If the UTF-8 character is more than one byte:
  			 * Decode it into "mb_c". */
! 			mb_l = utfc_ptr2len(p_extra);
  			mb_utf8 = FALSE;
  			if (mb_l > n_extra)
  			    mb_l = 1;
***************
*** 4219,4225 ****
  		{
  		    /* If the UTF-8 character is more than one byte: Decode it
  		     * into "mb_c". */
! 		    mb_l = (*mb_ptr2len)(ptr);
  		    mb_utf8 = FALSE;
  		    if (mb_l > 1)
  		    {
--- 4219,4225 ----
  		{
  		    /* If the UTF-8 character is more than one byte: Decode it
  		     * into "mb_c". */
! 		    mb_l = utfc_ptr2len(ptr);
  		    mb_utf8 = FALSE;
  		    if (mb_l > 1)
  		    {
***************
*** 4612,4618 ****
  		    }
  #ifdef FEAT_MBYTE
  		    mb_c = c;
! 		    if (enc_utf8 && (*mb_char2len)(c) > 1)
  		    {
  			mb_utf8 = TRUE;
  			u8cc[0] = 0;
--- 4612,4618 ----
  		    }
  #ifdef FEAT_MBYTE
  		    mb_c = c;
! 		    if (enc_utf8 && utf_char2len(c) > 1)
  		    {
  			mb_utf8 = TRUE;
  			u8cc[0] = 0;
***************
*** 4634,4640 ****
  		    }
  #ifdef FEAT_MBYTE
  		    mb_c = c;
! 		    if (enc_utf8 && (*mb_char2len)(c) > 1)
  		    {
  			mb_utf8 = TRUE;
  			u8cc[0] = 0;
--- 4634,4640 ----
  		    }
  #ifdef FEAT_MBYTE
  		    mb_c = c;
! 		    if (enc_utf8 && utf_char2len(c) > 1)
  		    {
  			mb_utf8 = TRUE;
  			u8cc[0] = 0;
***************
*** 4765,4771 ****
  			saved_attr2 = char_attr; /* save current attr */
  #ifdef FEAT_MBYTE
  			mb_c = c;
! 			if (enc_utf8 && (*mb_char2len)(c) > 1)
  			{
  			    mb_utf8 = TRUE;
  			    u8cc[0] = 0;
--- 4765,4771 ----
  			saved_attr2 = char_attr; /* save current attr */
  #ifdef FEAT_MBYTE
  			mb_c = c;
! 			if (enc_utf8 && utf_char2len(c) > 1)
  			{
  			    mb_utf8 = TRUE;
  			    u8cc[0] = 0;
***************
*** 4839,4845 ****
  		    }
  #ifdef FEAT_MBYTE
  		    mb_c = c;
! 		    if (enc_utf8 && (*mb_char2len)(c) > 1)
  		    {
  			mb_utf8 = TRUE;
  			u8cc[0] = 0;
--- 4839,4845 ----
  		    }
  #ifdef FEAT_MBYTE
  		    mb_c = c;
! 		    if (enc_utf8 && utf_char2len(c) > 1)
  		    {
  			mb_utf8 = TRUE;
  			u8cc[0] = 0;
***************
*** 5003,5009 ****
  		}
  # ifdef FEAT_MBYTE
  		mb_c = c;
! 		if (enc_utf8 && (*mb_char2len)(c) > 1)
  		{
  		    mb_utf8 = TRUE;
  		    u8cc[0] = 0;
--- 5003,5009 ----
  		}
  # ifdef FEAT_MBYTE
  		mb_c = c;
! 		if (enc_utf8 && utf_char2len(c) > 1)
  		{
  		    mb_utf8 = TRUE;
  		    u8cc[0] = 0;
***************
*** 5110,5116 ****
  		extra_attr = HL_ATTR(HLF_AT);
  	    }
  	    mb_c = c;
! 	    if (enc_utf8 && (*mb_char2len)(c) > 1)
  	    {
  		mb_utf8 = TRUE;
  		u8cc[0] = 0;
--- 5110,5116 ----
  		extra_attr = HL_ATTR(HLF_AT);
  	    }
  	    mb_c = c;
! 	    if (enc_utf8 && utf_char2len(c) > 1)
  	    {
  		mb_utf8 = TRUE;
  		u8cc[0] = 0;
***************
*** 5383,5389 ****
  	    char_attr = HL_ATTR(HLF_AT);
  #ifdef FEAT_MBYTE
  	    mb_c = c;
! 	    if (enc_utf8 && (*mb_char2len)(c) > 1)
  	    {
  		mb_utf8 = TRUE;
  		u8cc[0] = 0;
--- 5383,5389 ----
  	    char_attr = HL_ATTR(HLF_AT);
  #ifdef FEAT_MBYTE
  	    mb_c = c;
! 	    if (enc_utf8 && utf_char2len(c) > 1)
  	    {
  		mb_utf8 = TRUE;
  		u8cc[0] = 0;
*** ../vim-8.0.0519/src/spell.c	2017-03-12 20:09:59.492468205 +0100
--- src/spell.c	2017-03-29 17:21:00.903473354 +0200
***************
*** 1208,1214 ****
  	/* Need to convert the single byte flags to utf8 characters. */
  	p = uflags;
  	for (i = 0; flags[i] != NUL; ++i)
! 	    p += mb_char2bytes(flags[i], p);
  	*p = NUL;
  	p = uflags;
      }
--- 1208,1214 ----
  	/* Need to convert the single byte flags to utf8 characters. */
  	p = uflags;
  	for (i = 0; flags[i] != NUL; ++i)
! 	    p += utf_char2bytes(flags[i], p);
  	*p = NUL;
  	p = uflags;
      }
***************
*** 5117,5127 ****
  				 * SCORE_SUBCOMP. */
  				if (enc_utf8
  					&& utf_iscomposing(
! 					    mb_ptr2char(tword
  						+ sp->ts_twordlen
  							   - sp->ts_tcharlen))
  					&& utf_iscomposing(
! 					    mb_ptr2char(fword
  							+ sp->ts_fcharstart)))
  				    sp->ts_score -=
  						  SCORE_SUBST - SCORE_SUBCOMP;
--- 5117,5127 ----
  				 * SCORE_SUBCOMP. */
  				if (enc_utf8
  					&& utf_iscomposing(
! 					    utf_ptr2char(tword
  						+ sp->ts_twordlen
  							   - sp->ts_tcharlen))
  					&& utf_iscomposing(
! 					    utf_ptr2char(fword
  							+ sp->ts_fcharstart)))
  				    sp->ts_score -=
  						  SCORE_SUBST - SCORE_SUBCOMP;
*** ../vim-8.0.0519/src/version.c	2017-03-29 15:31:15.035397340 +0200
--- src/version.c	2017-03-29 17:23:02.806750569 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     520,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
232. You start conversations with, "Have you gotten an ISDN line?"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0521
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0521
Problem:    GtkForm handling is outdated.
Solution:   Get rid of event filter functions.  Get rid of GtkForm.width and
            .height.  Eliminate gtk_widget_size_request() calls. (Kazunobu
            Kuriyama)
Files:      src/gui_gtk_f.c, src/gui_gtk_f.h


*** ../vim-8.0.0520/src/gui_gtk_f.c	2016-09-09 22:00:25.000000000 +0200
--- src/gui_gtk_f.c	2017-03-29 17:34:14.302763381 +0200
***************
*** 92,105 ****
  				    gboolean force_allocate);
  static void gtk_form_position_children(GtkForm *form);
  
- #if !GTK_CHECK_VERSION(3,0,0)
- static GdkFilterReturn gtk_form_filter(GdkXEvent *gdk_xevent,
- 				       GdkEvent *event,
- 				       gpointer data);
- static GdkFilterReturn gtk_form_main_filter(GdkXEvent *gdk_xevent,
- 					    GdkEvent *event,
- 					    gpointer data);
- #endif
  #if !GTK_CHECK_VERSION(3,16,0)
  static void gtk_form_set_static_gravity(GdkWindow *window,
  					gboolean use_static);
--- 92,97 ----
***************
*** 171,179 ****
  	gtk_form_attach_child_window(form, child);
  
      gtk_widget_set_parent(child_widget, GTK_WIDGET(form));
- #if !GTK_CHECK_VERSION(3,0,0)
-     gtk_widget_size_request(child->widget, NULL);
- #endif
  
  #if GTK_CHECK_VERSION(3,0,0)
      if (gtk_widget_get_realized(GTK_WIDGET(form))
--- 163,168 ----
***************
*** 301,319 ****
      gtk_widget_set_has_window(GTK_WIDGET(form), TRUE);
  #endif
      form->children = NULL;
- 
- #if !GTK_CHECK_VERSION(3,0,0)
-     form->width = 1;
-     form->height = 1;
- #endif
- 
      form->bin_window = NULL;
- 
- #if !GTK_CHECK_VERSION(3,0,0)
-     form->configure_serial = 0;
-     form->visibility = GDK_VISIBILITY_PARTIAL;
- #endif
- 
      form->freeze_count = 0;
  }
  
--- 290,296 ----
***************
*** 414,424 ****
      gtk_style_set_background(widget->style, form->bin_window, GTK_STATE_NORMAL);
  #endif
  
- #if !GTK_CHECK_VERSION(3,0,0)
-     gdk_window_add_filter(widget->window, gtk_form_main_filter, form);
-     gdk_window_add_filter(form->bin_window, gtk_form_filter, form);
- #endif
- 
      for (tmp_list = form->children; tmp_list; tmp_list = tmp_list->next)
      {
  	GtkFormChild *child = tmp_list->data;
--- 391,396 ----
***************
*** 540,572 ****
      static void
  gtk_form_size_request(GtkWidget *widget, GtkRequisition *requisition)
  {
- #if !GTK_CHECK_VERSION(3,0,0)
-     GList *tmp_list;
-     GtkForm *form;
- #endif
- 
      g_return_if_fail(GTK_IS_FORM(widget));
  
- #if !GTK_CHECK_VERSION(3,0,0)
-     form = GTK_FORM(widget);
- #endif
- 
- #if GTK_CHECK_VERSION(3,0,0)
      requisition->width = 1;
      requisition->height = 1;
- #else
-     requisition->width = form->width;
-     requisition->height = form->height;
- 
-     tmp_list = form->children;
- 
-     while (tmp_list)
-     {
- 	GtkFormChild *child = tmp_list->data;
- 	gtk_widget_size_request(child->widget, NULL);
- 	tmp_list = tmp_list->next;
-     }
- #endif
  }
  
  #if GTK_CHECK_VERSION(3,0,0)
--- 512,522 ----
      static void
  gtk_form_size_request(GtkWidget *widget, GtkRequisition *requisition)
  {
      g_return_if_fail(GTK_IS_FORM(widget));
+     g_return_if_fail(requisition != NULL);
  
      requisition->width = 1;
      requisition->height = 1;
  }
  
  #if GTK_CHECK_VERSION(3,0,0)
***************
*** 735,762 ****
  	return FALSE;
  
      for (tmp_list = form->children; tmp_list; tmp_list = tmp_list->next)
!     {
! 	GtkFormChild	*formchild = tmp_list->data;
! 	GtkWidget	*child	   = formchild->widget;
! 	/*
! 	 * The following chunk of code is taken from gtkcontainer.c.  The
! 	 * gtk1.x code synthesized expose events directly on the child widgets,
! 	 * which can't be done in gtk2
! 	 */
! 	if (GTK_WIDGET_DRAWABLE(child) && GTK_WIDGET_NO_WINDOW(child)
! 		&& child->window == event->window)
! 	{
! 	    GdkEventExpose child_event;
! 	    child_event = *event;
! 
! 	    child_event.region = gtk_widget_region_intersect(child, event->region);
! 	    if (!gdk_region_empty(child_event.region))
! 	    {
! 		gdk_region_get_clipbox(child_event.region, &child_event.area);
! 		gtk_widget_send_expose(child, (GdkEvent *)&child_event);
! 	    }
! 	}
!     }
  
      return FALSE;
  }
--- 685,693 ----
  	return FALSE;
  
      for (tmp_list = form->children; tmp_list; tmp_list = tmp_list->next)
! 	gtk_container_propagate_expose(GTK_CONTAINER(widget),
! 		GTK_WIDGET(((GtkFormChild *)tmp_list->data)->widget),
! 		event);
  
      return FALSE;
  }
***************
*** 1068,1153 ****
  	gtk_form_position_child(form, tmp_list->data, FALSE);
  }
  
- /* Callbacks */
- 
- /* The main event filter. Actually, we probably don't really need
-  * to install this as a filter at all, since we are calling it
-  * directly above in the expose-handling hack.
-  *
-  * This routine identifies expose events that are generated when
-  * we've temporarily moved the bin_window_origin, and translates
-  * them or discards them, depending on whether we are obscured
-  * or not.
-  */
- #if !GTK_CHECK_VERSION(3,0,0)
-     static GdkFilterReturn
- gtk_form_filter(GdkXEvent *gdk_xevent, GdkEvent *event UNUSED, gpointer data)
- {
-     XEvent *xevent;
-     GtkForm *form;
- 
-     xevent = (XEvent *) gdk_xevent;
-     form = GTK_FORM(data);
- 
-     switch (xevent->type)
-     {
-     case Expose:
- 	if (xevent->xexpose.serial == form->configure_serial)
- 	{
- 	    if (form->visibility == GDK_VISIBILITY_UNOBSCURED)
- 		return GDK_FILTER_REMOVE;
- 	    else
- 		break;
- 	}
- 	break;
- 
-     case ConfigureNotify:
- 	if ((xevent->xconfigure.x != 0) || (xevent->xconfigure.y != 0))
- 	    form->configure_serial = xevent->xconfigure.serial;
- 	break;
-     }
- 
-     return GDK_FILTER_CONTINUE;
- }
- 
- /* Although GDK does have a GDK_VISIBILITY_NOTIFY event,
-  * there is no corresponding event in GTK, so we have
-  * to get the events from a filter
-  */
-     static GdkFilterReturn
- gtk_form_main_filter(GdkXEvent *gdk_xevent,
- 		     GdkEvent *event UNUSED,
- 		     gpointer data)
- {
-     XEvent *xevent;
-     GtkForm *form;
- 
-     xevent = (XEvent *) gdk_xevent;
-     form = GTK_FORM(data);
- 
-     if (xevent->type == VisibilityNotify)
-     {
- 	switch (xevent->xvisibility.state)
- 	{
- 	case VisibilityFullyObscured:
- 	    form->visibility = GDK_VISIBILITY_FULLY_OBSCURED;
- 	    break;
- 
- 	case VisibilityPartiallyObscured:
- 	    form->visibility = GDK_VISIBILITY_PARTIAL;
- 	    break;
- 
- 	case VisibilityUnobscured:
- 	    form->visibility = GDK_VISIBILITY_UNOBSCURED;
- 	    break;
- 	}
- 
- 	return GDK_FILTER_REMOVE;
-     }
-     return GDK_FILTER_CONTINUE;
- }
- #endif /* !GTK_CHECK_VERSION(3,0,0) */
- 
  #if !GTK_CHECK_VERSION(3,16,0)
      static void
  gtk_form_set_static_gravity(GdkWindow *window, gboolean use_static)
--- 999,1004 ----
*** ../vim-8.0.0520/src/gui_gtk_f.h	2016-08-29 22:42:20.000000000 +0200
--- src/gui_gtk_f.h	2017-03-29 17:34:14.302763381 +0200
***************
*** 43,61 ****
      GtkContainer container;
  
      GList *children;
- 
- #ifndef USE_GTK3
-     guint width;
-     guint height;
- #endif
- 
      GdkWindow *bin_window;
- 
- #ifndef USE_GTK3
-     GdkVisibilityState visibility;
-     gulong configure_serial;
- #endif
- 
      gint freeze_count;
  };
  
--- 43,49 ----
*** ../vim-8.0.0520/src/version.c	2017-03-29 17:30:23.168136866 +0200
--- src/version.c	2017-03-29 17:34:00.734844036 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     521,
  /**/

-- 
The term "free software" is defined by Richard M. Stallman as
being software that isn't necessarily for free.  Confusing?
Let's call it "Stallman software" then!
				-- Bram Moolenaar

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0522
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0522
Problem:    MS-Windows: when 'clipboard' is "unnamed" yyp does not work in a
            :global command.
Solution:   When setting the clipboard was postponed, do not clear the
            register.
Files:      src/ops.c, src/proto/ui.pro, src/ui.c, src/globals.h,
            src/testdir/test_global.vim, src/Makefile,
            src/testdir/test_alot.vim


*** ../vim-8.0.0521/src/ops.c	2017-03-16 17:23:26.831815811 +0100
--- src/ops.c	2017-03-29 18:53:04.746712871 +0200
***************
*** 6466,6472 ****
  	VIsual = old_visual;
  	VIsual_mode = old_visual_mode;
      }
!     else
      {
  	clip_free_selection(cbd);
  
--- 6466,6472 ----
  	VIsual = old_visual;
  	VIsual_mode = old_visual_mode;
      }
!     else if (!is_clipboard_needs_update())
      {
  	clip_free_selection(cbd);
  
*** ../vim-8.0.0521/src/proto/ui.pro	2016-09-29 15:18:51.351768068 +0200
--- src/proto/ui.pro	2017-03-29 18:55:31.281844107 +0200
***************
*** 16,21 ****
--- 16,22 ----
  void clip_own_selection(VimClipboard *cbd);
  void clip_lose_selection(VimClipboard *cbd);
  void start_global_changes(void);
+ int is_clipboard_needs_update(void);
  void end_global_changes(void);
  void clip_auto_select(void);
  int clip_isautosel_star(void);
*** ../vim-8.0.0521/src/ui.c	2017-03-16 17:23:26.839815753 +0100
--- src/ui.c	2017-03-29 19:05:52.598168213 +0200
***************
*** 392,399 ****
  
  #if defined(FEAT_CLIPBOARD) || defined(PROTO)
  
- static void clip_copy_selection(VimClipboard *clip);
- 
  /*
   * Selection stuff using Visual mode, for cutting and pasting text to other
   * windows.
--- 392,397 ----
***************
*** 569,575 ****
   * considerably.
   */
  static int global_change_count = 0; /* if set, inside a start_global_changes */
! static int clipboard_needs_update; /* clipboard needs to be updated */
  
  /*
   * Save clip_unnamed and reset it.
--- 567,574 ----
   * considerably.
   */
  static int global_change_count = 0; /* if set, inside a start_global_changes */
! static int clipboard_needs_update = FALSE; /* clipboard needs to be updated */
! static int clip_did_set_selection = TRUE;
  
  /*
   * Save clip_unnamed and reset it.
***************
*** 590,595 ****
--- 589,604 ----
  }
  
  /*
+  * Return TRUE if setting the clipboard was postponed, it already contains the
+  * right text.
+  */
+     int
+ is_clipboard_needs_update()
+ {
+     return clipboard_needs_update;
+ }
+ 
+ /*
   * Restore clip_unnamed and set the selection when needed.
   */
      void
***************
*** 619,624 ****
--- 628,634 ----
  	    }
  	}
      }
+     clipboard_needs_update = FALSE;
  }
  
  /*
*** ../vim-8.0.0521/src/globals.h	2017-03-29 13:08:31.007872313 +0200
--- src/globals.h	2017-03-29 19:04:10.566771762 +0200
***************
*** 532,538 ****
  EXTERN int	clip_autoselectml INIT(= FALSE);
  EXTERN int	clip_html INIT(= FALSE);
  EXTERN regprog_T *clip_exclude_prog INIT(= NULL);
- EXTERN int	clip_did_set_selection INIT(= TRUE);
  EXTERN int	clip_unnamed_saved INIT(= 0);
  #endif
  
--- 532,537 ----
*** ../vim-8.0.0521/src/testdir/test_global.vim	2017-03-29 19:19:38.709289673 +0200
--- src/testdir/test_global.vim	2017-03-29 19:16:24.682430659 +0200
***************
*** 0 ****
--- 1,11 ----
+ 
+ func Test_yank_put_clipboard()
+   new
+   call setline(1, ['a', 'b', 'c'])
+   set clipboard=unnamed
+   g/^/normal yyp
+   call assert_equal(['a', 'a', 'b', 'b', 'c', 'c'], getline(1, 6))
+ 
+   set clipboard&
+   bwipe!
+ endfunc
*** ../vim-8.0.0521/src/Makefile	2017-03-25 14:50:37.921991987 +0100
--- src/Makefile	2017-03-29 19:16:50.302280042 +0200
***************
*** 2145,2150 ****
--- 2144,2150 ----
  	test_ga \
  	test_gf \
  	test_glob2regpat \
+ 	test_global \
  	test_gn \
  	test_goto \
  	test_gui \
*** ../vim-8.0.0521/src/testdir/test_alot.vim	2017-03-21 17:08:46.678923883 +0100
--- src/testdir/test_alot.vim	2017-03-29 19:17:05.730189337 +0200
***************
*** 21,28 ****
  source test_float_func.vim
  source test_fnamemodify.vim
  source test_functions.vim
- source test_glob2regpat.vim
  source test_ga.vim
  source test_goto.vim
  source test_help_tagjump.vim
  source test_join.vim
--- 21,29 ----
  source test_float_func.vim
  source test_fnamemodify.vim
  source test_functions.vim
  source test_ga.vim
+ source test_glob2regpat.vim
+ source test_global.vim
  source test_goto.vim
  source test_help_tagjump.vim
  source test_join.vim
*** ../vim-8.0.0521/src/version.c	2017-03-29 18:07:36.574886122 +0200
--- src/version.c	2017-03-29 19:19:22.681383955 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     522,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
233. You start dreaming about web pages...in html.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0523
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0523
Problem:    dv} deletes part of a multi-byte character. (Urtica Dioica)
Solution:   Include the whole character.
Files:      src/search.c, src/testdir/test_normal.vim


*** ../vim-8.0.0522/src/search.c	2017-03-16 17:23:26.835815782 +0100
--- src/search.c	2017-03-29 19:39:23.666307037 +0200
***************
*** 2851,2859 ****
      curwin->w_cursor.lnum = curr;
      if (curr == curbuf->b_ml.ml_line_count && what != '}')
      {
! 	if ((curwin->w_cursor.col = (colnr_T)STRLEN(ml_get(curr))) != 0)
  	{
  	    --curwin->w_cursor.col;
  	    *pincl = TRUE;
  	}
      }
--- 2851,2867 ----
      curwin->w_cursor.lnum = curr;
      if (curr == curbuf->b_ml.ml_line_count && what != '}')
      {
! 	char_u *line = ml_get(curr);
! 
! 	/* Put the cursor on the last character in the last line and make the
! 	 * motion inclusive. */
! 	if ((curwin->w_cursor.col = (colnr_T)STRLEN(line)) != 0)
  	{
  	    --curwin->w_cursor.col;
+ #ifdef FEAT_MBYTE
+ 	    curwin->w_cursor.col -=
+ 			     (*mb_head_off)(line, line + curwin->w_cursor.col);
+ #endif
  	    *pincl = TRUE;
  	}
      }
*** ../vim-8.0.0522/src/testdir/test_normal.vim	2017-03-29 13:08:31.011872289 +0200
--- src/testdir/test_normal.vim	2017-03-29 19:42:18.841272925 +0200
***************
*** 2290,2292 ****
--- 2290,2304 ----
    normal 6666666666dL
    bwipe!
  endfunc
+ 
+ func Test_delete_until_paragraph()
+   if !has('multi_byte')
+     return
+   endif
+   new
+   normal grdv}
+   call assert_equal('', getline(1))
+   normal grd}
+   call assert_equal('', getline(1))
+   bwipe!
+ endfunc
*** ../vim-8.0.0522/src/version.c	2017-03-29 19:20:25.389015062 +0200
--- src/version.c	2017-03-29 19:31:00.925272375 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     523,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
234. You started college as a chemistry major, and walk out four years
     later as an Internet provider.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0524
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0524 (after 8.0.0518)
Problem:    Folds are messed up when 'encodin' is "utf-8".
Solution:   Also set the fold character when it's not multi-byte.
Files:      src/screen.c, src/testdir/test_display.vim


*** ../vim-8.0.0523/src/screen.c	2017-03-29 17:30:23.168136866 +0200
--- src/screen.c	2017-03-29 20:37:12.349673955 +0200
***************
*** 2700,2706 ****
--- 2700,2709 ----
                  ScreenLines[off + col] = 0x80; /* avoid storing zero */
  	    }
  	    else
+ 	    {
  		ScreenLinesUC[off + col] = 0;
+ 		ScreenLines[off + col] = fill_fold;
+ 	    }
  	    col++;
  	}
  	else
*** ../vim-8.0.0523/src/testdir/test_display.vim	2017-03-29 14:40:38.342357669 +0200
--- src/testdir/test_display.vim	2017-03-29 20:35:30.006287985 +0200
***************
*** 54,59 ****
--- 54,69 ----
          \ "  14                                    \u2502",
          \ ]
    call assert_equal(expect, lines)
+ 
+   set fillchars=fold:-,vert:\|
+   let lines=ScreenLines([1,3], winwidth(0)+1)
+   let expect=[
+         \ "  1                                     |",
+         \ "+ +-- 12 lines: 2". repeat("-", 23). "|",
+         \ "  14                                    |",
+         \ ]
+   call assert_equal(expect, lines)
+ 
    set foldtext& fillchars& foldmethod& fdc&
    bw!
  endfunc
*** ../vim-8.0.0523/src/version.c	2017-03-29 19:48:07.499210857 +0200
--- src/version.c	2017-03-29 20:38:40.809143273 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     524,
  /**/

-- 
You are Dead.  Do you wish to restart, load, or quit?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0525
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0525
Solution:   Completion for user command argument not tested.
Problem:    Add a test.
Files:      src/testdir/test_cmdline.vim


*** ../vim-8.0.0524/src/testdir/test_cmdline.vim	2017-03-26 13:50:02.536929400 +0200
--- src/testdir/test_cmdline.vim	2017-03-29 21:20:48.757909722 +0200
***************
*** 348,353 ****
--- 348,362 ----
    bw!
  endfunc
  
+ func Test_cmdline_complete_user_cmd()
+   command! -complete=color -nargs=1 Foo :
+   call feedkeys(":Foo \<Tab>\<Home>\"\<cr>", 'tx')
+   call assert_equal('"Foo blue', @:)
+   call feedkeys(":Foo b\<Tab>\<Home>\"\<cr>", 'tx')
+   call assert_equal('"Foo blue', @:)
+   delcommand Foo
+ endfunc
+ 
  " using a leading backslash here
  set cpo+=C
  
*** ../vim-8.0.0524/src/version.c	2017-03-29 20:38:53.309068287 +0200
--- src/version.c	2017-03-29 21:26:09.543973934 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     525,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
236. You start saving URL's in your digital watch.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0526
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0526
Problem:    Coverity complains about possible negative value.
Solution:   Check return value of ftell() not to be negative.
Files:      src/os_unix.c


*** ../vim-8.0.0525/src/os_unix.c	2017-03-25 20:16:23.652639953 +0100
--- src/os_unix.c	2017-03-30 21:15:31.604133703 +0200
***************
*** 6006,6011 ****
--- 6006,6012 ----
  {
      int		i;
      size_t	len;
+     long	llen;
      char_u	*p;
      int		dir;
  
***************
*** 6292,6300 ****
  	goto notfound;
      }
      fseek(fd, 0L, SEEK_END);
!     len = ftell(fd);			/* get size of temp file */
      fseek(fd, 0L, SEEK_SET);
!     buffer = alloc(len + 1);
      if (buffer == NULL)
      {
  	/* out of memory */
--- 6293,6305 ----
  	goto notfound;
      }
      fseek(fd, 0L, SEEK_END);
!     llen = ftell(fd);			/* get size of temp file */
      fseek(fd, 0L, SEEK_SET);
!     if (llen < 0)
! 	/* just in case ftell() would fail */
! 	buffer = NULL;
!     else
! 	buffer = alloc(llen + 1);
      if (buffer == NULL)
      {
  	/* out of memory */
***************
*** 6303,6308 ****
--- 6308,6314 ----
  	fclose(fd);
  	return FAIL;
      }
+     len = llen;
      i = fread((char *)buffer, 1, len, fd);
      fclose(fd);
      mch_remove(tempname);
*** ../vim-8.0.0525/src/version.c	2017-03-29 21:26:57.347685534 +0200
--- src/version.c	2017-03-30 21:12:17.449330352 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     526,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
237. You tattoo your email address on your forehead.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0527
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0527
Problem:    RISC OS support was removed long ago, but one file is still
            included.
Solution:   Delete the file. (Thomas Dziedzic, closes #1603)
Files:      Filelist, src/swis.s


*** ../vim-8.0.0526/Filelist	2017-03-25 14:50:37.925991956 +0100
--- Filelist	2017-03-30 21:49:09.339688921 +0200
***************
*** 725,731 ****
  		farsi/README.txt \
  		farsi/fonts/*/far-* \
  		runtime/vimlogo.xpm \
- 		src/swis.s \
  		src/tee/Makefile \
  		src/tee/Make_mvc.mak \
  		src/tee/tee.c \
--- 725,730 ----
*** ../vim-8.0.0526/src/swis.s	2010-05-15 13:04:07.000000000 +0200
--- src/swis.s	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,143 ****
- ; Thomas Leonard
- ; 24/5/98
- 
- ar0	rn	0
- ar1	rn	1
- ar2	rn	2
- ar3	rn	3
- ar4	rn	4
- ar5	rn	5
- ar6	rn	6
- ar7	rn	7
- ar10	rn	10
- ar11	rn	11
- lk	rn	14
- ar15	rn	15
- 
- 	AREA	DATA
- 	align	4
- 
- 	export	|r0|
- r0:	dcd	0
- 
- 	export	|r1|
- r1:	dcd	0
- 
- 	export	|r2|
- r2:	dcd	0
- 
- 	export	|r3|
- r3:	dcd	0
- 
- 	export	|r4|
- r4:	dcd	0
- 
- 	export	|r5|
- r5:	dcd	0
- 
- 	export	|r6|
- r6:	dcd	0
- 
- 	export	|r7|
- r7:	dcd	0
- 
- 	export	|time_of_last_poll|
- time_of_last_poll:  dcd	0
- 
- 	AREA	CODE, READONLY
- 	align 4
- 	import	|r0|
- 	export	|swi|
- 	=	"swi"
- 	align 4
- swi:
- 	; r0 = swi number
- 	stmfd	sp!,{ar4-ar10,lk}
- 	orr	ar10,ar0,#1<<17		;always use the X form
- 	mov	ar0,ar1
- 	mov	ar1,ar2
- 	mov	ar2,ar3
- 	add	ar3,sp,#4*8
- 	ldmia	ar3,{ar3-ar7}
- 	swi	0x6f		; OS_CallASWI
- 	ldr	ar10,regs_addr
- 	stmia	ar10,{ar0-ar7}
- 	ldmvcfd	sp!,{ar4-ar10,pc}^
- 	; report the error and quit on Cancel
- 	mov	r1,#0x17
- 	adr	r2,s_title
- 	swi	0x400df		; Wimp_ReportError
- 	cmp	r1,#1			;OK selected?
- 	ldmeqfd	sp!,{ar4-ar10,pc}^	;yes - try to continue
- 	swi	0x11			;no  - die (OS_Exit)
- s_title:
- 	= "Nasty error - Cancel to quit"
- 	= 0
- 
- 	align 4
- 	export	|xswi|
- 	=	"xswi"
- 	align 4
- xswi:
- 	; r0 = swi number
- 	stmfd	sp!,{ar4-ar10,lk}
- 	orr	ar10,ar0,#1<<17		;always use the X form
- 	mov	ar0,ar1
- 	mov	ar1,ar2
- 	mov	ar2,ar3
- 	add	ar3,sp,#4*8
- 	ldmia	ar3,{ar3-ar7}
- 	swi	0x6f		; OS_CallASWI
- 	ldr	ar10,regs_addr
- 	stmia	ar10,{ar0-ar7}
- 	mov	ar0,#0
- 	orr	ar0,ar0,ar15
- 	ldmfd	sp!,{ar4-ar10,pc}^
- 
- regs_addr:
- 	dcd	r0
- 
- 	; The Wimp_Poll swis have to be done specially because,
- 	; for some reason, r13 sometimes gets corrupted by Wimp_Poll
- 	; (eg when running FileFind)
- 	AREA	CODE, READONLY
- 	align 4
- 	import  |time_of_last_poll|
- 	export	|wimp_poll|
- 	=	"wimp_poll"
- 	align 4
- wimp_poll:
- 	mov	ar3,sp
- 	swi	0x400c7		; Wimp_Poll
- 	mov	sp,ar3
- 
- 	mov	ar3,ar0
- 	swi	0x42		; OS_ReadMonotonicTime
- 	ldr	ar2,addr_time
- 	str	ar0,[ar2]
- 	mov	ar0,ar3
- 
- 	mov	ar2,#0
- 	wfs	ar2		; Write floating point status. Needed?
- 	movs	pc,lk
- 
- 	align 4
- 	export	|wimp_pollidle|
- 	=	"wimp_pollidle"
- 	align 4
- wimp_pollidle:
- 	mov	ar3,sp
- 	swi	0x400e1		; Wimp_PollIdle
- 	mov	sp,ar3
- 
- 	mov	ar3,ar0
- 	swi	0x42		; OS_ReadMonotonicTime
- 	ldr	ar2,addr_time
- 	str	ar0,[ar2]
- 	mov	ar0,ar3
- 
- 	mov	ar2,#0
- 	wfs	ar2		; Write floating point status. Needed?
- 	movs	pc,lk
- 
- addr_time: dcd	time_of_last_poll
--- 0 ----
*** ../vim-8.0.0526/src/version.c	2017-03-30 21:18:40.818968442 +0200
--- src/version.c	2017-03-30 21:48:58.883753498 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     527,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
239. You think "surfing" is something you do on dry land.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0528
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0528
Problem:    When 'wildmenu' is set and 'wildmode' has "longest" then the first
            file name is highlighted, even though the text shows the longest
            match.
Solution:   Do not highlight the first match. (LemonBoy, closes #1602)
Files:      src/ex_getln.c


*** ../vim-8.0.0527/src/ex_getln.c	2017-03-16 19:58:19.416253412 +0100
--- src/ex_getln.c	2017-03-30 21:55:49.829217726 +0200
***************
*** 4147,4153 ****
  	got_int = FALSE;	/* only int. the completion, not the cmd line */
  #ifdef FEAT_WILDMENU
      else if (wildmenu)
! 	win_redr_status_matches(xp, num_files, files_found, 0, showtail);
  #endif
      else
      {
--- 4147,4153 ----
  	got_int = FALSE;	/* only int. the completion, not the cmd line */
  #ifdef FEAT_WILDMENU
      else if (wildmenu)
! 	win_redr_status_matches(xp, num_files, files_found, -1, showtail);
  #endif
      else
      {
*** ../vim-8.0.0527/src/version.c	2017-03-30 21:51:18.846889322 +0200
--- src/version.c	2017-03-30 22:04:17.166090807 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     528,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
240. You think Webster's Dictionary is a directory of WEB sites.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0529
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0529
Problem:    Line in test commented out.
Solution:   Uncomment the lines for character classes that were failing before
            8.0.0519. (Dominique Pelle, closes #1599)
Files:      src/testdir/test_regexp_utf8.vim


*** ../vim-8.0.0528/src/testdir/test_regexp_utf8.vim	2017-03-29 15:31:15.031397364 +0200
--- src/testdir/test_regexp_utf8.vim	2017-03-30 22:17:28.833221591 +0200
***************
*** 112,123 ****
    call assert_equal('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', alnumchars)
    call assert_equal("\b", backspacechar)
    call assert_equal("\t ", blankchars)
!   " Commented out: it succeeds on Linux and Windows, but fails on macOs in Travis.
!   " call assert_equal("\x01\x02\x03\x04\x05\x06\x07\b\t\n\x0b\f\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\e\x1c\x1d\x1e\x1f\x7f", cntrlchars)
    call assert_equal("0123456789", digitchars)
    call assert_equal("\<Esc>", escapechar)
!   " Commented out: it succeeds on Linux and Windows, but fails on macOs in Travis.
!   " call assert_equal('!"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~', graphchars)
    call assert_equal('abcdefghijklmnopqrstuvwxyz', lowerchars)
    call assert_equal(' !"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~', printchars)
    call assert_equal('!"#$%&''()*+,-./:;<=>?@[\]^_`{|}~', punctchars)
--- 112,121 ----
    call assert_equal('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', alnumchars)
    call assert_equal("\b", backspacechar)
    call assert_equal("\t ", blankchars)
!   call assert_equal("\x01\x02\x03\x04\x05\x06\x07\b\t\n\x0b\f\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\e\x1c\x1d\x1e\x1f\x7f", cntrlchars)
    call assert_equal("0123456789", digitchars)
    call assert_equal("\<Esc>", escapechar)
!   call assert_equal('!"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~', graphchars)
    call assert_equal('abcdefghijklmnopqrstuvwxyz', lowerchars)
    call assert_equal(' !"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~', printchars)
    call assert_equal('!"#$%&''()*+,-./:;<=>?@[\]^_`{|}~', punctchars)
*** ../vim-8.0.0528/src/version.c	2017-03-30 22:04:50.889883100 +0200
--- src/version.c	2017-03-30 22:19:27.460493104 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     529,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
242. You turn down a better-paying job because it doesn't come with
     a free e-mail account.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0530
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0530
Problem:    Buffer overflow when 'columns' is very big. (Nikolai Pavlov)
Solution:   Correctly compute where to truncate.  Fix translation.
            (closes #1600)
Files:      src/edit.c, src/testdir/test_edit.vim


*** ../vim-8.0.0529/src/edit.c	2017-03-16 17:23:26.815815927 +0100
--- src/edit.c	2017-03-31 22:12:34.266631500 +0200
***************
*** 4756,4762 ****
      int	    in_compl_func)	/* called from complete_check() */
  {
      int	    num_matches = -1;
-     int	    i;
      int	    todo = count;
      compl_T *found_compl = NULL;
      int	    found_end = FALSE;
--- 4756,4761 ----
***************
*** 4948,4962 ****
       */
      if (compl_shown_match->cp_fname != NULL)
      {
! 	STRCPY(IObuff, "match in file ");
! 	i = (vim_strsize(compl_shown_match->cp_fname) + 16) - sc_col;
! 	if (i <= 0)
! 	    i = 0;
! 	else
! 	    STRCAT(IObuff, "<");
! 	STRCAT(IObuff, compl_shown_match->cp_fname + i);
! 	msg(IObuff);
! 	redraw_cmdline = FALSE;	    /* don't overwrite! */
      }
  
      return num_matches;
--- 4947,4976 ----
       */
      if (compl_shown_match->cp_fname != NULL)
      {
! 	char	*lead = _("match in file");
! 	int	space = sc_col - vim_strsize((char_u *)lead) - 2;
! 	char_u	*s;
! 	char_u	*e;
! 
! 	if (space > 0)
! 	{
! 	    /* We need the tail that fits.  With double-byte encoding going
! 	     * back from the end is very slow, thus go from the start and keep
! 	     * the text that fits in "space" between "s" and "e". */
! 	    for (s = e = compl_shown_match->cp_fname; *e != NUL; MB_PTR_ADV(e))
! 	    {
! 		space -= ptr2cells(e);
! 		while (space < 0)
! 		{
! 		    space += ptr2cells(s);
! 		    MB_PTR_ADV(s);
! 		}
! 	    }
! 	    vim_snprintf((char *)IObuff, IOSIZE, "%s %s%s", lead,
! 				s > compl_shown_match->cp_fname ? "<" : "", s);
! 	    msg(IObuff);
! 	    redraw_cmdline = FALSE;	    /* don't overwrite! */
! 	}
      }
  
      return num_matches;
*** ../vim-8.0.0529/src/testdir/test_edit.vim	2017-03-16 22:37:55.991201882 +0100
--- src/testdir/test_edit.vim	2017-03-31 21:47:14.695936301 +0200
***************
*** 1322,1324 ****
--- 1322,1345 ----
    set norightleft
    bw!
  endfunc
+ 
+ func Test_edit_complete_very_long_name()
+   let save_columns = &columns
+   set columns=5000
+   call assert_equal(5000, &columns)
+   set noswapfile
+   let dirname = getcwd() . "/Xdir"
+   let longdirname = dirname . repeat('/' . repeat('d', 255), 4)
+   let longfilename = longdirname . '/' . repeat('a', 255)
+   call mkdir(longdirname, 'p')
+   call writefile(['Totum', 'Table'], longfilename)
+   new
+   exe "next Xfile " . longfilename
+   exe "normal iT\<C-N>"
+ 
+   bwipe!
+   exe 'bwipe! ' . longfilename
+   call delete(dirname, 'rf')
+   let &columns = save_columns
+   set swapfile&
+ endfunc
*** ../vim-8.0.0529/src/version.c	2017-03-30 22:20:23.416149582 +0200
--- src/version.c	2017-03-31 21:49:08.119240837 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     530,
  /**/

-- 
"Marriage is when a man and woman become as one; the trouble starts
when they try to decide which one"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0531
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0531 (after 8.0.0530)
Problem:    Test with long directory name fails on non-unix systems.
Solution:   Skip the test on non-unix systems.
Files:      src/testdir/test_edit.vim


*** ../vim-8.0.0530/src/testdir/test_edit.vim	2017-03-31 22:27:08.617328400 +0200
--- src/testdir/test_edit.vim	2017-03-31 23:29:29.722486313 +0200
***************
*** 1324,1329 ****
--- 1324,1333 ----
  endfunc
  
  func Test_edit_complete_very_long_name()
+   if !has('unix')
+     " Long directory names only work on Unix.
+     return
+   endif
    let save_columns = &columns
    set columns=5000
    call assert_equal(5000, &columns)
*** ../vim-8.0.0530/src/version.c	2017-03-31 22:27:08.621328374 +0200
--- src/version.c	2017-03-31 23:32:01.033557892 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     531,
  /**/

-- 
"Marriage is the process of finding out what kind of man your wife
would have preferred"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0532
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0532 (after 8.0.0531)
Problem:    Test with long directory name fails on Mac.
Solution:   Skip the test on Mac systems.
Files:      src/testdir/test_edit.vim


*** ../vim-8.0.0531/src/testdir/test_edit.vim	2017-03-31 23:32:49.165262632 +0200
--- src/testdir/test_edit.vim	2017-04-01 14:11:04.907453141 +0200
***************
*** 1324,1330 ****
  endfunc
  
  func Test_edit_complete_very_long_name()
!   if !has('unix')
      " Long directory names only work on Unix.
      return
    endif
--- 1324,1330 ----
  endfunc
  
  func Test_edit_complete_very_long_name()
!   if !has('unix') || has('mac')
      " Long directory names only work on Unix.
      return
    endif
*** ../vim-8.0.0531/src/version.c	2017-03-31 23:32:49.165262632 +0200
--- src/version.c	2017-04-01 14:11:50.023183137 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     532,
  /**/

-- 
If you're sending someone Styrofoam, what do you pack it in?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0533
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0533
Problem:    Abbreviation doesn't work after backspacing newline. (Hkonrk)
Solution:   Set the insert start column. (closes #1609)
Files:      src/testdir/test_mapping.vim, src/edit.c


*** ../vim-8.0.0532/src/testdir/test_mapping.vim	2017-02-01 17:24:29.681328124 +0100
--- src/testdir/test_mapping.vim	2017-04-01 15:08:20.374827197 +0200
***************
*** 160,162 ****
--- 160,173 ----
    set nomodified
    iunmap <M-">
  endfunc
+ 
+ func Test_abbr_after_line_join()
+   new
+   abbr foo bar
+   set backspace=indent,eol,start
+   exe "normal o\<BS>foo "
+   call assert_equal("bar ", getline(1))
+   bwipe!
+   unabbr foo
+   set backspace&
+ endfunc
*** ../vim-8.0.0532/src/edit.c	2017-03-31 22:27:08.617328400 +0200
--- src/edit.c	2017-04-01 15:10:49.921912543 +0200
***************
*** 9017,9023 ****
  #endif
  
      /*
!      * delete newline!
       */
      if (curwin->w_cursor.col == 0)
      {
--- 9017,9023 ----
  #endif
  
      /*
!      * Delete newline!
       */
      if (curwin->w_cursor.col == 0)
      {
***************
*** 9032,9038 ****
  			       (linenr_T)(curwin->w_cursor.lnum + 1)) == FAIL)
  		return FALSE;
  	    --Insstart.lnum;
! 	    Insstart.col = MAXCOL;
  	}
  	/*
  	 * In replace mode:
--- 9032,9038 ----
  			       (linenr_T)(curwin->w_cursor.lnum + 1)) == FAIL)
  		return FALSE;
  	    --Insstart.lnum;
! 	    Insstart.col = STRLEN(ml_get(Insstart.lnum));
  	}
  	/*
  	 * In replace mode:
*** ../vim-8.0.0532/src/version.c	2017-04-01 14:13:11.866693326 +0200
--- src/version.c	2017-04-01 15:09:31.454392379 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     533,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
245. You use Real Audio to listen to a radio station from a distant
     city rather than turn on your stereo system.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0534
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0534
Problem:    Defaults.vim does not work well with tiny features. (crd477)
Solution:   When the +eval feature is not available always reset 'compatible'.
Files:      runtime/defaults.vim


*** ../vim-8.0.0533/runtime/defaults.vim	2017-03-16 14:19:30.816329916 +0100
--- runtime/defaults.vim	2017-04-01 16:53:03.308489914 +0200
***************
*** 1,7 ****
  " The default vimrc file.
  "
  " Maintainer:	Bram Moolenaar <Bram@vim.org>
! " Last change:	2017 Mar 08
  "
  " This is loaded if no vimrc file was found.
  " Except when Vim is run with "-u NONE" or "-C".
--- 1,7 ----
  " The default vimrc file.
  "
  " Maintainer:	Bram Moolenaar <Bram@vim.org>
! " Last change:	2017 Apr 01
  "
  " This is loaded if no vimrc file was found.
  " Except when Vim is run with "-u NONE" or "-C".
***************
*** 26,31 ****
--- 26,41 ----
    set nocompatible
  endif
  
+ " When the +eval feature is missing, the set command above will be skipped.
+ " Use a trick to reset compatible only when the +eval feature is missing.
+ if 1
+   nnoremap : :"
+ endif
+ silent normal :set nocompatible
+ if 1
+   nunmap :
+ endif
+ 
  " Allow backspacing over everything in insert mode.
  set backspace=indent,eol,start
  
*** ../vim-8.0.0533/src/version.c	2017-04-01 15:15:48.288089636 +0200
--- src/version.c	2017-04-01 16:53:40.100266459 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     534,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
246. You use up your free 1 Gbyte in two days.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0535
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0535
Problem:    Memory leak when exiting from within a user function.
Solution:   Clear the function call stack on exit.
Files:      src/userfunc.c


*** ../vim-8.0.0534/src/userfunc.c	2017-03-16 17:23:26.839815753 +0100
--- src/userfunc.c	2017-04-01 21:01:57.537818637 +0200
***************
*** 41,47 ****
  /* pointer to funccal for currently active function */
  funccall_T *current_funccal = NULL;
  
! /* pointer to list of previously used funccal, still around because some
   * item in it is still being used. */
  funccall_T *previous_funccal = NULL;
  
--- 41,47 ----
  /* pointer to funccal for currently active function */
  funccall_T *current_funccal = NULL;
  
! /* Pointer to list of previously used funccal, still around because some
   * item in it is still being used. */
  funccall_T *previous_funccal = NULL;
  
***************
*** 628,633 ****
--- 628,682 ----
  }
  
  /*
+  * Handle the last part of returning from a function: free the local hashtable.
+  * Unless it is still in use by a closure.
+  */
+     static void
+ cleanup_function_call(funccall_T *fc)
+ {
+     current_funccal = fc->caller;
+ 
+     /* If the a:000 list and the l: and a: dicts are not referenced and there
+      * is no closure using it, we can free the funccall_T and what's in it. */
+     if (fc->l_varlist.lv_refcount == DO_NOT_FREE_CNT
+ 	    && fc->l_vars.dv_refcount == DO_NOT_FREE_CNT
+ 	    && fc->l_avars.dv_refcount == DO_NOT_FREE_CNT
+ 	    && fc->fc_refcount <= 0)
+     {
+ 	free_funccal(fc, FALSE);
+     }
+     else
+     {
+ 	hashitem_T	*hi;
+ 	listitem_T	*li;
+ 	int		todo;
+ 	dictitem_T	*v;
+ 
+ 	/* "fc" is still in use.  This can happen when returning "a:000",
+ 	 * assigning "l:" to a global variable or defining a closure.
+ 	 * Link "fc" in the list for garbage collection later. */
+ 	fc->caller = previous_funccal;
+ 	previous_funccal = fc;
+ 
+ 	/* Make a copy of the a: variables, since we didn't do that above. */
+ 	todo = (int)fc->l_avars.dv_hashtab.ht_used;
+ 	for (hi = fc->l_avars.dv_hashtab.ht_array; todo > 0; ++hi)
+ 	{
+ 	    if (!HASHITEM_EMPTY(hi))
+ 	    {
+ 		--todo;
+ 		v = HI2DI(hi);
+ 		copy_tv(&v->di_tv, &v->di_tv);
+ 	    }
+ 	}
+ 
+ 	/* Make a copy of the a:000 items, since we didn't do that above. */
+ 	for (li = fc->l_varlist.lv_first; li != NULL; li = li->li_next)
+ 	    copy_tv(&li->li_tv, &li->li_tv);
+     }
+ }
+ 
+ /*
   * Call a user function.
   */
      static void
***************
*** 982,1027 ****
      }
  
      did_emsg |= save_did_emsg;
-     current_funccal = fc->caller;
      --depth;
  
!     /* If the a:000 list and the l: and a: dicts are not referenced and there
!      * is no closure using it, we can free the funccall_T and what's in it. */
!     if (fc->l_varlist.lv_refcount == DO_NOT_FREE_CNT
! 	    && fc->l_vars.dv_refcount == DO_NOT_FREE_CNT
! 	    && fc->l_avars.dv_refcount == DO_NOT_FREE_CNT
! 	    && fc->fc_refcount <= 0)
!     {
! 	free_funccal(fc, FALSE);
!     }
!     else
!     {
! 	hashitem_T	*hi;
! 	listitem_T	*li;
! 	int		todo;
! 
! 	/* "fc" is still in use.  This can happen when returning "a:000",
! 	 * assigning "l:" to a global variable or defining a closure.
! 	 * Link "fc" in the list for garbage collection later. */
! 	fc->caller = previous_funccal;
! 	previous_funccal = fc;
! 
! 	/* Make a copy of the a: variables, since we didn't do that above. */
! 	todo = (int)fc->l_avars.dv_hashtab.ht_used;
! 	for (hi = fc->l_avars.dv_hashtab.ht_array; todo > 0; ++hi)
! 	{
! 	    if (!HASHITEM_EMPTY(hi))
! 	    {
! 		--todo;
! 		v = HI2DI(hi);
! 		copy_tv(&v->di_tv, &v->di_tv);
! 	    }
! 	}
! 
! 	/* Make a copy of the a:000 items, since we didn't do that above. */
! 	for (li = fc->l_varlist.lv_first; li != NULL; li = li->li_next)
! 	    copy_tv(&li->li_tv, &li->li_tv);
!     }
  }
  
  /*
--- 1031,1039 ----
      }
  
      did_emsg |= save_did_emsg;
      --depth;
  
!     cleanup_function_call(fc);
  }
  
  /*
***************
*** 1147,1152 ****
--- 1159,1171 ----
      long_u	todo = 1;
      long_u	used;
  
+     /* Clean up the call stack. */
+     while (current_funccal != NULL)
+     {
+ 	clear_tv(current_funccal->rettv);
+ 	cleanup_function_call(current_funccal);
+     }
+ 
      /* First clear what the functions contain.  Since this may lower the
       * reference count of a function, it may also free a function and change
       * the hash table. Restart if that happens. */
*** ../vim-8.0.0534/src/version.c	2017-04-01 16:59:25.194170493 +0200
--- src/version.c	2017-04-01 21:03:28.225268344 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     535,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
250. You've given up the search for the "perfect woman" and instead,
     sit in front of the PC until you're just too tired to care.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0536
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0536
Problem:    Quickfix window not updated when freeing quickfix stack.
Solution:   Update the quickfix window. (Yegappan Lakshmanan)
Files:      src/quickfix.c, src/testdir/test_quickfix.vim


*** ../vim-8.0.0535/src/quickfix.c	2017-03-29 14:19:21.882199174 +0200
--- src/quickfix.c	2017-04-02 15:13:20.097970139 +0200
***************
*** 4866,4874 ****
--- 4866,4915 ----
      return retval;
  }
  
+ /*
+  * Find the non-location list window with the specified location list.
+  */
+     static win_T *
+ find_win_with_ll(qf_info_T *qi)
+ {
+     win_T	*wp = NULL;
+ 
+     FOR_ALL_WINDOWS(wp)
+ 	if ((wp->w_llist == qi) && !bt_quickfix(wp->w_buffer))
+ 	    return wp;
+ 
+     return NULL;
+ }
+ 
+ /*
+  * Free the entire quickfix/location list stack.
+  * If the quickfix/location list window is open, then clear it.
+  */
      static void
  qf_free_stack(win_T *wp, qf_info_T *qi)
  {
+     win_T	*qfwin = qf_find_win(qi);
+     win_T	*llwin = NULL;
+     win_T	*orig_wp = wp;
+ 
+     if (qfwin != NULL)
+     {
+ 	/* If the quickfix/location list window is open, then clear it */
+ 	if (qi->qf_curlist < qi->qf_listcount)
+ 	    qf_free(qi, qi->qf_curlist);
+ 	qf_update_buffer(qi, NULL);
+     }
+ 
+     if (wp != NULL && IS_LL_WINDOW(wp))
+     {
+ 	/* If in the location list window, then use the non-location list
+ 	 * window with this location list (if present)
+ 	 */
+ 	llwin = find_win_with_ll(qi);
+ 	if (llwin != NULL)
+ 	    wp = llwin;
+     }
+ 
      qf_free_all(wp);
      if (wp == NULL)
      {
***************
*** 4876,4881 ****
--- 4917,4934 ----
  	qi->qf_curlist = 0;
  	qi->qf_listcount = 0;
      }
+     else if (IS_LL_WINDOW(orig_wp))
+     {
+ 	/* If the location list window is open, then create a new empty
+ 	 * location list */
+ 	qf_info_T *new_ll = ll_new_list();
+ 	orig_wp->w_llist_ref = new_ll;
+ 	if (llwin != NULL)
+ 	{
+ 	    llwin->w_llist = new_ll;
+ 	    new_ll->qf_refcount++;
+ 	}
+     }
  }
  
  /*
*** ../vim-8.0.0535/src/testdir/test_quickfix.vim	2017-03-29 14:19:21.886199149 +0200
--- src/testdir/test_quickfix.vim	2017-04-02 15:10:55.930856569 +0200
***************
*** 1912,1914 ****
--- 1912,1977 ----
    call XvimgrepTests('c')
    call XvimgrepTests('l')
  endfunc
+ 
+ func XfreeTests(cchar)
+   call s:setup_commands(a:cchar)
+ 
+   enew | only
+ 
+   " Deleting the quickfix stack should work even When the current list is
+   " somewhere in the middle of the stack
+   Xexpr ['Xfile1:10:10:Line 10', 'Xfile1:15:15:Line 15']
+   Xexpr ['Xfile2:20:20:Line 20', 'Xfile2:25:25:Line 25']
+   Xexpr ['Xfile3:30:30:Line 30', 'Xfile3:35:35:Line 35']
+   Xolder
+   call g:Xsetlist([], 'f')
+   call assert_equal(0, len(g:Xgetlist()))
+ 
+   " After deleting the stack, adding a new list should create a stack with a
+   " single list.
+   Xexpr ['Xfile1:10:10:Line 10', 'Xfile1:15:15:Line 15']
+   call assert_equal(1, g:Xgetlist({'all':1}).nr)
+ 
+   " Deleting the stack from a quickfix window should update/clear the
+   " quickfix/location list window.
+   Xexpr ['Xfile1:10:10:Line 10', 'Xfile1:15:15:Line 15']
+   Xexpr ['Xfile2:20:20:Line 20', 'Xfile2:25:25:Line 25']
+   Xexpr ['Xfile3:30:30:Line 30', 'Xfile3:35:35:Line 35']
+   Xolder
+   Xwindow
+   call g:Xsetlist([], 'f')
+   call assert_equal(2, winnr('$'))
+   call assert_equal(1, line('$'))
+   Xclose
+ 
+   " Deleting the stack from a non-quickfix window should update/clear the
+   " quickfix/location list window.
+   Xexpr ['Xfile1:10:10:Line 10', 'Xfile1:15:15:Line 15']
+   Xexpr ['Xfile2:20:20:Line 20', 'Xfile2:25:25:Line 25']
+   Xexpr ['Xfile3:30:30:Line 30', 'Xfile3:35:35:Line 35']
+   Xolder
+   Xwindow
+   wincmd p
+   call g:Xsetlist([], 'f')
+   call assert_equal(0, len(g:Xgetlist()))
+   wincmd p
+   call assert_equal(2, winnr('$'))
+   call assert_equal(1, line('$'))
+ 
+   " After deleting the location list stack, if the location list window is
+   " opened, then a new location list should be created. So opening the
+   " location list window again should not create a new window.
+   if a:cchar == 'l'
+       lexpr ['Xfile1:10:10:Line 10', 'Xfile1:15:15:Line 15']
+       wincmd p
+       lopen
+       call assert_equal(2, winnr('$'))
+   endif
+   Xclose
+ endfunc
+ 
+ " Tests for the quickifx free functionality
+ func Test_qf_free()
+   call XfreeTests('c')
+   call XfreeTests('l')
+ endfunc
*** ../vim-8.0.0535/src/version.c	2017-04-01 21:21:26.578627608 +0200
--- src/version.c	2017-04-02 15:15:04.773328435 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     536,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
253. You wait for a slow loading web page before going to the toilet.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0537
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0537
Problem:    Illegal memory access with :z and large count.
Solution:   Check for number overflow, using long instead of int. (Dominique
            Pelle, closes #1612)
Files:      src/Makefile, src/ex_cmds.c, src/testdir/test_alot.vim,
            src/testdir/test_ex_z.vim


*** ../vim-8.0.0536/src/Makefile	2017-03-29 19:20:25.385015086 +0200
--- src/Makefile	2017-04-02 15:40:36.983518442 +0200
***************
*** 2122,2131 ****
  	test_delete \
  	test_diffmode \
  	test_digraph \
- 	test_functions \
  	test_display \
  	test_edit \
  	test_ex_undo \
  	test_execute_func \
  	test_expand \
  	test_expand_dllpath \
--- 2123,2132 ----
  	test_delete \
  	test_diffmode \
  	test_digraph \
  	test_display \
  	test_edit \
  	test_ex_undo \
+ 	test_ex_z \
  	test_execute_func \
  	test_expand \
  	test_expand_dllpath \
***************
*** 2142,2147 ****
--- 2143,2149 ----
  	test_fnameescape \
  	test_fnamemodify \
  	test_fold \
+ 	test_functions \
  	test_ga \
  	test_gf \
  	test_glob2regpat \
*** ../vim-8.0.0536/src/ex_cmds.c	2017-03-26 13:50:02.536929400 +0200
--- src/ex_cmds.c	2017-04-02 15:41:44.443096865 +0200
***************
*** 4564,4570 ****
  ex_z(exarg_T *eap)
  {
      char_u	*x;
!     int		bigness;
      char_u	*kind;
      int		minus = 0;
      linenr_T	start, end, curs, i;
--- 4564,4570 ----
  ex_z(exarg_T *eap)
  {
      char_u	*x;
!     long	bigness;
      char_u	*kind;
      int		minus = 0;
      linenr_T	start, end, curs, i;
***************
*** 4601,4607 ****
  	}
  	else
  	{
! 	    bigness = atoi((char *)x);
  	    p_window = bigness;
  	    if (*kind == '=')
  		bigness += 2;
--- 4601,4612 ----
  	}
  	else
  	{
! 	    bigness = atol((char *)x);
! 
! 	    /* bigness could be < 0 if atol(x) overflows. */
! 	    if (bigness > 2 * curbuf->b_ml.ml_line_count || bigness < 0)
! 		bigness = 2 * curbuf->b_ml.ml_line_count;
! 
  	    p_window = bigness;
  	    if (*kind == '=')
  		bigness += 2;
*** ../vim-8.0.0536/src/testdir/test_alot.vim	2017-03-29 19:20:25.389015062 +0200
--- src/testdir/test_alot.vim	2017-04-02 15:40:56.999392658 +0200
***************
*** 8,17 ****
  source test_cursor_func.vim
  source test_delete.vim
  source test_ex_undo.vim
  source test_execute_func.vim
  source test_expand.vim
- source test_expr.vim
  source test_expand_dllpath.vim
  source test_feedkeys.vim
  source test_file_perm.vim
  source test_fileformat.vim
--- 8,18 ----
  source test_cursor_func.vim
  source test_delete.vim
  source test_ex_undo.vim
+ source test_ex_z.vim
  source test_execute_func.vim
  source test_expand.vim
  source test_expand_dllpath.vim
+ source test_expr.vim
  source test_feedkeys.vim
  source test_file_perm.vim
  source test_fileformat.vim
***************
*** 30,38 ****
  source test_jumps.vim
  source test_lambda.vim
  source test_lispwords.vim
  source test_match.vim
  source test_menu.vim
- source test_mapping.vim
  source test_messages.vim
  source test_partial.vim
  source test_popup.vim
--- 31,39 ----
  source test_jumps.vim
  source test_lambda.vim
  source test_lispwords.vim
+ source test_mapping.vim
  source test_match.vim
  source test_menu.vim
  source test_messages.vim
  source test_partial.vim
  source test_popup.vim
*** ../vim-8.0.0536/src/testdir/test_ex_z.vim	2017-04-02 15:44:23.726105152 +0200
--- src/testdir/test_ex_z.vim	2017-04-02 15:43:05.010595003 +0200
***************
*** 0 ****
--- 1,78 ----
+ " Test :z
+ 
+ func Test_z()
+   call setline(1, range(1, 100))
+ 
+   let a = execute('20z3')
+   call assert_equal("\n20\n21\n22", a)
+   call assert_equal(22, line('.'))
+   " 'window' should be set to the {count} value.
+   call assert_equal(3, &window)
+ 
+   " If there is only one window, then twice the amount of 'scroll' is used.
+   set scroll=2
+   let a = execute('20z')
+   call assert_equal("\n20\n21\n22\n23", a)
+   call assert_equal(23, line('.'))
+ 
+   let a = execute('20z+3')
+   " FIXME: I would expect the same result as '20z3' but it
+   " gives "\n21\n22\n23" instead. Bug in Vim or in ":help :z"?
+   "call assert_equal("\n20\n21\n22", a)
+   "call assert_equal(22, line('.'))
+ 
+   let a = execute('20z-3')
+   call assert_equal("\n18\n19\n20", a)
+   call assert_equal(20, line('.'))
+ 
+   let a = execute('20z=3')
+   call assert_match("^\n18\n19\n-\\+\n20\n-\\+\n21\n22$", a)
+   call assert_equal(20, line('.'))
+ 
+   let a = execute('20z^3')
+   call assert_equal("\n14\n15\n16\n17", a)
+   call assert_equal(17, line('.'))
+ 
+   let a = execute('20z.3')
+   call assert_equal("\n19\n20\n21", a)
+   call assert_equal(21, line('.'))
+ 
+   let a = execute('20z#3')
+   call assert_equal("\n 20 20\n 21 21\n 22 22", a)
+   call assert_equal(22, line('.'))
+ 
+   let a = execute('20z#-3')
+   call assert_equal("\n 18 18\n 19 19\n 20 20", a)
+   call assert_equal(20, line('.'))
+ 
+   let a = execute('20z#=3')
+   call assert_match("^\n 18 18\n 19 19\n-\\+\n 20 20\n-\\+\n 21 21\n 22 22$", a)
+   call assert_equal(20, line('.'))
+ 
+   " Test with {count} bigger than the number of lines in buffer.
+   let a = execute('20z1000')
+   call assert_match("^\n20\n21\n.*\n99\n100$", a)
+   call assert_equal(100, line('.'))
+ 
+   let a = execute('20z-1000')
+   call assert_match("^\n1\n2\n.*\n19\n20$", a)
+   call assert_equal(20, line('.'))
+ 
+   let a = execute('20z=1000')
+   call assert_match("^\n1\n.*\n-\\+\n20\n-\\\+\n.*\n100$", a)
+   call assert_equal(20, line('.'))
+ 
+   call assert_fails('20z=a', 'E144:')
+ 
+   set window& scroll&
+   bw!
+ endfunc
+ 
+ func Test_z_bug()
+   " This used to access invalid memory as a result of an integer overflow
+   " and freeze vim.
+   normal ox
+   normal Heat
+   z777777776666666
+   ')
+ endfunc
*** ../vim-8.0.0536/src/version.c	2017-04-02 15:15:44.825083189 +0200
--- src/version.c	2017-04-02 15:43:45.854340777 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     537,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
256. You are able to write down over 250 symptoms of being an internet
     addict, even though they only asked for 101.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0538
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0538
Problem:    No test for falling back to default term value.
Solution:   Add a test.
Files:      src/testdir/test_startup.vim


*** ../vim-8.0.0537/src/testdir/test_startup.vim	2017-03-27 23:02:03.392337316 +0200
--- src/testdir/test_startup.vim	2017-04-02 16:52:35.528579836 +0200
***************
*** 208,210 ****
--- 208,223 ----
    let out = system(GetVimCommand() . '-u NONE -es -c''set verbose=1|h|exe "%norm\<c-y>\<c-d>"'' -c cq')
    call assert_notmatch('E315:', out)
  endfunc
+ 
+ func Test_default_term()
+   if !has('unix') || has('gui_running')
+     " can't get output of Vim.
+     return
+   endif
+ 
+   let save_term = $TERM
+   let $TERM = 'unknown'
+   let out = system(GetVimCommand() . ' -c''set term'' -c cq')
+   call assert_match("defaulting to 'ansi'", out)
+   let $TERM = save_term
+ endfunc
*** ../vim-8.0.0537/src/version.c	2017-04-02 15:45:00.381877182 +0200
--- src/version.c	2017-04-02 16:53:19.460306740 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     538,
  /**/

-- 
Place mark here ->[ ]<- if you want a dirty monitor.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0539
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0539 (after 8.0.0538)
Problem:    Startup test fails on Mac.
Solution:   Use another term name, "unknown" is known. Avoid a 2 second delay.
Files:      src/testdir/test_startup.vim, src/main.c, src/proto/main.pro,
            src/term.c

*** ../vim-8.0.0538/src/testdir/test_startup.vim	2017-04-02 16:54:05.820018573 +0200
--- src/testdir/test_startup.vim	2017-04-02 17:14:53.108377770 +0200
***************
*** 216,222 ****
    endif
  
    let save_term = $TERM
!   let $TERM = 'unknown'
    let out = system(GetVimCommand() . ' -c''set term'' -c cq')
    call assert_match("defaulting to 'ansi'", out)
    let $TERM = save_term
--- 216,222 ----
    endif
  
    let save_term = $TERM
!   let $TERM = 'unknownxxx'
    let out = system(GetVimCommand() . ' -c''set term'' -c cq')
    call assert_match("defaulting to 'ansi'", out)
    let $TERM = save_term
*** ../vim-8.0.0538/src/main.c	2017-03-19 21:47:46.897119250 +0100
--- src/main.c	2017-04-02 17:19:31.626671792 +0200
***************
*** 1013,1018 ****
--- 1013,1027 ----
  }
  
  /*
+  * Return TRUE when the --not-a-term argument was found.
+  */
+     int
+ is_not_a_term()
+ {
+     return params.not_a_term;
+ }
+ 
+ /*
   * Main loop: Execute Normal mode commands until exiting Vim.
   * Also used to handle commands in the command-line window, until the window
   * is closed.
*** ../vim-8.0.0538/src/proto/main.pro	2017-03-18 18:10:08.767696888 +0100
--- src/proto/main.pro	2017-04-02 17:19:34.310655332 +0200
***************
*** 1,6 ****
--- 1,7 ----
  /* main.c */
  int vim_main2(void);
  void common_init(mparm_T *paramp);
+ int is_not_a_term(void);
  void main_loop(int cmdwin, int noexmode);
  void getout_preserve_modified(int exitval);
  void getout(int exitval);
*** ../vim-8.0.0538/src/term.c	2017-03-16 17:23:26.839815753 +0100
--- src/term.c	2017-04-02 17:19:51.842547812 +0200
***************
*** 1705,1711 ****
  		{
  		    screen_start();	/* don't know where cursor is now */
  		    out_flush();
! 		    ui_delay(2000L, TRUE);
  		}
  		set_string_option_direct((char_u *)"term", -1, term,
  								 OPT_FREE, 0);
--- 1705,1712 ----
  		{
  		    screen_start();	/* don't know where cursor is now */
  		    out_flush();
! 		    if (!is_not_a_term())
! 			ui_delay(2000L, TRUE);
  		}
  		set_string_option_direct((char_u *)"term", -1, term,
  								 OPT_FREE, 0);
*** ../vim-8.0.0538/src/version.c	2017-04-02 16:54:05.820018573 +0200
--- src/version.c	2017-04-02 17:20:27.574328630 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     539,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
258. When you want to see your girlfriend, you surf to her homepage.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0540
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0540 (after 8.0.0540)
Problem:    Building unit tests fails.
Solution:   Move params outside of #ifdef.
Files:      src/main.c, src/message_test.c


*** ../vim-8.0.0539/src/main.c	2017-04-02 17:21:09.890069493 +0200
--- src/main.c	2017-04-02 18:04:03.257961554 +0200
***************
*** 89,103 ****
  };
  
  #ifndef PROTO		/* don't want a prototype for main() */
  #ifndef NO_VIM_MAIN	/* skip this for unittests */
  
  static char_u *start_dir = NULL;	/* current working dir on startup */
  
  static int has_dash_c_arg = FALSE;
  
- /* Various parameters passed between main() and other functions. */
- static mparm_T	params;
- 
      int
  # ifdef VIMDLL
  _export
--- 89,104 ----
  };
  
  #ifndef PROTO		/* don't want a prototype for main() */
+ 
+ /* Various parameters passed between main() and other functions. */
+ static mparm_T	params;
+ 
  #ifndef NO_VIM_MAIN	/* skip this for unittests */
  
  static char_u *start_dir = NULL;	/* current working dir on startup */
  
  static int has_dash_c_arg = FALSE;
  
      int
  # ifdef VIMDLL
  _export
*** ../vim-8.0.0539/src/message_test.c	2016-08-29 22:42:20.000000000 +0200
--- src/message_test.c	2017-04-02 18:08:20.140381578 +0200
***************
*** 96,103 ****
      int
  main(int argc, char **argv)
  {
-     mparm_T params;
- 
      vim_memset(&params, 0, sizeof(params));
      params.argc = argc;
      params.argv = argv;
--- 96,101 ----
*** ../vim-8.0.0539/src/version.c	2017-04-02 17:21:09.890069493 +0200
--- src/version.c	2017-04-02 18:04:56.925631563 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     540,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
259. When you enter your name in the AltaVista search engine, the top ten
     matches do indeed refer to you.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0541
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0541
Problem:    Compiler warning on MS-Windows.
Solution:   Add a type cast. (Mike Williams)
Files:      src/edit.c


*** ../vim-8.0.0540/src/edit.c	2017-04-01 15:15:48.284089660 +0200
--- src/edit.c	2017-04-03 21:34:11.377676422 +0200
***************
*** 9032,9038 ****
  			       (linenr_T)(curwin->w_cursor.lnum + 1)) == FAIL)
  		return FALSE;
  	    --Insstart.lnum;
! 	    Insstart.col = STRLEN(ml_get(Insstart.lnum));
  	}
  	/*
  	 * In replace mode:
--- 9032,9038 ----
  			       (linenr_T)(curwin->w_cursor.lnum + 1)) == FAIL)
  		return FALSE;
  	    --Insstart.lnum;
! 	    Insstart.col = (colnr_T)STRLEN(ml_get(Insstart.lnum));
  	}
  	/*
  	 * In replace mode:
*** ../vim-8.0.0540/src/version.c	2017-04-02 18:19:48.376143576 +0200
--- src/version.c	2017-04-03 21:34:54.957404378 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     541,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
266. You hear most of your jokes via e-mail instead of in person.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0542
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0542
Problem:    getpos() can return a negative line number. (haya14busa)
Solution:   Handle a zero topline and botline. (closes #1613)
Files:      src/eval.c, runtime/doc/eval.txt


*** ../vim-8.0.0541/src/eval.c	2017-03-18 19:41:45.896072895 +0100
--- src/eval.c	2017-04-03 21:48:02.968400475 +0200
***************
*** 6120,6132 ****
  	if (name[1] == '0')		/* "w0": first visible line */
  	{
  	    update_topline();
! 	    pos.lnum = curwin->w_topline;
  	    return &pos;
  	}
  	else if (name[1] == '$')	/* "w$": last visible line */
  	{
  	    validate_botline();
! 	    pos.lnum = curwin->w_botline - 1;
  	    return &pos;
  	}
      }
--- 6120,6135 ----
  	if (name[1] == '0')		/* "w0": first visible line */
  	{
  	    update_topline();
! 	    /* In silent Ex mode topline is zero, but that's not a valid line
! 	     * number; use one instead. */
! 	    pos.lnum = curwin->w_topline > 0 ? curwin->w_topline : 1;
  	    return &pos;
  	}
  	else if (name[1] == '$')	/* "w$": last visible line */
  	{
  	    validate_botline();
! 	    /* In silent Ex mode botline is zero, return zero then. */
! 	    pos.lnum = curwin->w_botline > 0 ? curwin->w_botline - 1 : 0;
  	    return &pos;
  	}
      }
*** ../vim-8.0.0541/runtime/doc/eval.txt	2017-03-29 14:19:21.882199174 +0200
--- runtime/doc/eval.txt	2017-04-03 21:51:05.323245179 +0200
***************
*** 5398,5405 ****
  		    $	    the last line in the current buffer
  		    'x	    position of mark x (if the mark is not set, 0 is
  			    returned)
! 		    w0	    first line visible in current window
! 		    w$	    last line visible in current window
  		    v	    In Visual mode: the start of the Visual area (the
  			    cursor is the end).  When not in Visual mode
  			    returns the cursor position.  Differs from |'<| in
--- 5413,5422 ----
  		    $	    the last line in the current buffer
  		    'x	    position of mark x (if the mark is not set, 0 is
  			    returned)
! 		    w0	    first line visible in current window (one if the
! 			    display isn't updated, e.g. in silent Ex mode)
! 		    w$	    last line visible in current window (this is one
! 			    less than "w0" if no lines are visible)
  		    v	    In Visual mode: the start of the Visual area (the
  			    cursor is the end).  When not in Visual mode
  			    returns the cursor position.  Differs from |'<| in
*** ../vim-8.0.0541/src/version.c	2017-04-03 21:35:38.701127879 +0200
--- src/version.c	2017-04-03 21:56:07.017338505 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     542,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
267. You get an extra phone line so you can get phone calls.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0543
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0543
Problem:    Test_edit causes older xfce4-terminal to close. (Dominique Pelle)
Solution:   Reduce number of columns to 2000.  Try to restore the window
            position.
Files:      src/testdir/test_edit.vim, src/evalfunc.c, src/term.c,
            src/proto/term.pro, src/term.h


*** ../vim-8.0.0542/src/testdir/test_edit.vim	2017-04-01 14:13:11.866693326 +0200
--- src/testdir/test_edit.vim	2017-04-04 22:33:33.907147970 +0200
***************
*** 1328,1337 ****
      " Long directory names only work on Unix.
      return
    endif
    let save_columns = &columns
!   set columns=5000
!   call assert_equal(5000, &columns)
    set noswapfile
    let dirname = getcwd() . "/Xdir"
    let longdirname = dirname . repeat('/' . repeat('d', 255), 4)
    let longfilename = longdirname . '/' . repeat('a', 255)
--- 1328,1341 ----
      " Long directory names only work on Unix.
      return
    endif
+   " Try to get the Vim window position before setting 'columns'.
+   let winposx = getwinposx()
+   let winposy = getwinposy()
    let save_columns = &columns
!   set columns=2000
!   call assert_equal(2000, &columns)
    set noswapfile
+ 
    let dirname = getcwd() . "/Xdir"
    let longdirname = dirname . repeat('/' . repeat('d', 255), 4)
    let longfilename = longdirname . '/' . repeat('a', 255)
***************
*** 1345,1349 ****
--- 1349,1356 ----
    exe 'bwipe! ' . longfilename
    call delete(dirname, 'rf')
    let &columns = save_columns
+   if winposx >= 0 && winposy >= 0
+     exe 'winpos ' . winposx . ' ' . winposy
+   endif
    set swapfile&
  endfunc
*** ../vim-8.0.0542/src/evalfunc.c	2017-03-29 14:19:21.882199174 +0200
--- src/evalfunc.c	2017-04-04 21:50:59.879208445 +0200
***************
*** 5242,5265 ****
  }
  
  /*
-  * "getwinposx()" function
-  */
-     static void
- f_getwinposx(typval_T *argvars UNUSED, typval_T *rettv)
- {
-     rettv->vval.v_number = -1;
- #ifdef FEAT_GUI
-     if (gui.in_use)
-     {
- 	int	    x, y;
- 
- 	if (gui_mch_get_winpos(&x, &y) == OK)
- 	    rettv->vval.v_number = x;
-     }
- #endif
- }
- 
- /*
   * "win_findbuf()" function
   */
      static void
--- 5242,5247 ----
***************
*** 5307,5312 ****
--- 5289,5320 ----
  }
  
  /*
+  * "getwinposx()" function
+  */
+     static void
+ f_getwinposx(typval_T *argvars UNUSED, typval_T *rettv)
+ {
+     rettv->vval.v_number = -1;
+ #ifdef FEAT_GUI
+     if (gui.in_use)
+     {
+ 	int	    x, y;
+ 
+ 	if (gui_mch_get_winpos(&x, &y) == OK)
+ 	    rettv->vval.v_number = x;
+     }
+ #endif
+ #if defined(HAVE_TGETENT) && defined(FEAT_TERMRESPONSE)
+     {
+ 	int	    x, y;
+ 
+ 	if (term_get_winpos(&x, &y) == OK)
+ 	    rettv->vval.v_number = x;
+     }
+ #endif
+ }
+ 
+ /*
   * "getwinposy()" function
   */
      static void
***************
*** 5322,5327 ****
--- 5330,5343 ----
  	    rettv->vval.v_number = y;
      }
  #endif
+ #if defined(HAVE_TGETENT) && defined(FEAT_TERMRESPONSE)
+     {
+ 	int	    x, y;
+ 
+ 	if (term_get_winpos(&x, &y) == OK)
+ 	    rettv->vval.v_number = y;
+     }
+ #endif
  }
  
  /*
*** ../vim-8.0.0542/src/term.c	2017-04-02 17:21:09.890069493 +0200
--- src/term.c	2017-04-04 22:33:20.819229358 +0200
***************
*** 845,853 ****
--- 845,855 ----
  						  ESC_STR "[8;%p1%d;%p2%dt")},
      {(int)KS_CWP,	IF_EB("\033[3;%p1%d;%p2%dt",
  						  ESC_STR "[3;%p1%d;%p2%dt")},
+     {(int)KS_CGP,	IF_EB("\033[13t", ESC_STR "[13t")},
  #  else
      {(int)KS_CWS,	IF_EB("\033[8;%d;%dt", ESC_STR "[8;%d;%dt")},
      {(int)KS_CWP,	IF_EB("\033[3;%d;%dt", ESC_STR "[3;%d;%dt")},
+     {(int)KS_CGP,	IF_EB("\033[13t", ESC_STR "[13t")},
  #  endif
      {(int)KS_CRV,	IF_EB("\033[>c", ESC_STR "[>c")},
      {(int)KS_RBG,	IF_EB("\033]11;?\007", ESC_STR "]11;?\007")},
***************
*** 2581,2586 ****
--- 2583,2642 ----
      OUT_STR(tgoto((char *)T_CWP, y, x));
  }
  
+ # if defined(FEAT_TERMRESPONSE) || defined(PROTO)
+ /*
+  * Return TRUE if we can request the terminal for a response.
+  */
+     static int
+ can_get_termresponse()
+ {
+     return cur_tmode == TMODE_RAW
+ 	    && termcap_active
+ # ifdef UNIX
+ 	    && (is_not_a_term() || (isatty(1) && isatty(read_cmd_fd)))
+ # endif
+ 	    && p_ek;
+ }
+ 
+ static int winpos_x;
+ static int winpos_y;
+ static int waiting_for_winpos = FALSE;
+ 
+ /*
+  * Try getting the Vim window position from the terminal.
+  * Returns OK or FAIL.
+  */
+     int
+ term_get_winpos(int *x, int *y)
+ {
+     int count = 0;
+ 
+     if (*T_CGP == NUL || !can_get_termresponse())
+ 	return FAIL;
+     winpos_x = -1;
+     winpos_y = -1;
+     waiting_for_winpos = TRUE;
+     OUT_STR(T_CGP);
+     out_flush();
+ 
+     /* Try reading the result for 100 msec. */
+     while (count++ < 10)
+     {
+ 	(void)vpeekc_nomap();
+ 	if (winpos_x >= 0 && winpos_y >= 0)
+ 	{
+ 	    *x = winpos_x;
+ 	    *y = winpos_y;
+ 	    waiting_for_winpos = FALSE;
+ 	    return OK;
+ 	}
+ 	ui_delay(10, FALSE);
+     }
+     waiting_for_winpos = FALSE;
+     return FALSE;
+ }
+ # endif
+ 
      void
  term_set_winsize(int width, int height)
  {
***************
*** 3229,3242 ****
  may_req_termresponse(void)
  {
      if (crv_status == CRV_GET
! 	    && cur_tmode == TMODE_RAW
  	    && starting == 0
- 	    && termcap_active
- 	    && p_ek
- # ifdef UNIX
- 	    && isatty(1)
- 	    && isatty(read_cmd_fd)
- # endif
  	    && *T_CRV != NUL)
      {
  	LOG_TR("Sending CRV");
--- 3285,3292 ----
  may_req_termresponse(void)
  {
      if (crv_status == CRV_GET
! 	    && can_get_termresponse()
  	    && starting == 0
  	    && *T_CRV != NUL)
      {
  	LOG_TR("Sending CRV");
***************
*** 3263,3275 ****
  may_req_ambiguous_char_width(void)
  {
      if (u7_status == U7_GET
! 	    && cur_tmode == TMODE_RAW
! 	    && termcap_active
! 	    && p_ek
! #  ifdef UNIX
! 	    && isatty(1)
! 	    && isatty(read_cmd_fd)
! #  endif
  	    && *T_U7 != NUL
  	    && !option_was_set((char_u *)"ambiwidth"))
      {
--- 3313,3320 ----
  may_req_ambiguous_char_width(void)
  {
      if (u7_status == U7_GET
! 	    && can_get_termresponse()
! 	    && starting == 0
  	    && *T_U7 != NUL
  	    && !option_was_set((char_u *)"ambiwidth"))
      {
***************
*** 3295,3301 ****
  }
  # endif
  
- #if defined(FEAT_TERMRESPONSE) || defined(PROTO)
  /*
   * Similar to requesting the version string: Request the terminal background
   * color when it is the right moment.
--- 3340,3345 ----
***************
*** 3304,3316 ****
  may_req_bg_color(void)
  {
      if (rbg_status == RBG_GET
! 	    && cur_tmode == TMODE_RAW
! 	    && termcap_active
! 	    && p_ek
! #  ifdef UNIX
! 	    && isatty(1)
! 	    && isatty(read_cmd_fd)
! #  endif
  	    && *T_RBG != NUL
  	    && !option_was_set((char_u *)"bg"))
      {
--- 3348,3355 ----
  may_req_bg_color(void)
  {
      if (rbg_status == RBG_GET
! 	    && can_get_termresponse()
! 	    && starting == 0
  	    && *T_RBG != NUL
  	    && !option_was_set((char_u *)"bg"))
      {
***************
*** 3323,3329 ****
  	(void)vpeekc_nomap();
      }
  }
- # endif
  
  # ifdef DEBUG_TERMRESPONSE
      static void
--- 3362,3367 ----
***************
*** 4136,4145 ****
  	     * - Cursor position report: <Esc>[{row};{col}R
  	     *   The final byte must be 'R'. It is used for checking the
  	     *   ambiguous-width character state.
  	     */
  	    char_u *argp = tp[0] == ESC ? tp + 2 : tp + 1;
  
! 	    if ((*T_CRV != NUL || *T_U7 != NUL)
  			&& ((tp[0] == ESC && len >= 3 && tp[1] == '[')
  			    || (tp[0] == CSI && len >= 2))
  			&& (VIM_ISDIGIT(*argp) || *argp == '>' || *argp == '?'))
--- 4174,4185 ----
  	     * - Cursor position report: <Esc>[{row};{col}R
  	     *   The final byte must be 'R'. It is used for checking the
  	     *   ambiguous-width character state.
+ 	     *
+ 	     * - window position reply: <Esc>[3;{x};{y}t
  	     */
  	    char_u *argp = tp[0] == ESC ? tp + 2 : tp + 1;
  
! 	    if ((*T_CRV != NUL || *T_U7 != NUL || waiting_for_winpos)
  			&& ((tp[0] == ESC && len >= 3 && tp[1] == '[')
  			    || (tp[0] == CSI && len >= 2))
  			&& (VIM_ISDIGIT(*argp) || *argp == '>' || *argp == '?'))
***************
*** 4278,4283 ****
--- 4318,4358 ----
  		    key_name[1] = (int)KE_IGNORE;
  		    slen = i + 1;
  		}
+ 
+ 		/*
+ 		 * Check for a window position response from the terminal:
+ 		 *       {lead}3;{x}:{y}t
+ 		 */
+ 		else if (waiting_for_winpos
+ 			    && ((len >= 4 && tp[0] == ESC && tp[1] == '[')
+ 				|| (len >= 3 && tp[0] == CSI))
+ 			    && tp[(j = 1 + (tp[0] == ESC))] == '3'
+ 			    && tp[j + 1] == ';')
+ 		{
+ 		    j += 2;
+ 		    for (i = j; i < len && vim_isdigit(tp[i]); ++i)
+ 			;
+ 		    if (i < len && tp[i] == ';')
+ 		    {
+ 			winpos_x = atoi((char *)tp + j);
+ 			j = i + 1;
+ 			for (i = j; i < len && vim_isdigit(tp[i]); ++i)
+ 			    ;
+ 			if (i < len && tp[i] == 't')
+ 			{
+ 			    winpos_y = atoi((char *)tp + j);
+ 			    /* got finished code: consume it */
+ 			    key_name[0] = (int)KS_EXTRA;
+ 			    key_name[1] = (int)KE_IGNORE;
+ 			    slen = i + 1;
+ 			}
+ 		    }
+ 		    if (i == len)
+ 		    {
+ 			LOG_TR("not enough characters for winpos");
+ 			return -1;
+ 		    }
+ 		}
  	    }
  
  	    /* Check for background color response from the terminal:
*** ../vim-8.0.0542/src/proto/term.pro	2016-09-12 13:04:20.000000000 +0200
--- src/proto/term.pro	2017-04-04 21:26:37.440495254 +0200
***************
*** 22,27 ****
--- 22,28 ----
  void term_append_lines(int line_count);
  void term_delete_lines(int line_count);
  void term_set_winpos(int x, int y);
+ int term_get_winpos(int *x, int *y);
  void term_set_winsize(int width, int height);
  void term_fg_color(int n);
  void term_bg_color(int n);
*** ../vim-8.0.0542/src/term.h	2017-03-16 17:23:26.839815753 +0100
--- src/term.h	2017-04-04 20:54:20.296766437 +0200
***************
*** 77,82 ****
--- 77,83 ----
      KS_TS,	/* set window title start (to status line)*/
      KS_FS,	/* set window title end (from status line) */
      KS_CWP,	/* set window position in pixels */
+     KS_CGP,	/* get window position */
      KS_CWS,	/* set window size in characters */
      KS_CRV,	/* request version string */
      KS_RBG,	/* request background color */
***************
*** 163,169 ****
  #define T_CIE	(TERM_STR(KS_CIE))	/* set icon text end */
  #define T_TS	(TERM_STR(KS_TS))	/* set window title start */
  #define T_FS	(TERM_STR(KS_FS))	/* set window title end */
! #define T_CWP	(TERM_STR(KS_CWP))	/* window position */
  #define T_CWS	(TERM_STR(KS_CWS))	/* window size */
  #define T_CSI	(TERM_STR(KS_CSI))	/* start insert mode */
  #define T_CEI	(TERM_STR(KS_CEI))	/* end insert mode */
--- 164,171 ----
  #define T_CIE	(TERM_STR(KS_CIE))	/* set icon text end */
  #define T_TS	(TERM_STR(KS_TS))	/* set window title start */
  #define T_FS	(TERM_STR(KS_FS))	/* set window title end */
! #define T_CWP	(TERM_STR(KS_CWP))	/* set window position */
! #define T_CGP	(TERM_STR(KS_CGP))	/* get window position */
  #define T_CWS	(TERM_STR(KS_CWS))	/* window size */
  #define T_CSI	(TERM_STR(KS_CSI))	/* start insert mode */
  #define T_CEI	(TERM_STR(KS_CEI))	/* end insert mode */
*** ../vim-8.0.0542/src/version.c	2017-04-03 22:02:51.778787637 +0200
--- src/version.c	2017-04-04 22:39:02.645102811 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     543,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
269. You receive an e-mail from the wife of a deceased president, offering
     to send you twenty million dollar, and you are not even surprised.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0544
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0544
Problem:    Cppcheck warnings.
Solution:   Use temp variable. Change NUL to NULL. Swap conditions. (Dominique
            Pelle)
Files:      src/channel.c, src/edit.c, src/farsi.c


*** ../vim-8.0.0543/src/channel.c	2017-02-28 21:26:12.822899342 +0100
--- src/channel.c	2017-04-07 13:57:11.009887327 +0200
***************
*** 2571,2579 ****
  	    if (nl == NULL)
  	    {
  		/* Flush remaining message that is missing a NL. */
! 		buf = vim_realloc(buf, node->rq_buflen + 1);
! 		if (buf == NULL)
  		    return FALSE;
  		node->rq_buffer = buf;
  		nl = buf + node->rq_buflen++;
  		*nl = NUL;
--- 2571,2584 ----
  	    if (nl == NULL)
  	    {
  		/* Flush remaining message that is missing a NL. */
! 		char_u	*new_buf;
! 
! 		new_buf = vim_realloc(buf, node->rq_buflen + 1);
! 		if (new_buf == NULL)
! 		    /* This might fail over and over again, should the message
! 		     * be dropped? */
  		    return FALSE;
+ 		buf = new_buf;
  		node->rq_buffer = buf;
  		nl = buf + node->rq_buflen++;
  		*nl = NUL;
*** ../vim-8.0.0543/src/edit.c	2017-04-03 21:35:38.701127879 +0200
--- src/edit.c	2017-04-07 13:52:06.915781966 +0200
***************
*** 9524,9530 ****
  #endif
  	    buf[idx++] = c;
  	buf[idx] = NUL;
! 	if (end != NUL && STRNCMP(buf, end, idx) == 0)
  	{
  	    if (end[idx] == NUL)
  		break; /* Found the end of paste code. */
--- 9524,9530 ----
  #endif
  	    buf[idx++] = c;
  	buf[idx] = NUL;
! 	if (end != NULL && STRNCMP(buf, end, idx) == 0)
  	{
  	    if (end[idx] == NUL)
  		break; /* Found the end of paste code. */
*** ../vim-8.0.0543/src/farsi.c	2017-03-16 17:23:26.819815897 +0100
--- src/farsi.c	2017-04-07 13:52:06.915781966 +0200
***************
*** 1695,1701 ****
  		ptr[i] = toF_leading(ptr[i]);
  		++i;
  
! 		while (canF_Rjoin(ptr[i]) && i < llen)
  		{
  		    ptr[i] = toF_Rjoin(ptr[i]);
  		    if (F_isterm(ptr[i]) || !F_isalpha(ptr[i]))
--- 1695,1701 ----
  		ptr[i] = toF_leading(ptr[i]);
  		++i;
  
! 		while (i < llen && canF_Rjoin(ptr[i]))
  		{
  		    ptr[i] = toF_Rjoin(ptr[i]);
  		    if (F_isterm(ptr[i]) || !F_isalpha(ptr[i]))
*** ../vim-8.0.0543/src/version.c	2017-04-04 22:41:04.732342875 +0200
--- src/version.c	2017-04-07 13:53:35.827227909 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     544,
  /**/

-- 
press CTRL-ALT-DEL for more information

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0545
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0545
Problem:    Edit test may fail on some systems.
Solution:   If creating a directory with a very long path fails, bail out.
Files:      src/testdir/test_edit.vim


*** ../vim-8.0.0544/src/testdir/test_edit.vim	2017-04-04 22:41:04.724342925 +0200
--- src/testdir/test_edit.vim	2017-04-07 14:07:45.017940108 +0200
***************
*** 1324,1345 ****
  endfunc
  
  func Test_edit_complete_very_long_name()
!   if !has('unix') || has('mac')
      " Long directory names only work on Unix.
      return
    endif
    " Try to get the Vim window position before setting 'columns'.
    let winposx = getwinposx()
    let winposy = getwinposy()
    let save_columns = &columns
    set columns=2000
    call assert_equal(2000, &columns)
    set noswapfile
  
-   let dirname = getcwd() . "/Xdir"
-   let longdirname = dirname . repeat('/' . repeat('d', 255), 4)
    let longfilename = longdirname . '/' . repeat('a', 255)
-   call mkdir(longdirname, 'p')
    call writefile(['Totum', 'Table'], longfilename)
    new
    exe "next Xfile " . longfilename
--- 1324,1354 ----
  endfunc
  
  func Test_edit_complete_very_long_name()
!   if !has('unix')
      " Long directory names only work on Unix.
      return
    endif
+ 
+   let dirname = getcwd() . "/Xdir"
+   let longdirname = dirname . repeat('/' . repeat('d', 255), 4)
+   try
+     call mkdir(longdirname, 'p')
+   catch /E739:/
+     " Long directory name probably not supported.
+     call delete(dirname, 'rf')
+     return
+   endtry
+ 
    " Try to get the Vim window position before setting 'columns'.
    let winposx = getwinposx()
    let winposy = getwinposy()
    let save_columns = &columns
+   " Need at least about 1100 columns to reproduce the problem.
    set columns=2000
    call assert_equal(2000, &columns)
    set noswapfile
  
    let longfilename = longdirname . '/' . repeat('a', 255)
    call writefile(['Totum', 'Table'], longfilename)
    new
    exe "next Xfile " . longfilename
*** ../vim-8.0.0544/src/version.c	2017-04-07 14:01:54.848119739 +0200
--- src/version.c	2017-04-07 14:09:54.049137229 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     545,
  /**/

-- 
Microsoft: "Windows NT 4.0 now has the same user-interface as Windows 95"
    Windows 95: "Press CTRL-ALT-DEL to reboot"
Windows NT 4.0: "Press CTRL-ALT-DEL to login"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0546
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0546
Problem:    Swap file exists briefly when opening the command window.
Solution:   Set the noswapfile command modifier before splitting the window.
            (James McCoy, closes #1620)
Files:      src/ex_getln.c, src/option.c


*** ../vim-8.0.0545/src/ex_getln.c	2017-03-30 22:04:50.889883100 +0200
--- src/ex_getln.c	2017-04-07 14:59:33.606405002 +0200
***************
*** 127,133 ****
  #endif
  
  #ifdef FEAT_CMDWIN
! static int	ex_window(void);
  #endif
  
  #if defined(FEAT_CMDL_COMPL) || defined(PROTO)
--- 127,133 ----
  #endif
  
  #ifdef FEAT_CMDWIN
! static int	open_cmdwin(void);
  #endif
  
  #if defined(FEAT_CMDL_COMPL) || defined(PROTO)
***************
*** 773,779 ****
  		/*
  		 * Open a window to edit the command line (and history).
  		 */
! 		c = ex_window();
  		some_key_typed = TRUE;
  	    }
  	}
--- 773,779 ----
  		/*
  		 * Open a window to edit the command line (and history).
  		 */
! 		c = open_cmdwin();
  		some_key_typed = TRUE;
  	    }
  	}
***************
*** 1292,1298 ****
  		goto cmdline_not_changed;
  
  	case K_IGNORE:
! 		/* Ignore mouse event or ex_window() result. */
  		goto cmdline_not_changed;
  
  #ifdef FEAT_GUI_W32
--- 1292,1298 ----
  		goto cmdline_not_changed;
  
  	case K_IGNORE:
! 		/* Ignore mouse event or open_cmdwin() result. */
  		goto cmdline_not_changed;
  
  #ifdef FEAT_GUI_W32
***************
*** 6796,6802 ****
   *	K_IGNORE if editing continues
   */
      static int
! ex_window(void)
  {
      struct cmdline_info	save_ccline;
      bufref_T		old_curbuf;
--- 6796,6802 ----
   *	K_IGNORE if editing continues
   */
      static int
! open_cmdwin(void)
  {
      struct cmdline_info	save_ccline;
      bufref_T		old_curbuf;
***************
*** 6841,6846 ****
--- 6841,6847 ----
  # endif
      /* don't use a new tab page */
      cmdmod.tab = 0;
+     cmdmod.noswapfile = 1;
  
      /* Create a window for the command-line buffer. */
      if (win_split((int)p_cwh, WSP_BOT) == FAIL)
***************
*** 6857,6863 ****
      (void)do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, NULL);
      (void)setfname(curbuf, (char_u *)"[Command Line]", NULL, TRUE);
      set_option_value((char_u *)"bt", 0L, (char_u *)"nofile", OPT_LOCAL);
-     set_option_value((char_u *)"swf", 0L, NULL, OPT_LOCAL);
      curbuf->b_p_ma = TRUE;
  #ifdef FEAT_FOLDING
      curwin->w_p_fen = FALSE;
--- 6858,6863 ----
*** ../vim-8.0.0545/src/option.c	2017-03-16 17:23:26.831815811 +0100
--- src/option.c	2017-04-07 14:56:08.223691304 +0200
***************
*** 11058,11064 ****
  	    buf->b_p_ml = p_ml;
  	    buf->b_p_ml_nobin = p_ml_nobin;
  	    buf->b_p_inf = p_inf;
! 	    buf->b_p_swf = p_swf;
  #ifdef FEAT_INS_EXPAND
  	    buf->b_p_cpt = vim_strsave(p_cpt);
  #endif
--- 11058,11064 ----
  	    buf->b_p_ml = p_ml;
  	    buf->b_p_ml_nobin = p_ml_nobin;
  	    buf->b_p_inf = p_inf;
! 	    buf->b_p_swf = cmdmod.noswapfile ? FALSE : p_swf;
  #ifdef FEAT_INS_EXPAND
  	    buf->b_p_cpt = vim_strsave(p_cpt);
  #endif
*** ../vim-8.0.0545/src/version.c	2017-04-07 14:10:44.856821123 +0200
--- src/version.c	2017-04-07 14:58:12.142915160 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     546,
  /**/

-- 
The software said it requires Windows 95 or better, so I installed Linux.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0547
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0547
Problem:    Extra line break in verbosefile when using ":echomsg". (Ingo
            Karkat)
Solution:   Don't call msg_start(). (closes #1618)
Files:      src/eval.c, src/testdir/test_cmdline.vim


*** ../vim-8.0.0546/src/eval.c	2017-04-03 22:02:51.774787663 +0200
--- src/eval.c	2017-04-07 16:09:29.080123379 +0200
***************
*** 8328,8334 ****
  	     * follows is displayed on a new line when scrolling back at the
  	     * more prompt. */
  	    msg_sb_eol();
- 	    msg_start();
  	}
  
  	if (eap->cmdidx == CMD_echomsg)
--- 8328,8333 ----
*** ../vim-8.0.0546/src/testdir/test_cmdline.vim	2017-03-29 21:26:57.343685559 +0200
--- src/testdir/test_cmdline.vim	2017-04-07 16:17:29.693114167 +0200
***************
*** 412,415 ****
--- 412,425 ----
    cunmap <F6>
  endfunc
  
+ func Test_verbosefile()
+   set verbosefile=Xlog
+   echomsg 'foo'
+   echomsg 'bar'
+   set verbosefile=
+   let log = readfile('Xlog')
+   call assert_match("foo\nbar", join(log, "\n"))
+   call delete('Xlog')
+ endfunc
+ 
  set cpo&
*** ../vim-8.0.0546/src/version.c	2017-04-07 15:42:20.158333009 +0200
--- src/version.c	2017-04-07 16:06:00.373430387 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     547,
  /**/

-- 
       He was not in the least bit scared to be mashed into a pulp
       Or to have his eyes gouged out and his elbows broken;
       To have his kneecaps split and his body burned away
       And his limbs all hacked and mangled, brave Sir Robin.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0548
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0548
Problem:    Saving the redo buffer only works one time, resulting in the "."
            command not working well for a function call inside another
            function call. (Ingo Karkat)
Solution:   Save the redo buffer at every user function call. (closes #1619)
Files:      src/getchar.c, src/proto/getchar.pro, src/structs.h,
            src/fileio.c, src/userfunc.c, src/testdir/test_functions.vim


*** ../vim-8.0.0547/src/getchar.c	2017-03-16 17:23:26.823815869 +0100
--- src/getchar.c	2017-04-07 19:39:39.270876710 +0200
***************
*** 42,51 ****
  
  static buffheader_T redobuff = {{NULL, {NUL}}, NULL, 0, 0};
  static buffheader_T old_redobuff = {{NULL, {NUL}}, NULL, 0, 0};
- #if defined(FEAT_AUTOCMD) || defined(FEAT_EVAL) || defined(PROTO)
- static buffheader_T save_redobuff = {{NULL, {NUL}}, NULL, 0, 0};
- static buffheader_T save_old_redobuff = {{NULL, {NUL}}, NULL, 0, 0};
- #endif
  static buffheader_T recordbuff = {{NULL, {NUL}}, NULL, 0, 0};
  
  static int typeahead_char = 0;		/* typeahead char that's not flushed */
--- 42,47 ----
***************
*** 521,547 ****
   * Save redobuff and old_redobuff to save_redobuff and save_old_redobuff.
   * Used before executing autocommands and user functions.
   */
- static int save_level = 0;
- 
      void
! saveRedobuff(void)
  {
      char_u	*s;
  
!     if (save_level++ == 0)
      {
! 	save_redobuff = redobuff;
! 	redobuff.bh_first.b_next = NULL;
! 	save_old_redobuff = old_redobuff;
! 	old_redobuff.bh_first.b_next = NULL;
! 
! 	/* Make a copy, so that ":normal ." in a function works. */
! 	s = get_buffcont(&save_redobuff, FALSE);
! 	if (s != NULL)
! 	{
! 	    add_buff(&redobuff, s, -1L);
! 	    vim_free(s);
! 	}
      }
  }
  
--- 517,538 ----
   * Save redobuff and old_redobuff to save_redobuff and save_old_redobuff.
   * Used before executing autocommands and user functions.
   */
      void
! saveRedobuff(save_redo_T *save_redo)
  {
      char_u	*s;
  
!     save_redo->sr_redobuff = redobuff;
!     redobuff.bh_first.b_next = NULL;
!     save_redo->sr_old_redobuff = old_redobuff;
!     old_redobuff.bh_first.b_next = NULL;
! 
!     /* Make a copy, so that ":normal ." in a function works. */
!     s = get_buffcont(&save_redo->sr_redobuff, FALSE);
!     if (s != NULL)
      {
! 	add_buff(&redobuff, s, -1L);
! 	vim_free(s);
      }
  }
  
***************
*** 550,564 ****
   * Used after executing autocommands and user functions.
   */
      void
! restoreRedobuff(void)
  {
!     if (--save_level == 0)
!     {
! 	free_buff(&redobuff);
! 	redobuff = save_redobuff;
! 	free_buff(&old_redobuff);
! 	old_redobuff = save_old_redobuff;
!     }
  }
  #endif
  
--- 541,552 ----
   * Used after executing autocommands and user functions.
   */
      void
! restoreRedobuff(save_redo_T *save_redo)
  {
!     free_buff(&redobuff);
!     redobuff = save_redo->sr_redobuff;
!     free_buff(&old_redobuff);
!     old_redobuff = save_redo->sr_old_redobuff;
  }
  #endif
  
*** ../vim-8.0.0547/src/proto/getchar.pro	2016-09-12 13:04:04.000000000 +0200
--- src/proto/getchar.pro	2017-04-07 19:42:58.705664267 +0200
***************
*** 8,15 ****
  void flush_buffers(int flush_typeahead);
  void ResetRedobuff(void);
  void CancelRedo(void);
! void saveRedobuff(void);
! void restoreRedobuff(void);
  void AppendToRedobuff(char_u *s);
  void AppendToRedobuffLit(char_u *str, int len);
  void AppendCharToRedobuff(int c);
--- 8,15 ----
  void flush_buffers(int flush_typeahead);
  void ResetRedobuff(void);
  void CancelRedo(void);
! void saveRedobuff(save_redo_T *save_redo);
! void restoreRedobuff(save_redo_T *save_redo);
  void AppendToRedobuff(char_u *s);
  void AppendToRedobuffLit(char_u *str, int len);
  void AppendCharToRedobuff(int c);
*** ../vim-8.0.0547/src/structs.h	2017-03-08 22:19:21.717870787 +0100
--- src/structs.h	2017-04-07 19:42:14.217934749 +0200
***************
*** 515,520 ****
--- 515,526 ----
      int		bh_space;	/* space in bh_curr for appending */
  };
  
+ typedef struct
+ {
+     buffheader_T sr_redobuff;
+     buffheader_T sr_old_redobuff;
+ } save_redo_T;
+ 
  /*
   * used for completion on the command line
   */
*** ../vim-8.0.0547/src/fileio.c	2017-03-19 17:09:51.831080752 +0100
--- src/fileio.c	2017-04-07 19:40:58.598394480 +0200
***************
*** 9316,9321 ****
--- 9316,9322 ----
      proftime_T	wait_time;
  #endif
      int		did_save_redobuff = FALSE;
+     save_redo_T	save_redo;
  
      /*
       * Quickly return if there are no autocommands for this event or
***************
*** 9521,9527 ****
  	if (!ins_compl_active())
  #endif
  	{
! 	    saveRedobuff();
  	    did_save_redobuff = TRUE;
  	}
  	did_filetype = keep_filetype;
--- 9522,9528 ----
  	if (!ins_compl_active())
  #endif
  	{
! 	    saveRedobuff(&save_redo);
  	    did_save_redobuff = TRUE;
  	}
  	did_filetype = keep_filetype;
***************
*** 9624,9630 ****
      {
  	restore_search_patterns();
  	if (did_save_redobuff)
! 	    restoreRedobuff();
  	did_filetype = FALSE;
  	while (au_pending_free_buf != NULL)
  	{
--- 9625,9631 ----
      {
  	restore_search_patterns();
  	if (did_save_redobuff)
! 	    restoreRedobuff(&save_redo);
  	did_filetype = FALSE;
  	while (au_pending_free_buf != NULL)
  	{
*** ../vim-8.0.0547/src/userfunc.c	2017-04-01 21:21:26.578627608 +0200
--- src/userfunc.c	2017-04-07 19:41:18.590272942 +0200
***************
*** 1408,1413 ****
--- 1408,1414 ----
  		else
  		{
  		    int did_save_redo = FALSE;
+ 		    save_redo_T	save_redo;
  
  		    /*
  		     * Call the user function.
***************
*** 1419,1425 ****
  		    if (!ins_compl_active())
  #endif
  		    {
! 			saveRedobuff();
  			did_save_redo = TRUE;
  		    }
  		    ++fp->uf_calls;
--- 1420,1426 ----
  		    if (!ins_compl_active())
  #endif
  		    {
! 			saveRedobuff(&save_redo);
  			did_save_redo = TRUE;
  		    }
  		    ++fp->uf_calls;
***************
*** 1431,1437 ****
  			 * now. */
  			func_clear_free(fp, FALSE);
  		    if (did_save_redo)
! 			restoreRedobuff();
  		    restore_search_patterns();
  		    error = ERROR_NONE;
  		}
--- 1432,1438 ----
  			 * now. */
  			func_clear_free(fp, FALSE);
  		    if (did_save_redo)
! 			restoreRedobuff(&save_redo);
  		    restore_search_patterns();
  		    error = ERROR_NONE;
  		}
*** ../vim-8.0.0547/src/testdir/test_functions.vim	2017-03-19 16:09:41.157653918 +0100
--- src/testdir/test_functions.vim	2017-04-07 19:31:09.941971823 +0200
***************
*** 756,758 ****
--- 756,786 ----
    call win_gotoid(dum1_id)
    bwipe!
  endfunc
+ 
+ func Test_redo_in_nested_functions()
+   nnoremap g. :set opfunc=Operator<CR>g@
+   function Operator( type, ... )
+      let @x = 'XXX'
+      execute 'normal! g`[' . (a:type ==# 'line' ? 'V' : 'v') . 'g`]' . '"xp'
+   endfunction
+ 
+   function! Apply()
+       5,6normal! .
+   endfunction
+ 
+   new
+   call setline(1, repeat(['some "quoted" text', 'more "quoted" text'], 3))
+   1normal g.i"
+   call assert_equal('some "XXX" text', getline(1))
+   3,4normal .
+   call assert_equal('some "XXX" text', getline(3))
+   call assert_equal('more "XXX" text', getline(4))
+   call Apply()
+   call assert_equal('some "XXX" text', getline(5))
+   call assert_equal('more "XXX" text', getline(6))
+   bwipe!
+ 
+   nunmap g.
+   delfunc Operator
+   delfunc Apply
+ endfunc
*** ../vim-8.0.0547/src/version.c	2017-04-07 16:17:35.585077280 +0200
--- src/version.c	2017-04-07 19:08:46.534123562 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     548,
  /**/

-- 
The greatest lies of all time:
  (1) The check is in the mail.
  (2) We have a really challenging assignment for you.
  (3) I love you.
  (4) All bugs have been fixed.
  (5) This won't hurt a bit.
  (6) Honey, I just need to debug this program and be home in 5 minutes.
  (7) I have just sent you an e-mail about that.
  (8) Of course I'll respect you in the morning.
  (9) I'm from the government, and I'm here to help you.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0549
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0549
Problem:    No test for the 8g8 command.
Solution:   Add a test. (Dominique Pelle, closes #1615)
Files:      src/testdir/test_normal.vim


*** ../vim-8.0.0548/src/testdir/test_normal.vim	2017-03-29 19:48:07.499210857 +0200
--- src/testdir/test_normal.vim	2017-04-07 20:06:45.348900975 +0200
***************
*** 844,850 ****
    norm! j
    call assert_equal('52', getline('.'))
  
!   " zA on a opened fold when foldenale is not set
    50
    set nofoldenable
    norm! zA
--- 844,850 ----
    norm! j
    call assert_equal('52', getline('.'))
  
!   " zA on a opened fold when foldenable is not set
    50
    set nofoldenable
    norm! zA
***************
*** 906,912 ****
    norm! j
    call assert_equal('55', getline('.'))
  
!   " 2) do not close fold under curser
    51
    set nofoldenable
    norm! zx
--- 906,912 ----
    norm! j
    call assert_equal('55', getline('.'))
  
!   " 2) do not close fold under cursor
    51
    set nofoldenable
    norm! zx
***************
*** 1772,1789 ****
    if !has("multi_byte")
      return
    endif
    " Test for g8
    new
!   call append(0, 'abcdefghijklmnopqrstuvwxyz')
!   let a=execute(':norm! 1gg$g8')
!   call assert_equal('c3 b6 ', a[1:])
  
-   " Test for gp gP
-   call append(1, range(1,10))
    " clean up
    bw!
  endfunc
  
  fun! Test_normal35_g_cmd4()
    " Test for g<
    " Cannot capture its output,
--- 1772,1831 ----
    if !has("multi_byte")
      return
    endif
+ 
    " Test for g8
    new
!   let a=execute(':norm! 1G0g8')
!   call assert_equal("\nNUL", a)
! 
!   call setline(1, 'abcdefghijklmnopqrstuvwxyz')
!   let a=execute(':norm! 1G$g8')
!   call assert_equal("\nc3 b6 ", a)
! 
!   call setline(1, "a\u0302")
!   let a=execute(':norm! 1G0g8')
!   call assert_equal("\n61 + cc 82 ", a)
  
    " clean up
    bw!
  endfunc
  
+ func Test_normal_8g8()
+   if !has("multi_byte")
+     return
+   endif
+   new
+ 
+   " Test 8g8 which finds invalid utf8 at or after the cursor.
+ 
+   " With invalid byte.
+   call setline(1, "___\xff___")
+   norm! 1G08g8g
+   call assert_equal([0, 1, 4, 0, 1], getcurpos())
+ 
+   " With invalid byte before the cursor.
+   call setline(1, "___\xff___")
+   norm! 1G$h8g8g
+   call assert_equal([0, 1, 6, 0, 9], getcurpos())
+ 
+   " With truncated sequence.
+   call setline(1, "___\xE2\x82___")
+   norm! 1G08g8g
+   call assert_equal([0, 1, 4, 0, 1], getcurpos())
+ 
+   " With overlong sequence.
+   call setline(1, "___\xF0\x82\x82\xAC___")
+   norm! 1G08g8g
+   call assert_equal([0, 1, 4, 0, 1], getcurpos())
+ 
+   " With valid utf8.
+   call setline(1, "caf")
+   norm! 1G08g8
+   call assert_equal([0, 1, 1, 0, 1], getcurpos())
+ 
+   bw!
+ endfunc
+ 
  fun! Test_normal35_g_cmd4()
    " Test for g<
    " Cannot capture its output,
*** ../vim-8.0.0548/src/version.c	2017-04-07 19:50:08.695049295 +0200
--- src/version.c	2017-04-07 20:06:11.765109021 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     549,
  /**/

-- 
   They now pass three KNIGHTS impaled to a tree.  With their feet off the
   ground,  with one lance through the lot of them, they are skewered up
   like a barbecue.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0550
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0550
Problem:    Some etags format tags file use 0x01, breaking the parsing.
Solution:   Use 0x02 for TAG_SEP. (James McCoy, closes #1614)
Files:      src/tag.c, src/testdir/test_taglist.vim


*** ../vim-8.0.0549/src/tag.c	2017-03-25 15:03:41.372056986 +0100
--- src/tag.c	2017-04-07 20:28:15.608892372 +0200
***************
*** 2355,2372 ****
  		}
  		else
  		{
! #define TAG_SEP 0x01
  		    size_t tag_fname_len = STRLEN(tag_fname);
  #ifdef FEAT_EMACS_TAGS
  		    size_t ebuf_len = 0;
  #endif
  
  		    /* Save the tag in a buffer.
! 		     * Use 0x01 to separate fields (Can't use NUL, because the
! 		     * hash key is terminated by NUL).
! 		     * Emacs tag: <mtt><tag_fname><0x01><ebuf><0x01><lbuf><NUL>
! 		     * other tag: <mtt><tag_fname><0x01><0x01><lbuf><NUL>
! 		     * without Emacs tags: <mtt><tag_fname><0x01><lbuf><NUL>
  		     * Here <mtt> is the "mtt" value plus 1 to avoid NUL.
  		     */
  		    len = (int)tag_fname_len + (int)STRLEN(lbuf) + 3;
--- 2355,2373 ----
  		}
  		else
  		{
! #define TAG_SEP 0x02
  		    size_t tag_fname_len = STRLEN(tag_fname);
  #ifdef FEAT_EMACS_TAGS
  		    size_t ebuf_len = 0;
  #endif
  
  		    /* Save the tag in a buffer.
! 		     * Use 0x02 to separate fields (Can't use NUL because the
! 		     * hash key is terminated by NUL, or Ctrl_A because that is
! 		     * part of some Emacs tag files -- see parse_tag_line).
! 		     * Emacs tag: <mtt><tag_fname><0x02><ebuf><0x02><lbuf><NUL>
! 		     * other tag: <mtt><tag_fname><0x02><0x02><lbuf><NUL>
! 		     * without Emacs tags: <mtt><tag_fname><0x02><lbuf><NUL>
  		     * Here <mtt> is the "mtt" value plus 1 to avoid NUL.
  		     */
  		    len = (int)tag_fname_len + (int)STRLEN(lbuf) + 3;
*** ../vim-8.0.0549/src/testdir/test_taglist.vim	2017-03-21 17:08:46.678923883 +0100
--- src/testdir/test_taglist.vim	2017-04-07 20:27:54.297024595 +0200
***************
*** 19,21 ****
--- 19,58 ----
    bwipe
  endfunc
  
+ func Test_taglist_native_etags()
+   if !has('emacs_tags')
+     return
+   endif
+   call writefile([
+ 	\ "\x0c",
+ 	\ "src/os_unix.c,13491",
+ 	\ "set_signals(\x7f1335,32699",
+ 	\ "reset_signals(\x7f1407,34136",
+ 	\ ], 'Xtags')
+ 
+   set tags=Xtags
+ 
+   call assert_equal([['set_signals', '1335,32699'], ['reset_signals', '1407,34136']],
+ 	\ map(taglist('set_signals'), {i, v -> [v.name, v.cmd]}))
+ 
+   call delete('Xtags')
+ endfunc
+ 
+ func Test_taglist_ctags_etags()
+   if !has('emacs_tags')
+     return
+   endif
+   call writefile([
+ 	\ "\x0c",
+ 	\ "src/os_unix.c,13491",
+ 	\ "set_signals(void)\x7fset_signals\x011335,32699",
+ 	\ "reset_signals(void)\x7freset_signals\x011407,34136",
+ 	\ ], 'Xtags')
+ 
+   set tags=Xtags
+ 
+   call assert_equal([['set_signals', '1335,32699'], ['reset_signals', '1407,34136']],
+ 	\ map(taglist('set_signals'), {i, v -> [v.name, v.cmd]}))
+ 
+   call delete('Xtags')
+ endfunc
*** ../vim-8.0.0549/src/version.c	2017-04-07 20:09:47.311773995 +0200
--- src/version.c	2017-04-07 20:29:30.188429723 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     550,
  /**/

-- 
FIRST HEAD:  Oh! quick! get the sword out I want to cut his head off.
THIRD HEAD:  Oh, cut your own head off.
SECOND HEAD: Yes - do us all a favour.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0551
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0551
Problem:    The typeahead buffer is reallocated too often.
Solution:   Re-use the existing buffer if possible.
Files:      src/getchar.c


*** ../vim-8.0.0550/src/getchar.c	2017-04-07 19:50:08.687049344 +0200
--- src/getchar.c	2017-04-08 18:33:14.982907218 +0200
***************
*** 920,926 ****
  	typebuf.tb_noremap = noremapbuf_init;
  	typebuf.tb_buflen = TYPELEN_INIT;
  	typebuf.tb_len = 0;
! 	typebuf.tb_off = 0;
  	typebuf.tb_change_cnt = 1;
      }
  }
--- 920,926 ----
  	typebuf.tb_noremap = noremapbuf_init;
  	typebuf.tb_buflen = TYPELEN_INIT;
  	typebuf.tb_len = 0;
! 	typebuf.tb_off = MAXMAPLEN + 4;
  	typebuf.tb_change_cnt = 1;
      }
  }
***************
*** 974,984 ****
  	typebuf.tb_off -= addlen;
  	mch_memmove(typebuf.tb_buf + typebuf.tb_off, str, (size_t)addlen);
      }
      else
      {
  	/*
  	 * Need to allocate a new buffer.
! 	 * In typebuf.tb_buf there must always be room for 3 * MAXMAPLEN + 4
  	 * characters.  We add some extra room to avoid having to allocate too
  	 * often.
  	 */
--- 974,994 ----
  	typebuf.tb_off -= addlen;
  	mch_memmove(typebuf.tb_buf + typebuf.tb_off, str, (size_t)addlen);
      }
+     else if (typebuf.tb_len == 0 && typebuf.tb_buflen
+ 					       >= addlen + 3 * (MAXMAPLEN + 4))
+     {
+ 	/*
+ 	 * Buffer is empty and string fits in the existing buffer.
+ 	 * Leave some space before and after, if possible.
+ 	 */
+ 	typebuf.tb_off = (typebuf.tb_buflen - addlen - 3 * (MAXMAPLEN + 4)) / 2;
+ 	mch_memmove(typebuf.tb_buf + typebuf.tb_off, str, (size_t)addlen);
+     }
      else
      {
  	/*
  	 * Need to allocate a new buffer.
! 	 * In typebuf.tb_buf there must always be room for 3 * (MAXMAPLEN + 4)
  	 * characters.  We add some extra room to avoid having to allocate too
  	 * often.
  	 */
***************
*** 1291,1297 ****
  	return FAIL;
      }
      typebuf.tb_buflen = TYPELEN_INIT;
!     typebuf.tb_off = 0;
      typebuf.tb_len = 0;
      typebuf.tb_maplen = 0;
      typebuf.tb_silent = 0;
--- 1301,1307 ----
  	return FAIL;
      }
      typebuf.tb_buflen = TYPELEN_INIT;
!     typebuf.tb_off = MAXMAPLEN + 4;  /* can insert without realloc */
      typebuf.tb_len = 0;
      typebuf.tb_maplen = 0;
      typebuf.tb_silent = 0;
*** ../vim-8.0.0550/src/version.c	2017-04-07 20:30:24.196092735 +0200
--- src/version.c	2017-04-08 18:40:08.468310983 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     551,
  /**/

-- 
Facepalm statement #7: "Last week I almost got pregnant!"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0552
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0552
Problem:    Toupper and tolower don't work properly for Turkish when 'casemap'
            is empty. (Bjorn Linse)
Solution:   Check the 'casemap' options when deciding how to upper/lower case.
Files:      src/charset.c, src/testdir/test_normal.vim


*** ../vim-8.0.0551/src/charset.c	2017-03-12 21:31:54.289925047 +0100
--- src/charset.c	2017-04-08 19:00:06.124834223 +0200
***************
*** 960,966 ****
  }
  
  /*
!  * return TRUE if 'c' is a printable character
   * Assume characters above 0x100 are printable (multi-byte), except for
   * Unicode.
   */
--- 960,966 ----
  }
  
  /*
!  * Return TRUE if 'c' is a printable character.
   * Assume characters above 0x100 are printable (multi-byte), except for
   * Unicode.
   */
***************
*** 1717,1723 ****
  {
      if (c <= '@')
  	return c;
!     if (c >= 0x80)
      {
  	if (enc_utf8)
  	    return utf_toupper(c);
--- 1717,1723 ----
  {
      if (c <= '@')
  	return c;
!     if (c >= 0x80 || !(cmp_flags & CMP_KEEPASCII))
      {
  	if (enc_utf8)
  	    return utf_toupper(c);
***************
*** 1741,1747 ****
  {
      if (c <= '@')
  	return c;
!     if (c >= 0x80)
      {
  	if (enc_utf8)
  	    return utf_tolower(c);
--- 1741,1747 ----
  {
      if (c <= '@')
  	return c;
!     if (c >= 0x80 || !(cmp_flags & CMP_KEEPASCII))
      {
  	if (enc_utf8)
  	    return utf_tolower(c);
*** ../vim-8.0.0551/src/testdir/test_normal.vim	2017-04-07 20:09:47.311773995 +0200
--- src/testdir/test_normal.vim	2017-04-08 19:01:20.056373081 +0200
***************
*** 1603,1608 ****
--- 1603,1628 ----
    norm! V~
    call assert_equal('THIS IS A simple test: ss', getline('.'))
  
+   " Turkish ASCII turns to multi-byte.
+   try
+     lang tr_TR.UTF-8
+     set casemap=
+     call setline(1, 'iI')
+     1normal gUU
+     call assert_equal("\u0130I", getline(1))
+     call assert_equal("\u0130I", toupper("iI"))
+ 
+     call setline(1, 'iI')
+     1normal guu
+     call assert_equal("i\u0131", getline(1))
+     call assert_equal("i\u0131", tolower("iI"))
+ 
+     lang en_US.UTF-8
+   catch /E197:/
+     " can't use Turkish locale
+     throw 'Skipped: Turkish locale not available'
+   endtry
+ 
    " clean up
    bw!
  endfunc
*** ../vim-8.0.0551/src/version.c	2017-04-08 18:41:07.339941299 +0200
--- src/version.c	2017-04-08 19:10:57.584769418 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     552,
  /**/

-- 
Facepalm reply #9: "Speed up, you can drive 80 here" "Why, the cars behind us
are also driving 60"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0553
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0553 (after 8.0.0552)
Problem:    Toupper/tolower test with Turkish locale fails on Mac.
Solution:   Skip the test on Mac.
Files:      src/testdir/test_normal.vim


*** ../vim-8.0.0552/src/testdir/test_normal.vim	2017-04-08 19:12:00.612378409 +0200
--- src/testdir/test_normal.vim	2017-04-08 19:37:19.507001542 +0200
***************
*** 1603,1627 ****
    norm! V~
    call assert_equal('THIS IS A simple test: ss', getline('.'))
  
!   " Turkish ASCII turns to multi-byte.
!   try
!     lang tr_TR.UTF-8
!     set casemap=
!     call setline(1, 'iI')
!     1normal gUU
!     call assert_equal("\u0130I", getline(1))
!     call assert_equal("\u0130I", toupper("iI"))
  
!     call setline(1, 'iI')
!     1normal guu
!     call assert_equal("i\u0131", getline(1))
!     call assert_equal("i\u0131", tolower("iI"))
  
!     lang en_US.UTF-8
!   catch /E197:/
!     " can't use Turkish locale
!     throw 'Skipped: Turkish locale not available'
!   endtry
  
    " clean up
    bw!
--- 1603,1630 ----
    norm! V~
    call assert_equal('THIS IS A simple test: ss', getline('.'))
  
!   " Turkish ASCII turns to multi-byte.  On Mac the Turkish locale is available
!   " but toupper()/tolower() don't do the right thing.
!   if !has('mac')
!     try
!       lang tr_TR.UTF-8
!       set casemap=
!       call setline(1, 'iI')
!       1normal gUU
!       call assert_equal("\u0130I", getline(1))
!       call assert_equal("\u0130I", toupper("iI"))
  
!       call setline(1, 'iI')
!       1normal guu
!       call assert_equal("i\u0131", getline(1))
!       call assert_equal("i\u0131", tolower("iI"))
  
!       lang en_US.UTF-8
!     catch /E197:/
!       " can't use Turkish locale
!       throw 'Skipped: Turkish locale not available'
!     endtry
!   endif
  
    " clean up
    bw!
*** ../vim-8.0.0552/src/version.c	2017-04-08 19:12:00.612378409 +0200
--- src/version.c	2017-04-08 19:39:03.446358103 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     553,
  /**/

-- 
Facepalm statement #9: "Did you see, there is now even a hobbit book"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0554
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0554 (after 8.0.0552)
Problem:    Toupper and tolower don't work properly for Turkish when 'casemap'
            contains "keepascii". (Bjorn Linse)
Solution:   When 'casemap' contains "keepascii" use ASCII toupper/tolower.
Files:      src/charset.c, src/testdir/test_normal.vim


*** ../vim-8.0.0553/src/charset.c	2017-04-08 19:12:00.612378409 +0200
--- src/charset.c	2017-04-09 13:30:46.557743503 +0200
***************
*** 1733,1738 ****
--- 1733,1740 ----
  	if (enc_latin1like)
  	    return latin1upper[c];
      }
+     if (c < 0x80 && (cmp_flags & CMP_KEEPASCII))
+ 	return TOUPPER_ASC(c);
      return TOUPPER_LOC(c);
  }
  
***************
*** 1757,1762 ****
--- 1759,1766 ----
  	if (enc_latin1like)
  	    return latin1lower[c];
      }
+     if (c < 0x80 && (cmp_flags & CMP_KEEPASCII))
+ 	return TOLOWER_ASC(c);
      return TOLOWER_LOC(c);
  }
  #endif
*** ../vim-8.0.0553/src/testdir/test_normal.vim	2017-04-08 19:39:38.994137997 +0200
--- src/testdir/test_normal.vim	2017-04-09 13:19:10.254047111 +0200
***************
*** 1619,1624 ****
--- 1619,1635 ----
        call assert_equal("i\u0131", getline(1))
        call assert_equal("i\u0131", tolower("iI"))
  
+       set casemap&
+       call setline(1, 'iI')
+       1normal gUU
+       call assert_equal("II", getline(1))
+       call assert_equal("II", toupper("iI"))
+ 
+       call setline(1, 'iI')
+       1normal guu
+       call assert_equal("ii", getline(1))
+       call assert_equal("ii", tolower("iI"))
+ 
        lang en_US.UTF-8
      catch /E197:/
        " can't use Turkish locale
*** ../vim-8.0.0553/src/version.c	2017-04-08 19:39:38.994137997 +0200
--- src/version.c	2017-04-09 13:35:10.756105284 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     554,
  /**/

-- 
DINGO:   You must spank her well and after you have spanked her you
         may deal with her as you like and then ... spank me.
AMAZING: And spank me!
STUNNER: And me.
LOVELY:  And me.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0555
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0555 (after 8.0.0552)
Problem:    Toupper/tolower test fails on OSX without Darwin.
Solution:   Skip that part of the test also for OSX. (Kazunobu Kuriyama)
Files:      src/testdir/test_normal.vim


*** ../vim-8.0.0554/src/testdir/test_normal.vim	2017-04-09 13:41:54.789598722 +0200
--- src/testdir/test_normal.vim	2017-04-09 14:52:17.947216552 +0200
***************
*** 1605,1611 ****
  
    " Turkish ASCII turns to multi-byte.  On Mac the Turkish locale is available
    " but toupper()/tolower() don't do the right thing.
!   if !has('mac')
      try
        lang tr_TR.UTF-8
        set casemap=
--- 1605,1611 ----
  
    " Turkish ASCII turns to multi-byte.  On Mac the Turkish locale is available
    " but toupper()/tolower() don't do the right thing.
!   if !has('mac') && !has('osx')
      try
        lang tr_TR.UTF-8
        set casemap=
*** ../vim-8.0.0554/src/version.c	2017-04-09 13:41:54.789598722 +0200
--- src/version.c	2017-04-09 14:54:00.510574445 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     555,
  /**/

-- 
            ### Hiroshima 45, Chernobyl 86, Windows 95 ###

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0556
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0556
Problem:    Getting the window position fails if both the GUI and term
            code is built in.
Solution:   Return after getting the GUI window position. (Kazunobu Kuriyama)
Files:      src/evalfunc.c


*** ../vim-8.0.0555/src/evalfunc.c	2017-04-04 22:41:04.728342901 +0200
--- src/evalfunc.c	2017-04-09 15:00:17.448215667 +0200
***************
*** 5302,5307 ****
--- 5302,5308 ----
  
  	if (gui_mch_get_winpos(&x, &y) == OK)
  	    rettv->vval.v_number = x;
+ 	return;
      }
  #endif
  #if defined(HAVE_TGETENT) && defined(FEAT_TERMRESPONSE)
***************
*** 5328,5333 ****
--- 5329,5335 ----
  
  	if (gui_mch_get_winpos(&x, &y) == OK)
  	    rettv->vval.v_number = y;
+ 	return;
      }
  #endif
  #if defined(HAVE_TGETENT) && defined(FEAT_TERMRESPONSE)
***************
*** 7715,7720 ****
--- 7717,7723 ----
  /*
   * Create the directory in which "dir" is located, and higher levels when
   * needed.
+  * Return OK or FAIL.
   */
      static int
  mkdir_recurse(char_u *dir, int prot)
*** ../vim-8.0.0555/src/version.c	2017-04-09 14:58:11.653002677 +0200
--- src/version.c	2017-04-09 15:02:13.355490679 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     556,
  /**/

-- 
You cannot propel yourself forward by patting yourself on the back.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0557
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0557
Problem:    GTK: using static gravities is not useful.
Solution:   Remove setting static gravities. (Kazunobu Kuriyama)
Files:      src/gui_gtk_f.c


*** ../vim-8.0.0556/src/gui_gtk_f.c	2017-03-29 18:07:36.574886122 +0200
--- src/gui_gtk_f.c	2017-04-09 15:23:59.515302213 +0200
***************
*** 92,102 ****
  				    gboolean force_allocate);
  static void gtk_form_position_children(GtkForm *form);
  
- #if !GTK_CHECK_VERSION(3,16,0)
- static void gtk_form_set_static_gravity(GdkWindow *window,
- 					gboolean use_static);
- #endif
- 
  static void gtk_form_send_configure(GtkForm *form);
  
  static void gtk_form_child_map(GtkWidget *widget, gpointer user_data);
--- 92,97 ----
***************
*** 370,379 ****
  #endif
      gdk_window_set_user_data(form->bin_window, widget);
  
- #if !GTK_CHECK_VERSION(3,16,0)
-     gtk_form_set_static_gravity(form->bin_window, TRUE);
- #endif
- 
  #if GTK_CHECK_VERSION(3,0,0)
      {
  	GtkStyleContext * const sctx = gtk_widget_get_style_context(widget);
--- 365,370 ----
***************
*** 845,853 ****
  #endif
  
  	gtk_widget_set_parent_window(child->widget, child->window);
- #if !GTK_CHECK_VERSION(3,16,0)
- 	gtk_form_set_static_gravity(child->window, TRUE);
- #endif
  	/*
  	 * Install signal handlers to map/unmap child->window
  	 * alongside with the actual widget.
--- 836,841 ----
***************
*** 879,893 ****
  {
      gtk_form_attach_child_window(form, child);
      gtk_widget_realize(child->widget);
- 
- #if !GTK_CHECK_VERSION(3,16,0)
-     if (child->window == NULL) /* might be already set, see above */
- # if GTK_CHECK_VERSION(3,0,0)
- 	gtk_form_set_static_gravity(gtk_widget_get_window(child->widget), TRUE);
- # else
- 	gtk_form_set_static_gravity(child->widget->window, TRUE);
- # endif
- #endif
  }
  
      static void
--- 867,872 ----
***************
*** 999,1014 ****
  	gtk_form_position_child(form, tmp_list->data, FALSE);
  }
  
- #if !GTK_CHECK_VERSION(3,16,0)
-     static void
- gtk_form_set_static_gravity(GdkWindow *window, gboolean use_static)
- {
-     /* We don't check if static gravity is actually supported, because it
-      * results in an annoying assertion error message. */
-     gdk_window_set_static_gravities(window, use_static);
- }
- #endif /* !GTK_CHECK_VERSION(3,16,0) */
- 
      void
  gtk_form_move_resize(GtkForm *form, GtkWidget *widget,
  		     gint x, gint y, gint w, gint h)
--- 978,983 ----
*** ../vim-8.0.0556/src/version.c	2017-04-09 15:03:09.807137630 +0200
--- src/version.c	2017-04-09 15:25:54.778579995 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     557,
  /**/

-- 
The psychic said, "God bless you."  I said, "I didn't sneeze."  She
looked deep into my eyes and said, "You will, eventually."  And, damn
if she wasn't right.  Two days later, I sneezed.  --Ellen Degeneres

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0558
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0558
Problem:    The :ownsyntax command is not tested.
Solution:   Add a test. (Dominique Pelle, closes #1622)
Files:      src/testdir/test_syntax.vim


*** ../vim-8.0.0557/src/testdir/test_syntax.vim	2017-03-26 13:50:02.536929400 +0200
--- src/testdir/test_syntax.vim	2017-04-09 15:39:30.041476398 +0200
***************
*** 349,351 ****
--- 349,380 ----
    hi clear Nop
    hi clear @Wrong
  endfunc
+ 
+ func Test_ownsyntax()
+   new Xfoo
+   call setline(1, '#define FOO')
+   syntax on
+   set filetype=c
+   ownsyntax perl
+   call assert_equal('perlComment', synIDattr(synID(line('.'), col('.'), 1), 'name'))
+   call assert_equal('c',    b:current_syntax)
+   call assert_equal('perl', w:current_syntax)
+ 
+   " A new split window should have the original syntax.
+   split
+   call assert_equal('cDefine', synIDattr(synID(line('.'), col('.'), 1), 'name'))
+   call assert_equal('c', b:current_syntax)
+   call assert_equal(0, exists('w:current_syntax'))
+ 
+   wincmd x
+   call assert_equal('perlComment', synIDattr(synID(line("."), col("."), 1), "name"))
+ 
+   syntax off
+   set filetype&
+   %bw!
+ endfunc
+ 
+ func Test_ownsyntax_completion()
+   call feedkeys(":ownsyntax java\<C-A>\<C-B>\"\<CR>", 'tx')
+   call assert_equal('"ownsyntax java javacc javascript', @:)
+ endfunc
*** ../vim-8.0.0557/src/version.c	2017-04-09 15:27:05.798135087 +0200
--- src/version.c	2017-04-09 15:40:44.037013557 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     558,
  /**/

-- 
TALL KNIGHT OF NI: Ni!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0559
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0559
Problem:    Setting ttytype to xxx does not always fail as expected. (Marvin
            Schmidt)
Solution:   Catch both possible errors. (closes #1601)
Files:      src/testdir/test_options.vim


*** ../vim-8.0.0558/src/testdir/test_options.vim	2017-03-07 22:33:27.619323238 +0100
--- src/testdir/test_options.vim	2017-04-09 22:48:52.223191153 +0200
***************
*** 280,289 ****
      set ttytype=xterm
      call assert_equal('xterm', &ttytype)
      call assert_equal(&ttytype, &term)
!     " FIXME: "set ttytype=" gives E522 instead of E529
!     " in travis on some builds. Why? Commented out this test for now.
!     " call assert_fails('set ttytype=', 'E529:')
!     call assert_fails('set ttytype=xxx', 'E522:')
      set ttytype&
      call assert_equal(&ttytype, &term)
    endif
--- 280,301 ----
      set ttytype=xterm
      call assert_equal('xterm', &ttytype)
      call assert_equal(&ttytype, &term)
!     " "set ttytype=" gives E522 instead of E529
!     " in travis on some builds. Why?  Catch both for now
!     try
!       set ttytype=
!       call assert_report('set ttype= did not fail')
!     catch /E529\|E522/
!     endtry
! 
!     " Some systems accept any terminal name and return dumb settings,
!     " check for failure of finding the entry and for missing 'cm' entry.
!     try
!       set ttytype=xxx
!       call assert_report('set ttype=xxx did not fail')
!     catch /E522\|E437/
!     endtry
! 
      set ttytype&
      call assert_equal(&ttytype, &term)
    endif
*** ../vim-8.0.0558/src/version.c	2017-04-09 15:41:25.556753876 +0200
--- src/version.c	2017-04-09 22:50:20.510649254 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     559,
  /**/

-- 
ARTHUR:      Who are you?
TALL KNIGHT: We are the Knights Who Say "Ni"!
BEDEVERE:    No!  Not the Knights Who Say "Ni"!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0560
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0560
Problem:    :windo allows for ! but it's not supported.
Solution:   Disallow passing !. (Hirohito Higashi)
Files:      src/ex_cmds.h


*** ../vim-8.0.0559/src/ex_cmds.h	2017-04-11 12:38:37.415500103 +0200
--- src/ex_cmds.h	2017-04-11 12:36:49.860183241 +0200
***************
*** 1623,1629 ****
  			NEEDARG|WORD1|RANGE|NOTADR,
  			ADDR_WINDOWS),
  EX(CMD_windo,		"windo",	ex_listdo,
! 			BANG|NEEDARG|EXTRA|NOTRLCOM|RANGE|NOTADR|DFLALL,
  			ADDR_WINDOWS),
  EX(CMD_winpos,		"winpos",	ex_winpos,
  			EXTRA|TRLBAR|CMDWIN,
--- 1623,1629 ----
  			NEEDARG|WORD1|RANGE|NOTADR,
  			ADDR_WINDOWS),
  EX(CMD_windo,		"windo",	ex_listdo,
! 			NEEDARG|EXTRA|NOTRLCOM|RANGE|NOTADR|DFLALL,
  			ADDR_WINDOWS),
  EX(CMD_winpos,		"winpos",	ex_winpos,
  			EXTRA|TRLBAR|CMDWIN,
*** ../vim-8.0.0559/src/version.c	2017-04-11 12:37:52.987782292 +0200
--- src/version.c	2017-04-11 12:38:05.287704168 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     560,
  /**/

-- 
I'd like to meet the man who invented sex and see what he's working on now.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0561
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0561
Problem:    Undefined behavior when using backslash after empty line.
Solution:   Check for an empty line. (Dominique Pelle, closes #1631)
Files:      src/misc2.c, src/testdir/test_vimscript.vim


*** ../vim-8.0.0560/src/misc2.c	2017-03-29 17:30:23.160136913 +0200
--- src/misc2.c	2017-04-10 22:19:28.426376399 +0200
***************
*** 2129,2135 ****
  {
      int    len;
  
!     if (s == NULL)
  	return;
      len = (int)STRLEN(s);
      if (ga_grow(gap, len) == OK)
--- 2129,2135 ----
  {
      int    len;
  
!     if (s == NULL || *s == NUL)
  	return;
      len = (int)STRLEN(s);
      if (ga_grow(gap, len) == OK)
*** ../vim-8.0.0560/src/testdir/test_vimscript.vim	2017-03-18 20:18:42.067950195 +0100
--- src/testdir/test_vimscript.vim	2017-04-10 22:19:28.426376399 +0200
***************
*** 1310,1315 ****
--- 1310,1326 ----
  endfunc
  
  "-------------------------------------------------------------------------------
+ " Test 96:  line continuation						    {{{1
+ "
+ "           Undefined behavior was detected by ubsan with line continuation
+ "           after an empty line.
+ "-------------------------------------------------------------------------------
+ func Test_script_emty_line_continuation()
+ 
+     \
+ endfunc
+ 
+ "-------------------------------------------------------------------------------
  " Modelines								    {{{1
  " vim: ts=8 sw=4 tw=80 fdm=marker
  " vim: fdt=substitute(substitute(foldtext(),\ '\\%(^+--\\)\\@<=\\(\\s*\\)\\(.\\{-}\\)\:\ \\%(\"\ \\)\\=\\(Test\ \\d*\\)\:\\s*',\ '\\3\ (\\2)\:\ \\1',\ \"\"),\ '\\(Test\\s*\\)\\(\\d\\)\\D\\@=',\ '\\1\ \\2',\ "")
*** ../vim-8.0.0560/src/version.c	2017-04-10 21:46:33.442970106 +0200
--- src/version.c	2017-04-10 22:20:59.681796145 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     561,
  /**/

-- 
CONCORDE: Message for you, sir.
   He falls forward revealing the arrow with the note.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0562
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0562
Problem:    Not enough test coverage for syntax commands.
Solution:   Add a few more tests. (Dominique Pelle, closes #1624)
Files:      src/testdir/test_cmdline.vim, src/testdir/test_syntax.vim


*** ../vim-8.0.0561/src/testdir/test_cmdline.vim	2017-04-07 16:17:35.585077280 +0200
--- src/testdir/test_cmdline.vim	2017-04-10 22:39:42.574587964 +0200
***************
*** 65,70 ****
--- 65,74 ----
    hi Aardig ctermfg=green
    call feedkeys(":hi \<Tab>\<Home>\"\<CR>", 'xt')
    call assert_equal('"hi Aardig', getreg(':'))
+   call feedkeys(":hi default \<Tab>\<Home>\"\<CR>", 'xt')
+   call assert_equal('"hi default Aardig', getreg(':'))
+   call feedkeys(":hi clear Aa\<Tab>\<Home>\"\<CR>", 'xt')
+   call assert_equal('"hi clear Aardig', getreg(':'))
    call feedkeys(":hi li\<S-Tab>\<Home>\"\<CR>", 'xt')
    call assert_equal('"hi link', getreg(':'))
    call feedkeys(":hi d\<S-Tab>\<Home>\"\<CR>", 'xt')
*** ../vim-8.0.0561/src/testdir/test_syntax.vim	2017-04-09 15:41:25.556753876 +0200
--- src/testdir/test_syntax.vim	2017-04-10 22:39:42.574587964 +0200
***************
*** 304,315 ****
    syn clear
  endfunc
  
! func Test_invalid_arg()
    call assert_fails('syntax case asdf', 'E390:')
    if has('conceal')
      call assert_fails('syntax conceal asdf', 'E390:')
    endif
    call assert_fails('syntax spell asdf', 'E390:')
  endfunc
  
  func Test_syn_sync()
--- 304,321 ----
    syn clear
  endfunc
  
! func Test_syntax_invalid_arg()
    call assert_fails('syntax case asdf', 'E390:')
    if has('conceal')
      call assert_fails('syntax conceal asdf', 'E390:')
    endif
    call assert_fails('syntax spell asdf', 'E390:')
+   call assert_fails('syntax clear @ABCD', 'E391:')
+   call assert_fails('syntax include @Xxx', 'E397:')
+   call assert_fails('syntax region X start="{"', 'E399:')
+   call assert_fails('syntax sync x', 'E404:')
+   call assert_fails('syntax keyword Abc a[', 'E789:')
+   call assert_fails('syntax keyword Abc a[bc]d', 'E890:')
  endfunc
  
  func Test_syn_sync()
***************
*** 378,380 ****
--- 384,403 ----
    call feedkeys(":ownsyntax java\<C-A>\<C-B>\"\<CR>", 'tx')
    call assert_equal('"ownsyntax java javacc javascript', @:)
  endfunc
+ 
+ func Test_highlight_invalid_arg()
+   if has('gui_running')
+     call assert_fails('hi XXX guifg=xxx', 'E254:')
+   endif
+   call assert_fails('hi DoesNotExist', 'E411:')
+   call assert_fails('hi link', 'E412:')
+   call assert_fails('hi link a', 'E412:')
+   call assert_fails('hi link a b c', 'E413:')
+   call assert_fails('hi XXX =', 'E415:')
+   call assert_fails('hi XXX cterm', 'E416:')
+   call assert_fails('hi XXX cterm=', 'E417:')
+   call assert_fails('hi XXX cterm=DoesNotExist', 'E418:')
+   call assert_fails('hi XXX ctermfg=DoesNotExist', 'E421:')
+   call assert_fails('hi XXX xxx=White', 'E423:')
+ endfunc
+ 
*** ../vim-8.0.0561/src/version.c	2017-04-10 22:22:38.545160122 +0200
--- src/version.c	2017-04-10 22:40:56.342107427 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     562,
  /**/

-- 
Even got a Datapoint 3600(?) with a DD50 connector instead of the
usual DB25...  what a nightmare trying to figure out the pinout
for *that* with no spex...

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0563
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0563
Problem:    Crash when getting the window position in tmux. (Marvin Schmidt)
Solution:   Add t_GP to the list of terminal options. (closes #1627)
Files:      src/option.c


*** ../vim-8.0.0562/src/option.c	2017-04-07 15:42:20.158333009 +0200
--- src/option.c	2017-04-11 22:33:23.609901609 +0200
***************
*** 3174,3179 ****
--- 3174,3180 ----
      p_term("t_vi", T_VI)
      p_term("t_vs", T_VS)
      p_term("t_WP", T_CWP)
+     p_term("t_GP", T_CGP)
      p_term("t_WS", T_CWS)
      p_term("t_xn", T_XN)
      p_term("t_xs", T_XS)
*** ../vim-8.0.0562/src/version.c	2017-04-10 22:45:26.140352638 +0200
--- src/version.c	2017-04-11 22:34:20.209510497 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     563,
  /**/

-- 
Not too long ago, a program was something you watched on TV...

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0564
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0564
Problem:    Cannot detect Bazel BUILD files on some systems.
Solution:   Check for BUILD after script checks. (Issue #1340)
Files:      runtime/filetype.vim


*** ../vim-8.0.0563/runtime/filetype.vim	2016-08-26 19:25:07.000000000 +0200
--- runtime/filetype.vim	2017-04-15 14:14:22.922164313 +0200
***************
*** 309,315 ****
  au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
  
  " Bazel (http://bazel.io)
! autocmd BufRead,BufNewFile *.bzl,BUILD,WORKSPACE setfiletype bzl
  
  " C or lpc
  au BufNewFile,BufRead *.c			call s:FTlpc()
--- 310,320 ----
  au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
  
  " Bazel (http://bazel.io)
! autocmd BufRead,BufNewFile *.bzl,WORKSPACE 	setf bzl
! if has("fname_case")
!   " There is another check for BUILD further below.
!   autocmd BufRead,BufNewFile BUILD		setf bzl
! endif
  
  " C or lpc
  au BufNewFile,BufRead *.c			call s:FTlpc()
***************
*** 2576,2581 ****
--- 2603,2613 ----
  " Bazaar version control
  au BufNewFile,BufRead bzr_log.*			setf bzr
  
+ " Bazel build file
+ if !has("fname_case")
+   au BufNewFile,BufRead BUILD			setf bzl
+ endif
+ 
  " BIND zone
  au BufNewFile,BufRead */named/db.*,*/bind/db.*	call s:StarSetf('bindzone')
  
*** ../vim-8.0.0563/src/version.c	2017-04-11 22:44:00.297521127 +0200
--- src/version.c	2017-04-15 14:24:09.158467724 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     564,
  /**/

-- 
Computers are not intelligent.  They only think they are.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0565
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0565
Problem:    Using freed memory in :caddbuf after clearing quickfix list.
            (Dominique Pelle)
Solution:   Set qf_last to NULL.
Files:      src/quickfix.c


*** ../vim-8.0.0564/src/quickfix.c	2017-04-02 15:15:44.825083189 +0200
--- src/quickfix.c	2017-04-15 15:15:01.611189631 +0200
***************
*** 2750,2755 ****
--- 2750,2756 ----
      vim_free(qi->qf_lists[idx].qf_title);
      qi->qf_lists[idx].qf_title = NULL;
      qi->qf_lists[idx].qf_index = 0;
+     qi->qf_lists[idx].qf_last = NULL;
  
      qf_clean_dir_stack(&qi->qf_dir_stack);
      qi->qf_directory = NULL;
*** ../vim-8.0.0564/src/version.c	2017-04-15 14:35:25.642199904 +0200
--- src/version.c	2017-04-15 15:19:52.549350711 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     565,
  /**/

-- 
GUARD #2:  It could be carried by an African swallow!
GUARD #1:  Oh, yeah, an African swallow maybe, but not a European swallow,
           that's my point.
GUARD #2:  Oh, yeah, I agree with that...
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0566
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0566
Problem:    Setting nocompatible for the tiny version moves the cursor.
Solution:   Use another trick to skip commands when the +eval feature is
            present. (Christian Brabandt, closes #1630)
Files:      runtime/defaults.vim


*** ../vim-8.0.0565/runtime/defaults.vim	2017-04-01 16:59:25.194170493 +0200
--- runtime/defaults.vim	2017-04-12 21:13:08.153039333 +0200
***************
*** 1,7 ****
  " The default vimrc file.
  "
  " Maintainer:	Bram Moolenaar <Bram@vim.org>
! " Last change:	2017 Apr 01
  "
  " This is loaded if no vimrc file was found.
  " Except when Vim is run with "-u NONE" or "-C".
--- 1,7 ----
  " The default vimrc file.
  "
  " Maintainer:	Bram Moolenaar <Bram@vim.org>
! " Last change:	2017 Apr 12
  "
  " This is loaded if no vimrc file was found.
  " Except when Vim is run with "-u NONE" or "-C".
***************
*** 28,40 ****
  
  " When the +eval feature is missing, the set command above will be skipped.
  " Use a trick to reset compatible only when the +eval feature is missing.
! if 1
!   nnoremap : :"
! endif
! silent normal :set nocompatible
! if 1
!   nunmap :
! endif
  
  " Allow backspacing over everything in insert mode.
  set backspace=indent,eol,start
--- 28,36 ----
  
  " When the +eval feature is missing, the set command above will be skipped.
  " Use a trick to reset compatible only when the +eval feature is missing.
! silent! while 0
!   set nocompatible
! silent! endwhile
  
  " Allow backspacing over everything in insert mode.
  set backspace=indent,eol,start
*** ../vim-8.0.0565/src/version.c	2017-04-15 15:22:47.508245073 +0200
--- src/version.c	2017-04-15 15:36:41.326977831 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     566,
  /**/

-- 
GUARD #2:  Wait a minute -- supposing two swallows carried it together?
GUARD #1:  No, they'd have to have it on a line.
GUARD #2:  Well, simple!  They'd just use a standard creeper!
GUARD #1:  What, held under the dorsal guiding feathers?
GUARD #2:  Well, why not?
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0567
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0567
Problem:    Call for requesting color and ambiwidth is too early. (Hirohito
            Higashi)
Solution:   Move the call down to below resetting "starting".
Files:      src/main.c


*** ../vim-8.0.0566/src/main.c	2017-04-02 18:19:48.376143576 +0200
--- src/main.c	2017-04-18 18:47:16.909399297 +0200
***************
*** 666,677 ****
  
      starttermcap();	    /* start termcap if not done by wait_return() */
      TIME_MSG("start termcap");
- #if defined(FEAT_TERMRESPONSE)
- # if defined(FEAT_MBYTE)
-     may_req_ambiguous_char_width();
- # endif
-     may_req_bg_color();
- #endif
  
  #ifdef FEAT_MOUSE
      setmouse();				/* may start using the mouse */
--- 666,671 ----
***************
*** 801,806 ****
--- 795,805 ----
      /* Requesting the termresponse is postponed until here, so that a "-c q"
       * argument doesn't make it appear in the shell Vim was started from. */
      may_req_termresponse();
+ 
+ # if defined(FEAT_MBYTE)
+     may_req_ambiguous_char_width();
+ # endif
+     may_req_bg_color();
  #endif
  
      /* start in insert mode */
*** ../vim-8.0.0566/src/version.c	2017-04-15 15:37:09.646798989 +0200
--- src/version.c	2017-04-18 18:49:24.664614475 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     567,
  /**/

-- 
DEAD PERSON:  I'm getting better!
CUSTOMER:     No, you're not -- you'll be stone dead in a moment.
MORTICIAN:    Oh, I can't take him like that -- it's against regulations.
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
